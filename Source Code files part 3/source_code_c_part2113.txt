_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, nIdToolTipButton);
	}

	return 0;
}

void CMFCCaptionBar::UpdateTooltips()
{
	if (m_pToolTip->GetSafeHwnd() != NULL)
	{
		m_pToolTip->SetToolRect(this, nIdToolTipClose, m_rectClose);

		if (m_bTextIsTruncated)
		{
			m_pToolTip->SetToolRect(this, nIdToolTipText, m_rectDrawText);
		}
		else
		{
			m_pToolTip->SetToolRect(this, nIdToolTipText, CRect(0, 0, 0, 0));
		}

		if (!m_strImageToolTip.IsEmpty())
		{
			m_pToolTip->SetToolRect(this, nIdToolTipImage, m_rectImage);
		}
		else
		{
			m_pToolTip->SetToolRect(this, nIdToolTipImage, CRect(0, 0, 0, 0));
		}

		if (!m_strButtonToolTip.IsEmpty())
		{
			m_pToolTip->SetToolRect(this, nIdToolTipButton, m_rectButton);
		}
		else
		{
			m_pToolTip->SetToolRect(this, nIdToolTipButton, CRect(0, 0, 0, 0));
		}
	}
}

CSize CMFCCaptionBar::GetTextSize(CDC* pDC, const CString& strText)
{
	ASSERT_VALID(pDC);

	if (m_arTextParts.GetSize() == 1)
	{
		return pDC->GetTextExtent(strText);
	}

	CSize sizeText(0, 0);

	BOOL bIsBold = FALSE;

	for (int i = 0; i < m_arTextParts.GetSize(); i++)
	{
		if (!m_arTextParts [i].IsEmpty())
		{
			CFont* pOldFont = NULL;

			if (bIsBold)
			{
				pOldFont = pDC->SelectObject(&afxGlobalData.fontBold);
			}

			CSize sizePart = pDC->GetTextExtent(m_arTextParts [i]);

			sizeText.cx += sizePart.cx;
			sizeText.cy = max(sizeText.cy, sizePart.cy);

			if (pOldFont != NULL)
			{
				pDC->SelectObject(pOldFont);
			}
		}

		bIsBold = !bIsBold;
	}

	return sizeText;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcaptionbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxcaptionbutton.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

int CMFCCaptionButton::m_nButtonMargin = 3;
int CMFCCaptionButton::m_nButtonMarginVert = 4;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCCaptionButton::CMFCCaptionButton()
{
	m_bPushed = FALSE;
	m_bFocused = FALSE;
	m_bDroppedDown = FALSE;
	m_bHidden = FALSE;
	m_bEnabled = TRUE;
	m_nHit = HTNOWHERE;
	m_bLeftAlign = FALSE;
	m_clrForeground = (COLORREF)-1;
	m_bIsMiniFrameButton = FALSE;
}

CMFCCaptionButton::CMFCCaptionButton(UINT nHit, BOOL bLeftAlign)
{
	m_bPushed = FALSE;
	m_bFocused = FALSE;
	m_bDroppedDown = FALSE;
	m_bHidden = FALSE;
	m_bEnabled = TRUE;
	m_nHit = nHit;
	m_bLeftAlign = bLeftAlign;
	m_clrForeground = (COLORREF)-1;
	m_bIsMiniFrameButton = FALSE;
}

CMFCCaptionButton::~CMFCCaptionButton()
{
}

UINT CMFCCaptionButton::GetHit() const
{
	return m_nHit;
}

void CMFCCaptionButton::OnDraw(CDC* pDC, BOOL bActive, BOOL /*bHorz*/, BOOL bMaximized, BOOL bDisabled)
{
	if (m_bHidden)
	{
		return;
	}

	CMFCVisualManager::GetInstance()->OnDrawCaptionButton(pDC, this, bActive, FALSE, bMaximized, bDisabled || !m_bEnabled);
}

CMenuImages::IMAGES_IDS CMFCCaptionButton::GetIconID(BOOL bHorz, BOOL bMaximized) const
{
	switch(m_nHit)
	{
	case HTCLOSE:
	case AFX_HTCLOSE:
		return CMenuImages::IdClose;

	case HTMINBUTTON:
		return bHorz ?
			bMaximized ? CMenuImages::IdArrowLeft : CMenuImages::IdArrowRight :
			bMaximized ? CMenuImages::IdArrowDownLarge :  CMenuImages::IdArrowUp;

	case HTMAXBUTTON:
		return bMaximized ? CMenuImages::IdPinHorz : CMenuImages::IdPinVert;

	case AFX_HTLEFTBUTTON:
		return CMenuImages::IdArrowBack;

	case AFX_HTRIGHTBUTTON:
		return CMenuImages::IdArrowForward;

	case AFX_HTMENU:
		return CMenuImages::IdArrowDownLarge;
	}

	return(CMenuImages::IMAGES_IDS)-1;
}

CMFCCaptionButtonEx::CMFCCaptionButtonEx(UINT nHit)
{
	m_nHit = nHit;
	m_rect.SetRectEmpty();
}

CMFCCaptionButtonEx::~CMFCCaptionButtonEx()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcaptionmenubutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxvisualmanager.h"
#include "afxcontextmenumanager.h"
#include "afxcaptionbutton.h"
#include "afxcaptionmenubutton.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCCaptionMenuButton

CMFCCaptionMenuButton::CMFCCaptionMenuButton()
{
	m_nMenuResult = 0;
	m_bOSMenu = TRUE;
	m_bMenuIsActive = FALSE;
}

CMFCCaptionMenuButton::CMFCCaptionMenuButton(UINT nHit, BOOL bLeftAlign) :
	CMFCCaptionButton(nHit, bLeftAlign)
{
	m_nMenuResult = 0;
	m_bOSMenu = TRUE;
	m_bMenuIsActive = FALSE;
}

CMFCCaptionMenuButton::~CMFCCaptionMenuButton()
{
}

/////////////////////////////////////////////////////////////////////////////
// CMFCCaptionMenuButton message handlers

void CMFCCaptionMenuButton::OnDraw(CDC* pDC, BOOL bActive, BOOL bHorz, BOOL bMaximized, BOOL bDisabled)
{
	if (m_bHidden)
	{
		return;
	}

	CMFCVisualManager::GetInstance()->OnDrawCaptionButton(pDC, this, bActive, bHorz, bMaximized, bDisabled);
}

void CMFCCaptionMenuButton::ShowMenu(HMENU hMenu, CWnd* pWndOwner)
{
	ASSERT_VALID(pWndOwner);

	CRect rectWnd;
	pWndOwner->GetWindowRect(&rectWnd);
	CSize size = GetSize();
	CPoint point = m_ptOrg + rectWnd.TopLeft();
	point.x += size.cx;
	point.y += size.cy;

	m_bMenuIsActive = TRUE;
	m_bPushed = TRUE;
	pWndOwner->InvalidateRect(GetRect());
	pWndOwner->SendMessage(WM_NCPAINT);

	if (!m_bOSMenu && afxContextMenuManager != NULL)
	{
		m_nMenuResult = afxContextMenuManager->TrackPopupMenu(hMenu, point.x, point.y, pWndOwner, TRUE /* RightAlign */);
	}
	else
	{
		m_nMenuResult = ::TrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, point.x, point.y, 0, pWndOwner->GetSafeHwnd(), NULL);
	}

	m_bMenuIsActive = FALSE;
	m_bPushed = FALSE;
	pWndOwner->InvalidateRect(GetRect());
	pWndOwner->SendMessage(WM_NCPAINT);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcmdusagecount.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxcmdusagecount.h"
#include "afxtoolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

UINT CMFCCmdUsageCount::m_nStartCount = 0;
UINT CMFCCmdUsageCount::m_nMinUsagePercentage = 5;

// Construction/Destruction
CMFCCmdUsageCount::CMFCCmdUsageCount() : m_nTotalUsage(0)
{
}

CMFCCmdUsageCount::~CMFCCmdUsageCount()
{
}

void CMFCCmdUsageCount::Serialize(CArchive& ar)
{
	if (ar.IsLoading())
	{
		ar >> m_nTotalUsage;
	}
	else
	{
		ar << m_nTotalUsage;
	}

	m_CmdUsage.Serialize(ar);
}

void CMFCCmdUsageCount::AddCmd(UINT uiCmd)
{
	if (CMFCToolBar::IsCustomizeMode())
	{
		return;
	}

	if ((uiCmd == 0 || uiCmd == (UINT) -1) || // Ignore submenus and separators, CMFCToolBar::IsBasicCommand(uiCmd) || // basic commands and
		IsStandardCommand(uiCmd)) // standard commands
	{
		return;
	}

	UINT uiCount = 0;
	if (!m_CmdUsage.Lookup(uiCmd, uiCount))
	{
		uiCount = 0;
	}

	m_CmdUsage.SetAt(uiCmd, ++uiCount);
	m_nTotalUsage ++;
}

void CMFCCmdUsageCount::Reset()
{
	m_CmdUsage.RemoveAll();
	m_nTotalUsage = 0;
}

UINT CMFCCmdUsageCount::GetCount(UINT uiCmd) const
{
	UINT uiCount = 0;
	m_CmdUsage.Lookup(uiCmd, uiCount);

	return uiCount;
}

BOOL CMFCCmdUsageCount::IsFreqeuntlyUsedCmd(UINT uiCmd) const
{
	// I say, that the specific command is frequently used,
	// if the command usage percentage is more than 20%
	if (m_nTotalUsage == 0)
	{
		return FALSE;
	}

	UINT uiCount = GetCount(uiCmd);

	if (m_nMinUsagePercentage == 0)
	{
		return uiCount > 0;
	}
	else
	{
		UINT uiPercentage = uiCount * 100 / m_nTotalUsage;
		return uiPercentage > m_nMinUsagePercentage;
	}
}

BOOL CMFCCmdUsageCount::HasEnoughInformation() const
{
	return m_nTotalUsage >= m_nStartCount;
}

BOOL __stdcall CMFCCmdUsageCount::SetOptions(UINT nStartCount, UINT nMinUsagePercentage)
{
	if (nMinUsagePercentage >= 100)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_nStartCount = nStartCount;
	m_nMinUsagePercentage = nMinUsagePercentage;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcolorbutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxcontrolbarutil.h"
#include "afxcolorbutton.h"
#include "afxcolorbar.h"
#include "afxcolorpopupmenu.h"
#include "afxmenuimages.h"
#include "afxvisualmanager.h"
#include "afxtoolbarcomboboxbutton.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nImageHorzMargin = 8;

/////////////////////////////////////////////////////////////////////////////
// CMFCColorButton

IMPLEMENT_DYNAMIC(CMFCColorButton, CMFCButton)

CMFCColorButton::CMFCColorButton()
{
	m_Color = RGB(0, 0, 0);
	m_ColorAutomatic = (COLORREF)-1;
	m_nColumns = -1;
	m_pPopup = NULL;
	m_bAltColorDlg = TRUE;
	m_pPalette = NULL;
	m_bEnabledInCustomizeMode = FALSE;
	m_bAutoSetFocus = TRUE;
}

CMFCColorButton::~CMFCColorButton()
{
	if (m_pPalette != NULL)
	{
		delete m_pPalette;
	}
}


BEGIN_MESSAGE_MAP(CMFCColorButton, CMFCButton)
	//{{AFX_MSG_MAP(CMFCColorButton)
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONDOWN()
	ON_WM_GETDLGCODE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_MOUSEMOVE()
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCColorButton::OnInitControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCColorButton message handlers

CSize CMFCColorButton::SizeToContent(BOOL bCalcOnly)
{
	CSize size = CMFCButton::SizeToContent(FALSE);
	size.cx += CMenuImages::Size().cx;

	if (!bCalcOnly)
	{
		SetWindowPos(NULL, -1, -1, size.cx, size.cy, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
	}

	return size;
}

void CMFCColorButton::OnFillBackground(CDC* pDC, const CRect& rectClient)
{
	if (!IsDrawXPTheme())
	{
		CMFCButton::OnFillBackground(pDC, rectClient);
		return;
	}

	ASSERT_VALID(pDC);
	pDC->FillRect(rectClient, &afxGlobalData.brWindow);
}

void CMFCColorButton::OnDraw(CDC* pDC, const CRect& rect, UINT uiState)
{
	ASSERT_VALID(pDC);

	if (m_pPalette == NULL)
	{
		RebuildPalette(NULL);
	}

	CPalette* pCurPalette = pDC->SelectPalette(m_pPalette, FALSE);
	pDC->RealizePalette();

	CSize sizeArrow = CMenuImages::Size();

	CRect rectColor = rect;
	rectColor.right -= sizeArrow.cx + nImageHorzMargin;

	CRect rectArrow = rect;
	rectArrow.left = rectColor.right;

	COLORREF color = m_Color;
	if (color == (COLORREF) -1) // Automatic
	{
		//---------------------------
		// Draw automatic text label:
		//---------------------------
		color = m_ColorAutomatic;

		if (!m_strAutoColorText.IsEmpty())
		{
			rectColor.right = rectColor.left + rectColor.Height();

			CRect rectText = rect;
			rectText.left = rectColor.right;
			rectText.right = rectArrow.left;

			CFont* pOldFont = SelectFont(pDC);
			ENSURE(pOldFont != NULL);

			pDC->SetBkMode(TRANSPARENT);
			pDC->SetTextColor(afxGlobalData.clrBtnText);
			pDC->DrawText(m_strAutoColorText, rectText, DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_END_ELLIPSIS);

			pDC->SelectObject(pOldFont);
		}
	}

	//----------------
	// Draw color box:
	//----------------
	rectColor.DeflateRect(2, 2);
	pDC->Draw3dRect(rectColor, afxGlobalData.clrBtnHilite, afxGlobalData.clrBtnHilite);
	rectColor.DeflateRect(1, 1);
	pDC->Draw3dRect(rectColor, afxGlobalData.clrBtnDkShadow, afxGlobalData.clrBtnDkShadow);
	rectColor.DeflateRect(1, 1);

	if (color != (COLORREF)-1 &&(uiState & ODS_DISABLED) == 0)
	{
		if (afxGlobalData.m_nBitsPerPixel == 8) // 256 colors
		{
			ASSERT_VALID(m_pPalette);
			color =  PALETTEINDEX(m_pPalette->GetNearestPaletteIndex(color));
		}

		CBrush br(color);
		pDC->FillRect(rectColor, &br);
	}

	//----------------------
	// Draw drop-down arrow:
	//----------------------
	CRect rectArrowWinXP = rectArrow;
	rectArrowWinXP.DeflateRect(2, 2);

	if (!m_bWinXPTheme || !CMFCVisualManager::GetInstance()->DrawComboDropButtonWinXP(pDC, rectArrowWinXP, (uiState & ODS_DISABLED), m_bPushed, m_bHighlighted))
	{
		pDC->FillRect(rectArrow, &afxGlobalData.brBtnFace);

		CMenuImages::Draw(pDC, CMenuImages::IdArrowDownLarge, rectArrow, (uiState & ODS_DISABLED) ? CMenuImages::ImageGray : CMenuImages::ImageBlack);

		pDC->Draw3dRect(rectArrow, afxGlobalData.clrBtnLight, afxGlobalData.clrBtnDkShadow);
		rectArrow.DeflateRect(1, 1);
		pDC->Draw3dRect(rectArrow, afxGlobalData.clrBtnHilite, afxGlobalData.clrBtnShadow);
	}

	if (pCurPalette != NULL)
	{
		pDC->SelectPalette(pCurPalette, FALSE);
	}
}

void CMFCColorButton::OnDrawBorder(CDC* pDC, CRect& rectClient, UINT /*uiState*/)
{
	ASSERT_VALID(pDC);
	ASSERT(m_nFlatStyle != BUTTONSTYLE_NOBORDERS); // Always has borders

	if (!m_bWinXPTheme || !CMFCVisualManager::GetInstance()->DrawComboBorderWinXP(pDC, rectClient, !IsWindowEnabled(), FALSE, TRUE))
	{
		pDC->Draw3dRect(rectClient, afxGlobalData.clrBtnDkShadow, afxGlobalData.clrBtnHilite);

		rectClient.DeflateRect(1, 1);

		if (m_nFlatStyle == BUTTONSTYLE_3D || m_bHighlighted)
		{
			pDC->Draw3dRect(rectClient, afxGlobalData.clrBtnShadow, afxGlobalData.clrBtnLight);
		}
	}
}

void CMFCColorButton::OnDrawFocusRect(CDC* pDC, const CRect& rectClient)
{
	CSize sizeArrow = CMenuImages::Size();

	CRect rectColor = rectClient;
	rectColor.right -= sizeArrow.cx + nImageHorzMargin;

	CMFCButton::OnDrawFocusRect(pDC, rectColor);
}

void CMFCColorButton::OnShowColorPopup()
{
	if (m_pPopup != NULL)
	{
		m_pPopup->SendMessage(WM_CLOSE);
		m_pPopup = NULL;
		return;
	}

	if (m_Colors.GetSize() == 0)
	{
		// Use default pallete:
		CMFCColorBar::InitColors(NULL, m_Colors);
	}

	m_pPopup = new CMFCColorPopupMenu(this, m_Colors, m_Color, m_strAutoColorText, m_strOtherText, m_strDocColorsText, m_lstDocColors, m_nColumns, m_ColorAutomatic);
	m_pPopup->m_bEnabledInCustomizeMode = m_bEnabledInCustomizeMode;

	CRect rectWindow;
	GetWindowRect(rectWindow);

	if (!m_pPopup->Create(this, rectWindow.left, rectWindow.bottom, NULL, m_bEnabledInCustomizeMode))
	{
		ASSERT(FALSE);
		m_pPopup = NULL;

		TRACE(_T("Color menu can't be used in the customization mode. You need to set CMFCColorButton::m_bEnabledInCustomizeMode\n"));
	}
	else
	{
		if (m_bEnabledInCustomizeMode)
		{
			CMFCColorBar* pColorBar = DYNAMIC_DOWNCAST(CMFCColorBar, m_pPopup->GetMenuBar());

			if (pColorBar != NULL)
			{
				ASSERT_VALID(pColorBar);
				pColorBar->m_bInternal = TRUE;
			}
		}

		CRect rect;
		m_pPopup->GetWindowRect(&rect);
		m_pPopup->UpdateShadow(&rect);

		if (m_bAutoSetFocus)
		{
			m_pPopup->GetMenuBar()->SetFocus();
		}
	}

	if (m_bCaptured)
	{
		ReleaseCapture();
		m_bCaptured = FALSE;
	}
}

void CMFCColorButton::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_SPACE || nChar == VK_DOWN)
	{
		OnShowColorPopup();
		return;
	}

	CButton::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CMFCColorButton::OnLButtonDown(UINT /*nFlags*/, CPoint /*point*/)
{
	SetFocus();
	OnShowColorPopup();
}

void CMFCColorButton::OnMouseMove(UINT nFlags, CPoint point)
{
	FlatStyle nFlatStyle = m_nFlatStyle;
	if (IsDrawXPTheme())
	{
		m_nFlatStyle = BUTTONSTYLE_SEMIFLAT;
	}

	CMFCButton::OnMouseMove(nFlags, point);
	m_nFlatStyle = nFlatStyle;
}

UINT CMFCColorButton::OnGetDlgCode()
{
	return DLGC_WANTARROWS;
}

void CMFCColorButton::EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable)
{
	m_strAutoColorText = (bEnable && lpszLabel == NULL) ? _T("") : lpszLabel;
	m_ColorAutomatic = colorAutomatic;
}

void CMFCColorButton::EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg, BOOL bEnable)
{
	m_strOtherText = (bEnable && lpszLabel == NULL) ? _T("") : lpszLabel;
	m_bAltColorDlg = bAltColorDlg;
}

void CMFCColorButton::SetDocumentColors(LPCTSTR lpszLabel, CList<COLORREF,COLORREF>& lstColors)
{
	m_lstDocColors.RemoveAll();
	m_strDocColorsText = (lpszLabel == NULL) ? _T("") : lpszLabel;

	if (!m_strDocColorsText.IsEmpty())
	{
		m_lstDocColors.AddTail(&lstColors);
	}
}

void CMFCColorButton::SetPalette(CPalette* pPalette)
{
	if (m_Colors.GetSize() != 0)
	{
		m_Colors.SetSize(0);
		m_Colors.FreeExtra();
	}

	CMFCColorBar::InitColors(pPalette, m_Colors);
	RebuildPalette(pPalette);
}

void CMFCColorButton::SetColor(COLORREF color /* -1 - automatic*/)
{
	m_Color = color;

	if (GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

void CMFCColorButton::UpdateColor(COLORREF color)
{
	SetColor(color);

	//-------------------------------------------------------
	// Trigger mouse up event(to button click notification):
	//-------------------------------------------------------
	CWnd* pParent = GetParent();
	if (pParent != NULL)
	{
		pParent->SendMessage( WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM) m_hWnd);
	}
}

void CMFCColorButton::RebuildPalette(CPalette* pPal)
{
	if (m_pPalette != NULL)
	{
		delete m_pPalette;
	}

	m_pPalette = new CPalette();

	// Create palette:
	CClientDC dc(this);

	if (pPal == NULL)
	{
		int nColors = 256; // Use 256 first entries
		UINT nSize = sizeof(LOGPALETTE) +(sizeof(PALETTEENTRY) * nColors);
		LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];

		::GetSystemPaletteEntries(dc.GetSafeHdc(), 0, nColors, pLP->palPalEntry);

		pLP->palVersion = 0x300;
		pLP->palNumEntries = (USHORT) nColors;

		m_pPalette->CreatePalette(pLP);

		delete[] pLP;
	}
	else
	{
		ASSERT_VALID(pPal);
		int nColors = pPal->GetEntryCount();
		UINT nSize = sizeof(LOGPALETTE) +(sizeof(PALETTEENTRY) * nColors);
		LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];

		pPal->GetPaletteEntries(0, nColors, pLP->palPalEntry);

		pLP->palVersion = 0x300;
		pLP->palNumEntries = (USHORT) nColors;

		m_pPalette->CreatePalette(pLP);

		delete[] pLP;
	}
}

void CMFCColorButton::OnSysColorChange()
{
	CMFCButton::OnSysColorChange();
	RebuildPalette(NULL);

	Invalidate();
	UpdateWindow();
}

BOOL CMFCColorButton::IsDrawXPTheme() const
{
	return m_bWinXPTheme && CMFCVisualManager::GetInstance()->IsWindowsThemingSupported();
}

LRESULT CMFCColorButton::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	BOOL bEnableOtherButton = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCColorButton_EnableOtherButton, bEnableOtherButton))
	{
		if (bEnableOtherButton)
		{
			EnableOtherButton(_T("Other"), TRUE, bEnableOtherButton);
		}
		else
		{
			EnableOtherButton(NULL, TRUE, bEnableOtherButton);
		}
	}

	BOOL bEnableAutomaticButton = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCColorButton_EnableAutomaticButton, bEnableAutomaticButton))
	{
		if (bEnableAutomaticButton)
		{
			EnableAutomaticButton(_T("Automatic"), RGB(0, 0, 0), bEnableAutomaticButton);
		}
		else
		{
			EnableAutomaticButton(NULL, RGB(0, 0, 0), bEnableAutomaticButton);
		}
	}

	CString strColumnsCount;
	if (tagManager.ExcludeTag(PS_MFCColorButton_ColumnsCount, strColumnsCount))
	{
		if (!strColumnsCount.IsEmpty())
		{
			int nColumnsCount = _ttoi((LPCTSTR)strColumnsCount);
			if (nColumnsCount > 0)
			{
				SetColumnsNumber(nColumnsCount);
			}
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcolormenubutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxmenutearoffmanager.h"
#include "afxcontrolbarutil.h"
#include "afxmenuimages.h"
#include "afxpopupmenubar.h"
#include "afxcolormenubutton.h"
#include "afxcolordialog.h"
#include "afxcolorbar.h"
#include "afxsettingsstore.h"
#include "afxcolorpopupmenu.h"
#include "afxglobals.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int SEPARATOR_SIZE = 2;

CMap<UINT,UINT,COLORREF, COLORREF> CMFCColorMenuButton::m_ColorsByID;

UINT AFX_WM_GETDOCUMENTCOLORS = ::RegisterWindowMessage(_T("TOOLBAR__GETDOCUMENTCOLORS"));

IMPLEMENT_SERIAL(CMFCColorMenuButton, CMFCToolBarMenuButton, VERSIONABLE_SCHEMA | 1)

// Construction/Destruction
CMFCColorMenuButton::CMFCColorMenuButton()
{
	Initialize();
}

CMFCColorMenuButton::CMFCColorMenuButton(UINT uiCmdID, LPCTSTR lpszText, CPalette* pPalette) :
	CMFCToolBarMenuButton(uiCmdID, NULL, afxCommandManager->GetCmdImage(uiCmdID, FALSE), lpszText)
{
	Initialize();

	CMFCColorBar::InitColors(pPalette, m_Colors);
	m_Color = GetColorByCmdID(uiCmdID);
}

void CMFCColorMenuButton::Initialize()
{
	m_Color = (COLORREF) -1; // Default(automatic) color
	m_colorAutomatic = 0;
	m_nColumns = -1;
	m_nVertDockColumns = -1;
	m_nHorzDockRows = -1;
	m_bIsAutomaticButton = FALSE;
	m_bIsOtherButton = FALSE;
	m_bIsDocumentColors = FALSE;
	m_bStdColorDlg = FALSE;
}

CMFCColorMenuButton::~CMFCColorMenuButton()
{
}

void CMFCColorMenuButton::EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable)
{
	m_bIsAutomaticButton = bEnable;
	if (bEnable)
	{
		ENSURE(lpszLabel != NULL);
		m_strAutomaticButtonLabel = lpszLabel;

		m_colorAutomatic = colorAutomatic;
	}
}

void CMFCColorMenuButton::EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg, BOOL bEnable)
{
	m_bIsOtherButton = bEnable;

	if (bEnable)
	{
		ENSURE(lpszLabel != NULL);
		m_strOtherButtonLabel = lpszLabel;

		m_bStdColorDlg = !bAltColorDlg;
	}
}

void CMFCColorMenuButton::EnableDocumentColors(LPCTSTR lpszLabel, BOOL bEnable)
{
	m_bIsDocumentColors = bEnable;
	if (bEnable)
	{
		ENSURE(lpszLabel != NULL);
		m_strDocumentColorsLabel = lpszLabel;
	}
}

void CMFCColorMenuButton::EnableTearOff(UINT uiID, int nVertDockColumns, int nHorzDockRows)
{
	if (g_pTearOffMenuManager != NULL && g_pTearOffMenuManager->IsDynamicID(uiID))
	{
		ASSERT(FALSE); // SHould be static ID!
		uiID = 0;
	}

	m_uiTearOffBarID = uiID;

	m_nVertDockColumns = nVertDockColumns;
	m_nHorzDockRows = nHorzDockRows;
}

void CMFCColorMenuButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz, BOOL bCustomizeMode, BOOL bHighlight, BOOL bDrawBorder, BOOL bGrayDisabledButtons)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CMFCToolBarMenuButton::OnDraw(pDC, rect, pImages, bHorz, bCustomizeMode, bHighlight, bDrawBorder, bGrayDisabledButtons);

	if (!IsDrawImage() || pImages == NULL)
	{
		return;
	}

	CPalette* pOldPalette = NULL;
	if (afxGlobalData.m_nBitsPerPixel == 8) // 256 colors
	{
		if (m_Palette.GetSafeHandle() == NULL)
		{
			// Palette not created yet; create it now
			CMFCColorBar::CreatePalette(m_Colors, m_Palette);
		}

		ENSURE(m_Palette.GetSafeHandle() != NULL);

		pOldPalette = pDC->SelectPalette(&m_Palette, FALSE);
		pDC->RealizePalette();
	}
	else if (m_Palette.GetSafeHandle() != NULL)
	{
		::DeleteObject(m_Palette.Detach());
		ENSURE(m_Palette.GetSafeHandle() == NULL);
	}

	ENSURE(pImages != NULL);
	CRect rectColor = pImages->GetLastImageRect();
	const int nColorBoxSize = CMFCToolBar::IsLargeIcons() && !m_bMenuMode ? 10 : 5;

	rectColor.top = rectColor.bottom - nColorBoxSize;
	rectColor.OffsetRect(0, 1);

	// Draw color bar:
	BOOL bDrawImageShadow = bHighlight && !bCustomizeMode && CMFCVisualManager::GetInstance()->IsShadowHighlightedImage() && !afxGlobalData.IsHighContrastMode() &&
		((m_nStyle & TBBS_PRESSED) == 0) && ((m_nStyle & TBBS_CHECKED) == 0) && ((m_nStyle & TBBS_DISABLED) == 0);

	if (bDrawImageShadow)
	{
		CBrush brShadow(afxGlobalData.clrBarShadow);
		pDC->FillRect(rectColor, &brShadow);
		rectColor.OffsetRect(-1, -1);
	}

	COLORREF color = (m_nStyle & TBBS_DISABLED) ? afxGlobalData.clrBarShadow : (m_Color == (COLORREF)-1 ? m_colorAutomatic : m_Color);

	CBrush br(PALETTERGB( GetRValue(color), GetGValue(color), GetBValue(color)));

	CBrush* pOldBrush = pDC->SelectObject(&br);
	CPen* pOldPen = (CPen*) pDC->SelectStockObject(NULL_PEN);

	pDC->Rectangle(&rectColor);

	pDC->SelectObject(pOldPen);
	pDC->SelectObject(pOldBrush);

	if (CMFCVisualManager::GetInstance()->IsMenuFlatLook())
	{
		if (color == afxGlobalData.clrBarFace)
		{
			pDC->Draw3dRect(rectColor, afxGlobalData.clrBarDkShadow, afxGlobalData.clrBarDkShadow);
		}
	}
	else
	{
		pDC->Draw3dRect(rectColor, afxGlobalData.clrBarShadow, afxGlobalData.clrBarLight);
	}

	if (pOldPalette != NULL)
	{
		pDC->SelectPalette(pOldPalette, FALSE);
	}
}

int CMFCColorMenuButton::OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected)
{
	int nID = m_nID;
	m_nID = 0; // Force draw right arrow

	CRect rectColor = rect;
	rectColor.DeflateRect(1, 0);

	int iRes = CMFCToolBarMenuButton::OnDrawOnCustomizeList(pDC, rect, bSelected);

	m_nID = nID;

	return iRes;
}

void CMFCColorMenuButton::SetColor(COLORREF clr, BOOL bNotify)
{
	m_Color = clr;
	m_ColorsByID.SetAt(m_nID, m_Color);

	if (m_pWndParent->GetSafeHwnd() != NULL)
	{
		m_pWndParent->InvalidateRect(m_rect);
	}

	if (bNotify)
	{
		CObList listButtons;
		if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) > 0)
		{
			for (POSITION pos = listButtons.GetHeadPosition(); pos != NULL;)
			{
				CMFCColorMenuButton* pOther = DYNAMIC_DOWNCAST(CMFCColorMenuButton, listButtons.GetNext(pos));

				if (pOther != NULL && pOther != this)
				{
					pOther->SetColor(clr, FALSE);
				}
			}
		}

		const CObList& lstToolBars = CMFCToolBar::GetAllToolbars();
		for (POSITION pos = lstToolBars.GetHeadPosition(); pos != NULL;)
		{
			CMFCColorBar* pColorBar = DYNAMIC_DOWNCAST(CMFCColorBar, lstToolBars.GetNext(pos));
			if (pColorBar != NULL && pColorBar->m_nCommandID == m_nID)
			{
				pColorBar->SetColor(clr);
			}
		}
	}
}

void CMFCColorMenuButton::OnChangeParentWnd(CWnd* pWndParent)
{
	CMFCToolBarButton::OnChangeParentWnd(pWndParent);

	if (pWndParent != NULL)
	{
		if (pWndParent->IsKindOf(RUNTIME_CLASS(CMFCMenuBar)))
		{
			m_bText = TRUE;
		}

		if (pWndParent->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
		{
			m_bMenuMode = TRUE;
			m_bText = TRUE;
		}
		else
		{
			m_bMenuMode = FALSE;
		}
	}

	m_bDrawDownArrow = TRUE;
	m_pWndParent = pWndParent;
}

void CMFCColorMenuButton::Serialize(CArchive& ar)
{
	CMFCToolBarMenuButton::Serialize(ar);

	if (ar.IsLoading())
	{
		int nColorsCount;
		ar >> nColorsCount;

		m_Colors.SetSize(nColorsCount);

		for (int i = 0; i < nColorsCount; i++)
		{
			COLORREF color;
			ar >> color;

			m_Colors [i] = color;
		}

		ar >> m_nColumns;
		ar >> m_nVertDockColumns;
		ar >> m_nHorzDockRows;

		ar >> m_bIsAutomaticButton;
		ar >> m_bIsOtherButton;
		ar >> m_bIsDocumentColors;

		ar >> m_strAutomaticButtonLabel;
		ar >> m_strOtherButtonLabel;
		ar >> m_strDocumentColorsLabel;

		ar >> m_colorAutomatic;
		ar >> m_bStdColorDlg;

		// Synchromize color with another buttons with the same ID:
		CObList listButtons;
		if (CMFCToolBar::GetCommandButtons(m_nID, listButtons) > 0)
		{
			for (POSITION pos = listButtons.GetHeadPosition(); pos != NULL;)
			{
				CMFCColorMenuButton* pOther = DYNAMIC_DOWNCAST(CMFCColorMenuButton, listButtons.GetNext(pos));
				if (pOther != NULL && pOther != this && pOther->m_Color != (COLORREF) -1)
				{
					m_Color = pOther->m_Color;
				}
			}
		}
	}
	else
	{
		ar <<(int) m_Colors.GetSize();
		for (int i = 0; i < m_Colors.GetSize(); i++)
		{
			ar << m_Colors [i];
		}

		ar << m_nColumns;

		ar << m_nVertDockColumns;
		ar << m_nHorzDockRows;

		ar << m_bIsAutomaticButton;
		ar << m_bIsOtherButton;
		ar << m_bIsDocumentColors;

		ar << m_strAutomaticButtonLabel;
		ar << m_strOtherButtonLabel;
		ar << m_strDocumentColorsLabel;

		ar << m_colorAutomatic;
		ar << m_bStdColorDlg;
	}
}

void CMFCColorMenuButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarMenuButton::CopyFrom(s);

	const CMFCColorMenuButton& src = (const CMFCColorMenuButton&) s;

	m_Color = src.m_Color;
	m_ColorsByID.SetAt(m_nID, m_Color); // Just to be happy :-)

	m_Colors.SetSize(src.m_Colors.GetSize());

	for (int i = 0; i < m_Colors.GetSize(); i++)
	{
		m_Colors [i] = src.m_Colors [i];
	}

	m_bIsAutomaticButton = src.m_bIsAutomaticButton;
	m_colorAutomatic = src.m_colorAutomatic;
	m_bIsOtherButton = src.m_bIsOtherButton;
	m_bIsDocumentColors = src.m_bIsDocumentColors;

	m_strAutomaticButtonLabel = src.m_strAutomaticButtonLabel;
	m_strOtherButtonLabel = src.m_strOtherButtonLabel;
	m_strDocumentColorsLabel =  src.m_strDocumentColorsLabel;

	m_nColumns = src.m_nColumns;
	m_nVertDockColumns = src.m_nVertDockColumns;
	m_nHorzDockRows = src.m_nHorzDockRows;

	m_bStdColorDlg = src.m_bStdColorDlg;
}

BOOL CMFCColorMenuButton::OpenColorDialog(const COLORREF colorDefault, COLORREF& colorRes)
{
	BOOL bResult = FALSE;

	if (m_bStdColorDlg)
	{
		CColorDialog dlg(colorDefault, CC_FULLOPEN | CC_ANYCOLOR);
		if (dlg.DoModal() == IDOK)
		{
			colorRes = dlg.GetColor();
			bResult = TRUE;
		}
	}
	else
	{
		CMFCColorDialog dlg(colorDefault);
		if (dlg.DoModal() == IDOK)
		{
			colorRes = dlg.GetColor();
			bResult = TRUE;
		}
	}

	return bResult;
}

CMFCPopupMenu* CMFCColorMenuButton::CreatePopupMenu()
{
	CList<COLORREF,COLORREF> lstDocColors;
	if (m_bIsDocumentColors && m_pWndParent != NULL)
	{
		CFrameWnd* pOwner = AFXGetTopLevelFrame(m_pWndParent);
		ASSERT_VALID(pOwner);

		// Fill document colors list:
		pOwner->SendMessage(AFX_WM_GETDOCUMENTCOLORS, (WPARAM) m_nID, (LPARAM) &lstDocColors);
	}

	return new CMFCColorPopupMenu(m_Colors, m_Color, (m_bIsAutomaticButton ?(LPCTSTR) m_strAutomaticButtonLabel : NULL), (m_bIsOtherButton ?(LPCTSTR) m_strOtherButtonLabel : NULL),
		(m_bIsDocumentColors ?(LPCTSTR) m_strDocumentColorsLabel : NULL), lstDocColors, m_nColumns, m_nHorzDockRows, m_nVertDockColumns, m_colorAutomatic, m_nID, m_bStdColorDlg);
}

void __stdcall CMFCColorMenuButton::SetColorName(COLORREF color, const CString& strName)
{
	CMFCColorBar::m_ColorNames.SetAt(color, strName);
}

COLORREF __stdcall CMFCColorMenuButton::GetColorByCmdID(UINT uiCmdID)
{
	COLORREF color = (COLORREF)-1;
	m_ColorsByID.Lookup(uiCmdID, color);

	return color;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcolorpickerctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include <math.h>
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxcolorpickerctrl.h"
#include "afxdrawmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_DEFAULT_WIDTH_OF_LUMINANCE_BAR 20
#define AFX_DEFAULT_OFFSET_OF_LUMINANCE_BAR 5
#define AFX_DEFAULT_LUMINANCE 0.50f
#define AFX_PICKER_CURSOR_SIZE 19
#define AFX_LUM_CURSOR_SIZE 9

// Hex
#define AFX_NUM_LEVELS 7
#define AFX_CELL_EDGES 6
#define AFX_GRAY_CELLS_NUM 15 // + 2(Black and white)
#define AFX_TAN30 0.57735026918962F
#define AFX_YOFFSET (1.5F * AFX_TAN30)
#define AFX_PI 3.14159265358979

static const float cfxOffset[] = { -0.5, -1.0, -0.5, 0.5, 1.0, 0.5 };
static const float cfyOffset[] = { AFX_YOFFSET, 0.0, -AFX_YOFFSET, -AFX_YOFFSET, 0.0, AFX_YOFFSET };

static const COLORREF colorWhite = RGB(255, 255, 255);
static const COLORREF colorBlack = RGB(0, 0, 0);

static long __stdcall AlignColor(long lPart, const long lDelta)
{
	if (lDelta == 0)
	{
		return lPart;
	}

	if (lPart < lDelta)
	{
		return 0;
	}

	if (lPart > 255 - lDelta)
	{
		return 255;
	}

	if (abs(lPart - 128) < lDelta)
	{
		return 128;
	}

	if (abs(lPart - 192) < lDelta)
	{
		return 192;
	}

	return lPart;
}

class CCellObj : public CObject
{
	friend class CMFCColorPickerCtrl;

	CCellObj( CPalette* pPalette, const COLORREF color, const int x, const int y, const int nCellWidth, const long lDelta)
	{
		m_x = x;
		m_y = y;

		m_nCellWidth = nCellWidth;

		// Approximate color to one of "standard" colors:
		long lRed = AlignColor(GetRValue(color), lDelta);
		long lGreen = AlignColor(GetGValue(color), lDelta);
		long lBlue = AlignColor(GetBValue(color), lDelta);

		m_CellColor = RGB(lRed, lGreen, lBlue);

		if (afxGlobalData.m_nBitsPerPixel == 8) // 256 colors
		{
			ASSERT_VALID(pPalette);

			UINT uiPalIndex = pPalette->GetNearestPaletteIndex(color);
			m_CellDrawColor = PALETTEINDEX(uiPalIndex);
		}
		else
		{
			m_CellDrawColor = m_CellColor;
		}

		GetPoints(m_x, m_y, nCellWidth, m_CellPoints);
	}

	BOOL HitTest(POINT pt)
	{
		CRgn rgn;
		rgn.CreatePolygonRgn(m_CellPoints, AFX_CELL_EDGES, ALTERNATE);

		return rgn.PtInRegion(pt);
	}

	void GetPoints(int x, int y, int nCellWidth, POINT* pptArray)
	{
		// side length = half the height * sin(60)
		int nHalfWidth = nCellWidth / 2;
		int nSideLength = static_cast<int>(static_cast<float>(nCellWidth) * AFX_TAN30);
		int nTemp = nSideLength/2;

		pptArray[0].x = x - nHalfWidth;
		pptArray[0].y = y - nTemp;

		pptArray[1].x = x;
		pptArray[1].y = y - nHalfWidth;

		pptArray[2].x = x + nHalfWidth;
		pptArray[2].y = y - nTemp;

		pptArray[3].x = x + nHalfWidth;
		pptArray[3].y = y + nTemp;

		pptArray[4].x = x;
		pptArray[4].y = y + nHalfWidth;

		pptArray[5].x = x - nHalfWidth;
		pptArray[5].y = y + nTemp;
	}

	void Draw(CDC* pDC)
	{
		ASSERT_VALID(pDC);

		CBrush br(m_CellDrawColor);
		CPen pen(PS_SOLID, 1, m_CellDrawColor);

		CBrush* pOldBrush = pDC->SelectObject(&br);
		CPen* pOldPen = pDC->SelectObject(&pen);

		pDC->Polygon(m_CellPoints, AFX_CELL_EDGES);

		pDC->SelectObject(pOldPen);
		pDC->SelectObject(pOldBrush);
	}

	void DrawSelected(CDC* pDC)
	{
		ASSERT_VALID(pDC);

		CBrush* pBrWhite = CBrush::FromHandle((HBRUSH) ::GetStockObject(WHITE_BRUSH));
		ASSERT_VALID(pBrWhite);

		CBrush* pBrBlack = CBrush::FromHandle((HBRUSH) ::GetStockObject(BLACK_BRUSH));
		ASSERT_VALID(pBrBlack);

		CRgn rgnOne, rgnTwo, rgnThree;

		POINT ptArrayTwo[AFX_CELL_EDGES];
		GetPoints(m_x, m_y - 1, m_nCellWidth + 2, ptArrayTwo);

		rgnTwo.CreatePolygonRgn((POINT*)&ptArrayTwo, AFX_CELL_EDGES, ALTERNATE);
		pDC->FrameRgn(&rgnTwo, pBrWhite, 2, 2);

		POINT ptArrayThree[AFX_CELL_EDGES];
		GetPoints(m_x, m_y, m_nCellWidth + 2, ptArrayThree);

		rgnThree.CreatePolygonRgn((POINT*)&ptArrayThree, AFX_CELL_EDGES, ALTERNATE);
		pDC->FrameRgn(&rgnThree, pBrBlack, 1, 1);

		POINT ptArrayOne[AFX_CELL_EDGES];
		GetPoints(m_x, m_y, m_nCellWidth - 1, ptArrayOne);

		rgnOne.CreatePolygonRgn((POINT*)&ptArrayOne, AFX_CELL_EDGES, ALTERNATE);
		pDC->FrameRgn(&rgnOne, pBrBlack, 1, 1);
	}

	POINT m_CellPoints [AFX_CELL_EDGES];
	COLORREF m_CellColor;
	COLORREF m_CellDrawColor;
	int m_x;
	int m_y;
	int m_nCellWidth;
};

//----------------------------------------------------------------------
// CMFCColorPickerCtrl class
//----------------------------------------------------------------------

CMFCColorPickerCtrl::CMFCColorPickerCtrl()
{
	m_colorNew = 0;
	m_colorOriginal = 0;

	CDrawingManager::RGBtoHSL(m_colorNew, &m_dblHue, &m_dblSat, &m_dblLum);

	m_nLumBarWidth  = AFX_DEFAULT_WIDTH_OF_LUMINANCE_BAR;
	m_COLORTYPE = PICKER;

	m_dblLum = 0.500;
	m_pPalette = NULL;
}

CMFCColorPickerCtrl::~CMFCColorPickerCtrl()
{
	for (int i = 0; i < m_arCells.GetSize(); i ++)
	{
		delete m_arCells [i];
	}
}

BEGIN_MESSAGE_MAP(CMFCColorPickerCtrl, CButton)
	//{{AFX_MSG_MAP(CMFCColorPickerCtrl)
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_SIZE()
	ON_WM_GETDLGCODE()
	ON_WM_KEYDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_QUERYNEWPALETTE()
	ON_WM_PALETTECHANGED()
	ON_WM_ERASEBKGND()
	ON_WM_CANCELMODE()
	ON_WM_LBUTTONDBLCLK()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//----------------------------------------------------------------------
// CMFCColorPickerCtrl message handlers
//----------------------------------------------------------------------

int CMFCColorPickerCtrl::GetAngleFromPoint(int nX, int nY)
{
	double dAngle = atan2((double) nY, (double)nX);

	return(int)(dAngle * 180.0/AFX_PI);
}

void CMFCColorPickerCtrl::CreateHexGreyScaleBar()
{
	if (m_arCells.GetSize() != 0)
	{
		// Already created
		return;
	}

	CRect area;
	GetClientRect(area);

	int nCellSize = min(area.Height() / 2 - 2, area.Width() /(AFX_GRAY_CELLS_NUM  / 2 + 6));
	if ((nCellSize % 2) != 0)
	{
		nCellSize ++;
	}

	const int nCellLargeSize = nCellSize * 2;

	int yCenter = (area.top + area.bottom) / 2;
	int nSideLength = static_cast<int>(static_cast<float>(nCellSize) * AFX_TAN30 * 1.5);

	int y1 = yCenter - nSideLength / 2;
	int y2 = y1 + nSideLength;

	int nRGBOffset = 255 /(AFX_GRAY_CELLS_NUM + 2);

	int nStartOffset = area.left;

	for (int nRowNum = 0; nRowNum < 2; nRowNum++)
	{
		if (nRowNum == 1)
		{
			// Draw large white cell:
			int x1 = nStartOffset +(nCellLargeSize / 2);
			m_arCells.Add(new CCellObj(m_pPalette, colorWhite, x1, yCenter, nCellLargeSize, 0));
		}

		int x = nCellLargeSize + nCellSize + nStartOffset;
		int nCurry = y1;
		int nRGB = 255 - nRGBOffset;

		for (int i = 0; i < AFX_GRAY_CELLS_NUM; i++)
		{
			COLORREF color = RGB(nRGB, nRGB, nRGB);
			if (nRowNum == 1)
			{
				m_arCells.Add(new CCellObj(m_pPalette, color, x, nCurry, nCellSize, 7));
			}

			x += (nCellSize / 2);

			nCurry = (nCurry == y1) ? y2 : y1; // Toggle Y
			nRGB -= nRGBOffset;
		}

		if (nRowNum == 1)
		{
			// Draw large black cell:
			int x1 = (x + nCellSize +(nCellSize / 2)) - 1;

			m_arCells.Add(new CCellObj(m_pPalette, colorBlack, x1, yCenter, nCellLargeSize, 0));
		}

		x += nCellLargeSize +(nCellSize / 2);

		if (nRowNum == 0)
		{
			nStartOffset = (area.right - x) / 2;
		}
	}
}

void CMFCColorPickerCtrl::SelectCellHexagon(BYTE R, BYTE G, BYTE B)
{
	SetColor(RGB(R, G, B));
}

void CMFCColorPickerCtrl::SetColor(COLORREF Color)
{
	m_colorNew = Color;
	CDrawingManager::RGBtoHSL(m_colorNew, &m_dblHue, &m_dblSat, &m_dblLum);

	if (GetSafeHwnd() != NULL)
	{
		RedrawWindow();
	}
};

BOOL CMFCColorPickerCtrl::SelectCellHexagon(int x, int y)
{
	for (int i = 0; i < m_arCells.GetSize(); i ++)
	{
		CCellObj* pCell = (CCellObj*) m_arCells [i];
		ASSERT_VALID(pCell);

		if (pCell->HitTest(CPoint(x, y)))
		{
			m_colorNew = pCell->m_CellColor;
			CDrawingManager::RGBtoHSL(m_colorNew, &m_dblHue, &m_dblSat, &m_dblLum);
			return TRUE;
		}
	}

	return FALSE;
}

void CMFCColorPickerCtrl::CreateHexagon()
{
	if (m_arCells.GetSize() != 0)
	{
		// Already created, do nothing
		return;
	}

	CRect rectClient;
	GetClientRect(rectClient);

	// Normalize to squere:
	if (rectClient.Height() < rectClient.Width())
	{
		rectClient.DeflateRect((rectClient.Width() - rectClient.Height()) / 2, 0);
	}
	else
	{
		rectClient.DeflateRect(0, (rectClient.Height() - rectClient.Width()) / 2);
	}

	ASSERT(abs(rectClient.Height() - rectClient.Width()) <= 1);

	int nCellSize = rectClient.Height() /(2 * AFX_NUM_LEVELS - 1) + 1;

	int x = (rectClient.left + rectClient.right) / 2;
	int y = (rectClient.top + rectClient.bottom) / 2;

	// Add center cell
	m_arCells.Add(new CCellObj(m_pPalette, colorWhite, x, y, nCellSize, 0));

	// for each level
	for (int nLevel = 1; nLevel < AFX_NUM_LEVELS; nLevel++)
	{
		// store the level start position
		int nPosX = x +(nCellSize * nLevel);
		int nPosY = y;

		// for each side
		for (int nSide = 0; nSide < AFX_NUM_LEVELS - 1; nSide++)
		{
			// set the deltas for the side
			int nDx = static_cast<int>(static_cast<float>(nCellSize) * cfxOffset[nSide]);
			int nDy = static_cast<int>(static_cast<float>(nCellSize) * cfyOffset[nSide]);

			// for each cell per side
			for (int nCell = 0; nCell < nLevel; nCell++)
			{
				int nAngle = GetAngleFromPoint(nPosX - x, nPosY - y);

				double L = 1. *(AFX_NUM_LEVELS - nLevel) / AFX_NUM_LEVELS + .1;

				m_arCells.Add(new CCellObj(m_pPalette, CDrawingManager::HLStoRGB_TWO((float) nAngle, L, 1.0F), nPosX, nPosY, nCellSize, 16));

				// offset the position
				nPosX += nDx;
				nPosY += nDy;
			}
		}
	}
}

void CMFCColorPickerCtrl::DrawHex(CDC* pDC)
{
	ASSERT_VALID(pDC);

	afxGlobalData.DrawParentBackground(this, pDC);

	CCellObj* pSelCell = NULL;

	for (int i = 0; i < m_arCells.GetSize(); i ++)
	{
		CCellObj* pCell = (CCellObj*) m_arCells [i];
		ASSERT_VALID(pCell);

		pCell->Draw(pDC);

		if (pCell->m_CellColor == m_colorNew)
		{
			pSelCell = pCell;
		}
	}

	if (pSelCell != NULL)
	{
		pSelCell->DrawSelected(pDC);
	}
}

void CMFCColorPickerCtrl::DrawPicker(CDC* pDC)
{
	CRect rectClient;
	GetClientRect(rectClient);

	CSize szColorPicker = rectClient.Size();

	if (m_bmpPicker.GetSafeHandle() == NULL)
	{
		// Prepare picker's bitmap:
		CDC dcMem;
		if (dcMem.CreateCompatibleDC(pDC) && m_bmpPicker.CreateCompatibleBitmap(pDC, szColorPicker.cx, szColorPicker.cy))
		{
			CBitmap* pOldBmp = dcMem.SelectObject(&m_bmpPicker);

			int nStep = (afxGlobalData.m_nBitsPerPixel > 8) ? 1 : 4;

			for (int i= 0;i<szColorPicker.cy;i += nStep)
			{
				for (int j=0;j<szColorPicker.cx;j += nStep)
				{
					CPoint pt(j, szColorPicker.cy - i - nStep);
					COLORREF color = CDrawingManager::HLStoRGB_ONE((double)j/(double)szColorPicker.cx, AFX_DEFAULT_LUMINANCE, (double)i/(double)szColorPicker.cy);

					if (afxGlobalData.m_nBitsPerPixel > 8) // High/True color
					{
						// Draw exact color:
						dcMem.SetPixelV(pt, color);
					}
					else
					{
						// Draw dithered rectangle:
						CBrush br(color);
						dcMem.FillRect(CRect(pt, CSize(nStep, nStep)), &br);
					}
				}
			}

			dcMem.SelectObject(pOldBmp);
		}
	}

	pDC->DrawState(CPoint(0, 0), szColorPicker, &m_bmpPicker, DSS_NORMAL);
}

void CMFCColorPickerCtrl :: DrawLuminanceBar(CDC* pDC)
{
	CRect rectClient;
	GetClientRect(rectClient);

	rectClient.DeflateRect(0, AFX_DEFAULT_OFFSET_OF_LUMINANCE_BAR);

	for (int y = rectClient.top; y <= rectClient.bottom; y ++)
	{
		COLORREF col = 	CDrawingManager::HLStoRGB_ONE(m_dblHue, LumFromPoint(y), m_dblSat);

		CBrush br(col);
		pDC->FillRect(CRect(0, y, m_nLumBarWidth, y + 1), &br);
	}
}

void CMFCColorPickerCtrl::DrawCursor(CDC* pDC, const CRect& rect)
{
	const int nHalfSize = rect.Width() / 2; // Assume square

	if (m_COLORTYPE == PICKER)
	{
		COLORREF colorFocus = (GetFocus() == this) ? colorBlack : colorWhite;

		pDC->FillSolidRect((rect.left + nHalfSize) - 1, rect.top, 3, 5, colorFocus); // Top
		pDC->FillSolidRect((rect.left + nHalfSize) - 1, rect.bottom - 5, 3, 5, colorFocus); // Bottom
		pDC->FillSolidRect(rect.left, (rect.top + nHalfSize) - 1, 5, 3, colorFocus); // Left
		pDC->FillSolidRect(rect.right - 5, (rect.top + nHalfSize) - 1, 5, 3, colorFocus); // Right
	}
	else if (m_COLORTYPE == LUMINANCE)
	{
		POINT pt[3];
		pt[0].x = rect.left;
		pt[0].y = rect.top + nHalfSize;

		pt[1].x = rect.right - 1;
		pt[1].y = rect.top;

		pt[2].x = rect.right - 1;
		pt[2].y = rect.bottom - 1;

		CPen pen(PS_SOLID, 1, afxGlobalData.clrBtnText);

		CBrush br(GetFocus() == this ? afxGlobalData.clrBtnText : afxGlobalData.clrBtnShadow);

		CBrush* poldBrush = pDC->SelectObject(&br);
		CPen* poldPen = pDC->SelectObject(&pen);

		pDC->Polygon(pt, 3);

		pDC->SelectObject(poldBrush);
		pDC->SelectObject(poldPen);
	}
}

void CMFCColorPickerCtrl::SetOriginalColor(COLORREF ref)
{
	ASSERT(m_COLORTYPE == CURRENT);
	m_colorOriginal = ref;
}

void CMFCColorPickerCtrl::SetHLS(double hue, double luminance, double saturation, BOOL bInvalidate)
{
	if (hue != -1)
		m_dblHue = hue;

	if (saturation != -1)
		m_dblSat = saturation;

	if (luminance != -1)
		m_dblLum = luminance;

	m_colorNew = CDrawingManager::HLStoRGB_TWO(m_dblHue, m_dblSat, m_dblLum);

	if (bInvalidate && GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

void CMFCColorPickerCtrl::GetHLS(double *hue, double *luminance, double *saturation)
{
	*hue = m_dblHue;
	*luminance = m_dblLum;
	*saturation = m_dblSat;
}

void CMFCColorPickerCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	SetCapture();
	SetFocus();

	OnMouseMove(nFlags, point);
}

void CMFCColorPickerCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	if (GetCapture() != this)
	{
		return;
	}

	CRect rectClient;
	GetClientRect(rectClient);

	point.x = min(max(rectClient.left, point.x), rectClient.right);
	point.y = min(max(rectClient.top, point.y), rectClient.bottom);

	switch (m_COLORTYPE)
	{
	case LUMINANCE:
		{
			CRect rectCursorOld = GetCursorRect();
			rectCursorOld.InflateRect(1, 1);

			m_dblLum = LumFromPoint(point.y);
			m_colorNew = CDrawingManager::HLStoRGB_ONE(m_dblHue, m_dblLum, m_dblSat);

			InvalidateRect(rectCursorOld);
			InvalidateRect(GetCursorRect());
		}
		break;

	case PICKER:
		{
			CRect rectCursorOld = GetCursorRect();
			rectCursorOld.InflateRect(1, 1);

			if (nFlags & MK_CONTROL)
			{
				point.x = GetCursorPos().x;
			}

			if (nFlags & MK_SHIFT)
			{
				point.y = GetCursorPos().y;
			}

			m_dblHue = (double) point.x /(double) rectClient.Width();
			m_dblSat = 1. -(double) point.y / rectClient.Height();
			m_colorNew = CDrawingManager::HLStoRGB_ONE(m_dblHue, m_dblLum, m_dblSat);

			InvalidateRect(rectCursorOld);
			InvalidateRect(GetCursorRect());
		}
		break;

	case HEX:
	case HEX_GREYSCALE:
		if (!SelectCellHexagon(point.x, point.y))
		{
			return;
		}

		Invalidate();
		break;
	}

	NotifyParent();
	UpdateWindow();
}

void CMFCColorPickerCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (GetCapture() == this)
		::ReleaseCapture();

	CButton::OnLButtonUp(nFlags, point);
}

// this function must be call before the first paint message
// on the picker control
void CMFCColorPickerCtrl::SetLuminanceBarWidth(int w)
{
	CRect rectClient;
	GetClientRect(rectClient);

	w = min(w, rectClient.Width() * 3 / 4);

	m_nLumBarWidth = w;
	Invalidate();
}

void CMFCColorPickerCtrl::OnSize(UINT nType, int cx, int cy)
{
	CButton::OnSize(nType, cx, cy);

	if (m_bmpPicker.GetSafeHandle() != NULL)
	{
		// picker's bitmap should be rebuild!
		::DeleteObject(m_bmpPicker.Detach());
	}

	Invalidate();
	UpdateWindow();
}

void CMFCColorPickerCtrl::SetType(COLORTYPE colorType)
{
	m_COLORTYPE = colorType;
}

UINT CMFCColorPickerCtrl::OnGetDlgCode()
{
	return DLGC_WANTARROWS;
}

void CMFCColorPickerCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	const double dblDelta = .05;

	switch (m_COLORTYPE)
	{
	case PICKER:
		{
			CRect rectCursorOld = GetCursorRect();
			rectCursorOld.InflateRect(1, 1);

			double dblSat = m_dblSat;
			double dblHue = m_dblHue;

			switch (nChar)
			{
			case VK_UP:
				m_dblSat += dblDelta;
				break;

			case VK_DOWN:
				m_dblSat -= dblDelta;
				break;

			case VK_LEFT:
				m_dblHue -= dblDelta;
				break;

			case VK_RIGHT:
				m_dblHue += dblDelta;
				break;
			}

			m_dblSat = min(1., max(0., m_dblSat));
			m_dblHue = min(1., max(0., m_dblHue));

			if (m_dblHue != dblHue || m_dblSat != dblSat)
			{
				m_colorNew = CDrawingManager::HLStoRGB_ONE(m_dblHue, m_dblLum, m_dblSat);

				InvalidateRect(rectCursorOld);
				InvalidateRect(GetCursorRect());

				NotifyParent();
			}
		}
		break;

	case LUMINANCE:
		{
			CRect rectCursorOld = GetCursorRect();
			rectCursorOld.InflateRect(1, 1);

			double dblLum = m_dblLum;

			switch (nChar)
			{
			case VK_UP:
				m_dblLum += dblDelta;
				break;

			case VK_DOWN:
				m_dblLum -= dblDelta;
				break;
			}

			m_dblLum = min(1., max(0., m_dblLum));
			if (dblLum != m_dblLum)
			{
				m_colorNew = CDrawingManager::HLStoRGB_ONE(m_dblHue, m_dblLum, m_dblSat);

				InvalidateRect(rectCursorOld);
				InvalidateRect(GetCursorRect());

				NotifyParent();
			}
		}
		break;

	case HEX:
	case HEX_GREYSCALE:
	default:
		break;
		// TBD
	}

	CButton::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CMFCColorPickerCtrl::OnSetFocus(CWnd* pOldWnd)
{
	CButton::OnSetFocus(pOldWnd);

	Invalidate();
}

void CMFCColorPickerCtrl::OnKillFocus(CWnd* pNewWnd)
{
	CButton::OnKillFocus(pNewWnd);

	Invalidate();
}

BOOL CMFCColorPickerCtrl::OnQueryNewPalette()
{
	Invalidate();
	return CButton::OnQueryNewPalette();
}

void CMFCColorPickerCtrl::OnPaletteChanged(CWnd* pFocusWnd)
{
	CButton::OnPaletteChanged(pFocusWnd);

	if (pFocusWnd->GetSafeHwnd() != GetSafeHwnd())
	{
		Invalidate();
	}
}

BOOL CMFCColorPickerCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style |= BS_OWNERDRAW;
	cs.style &= ~BS_DEFPUSHBUTTON;

	return CButton::PreCreateWindow(cs);
}

void CMFCColorPickerCtrl::PreSubclassWindow()
{
	ModifyStyle(BS_DEFPUSHBUTTON, BS_OWNERDRAW);
	CButton::PreSubclassWindow();
}

void CMFCColorPickerCtrl::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	ENSURE(lpDIS != NULL);
	ENSURE(lpDIS->CtlType == ODT_BUTTON);
	ASSERT_VALID(m_pPalette);

	CDC* pDCDraw = CDC::FromHandle(lpDIS->hDC);
	ASSERT_VALID(pDCDraw);

	CPalette* pCurPalette = pDCDraw->SelectPalette(m_pPalette, FALSE);
	pDCDraw->RealizePalette();

	CRect rectClip;
	pDCDraw->GetClipBox(rectClip);

	CRect rectClient = lpDIS->rcItem;

	CDC* pDC = pDCDraw;
	BOOL m_bMemDC = FALSE;
	CDC dcMem;
	CBitmap bmp;
	CBitmap* pOldBmp = NULL;
	CPalette* pCurMemPalette = NULL;

	if (dcMem.CreateCompatibleDC(pDCDraw) && bmp.CreateCompatibleBitmap(pDCDraw, rectClient.Width(), rectClient.Height()))
	{
		// Off-screen DC successfully created. Better paint to it then!
		m_bMemDC = TRUE;
		pOldBmp = dcMem.SelectObject(&bmp);
		pDC = &dcMem;

		pCurMemPalette = pDC->SelectPalette(m_pPalette, FALSE);
		pDC->RealizePalette();

		afxGlobalData.DrawParentBackground(this, pDC);
	}

	switch (m_COLORTYPE)
	{
	case HEX:
		CreateHexagon();
		DrawHex(pDC);
		break;

	case HEX_GREYSCALE:
		CreateHexGreyScaleBar();
		DrawHex(pDC);
		break;

	case CURRENT:
		{
			COLORREF clrText = pDC->GetTextColor();

			int nHalf = rectClient.Height() / 2;
			pDC->FillSolidRect(0, 0, rectClient.Width(), nHalf, m_colorNew);
			pDC->FillSolidRect(0, nHalf, rectClient.Width(), nHalf, m_colorOriginal);

			pDC->SetTextColor(clrText); // Text color was changed by FillSolidRect

			// Draw frame
			pDC->Draw3dRect(rectClient, afxGlobalData.clrBtnDkShadow, afxGlobalData.clrBtnDkShadow);
		}
		break;

	case PICKER:
		DrawPicker(pDC);
		DrawCursor(pDC, GetCursorRect());
		pDC->Draw3dRect(rectClient, afxGlobalData.clrBtnDkShadow, afxGlobalData.clrBtnHilite);
		break;

	case LUMINANCE:
		DrawLuminanceBar(pDC);

		// Draw marker:
		afxGlobalData.DrawParentBackground(this, pDC, CRect(m_nLumBarWidth, 0, rectClient.Width() - m_nLumBarWidth, rectClient.Height()));
		DrawCursor(pDC, GetCursorRect());
		break;
	}

	if (m_bMemDC)
	{
		// Copy the results to the on-screen DC:
		pDCDraw->BitBlt(rectClip.left, rectClip.top, rectClip.Width(), rectClip.Height(), &dcMem, rectClip.left, rectClip.top, SRCCOPY);

		if (pCurMemPalette != NULL)
		{
			dcMem.SelectPalette(pCurMemPalette, FALSE);
		}

		dcMem.SelectObject(pOldBmp);
	}

	if (pCurPalette != NULL)
	{
		pDCDraw->SelectPalette(pCurPalette, FALSE);
	}
}

void CMFCColorPickerCtrl::SetPalette(CPalette* pPalette)
{
	ASSERT_VALID(pPalette);
	m_pPalette = pPalette;

	if (m_bmpPicker.GetSafeHandle() != NULL)
	{
		// picker's bitmap should be rebuild!
		::DeleteObject(m_bmpPicker.Detach());
	}

	if (GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

BOOL CMFCColorPickerCtrl::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

double CMFCColorPickerCtrl::LumFromPoint(int nY)
{
	ASSERT(m_COLORTYPE == LUMINANCE);

	CRect rectClient;
	GetClientRect(rectClient);

	rectClient.DeflateRect(0, AFX_DEFAULT_OFFSET_OF_LUMINANCE_BAR);

	nY = min(max(rectClient.top, nY), rectClient.bottom);
	return((double) rectClient.bottom - nY) / rectClient.Height();
}

int CMFCColorPickerCtrl::PointFromLum(double dblLum)
{
	ASSERT(m_COLORTYPE == LUMINANCE);

	CRect rectClient;
	GetClientRect(rectClient);

	rectClient.DeflateRect(0, AFX_DEFAULT_OFFSET_OF_LUMINANCE_BAR);
	return rectClient.top +(int)((1. - dblLum) * rectClient.Height());
}

CPoint CMFCColorPickerCtrl::GetCursorPos()
{
	CRect rectClient;
	GetClientRect(rectClient);

	CPoint point(0, 0);

	switch (m_COLORTYPE)
	{
	case LUMINANCE:
		point =  CPoint(rectClient.left + m_nLumBarWidth + 6, PointFromLum(m_dblLum));
		break;

	case PICKER:
		point =  CPoint((long)((double) rectClient.Width() * m_dblHue),
			(long)((1. - m_dblSat) * rectClient.Height()));
		break;

	case HEX:
	case HEX_GREYSCALE:
	default:
		ASSERT(FALSE);
	}

	return point;
}

CRect CMFCColorPickerCtrl::GetCursorRect()
{
	CRect rect;

	switch (m_COLORTYPE)
	{
	case PICKER:
		rect = CRect(GetCursorPos(), CSize(AFX_PICKER_CURSOR_SIZE, AFX_PICKER_CURSOR_SIZE));
		break;

	case LUMINANCE:
		rect = CRect(GetCursorPos(), CSize(AFX_LUM_CURSOR_SIZE, AFX_LUM_CURSOR_SIZE));
		break;

	case HEX:
	case HEX_GREYSCALE:
	default:
		ASSERT(FALSE);
		rect.SetRectEmpty();
	}

	rect.OffsetRect(-rect.Width() / 2, -rect.Height() / 2);
	return rect;
}

void CMFCColorPickerCtrl::OnCancelMode()
{
	CButton::OnCancelMode();
}

void CMFCColorPickerCtrl::NotifyParent()
{
	CWnd* pParent = GetParent();
	if (pParent != NULL)
	{
		pParent->SendMessage( WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM) GetSafeHwnd());
	}
}

void CMFCColorPickerCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	switch (m_COLORTYPE)
	{
	case PICKER:
	case HEX:
	case HEX_GREYSCALE:
		{
			if (SelectCellHexagon(point.x, point.y))
			{
				CWnd* pParent = GetParent();
				if (pParent != NULL)
				{
					pParent->SendMessage( WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_DOUBLECLICKED), (LPARAM) GetSafeHwnd());
				}
			}

			return;
		}
	}

	CButton::OnLButtonDblClk(nFlags, point);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcolordialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxcontrolbarutil.h"
#include "afxcolordialog.h"
#include "afxcolorpropertysheet.h"
#include "afxglobals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CScreenWnd window

class CScreenWnd : public CWnd
{
// Construction
public:
	CScreenWnd();

// Overrides
public:
	virtual BOOL Create(CMFCColorDialog* pColorDlg);

// Implementation
public:
	virtual ~CScreenWnd();

// Generated message map functions
protected:
	//{{AFX_MSG(CScreenWnd)
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMFCColorDialog* m_pColorDlg;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCColorDialog dialog

CMFCColorDialog::CMFCColorDialog(COLORREF clrInit, DWORD /*dwFlags - reserved */, CWnd* pParentWnd, HPALETTE hPal)
	: CDialogEx(CMFCColorDialog::IDD, pParentWnd)
{
	//{{AFX_DATA_INIT(CMFCColorDialog)
	//}}AFX_DATA_INIT

	m_pColourSheetOne = NULL;
	m_pColourSheetTwo = NULL;

	m_CurrentColor = m_NewColor = clrInit;
	m_pPropSheet = NULL;
	m_bIsMyPalette = TRUE;
	m_pPalette = NULL;

	if (hPal != NULL)
	{
		m_pPalette = CPalette::FromHandle(hPal);
		m_bIsMyPalette = FALSE;
	}

	m_bPickerMode = FALSE;
}

CMFCColorDialog::~CMFCColorDialog()
{
	if (m_pColourSheetOne != NULL)
	{
		delete m_pColourSheetOne;
	}

	if (m_pColourSheetTwo != NULL)
	{
		delete m_pColourSheetTwo;
	}
}

void CMFCColorDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CMFCColorDialog)
	DDX_Control(pDX, IDC_AFXBARRES_COLOR_SELECT, m_btnColorSelect);
	DDX_Control(pDX, IDC_AFXBARRES_STATICPLACEHOLDER, m_wndStaticPlaceHolder);
	DDX_Control(pDX, IDC_AFXBARRES_COLOURPLACEHOLDER, m_wndColors);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCColorDialog, CDialogEx)
	//{{AFX_MSG_MAP(CMFCColorDialog)
	ON_WM_DESTROY()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_SETCURSOR()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_BN_CLICKED(IDC_AFXBARRES_COLOR_SELECT, &CMFCColorDialog::OnColorSelect)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCColorDialog message handlers

BOOL CMFCColorDialog::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	if (AfxGetMainWnd() != NULL && (AfxGetMainWnd()->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		ModifyStyleEx(0, WS_EX_LAYOUTRTL);
	}

	if (afxGlobalData.m_nBitsPerPixel < 8) // 16 colors, call standard dialog
	{
		CColorDialog dlg(m_CurrentColor, CC_FULLOPEN | CC_ANYCOLOR);
		int nResult = (int) dlg.DoModal();
		m_NewColor = dlg.GetColor();
		EndDialog(nResult);

		return TRUE;
	}

	if (m_pPalette == NULL)
	{
		m_pPalette = new CPalette();
		RebuildPalette();
	}

	m_wndColors.SetType(CMFCColorPickerCtrl::CURRENT);
	m_wndColors.SetPalette(m_pPalette);

	m_wndColors.SetOriginalColor(m_CurrentColor);
	m_wndColors.SetColor(m_NewColor);

	// Create property sheet.
	m_pPropSheet = new CMFCColorPropertySheet(_T(""), this);
	ENSURE(m_pPropSheet);

	m_pColourSheetOne = new CMFCStandardColorsPropertyPage;
	m_pColourSheetTwo = new CMFCCustomColorsPropertyPage;

	// Set parent dialog.
	m_pColourSheetOne->m_pDialog = this;
	m_pColourSheetTwo->m_pDialog = this;

	m_pPropSheet->AddPage(m_pColourSheetOne);
	m_pPropSheet->AddPage(m_pColourSheetTwo);

	// Retrieve the location of the window
	CRect rectListWnd;
	m_wndStaticPlaceHolder.GetWindowRect(rectListWnd);
	ScreenToClient(rectListWnd);

	if (!m_pPropSheet->Create(this, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, 0))
	{
		TRACE0("CMFCColorDialog::OnInitDialog(): Can't create the property sheet.....\n");
	}

	m_pPropSheet->SetWindowPos(NULL, rectListWnd.left, rectListWnd.top, rectListWnd.Width(), rectListWnd.Height(), SWP_NOZORDER | SWP_NOACTIVATE);

	SetPageOne(GetRValue(m_CurrentColor), GetGValue(m_CurrentColor), GetBValue(m_CurrentColor));
	SetPageTwo(GetRValue(m_CurrentColor), GetGValue(m_CurrentColor), GetBValue(m_CurrentColor));

	m_btnColorSelect.SetImage(IDB_AFXBARRES_COLOR_PICKER);

	m_hcurPicker = AfxGetApp()->LoadCursor(IDC_AFXBARRES_COLOR);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CMFCColorDialog::SetCurrentColor(COLORREF rgb)
{
	m_CurrentColor = rgb;
}

void CMFCColorDialog::SetPageOne(BYTE R, BYTE G, BYTE B)
{
	m_pColourSheetOne->m_hexpicker.SelectCellHexagon(R, G, B);
	m_pColourSheetOne->m_hexpicker_greyscale.SelectCellHexagon(R, G, B);
}

void CMFCColorDialog::SetPageTwo(BYTE R, BYTE G, BYTE B)
{
	m_pColourSheetTwo->Setup(R, G, B);
}

void CMFCColorDialog::OnDestroy()
{
	if (m_bIsMyPalette && m_pPalette != NULL)
	{
		m_pPalette->DeleteObject();
		delete m_pPalette;
		m_pPalette = NULL;
	}

	CDialogEx::OnDestroy();
}

void CMFCColorDialog::SetNewColor(COLORREF rgb)
{
	m_NewColor = rgb;

	if (afxGlobalData.m_nBitsPerPixel == 8) // 256 colors
	{
		ENSURE(m_pPalette != NULL);

		UINT uiPalIndex = m_pPalette->GetNearestPaletteIndex(rgb);
		m_wndColors.SetColor(PALETTEINDEX(uiPalIndex));
	}
	else
	{
		m_wndColors.SetColor(rgb);
	}

	m_wndColors.Invalidate();
	m_wndColors.UpdateWindow();
}

void CMFCColorDialog::OnSysColorChange()
{
	CDialogEx::OnSysColorChange();

	afxGlobalData.UpdateSysColors();

	if (m_bIsMyPalette)
	{
		if (afxGlobalData.m_nBitsPerPixel < 8) // 16 colors, call standard dialog
		{
			ShowWindow(SW_HIDE);

			CColorDialog dlg(m_CurrentColor, CC_FULLOPEN | CC_ANYCOLOR);
			int nResult = (int) dlg.DoModal();
			m_NewColor = dlg.GetColor();
			EndDialog(nResult);
		}
		else
		{
			::DeleteObject(m_pPalette->Detach());
			RebuildPalette();

			Invalidate();
			UpdateWindow();
		}
	}
}

void CMFCColorDialog::RebuildPalette()
{
	ENSURE(m_pPalette->GetSafeHandle() == NULL);

	// Create palette:
	CClientDC dc(this);

	int nColors = 256; // Use 256 first entries
	UINT nSize = sizeof(LOGPALETTE) +(sizeof(PALETTEENTRY) * nColors);
	LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];

	pLP->palVersion = 0x300;
	pLP->palNumEntries = (USHORT) nColors;

	::GetSystemPaletteEntries(dc.GetSafeHdc(), 0, nColors, pLP->palPalEntry);

	m_pPalette->CreatePalette(pLP);

	delete[] pLP;
}

void CMFCColorDialog::OnColorSelect()
{
	if (m_bPickerMode)
	{
		return;
	}

	CWinThread* pCurrThread = ::AfxGetThread();
	if (pCurrThread == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	MSG msg;
	m_bPickerMode = TRUE;;
	::SetCursor(m_hcurPicker);

	CScreenWnd* pScreenWnd = new CScreenWnd;
	if (!pScreenWnd->Create(this))
	{
		return;
	}

	SetForegroundWindow();
	BringWindowToTop();

	SetCapture();

	COLORREF colorSaved = m_NewColor;

	while (m_bPickerMode)
	{
		while (m_bPickerMode && ::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			if (msg.message == WM_KEYDOWN)
			{
				switch (msg.wParam)
				{
				case VK_RETURN:
					m_bPickerMode = FALSE;
					break;

				case VK_ESCAPE:
					SetNewColor(colorSaved);
					m_bPickerMode = FALSE;
					break;
				}
			}
			else if (msg.message == WM_RBUTTONDOWN || msg.message == WM_MBUTTONDOWN)
			{
				m_bPickerMode = FALSE;
			}
			else
			{
				if (!pCurrThread->PreTranslateMessage(&msg))
				{
					::TranslateMessage(&msg);
					::DispatchMessage(&msg);
				}

				pCurrThread->OnIdle(0);
			}
		}

		WaitMessage();
	}

	ReleaseCapture();
	pScreenWnd->DestroyWindow();
	delete pScreenWnd;

	m_bPickerMode = FALSE;
}

BOOL CMFCColorDialog::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (m_bPickerMode)
	{
		::SetCursor(m_hcurPicker);
		return TRUE;
	}

	return CDialogEx::OnSetCursor(pWnd, nHitTest, message);
}

void CMFCColorDialog::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bPickerMode)
	{
		ClientToScreen(&point);

		CClientDC dc(NULL);
		SetNewColor(dc.GetPixel(point));
	}

	CDialogEx::OnMouseMove(nFlags, point);
}

void CMFCColorDialog::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_bPickerMode = FALSE;

	SetPageOne(GetRValue(m_NewColor), GetGValue(m_NewColor), GetBValue(m_NewColor));
	SetPageTwo(GetRValue(m_NewColor), GetGValue(m_NewColor), GetBValue(m_NewColor));

	CDialogEx::OnLButtonDown(nFlags, point);
}

/////////////////////////////////////////////////////////////////////////////
// CScreenWnd

CScreenWnd::CScreenWnd()
{
}

CScreenWnd::~CScreenWnd()
{
}

BEGIN_MESSAGE_MAP(CScreenWnd, CWnd)
	//{{AFX_MSG_MAP(CScreenWnd)
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_SETCURSOR()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScreenWnd message handlers

BOOL CScreenWnd::Create(CMFCColorDialog* pColorDlg)
{
	CWnd* pWndDesktop = GetDesktopWindow();
	if (pWndDesktop == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	m_pColorDlg = pColorDlg;

	CRect rectScreen;
	pWndDesktop->GetWindowRect(rectScreen);

	CString strClassName = ::AfxRegisterWndClass(CS_SAVEBITS, AfxGetApp()->LoadCursor(IDC_AFXBARRES_COLOR), (HBRUSH)(COLOR_BTNFACE + 1), NULL);

	return CWnd::CreateEx(WS_EX_TOOLWINDOW | WS_EX_TRANSPARENT, strClassName, _T(""), WS_VISIBLE | WS_POPUP, rectScreen, NULL, 0);
}

void CScreenWnd::OnMouseMove(UINT nFlags, CPoint point)
{
	MapWindowPoints(m_pColorDlg, &point, 1);
	m_pColorDlg->SendMessage(WM_MOUSEMOVE, nFlags, MAKELPARAM(point.x, point.y));

	CWnd::OnMouseMove(nFlags, point);
}

void CScreenWnd::OnLButtonDown(UINT nFlags, CPoint point)
{
	MapWindowPoints(m_pColorDlg, &point, 1);
	m_pColorDlg->SendMessage(WM_LBUTTONDOWN, nFlags, MAKELPARAM(point.x, point.y));
}

BOOL CScreenWnd::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

BOOL CMFCColorDialog::PreTranslateMessage(MSG* pMsg)
{
#ifdef _UNICODE
#define AFX_TCF_TEXT CF_UNICODETEXT
#else
#define AFX_TCF_TEXT CF_TEXT
#endif

	if (pMsg->message == WM_KEYDOWN)
	{
		UINT nChar = (UINT) pMsg->wParam;
		BOOL bIsCtrl = (::GetAsyncKeyState(VK_CONTROL) & 0x8000);

		if (bIsCtrl &&(nChar == _T('C') || nChar == VK_INSERT))
		{
			if (OpenClipboard())
			{
				EmptyClipboard();

				CString strText;
				strText.Format(_T("RGB(%d, %d, %d)"), GetRValue(m_NewColor), GetGValue(m_NewColor), GetBValue(m_NewColor));

				HGLOBAL hClipbuffer = ::GlobalAlloc(GMEM_DDESHARE, (strText.GetLength() + 1) * sizeof(TCHAR));
				LPTSTR lpszBuffer = (LPTSTR) GlobalLock(hClipbuffer);

				lstrcpy(lpszBuffer, (LPCTSTR) strText);

				::GlobalUnlock(hClipbuffer);
				::SetClipboardData(AFX_TCF_TEXT, hClipbuffer);

				CloseClipboard();
			}
		}
	}

	return CDialogEx::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcolorbar.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include <math.h>
#include "afxcontrolbarutil.h"
#include "afxcolorbar.h"
#include "afxcolormenubutton.h"
#include "afxpopupmenu.h"
#include "afxcolordialog.h"
#include "afxcolorbutton.h"
#include "afxtrackmouse.h"
#include "afxvisualmanager.h"
#include "afxpropertygridctrl.h"
#include "afxribboncolorbutton.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int SEPARATOR_SIZE = 2;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarColorButton

class CMFCToolBarColorButton : public CMFCToolBarButton
{
	friend class CMFCColorBar;

	DECLARE_SERIAL(CMFCToolBarColorButton)

protected:
	CMFCToolBarColorButton(COLORREF color = RGB(0, 0, 0), BOOL bIsAutomatic = FALSE, BOOL bIsOther = FALSE,
		LPCTSTR lpszColorName = NULL, BOOL bHighlight = FALSE, BOOL bIsDocument = FALSE, BOOL bIsOtherColor = FALSE)
	{
		m_Color = color;
		m_bHighlight = bHighlight;
		m_strText = (lpszColorName == NULL) ? _T("") : lpszColorName;
		m_bIsAutomatic = bIsAutomatic;
		m_bIsOther = bIsOther;
		m_bIsLabel = FALSE;
		m_bIsDocument = bIsDocument;
		m_bIsOtherColor = bIsOtherColor;
		m_pParentBar = NULL;
		m_bLocked = TRUE;
	}

	CMFCToolBarColorButton(LPCTSTR lpszColorName, BOOL bIsDocument = FALSE)
	{
		ENSURE(lpszColorName != NULL);

		m_Color = (COLORREF)-1;
		m_bHighlight = FALSE;
		m_strText = lpszColorName;
		m_bIsAutomatic = FALSE;
		m_bIsOther = FALSE;
		m_bIsLabel = TRUE;
		m_bIsDocument = bIsDocument;
		m_bIsOtherColor = FALSE;
		m_pParentBar = NULL;
		m_bLocked = TRUE;
	}

	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE, BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);

	virtual BOOL OnToolHitTest(const CWnd* pWnd, TOOLINFO* pTI)
	{
		UNREFERENCED_PARAMETER(pWnd);

		if (m_nStyle & TBBS_DISABLED)
		{
			return FALSE;
		}

		if (!CMFCToolBar::GetShowTooltips() || pTI == NULL)
		{
			return FALSE;
		}

		CString str = m_strText;
		if (!m_bIsAutomatic && !m_bIsOther && !m_bIsLabel)
		{
			if (!CMFCColorBar::m_ColorNames.Lookup(m_Color, str))
			{
				str.Format(_T("Hex={%02X,%02X,%02X}"), GetRValue(m_Color), GetGValue(m_Color), GetBValue(m_Color));
			}
		}

		pTI->lpszText = (LPTSTR) ::calloc((str.GetLength() + 1), sizeof(TCHAR));
		if (pTI->lpszText == NULL)
		{
			return FALSE;
		}

		lstrcpy(pTI->lpszText, str);

		return TRUE;
	}

	virtual void OnChangeParentWnd(CWnd* pWndParent)
	{
		CMFCToolBarButton::OnChangeParentWnd(pWndParent);
		m_pParentBar = DYNAMIC_DOWNCAST(CMFCColorBar, pWndParent);
	}

	COLORREF m_Color;
	BOOL m_bHighlight;
	BOOL m_bIsAutomatic;
	BOOL m_bIsOther;
	BOOL m_bIsLabel;
	BOOL m_bIsDocument;
	BOOL m_bIsOtherColor;
	CMFCColorBar* m_pParentBar;
};

IMPLEMENT_SERIAL(CMFCToolBarColorButton, CMFCToolBarButton, 1)

void CMFCToolBarColorButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* /*pImages*/, BOOL bHorz, BOOL bCustomizeMode, BOOL bHighlight, BOOL bDrawBorder, BOOL /*bGrayDisabledButtons*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	CPalette* pOldPalette = NULL;

	if (m_pParentBar != NULL)
	{
		pOldPalette = m_pParentBar->SelectPalette(pDC);
	}

	BOOL bDisabled = (m_nStyle & TBBS_DISABLED);

	UINT nStyle = m_nStyle;

	if (m_bHighlight)
	{
		m_nStyle |= TBBS_CHECKED;
	}

	// Fill button interior:
	FillInterior(pDC, rect, bHighlight && !m_bIsLabel);

	// Draw button border:
	if (!bDisabled && !m_bIsLabel && HaveHotBorder() && bDrawBorder && !bCustomizeMode)
	{
		if (m_nStyle &(TBBS_PRESSED | TBBS_CHECKED))
		{
			// Pressed in or checked:
			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsPressed);
		}
		else if (bHighlight && !(m_nStyle &(TBBS_CHECKED | TBBS_INDETERMINATE)))
		{
			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsHighlighted);
		}
	}

	CRect rectFrame = rect;
	rectFrame.DeflateRect(afxData.cxBorder2, afxData.cyBorder2);

	if (m_bIsOther || m_bIsAutomatic || m_bIsLabel)
	{
		CRect rectText = rect;

		if (m_bIsAutomatic && m_Color != (COLORREF)-1)
		{
			CRect rectColor = rectFrame;
			rectColor.DeflateRect(afxData.cxBorder2 + 1, afxData.cyBorder2 + 1);
			rectColor.right = rectColor.left + rectColor.Height();

			if (!bDisabled)
			{
				CBrush br(PALETTERGB(GetRValue(m_Color), GetGValue(m_Color), GetBValue(m_Color)));
				CPen pen(PS_SOLID, 1, afxGlobalData.clrBarShadow);

				CBrush* pOldBrush = pDC->SelectObject(&br);
				CPen* pOldPen = pDC->SelectObject(&pen);

				pDC->Rectangle(rectColor);

				pDC->SelectObject(pOldPen);
				pDC->SelectObject(pOldBrush);
			}
			else
			{
				pDC->Draw3dRect(rectColor, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
				rectColor.OffsetRect(1, 1);
				pDC->Draw3dRect(rectColor, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
			}

			rectText.left = rectColor.right + afxData.cxBorder2;
		}

		// Draw label:
		pDC->SetTextColor((m_nStyle & TBBS_DISABLED) && !m_bIsLabel ? afxGlobalData.clrGrayedText : afxGlobalData.clrBarText);

		UINT nFormat = DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS;
		if (!m_bIsLabel)
		{
			nFormat |= DT_CENTER;
		}

		CFont* pCurrFont = NULL;
		if (!bHorz)
		{
			pCurrFont = pDC->SelectObject(&afxGlobalData.fontRegular);
			ENSURE(pCurrFont != NULL);
		}

		pDC->DrawText(m_strText, &rectText, nFormat);

		if (pCurrFont != NULL)
		{
			pDC->SelectObject(pCurrFont);
		}
	}
	else if (!bDisabled)
	{
		// Draw color box:
		CBrush br(PALETTERGB(GetRValue(m_Color), GetGValue(m_Color), GetBValue(m_Color)));

		CBrush* pOldBrush = pDC->SelectObject(&br);
		CPen* pOldPen = (CPen*) pDC->SelectObject(&afxGlobalData.penBarShadow);

		rectFrame.right--;
		rectFrame.bottom--;

		pDC->Rectangle(rectFrame);

		pDC->SelectObject(pOldPen);
		pDC->SelectObject(pOldBrush);
	}

	// Draw frame:
	if (!m_bIsOther && !m_bIsLabel)
	{
		if (!bDisabled)
		{
			pDC->Draw3dRect(rectFrame, afxGlobalData.clrBarShadow, afxGlobalData.clrBarShadow);
		}
		else
		{
			pDC->Draw3dRect(rectFrame, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
			rectFrame.OffsetRect(1, 1);
			pDC->Draw3dRect(rectFrame, afxGlobalData.clrBarShadow, afxGlobalData.clrBarHilite);
		}
	}

	if (pOldPalette != NULL)
	{
		pDC->SelectPalette(pOldPalette, FALSE);
	}

	m_nStyle = nStyle;
}

/////////////////////////////////////////////////////////////////////////////
// CMFCColorBar

IMPLEMENT_SERIAL(CMFCColorBar, CMFCPopupMenuBar, 1)

CMap<COLORREF,COLORREF,CString, LPCTSTR> CMFCColorBar::m_ColorNames;

CMFCColorBar::CMFCColorBar()
{
	m_nNumColumns = 0;
	m_nNumRowsHorz = 0;
	m_nNumColumnsVert = 0;
	m_BoxSize = CSize(0, 0);
	m_nRowHeight = 0;
	m_ColorSelected = (COLORREF) -1;
	m_ColorAutomatic = (COLORREF) -1;
	m_nCommandID = 0;
	m_bStdColorDlg = FALSE;
	m_bIsTearOff = TRUE;
	m_bShowDocColorsWhenDocked = FALSE;
	m_bLocked = TRUE;
	m_bIsEnabled = TRUE;
	m_pParentBtn = NULL;
	m_pParentRibbonBtn = NULL;
	m_pWndPropList = NULL;
	m_nHorzOffset = m_nVertOffset = 0;
	m_bInternal = FALSE;
	m_nVertMargin = 4;
	m_nHorzMargin = 4;
}

CMFCColorBar::CMFCColorBar(const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor, LPCTSTR lpszDocColors,
		CList<COLORREF,COLORREF>& lstDocColors, int nColumns, int nRowsDockHorz, int nColDockVert, COLORREF colorAutomatic, UINT nCommandID, CMFCColorButton* pParentBtn) :
	m_ColorSelected(color), m_strAutoColor(lpszAutoColor == NULL ? _T("") : lpszAutoColor), m_strOtherColor(lpszOtherColor == NULL ? _T("") : lpszOtherColor),
	m_strDocColors(lpszDocColors == NULL ? _T("") : lpszDocColors), m_nNumColumns(nColumns), m_nNumRowsHorz(nRowsDockHorz), m_nNumColumnsVert(nColDockVert),
	m_ColorAutomatic(colorAutomatic), m_bIsTearOff(FALSE), m_bStdColorDlg(FALSE), m_nCommandID(nCommandID), m_pParentBtn(pParentBtn)
{
	m_pWndPropList = NULL;
	m_pParentRibbonBtn = NULL;

	m_colors.SetSize(colors.GetSize());

	for (int i = 0; i < colors.GetSize(); i++)
	{
		m_colors [i] = colors [i];
	}

	m_lstDocColors.AddTail(&lstDocColors);
	m_bLocked = TRUE;
	m_bIsEnabled = TRUE;
	m_bShowDocColorsWhenDocked = TRUE;

	if (m_pParentBtn != NULL)
	{
		m_bStdColorDlg = !m_pParentBtn->m_bAltColorDlg;
	}

	m_nHorzOffset = m_nVertOffset = 0;
	m_bInternal = FALSE;
	m_nVertMargin = 4;
	m_nHorzMargin = 4;
}

CMFCColorBar::CMFCColorBar(const CArray<COLORREF, COLORREF>& colors, COLORREF color, LPCTSTR lpszAutoColor, LPCTSTR lpszOtherColor, LPCTSTR lpszDocColors,
		CList<COLORREF,COLORREF>& lstDocColors, int nColumns, COLORREF colorAutomatic, UINT nCommandID, CMFCRibbonColorButton* pParentRibbonBtn) :
	m_ColorSelected(color), m_strAutoColor(lpszAutoColor == NULL ? _T("") : lpszAutoColor), m_strOtherColor(lpszOtherColor == NULL ? _T("") : lpszOtherColor),
	m_strDocColors(lpszDocColors == NULL ? _T("") : lpszDocColors), m_nNumColumns(nColumns), m_nNumRowsHorz(0), m_nNumColumnsVert(0), m_ColorAutomatic(colorAutomatic),
	m_bIsTearOff(FALSE), m_bStdColorDlg(FALSE), m_nCommandID(nCommandID), m_pParentRibbonBtn(pParentRibbonBtn)
{
	m_pWndPropList = NULL;
	m_pParentBtn = NULL;

	m_colors.SetSize(colors.GetSize());

	for (int i = 0; i < colors.GetSize(); i++)
	{
		m_colors [i] = colors [i];
	}

	m_lstDocColors.AddTail(&lstDocColors);
	m_bLocked = TRUE;
	m_bIsEnabled = TRUE;
	m_bShowDocColorsWhenDocked = TRUE;

	m_bStdColorDlg = FALSE;

	m_nHorzOffset = m_nVertOffset = 0;
	m_bInternal = FALSE;
	m_nVertMargin = 4;
	m_nHorzMargin = 4;
}

CMFCColorBar::CMFCColorBar(CMFCColorBar& src, UINT uiCommandID) :
	m_ColorSelected(src.m_ColorSelected), m_strAutoColor(src.m_strAutoColor), m_strOtherColor(src.m_strOtherColor), m_strDocColors(src.m_strDocColors),
	m_ColorAutomatic(src.m_ColorAutomatic), m_nNumColumns(src.m_nNumColumns), m_nNumRowsHorz(src.m_nNumRowsHorz), m_nNumColumnsVert(src.m_nNumColumnsVert),
	m_bIsTearOff(TRUE), m_nCommandID(uiCommandID), m_bStdColorDlg(src.m_bStdColorDlg)
{
	m_colors.SetSize(src.m_colors.GetSize());

	for (int i = 0; i < src.m_colors.GetSize(); i++)
	{
		m_colors [i] = src.m_colors [i];
	}

	m_lstDocColors.AddTail(&src.m_lstDocColors);
	m_bLocked = TRUE;
	m_bIsEnabled = TRUE;
	m_bShowDocColorsWhenDocked = FALSE;
	m_pParentBtn = NULL;
	m_pParentRibbonBtn = NULL;
	m_pWndPropList = NULL;
	m_nHorzOffset = m_nVertOffset = 0;
	m_bInternal = FALSE;
	m_nVertMargin = 4;
	m_nHorzMargin = 4;
}

CMFCColorBar::~CMFCColorBar()
{
}

void CMFCColorBar::AdjustLocations()
{
	if (GetSafeHwnd() == NULL || !::IsWindow(m_hWnd) || m_bInUpdateShadow)
	{
		return;
	}

	ASSERT_VALID(this);

	CRect rectClient; // Client area rectangle
	GetClientRect(&rectClient);

	rectClient.DeflateRect(m_nHorzMargin + m_nHorzOffset, m_nVertMargin + m_nVertOffset);

	int x = rectClient.left;
	int y = rectClient.top;
	int i = 0;

	BOOL bPrevSeparator = FALSE;
	BOOL bIsOtherColor = (m_strAutoColor.IsEmpty() || m_ColorSelected != (COLORREF)-1);

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; i ++)
	{
		CRect rectButton(0, 0, 0, 0);

		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			if (bPrevSeparator)
			{
				rectButton.SetRectEmpty();
			}
			else
			{
				if (x > rectClient.left)
				{
					// Next line
					x = rectClient.left;
					y += m_BoxSize.cy + m_nVertMargin;
				}

				rectButton = CRect(CPoint(x, y), CSize(rectClient.Width(), SEPARATOR_SIZE));

				y += SEPARATOR_SIZE + 2;
				x = rectClient.left;
			}

			bPrevSeparator = TRUE;
		}
		else
		{
			CMFCToolBarColorButton* pColorButton = DYNAMIC_DOWNCAST(CMFCToolBarColorButton, pButton);
			if (pColorButton == NULL)
			{
				continue;
			}

			ASSERT_VALID(pColorButton);

			if (pColorButton->m_bIsDocument && !m_bShowDocColorsWhenDocked && !IsFloating())
			{
				rectButton.SetRectEmpty();
			}
			else if (pColorButton->m_bIsAutomatic || pColorButton->m_bIsOther || pColorButton->m_bIsLabel)
			{
				if (x > rectClient.left)
				{
					// Next line
					x = rectClient.left;
					y += m_BoxSize.cy + m_nVertMargin;
				}

				if (pColorButton->m_bIsOther && bIsOtherColor)
				{
					rectButton = CRect(CPoint(x, y), CSize(rectClient.Width() - m_BoxSize.cx, m_nRowHeight - m_nVertMargin / 2));
					x = rectButton.right;
					y += (rectButton.Height() - m_BoxSize.cy) / 2;
				}
				else
				{
					rectButton = CRect(CPoint(x, y), CSize(rectClient.Width(), m_nRowHeight - m_nVertMargin / 2));
					y += m_nRowHeight - m_nVertMargin / 2;
					x = rectClient.left;
				}

				if (pColorButton->m_bIsOther)
				{
					rectButton.DeflateRect(m_nHorzMargin / 2, m_nVertMargin / 2);
				}

				bPrevSeparator = FALSE;
			}
			else
			{
				if (x + m_BoxSize.cx > rectClient.right)
				{
					x = rectClient.left;
					y += m_BoxSize.cy;
				}

				if (pColorButton->m_bIsOtherColor && !bIsOtherColor)
				{
					rectButton.SetRectEmpty();
				}
				else
				{
					rectButton = CRect(CPoint(x, y), m_BoxSize);
					x += m_BoxSize.cx;

					bPrevSeparator = FALSE;
				}

				if (pColorButton->m_Color == m_ColorSelected && !pColorButton->m_bIsOtherColor)
				{
					bIsOtherColor = FALSE;
				}
			}
		}

		pButton->SetRect(rectButton);
	}

	UpdateTooltips();
}

CSize CMFCColorBar::CalcSize(BOOL bVertDock)
{
	CSize sizeGrid = GetColorGridSize(bVertDock);

	return CSize(sizeGrid.cx * m_BoxSize.cx + 2 * m_nVertMargin, sizeGrid.cy * m_BoxSize.cy + GetExtraHeight(sizeGrid.cx) + 2 * m_nHorzMargin);
}

CSize CMFCColorBar::GetColorGridSize(BOOL bVertDock) const
//
// Calculate number of columns and rows in the color grid
//
{
	int nNumColumns = 0;
	int nNumRows = 0;

	int nColors = (int) m_colors.GetSize();

	if (!m_bIsTearOff || IsFloating() || bVertDock || m_nNumRowsHorz <= 0)
	{
		nNumColumns = !m_bIsTearOff || IsFloating() || m_nNumColumnsVert <= 0 ? m_nNumColumns : m_nNumColumnsVert;
		if (nNumColumns <= 0)
		{
			nNumColumns = (int)(sqrt((double) nColors)) + 1;
		}

		nNumRows = nColors / nNumColumns;
		if ((nColors % nNumColumns) != 0)
		{
			nNumRows ++;
		}
	}
	else // Horz dock
	{
		nNumRows = m_nNumRowsHorz;
		nNumColumns = nColors / nNumRows;

		if ((nColors % nNumRows) != 0)
		{
			nNumColumns ++;
		}
	}

	return CSize(nNumColumns, nNumRows);
}

int CMFCColorBar::GetExtraHeight(int nNumColumns) const
//
// Calculate additional height required by the misc. elements such
// as "Other" button, document colors, e.t.c
//
{
	int nExtraHeight = 0;

	if (!m_strAutoColor.IsEmpty())
	{
		nExtraHeight += m_nRowHeight;
	}
	else if (!m_strOtherColor.IsEmpty())
	{
		nExtraHeight += m_nVertMargin;
	}

	if (!m_strOtherColor.IsEmpty())
	{
		nExtraHeight += m_nRowHeight;
	}

	if (!m_strDocColors.IsEmpty() && !m_lstDocColors.IsEmpty() && (m_bShowDocColorsWhenDocked || IsFloating()))
	{
		int nDocColorRows = (int) m_lstDocColors.GetCount() / nNumColumns;
		if ((m_lstDocColors.GetCount() % nNumColumns) != 0)
		{
			nDocColorRows++;
		}

		nExtraHeight += m_nRowHeight + nDocColorRows * m_BoxSize.cy + 2 * SEPARATOR_SIZE + m_nVertMargin;
	}

	return nExtraHeight;
}

//{{AFX_MSG_MAP(CMFCColorBar)
BEGIN_MESSAGE_MAP(CMFCColorBar, CMFCPopupMenuBar)
	ON_WM_CREATE()
	ON_WM_QUERYNEWPALETTE()
	ON_WM_PALETTECHANGED()
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_DESTROY()
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCColorBar::OnMouseLeave)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCColorBar message handlers

void CMFCColorBar::SetDocumentColors(LPCTSTR lpszCaption, CList<COLORREF,COLORREF>& lstDocColors, BOOL bShowWhenDocked)
{
	m_strDocColors = lpszCaption == NULL ? _T("") : lpszCaption;

	if (m_lstDocColors.GetCount() == lstDocColors.GetCount())
	{
		BOOL bChanged = FALSE;

		POSITION posCur = m_lstDocColors.GetHeadPosition();
		POSITION posNew = lstDocColors.GetHeadPosition();

		while (posCur != NULL && posNew != NULL)
		{
			if (m_lstDocColors.GetNext(posCur) != lstDocColors.GetNext(posNew))
			{
				bChanged = TRUE;
				break;
			}
		}

		if (!bChanged)
		{
			return;
		}
	}

	m_lstDocColors.RemoveAll();
	m_lstDocColors.AddTail(&lstDocColors);

	m_bShowDocColorsWhenDocked = bShowWhenDocked;

	Rebuild();
	AdjustLayout();
}

void CMFCColorBar::ContextToSize(BOOL bSquareButtons, BOOL bCenterButtons)
{
	ENSURE(GetSafeHwnd() != NULL);

	CRect rectClient;
	GetClientRect(rectClient);

	// First, adjust height:
	int nCurrHeight = CalcSize(TRUE).cy;
	int yDelta = nCurrHeight < rectClient.Height() ? 1 : -1;

	while ((nCurrHeight = CalcSize(TRUE).cy) != rectClient.Height())
	{
		if (yDelta < 0)
		{
			if (nCurrHeight < rectClient.Height())
			{
				break;
			}
		}
		else if (nCurrHeight > rectClient.Height())
		{
			m_BoxSize.cy -= yDelta;
			m_nRowHeight = m_BoxSize.cy * 3 / 2;
			break;
		}

		m_BoxSize.cy += yDelta;
		m_nRowHeight = m_BoxSize.cy * 3 / 2;
	}

	// Now, adjust width:
	int nCurrWidth = CalcSize(TRUE).cx;
	int xDelta = nCurrWidth < rectClient.Width() ? 1 : -1;

	while ((nCurrWidth = CalcSize(TRUE).cx) != rectClient.Width())
	{
		if (xDelta < 0)
		{
			if (nCurrWidth < rectClient.Width())
			{
				break;
			}
		}
		else if (nCurrWidth > rectClient.Width())
		{
			m_BoxSize.cy -= xDelta;
			break;
		}

		m_BoxSize.cx += xDelta;
	}

	m_BoxSize.cx--;
	m_BoxSize.cy--;

	if (bSquareButtons)
	{
		m_BoxSize.cx = m_BoxSize.cy = min(m_BoxSize.cx, m_BoxSize.cy);
		m_nRowHeight = m_BoxSize.cy * 3 / 2;
	}

	if (bCenterButtons)
	{
		// Finaly, calculate offset to center buttons area:
		CSize size = CalcSize(TRUE);

		m_nHorzOffset = (rectClient.Width() - size.cx) / 2;
		m_nVertOffset = (rectClient.Height() - size.cy) / 2;
	}
	else
	{
		m_nHorzOffset = m_nVertOffset = 0;
	}

	AdjustLocations();
}

void CMFCColorBar::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	if (m_bIsTearOff)
	{
		CMFCToolBar::OnNcCalcSize(bCalcValidRects, lpncsp);
	}
	else
	{
		CMFCPopupMenuBar::OnNcCalcSize(bCalcValidRects, lpncsp);
	}
}

void CMFCColorBar::OnNcPaint()
{
	if (m_bIsTearOff)
	{
		CMFCToolBar::OnNcPaint();
	}
	else
	{
		CMFCPopupMenuBar::OnNcPaint();
	}
}

int CMFCColorBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCPopupMenuBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_BoxSize = GetMenuImageSize();
	m_BoxSize.cx ++;
	m_BoxSize.cy ++;

	m_bLeaveFocus = FALSE;
	m_nRowHeight = m_BoxSize.cy * 3 / 2;
	Rebuild();

	if (m_pParentBtn != NULL)
	{
		SetCapture();
		m_pParentBtn->m_bCaptured = FALSE;
	}
	else if (m_pWndPropList != NULL)
	{
		SetCapture();
	}

	return 0;
}

void CMFCColorBar::Rebuild()
{
	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	RemoveAllButtons();

	BOOL bAlreadySelected = FALSE;
	if (!m_strAutoColor.IsEmpty()) // Automatic
	{
		InsertButton(new CMFCToolBarColorButton(m_ColorAutomatic, TRUE, FALSE, m_strAutoColor, m_ColorSelected == (COLORREF) -1));

		if (!bAlreadySelected)
		{
			bAlreadySelected = (m_ColorSelected == (COLORREF) -1);
		}
	}

	for (int i = 0; i < m_colors.GetSize(); i ++)
	{
		InsertButton(new CMFCToolBarColorButton(m_colors [i], FALSE, FALSE, NULL, m_ColorSelected == m_colors [i]));

		if (!bAlreadySelected)
		{
			bAlreadySelected = (m_ColorSelected == m_colors [i]);
		}
	}

	if (!m_strDocColors.IsEmpty() && !m_lstDocColors.IsEmpty())
	{
		InsertSeparator();
		InsertButton(new CMFCToolBarColorButton(m_strDocColors, TRUE)); // Label

		for (POSITION pos = m_lstDocColors.GetHeadPosition(); pos != NULL;)
		{
			COLORREF color = m_lstDocColors.GetNext(pos);
			InsertButton(new CMFCToolBarColorButton(color, FALSE, FALSE, NULL, !bAlreadySelected && m_ColorSelected == color, TRUE));
		}
	}

	if (!m_strOtherColor.IsEmpty()) // Other color button
	{
		InsertSeparator();
		InsertButton(new CMFCToolBarColorButton((COLORREF) -1,FALSE, TRUE, m_strOtherColor));
		InsertButton(new CMFCToolBarColorButton(m_ColorSelected, FALSE, FALSE, NULL, !bAlreadySelected, FALSE, TRUE));
	}
}

class CMFCColorBarCmdUI  : public CCmdUI
{
public:
	CMFCColorBarCmdUI ();

public: // re-implementations only
	virtual void Enable(BOOL bOn);
	BOOL m_bEnabled;
};

CMFCColorBarCmdUI ::CMFCColorBarCmdUI ()
{
	m_bEnabled = TRUE;  // assume it is enabled
}

void CMFCColorBarCmdUI ::Enable(BOOL bOn)
{
	m_bEnabled = bOn;
	m_bEnableChanged = TRUE;
}

void CMFCColorBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	ASSERT_VALID(this);

	if (m_nCommandID == 0 || m_nCommandID == (UINT)-1)
	{
		CMFCPopupMenuBar::OnUpdateCmdUI(pTarget, bDisableIfNoHndler);
		return;
	}

	CMFCColorBarCmdUI  state;
	state.m_pOther = this;
	state.m_nIndexMax = 1;
	state.m_nID = m_nCommandID;

	BOOL bIsEnabled = FALSE;
	if (pTarget->OnCmdMsg(m_nCommandID, CN_UPDATE_COMMAND_UI, &state, NULL))
	{
		bIsEnabled = state.m_bEnabled;
	}
	else if (bDisableIfNoHndler && !state.m_bEnableChanged)
	{
		AFX_CMDHANDLERINFO info;
		info.pTarget = NULL;

		bIsEnabled = pTarget->OnCmdMsg(m_nCommandID, CN_COMMAND, &state, &info);
	}

	if (bIsEnabled != m_bIsEnabled)
	{
		m_bIsEnabled = bIsEnabled;

		for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
		{
			CMFCToolBarColorButton* pColorButton = DYNAMIC_DOWNCAST(CMFCToolBarColorButton, m_Buttons.GetNext(pos));
			if (pColorButton != NULL)
			{
				pColorButton->m_nStyle &= ~TBBS_DISABLED;
				if (!bIsEnabled)
				{
					pColorButton->m_nStyle |= TBBS_DISABLED;
				}
			}
		}

		Invalidate();
		UpdateWindow();
	}

	CMFCPopupMenuBar::OnUpdateCmdUI(pTarget, bDisableIfNoHndler);
}

void CMFCColorBar::DoPaint(CDC* pDC)
{
	CPalette* pOldPalette = SelectPalette(pDC);

	CMFCPopupMenuBar::DoPaint(pDC);

	if (pOldPalette != NULL)
	{
		pDC->SelectPalette(pOldPalette, FALSE);
	}
}

BOOL CMFCColorBar::OnQueryNewPalette()
{
	Invalidate();
	UpdateWindow();
	return CMFCPopupMenuBar::OnQueryNewPalette();
}

void CMFCColorBar::OnPaletteChanged(CWnd* pFocusWnd)
{
	CMFCPopupMenuBar::OnPaletteChanged(pFocusWnd);

	if (pFocusWnd->GetSafeHwnd() != GetSafeHwnd())
	{
		Invalidate();
		UpdateWindow();
	}
}

BOOL CMFCColorBar::OnSendCommand(const CMFCToolBarButton* pButton)
{
	if (m_pParentBtn != NULL || m_pWndPropList != NULL)
	{
		ReleaseCapture();
	}

	COLORREF color = (COLORREF) -1;

	CMFCColorMenuButton* pColorMenuButton = NULL;

	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
	if (pParentMenu != NULL)
	{
		pColorMenuButton = DYNAMIC_DOWNCAST(CMFCColorMenuButton, pParentMenu->GetParentButton());
	}

	CMFCToolBarColorButton* pColorButton = DYNAMIC_DOWNCAST(CMFCToolBarColorButton, pButton);
	if (pColorButton == NULL)
	{
		ASSERT(FALSE);
	}
	else if (pColorButton->m_bIsLabel)
	{
		return FALSE;
	}
	else if (pColorButton->m_bIsOther)
	{
		SetInCommand();

		if (pParentMenu != NULL)
		{
			pParentMenu->ShowWindow(SW_HIDE);

			if (AFXGetTopLevelFrame(this) != NULL)
			{
				CMFCPopupMenu::ActivatePopupMenu(AFXGetTopLevelFrame(this), NULL);
			}
		}

		HWND hwnd = GetSafeHwnd();

		InvalidateRect(pButton->Rect());
		UpdateWindow();

		// Invoke color dialog:
		if (!OpenColorDialog(m_ColorSelected == (COLORREF)-1 ? m_ColorAutomatic : m_ColorSelected, color))
		{
			if (!::IsWindow(hwnd))
			{
				return TRUE;
			}

			SetInCommand(FALSE);

			if (m_pParentBtn != NULL || m_pWndPropList != NULL || m_pParentRibbonBtn != NULL)
			{
				GetParent()->SendMessage(WM_CLOSE);
			}
			else if (pColorMenuButton != NULL)
			{
				InvokeMenuCommand(0, pColorMenuButton);
			}
			else if (AFXGetTopLevelFrame(this) != NULL)
			{
				AFXGetTopLevelFrame(this)->SetFocus();
			}

			return TRUE;
		}

		if (!::IsWindow(hwnd))
		{
			return TRUE;
		}

		SetInCommand(FALSE);
	}
	else if (pColorButton->m_bIsAutomatic)
	{
		color = (COLORREF) -1;
	}
	else
	{
		color = pColorButton->m_Color;
	}

	if (pColorMenuButton != NULL)
	{
		pColorMenuButton->SetColor(color);
		InvokeMenuCommand(pColorMenuButton->m_nID, pColorMenuButton);
	}
	else if (m_pParentBtn != NULL)
	{
		m_pParentBtn->UpdateColor(color);
		GetParent()->SendMessage(WM_CLOSE);
	}

	else if (m_pParentRibbonBtn != NULL)
	{
		m_pParentRibbonBtn->UpdateColor(color);
		GetParent()->SendMessage(WM_CLOSE);
	}
	else if (m_pWndPropList != NULL)
	{
		m_pWndPropList->UpdateColor(color);
		GetParent()->SendMessage(WM_CLOSE);
	}
	else
	{
		ASSERT(m_nCommandID != 0);

		SetColor(color);

		CObList listButtons;
		if (CMFCToolBar::GetCommandButtons(m_nCommandID, listButtons) > 0)
		{
			for (POSITION pos = listButtons.GetHeadPosition(); pos != NULL;)
			{
				CMFCColorMenuButton* pCurrColorButton = NULL;
				pCurrColorButton = DYNAMIC_DOWNCAST(CMFCColorMenuButton, listButtons.GetNext(pos));
				if (pCurrColorButton != NULL)
				{
					ASSERT_VALID(pCurrColorButton);
					pCurrColorButton->SetColor(color, FALSE);
				}
			}
		}

		CMFCColorMenuButton::SetColorByCmdID(m_nCommandID, color);
		GetOwner()->SendMessage(WM_COMMAND, m_nCommandID);    // send command

		if (AFXGetTopLevelFrame(this) != NULL)
		{
			AFXGetTopLevelFrame(this)->SetFocus();
		}
	}

	return TRUE;
}

BOOL CMFCColorBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID, CPalette* pPalette/* = NULL*/, int nColumns/* = 0*/, int nRowsDockHorz/* = 0*/, int nColDockVert/* = 0*/)
{
	if (m_colors.GetSize() != NULL)
	{
		return CMFCPopupMenuBar::Create(pParentWnd, dwStyle, nID);
	}

	m_nNumColumns = nColumns;
	m_nNumColumnsVert = nColDockVert;
	m_nNumRowsHorz = nRowsDockHorz;

	InitColors(pPalette, m_colors);
	return CMFCPopupMenuBar::Create(pParentWnd, dwStyle, nID);
}

BOOL CMFCColorBar::CreateControl(CWnd* pParentWnd, const CRect& rect, UINT nID, int nColumns, CPalette* pPalette/* = NULL*/)
{
	ASSERT_VALID(pParentWnd);

	EnableLargeIcons(FALSE);

	if (nColumns <= 0)
	{
		const int nColorsCount = (pPalette == NULL) ? 20 : pPalette->GetEntryCount();
		ASSERT(nColorsCount > 0);

		// Optimal fill
		for (nColumns = nColorsCount; nColumns > 0; nColumns--)
		{
			int nCellSize = (rect.Width() - 2 * m_nHorzMargin) / nColumns;
			if (nCellSize == 0)
			{
				continue;
			}

			int nRows = nColorsCount / nColumns;
			if (nRows * nCellSize > rect.Height() - 2 * m_nVertMargin)
			{
				nColumns++;
				break;
			}
		}

		if (nColumns <= 0)
		{
			nColumns = -1;
		}
	}

	if (!Create(pParentWnd, WS_CHILD | WS_VISIBLE | CBRS_ALIGN_TOP, nID, pPalette, nColumns))
	{
		return FALSE;
	}

	SetPaneStyle(GetPaneStyle() & ~(CBRS_GRIPPER | CBRS_BORDER_TOP | CBRS_BORDER_BOTTOM | CBRS_BORDER_LEFT | CBRS_BORDER_RIGHT));

	CRect rectWnd = rect;
	MoveWindow(rectWnd);
	ContextToSize();

	SetWindowPos(&wndTop, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

	SetOwner(pParentWnd);
	SetCommandID(nID);

	// All commands will be routed via this dialog, not via the parent frame:
	SetRouteCommandsViaFrame(FALSE);
	return TRUE;
}

int __stdcall CMFCColorBar::InitColors(CPalette* pPalette, CArray<COLORREF, COLORREF>& arColors)
{
	int nColorsCount = (pPalette == NULL) ? 20 : pPalette->GetEntryCount();
	arColors.SetSize(nColorsCount);

	if (pPalette == NULL)
	{
		// Use system palette:
		pPalette = CPalette::FromHandle((HPALETTE) ::GetStockObject(DEFAULT_PALETTE));
		ASSERT_VALID(pPalette);
	}

	PALETTEENTRY palEntry;
	for (int i = 0; i < nColorsCount; i++)
	{
		pPalette->GetPaletteEntries(i, 1, &palEntry);
		arColors [i] = RGB(palEntry.peRed, palEntry.peGreen, palEntry.peBlue);
	}

	return nColorsCount;
}

void CMFCColorBar::Serialize(CArchive& ar)
{
	CMFCPopupMenuBar::Serialize(ar);

	if (ar.IsLoading())
	{
		ar >> m_nNumColumns;
		ar >> m_nNumRowsHorz;
		ar >> m_nNumColumnsVert;
		ar >> m_ColorAutomatic;
		ar >> m_strAutoColor;
		ar >> m_strOtherColor;
		ar >> m_strDocColors;
		ar >> m_bIsTearOff;
		ar >> m_nCommandID;
		ar >> m_bStdColorDlg;

		int nColors = 0;
		ar >> nColors;

		m_colors.SetSize(nColors);

		for (int i = 0; i < nColors; i ++)
		{
			COLORREF color;
			ar >> color;

			m_colors [i] = color;
		}

		Rebuild();
		AdjustLocations();
	}
	else
	{
		ar << m_nNumColumns;
		ar << m_nNumRowsHorz;
		ar << m_nNumColumnsVert;
		ar << m_ColorAutomatic;
		ar << m_strAutoColor;
		ar << m_strOtherColor;
		ar << m_strDocColors;
		ar << m_bIsTearOff;
		ar << m_nCommandID;
		ar << m_bStdColorDlg;

		ar <<(int) m_colors.GetSize();

		for (int i = 0; i < m_colors.GetSize(); i ++)
		{
			ar << m_colors [i];
		}
	}
}

void CMFCColorBar::ShowCommandMessageString(UINT /*uiCmdId*/)
{
	GetOwner()->SendMessage(WM_SETMESSAGESTRING, m_nCommandID == (UINT) -1 ? AFX_IDS_IDLEMESSAGE :(WPARAM) m_nCommandID);
}

BOOL CMFCColorBar::OpenColorDialog(const COLORREF colorDefault, COLORREF& colorRes)
{
	CMFCColorMenuButton* pColorMenuButton = NULL;

	CMFCPopupMenu* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, GetParent());
	if (pParentMenu != NULL)
	{
		pColorMenuButton = DYNAMIC_DOWNCAST(CMFCColorMenuButton, pParentMenu->GetParentButton());
		if (pColorMenuButton != NULL)
		{
			return pColorMenuButton->OpenColorDialog(colorDefault, colorRes);
		}
	}

	BOOL bResult = FALSE;

	if (m_bStdColorDlg)
	{
		CColorDialog dlg(colorDefault, CC_FULLOPEN | CC_ANYCOLOR);
		if (dlg.DoModal() == IDOK)
		{
			colorRes = dlg.GetColor();
			bResult = TRUE;
		}
	}
	else
	{
		CMFCColorDialog dlg(colorDefault);
		if (dlg.DoModal() == IDOK)
		{
			colorRes = dlg.GetColor();
			bResult = TRUE;
		}
	}

	return bResult;
}

void CMFCColorBar::EnableAutomaticButton(LPCTSTR lpszLabel, COLORREF colorAutomatic, BOOL bEnable)
{
	m_ColorAutomatic = colorAutomatic;
	m_strAutoColor = (!bEnable || lpszLabel == NULL) ? _T("") : lpszLabel;

	Rebuild();
	AdjustLayout();
}

void CMFCColorBar::EnableOtherButton(LPCTSTR lpszLabel, BOOL bAltColorDlg, BOOL bEnable)
{
	m_bStdColorDlg = !bAltColorDlg;
	m_strOtherColor = (!bEnable || lpszLabel == NULL) ? _T("") : lpszLabel;

	Rebuild();
	AdjustLayout();
}

void CMFCColorBar::SetColor(COLORREF color)
{
	if (m_ColorSelected == color)
	{
		return;
	}

	m_ColorSelected = color;

	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	BOOL bIsOtherColor = !(m_ColorAutomatic != (UINT)-1 && m_ColorSelected == (COLORREF)-1);
	BOOL bWasOtherColor = FALSE;

	m_iHighlighted = -1;
	int iButton = 0;

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL; iButton++)
	{
		CRect rectButton;

		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			continue;
		}

		CMFCToolBarColorButton* pColorButton = DYNAMIC_DOWNCAST(CMFCToolBarColorButton, pButton);
		if (pColorButton == NULL)
		{
			continue;
		}

		ASSERT_VALID(pColorButton);

		if (pColorButton->m_bIsOther || pColorButton->m_bIsLabel)
		{
			continue;
		}

		if (pColorButton->m_bHighlight)
		{
			pColorButton->m_bHighlight = FALSE;
			InvalidateRect(pColorButton->Rect());
		}

		if (pColorButton->m_bIsAutomatic && color == (COLORREF)-1)
		{
			pColorButton->m_bHighlight = TRUE;
			m_iHighlighted = iButton;
			InvalidateRect(pColorButton->Rect());
		}
		else if (pColorButton->m_Color == color)
		{
			pColorButton->m_bHighlight = TRUE;
			m_iHighlighted = iButton;
			InvalidateRect(pColorButton->Rect());
			bIsOtherColor = FALSE;
		}

		if (pColorButton->m_bIsOtherColor)
		{
			pColorButton->m_Color = m_ColorSelected;
			pColorButton->m_bHighlight = TRUE;

			InvalidateRect(pColorButton->Rect());
			bWasOtherColor = !(pColorButton->Rect().IsRectEmpty());
		}
	}

	if (bWasOtherColor != bIsOtherColor)
	{
		AdjustLocations();
		Invalidate();
	}

	UpdateWindow();
}

void CMFCColorBar::OnMouseMove(UINT nFlags, CPoint point)
{
	if (!IsCustomizeMode() || m_bInternal)
	{
		CMFCToolBar::OnMouseMove(nFlags, point);
	}
}

void CMFCColorBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (IsCustomizeMode() && !m_bInternal)
	{
		return;
	}

	if (HitTest(point) == -1)
	{
		CMFCToolBar::OnLButtonDown(nFlags, point);
	}
}

void CMFCColorBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (!IsCustomizeMode() || m_bInternal)
	{
		int iHit = HitTest(point);
		if (iHit >= 0)
		{
			m_iButtonCapture = iHit;
		}

		CMFCToolBar::OnLButtonUp(nFlags, point);
	}
}

void CMFCColorBar::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	if (!IsCustomizeMode() || m_bInternal)
	{
		CMFCToolBar::OnLButtonDblClk(nFlags, point);
	}
}

BOOL CMFCColorBar::PreTranslateMessage(MSG* pMsg)
{
	if ((m_pParentBtn != NULL || m_pWndPropList != NULL || m_pParentRibbonBtn != NULL)
		&& !m_bInCommand)
	{
		switch (pMsg->message)
		{
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MBUTTONDOWN:
			{
				CRect rect;
				GetClientRect(rect);

				CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
				if (!rect.PtInRect(pt))
				{
					GetParent()->SendMessage(WM_CLOSE);
					return TRUE;
				}
			}
			break;

		case WM_SYSKEYDOWN:
		case WM_CONTEXTMENU:
			GetParent()->SendMessage(WM_CLOSE);
			return TRUE;

		case WM_KEYDOWN:
			if (pMsg->wParam == VK_ESCAPE)
			{
				GetParent()->SendMessage(WM_CLOSE);
				return TRUE;
			}
		}
	}

	return CMFCPopupMenuBar::PreTranslateMessage(pMsg);
}

void CMFCColorBar::OnDestroy()
{
	if (m_pParentBtn != NULL)
	{
		m_pParentBtn->m_pPopup = NULL;
		m_pParentBtn->SetFocus();
	}
	else if (m_pWndPropList != NULL)
	{
		m_pWndPropList->CloseColorPopup();
		m_pWndPropList->SetFocus();
	}

	CMFCPopupMenuBar::OnDestroy();
}

BOOL CMFCColorBar::OnKey(UINT nChar)
{
	POSITION posSel = (m_iHighlighted < 0) ? NULL : m_Buttons.FindIndex(m_iHighlighted);
	CMFCToolBarButton* pSelButton = (posSel == NULL) ? NULL :(CMFCToolBarButton*) m_Buttons.GetAt(posSel);

	switch (nChar)
	{
	case VK_RETURN:
		if (pSelButton != NULL)
		{
			GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
			OnSendCommand(pSelButton);
			return TRUE;
		}
		break;
	}

	return CMFCPopupMenuBar::OnKey(nChar);
}

void CMFCColorBar::OnChangeHot(int iHot)
{
	CMFCPopupMenuBar::OnChangeHot(iHot);

	if (m_pParentRibbonBtn != NULL)
	{
		ASSERT_VALID(m_pParentRibbonBtn);

		CMFCToolBarColorButton* pColorButton = DYNAMIC_DOWNCAST(CMFCToolBarColorButton, GetButton(iHot));

		if (pColorButton == NULL || pColorButton->m_bIsOther || pColorButton->m_bIsLabel)
		{
			iHot = -1;
		}

		m_pParentRibbonBtn->NotifyHighlightListItem(iHot);
	}
}

afx_msg LRESULT CMFCColorBar::OnMouseLeave(WPARAM wp,LPARAM lp)
{
	if (m_pParentBtn == NULL && m_pWndPropList == NULL)
	{
		return CMFCToolBar::OnMouseLeave(wp, lp);
	}

	if (m_hookMouseHelp != NULL ||
		(m_bMenuMode && !IsCustomizeMode() && GetDroppedDownMenu() != NULL))
	{
		return 0;
	}

	m_bTracked = FALSE;
	m_ptLastMouse = CPoint(-1, -1);

	if (m_iHighlighted >= 0)
	{
		int iButton = m_iHighlighted;
		m_iHighlighted = -1;

		OnChangeHot(m_iHighlighted);

		InvalidateButton(iButton);
		UpdateWindow(); // immediate feedback

		GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);

		if (m_pParentRibbonBtn != NULL)
		{
			ASSERT_VALID(m_pParentRibbonBtn);
			m_pParentRibbonBtn->NotifyHighlightListItem(-1);
		}
	}

	return 0;
}

BOOL __stdcall CMFCColorBar::CreatePalette(const CArray<COLORREF, COLORREF>& arColors, CPalette& palette)
{
	if (palette.GetSafeHandle() != NULL)
	{
		::DeleteObject(palette.Detach());
		ENSURE(palette.GetSafeHandle() == NULL);
	}

	if (afxGlobalData.m_nBitsPerPixel != 8)
	{
		return FALSE;
	}

#define AFX_MAX_COLOURS 100
	int nNumColours = (int) arColors.GetSize();
	if (nNumColours == 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	ASSERT(nNumColours <= AFX_MAX_COLOURS);
	if (nNumColours > AFX_MAX_COLOURS)
	{
		nNumColours = AFX_MAX_COLOURS;
	}

	// Create the palette
	struct
	{
		LOGPALETTE    LogPalette;
		PALETTEENTRY  PalEntry [AFX_MAX_COLOURS];
	}
	pal;

	LOGPALETTE* pLogPalette = (LOGPALETTE*) &pal;
	pLogPalette->palVersion    = 0x300;
	pLogPalette->palNumEntries = (WORD) nNumColours;

	for (int i = 0; i < nNumColours; i++)
	{
		pLogPalette->palPalEntry[i].peRed   = GetRValue(arColors[i]);
		pLogPalette->palPalEntry[i].peGreen = GetGValue(arColors[i]);
		pLogPalette->palPalEntry[i].peBlue  = GetBValue(arColors[i]);
		pLogPalette->palPalEntry[i].peFlags = 0;
	}

	palette.CreatePalette(pLogPalette);
	return TRUE;
}

CPalette* CMFCColorBar::SelectPalette(CDC* pDC)
{
	ASSERT_VALID(pDC);

	if (afxGlobalData.m_nBitsPerPixel != 8)
	{
		if (m_Palette.GetSafeHandle() != NULL)
		{
			::DeleteObject(m_Palette.Detach());
		}

		return NULL;
	}

	CPalette* pOldPalette = NULL;

	if (m_pParentBtn != NULL && m_pParentBtn->m_pPalette != NULL)
	{
		pOldPalette = pDC->SelectPalette(m_pParentBtn->m_pPalette, FALSE);
	}
	else
	{
		if (m_Palette.GetSafeHandle() == NULL)
		{
			// Palette not created yet; create it now
			CreatePalette(m_colors, m_Palette);
		}

		pOldPalette = pDC->SelectPalette(&m_Palette, FALSE);
	}

	ENSURE(pOldPalette != NULL);
	pDC->RealizePalette();

	return pOldPalette;
}

void CMFCColorBar::SetVertMargin(int nVertMargin)
{
	ASSERT_VALID(this);

	m_nVertMargin = nVertMargin;
	AdjustLayout();
}

void CMFCColorBar::SetHorzMargin(int nHorzMargin)
{
	ASSERT_VALID(this);

	m_nHorzMargin = nHorzMargin;
	AdjustLayout();
}

COLORREF CMFCColorBar::GetHighlightedColor() const
{
	ASSERT_VALID(this);

	if (m_iHot < 0)
	{
		return(COLORREF)-1;
	}

	CMFCToolBarColorButton* pColorButton = DYNAMIC_DOWNCAST(CMFCToolBarColorButton, GetButton(m_iHot));

	if (pColorButton == NULL)
	{
		return(COLORREF)-1;
	}

	return pColorButton->m_Color;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcolorpopupmenu.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxcontrolbarutil.h"
#include "afxcolormenubutton.h"
#include "afxpane.h"
#include "afxcolorpopupmenu.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPopupMenu

IMPLEMENT_DYNAMIC(CMFCColorPopupMenu, CMFCPopupMenu)

BEGIN_MESSAGE_MAP(CMFCColorPopupMenu, CMFCPopupMenu)
	//{{AFX_MSG_MAP(CMFCColorPopupMenu)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMFCColorPopupMenu::~CMFCColorPopupMenu()
{
}

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPopupMenu message handlers

int CMFCColorPopupMenu::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCToolBar::IsCustomizeMode() && !m_bEnabledInCustomizeMode)
	{
		// Don't show color popup in cistomization mode
		return -1;
	}

	if (CMiniFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	DWORD toolbarStyle = AFX_DEFAULT_TOOLBAR_STYLE;
	if (GetAnimationType() != NO_ANIMATION && !CMFCToolBar::IsCustomizeMode())
	{
		toolbarStyle &= ~WS_VISIBLE;
	}

	if (!m_wndColorBar.Create(this, toolbarStyle | CBRS_TOOLTIPS | CBRS_FLYBY, 1))
	{
		TRACE(_T("Can't create popup menu bar\n"));
		return -1;
	}

	CWnd* pWndParent = GetParent();
	ASSERT_VALID(pWndParent);

	m_wndColorBar.SetOwner(pWndParent);
	m_wndColorBar.SetPaneStyle(m_wndColorBar.GetPaneStyle() | CBRS_TOOLTIPS);

	ActivatePopupMenu(AFXGetTopLevelFrame(pWndParent), this);
	RecalcLayout();
	return 0;
}

CPane* CMFCColorPopupMenu::CreateTearOffBar(CFrameWnd* pWndMain, UINT uiID, LPCTSTR lpszName)
{
	ASSERT_VALID(pWndMain);
	ENSURE(lpszName != NULL);
	ENSURE(uiID != 0);

	CMFCColorMenuButton* pColorMenuButton = DYNAMIC_DOWNCAST(CMFCColorMenuButton, GetParentButton());
	if (pColorMenuButton == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	CMFCColorBar* pColorBar = new CMFCColorBar(m_wndColorBar, pColorMenuButton->m_nID);

	if (!pColorBar->Create(pWndMain, AFX_DEFAULT_TOOLBAR_STYLE, uiID))
	{
		TRACE0("Failed to create a new toolbar!\n");
		delete pColorBar;
		return NULL;
	}

	pColorBar->SetWindowText(lpszName);
	pColorBar->SetPaneStyle(pColorBar->GetPaneStyle() | CBRS_TOOLTIPS | CBRS_FLYBY);
	pColorBar->EnableDocking(CBRS_ALIGN_ANY);

	return pColorBar;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcolorpropertysheet.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxcolorpropertysheet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPropertySheet

IMPLEMENT_DYNAMIC(CMFCColorPropertySheet, CPropertySheet)

CMFCColorPropertySheet::CMFCColorPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	: CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
	m_hAccel = NULL;
}

CMFCColorPropertySheet::CMFCColorPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	: CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
	m_hAccel = NULL;
}

CMFCColorPropertySheet::~CMFCColorPropertySheet()
{
}

BEGIN_MESSAGE_MAP(CMFCColorPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CMFCColorPropertySheet)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCColorPropertySheet message handlers

void CMFCColorPropertySheet::PostNcDestroy()
{
	// Call the base class routine first
	CPropertySheet::PostNcDestroy();

	if (m_bModeless)
	{
		delete this;
	}
}

BOOL CMFCColorPropertySheet::OnInitDialog()
{
	ASSERT_VALID(this);

	// Call the base class routine
	BOOL bRtnValue = CPropertySheet::OnInitDialog();

	ModifyStyleEx(0, WS_EX_CONTROLPARENT);

	ResizeControl();
	return bRtnValue;
}

BOOL CMFCColorPropertySheet::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	NMHDR* pNMHDR = (NMHDR*) lParam;
	ENSURE(pNMHDR != NULL);

	if (pNMHDR->code == TCN_SELCHANGE)
	{
		ResizeControl();
	}

	return CPropertySheet::OnNotify(wParam, lParam, pResult);
}

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
void CMFCColorPropertySheet::LoadAcceleratorTable(UINT nAccelTableID /*=0*/)
{
	if (nAccelTableID)
	{
		m_hAccel = ::LoadAcceleratorsW(AfxGetInstanceHandle(), MAKEINTRESOURCEW(nAccelTableID));
		ASSERT(m_hAccel);
	}
}

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
BOOL CMFCColorPropertySheet::PreTranslateMessage(MSG* pMsg)
{
	//TRACE("[%s - %d] - CMFCColorPropertySheet::PreTranslateMessage().....\n", __FILE__,__LINE__);
	////////
	// Check to see if the property sheet has an accelerator table
	// attached to it. If there is one call it. Return TRUE if it has
	// been processed. Otherwise, past it to the base class function.
	////////
	if (m_hAccel && ::TranslateAccelerator(m_hWnd, m_hAccel, pMsg))
	{
		return TRUE;
	}

	return CPropertySheet::PreTranslateMessage(pMsg);
}

void CMFCColorPropertySheet::OnSize(UINT nType, int cx, int cy)
{
	CPropertySheet::OnSize(nType, cx, cy);
	ResizeControl();
}

void CMFCColorPropertySheet::ResizeControl()
{
	CTabCtrl* pTabCtrl = GetTabControl();
	if (pTabCtrl == NULL)
	{
		return;
	}

	CRect rectClient;
	GetClientRect(rectClient);

	pTabCtrl->SetWindowPos(NULL, 0, 0, rectClient.Width(), rectClient.Height(), SWP_NOZORDER | SWP_NOACTIVATE);

	int nPageCount = CPropertySheet::GetPageCount();

	int nXBorder = ::GetSystemMetrics(SM_CXEDGE);
	int nYBorder = ::GetSystemMetrics(SM_CYEDGE);

	for (int nPage = 0; nPage <= nPageCount - 1; nPage++)
	{
		CPropertyPage* pPage = GetPage(nPage);

		if ((pPage != NULL) &&(pPage->m_hWnd != NULL))
		{
			CRect rcTabCtrl;
			pPage->GetWindowRect(&rcTabCtrl);
			pTabCtrl->ScreenToClient(rcTabCtrl);

			pPage->SetWindowPos(NULL, rcTabCtrl.left, rcTabCtrl.top, rectClient.Width() -(nXBorder * 3),
				rectClient.Height() -(rcTabCtrl.top + nYBorder), SWP_NOZORDER | SWP_NOACTIVATE);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcommandmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//

#include "stdafx.h"
#include "afxcommandmanager.h"
#include "afxsettingsstore.h"
#include "afxregpath.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_REG_PARAMS_FMT _T("%sCommandManager")
#define AFX_REG_ENTRY_COMMANDS_WITHOUT_IMAGES _T("CommandsWithoutImages")
#define AFX_REG_ENTRY_MENU_USER_IMAGES _T("MenuUserImages")

static const CString strToolbarProfile = _T("ToolBars");

//////////////////////////////////////////////////////////////////////
// One global static CCommandManager Object
//////////////////////////////////////////////////////////////////////
class _STATIC_CREATOR_
{
public:
	CCommandManager s_TheCmdMgr;
};

static _STATIC_CREATOR_ STATIC_CREATOR;

CCommandManager* GetCmdMgr()
{
	return &STATIC_CREATOR.s_TheCmdMgr;
}
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Constructor/Destructor
//////////////////////////////////////////////////////////////////////

CCommandManager::CCommandManager()
{
}

CCommandManager::~CCommandManager()
{
}

//////////////////////////////////////////////////////////////////////
// ImageHash functions
//////////////////////////////////////////////////////////////////////

void CCommandManager::SetCmdImage(UINT uiCmd, int iImage, BOOL bUserImage)
{
	if (uiCmd == 0 || uiCmd == (UINT) -1)
	{
		return;
	}

	if (bUserImage)
	{
		// If command is already associated to the "standard" image list,
		// don't assign to to the "user" images
		if (GetCmdImage(uiCmd, FALSE) < 0)
		{
			m_CommandIndexUser.SetAt(uiCmd, iImage);
		}
	}
	else
	{
		if (GetCmdImage(uiCmd, TRUE) < 0)
		{
			m_CommandIndex.SetAt(uiCmd, iImage);
		}
	}
}

int CCommandManager::GetCmdImage(UINT uiCmd, BOOL bUserImage) const
{
	int iImage = -1;

	if (bUserImage)
	{
		if (!m_CommandIndexUser.Lookup(uiCmd, iImage))
		{
			return -1;
		}
	}
	else
	{
		if (!m_CommandIndex.Lookup(uiCmd, iImage))
		{
			return -1;
		}
	}

	return iImage;
}

void CCommandManager::ClearCmdImage(UINT uiCmd)
{
	m_CommandIndexUser.RemoveKey(uiCmd);
}

void CCommandManager::ClearUserCmdImages()
{
	m_CommandIndexUser.RemoveAll();
}

void CCommandManager::ClearAllCmdImages()
{
	m_CommandIndex.RemoveAll();
	m_CommandIndexUser.RemoveAll();
	m_lstCommandsWithoutImages.RemoveAll();
	m_mapMenuUserImages.RemoveAll();
}

void CCommandManager::CleanUp()
{
	ClearAllCmdImages();
}

void CCommandManager::EnableMenuItemImage(UINT uiCmd, BOOL bEnable, int iUserImage)
{
	POSITION pos = m_lstCommandsWithoutImages.Find(uiCmd);

	if (bEnable)
	{
		if (pos != NULL)
		{
			m_lstCommandsWithoutImages.RemoveAt(pos);
		}

		if (iUserImage >= 0)
		{
			m_mapMenuUserImages.SetAt(uiCmd, iUserImage);
		}
		else
		{
			m_mapMenuUserImages.RemoveKey(uiCmd);
		}
	}
	else
	{
		m_mapMenuUserImages.RemoveKey(uiCmd);

		if (pos == NULL)
		{
			m_lstCommandsWithoutImages.AddTail(uiCmd);
		}
	}
}

BOOL CCommandManager::LoadState(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strToolbarProfile, lpszProfileName);

	CString strSection;
	strSection.Format(AFX_REG_PARAMS_FMT, (LPCTSTR)strProfileName);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	m_lstCommandsWithoutImages.RemoveAll();

	return reg.Read(AFX_REG_ENTRY_COMMANDS_WITHOUT_IMAGES, m_lstCommandsWithoutImages) && reg.Read(AFX_REG_ENTRY_MENU_USER_IMAGES, m_mapMenuUserImages);
}

BOOL CCommandManager::SaveState(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strToolbarProfile, lpszProfileName);

	CString strSection;
	strSection.Format(AFX_REG_PARAMS_FMT, (LPCTSTR)strProfileName);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		return reg.Write(AFX_REG_ENTRY_COMMANDS_WITHOUT_IMAGES, m_lstCommandsWithoutImages) && reg.Write(AFX_REG_ENTRY_MENU_USER_IMAGES, m_mapMenuUserImages);
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcontextmenumanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontextmenumanager.h"
#include "afxmenutearoffmanager.h"
#include "afxpopupmenu.h"
#include "afxmenuhash.h"
#include "afxglobals.h"
#include "afxregpath.h"
#include "afxdialogex.h"
#include "afxpropertypage.h"
#include "afxwinappex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const CString strMenusProfile = _T("ContextMenuManager");

CContextMenuManager* afxContextMenuManager = NULL;

// Construction/Destruction
CContextMenuManager::CContextMenuManager()
{
	ENSURE(afxContextMenuManager == NULL);
	afxContextMenuManager = this;
	m_nLastCommandID = 0;
	m_bTrackMode = FALSE;
	m_bDontCloseActiveMenu = FALSE;
}

CContextMenuManager::~CContextMenuManager()
{
	POSITION pos = NULL;

	for (pos = m_Menus.GetStartPosition(); pos != NULL;)
	{
		UINT uiResId;
		HMENU hMenu;

		m_Menus.GetNextAssoc(pos, uiResId, hMenu);
		::DestroyMenu(hMenu);
	}

	for (pos = m_MenuOriginalItems.GetStartPosition(); pos != NULL;)
	{
		UINT uiResId;
		CObList* pLstOrginItems = NULL;

		m_MenuOriginalItems.GetNextAssoc(pos, uiResId, pLstOrginItems);
		ASSERT_VALID(pLstOrginItems);

		while (!pLstOrginItems->IsEmpty())
		{
			delete pLstOrginItems->RemoveHead();
		}

		delete pLstOrginItems;
	}

	afxContextMenuManager = NULL;
}

BOOL CContextMenuManager::AddMenu(UINT uiMenuNameResId, UINT uiMenuResId)
{
	CString strMenuName;
	ENSURE(strMenuName.LoadString(uiMenuNameResId));

	return AddMenu(strMenuName, uiMenuResId);
}

BOOL CContextMenuManager::AddMenu(LPCTSTR lpszName, UINT uiMenuResId)
{
	ENSURE(lpszName != NULL);

	CMenu menu;
	if (!menu.LoadMenu(uiMenuResId))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	HMENU hExMenu;
	if (m_Menus.Lookup(uiMenuResId, hExMenu))
	{
		// Menu with the same name is already exist!
		return FALSE;
	}

	HMENU hMenu = menu.Detach();

	if (g_pTearOffMenuManager != NULL)
	{
		g_pTearOffMenuManager->SetupTearOffMenus(hMenu);
	}

	m_Menus.SetAt(uiMenuResId, hMenu);
	m_MenuNames.SetAt(lpszName, hMenu);

	return TRUE;
}

BOOL CContextMenuManager::ShowPopupMenu(UINT uiMenuResId, int x, int y, CWnd* pWndOwner, BOOL bOwnMessage, BOOL bRightAlign)
{
	HMENU hMenu;
	if (!m_Menus.Lookup(uiMenuResId, hMenu) || hMenu == NULL)
	{
		return FALSE;
	}

	if (x == -1 && y == -1 && // Undefined position
		pWndOwner != NULL)
	{
		CRect rectParent;
		pWndOwner->GetClientRect(&rectParent);
		pWndOwner->ClientToScreen(&rectParent);

		x = rectParent.left + 5;
		y = rectParent.top + 5;
	}

	HMENU hmenuPopup = ::GetSubMenu(hMenu, 0);
	if (hmenuPopup == NULL)
	{
#ifdef _DEBUG

		MENUITEMINFO info;
		memset(&info, 0, sizeof(MENUITEMINFO));

		if (!::GetMenuItemInfo(hMenu, 0, TRUE, &info))
		{
			TRACE(_T("Invalid menu: %d\n"), uiMenuResId);
		}
		else
		{
			ASSERT(info.hSubMenu == NULL);
			TRACE(_T("Menu %d, first option '%s' doesn't contain popup menu!\n"), uiMenuResId, info.dwTypeData);
		}

#endif // _DEBUG
		return FALSE;
	}

	return ShowPopupMenu(hmenuPopup, x, y, pWndOwner, bOwnMessage, TRUE, bRightAlign) != NULL;
}

CMFCPopupMenu* CContextMenuManager::ShowPopupMenu(HMENU hmenuPopup, int x, int y, CWnd* pWndOwner, BOOL bOwnMessage, BOOL /*bAutoDestroy*/, BOOL bRightAlign)
{
	if (pWndOwner != NULL && pWndOwner->IsKindOf(RUNTIME_CLASS(CDialogEx)) && !bOwnMessage)
	{
		// CDialogEx should own menu messages
		ASSERT(FALSE);
		return NULL;
	}

	if (pWndOwner != NULL && pWndOwner->IsKindOf(RUNTIME_CLASS(CMFCPropertyPage)) && !bOwnMessage)
	{
		// CMFCPropertyPage should own menu messages
		ASSERT(FALSE);
		return NULL;
	}

	ENSURE(hmenuPopup != NULL);
	if (g_pTearOffMenuManager != NULL)
	{
		g_pTearOffMenuManager->SetupTearOffMenus(hmenuPopup);
	}

	if (m_bTrackMode)
	{
		bOwnMessage = TRUE;
	}

	if (!bOwnMessage)
	{
		while (pWndOwner != NULL && pWndOwner->GetStyle() & WS_CHILD)
		{
			pWndOwner = pWndOwner->GetParent();
		}
	}

	CMFCPopupMenu* pPopupMenu = new CMFCPopupMenu;
	pPopupMenu->SetAutoDestroy(FALSE);

	pPopupMenu->m_bTrackMode = m_bTrackMode;
	pPopupMenu->SetRightAlign(bRightAlign);

	CMFCPopupMenu* pMenuActive = CMFCPopupMenu::GetActiveMenu();
	if (!m_bDontCloseActiveMenu && pMenuActive != NULL)
	{
		pMenuActive->SendMessage(WM_CLOSE);
	}

	if (!pPopupMenu->Create(pWndOwner, x, y, hmenuPopup, FALSE, bOwnMessage))
	{
		return NULL;
	}

	return pPopupMenu;
}

UINT CContextMenuManager::TrackPopupMenu(HMENU hmenuPopup, int x, int y, CWnd* pWndOwner, BOOL bRightAlign)
{
	m_nLastCommandID = 0;

	CWinThread* pCurrThread = ::AfxGetThread();
	if (pCurrThread == NULL)
	{
		ASSERT(FALSE);
		return 0;
	}

	m_bTrackMode = TRUE;

	CMFCPopupMenu* pMenu = ShowPopupMenu(hmenuPopup, x, y, pWndOwner, FALSE, TRUE, bRightAlign);

	if (pMenu != NULL)
	{
		CRect rect;
		pMenu->GetWindowRect(&rect);
		pMenu->UpdateShadow(&rect);
	}

	CDialogEx* pParentDlg = NULL;
	if (pWndOwner != NULL && pWndOwner->GetParent() != NULL)
	{
		pParentDlg = DYNAMIC_DOWNCAST(CDialogEx, pWndOwner->GetParent());
		if (pParentDlg != NULL)
		{
			pParentDlg->SetActiveMenu(pMenu);
		}
	}

	CMFCPropertyPage* pParentPropPage = NULL;
	if (pWndOwner != NULL && pWndOwner->GetParent() != NULL)
	{
		pParentPropPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, pWndOwner->GetParent());
		if (pParentPropPage != NULL)
		{
			pParentPropPage->SetActiveMenu(pMenu);
		}
	}

	m_bTrackMode = FALSE;

	if (pMenu != NULL && pCurrThread != NULL)
	{
		ASSERT_VALID(pMenu);

		CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
		if (pApp == NULL || !pApp->OnWorkspaceIdle(pMenu))
		{
			LONG lIdleCount = 0;
			HWND hwndMenu = pMenu->GetSafeHwnd();

			while (::IsWindow(hwndMenu))
			{
				MSG msg;
				while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
				{
					if (msg.message == WM_QUIT)
					{
						PostThreadMessage(GetCurrentThreadId(), msg.message, msg.wParam, msg.lParam);
						return 0;
					}

					if (!::IsWindow(hwndMenu))
					{
						break;
					}

					switch (msg.message)
					{
					case WM_NCLBUTTONDOWN:
						pMenu->DestroyWindow();

						PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);

						if (pParentDlg != NULL)
						{
							pParentDlg->SetActiveMenu(NULL);
						}

						if (pParentPropPage != NULL)
						{
							pParentPropPage->SetActiveMenu(NULL);
						}

						return 0;
					}

					if (::IsWindow(hwndMenu) && !pCurrThread->PreTranslateMessage(&msg))
					{
						::TranslateMessage(&msg);
						::DispatchMessage(&msg);
					}

					if (::IsWindow(hwndMenu) && pMenu->IsIdle())
					{
						pCurrThread->OnIdle(lIdleCount++);
					}
				}

				// reset "no idle" state after pumping "normal" message
				if (pCurrThread->IsIdleMessage(&msg))
				{
					lIdleCount = 0;
				}

				if (!::IsWindow(hwndMenu))
				{
					break;
				}

				WaitMessage();
			}
		}
	}

	if (pParentDlg != NULL)
	{
		pParentDlg->SetActiveMenu(NULL);
	}

	if (pParentPropPage != NULL)
	{
		pParentPropPage->SetActiveMenu(NULL);
	}

	return m_nLastCommandID;
}

void CContextMenuManager::GetMenuNames(CStringList& listOfNames) const
{
	listOfNames.RemoveAll();

	for (POSITION pos = m_MenuNames.GetStartPosition(); pos != NULL;)
	{
		CString strName;
		HMENU hMenu;

		m_MenuNames.GetNextAssoc(pos, strName, hMenu);
		listOfNames.AddTail(strName);
	}
}

HMENU CContextMenuManager::GetMenuByName(LPCTSTR lpszName, UINT* puiOrigResID) const
{
	HMENU hMenu;
	if (!m_MenuNames.Lookup(lpszName, hMenu))
	{
		return NULL;
	}

	if (puiOrigResID != NULL)
	{
		*puiOrigResID = 0;

		for (POSITION pos = m_Menus.GetStartPosition(); pos != NULL;)
		{
			UINT uiResId;
			HMENU hMenuMap;

			m_Menus.GetNextAssoc(pos, uiResId, hMenuMap);
			if (hMenuMap == hMenu)
			{
				*puiOrigResID = uiResId;
				break;
			}
		}
	}

	return hMenu;
}

BOOL CContextMenuManager::LoadState(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strMenusProfile, lpszProfileName);

	for (POSITION pos = m_Menus.GetStartPosition(); pos != NULL;)
	{
		UINT uiResId;
		HMENU hMenu;

		m_Menus.GetNextAssoc(pos, uiResId, hMenu);
		ENSURE(hMenu != NULL);

		HMENU hPopupMenu = ::GetSubMenu(hMenu, 0);
		ENSURE(hPopupMenu != NULL);

		CMFCPopupMenuBar* pBar = new CMFCPopupMenuBar;

		CWnd* pParentWnd = AfxGetMainWnd();
		if (pParentWnd == NULL)
		{
			pParentWnd = CWnd::FromHandle(GetDesktopWindow());
		}

		if (pBar->Create(pParentWnd, AFX_DEFAULT_TOOLBAR_STYLE, 0xFFFF))
		{
			if (!pBar->ImportFromMenu(hPopupMenu))
			{
				pBar->DestroyWindow();
				delete pBar;
				return FALSE;
			}

			pBar->BuildOrigItems(uiResId);

			if (pBar->LoadState(strProfileName, 0, uiResId) && !pBar->IsResourceChanged())
			{
				afxMenuHash.SaveMenuBar(hPopupMenu, pBar);
			}

			CopyOriginalMenuItemsFromMenu(uiResId, *pBar);
			pBar->DestroyWindow();
		}

		delete pBar;
	}

	return TRUE;
}

BOOL CContextMenuManager::SaveState(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strMenusProfile, lpszProfileName);

	for (POSITION pos = m_Menus.GetStartPosition(); pos != NULL;)
	{
		UINT uiResId;
		HMENU hMenu;

		m_Menus.GetNextAssoc(pos, uiResId, hMenu);
		ENSURE(hMenu != NULL);

		HMENU hPopupMenu = ::GetSubMenu(hMenu, 0);
		ENSURE(hPopupMenu != NULL);

		CMFCPopupMenuBar* pBar = new CMFCPopupMenuBar;
		if (pBar->Create(CWnd::FromHandle(GetDesktopWindow())))
		{
			if (afxMenuHash.LoadMenuBar(hPopupMenu, pBar))
			{
				CopyOriginalMenuItemsToMenu(uiResId, *pBar);

				if (!pBar->SaveState(strProfileName, 0, uiResId))
				{
					pBar->DestroyWindow();
					delete pBar;
					return FALSE;
				}
			}

			pBar->DestroyWindow();
		}
		delete pBar;
	}

	return TRUE;
}

BOOL CContextMenuManager::ResetState()
{
	POSITION pos = NULL;

	for (pos = m_Menus.GetStartPosition(); pos != NULL;)
	{
		UINT uiResId;
		HMENU hMenu;

		m_Menus.GetNextAssoc(pos, uiResId, hMenu);
		ENSURE(hMenu != NULL);

		HMENU hPopupMenu = ::GetSubMenu(hMenu, 0);
		ENSURE(hPopupMenu != NULL);

		afxMenuHash.RemoveMenu(hPopupMenu);
	}

	for (pos = m_MenuOriginalItems.GetStartPosition(); pos != NULL;)
	{
		UINT uiResId;
		CObList* pLstOrginItems = NULL;

		m_MenuOriginalItems.GetNextAssoc(pos, uiResId, pLstOrginItems);
		ASSERT_VALID(pLstOrginItems);

		while (!pLstOrginItems->IsEmpty())
		{
			delete pLstOrginItems->RemoveHead();
		}

		delete pLstOrginItems;
	}

	m_MenuOriginalItems.RemoveAll();

	return TRUE;
}

HMENU CContextMenuManager::GetMenuById(UINT nMenuResId) const
{
	HMENU hMenu = NULL ;
	return m_Menus.Lookup(nMenuResId, hMenu) ? hMenu : NULL;
}

void CContextMenuManager::CopyOriginalMenuItemsToMenu(UINT uiResId, CMFCPopupMenuBar& menuBar)
{
	CObList* pLstOrginItems = NULL;

	if (!m_MenuOriginalItems.Lookup(uiResId, pLstOrginItems))
	{
		return;
	}

	ASSERT_VALID(pLstOrginItems);

	if (pLstOrginItems->IsEmpty())
	{
		return;
	}

	CObList lstMenuItems;

	for (POSITION pos = pLstOrginItems->GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pSrcButton = DYNAMIC_DOWNCAST(CMFCToolBarButton, pLstOrginItems->GetNext(pos));
		ASSERT_VALID(pSrcButton);

		CRuntimeClass* pClass = pSrcButton->GetRuntimeClass();
		ENSURE(pClass != NULL);

		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pClass->CreateObject();
		ASSERT_VALID(pButton);

		pButton->CopyFrom(*pSrcButton);
		lstMenuItems.AddTail(pButton);
	}

	menuBar.SetOrigButtons(lstMenuItems);
}

void CContextMenuManager::CopyOriginalMenuItemsFromMenu(UINT uiResId, CMFCPopupMenuBar& menuBar)
{
	const CObList& lstMenuItems = menuBar.GetOrigButtons();

	CObList* pLstOrginItems = NULL;

	if (m_MenuOriginalItems.Lookup(uiResId, pLstOrginItems))
	{
		ASSERT_VALID(pLstOrginItems);

		while (!pLstOrginItems->IsEmpty())
		{
			delete pLstOrginItems->RemoveHead();
		}

		if (lstMenuItems.IsEmpty())
		{
			m_MenuOriginalItems.RemoveKey(uiResId);
			delete pLstOrginItems;
			return;
		}
	}
	else
	{
		if (lstMenuItems.IsEmpty())
		{
			return;
		}

		pLstOrginItems = new CObList;
		m_MenuOriginalItems.SetAt(uiResId, pLstOrginItems);
	}

	ASSERT_VALID(pLstOrginItems);

	for (POSITION pos = lstMenuItems.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pSrcButton = DYNAMIC_DOWNCAST(CMFCToolBarButton, lstMenuItems.GetNext(pos));
		ASSERT_VALID(pSrcButton);

		CRuntimeClass* pClass = pSrcButton->GetRuntimeClass();
		ENSURE(pClass != NULL);

		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pClass->CreateObject();
		ASSERT_VALID(pButton);

		pButton->CopyFrom(*pSrcButton);
		pLstOrginItems->AddTail(pButton);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcontrolbarimpl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarimpl.h"
#include "afxtoolbar.h"
#include "afxvisualmanager.h"
#include "afxglobals.h"
#include "afxpane.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CFrameWnd* g_pTopLevelFrame = NULL;

// Construction/Destruction
CMFCControlBarImpl::CMFCControlBarImpl(CPane* pBar) : m_pBar(pBar)
{
	ASSERT_VALID(m_pBar);
}

CMFCControlBarImpl::~CMFCControlBarImpl()
{
}

void CMFCControlBarImpl::DrawNcArea()
{
	CWindowDC dc(m_pBar);

	CRect rectClient;
	m_pBar->GetClientRect(rectClient);

	CRect rectWindow;
	m_pBar->GetWindowRect(rectWindow);

	m_pBar->ScreenToClient(rectWindow);
	rectClient.OffsetRect(-rectWindow.left, -rectWindow.top);
	dc.ExcludeClipRect(rectClient);

	BOOL bRTL = m_pBar->GetExStyle() & WS_EX_LAYOUTRTL;

	{
		MSG* pMsg = &AfxGetThreadState()->m_lastSentMsg;

		ASSERT(pMsg->hwnd == m_pBar->m_hWnd);
		ASSERT(pMsg->message == WM_NCPAINT);

		CRgn* pRgn = NULL;
		if (pMsg->wParam != 1 &&
			(pRgn = CRgn::FromHandle((HRGN) pMsg->wParam)) != NULL)
		{
			CRect rect;
			m_pBar->GetWindowRect(rect);

			if (bRTL)
			{
				CRect rect2;
				pRgn->GetRgnBox(&rect2);
				rect2.OffsetRect(rect.right - rect2.right - rect2.left, -rect.top);
				CRgn rgn;
				rgn.CreateRectRgnIndirect(&rect2);
				dc.SelectClipRgn(&rgn, RGN_AND);
			}
			else
			{
				pRgn->OffsetRgn(- rect.TopLeft());
				dc.SelectClipRgn(pRgn, RGN_AND);
			}
		}
	}

	// draw borders in non-client area
	rectWindow.OffsetRect(-rectWindow.left, -rectWindow.top);
	CMFCVisualManager::GetInstance()->OnDrawPaneBorder(&dc, m_pBar, rectWindow);

	// erase parts not drawn
	dc.IntersectClipRect(rectWindow);
	CMFCVisualManager::GetInstance()->OnFillBarBackground(&dc, m_pBar, rectWindow, CRect(0, 0, 0, 0), TRUE /* NC area */);

	// draw gripper in non-client area
	if ((m_pBar->GetPaneStyle() &(CBRS_GRIPPER|CBRS_FLOATING)) != CBRS_GRIPPER)
	{
		dc.SelectClipRgn(NULL);
		return;
	}

	CRect rectGripper;
	GetGripperRect(rectGripper);

	BOOL bHorz = (m_pBar->GetPaneStyle() & CBRS_ORIENT_HORZ) ? TRUE : FALSE;

	CMFCVisualManager::GetInstance()->OnDrawBarGripper(&dc, rectGripper, bHorz, m_pBar);

	dc.SelectClipRgn(NULL);
}

void CMFCControlBarImpl::CalcNcSize(NCCALCSIZE_PARAMS FAR* lpncsp)
{
	ASSERT_VALID(m_pBar);

	CRect rect; rect.SetRectEmpty();
	BOOL bHorz = m_pBar->IsHorizontal();

	m_pBar->CalcInsideRect(rect, bHorz);

	if (bHorz &&(m_pBar->GetExStyle() & WS_EX_LAYOUTRTL) &&((m_pBar->GetStyle() &(CBRS_GRIPPER|CBRS_FLOATING)) == CBRS_GRIPPER))
	{
		rect.OffsetRect(-(AFX_CX_BORDER_GRIPPER+AFX_CX_GRIPPER+AFX_CX_BORDER_GRIPPER), 0);
	}

	// adjust non-client area for border space
	lpncsp->rgrc[0].left += rect.left;
	lpncsp->rgrc[0].top += rect.top;

	lpncsp->rgrc[0].right += rect.right;
	lpncsp->rgrc[0].bottom += rect.bottom;
}

BOOL CMFCControlBarImpl::GetBackgroundFromParent(CDC* pDC)
{
	return afxGlobalData.DrawParentBackground(m_pBar, pDC);
}

void CMFCControlBarImpl::GetGripperRect(CRect& rectGripper, BOOL bClientCoord)
{
	ASSERT_VALID(m_pBar);

	if (m_pBar->GetParentDockSite() == NULL)
	{
		rectGripper.SetRectEmpty();
		return;
	}

	BOOL bRTL = m_pBar->GetExStyle() & WS_EX_LAYOUTRTL;
	BOOL bHorz = (m_pBar->GetPaneStyle() & CBRS_ORIENT_HORZ) ? TRUE : FALSE;

	m_pBar->GetWindowRect(&rectGripper);

	CRect rcClient;
	m_pBar->GetClientRect(&rcClient);
	m_pBar->ClientToScreen(&rcClient);

	if (bHorz)
	{
		if (bRTL)
		{
			rectGripper.left = rcClient.right - 1;
		}
		else
		{
			rectGripper.right = min(rectGripper.right, rcClient.left - 1);
		}
	}
	else
	{
		rectGripper.bottom = min(rectGripper.bottom, rcClient.top - 1);
	}

	if (bClientCoord)
	{
		m_pBar->ScreenToClient(&rectGripper);
	}
	else
	{
		rectGripper.OffsetRect(-rectGripper.left, -rectGripper.top);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcrit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



#pragma warning(disable: 4706) // assignment within conditional

/////////////////////////////////////////////////////////////////////////////
// global thread protection

#ifdef _MT

AFX_STATIC_DATA BOOL _afxCriticalInit = 0;   // set _afxGlobalLock, _afxTempLock init

// _afxResourceLock and _afxLockInit are used to lock each MFC global resource
AFX_STATIC_DATA CRITICAL_SECTION _afxResourceLock[CRIT_MAX] = { { 0 } };
AFX_STATIC_DATA CRITICAL_SECTION _afxLockInitLock = { 0 };
AFX_STATIC_DATA BOOL _afxLockInit[CRIT_MAX] = { 0 };
#ifdef _DEBUG
AFX_STATIC_DATA BOOL _afxResourceLocked[CRIT_MAX] = { 0 };
#endif

BOOL AFXAPI AfxCriticalInit()
{
	// Note: this must be initialized with only one thread running
	if (!_afxCriticalInit)
	{
		// now we are about to be initialized
		VERIFY(++_afxCriticalInit);
		InitializeCriticalSection(&_afxLockInitLock);
	}
	return _afxCriticalInit;
}

void AFXAPI AfxCriticalTerm()
{
	if (_afxCriticalInit)
	{
		VERIFY(!--_afxCriticalInit);

		// delete helper critical sections
		DeleteCriticalSection(&_afxLockInitLock);

		// delete specific resource critical sections
		for (int i = 0; i < CRIT_MAX; i++)
		{
#ifdef _DEBUG
			ASSERT(!_afxResourceLocked[i]);
#endif
			if (_afxLockInit[i])
			{
				DeleteCriticalSection(&_afxResourceLock[i]);
				VERIFY(!--_afxLockInit[i]);
			}
		}
	}
}

void AFXAPI AfxLockGlobals(int nLockType)
{
	ENSURE((UINT)nLockType < CRIT_MAX);

	// intialize global state, if necessary
	if (!_afxCriticalInit)
	{
		AfxCriticalInit();
		ASSERT(_afxCriticalInit);
	}

	// initialize specific resource if necessary
	if (!_afxLockInit[nLockType])
	{
		EnterCriticalSection(&_afxLockInitLock);
		if (!_afxLockInit[nLockType])
		{
			InitializeCriticalSection(&_afxResourceLock[nLockType]);
			VERIFY(++_afxLockInit[nLockType]);
		}
		LeaveCriticalSection(&_afxLockInitLock);
	}

	// lock specific resource
	EnterCriticalSection(&_afxResourceLock[nLockType]);
#ifdef _DEBUG
	ASSERT(++_afxResourceLocked[nLockType] > 0);
#endif
}

void AFXAPI AfxUnlockGlobals(int nLockType)
{
	ASSERT(_afxCriticalInit);
	ENSURE((UINT)nLockType < CRIT_MAX);

	// unlock specific resource
	ASSERT(_afxLockInit[nLockType]);
#ifdef _DEBUG
	ASSERT(--_afxResourceLocked[nLockType] >= 0);
#endif
	LeaveCriticalSection(&_afxResourceLock[nLockType]);
}

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcontrolrenderer.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolrenderer.h"
#include "afxdrawmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CMFCControlRendererInfo::CMFCControlRendererInfo()
{
	CommonInit();
}

CMFCControlRendererInfo::~CMFCControlRendererInfo()
{
}

CMFCControlRendererInfo::CMFCControlRendererInfo(UINT uiBmpResID, const CRect& rtImage, const CRect& rtCorners,
	const CRect& rtSides/* = CRect(0, 0, 0, 0)*/, const CRect& rtInner/* = CRect(0, 0, 0, 0)*/)
{
	CommonInit();
	SetResourceID(MAKEINTRESOURCE(uiBmpResID));

	m_rectImage      = rtImage;
	m_rectCorners    = rtCorners;
	m_rectSides      = rtSides;
	m_rectInter      = rtInner;
}

CMFCControlRendererInfo::CMFCControlRendererInfo(LPCTSTR lpszBmpResID, const CRect& rtImage, const CRect& rtCorners,
	const CRect& rtSides/* = CRect(0, 0, 0, 0)*/, const CRect& rtInner/* = CRect(0, 0, 0, 0)*/)
{
	CommonInit();
	SetResourceID(lpszBmpResID);

	m_rectImage      = rtImage;
	m_rectCorners    = rtCorners;
	m_rectSides      = rtSides;
	m_rectInter      = rtInner;
}

CMFCControlRendererInfo::CMFCControlRendererInfo(UINT uiBmpResID, COLORREF clrTransparent, const CRect& rtImage, const CRect& rtCorners,
	const CRect& rtSides/* = CRect(0, 0, 0, 0)*/, const CRect& rtInner/* = CRect(0, 0, 0, 0)*/, BOOL bPreMultiplyCheck/* = TRUE*/)
{
	CommonInit();
	SetResourceID(MAKEINTRESOURCE(uiBmpResID));

	m_rectImage         = rtImage;
	m_rectCorners	    = rtCorners;
	m_rectSides		    = rtSides;
	m_rectInter         = rtInner;
	m_clrTransparent    = clrTransparent;
	m_bPreMultiplyCheck = bPreMultiplyCheck;
}

CMFCControlRendererInfo::CMFCControlRendererInfo(LPCTSTR lpszBmpResID, COLORREF clrTransparent, const CRect& rtImage, const CRect& rtCorners,
	const CRect& rtSides/* = CRect(0, 0, 0, 0)*/, const CRect& rtInner/* = CRect(0, 0, 0, 0)*/, BOOL bPreMultiplyCheck/* = TRUE*/)
{
	CommonInit();
	SetResourceID(lpszBmpResID);

	m_rectImage         = rtImage;
	m_rectCorners       = rtCorners;
	m_rectSides         = rtSides;
	m_rectInter         = rtInner;
	m_clrTransparent    = clrTransparent;
	m_bPreMultiplyCheck = bPreMultiplyCheck;
}

CMFCControlRendererInfo::CMFCControlRendererInfo(const CMFCControlRendererInfo& rSrc)
{
	CommonInit();

	(*this) = rSrc;
}

void CMFCControlRendererInfo::CommonInit()
{
	m_uiBmpResID   = 0;
	m_strBmpResID.Empty();
	m_rectImage.SetRectEmpty();
	m_rectCorners.SetRectEmpty();
	m_rectSides.SetRectEmpty();
	m_rectInter.SetRectEmpty();
	m_clrTransparent    = CLR_DEFAULT;
	m_bPreMultiplyCheck = TRUE;
}

LPCTSTR CMFCControlRendererInfo::GetResourceID() const
{
	if (m_strBmpResID.IsEmpty())
	{
		return MAKEINTRESOURCE(m_uiBmpResID);
	}

	return m_strBmpResID;
}

void CMFCControlRendererInfo::SetResourceID(LPCTSTR lpszBmpResID)
{
	if (IS_INTRESOURCE(lpszBmpResID))
	{
		m_uiBmpResID = (UINT)((UINT_PTR)(lpszBmpResID));
	}
	else
	{
		m_strBmpResID = lpszBmpResID;
	}
}

CMFCControlRendererInfo& CMFCControlRendererInfo::operator = (const CMFCControlRendererInfo& rSrc)
{
	m_uiBmpResID        = rSrc.m_uiBmpResID;
	m_strBmpResID       = rSrc.m_strBmpResID;
	m_rectImage         = rSrc.m_rectImage;
	m_rectCorners       = rSrc.m_rectCorners;
	m_rectSides         = rSrc.m_rectSides;
	m_rectInter         = rSrc.m_rectInter;
	m_clrTransparent    = rSrc.m_clrTransparent;
	m_bPreMultiplyCheck = rSrc.m_bPreMultiplyCheck;

	return *this;
}

IMPLEMENT_DYNCREATE(CMFCControlRenderer, CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCControlRenderer::CMFCControlRenderer()
{
	m_bMirror = FALSE;
	m_bIsScaled = FALSE;
}

CMFCControlRenderer::~CMFCControlRenderer()
{
	CleanUp();
}

//////////////////////////////////////////////////////////////////////
// Operations
//////////////////////////////////////////////////////////////////////

BOOL CMFCControlRenderer::Create(const CMFCControlRendererInfo& params, BOOL bFlipvert /*= FALSE*/)
{
	CleanUp();

	m_Params = params;

	LPCTSTR lpszResID = m_Params.GetResourceID();
	if (lpszResID != NULL)
	{
		m_Bitmap.SetImageSize(m_Params.m_rectImage.Size());
		m_Bitmap.SetPreMultiplyAutoCheck(m_Params.m_bPreMultiplyCheck);
		m_Bitmap.SetMapTo3DColors(FALSE);
		m_Bitmap.LoadStr(lpszResID);

		if (bFlipvert)
		{
			m_Bitmap.MirrorVert();
		}

		if (m_Params.m_clrTransparent != CLR_DEFAULT)
		{
			m_Bitmap.SetTransparentColor(m_Params.m_clrTransparent);
		}

		if (CMFCToolBarImages::IsRTL() && m_Bitmap.GetImageWell() != NULL && m_Params.m_clrTransparent == CLR_DEFAULT)
		{
			BITMAP bmp;
			if (::GetObject(m_Bitmap.GetImageWell(), sizeof(BITMAP), &bmp) != 0)
			{
				if (bmp.bmBitsPixel == 32)
				{
					Mirror();
				}
			}
		}

		if (m_Params.m_rectSides.IsRectNull())
		{
			m_Params.m_rectSides = m_Params.m_rectCorners;
		}

		if (m_Params.m_rectInter.IsRectNull())
		{
			m_Params.m_rectInter = CRect(CPoint(0, 0), m_Params.m_rectImage.Size());
			m_Params.m_rectInter.left   += m_Params.m_rectCorners.left;
			m_Params.m_rectInter.top    += m_Params.m_rectCorners.top;
			m_Params.m_rectInter.right  -= m_Params.m_rectCorners.right;
			m_Params.m_rectInter.bottom -= m_Params.m_rectCorners.bottom;
		}

		if (bFlipvert)
		{
			long temp;
			temp = m_Params.m_rectCorners.top;
			m_Params.m_rectCorners.top = m_Params.m_rectCorners.bottom;
			m_Params.m_rectCorners.bottom = temp;

			temp = m_Params.m_rectSides.top;
			m_Params.m_rectSides.top = m_Params.m_rectSides.bottom;
			m_Params.m_rectSides.bottom = temp;

			long height = m_Params.m_rectImage.Height();
			temp = m_Params.m_rectInter.top;
			m_Params.m_rectInter.top = height - m_Params.m_rectInter.bottom;
			m_Params.m_rectInter.bottom = height - temp;
		}
	}

	return TRUE;
}

void CMFCControlRenderer::Mirror()
{
	if (m_Bitmap.Mirror())
	{
		m_bMirror = !m_bMirror;
	}
}

void CMFCControlRenderer::CleanUp()
{
	m_Bitmap.Clear();
	m_Bitmap.SetTransparentColor((COLORREF)(-1));

	CMFCControlRendererInfo emptyParams;
	m_Params = emptyParams;
	m_bMirror = FALSE;
}

void CMFCControlRenderer::Draw(CDC* pDC, CRect rect, UINT index, BYTE alphaSrc/* = 255*/)
{
	CRect rectInter(rect);
	rectInter.left   += m_Params.m_rectSides.left;
	rectInter.top    += m_Params.m_rectSides.top;
	rectInter.right  -= m_Params.m_rectSides.right;
	rectInter.bottom -= m_Params.m_rectSides.bottom;

	FillInterior(pDC, rectInter, index, alphaSrc);

	DrawFrame(pDC, rect, index, alphaSrc);
}

void CMFCControlRenderer::DrawFrame(CDC* pDC, CRect rect, UINT index, BYTE alphaSrc/* = 255*/)
{
	struct XHVTypes
	{
		CMFCToolBarImages::ImageAlignHorz horz;
		CMFCToolBarImages::ImageAlignVert vert;
	};

	XHVTypes corners[4] = 
	{
		{CMFCToolBarImages::ImageAlignHorzLeft , CMFCToolBarImages::ImageAlignVertTop},
		{CMFCToolBarImages::ImageAlignHorzRight, CMFCToolBarImages::ImageAlignVertTop},
		{CMFCToolBarImages::ImageAlignHorzLeft , CMFCToolBarImages::ImageAlignVertBottom},
		{CMFCToolBarImages::ImageAlignHorzRight, CMFCToolBarImages::ImageAlignVertBottom}
	};

	XHVTypes sides[4] =
	{
		{CMFCToolBarImages::ImageAlignHorzLeft   , CMFCToolBarImages::ImageAlignVertStretch},
		{CMFCToolBarImages::ImageAlignHorzRight  , CMFCToolBarImages::ImageAlignVertStretch},
		{CMFCToolBarImages::ImageAlignHorzStretch, CMFCToolBarImages::ImageAlignVertTop},
		{CMFCToolBarImages::ImageAlignHorzStretch, CMFCToolBarImages::ImageAlignVertBottom}
	};

	CRect rectImage(m_Params.m_rectImage);
	int ind = index;
	if (m_Bitmap.GetCount() == 1)
	{
		rectImage.OffsetRect(0, m_Params.m_rectImage.Size().cy * ind);
		ind = 0;
	}

	CRect rt(rect);
	CRect rectCorners(m_Params.m_rectCorners);
	CRect rectSides(m_Params.m_rectSides);

	rt.left   += rectCorners.left;
	rt.top    += rectCorners.top;
	rt.right  -= rectCorners.right;
	rt.bottom -= rectCorners.bottom;

	if (rt.Width() > 0 || rt.Height() > 0)
	{
		if (rt.Height() > 0)
		{
			if (rectSides.left > 0)
			{
				CRect r(rt);
				r.left  = rect.left;
				r.right = r.left + rectSides.left;

				CRect rectPart;
				if (m_bMirror)
				{
					rectPart = CRect(rectImage.right - rectSides.left, rectImage.top + rectCorners.top, rectImage.right, rectImage.bottom - rectCorners.bottom);
				}
				else
				{
					rectPart = CRect(rectImage.left, rectImage.top + rectCorners.top, rectImage.left + rectSides.left, rectImage.bottom - rectCorners.bottom);
				}

				m_Bitmap.DrawEx(pDC, r, ind, sides[0].horz, sides[0].vert, rectPart, alphaSrc);
			}

			if (rectSides.right > 0)
			{
				CRect r(rt);
				r.right = rect.right;
				r.left  = r.right - rectSides.right;

				CRect rectPart;
				if (m_bMirror)
				{
					rectPart = CRect(rectImage.left, rectImage.top + rectCorners.top, rectImage.left + rectSides.right, rectImage.bottom - rectCorners.bottom);
				}
				else
				{
					rectPart = CRect(rectImage.right - rectSides.right, rectImage.top + rectCorners.top, rectImage.right, rectImage.bottom - rectCorners.bottom);
				}

				m_Bitmap.DrawEx(pDC, r, ind, sides[1].horz, sides[1].vert, rectPart, alphaSrc);
			}
		}

		if (rt.Width() > 0)
		{
			if (rectSides.top > 0)
			{
				CRect r(rt);
				r.top    = rect.top;
				r.bottom = r.top + rectSides.top;

				CRect rectPart;
				if (m_bMirror)
				{
					rectPart = CRect(rectImage.left + rectCorners.right, rectImage.top, rectImage.right - rectCorners.left, rectImage.top + rectSides.top);
				}
				else
				{
					rectPart = CRect(rectImage.left + rectCorners.left, rectImage.top, rectImage.right - rectCorners.right, rectImage.top + rectSides.top);
				}

				m_Bitmap.DrawEx(pDC, r, ind, sides[2].horz, sides[2].vert, rectPart, alphaSrc);
			}

			if (rectSides.bottom > 0)
			{
				CRect r(rt);
				r.bottom = rect.bottom;
				r.top    = r.bottom - rectSides.bottom;

				CRect rectPart;
				if (m_bMirror)
				{
					rectPart = CRect(rectImage.left + rectCorners.right, rectImage.bottom - rectSides.bottom, rectImage.right - rectCorners.left, rectImage.bottom);
				}
				else
				{
					rectPart = CRect(rectImage.left + rectCorners.left, rectImage.bottom - rectSides.bottom, rectImage.right - rectCorners.right, rectImage.bottom);
				}

				m_Bitmap.DrawEx(pDC, r, ind, sides[3].horz, sides[3].vert, rectPart, alphaSrc);
			}
		}

		if (rectCorners.left > 0 && rectCorners.top > 0)
		{
			CRect rectPart;
			if (m_bMirror)
			{
				rectPart = CRect(CPoint(rectImage.right - rectCorners.left, rectImage.top), CSize(rectCorners.left, rectCorners.top));
			}
			else
			{
				rectPart = CRect(CPoint(rectImage.left, rectImage.top), CSize(rectCorners.left, rectCorners.top));
			}

			m_Bitmap.DrawEx(pDC, rect, ind, corners[0].horz, corners[0].vert, rectPart, alphaSrc);
		}

		if (rectCorners.right > 0 && rectCorners.top > 0)
		{
			CRect rectPart;
			if (m_bMirror)
			{
				rectPart = CRect(CPoint(rectImage.left, rectImage.top), CSize(rectCorners.right, rectCorners.top));
			}
			else
			{
				rectPart = CRect(CPoint(rectImage.right - rectCorners.right, rectImage.top), CSize(rectCorners.right, rectCorners.top));
			}

			m_Bitmap.DrawEx(pDC, rect, ind, corners[1].horz, corners[1].vert, rectPart, alphaSrc);
		}

		if (rectCorners.left > 0 && rectCorners.bottom > 0)
		{
			CRect rectPart;
			if (m_bMirror)
			{
				rectPart = CRect(CPoint(rectImage.right - rectCorners.left, rectImage.bottom - rectCorners.bottom), CSize(rectCorners.left, rectCorners.bottom));
			}
			else
			{
				rectPart = CRect(CPoint(rectImage.left, rectImage.bottom - rectCorners.bottom), CSize(rectCorners.left, rectCorners.bottom));
			}

			m_Bitmap.DrawEx(pDC, rect, ind, corners[2].horz, corners[2].vert, rectPart, alphaSrc);
		}

		if (rectCorners.right > 0 && rectCorners.bottom > 0)
		{
			CRect rectPart;
			if (m_bMirror)
			{
				rectPart = CRect(CPoint(rectImage.left, rectImage.bottom - rectCorners.bottom), CSize(rectCorners.right, rectCorners.bottom));
			}
			else
			{
				rectPart = CRect(CPoint(rectImage.right - rectCorners.right, rectImage.bottom - rectCorners.bottom), CSize(rectCorners.right, rectCorners.bottom));
			}

			m_Bitmap.DrawEx(pDC, rect, ind, corners[3].horz, corners[3].vert, rectPart, alphaSrc);
		}
	}
}

void CMFCControlRenderer::FillInterior(CDC* pDC, CRect rect, CMFCToolBarImages::ImageAlignHorz horz, CMFCToolBarImages::ImageAlignVert vert, UINT index, BYTE alphaSrc/* = 255*/)
{
	if (m_Params.m_rectInter.IsRectEmpty())
	{
		return;
	}

	CRect rectImage(m_Params.m_rectInter);

	if (m_bMirror)
	{
		rectImage.left  = m_Params.m_rectImage.Size().cx - m_Params.m_rectInter.right;
		rectImage.right = rectImage.left + m_Params.m_rectInter.Width();
	}

	rectImage.OffsetRect(m_Params.m_rectImage.TopLeft());

	int ind = index;
	if (m_Bitmap.GetCount() == 1)
	{
		rectImage.OffsetRect(0, m_Params.m_rectImage.Size().cy * ind);
		ind = 0;
	}

	m_Bitmap.DrawEx(pDC, rect, ind, horz, vert, rectImage, alphaSrc);
}

void CMFCControlRenderer::FillInterior(CDC* pDC, CRect rect, UINT index, BYTE alphaSrc/* = 255*/)
{
	FillInterior(pDC, rect, CMFCToolBarImages::ImageAlignHorzStretch, CMFCToolBarImages::ImageAlignVertStretch, index, alphaSrc);
}

void CMFCControlRenderer::OnSysColorChange()
{
	if (m_Bitmap.GetImageWell() != NULL)
	{
		m_Bitmap.OnSysColorChange();
	}
}


static void ResizeRect(CRect& rect, double dblScale)
{
	int nWidth = rect.Width();
	int nHeight = rect.Height();

	rect.left = (int)(.5 + dblScale * rect.left);
	rect.top = (int)(.5 + dblScale * rect.top);

	rect.right = rect.left + (int)(.5 + dblScale * nWidth);
	rect.bottom = rect.top + (int)(.5 + dblScale * nHeight);
}

BOOL CMFCControlRenderer::SmoothResize(double dblScale)
{
	if (dblScale <= 1. || !m_Bitmap.SmoothResize(dblScale))
	{
		return FALSE;
	}

	ResizeRect(m_Params.m_rectImage, dblScale);
	ResizeRect(m_Params.m_rectInter, dblScale);

	m_bIsScaled = TRUE;
	return TRUE;
}

IMPLEMENT_DYNCREATE(CMFCShadowRenderer, CMFCControlRenderer)

CMFCShadowRenderer::CMFCShadowRenderer()
{
}

CMFCShadowRenderer::~CMFCShadowRenderer()
{
}

BOOL CMFCShadowRenderer::Create (const CMFCControlRendererInfo& /*params*/, BOOL /*bFlipvert*/ /*= FALSE*/)
{
	return FALSE;
}

BOOL CMFCShadowRenderer::Create (int nDepth,
								  COLORREF clrBase,
                                  int iMinBrightness/* = 0*/, int iMaxBrightness/* = 100*/)
{
	CleanUp ();

	HBITMAP hBitmap = CDrawingManager::PrepareShadowMask (nDepth, clrBase, iMinBrightness, iMaxBrightness);
	if (hBitmap == NULL)
	{
		return FALSE;
	}

	int nSize     = nDepth < 3 ? 3 : nDepth;
	int nDestSize = nSize * 2 + 1;

	m_Params.m_rectImage   = CRect (0, 0, nDestSize, nDestSize);
	m_Params.m_rectCorners = CRect (nSize, nSize, nSize, nSize);
	m_Params.m_rectSides = m_Params.m_rectCorners;

	m_Params.m_rectInter = CRect (CPoint (0, 0), m_Params.m_rectImage.Size ());
	m_Params.m_rectInter.left   += m_Params.m_rectCorners.left;
	m_Params.m_rectInter.top    += m_Params.m_rectCorners.top;
	m_Params.m_rectInter.right  -= m_Params.m_rectCorners.right;
	m_Params.m_rectInter.bottom -= m_Params.m_rectCorners.bottom;

	m_Bitmap.SetImageSize (m_Params.m_rectImage.Size ());
	m_Bitmap.SetPreMultiplyAutoCheck (m_Params.m_bPreMultiplyCheck);
	m_Bitmap.SetMapTo3DColors (FALSE);

	m_Bitmap.AddImage (hBitmap, TRUE);

	::DeleteObject (hBitmap);

	return m_Bitmap.GetCount () == 1;
}

void CMFCShadowRenderer::OnSysColorChange ()
{
}

void CMFCShadowRenderer::Draw (CDC* pDC, CRect rect, UINT index/* = 0*/, BYTE alphaSrc/* = 255*/)
{
	CRect rectInter (rect);
	
	if (CMFCToolBarImages::IsRTL ())
	{
		rectInter.left   += m_Params.m_rectSides.left;
		rectInter.right   = rectInter.left + m_Params.m_rectSides.left;
	}
	else
	{
		rectInter.right  -= m_Params.m_rectSides.right;
		rectInter.left    = rectInter.right - m_Params.m_rectSides.right;
	}

	rectInter.bottom -= m_Params.m_rectSides.bottom;
	rectInter.top     = rectInter.bottom - m_Params.m_rectSides.bottom;

	FillInterior (pDC, rectInter, index, alphaSrc);

	DrawFrame (pDC, rect, index, alphaSrc);
}

void CMFCShadowRenderer::DrawFrame (CDC* pDC, CRect rect, UINT index/* = 0*/, BYTE alphaSrc/* = 255*/)
{
	struct XHVTypes
	{
		CMFCToolBarImages::ImageAlignHorz horz;
		CMFCToolBarImages::ImageAlignVert vert;
	};

	XHVTypes corners[4] = 
	{
		{CMFCToolBarImages::ImageAlignHorzLeft , CMFCToolBarImages::ImageAlignVertTop},
		{CMFCToolBarImages::ImageAlignHorzRight, CMFCToolBarImages::ImageAlignVertTop},
		{CMFCToolBarImages::ImageAlignHorzLeft , CMFCToolBarImages::ImageAlignVertBottom},
		{CMFCToolBarImages::ImageAlignHorzRight, CMFCToolBarImages::ImageAlignVertBottom}
	};

	XHVTypes sides[4] = 
	{
		{CMFCToolBarImages::ImageAlignHorzLeft   , CMFCToolBarImages::ImageAlignVertStretch},
		{CMFCToolBarImages::ImageAlignHorzRight  , CMFCToolBarImages::ImageAlignVertStretch},
		{CMFCToolBarImages::ImageAlignHorzStretch, CMFCToolBarImages::ImageAlignVertTop},
		{CMFCToolBarImages::ImageAlignHorzStretch, CMFCToolBarImages::ImageAlignVertBottom}
	};

	CRect rectImage (m_Params.m_rectImage);
	int ind = index;
	if (m_Bitmap.GetCount () == 1)
	{
		rectImage.OffsetRect (0, m_Params.m_rectImage.Size ().cy * ind);
		ind = 0;
	}

	CRect rt  (rect);
	CRect rectCorners (m_Params.m_rectCorners);
	CRect rectSides   (m_Params.m_rectSides);

	rt.left   += rectCorners.left;
	rt.top    += rectCorners.top;
	rt.right  -= rectCorners.right;
	rt.bottom -= rectCorners.bottom;

	BOOL bRTL = CMFCToolBarImages::IsRTL ();

	if (rt.Width () > 0 || rt.Height () > 0)
	{
		if (rt.Height () > 0)
		{
			if (bRTL)
			{
				if (rectSides.left > 0)
				{
					CRect r (rt);
					r.left  = rect.left;
					r.right = r.left + rectSides.left;

					CRect rectPart (rectImage.left, 
						rectImage.top + rectCorners.top, rectImage.left + rectSides.left, rectImage.bottom - rectCorners.bottom);

					m_Bitmap.DrawEx (pDC, r, ind, sides[0].horz, sides[0].vert, rectPart, alphaSrc);
				}
			}
			else
			{
				if (rectSides.right > 0)
				{
					CRect r (rt);
					r.right = rect.right;
					r.left  = r.right - rectSides.right;

					CRect rectPart  (rectImage.right - rectSides.right, 
    						rectImage.top + rectCorners.top, rectImage.right, rectImage.bottom - rectCorners.bottom);

					m_Bitmap.DrawEx (pDC, r, ind, sides[1].horz, sides[1].vert, rectPart, alphaSrc);
				}
			}	
		}

		if (rt.Width () > 0)
		{
			if (rectSides.bottom > 0)
			{
				CRect r (rt);
				r.bottom = rect.bottom;
				r.top    = r.bottom - rectSides.bottom;
				
				CRect rectPart  (rectImage.left + rectCorners.left, 
    					rectImage.bottom - rectSides.bottom, rectImage.right - rectCorners.right, rectImage.bottom);

				m_Bitmap.DrawEx (pDC, r, ind, sides[3].horz, sides[3].vert, rectPart, alphaSrc);
			}
		}

		if (bRTL)
		{
			if (rectCorners.left > 0 && rectCorners.top > 0)
			{
				CRect rectPart (CPoint (rectImage.left, rectImage.top), 
						CSize (rectCorners.left, rectCorners.top));

				m_Bitmap.DrawEx (pDC, rect, ind, corners[0].horz, corners[0].vert, rectPart, alphaSrc);
			}
		}
		else
		{
			if (rectCorners.right > 0 && rectCorners.top > 0)
			{
				CRect rectPart (CPoint (rectImage.right - rectCorners.right, rectImage.top), 
						CSize (rectCorners.right, rectCorners.top));

				m_Bitmap.DrawEx (pDC, rect, ind, corners[1].horz, corners[1].vert, rectPart, alphaSrc);
			}
		}

		if (rectCorners.left > 0 && rectCorners.bottom > 0)
		{
			CRect rectPart (CPoint (rectImage.left, rectImage.bottom - rectCorners.bottom), 
					CSize (rectCorners.left, rectCorners.bottom));

			m_Bitmap.DrawEx (pDC, rect, ind, corners[2].horz, corners[2].vert, rectPart, alphaSrc);
		}

		if (rectCorners.right > 0 && rectCorners.bottom > 0)
		{
			CRect rectPart (CPoint (rectImage.right - rectCorners.right, rectImage.bottom - rectCorners.bottom), 
					CSize (rectCorners.right, rectCorners.bottom));

			m_Bitmap.DrawEx (pDC, rect, ind, corners[3].horz, corners[3].vert, rectPart, alphaSrc);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxctrlcontainer.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//
// CWnd support for MFC Control containment (Feature Pack controls)
//

#include "stdafx.h"
#include "afxctrlcontainer.h"
#include "afxtagmanager.h"
#include "afxbutton.h"
#include "afxcolorbutton.h"
#include "afxeditbrowsectrl.h"
#include "afxfontcombobox.h"
#include "afxlinkctrl.h"
#include "afxmaskededit.h"
#include "afxmenubutton.h"
#include "afxpropertygridctrl.h"
#include "afxshelllistctrl.h"
#include "afxshelltreectrl.h"
#include "afxvslistbox.h"

////////////////////////////////////////////////////////////////////////////

static void DoRegisterWindowClass(LPCTSTR lpszClassName, LPCTSTR lpszBaseClassName)
{
	ASSERT(lpszClassName != NULL);
	ASSERT(lpszBaseClassName != NULL);

	WNDCLASS wnd = {0};

	HINSTANCE hInst = AfxGetInstanceHandle();
	if (!AfxCtxGetClassInfo(hInst, lpszBaseClassName, &wnd))
	{
		wnd.style = CS_DBLCLKS;
		wnd.hInstance = hInst;
		wnd.lpfnWndProc = ::DefWindowProc;
	}

	wnd.lpszClassName = lpszClassName;
	AfxRegisterClass(&wnd);
}

void AfxRegisterMFCCtrlClasses()
{
	DoRegisterWindowClass(_T("MFCButton"), WC_BUTTON);
	DoRegisterWindowClass(_T("MFCColorButton"), WC_BUTTON);
	DoRegisterWindowClass(_T("MFCEditBrowse"), WC_EDIT);
	DoRegisterWindowClass(_T("MFCFontComboBox"), WC_COMBOBOX);
	DoRegisterWindowClass(_T("MFCLink"), WC_BUTTON);
	DoRegisterWindowClass(_T("MFCMaskedEdit"), WC_EDIT);
	DoRegisterWindowClass(_T("MFCMenuButton"), WC_BUTTON);
	DoRegisterWindowClass(_T("MFCPropertyGrid"), WC_STATIC);
	DoRegisterWindowClass(_T("MFCShellList"), WC_LISTVIEW);
	DoRegisterWindowClass(_T("MFCShellTree"), WC_TREEVIEW);
	DoRegisterWindowClass(_T("MFCVSListBox"), WC_STATIC);
}

////////////////////////////////////////////////////////////////////////////
// CMFCControlContainer

CMFCControlContainer::CMFCControlContainer(CWnd* pWnd) : m_pWnd(pWnd)
{
}

CMFCControlContainer::~CMFCControlContainer()
{
	FreeSubclassedControls();
	ClearControlData();
}

BOOL CMFCControlContainer::SubclassDlgControls()
{
	if (m_pWnd->GetSafeHwnd() != NULL)
	{
		// Subclass Feature Pack controls:
		CWnd* pWndChild = m_pWnd->GetWindow(GW_CHILD);
		while (pWndChild != NULL)
		{
			ASSERT_VALID(pWndChild);

			TCHAR lpszClassName [MAX_CLASS_NAME + 1];

			::GetClassName(pWndChild->GetSafeHwnd(), lpszClassName, MAX_CLASS_NAME);
			CWnd* pWndSubclassedCtrl = CreateDlgControl(lpszClassName);

			if (pWndSubclassedCtrl != NULL)
			{
				m_arSubclassedCtrls.Add((CObject*)pWndSubclassedCtrl);
				pWndSubclassedCtrl->SubclassWindow(pWndChild->GetSafeHwnd());
			}

			pWndChild = pWndChild->GetNextWindow();
		}

		return TRUE;
	}

	return FALSE;
}

void CMFCControlContainer::FreeSubclassedControls()
{
	// Free subclassed controls: 
	for (int i = 0; i < m_arSubclassedCtrls.GetCount(); i++)
	{
		if (m_arSubclassedCtrls [i] != NULL)
		{
			delete m_arSubclassedCtrls [i];
		}
	}
	m_arSubclassedCtrls.RemoveAll();
}

CWnd* CMFCControlContainer::CreateDlgControl(LPCTSTR lpszClassName)
{
	ASSERT(m_pWnd->GetSafeHwnd() != NULL);

	if (lpszClassName != NULL)
	{
		CString strClass = lpszClassName;
		CWnd* pWndSubclassedCtrl = NULL;

		if (strClass == _T("MFCButton"))
		{
			pWndSubclassedCtrl = new CMFCButton;
		}
		else if (strClass == _T("MFCColorButton"))
		{
			pWndSubclassedCtrl = new CMFCColorButton;
		}
		else if (strClass == _T("MFCEditBrowse"))
		{
			pWndSubclassedCtrl = new CMFCEditBrowseCtrl;
		}
		else if (strClass == _T("MFCFontComboBox"))
		{
			pWndSubclassedCtrl = new CMFCFontComboBox;
		}
		else if (strClass == _T("MFCLink"))
		{
			pWndSubclassedCtrl = new CMFCLinkCtrl;
		}
		else if (strClass == _T("MFCMaskedEdit"))
		{
			pWndSubclassedCtrl = new CMFCMaskedEdit;
		}
		else if (strClass == _T("MFCMenuButton"))
		{
			pWndSubclassedCtrl = new CMFCMenuButton;
		}
		else if (strClass == _T("MFCPropertyGrid"))
		{
			pWndSubclassedCtrl = new CMFCPropertyGridCtrl;
		}
		else if (strClass == _T("MFCShellList"))
		{
			pWndSubclassedCtrl = new CMFCShellListCtrl;
		}
		else if (strClass == _T("MFCShellTree"))
		{
			pWndSubclassedCtrl = new CMFCShellTreeCtrl;
		}
		else if (strClass == _T("MFCVSListBox"))
		{
			pWndSubclassedCtrl = new CVSListBox;
		}

		return pWndSubclassedCtrl;
	}

	return NULL;
}

BOOL CMFCControlContainer::IsSubclassedFeaturePackControl(HWND hWndCtrl)
{
	if (hWndCtrl == NULL)
	{
		return FALSE;
	}

	for (int i = 0; i < m_arSubclassedCtrls.GetCount(); i++)
	{
		CWnd* pWnd = (CWnd*)m_arSubclassedCtrls[i];
		if (pWnd->GetSafeHwnd() == hWndCtrl)
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CMFCControlContainer::PreUnsubclassControl(CWnd* pControl)
{
	CMFCShellListCtrl* pListCtrl = DYNAMIC_DOWNCAST(CMFCShellListCtrl, pControl);
	if (pListCtrl != NULL && pListCtrl->GetHeaderCtrl().GetSafeHwnd() != NULL)
	{
		pListCtrl->GetHeaderCtrl().UnsubclassWindow();
	}
}

BOOL CMFCControlContainer::ReSubclassControl(HWND hWndCtrl, WORD nIDC, CWnd& control)
{
	if (hWndCtrl == NULL)
	{
		return FALSE;
	}

	int nIndex = -1;
	for (int i = 0; i < m_arSubclassedCtrls.GetCount(); i++)
	{
		CWnd* pWnd = (CWnd*)m_arSubclassedCtrls [i];
		if (pWnd->GetSafeHwnd() == hWndCtrl)
		{
			nIndex = i;
			break;
		}
	}

	if (nIndex != -1)
	{
		CWnd* pWnd = DYNAMIC_DOWNCAST(CWnd, m_arSubclassedCtrls [nIndex]);
		
		if (pWnd->GetSafeHwnd() != NULL)
		{
			ASSERT_VALID(pWnd);

			// get init state
			DWORD dwSize = 0;
			BYTE* pbInitData = NULL;
			GetControlData(nIDC, dwSize, pbInitData);

			// Free old subclassed control:
			m_arSubclassedCtrls [nIndex] = NULL;

			// unsubclass
			PreUnsubclassControl(pWnd);
			VERIFY(pWnd->UnsubclassWindow() == hWndCtrl);
			// destroy
			delete pWnd;

			// subclass
			if (!control.SubclassWindow(hWndCtrl))
			{
				ASSERT(FALSE);      // possibly trying to subclass twice?
				AfxThrowNotSupportedException();
			}

			// set init state
			if (dwSize > 0)
			{
				control.SendMessage(WM_MFC_INITCTRL, (WPARAM)dwSize, (LPARAM)pbInitData);
			}

			return TRUE;
		}
	}

	return FALSE;
}

void CMFCControlContainer::SetControlData(WORD nIDC, DWORD dwSize, BYTE* pbData)
{
	CByteArray* pArray = new CByteArray;
	pArray->SetSize(dwSize);

	BYTE* pbBuffer = pArray->GetData();
	if (memcpy_s(pbBuffer, dwSize, pbData, dwSize) != 0)
	{
		delete pArray;
		ASSERT(FALSE);
		return;
	}

	m_mapControlData.SetAt(nIDC, pArray);
}

BOOL CMFCControlContainer::GetControlData(WORD nIDC, DWORD& dwSize, BYTE*& pbData)
{
	CObject* pData = NULL;
	if (m_mapControlData.Lookup(nIDC, pData) && pData != NULL)
	{
		CByteArray* pArray = (CByteArray*)pData;
		dwSize = (DWORD)pArray->GetSize();
		pbData = pArray->GetData();
		return TRUE;
	}

	return FALSE;
}

void CMFCControlContainer::ClearControlData()
{
	WORD nIDC;
	CObject* pData = NULL;
	POSITION pos = m_mapControlData.GetStartPosition();
	while (pos != NULL)
	{
		m_mapControlData.GetNextAssoc(pos, nIDC, pData); 
		CByteArray* pArray = (CByteArray*)pData; 
		delete pArray;
	}

	m_mapControlData.RemoveAll();
}

////////////////////////////////////////////////////////////////////////////
// Accessing dialog DLGINIT helpers

int __stdcall CMFCControlContainer::UTF8ToString(LPCSTR lpSrc, CString& strDst, int nLength)
{
	LPTSTR lpDst = NULL;
	int count = ::MultiByteToWideChar(CP_UTF8, 0, lpSrc, nLength, NULL, 0);
	if (count <= 0)
	{
		return 0;
	}

	LPWSTR lpWide = new WCHAR[count + 1];
	memset(lpWide, 0, (count + 1) * sizeof(WCHAR));

	::MultiByteToWideChar(CP_UTF8, 0, lpSrc, nLength, lpWide, count);

#ifdef _UNICODE
	lpDst = lpWide;
#else
	count = ::WideCharToMultiByte(::GetACP(), 0, lpWide, -1, NULL, 0, NULL, 0);

	if (count > 0)
	{
		lpDst = new char[count + 1];
		memset(lpDst, 0, count + 1);

		::WideCharToMultiByte(::GetACP(), 0, lpWide, -1, lpDst, count, NULL, 0);
	}

	delete [] lpWide;
#endif

	strDst = lpDst;
	delete[] lpDst;
	return count;
}

BOOL __stdcall CMFCControlContainer::ReadBoolProp(CTagManager& tagManager, LPCTSTR lpszTag, BOOL& bMember)
{
	if (lpszTag == NULL)
	{
		return FALSE;
	}

	CString str;
	tagManager.ExcludeTag(lpszTag, str);

	if (str.IsEmpty())
	{
		return FALSE;
	}

	bMember = (str.CompareNoCase(PS_True) == 0);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcustomcolorspropertypage.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxcontrolbarutil.h"
#include "afxcolordialog.h"
#include "afxdrawmanager.h"
#include "afxribbonres.h"
#include "afxcustomcolorspropertypage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static double __stdcall Int2HLS(UINT n)
{
	return min(1., (double)(.5 + n) / 255.);
}

static UINT __stdcall HLS2Int(double n)
{
	return min(255, (UINT)(.5 + n * 255.));
}

/////////////////////////////////////////////////////////////////////////////
// CMFCCustomColorsPropertyPage property page

IMPLEMENT_DYNCREATE(CMFCCustomColorsPropertyPage, CPropertyPage)

CMFCCustomColorsPropertyPage::CMFCCustomColorsPropertyPage() : CPropertyPage(CMFCCustomColorsPropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CMFCCustomColorsPropertyPage)
	m_r = 0;
	m_b = 0;
	m_g = 0;
	m_l = 0;
	m_h = 0;
	m_s = 0;
	//}}AFX_DATA_INIT

	m_pDialog = NULL;
	m_bIsReady = FALSE;
	m_bInUpdate = FALSE;
}

void CMFCCustomColorsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCCustomColorsPropertyPage)
	DDX_Control(pDX, IDC_AFXBARRES_LUMINANCEPLACEHOLDER, m_wndLuminance);
	DDX_Control(pDX, IDC_AFXBARRES_COLOURPLACEHOLDER, m_wndColorPicker);
	DDX_Text(pDX, IDC_AFXBARRES_R, m_r);
	DDX_Text(pDX, IDC_AFXBARRES_B, m_b);
	DDX_Text(pDX, IDC_AFXBARRES_G, m_g);
	DDX_Text(pDX, IDC_AFXBARRES_L, m_l);
	DDX_Text(pDX, IDC_AFXBARRES_H, m_h);
	DDX_Text(pDX, IDC_AFXBARRES_S, m_s);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCCustomColorsPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCCustomColorsPropertyPage)
	ON_EN_CHANGE(IDC_AFXBARRES_B, &CMFCCustomColorsPropertyPage::OnRGBChanged)
	ON_EN_CHANGE(IDC_AFXBARRES_H, &CMFCCustomColorsPropertyPage::OnHLSChanged)
	ON_EN_CHANGE(IDC_AFXBARRES_G, &CMFCCustomColorsPropertyPage::OnRGBChanged)
	ON_EN_CHANGE(IDC_AFXBARRES_R, &CMFCCustomColorsPropertyPage::OnRGBChanged)
	ON_EN_CHANGE(IDC_AFXBARRES_L, &CMFCCustomColorsPropertyPage::OnHLSChanged)
	ON_EN_CHANGE(IDC_AFXBARRES_S, &CMFCCustomColorsPropertyPage::OnHLSChanged)
	ON_BN_CLICKED(IDC_AFXBARRES_LUMINANCEPLACEHOLDER, &CMFCCustomColorsPropertyPage::OnLuminance)
	ON_BN_CLICKED(IDC_AFXBARRES_COLOURPLACEHOLDER, &CMFCCustomColorsPropertyPage::OnColour)
	ON_BN_DOUBLECLICKED(IDC_AFXBARRES_COLOURPLACEHOLDER, &CMFCCustomColorsPropertyPage::OnDoubleClickedColor)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCCustomColorsPropertyPage message handlers

BOOL CMFCCustomColorsPropertyPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	m_wndColorPicker.SetPalette(m_pDialog->GetPalette());
	m_wndColorPicker.SetType(CMFCColorPickerCtrl::PICKER);

	double hue, luminance, saturation;

	m_wndColorPicker.GetHLS(&hue, &luminance, &saturation);

	m_wndLuminance.SetPalette(m_pDialog->GetPalette());
	m_wndLuminance.SetType(CMFCColorPickerCtrl::LUMINANCE);
	m_wndLuminance.SetHLS(hue, luminance, saturation);
	m_wndLuminance.SetLuminanceBarWidth(14);

	// Initialize spin controls:
	for (UINT uiID = IDC_AFXBARRES_SPIN1; uiID <= IDC_AFXBARRES_SPIN6; uiID++)
	{
		CSpinButtonCtrl* pWnd = (CSpinButtonCtrl*) GetDlgItem(uiID);
		if (pWnd == NULL)
		{
			VERIFY(FALSE);
			break;
		}

		pWnd->SetRange(0, 255);
	}

	m_bIsReady = TRUE;
	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCCustomColorsPropertyPage::OnRGBChanged()
{
	if (m_bInUpdate || !m_bIsReady)
	{
		return;
	}

	CString str;

	GetDlgItemText(IDC_AFXBARRES_R, str);
	if (str.IsEmpty())
	{
		return;
	}

	GetDlgItemText(IDC_AFXBARRES_G, str);
	if (str.IsEmpty())
	{
		return;
	}

	GetDlgItemText(IDC_AFXBARRES_B, str);
	if (str.IsEmpty())
	{
		return;
	}

	if (!UpdateData())
	{
		return;
	}

	m_bInUpdate = TRUE;
	COLORREF color = RGB(m_r, m_g, m_b);

	m_r = min(m_r, 255);
	m_g = min(m_g, 255);
	m_b = min(m_b, 255);

	m_pDialog->SetNewColor(color);
	m_pDialog->SetPageOne((BYTE) m_r, (BYTE) m_g, (BYTE) m_b);

	double hue;
	double luminance;
	double saturation;
	CDrawingManager::RGBtoHSL(color, &hue, &saturation, &luminance);

	m_h = HLS2Int(hue);
	m_l = HLS2Int(luminance);
	m_s = HLS2Int(saturation);

	UpdateData(FALSE);

	m_wndColorPicker.SetHLS(hue, luminance, saturation, TRUE);
	m_wndLuminance.SetHLS(hue, luminance, saturation, TRUE);

	m_bInUpdate = FALSE;
}

void CMFCCustomColorsPropertyPage::OnHLSChanged()
{
	if (m_bInUpdate || !m_bIsReady)
	{
		return;
	}

	CString str;

	GetDlgItemText(IDC_AFXBARRES_H, str);
	if (str.IsEmpty())
	{
		return;
	}

	GetDlgItemText(IDC_AFXBARRES_L, str);
	if (str.IsEmpty())
	{
		return;
	}

	GetDlgItemText(IDC_AFXBARRES_S, str);
	if (str.IsEmpty())
	{
		return;
	}

	if (!UpdateData())
	{
		return;
	}

	m_bInUpdate = TRUE;

	m_h = min(m_h, 255);
	m_s = min(m_s, 255);
	m_l = min(m_l, 255);

	double dblH = Int2HLS(m_h);
	double dblS = Int2HLS(m_s);
	double dblL = Int2HLS(m_l);

	COLORREF color = CDrawingManager::HLStoRGB_ONE(dblH, dblL, dblS);

	m_r = GetRValue(color);
	m_g = GetGValue(color);
	m_b = GetBValue(color);

	UpdateData(FALSE);

	m_pDialog->SetNewColor(color);
	m_pDialog->SetPageOne((BYTE) m_r, (BYTE) m_g, (BYTE) m_b);

	m_wndColorPicker.SetHLS(dblH, dblL, dblS, TRUE);
	m_wndLuminance.SetHLS(dblH, dblL, dblS, TRUE);

	m_bInUpdate = FALSE;
}

void CMFCCustomColorsPropertyPage::Setup(BYTE R, BYTE G, BYTE B)
{
	double hue;
	double luminance;
	double saturation;
	CDrawingManager::RGBtoHSL((COLORREF)RGB(R, G, B), &hue, &saturation, &luminance);

	m_wndColorPicker.SetHLS(hue, luminance, saturation);
	m_wndLuminance.SetHLS(hue, luminance, saturation);

	m_r = R;
	m_g = G;
	m_b = B;

	m_h = HLS2Int(hue);
	m_l = HLS2Int(luminance);
	m_s = HLS2Int(saturation);

	if (GetSafeHwnd() != NULL)
	{
		UpdateData(FALSE);
	}
}

void CMFCCustomColorsPropertyPage::OnLuminance()
{
	m_bInUpdate = TRUE;

	double luminance = m_wndLuminance.GetLuminance();
	m_wndColorPicker.SetLuminance(luminance);

	double H,L,S;
	m_wndColorPicker.GetHLS(&H,&L,&S);
	m_h = HLS2Int(H);
	m_l = HLS2Int(L);
	m_s = HLS2Int(S);

	COLORREF color = CDrawingManager::HLStoRGB_ONE(H, L, S);

	m_pDialog->SetNewColor(color);

	m_r = GetRValue(color);
	m_g = GetGValue(color);
	m_b = GetBValue(color);

	m_pDialog->SetPageOne((BYTE) m_r, (BYTE) m_g, (BYTE) m_b);

	UpdateData(FALSE);
	m_bInUpdate = FALSE;
}

void CMFCCustomColorsPropertyPage::OnColour()
{
	m_bInUpdate = TRUE;
	COLORREF ref = m_wndColorPicker.GetColor();

	m_r = GetRValue(ref);
	m_g = GetGValue(ref);
	m_b = GetBValue(ref);

	double saturation = m_wndColorPicker.GetSaturation();
	double hue = m_wndColorPicker.GetHue();

	m_wndLuminance.SetHue(hue);
	m_wndLuminance.SetSaturation(saturation);
	m_wndLuminance.Invalidate();

	double H,L,S;
	m_wndColorPicker.GetHLS(&H,&L,&S);
	m_h = HLS2Int(H);
	m_l = HLS2Int(L);
	m_s = HLS2Int(S);

	// Set actual color.
	m_pDialog->SetNewColor(CDrawingManager::HLStoRGB_ONE(H, L, S));
	m_pDialog->SetPageOne((BYTE) m_r, (BYTE) m_g, (BYTE) m_b);

	UpdateData(FALSE);
	m_bInUpdate = FALSE;
}

void CMFCCustomColorsPropertyPage::OnDoubleClickedColor()
{
	m_pDialog->EndDialog(IDOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcustomizemenubutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxribbonres.h"
#include "afxcontrolbarutil.h"
#include "afxcustomizemenubutton.h"
#include "afxcustomizebutton.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxkeyboardmanager.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CMFCCustomizeMenuButton, CMFCToolBarMenuButton)

CMap<UINT, UINT, int, int>	 CMFCCustomizeMenuButton::m_mapPresentIDs;
CMFCToolBar* CMFCCustomizeMenuButton::m_pWndToolBar = NULL;

BOOL CMFCCustomizeMenuButton::m_bRecentlyUsedOld = FALSE;

// Construction/Destruction
CMFCCustomizeMenuButton::CMFCCustomizeMenuButton()
{
}

CMFCCustomizeMenuButton::~CMFCCustomizeMenuButton()
{
}

CMFCCustomizeMenuButton::CMFCCustomizeMenuButton(UINT uiID,HMENU hMenu,int iImage,LPCTSTR lpszText,BOOL bUserButton):
	CMFCToolBarMenuButton(uiID, hMenu/* HMENU */, iImage /*iImage*/, lpszText, bUserButton)
{
	m_uiIndex = (UINT)-1;
	bSeparator = FALSE;
	m_bAddSpr = FALSE;
	m_bIsEnabled = TRUE;
	m_bBrothersBtn = FALSE;
}

void CMFCCustomizeMenuButton::SetItemIndex(UINT uiIndex, BOOL bExist, BOOL bAddSpr)
{
	m_uiIndex = uiIndex;
	m_bExist = bExist;
	m_bAddSpr = bAddSpr;

	if ((uiIndex != ID_AFXBARRES_TOOLBAR_RESET_PROMT) && !bSeparator && bExist)
	{
		CMFCToolBarButton* pBtn = m_pWndToolBar->GetButton(uiIndex);
		m_bShow = pBtn->IsVisible();

	}
	else
	{
		m_bShow = FALSE;

		if (m_uiIndex == ID_AFXBARRES_TOOLBAR_RESET_PROMT && m_pWndToolBar->IsUserDefined())
		{
			m_bIsEnabled = FALSE;
		}
	}
}

void CMFCCustomizeMenuButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarButton::CopyFrom(s);
	const CMFCCustomizeMenuButton& src = (const CMFCCustomizeMenuButton&) s;

	m_uiIndex      =   src.m_uiIndex;
	m_bShow        =   src.m_bShow;
	m_pWndToolBar  =   src.m_pWndToolBar;
	bSeparator     =   src.bSeparator;
	m_bExist       =   src.m_bExist;
	m_bAddSpr      =   src.m_bAddSpr;
	m_bIsEnabled   =   src.m_bIsEnabled;
	m_bBrothersBtn =   src.m_bBrothersBtn;
}

SIZE CMFCCustomizeMenuButton::OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz)
{
	if (bSeparator)
	{
		return CSize(0,  4);
	}

	if (m_bBrothersBtn)
	{
		return CMFCToolBarMenuButton::OnCalculateSize(pDC, sizeDefault, bHorz);
	}

	//  Try to Find Buttons Text
	if (m_strText.IsEmpty())
	{
		// Try to find the command name in resources:
		CString strMessage;
		int iOffset;
		if (strMessage.LoadString(m_nID) && (iOffset = strMessage.Find(_T('\n'))) != -1)
		{
			m_strText = strMessage.Mid(iOffset + 1);
		}
	}
	else
	{
		// m_strText.Remove(_T('&'));

		// Remove trailing label(ex.:"\tCtrl+S"):
		int iOffset = m_strText.Find(_T('\t'));
		if (iOffset != -1)
		{
			m_strText = m_strText.Left(iOffset);
		}
	}

	// Change accelerator:
	if (afxKeyboardManager != NULL && m_bMenuMode && (m_nID < 0xF000 || m_nID >= 0xF1F0)) // Not system.
	{
		// Remove standard aceleration label:
		int iTabOffset = m_strText.Find(_T('\t'));
		if (iTabOffset >= 0)
		{
			m_strText = m_strText.Left(iTabOffset);
		}

		// Add an actual accelartion label:
		CString strAccel;
		CFrameWnd* pParent = m_pWndParent == NULL ? DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd()) : AFXGetTopLevelFrame(m_pWndParent);

		if (pParent != NULL &&
			(CKeyboardManager::FindDefaultAccelerator(m_nID, strAccel, pParent, TRUE) || CKeyboardManager::FindDefaultAccelerator(m_nID, strAccel, pParent->GetActiveFrame(), FALSE)))
		{
			m_strText += _T('\t');
			m_strText += strAccel;
		}
	}

	int nTolalWidth = m_strText.GetLength();
	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);
	nTolalWidth *= tm.tmAveCharWidth;
	CSize sizeImage = CMFCToolBar::GetMenuButtonSize();
	nTolalWidth += 2*sizeImage.cx;
	nTolalWidth += 3*CMFCVisualManager::GetInstance()->GetMenuImageMargin() + 50;

	CSize sizeStandard = CMFCToolBarMenuButton::OnCalculateSize(pDC, sizeDefault, bHorz);

	int nTotalHeight = sizeStandard.cy + 2;

	if (!m_bMenuMode)
	{
		nTotalHeight += CMFCVisualManager::GetInstance()->GetMenuImageMargin();
	}

	return CSize(nTolalWidth,  nTotalHeight);
}

BOOL CMFCCustomizeMenuButton::OnClickMenuItem()
{
	if (bSeparator || !m_bIsEnabled)
	{
		return TRUE;
	}

	CMFCPopupMenuBar* pMenuBar = (CMFCPopupMenuBar*)m_pWndParent;
	ENSURE(pMenuBar != NULL);
	ASSERT_VALID(pMenuBar);

	int nIndex = pMenuBar->ButtonToIndex(this);
	if (nIndex !=-1)
	{
		if (pMenuBar->m_iHighlighted != nIndex)
		{
			pMenuBar->m_iHighlighted = nIndex;
			pMenuBar->InvalidateRect(this->Rect());
		}
	}

	if (m_bBrothersBtn)
	{
		if (m_pWndToolBar->IsOneRowWithSibling())
		{
			m_pWndToolBar->SetTwoRowsWithSibling();
		}
		else
		{
			m_pWndToolBar->SetOneRowWithSibling();
		}

		return FALSE;
	}

	if (m_uiIndex == ID_AFXBARRES_TOOLBAR_RESET_PROMT) // reset pressed
	{
		//load default toolbar
		m_pWndToolBar->PostMessage(AFX_WM_RESETRPROMPT);
		return FALSE;
	}

	if (!m_bExist)
	{
		const CObList& lstOrignButtons = m_pWndToolBar->GetOrigResetButtons();

		POSITION pos = lstOrignButtons.FindIndex(m_uiIndex);
		CMFCToolBarButton* pButton = (CMFCToolBarButton*)lstOrignButtons.GetAt(pos);
		if (pButton == NULL)
		{
			return TRUE;
		}

		UINT nNewIndex = m_pWndToolBar->InsertButton(*pButton, m_uiIndex);

		if (nNewIndex == -1)
		{
			nNewIndex = m_pWndToolBar->InsertButton(*pButton);
		}
		else
		{
			int nCount = pMenuBar->GetCount();
			for (int i = 0; i < nCount; i++)
			{
				CMFCCustomizeMenuButton* pBtn = (CMFCCustomizeMenuButton*)pMenuBar->GetButton(i);
				if ((pBtn->m_uiIndex >= nNewIndex) && (pBtn->m_uiIndex != ID_AFXBARRES_TOOLBAR_RESET_PROMT))
				{
					if (pBtn->m_bExist)
					{
						pBtn->m_uiIndex += 1;
					}
				}
			}
		}

		m_uiIndex = nNewIndex;

		if (m_bAddSpr)
		{
			if (nNewIndex <(UINT)m_pWndToolBar->GetCount())
			{
				CMFCToolBarButton* pBtn = m_pWndToolBar->GetButton(nNewIndex+1);
				if (!(pBtn->m_nStyle & TBBS_SEPARATOR))
				{
					m_pWndToolBar->InsertSeparator();
				}
			}
			else
			{
				m_pWndToolBar->InsertSeparator();
			}
		}

		m_pWndToolBar->AdjustLayout();
		m_pWndToolBar->AdjustSizeImmediate();
		UpdateCustomizeButton();

		m_bExist = TRUE;
		m_bShow = TRUE;
		pMenuBar->Invalidate();

		return TRUE;
	}

	CMFCToolBarButton* pBtn = m_pWndToolBar->GetButton(m_uiIndex);
	BOOL bVisible = pBtn->IsVisible();
	pBtn->SetVisible(!bVisible);
	m_bShow = !bVisible;

	//  Make next Separator the same state
	int nNext = m_uiIndex + 1;
	if (nNext < m_pWndToolBar->GetCount())
	{
		CMFCToolBarButton* pBtnNext = m_pWndToolBar->GetButton(nNext);
		if (pBtnNext->m_nStyle & TBBS_SEPARATOR)
		{
			pBtnNext->SetVisible(!bVisible);
		}
	}

	CMFCPopupMenu* pCustomizeMenu = NULL;

	for (CMFCPopupMenu* pMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pMenuBar->GetParent()); pMenu != NULL; pMenu = pMenu->GetParentPopupMenu())
	{
		pCustomizeMenu = pMenu;
	}

	if (pCustomizeMenu != NULL)
	{
		pCustomizeMenu->ShowWindow(SW_HIDE);
	}

	m_pWndToolBar->AdjustLayout();
	m_pWndToolBar->AdjustSizeImmediate();
	UpdateCustomizeButton();
	pMenuBar->Invalidate();

	if (pCustomizeMenu != NULL)
	{
		pCustomizeMenu->ShowWindow(SW_SHOWNOACTIVATE);

		CRect rectScreen;
		pCustomizeMenu->GetWindowRect(&rectScreen);
		CMFCPopupMenu::UpdateAllShadows(rectScreen);
	}

	return TRUE;
}

void CMFCCustomizeMenuButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz, BOOL bCustomizeMode, BOOL bHighlight, BOOL bDrawBorder, BOOL bGrayDisabledButtons)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	// Draw separator:
	if (bSeparator)
	{
		CRect rcSeparator(rect);
		rcSeparator.left = 2*CMFCToolBar::GetMenuImageSize().cx + CMFCVisualManager::GetInstance()->GetMenuImageMargin();

		CMFCPopupMenuBar* pMenuBar = (CMFCPopupMenuBar*)m_pWndParent;
		ENSURE(pMenuBar != NULL);
		ASSERT_VALID(pMenuBar);

		CMFCVisualManager::GetInstance()->OnDrawSeparator(pDC, pMenuBar, rcSeparator, FALSE);
		return;
	}

	if (m_bBrothersBtn)
	{
		CMFCToolBarMenuButton::OnDraw(pDC, rect, NULL, bHorz, bCustomizeMode, bHighlight, bDrawBorder, bGrayDisabledButtons);
		return;
	}

	CRect rectItem = rect;
	rectItem.bottom--;

	if (m_bIsEnabled)
	{
		if (m_bShow && bHighlight)
		{
			SetStyle(TBBS_BUTTON|TBBS_CHECKED);
		}
		else
		{
			SetStyle(TBBS_BUTTON);
		}
	}
	else
	{
		SetStyle(TBBS_DISABLED);
		bGrayDisabledButtons = TRUE;
		bHighlight = FALSE;
	}

	BOOL bIsResetItem = m_uiIndex == ID_AFXBARRES_TOOLBAR_RESET_PROMT;

	if (bIsResetItem)
	{
		m_bImage = FALSE;
		m_iImage = -1;
	}

	// Highlight item:
	if (bHighlight && m_bIsEnabled)
	{
		CRect rcHighlight = rectItem;
		rcHighlight.left += 2;
		rcHighlight.right--;

		if (!CMFCVisualManager::GetInstance()->IsHighlightWholeMenuItem() && !bIsResetItem)
		{
			rcHighlight.left += 2 * CMFCToolBar::GetMenuImageSize().cx + 5 * CMFCVisualManager::GetInstance()->GetMenuImageMargin();
		}

		COLORREF clrText;
		CMFCVisualManager::GetInstance()->OnHighlightMenuItem(pDC, this, rcHighlight, clrText);
	}

	// Draw checkbox:
	CSize sizeMenuImage = CMFCToolBar::GetMenuImageSize();

	CRect rectCheck = rectItem;
	rectCheck.left += CMFCVisualManager::GetInstance()->GetMenuImageMargin() + 1;
	rectCheck.right = rectCheck.left + sizeMenuImage.cx + CMFCVisualManager::GetInstance()->GetMenuImageMargin() + 2;
	rectCheck.bottom--;

	DrawCheckBox(pDC, rectCheck, bHighlight);

	if (bHighlight && !(m_nStyle & TBBS_DISABLED) && !bIsResetItem)
	{
		SetStyle(TBBS_BUTTON);
	}

	// Draw icon + text:
	CRect rectStdMenu = rectItem;
	rectStdMenu.left = rectCheck.right;

	DrawMenuItem(pDC, rectStdMenu, pImages, bCustomizeMode, bHighlight, bGrayDisabledButtons, TRUE);
}

CString CMFCCustomizeMenuButton::SearchCommandText(CMenu* pMenu, UINT in_uiCmd)
{
	ENSURE(pMenu != NULL);

	int iCount = pMenu->GetMenuItemCount();

	for (int i = 0; i < iCount; i ++)
	{
		UINT uiCmd = pMenu->GetMenuItemID(i);
		if (uiCmd == in_uiCmd)
		{
			CString strText;
			pMenu->GetMenuString(i, strText, MF_BYPOSITION);
			return strText;
		}

		switch (uiCmd)
		{
		case 0: // Separator, ignore it.
			break;

		case -1: // Submenu
			{
				CMenu* pSubMenu = pMenu->GetSubMenu(i);

				CString strText = SearchCommandText(pSubMenu, in_uiCmd);
				if (strText != _T("")) return strText;
			}
			break;

		}//end switch
	}//end for

	return _T("");
}

void CMFCCustomizeMenuButton::DrawCheckBox(CDC* pDC, const CRect& rect, BOOL bHighlight)
{
	if (!m_bShow)
	{
		return;
	}

	CRect rectCheck = rect;
	rectCheck.DeflateRect(0, 1, 1, 1);

	if (!CMFCVisualManager::GetInstance()->IsOwnerDrawMenuCheck())
	{
		UINT nStyle = m_nStyle;
		m_nStyle |= TBBS_CHECKED;

		FillInterior(pDC, rectCheck, bHighlight, TRUE);

		if (bHighlight && CMFCVisualManager::GetInstance()->IsFrameMenuCheckedItems())
		{
			m_nStyle |= TBBS_MARKED;
		}

		CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectCheck, CMFCVisualManager::ButtonsIsPressed);

		m_nStyle = nStyle;
	}

	CMFCVisualManager::GetInstance()->OnDrawMenuCheck(pDC, this, rectCheck, bHighlight, FALSE);
}

void CMFCCustomizeMenuButton::UpdateCustomizeButton()
{
	ASSERT_VALID(m_pWndToolBar);

	if (m_pWndToolBar->GetParent()->GetSafeHwnd() != NULL)
	{
		m_pWndToolBar->GetParent()->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_FRAME);
	}

	m_pWndToolBar->RedrawCustomizeButton();
}

BOOL __stdcall CMFCCustomizeMenuButton::IsCommandExist(UINT uiCmdId)
{
	int nTmp = 0;
	return m_mapPresentIDs.Lookup(uiCmdId, nTmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdbcs.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifdef _MBCS    // entire file is only for DBCS enabling



AFX_STATIC BOOL PASCAL _AfxInitDBCS()
{
	CPINFO info;
	GetCPInfo(GetOEMCP(), &info);
	return info.MaxCharSize > 1;
}

const AFX_DATADEF BOOL _afxDBCS = _AfxInitDBCS();

#endif //_MBCS

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdatarecovery.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxdatarecovery.h"

#include <shlobj.h>
#include <knownfolders.h>

#if defined(_UNICODE)
#include "afxtaskdialog.h"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

void CALLBACK AfxAutosaveTimerProc(HWND, UINT, UINT_PTR, DWORD)
{
	CWinApp *pApp = AfxGetApp();
	if (pApp != NULL)
	{
		CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
		if (pHandler != NULL)
		{
			pHandler->SetSaveDocumentInfoOnIdle(TRUE);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CDataRecoveryHandler

CDataRecoveryHandler::CDataRecoveryHandler(_In_ DWORD dwRestartManagerSupportFlags, _In_ int nAutosaveInterval)
{
	// Ensure that the combination of flags makes sense
	ASSERT(dwRestartManagerSupportFlags & (AFX_RESTART_MANAGER_SUPPORT_RESTART | AFX_RESTART_MANAGER_SUPPORT_RECOVERY));
	if (dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES)
	{
		ASSERT(dwRestartManagerSupportFlags & (AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART | AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL));
	}

	m_dwRestartManagerSupportFlags = dwRestartManagerSupportFlags;
	m_nAutosaveInterval = nAutosaveInterval;
	m_bSaveDocumentInfoOnIdle = FALSE;
	m_bShutdownByRestartManager = FALSE;
	m_bRestoringPreviousOpenDocs = FALSE;
	m_nTimerID = 0;
}

CDataRecoveryHandler::~CDataRecoveryHandler()
{
	// Process failed autosave deletes
	while (!m_lstAutosavesToDelete.IsEmpty())
	{
		CString strAutosaveToDelete = m_lstAutosavesToDelete.RemoveHead();
		DeleteFile(strAutosaveToDelete);
	}

	KillTimer(NULL, m_nTimerID);
}

typedef HRESULT (STDAPICALLTYPE *PFNGETKNOWNFOLDERPATH)(REFKNOWNFOLDERID, DWORD, HANDLE, PWSTR *);

BOOL CDataRecoveryHandler::Initialize()
{
	BOOL bRet = TRUE;

	if (m_dwRestartManagerSupportFlags & (AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART | AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL))
	{
		HRESULT hr = S_FALSE;
		PWSTR pszAutosavePath = NULL;

		// Get the path where files will be autosaved on timer tick or restart
		HMODULE hShell = AfxCtxLoadLibraryW(L"SHELL32.DLL");
		if (hShell != NULL)
		{
			PFNGETKNOWNFOLDERPATH pfnSHGetKnownFolderPath = (PFNGETKNOWNFOLDERPATH)GetProcAddress(hShell, "SHGetKnownFolderPath");
			if (pfnSHGetKnownFolderPath != NULL)
			{
				hr = pfnSHGetKnownFolderPath(FOLDERID_LocalAppData, 0, NULL, &pszAutosavePath);
			}
		}

		if ((hr == S_OK) && (pszAutosavePath != NULL))
		{
			SetAutosavePath(pszAutosavePath);
			CoTaskMemFree(pszAutosavePath);
		}
		else
		{
			bRet = FALSE;
		}
	}

	if (bRet && (m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL))
	{
		// Start the timer that will be used to trigger the periodic autosaves
		m_nTimerID = SetTimer(NULL, m_nTimerID, GetAutosaveInterval(), AfxAutosaveTimerProc);
	}

	return bRet;
}

void CDataRecoveryHandler::SetAutosaveInterval(_In_ int nAutosaveInterval)
{
	// reset the auto-save timer interval...
	m_nAutosaveInterval = nAutosaveInterval;
	// ...and then reset the timer with the new auto-save interval.
	m_nTimerID = SetTimer(NULL, m_nTimerID, GetAutosaveInterval(), AfxAutosaveTimerProc);
}

BOOL CDataRecoveryHandler::SaveOpenDocumentList()
{
	BOOL bRet = TRUE;  // return FALSE if document list non-empty and not saved

	POSITION posAutosave = m_mapDocNameToAutosaveName.GetStartPosition();
	if (posAutosave != NULL)
	{
		bRet = FALSE;

		// Save the open document list and associated autosave info to the registry
		CRegKey keyRestart;
		if (keyRestart.Create(AfxGetApp()->GetAppRegistryKey(), GetRestartIdentifier()) == ERROR_SUCCESS)
		{
			while (posAutosave != NULL)
			{
				CString strDocument, strAutosave;
				m_mapDocNameToAutosaveName.GetNextAssoc(posAutosave, strDocument, strAutosave);

				keyRestart.SetStringValue(strDocument, strAutosave, REG_SZ);
			}

			return TRUE;
		}
	}

	return bRet;
}

BOOL CDataRecoveryHandler::ReadOpenDocumentList()
{
	BOOL bRet = FALSE;  // return TRUE only if at least one document was found

	// Read the open document list and associated autosave info from the registry
	CRegKey keyApp(AfxGetApp()->GetAppRegistryKey()), keyRestart;
	if (keyRestart.Open(keyApp, GetRestartIdentifier()) == ERROR_SUCCESS)
	{
		DWORD dwValueIndex = 0;
		TCHAR szValueName[MAX_PATH] = _T("");
		DWORD cchValueName = _countof(szValueName);
		while (::RegEnumValue(keyRestart, dwValueIndex, szValueName, &cchValueName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
		{
			dwValueIndex++;
			cchValueName = _countof(szValueName);


			TCHAR szValue[MAX_PATH] = _T("");
			DWORD cchValue = _countof(szValue);
			if (keyRestart.QueryStringValue(szValueName, szValue, &cchValue) == ERROR_SUCCESS)
			{
				m_mapDocNameToAutosaveName[szValueName] = szValue;
				bRet = TRUE;
			}
		}

		// Once the information is read, delete the key from the registry
		keyRestart.Close();
		keyApp.DeleteSubKey(GetRestartIdentifier());
	}

	return bRet;
}

BOOL CDataRecoveryHandler::AutosaveDocumentInfo(_In_ CDocument *pDocument, _In_ BOOL bResetModifiedFlag)
{
	if (m_dwRestartManagerSupportFlags & (AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART | AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL))
	{
		if (pDocument != NULL)
		{
			ASSERT_VALID(pDocument);
			ASSERT_KINDOF(CDocument, pDocument);

			CString strDocumentPathName;
			m_mapDocumentPtrToDocName.Lookup(pDocument, strDocumentPathName);

			if (strDocumentPathName.IsEmpty())
			{
				strDocumentPathName = GetDocumentListName(pDocument);
				m_mapDocumentPtrToDocName[pDocument] = strDocumentPathName;
			}

			if (!strDocumentPathName.IsEmpty())
			{
				CString strAutosavePathNameCurrent, strAutosavePathNameNew;
				if (pDocument->IsModified())
				{
					// Make sure that the document has an entry in the open document list
					if (!m_mapDocNameToAutosaveName.Lookup(strDocumentPathName, strAutosavePathNameCurrent))
					{
						m_mapDocNameToAutosaveName[strDocumentPathName] = _T("");
					}

					if (m_dwRestartManagerSupportFlags & (AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART | AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL))
					{
						// Generate the new autosave filename
						strAutosavePathNameNew = GenerateAutosaveFileName(strDocumentPathName);

						// Save the document to the autosave location (but don't update document path)
						if (pDocument->DoSave(strAutosavePathNameNew, FALSE))
						{
							// If successful, update the document's entry in the open document list...
							m_mapDocNameToAutosaveName[strDocumentPathName] = strAutosavePathNameNew;

							//...and delete the previous autosave file (if there was one)
							if (strAutosavePathNameCurrent.CompareNoCase(strAutosavePathNameNew) != 0)
							{
								DeleteAutosavedFile(strAutosavePathNameCurrent);
							}

							if (bResetModifiedFlag)
							{
								// Make sure that the document is still in modified state,
								// so any attempt to close it will prompt for save.
								pDocument->SetModifiedFlag(TRUE);
							}
							else
							{
								// Make sure that the document is in un-modified state,
								// so pending SaveAllModified will not prompt for save.
								pDocument->SetModifiedFlag(FALSE);
							}
						}
					}
				}
				else
				{
					BOOL bRet = m_mapDocNameToAutosaveName.Lookup(strDocumentPathName, strAutosavePathNameCurrent);

					// Make sure that the document is in the open document list with no autosave associated
					m_mapDocNameToAutosaveName[strDocumentPathName] = _T("");

					if (bRet)
					{
						// Delete the previous autosave file (if there was one)
						DeleteAutosavedFile(strAutosavePathNameCurrent);
					}
				}
			}

			return TRUE;
		}
	}

	return FALSE;
}

BOOL CDataRecoveryHandler::AutosaveAllDocumentInfo()
{
	BOOL bRet = TRUE;

	if (m_dwRestartManagerSupportFlags & (AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART | AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL))
	{
		CWinApp *pApp = AfxGetApp();
		if (pApp != NULL)
		{
			CDocManager *pDocManager = pApp->m_pDocManager;
			if (pDocManager != NULL)
			{
				// Loop through all the document templates
				POSITION posTemplate = pDocManager->GetFirstDocTemplatePosition();
				while (posTemplate != NULL)
				{
					CDocTemplate* pTemplate = pDocManager->GetNextDocTemplate(posTemplate);
					ASSERT_KINDOF(CDocTemplate, pTemplate);

					// Loop through all the documents in the template
					POSITION posDocument = pTemplate->GetFirstDocPosition();
					while (posDocument != NULL)
					{
						CDocument* pDocument = pTemplate->GetNextDoc(posDocument);
						ASSERT_VALID(pDocument);
						ASSERT_KINDOF(CDocument, pDocument);

						// Autosave the document information for the document
						bRet &= AutosaveDocumentInfo(pDocument, FALSE);
					}
				}
			}
		}
	}

	// If any autosave failed, return failure
	return bRet;
}

BOOL CDataRecoveryHandler::CreateDocumentInfo(_In_ CDocument *pDocument)
{
	BOOL bRet = TRUE;

	if ((m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES) && !m_bRestoringPreviousOpenDocs)
	{
		// A document has been opened.  Add it to the open document list,
		// but first check to see if the document is already in the lists
		// (which will be the case if SDI) and remove those references.
		CString strDocumentListName;

		if (m_mapDocumentPtrToDocName.Lookup(pDocument, strDocumentListName))
		{
			m_mapDocumentPtrToDocName.RemoveKey(pDocument);
			m_mapDocumentPtrToDocTitle.RemoveKey(pDocument);
			m_mapDocNameToDocumentPtr.RemoveKey(strDocumentListName);
			CString strAutosavePathName;
			m_mapDocNameToAutosaveName.Lookup(strDocumentListName, strAutosavePathName);
			DeleteAutosavedFile(strAutosavePathName);
			m_mapDocNameToAutosaveName.RemoveKey(strDocumentListName);
		}

		strDocumentListName = GetDocumentListName(pDocument);
		m_mapDocumentPtrToDocName[pDocument] = strDocumentListName;
		m_mapDocNameToAutosaveName[strDocumentListName] = _T("");
	}

	return bRet;
}

BOOL CDataRecoveryHandler::UpdateDocumentInfo(_In_ CDocument *pDocument)
{
	BOOL bRet = TRUE;

	if (m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES)
	{
		// A document has been saved, perhaps with a new filename.  Delete the old
		// filename from the open document list and delete any existing auto-save
		// file from disk.  Add the new filename to the open document list.
		RemoveDocumentInfo(pDocument);
		CString strNewDocumentName = GetDocumentListName(pDocument);
		m_mapDocumentPtrToDocName[pDocument] = strNewDocumentName;
		m_mapDocNameToAutosaveName[strNewDocumentName] = _T("");
	}

	return bRet;
}

BOOL CDataRecoveryHandler::RemoveDocumentInfo(_In_ CDocument *pDocument)
{
	BOOL bRet = TRUE;

	if (m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES)
	{
		// A document has been closed.  Delete the filename from the open
		// document list and delete any existing auto-save file from disk.
		CString strDocumentName;
		if (m_mapDocumentPtrToDocName.Lookup(pDocument, strDocumentName))
		{
			CString strAutosavePathName;

			m_mapDocNameToAutosaveName.Lookup(strDocumentName, strAutosavePathName);
			DeleteAutosavedFile(strAutosavePathName);
			m_mapDocNameToAutosaveName.RemoveKey(strDocumentName);
			m_mapDocNameToDocumentPtr.RemoveKey(strDocumentName);
		}

		m_mapDocumentPtrToDocName.RemoveKey(pDocument);
		m_mapDocumentPtrToDocTitle.RemoveKey(pDocument);
	}

	return bRet;
}

BOOL CDataRecoveryHandler::DeleteAutosavedFile(_In_ const CString &strAutosavedFile)
{
	if (!strAutosavedFile.IsEmpty())
	{
		if (DeleteFile(strAutosavedFile) == 0)
		{
			// Remember failed deletes in a list to be processed at destruction
			m_lstAutosavesToDelete.AddTail(strAutosavedFile);
		}
	}

	return TRUE;
}

BOOL CDataRecoveryHandler::DeleteAllAutosavedFiles()
{
	POSITION posAutosave = m_mapDocNameToAutosaveName.GetStartPosition();
	while (posAutosave != NULL)
	{
		CString strDocument, strAutosave;
		m_mapDocNameToAutosaveName.GetNextAssoc(posAutosave, strDocument, strAutosave);

		if (!strAutosave.IsEmpty())
		{
			// Make sure that the document has an entry in the open document list
			m_mapDocNameToAutosaveName[strDocument] = _T("");

			// Delete the autosave file
			DeleteAutosavedFile(strAutosave);
		}
	}

	return TRUE;
}

BOOL CDataRecoveryHandler::ReopenPreviousDocuments()
{
	BOOL bRet = FALSE;
	m_mapDocNameToDocumentPtr.RemoveAll();
	m_bRestoringPreviousOpenDocs = TRUE;

	if (m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES)
	{
		POSITION posAutosave = m_mapDocNameToAutosaveName.GetStartPosition();
		while (posAutosave != NULL)
		{
			CDocument *pDocument = NULL;
			CString strDocument, strAutosave;
			m_mapDocNameToAutosaveName.GetNextAssoc(posAutosave, strDocument, strAutosave);

			int iPathDelimiter = strDocument.FindOneOf(_T(":/\\"));
			if (iPathDelimiter != -1)
			{
				// Open an existing previously saved document from disk.
				pDocument = AfxGetApp()->OpenDocumentFile(strDocument, TRUE);
			}
			else
			{
				// Create a new document and give it the previously opened document's name,
				// using the template based on the extension in the document's name.
				CWinApp *pApp = AfxGetApp();
				CDocTemplate* pBestTemplate = NULL;

				if ((pApp != NULL) && (pApp->m_pDocManager != NULL))
				{
					pBestTemplate = pApp->m_pDocManager->GetBestTemplate(strDocument);
				}

				if (pBestTemplate != NULL)
				{
					pDocument = pBestTemplate->OpenDocumentFile(NULL, FALSE, TRUE);
				}

				if (pDocument != NULL)
				{
					CString strDocumentTitle = strDocument;
					int nStartExtension = strDocument.ReverseFind(_T('.'));
					if (nStartExtension > 0)
					{
						strDocumentTitle = strDocument.Left(nStartExtension);
					}
					pDocument->SetTitle(strDocumentTitle);
				}
			}

			m_mapDocNameToDocumentPtr[strDocument] = pDocument;
			bRet |= (pDocument != NULL);
		}
	}

	m_bRestoringPreviousOpenDocs = FALSE;
	// If any document was created, return TRUE.
	return bRet;
}

void CDataRecoveryHandler::QueryRestoreAutosavedDocuments()
{
	// This method is separate so an alternate UI can be provided for asking the user about
	// restoring autosaved files.  After presenting the UI, fill m_mapDocNameToRestoreBool with
	// pairs of filenames and true/false values to indicate whether a file should be restored.
	int nRet = IDNO;
#if defined(_UNICODE)
	if (CTaskDialog::IsSupported())
	{
		BOOL bRet;
		CString strTitle;
		bRet = strTitle.LoadString(AFX_IDS_AUTOSAVE_RECOVERY_ASK_1);
		ASSERT(bRet);
		CString strMainInstruction;
		bRet = strMainInstruction.LoadString(AFX_IDS_AUTOSAVE_RECOVERY_ASK_2);
		ASSERT(bRet);
		strTitle += _T("\r\n");
		strTitle += strMainInstruction;
		CString strContent;
		bRet = strContent.LoadString(AFX_IDS_AUTOSAVE_RECOVERY_ASK_3);
		ASSERT(bRet);
		CString strFooter;
		bRet = strFooter.LoadString(AFX_IDS_AUTOSAVE_RECOVERY_ASK_4);
		ASSERT(bRet);

		INT_PTR nReturn = CTaskDialog::ShowDialog(strContent, strTitle, AfxGetApp()->m_pszAppName,
			AFX_IDS_AUTOSAVE_RECOVERY_ASK_5, AFX_IDS_AUTOSAVE_RECOVERY_ASK_6, 0, TDF_USE_COMMAND_LINKS, strFooter);
		nRet = (nReturn == AFX_IDS_AUTOSAVE_RECOVERY_ASK_5 ? IDYES : IDNO);
	}
	else
#endif
	{
		BOOL bRet;
		CString strAutosaveRecoverQuery, strTemp;
		bRet = strAutosaveRecoverQuery.LoadString(AFX_IDS_AUTOSAVE_RECOVERY_ASK_1);
		ASSERT(bRet);
		strAutosaveRecoverQuery += _T("\r\n");
		bRet = strTemp.LoadString(AFX_IDS_AUTOSAVE_RECOVERY_ASK_2);
		ASSERT(bRet);
		strAutosaveRecoverQuery += strTemp;
		strAutosaveRecoverQuery += _T("\r\n\r\n");
		bRet = strTemp.LoadString(AFX_IDS_AUTOSAVE_RECOVERY_ASK_3);
		ASSERT(bRet);
		strAutosaveRecoverQuery += strTemp;
		strAutosaveRecoverQuery += _T("\r\n\r\n");
		bRet = strTemp.LoadString(AFX_IDS_AUTOSAVE_RECOVERY_ASK_4);
		ASSERT(bRet);
		strAutosaveRecoverQuery += strTemp;

		nRet = AfxMessageBox(strAutosaveRecoverQuery, MB_YESNO);
	}

	POSITION posAutosave = m_mapDocNameToAutosaveName.GetStartPosition();
	while (posAutosave != NULL)
	{
		CString strDocument, strAutosave;
		m_mapDocNameToAutosaveName.GetNextAssoc(posAutosave, strDocument, strAutosave);

		if (!strAutosave.IsEmpty())
		{
			m_mapDocNameToRestoreBool[strDocument] = (nRet == IDYES ? true :false);
		}
	}
}

BOOL CDataRecoveryHandler::RestoreAutosavedDocuments()
{
	m_mapDocNameToRestoreBool.RemoveAll();
	m_bRestoringPreviousOpenDocs = TRUE;

	if ((m_dwRestartManagerSupportFlags & (AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES | AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES)) == (AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES | AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES))
	{
		CFileStatus fs;
		POSITION posAutosave;
		BOOL bHaveDocumentsToRestore = FALSE;

		// First determine whether there are any autosaved files to restore
		posAutosave = m_mapDocNameToAutosaveName.GetStartPosition();
		while (posAutosave != NULL)
		{
			CString strDocument, strAutosave;
			m_mapDocNameToAutosaveName.GetNextAssoc(posAutosave, strDocument, strAutosave);
			if ((!strAutosave.IsEmpty()) && (CFile::GetStatus(strAutosave, fs)))
			{
				bHaveDocumentsToRestore = TRUE;
				break;
			}
		}

		if (bHaveDocumentsToRestore)
		{
			// Call QueryRestoreAutosavedDocuments to fill up the m_mapDocNameToRestoreBool map
			// with true/false about whether to restore the autosave for each document that has one.
			QueryRestoreAutosavedDocuments();

			posAutosave = m_mapDocNameToAutosaveName.GetStartPosition();
			while (posAutosave != NULL)
			{
				CString strDocument, strAutosave;
				m_mapDocNameToAutosaveName.GetNextAssoc(posAutosave, strDocument, strAutosave);

				if ((!strAutosave.IsEmpty()) && (CFile::GetStatus(strAutosave, fs)))
				{
					bool bRestore;
					m_mapDocNameToRestoreBool.Lookup(strDocument, bRestore);
					if (bRestore)
					{
						// Turn redraw of the main frame off so the opening/closing is not visible
						AfxGetApp()->GetMainWnd()->SetRedraw(FALSE);

						// Open the autosave file
						CDocument *pDocument = AfxGetApp()->OpenDocumentFile(strAutosave, FALSE);
						if (pDocument != NULL)
						{
							CString strTitle;
							int iPathDelimiter = strDocument.FindOneOf(_T(":/\\"));
							if (iPathDelimiter != -1)
							{
								// Set the path name to the original document path
								pDocument->SetPathName(strDocument, FALSE);
								strTitle = pDocument->GetTitle();
							}
							else
							{
								// Set the path name to empty so save will prompt
								pDocument->ClearPathName();

								strTitle = strDocument;
								int nStartExtension = strDocument.ReverseFind(_T('.'));
								if (nStartExtension > 0)
								{
									strTitle = strDocument.Left(nStartExtension);
								}
								pDocument->SetTitle(strTitle);
							}

							CString strDocumentListName = GetDocumentListName(pDocument);
							m_mapDocumentPtrToDocName[pDocument] = strDocumentListName;

							// Close the original file now that the autosave file is opened, but
							// only if the original document is different than current (not SDI).
							CDocument *pOriginalDocument = NULL;
							m_mapDocNameToDocumentPtr.Lookup(strDocument, pOriginalDocument);
							if ((pOriginalDocument != NULL) && (pOriginalDocument != pDocument))
							{
								pOriginalDocument->OnCloseDocument();
							}

							// Set the document to be modified so it will prompt for save
							pDocument->SetModifiedFlag(TRUE);

							// Turn redraw of the main frame back on
							AfxGetApp()->GetMainWnd()->SetRedraw(TRUE);
							AfxGetApp()->GetMainWnd()->Invalidate(TRUE);
							AfxGetApp()->GetMainWnd()->UpdateWindow();

							// Append the "[recovered]" string to the title.  Do this after turning redraw back on so
							// there is an indication of state change in the application, and so repainting is forced.
							m_mapDocumentPtrToDocTitle[pDocument] = strTitle;
							CString strRecoveredTitle = GetRecoveredDocumentTitle(strTitle);
							pDocument->SetTitle(strRecoveredTitle);
						}
						else
						{
							// Turn redraw of the main frame back on
							AfxGetApp()->GetMainWnd()->SetRedraw(TRUE);
							AfxGetApp()->GetMainWnd()->Invalidate(TRUE);
							AfxGetApp()->GetMainWnd()->UpdateWindow();
						}
					}
					else
					{
						// Remove the autosave association
						m_mapDocNameToAutosaveName[strDocument] = _T("");

						// Delete the autosave file
						DeleteAutosavedFile(strAutosave);
					}
				}
			}
		}
	}

	m_mapDocNameToRestoreBool.RemoveAll();
	m_mapDocNameToDocumentPtr.RemoveAll();
	m_bRestoringPreviousOpenDocs = FALSE;
	return TRUE;
}

CString CDataRecoveryHandler::GetDocumentListName(_In_ CDocument *pDocument) const
{
	CString strDocumentPathName = pDocument->GetPathName();
	if (strDocumentPathName.IsEmpty())
	{
		strDocumentPathName = pDocument->GetTitle();

		// append the default suffix if there is one
		CString strExt;
		CDocTemplate* pTemplate = pDocument->GetDocTemplate();
		ASSERT(pTemplate != NULL);
		if (pTemplate && pTemplate->GetDocString(strExt, CDocTemplate::filterExt) && !strExt.IsEmpty())
		{
			ASSERT(strExt[0] == '.');
			int iStart = 0;
			strDocumentPathName += strExt.Tokenize(_T(";"), iStart);
		}
	}

	return strDocumentPathName;
}

CString CDataRecoveryHandler::GenerateAutosaveFileName(_In_ const CString &strDocumentName) const
{
	int nPathLength = strDocumentName.GetLength();
	int nLastBackslash = strDocumentName.ReverseFind(_T('\\'));
	CString strDocumentFileName = strDocumentName.Right(nPathLength - nLastBackslash - 1);

	GUID guidAutosave = GUID_NULL;
	CoCreateGuid(&guidAutosave);

	CString strAutosave;
	strAutosave.Format(_T("%08lX%04X%04x%02X%02X%02X%02X%02X%02X%02X%02X"),
		guidAutosave.Data1, guidAutosave.Data2, guidAutosave.Data3,
		guidAutosave.Data4[0], guidAutosave.Data4[1], guidAutosave.Data4[2], guidAutosave.Data4[3],
		guidAutosave.Data4[4], guidAutosave.Data4[5], guidAutosave.Data4[6], guidAutosave.Data4[7]);

	CString strAutosavePathName;
	strAutosavePathName = GetAutosavePath();
	strAutosavePathName += _T("\\");
	strAutosavePathName += strAutosave;
	strAutosavePathName += _T(".");
	strAutosavePathName += strDocumentFileName;

	return strAutosavePathName;
}

CString CDataRecoveryHandler::GetRecoveredDocumentTitle(_In_ const CString &strDocumentTitle) const
{
	CString strFormat, strRecoveredTitle;
	BOOL bRet = strFormat.LoadString(AFX_IDS_AUTOSAVE_RECOVERED);
	ASSERT(bRet);
	strRecoveredTitle.Format(strFormat, strDocumentTitle);
	return strRecoveredTitle;
}

CString CDataRecoveryHandler::GetNormalDocumentTitle(CDocument *pDocument) const
{
	CString strNormalTitle;
	m_mapDocumentPtrToDocTitle.Lookup(pDocument, strNormalTitle);
	return strNormalTitle;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxcustomizebutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcustomizebutton.h"
#include "afxglobals.h"
#include "afxtoolbar.h"
#include "afxmenuimages.h"
#include "afxtoolbarcomboboxbutton.h"
#include "afxribbonres.h"
#include "afxvisualmanager.h"
#include "afxdockingpanesrow.h"
#include "afxcustomizemenubutton.h"

BOOL CMFCCustomizeButton::m_bIgnoreLargeIconsMode = FALSE;

IMPLEMENT_SERIAL(CMFCCustomizeButton, CMFCToolBarMenuButton, VERSIONABLE_SCHEMA | 1)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCCustomizeButton::CMFCCustomizeButton()
{
	CommonInit();
}

CMFCCustomizeButton::CMFCCustomizeButton(int iCustomizeCmdId, const CString& strCustomizeText)
{
	CommonInit();

	m_iCustomizeCmdId = iCustomizeCmdId;
	m_strCustomizeText = strCustomizeText;
}

void CMFCCustomizeButton::CommonInit()
{
	m_iCustomizeCmdId = 0;
	m_bIsEmpty = FALSE;
	m_bDefaultDraw = TRUE;
	m_sizeExtra = CSize(0, 0);
	m_pWndParentToolbar = NULL;
	m_bIsPipeStyle = TRUE;
	m_bOnRebar = FALSE;
	m_bMenuRightAlign = TRUE;
}

CMFCCustomizeButton::~CMFCCustomizeButton()
{
}

void CMFCCustomizeButton::OnChangeParentWnd(CWnd* pWndParent)
{
	CMFCToolBarButton::OnChangeParentWnd(pWndParent);

	m_pWndParentToolbar = DYNAMIC_DOWNCAST(CMFCToolBar, pWndParent);
	m_pWndParent = pWndParent;
	m_bText = FALSE;
	m_bIsEmpty = FALSE;
	m_bOnRebar = DYNAMIC_DOWNCAST(CReBar, pWndParent->GetParent()) != NULL;
}

void CMFCCustomizeButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* /*pImages*/, BOOL bHorz,
	BOOL bCustomizeMode, BOOL bHighlight, BOOL /*bDrawBorder*/, BOOL /*bGrayDisabledButtons*/)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	if (m_bMenuMode)
	{
		ASSERT(FALSE); // Customize button is available for
		// the "pure" toolbars only!
		return;
	}

	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	CRect rectBorder = rect;

	//----------------------
	// Fill button interior:
	//----------------------
	m_bDefaultDraw = TRUE;

	FillInterior(pDC, rectBorder, bHighlight || IsDroppedDown());

	int nMargin = CMFCVisualManager::GetInstance()->GetToolBarCustomizeButtonMargin();

	if (m_bDefaultDraw)
	{
		CSize sizeImage = CMenuImages::Size();
		if (CMFCToolBar::IsLargeIcons() && !m_bIgnoreLargeIconsMode)
		{
			sizeImage.cx *= 2;
			sizeImage.cy *= 2;
		}

		if (m_iCustomizeCmdId > 0)
		{
			//-----------------
			// Draw menu image:
			//-----------------
			CRect rectMenu = rect;
			if (bHorz)
			{
				rectMenu.top = rectMenu.bottom - sizeImage.cy - 2 * nMargin;
			}
			else
			{
				rectMenu.right = rectMenu.left + sizeImage.cx + 2 * nMargin;
			}

			if ((m_nStyle &(TBBS_PRESSED | TBBS_CHECKED)) || m_pPopupMenu != NULL)
			{
				if (!CMFCVisualManager::GetInstance()->IsMenuFlatLook())
				{
					rectMenu.OffsetRect(1, 1);
				}
			}

			CMenuImages::Draw(pDC, bHorz ? CMenuImages::IdArrowDown : CMenuImages::IdArrowLeft, rectMenu, CMenuImages::ImageBlack, sizeImage);
		}

		if (!m_lstInvisibleButtons.IsEmpty())
		{
			//-------------------
			// Draw "more" image:
			//-------------------
			CRect rectMore = rect;
			if (bHorz)
			{
				rectMore.bottom = rectMore.top + sizeImage.cy + 2 * nMargin;
			}
			else
			{
				rectMore.left = rectMore.right - sizeImage.cx - 2 * nMargin;
			}

			if ((m_nStyle &(TBBS_PRESSED | TBBS_CHECKED)) || m_pPopupMenu != NULL)
			{
				if (!CMFCVisualManager::GetInstance()->IsMenuFlatLook())
				{
					rectMore.OffsetRect(1, 1);
				}
			}

			CMenuImages::Draw(pDC, bHorz ? CMenuImages::IdMoreButtons : CMenuImages::IdArrowShowAll, rectMore, CMenuImages::ImageBlack, sizeImage);
		}
	}

	//--------------------
	// Draw button border:
	//--------------------
	if (!bCustomizeMode)
	{
		if ((m_nStyle &(TBBS_PRESSED | TBBS_CHECKED)) || m_pPopupMenu != NULL)
		{
			//-----------------------
			// Pressed in or checked:
			//-----------------------
			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectBorder, CMFCVisualManager::ButtonsIsPressed);
		}
		else if (bHighlight && !(m_nStyle & TBBS_DISABLED) && !(m_nStyle &(TBBS_CHECKED | TBBS_INDETERMINATE)))
		{
			CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rectBorder, CMFCVisualManager::ButtonsIsHighlighted);
		}
	}
}

CMFCPopupMenu* CMFCCustomizeButton::CreatePopupMenu()
{
	if (CMFCToolBar::m_bAltCustomizeMode || CMFCToolBar::IsCustomizeMode())
	{
		return NULL;
	}

	CMFCPopupMenu* pMenu = CMFCToolBarMenuButton::CreatePopupMenu();
	if (pMenu == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	if (m_pWndParentToolbar->IsLocked())
	{
		pMenu->GetMenuBar()->m_pRelatedToolbar = m_pWndParentToolbar;
	}

	pMenu->m_bRightAlign = m_bMenuRightAlign && (m_pWndParentToolbar->GetExStyle() & WS_EX_LAYOUTRTL) == 0;

	BOOL bIsLocked = (m_pWndParentToolbar == NULL || m_pWndParentToolbar->IsLocked());
	BOOL bIsFirst = TRUE;

	for (POSITION pos = m_lstInvisibleButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_lstInvisibleButtons.GetNext(pos);
		ASSERT_VALID(pButton);

		//--------------------------------------
		// Don't insert first or last separator:
		//--------------------------------------
		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			if (bIsFirst)
			{
				continue;
			}

			if (pos == NULL) // Last
			{
				break;
			}
		}

		int iIndex = -1;

		bIsFirst = FALSE;

		if (pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarMenuButton)))
		{
			iIndex = pMenu->InsertItem(*((CMFCToolBarMenuButton*) pButton));
		}
		else
		{
			if (pButton->m_nID == 0)
			{
				iIndex = pMenu->InsertSeparator();
			}
			else
			{
				iIndex = pMenu->InsertItem(CMFCToolBarMenuButton(pButton->m_nID, NULL,
					bIsLocked ? - 1 : pButton->GetImage(), pButton->m_strText, pButton->m_bUserButton));
			}
		}

		if (iIndex < 0)
		{
			ASSERT(FALSE);
			continue;
		}

		CMFCToolBarMenuButton* pMenuButton = pMenu->GetMenuItem(iIndex);
		if (pMenuButton == NULL)
		{
			continue;
		}

		//-----------------------------------------------------
		// Text may be undefined, bring it from the tooltip :-(
		//-----------------------------------------------------
		if ((pMenuButton->m_strText.IsEmpty() || pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarComboBoxButton))) && pMenuButton->m_nID != 0)
		{
			CString strMessage;
			int iOffset;
			if (strMessage.LoadString(pMenuButton->m_nID) && (iOffset = strMessage.Find(_T('\n'))) != -1)
			{
				pMenuButton->m_strText = strMessage.Mid(iOffset + 1);
				if ((iOffset = pMenuButton->m_strText.Find(_T('\n'))) != -1)
				{
					pMenuButton->m_strText = pMenuButton->m_strText.Left( iOffset );
				}
			}
		}

		pMenuButton->m_bText = TRUE;
	}

	if (m_iCustomizeCmdId > 0)
	{
		if (!m_lstInvisibleButtons.IsEmpty())
		{
			pMenu->InsertSeparator();
		}

		if (m_pWndParentToolbar->IsAddRemoveQuickCustomize())
		{
			//--------------------------------
			// Prepare Quick Customize Items
			//--------------------------------

			CMFCPopupMenu* pMenuCustomize = new CMFCPopupMenu;

			CDockingPanesRow* pDockRow = m_pWndParentToolbar->GetPaneRow();
			if (pDockRow != NULL)
			{
				const CObList& list = pDockRow->GetPaneList();

				for (POSITION pos = list.GetHeadPosition(); pos != NULL;)
				{
					CMFCToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCToolBar, list.GetNext(pos));

					if (pToolBar != NULL && pToolBar->IsVisible() && pToolBar->IsExistCustomizeButton())
					{
						CString strCaption;
						pToolBar->GetWindowText(strCaption);

						strCaption.TrimLeft();
						strCaption.TrimRight();

						if (!strCaption.GetLength())
						{
							ENSURE(strCaption.LoadString(IDS_AFXBARRES_UNTITLED_TOOLBAR));
						}

						CString strToolId;
						strToolId.Format(_T("%d"), pToolBar->GetDlgCtrlID());

						//------------------------
						// Insert Dummy Menu Item
						//------------------------
						CMFCPopupMenu menuDummy;
						menuDummy.InsertItem(CMFCToolBarMenuButton(1, NULL, -1, strToolId));

						CMFCToolBarMenuButton btnToolCaption((UINT)-1, menuDummy.GetMenuBar()->ExportToMenu(), -1, strCaption);
						pMenuCustomize->InsertItem(btnToolCaption);
					}
				}
			}
			else
			{
				CString strCaption;
				m_pWndParentToolbar->GetWindowText(strCaption);

				strCaption.TrimLeft();
				strCaption.TrimRight();

				if (!strCaption.GetLength())
				{
					ENSURE(strCaption.LoadString(IDS_AFXBARRES_UNTITLED_TOOLBAR));
				}

				CString strToolId;
				strToolId.Format(_T("%d"), m_pWndParentToolbar->GetDlgCtrlID());

				//------------------------
				// Insert Dummy Menu Item
				//------------------------
				CMFCPopupMenu menuDummy;
				menuDummy.InsertItem(CMFCToolBarMenuButton(1, NULL, -1, strToolId)); //_T("DUMMY")

				CMFCToolBarMenuButton btnToolCaption((UINT)-1, menuDummy.GetMenuBar()->ExportToMenu(), -1, strCaption);

				pMenuCustomize->InsertItem(btnToolCaption);
			}

			CMFCToolBarMenuButton btnStandard(m_iCustomizeCmdId, NULL, -1, m_strCustomizeText);

			pMenuCustomize->InsertItem(btnStandard);

			CString strLabel;
			ENSURE(strLabel.LoadString(IDS_AFXBARRES_ADD_REMOVE_BTNS));

			CMFCToolBarMenuButton btnAddRemove((UINT)-1, pMenuCustomize->GetMenuBar()->ExportToMenu(), -1, strLabel);

			btnAddRemove.EnableQuickCustomize();

			delete pMenuCustomize;
			pMenuCustomize = NULL;

			//-----------------
			//Brothers Support
			//-----------------
			if (m_pWndParentToolbar != NULL && m_pWndParentToolbar->IsSibling())
			{
				if (m_pWndParentToolbar->CanHandleSiblings())
				{
					CString strText;

					if (m_pWndParentToolbar->IsOneRowWithSibling())
					{
						ENSURE(strText.LoadString(IDS_AFXBARRES_SHOWTWOROWS));
					}
					else
					{
						ENSURE(strText.LoadString(IDS_AFXBARRES_SHOWONEROW));
					}

					CMFCCustomizeMenuButton btnBrother(AFX_CUSTOMIZE_INTERNAL_ID, NULL, -1, strText, FALSE);
					CMFCCustomizeMenuButton::SetParentToolbar(m_pWndParentToolbar);
					btnBrother.SetSiblingsButton();
					pMenu->InsertItem(btnBrother);
				}
			}

			pMenu->InsertItem(btnAddRemove);
			pMenu->SetQuickMode();
			pMenu->SetQuickCustomizeType(CMFCPopupMenu::QUICK_CUSTOMIZE_ADDREMOVE);
		}
		else // for old version(< 6.5) compatibility.
		{
			CMFCToolBarMenuButton btnStandard(m_iCustomizeCmdId, NULL, -1, m_strCustomizeText);

			pMenu->InsertItem(btnStandard);
		}
	}

	//-----------------------------------------------------------
	// All menu commands should be routed via the same window as
	// parent toolbar commands:
	//-----------------------------------------------------------
	if (m_pWndParentToolbar != NULL)
	{
		pMenu->m_pMessageWnd = m_pWndParentToolbar->GetOwner();
	}

	return pMenu;
}

SIZE CMFCCustomizeButton::OnCalculateSize(CDC* /*pDC*/, const CSize& sizeDefault, BOOL bHorz)
{
	if (m_bIsEmpty)
	{
		return CSize(0, 0);
	}

	if (m_strText.IsEmpty())
	{
		ENSURE(m_strText.LoadString(IDS_AFXBARRES_TOOLBAR_OPTIONS));
		ENSURE(!m_strText.IsEmpty());
	}

	if (m_pWndParentToolbar != NULL && !m_pWndParentToolbar->IsDocked())
	{
		return CSize(0, 0);
	}

	int nMargin = CMFCVisualManager::GetInstance()->GetToolBarCustomizeButtonMargin();
	const int xLargeIcons = CMFCToolBar::IsLargeIcons() && !m_bIgnoreLargeIconsMode ? 2 : 1;

	if (bHorz)
	{
		return CSize( CMenuImages::Size().cx * xLargeIcons + 2 * nMargin, sizeDefault.cy);
	}
	else
	{
		return CSize( sizeDefault.cx, CMenuImages::Size().cy * xLargeIcons + 2 * nMargin);
	}
}

void CMFCCustomizeButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarMenuButton::CopyFrom(s);
	const CMFCCustomizeButton& src = (const CMFCCustomizeButton&) s;

	m_iCustomizeCmdId = src.m_iCustomizeCmdId;
	m_strCustomizeText = src.m_strCustomizeText;
	m_bIsEmpty = src.m_bIsEmpty;
	m_bIsPipeStyle = src.m_bIsPipeStyle;
	m_bMenuRightAlign = src.m_bMenuRightAlign;
}

void CMFCCustomizeButton::OnCancelMode()
{
	CMFCToolBarMenuButton::OnCancelMode();

	if (m_sizeExtra != CSize(0, 0) && m_pWndParentToolbar != NULL)
	{
		int nIndex = m_pWndParentToolbar->ButtonToIndex(this);
		if (nIndex >= 0)
		{
			m_pWndParentToolbar->InvalidateButton(nIndex);
		}
	}
}

BOOL CMFCCustomizeButton::InvokeCommand(CMFCPopupMenuBar* pMenuBar, const CMFCToolBarButton* pButton)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pMenuBar);
	ASSERT_VALID(pButton);

	if (m_pWndParentToolbar == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(m_pWndParentToolbar);

	int nIndex = pMenuBar->ButtonToIndex(pButton);
	if (nIndex < 0)
	{
		return FALSE;
	}

	if (m_lstInvisibleButtons.GetCount()  > 0 )
	{
		CMFCToolBarButton* pButtonHead = (CMFCToolBarButton*)m_lstInvisibleButtons.GetHead();
		if (pButtonHead->m_nStyle & TBBS_SEPARATOR)
		{
			nIndex++;
		}
	}

	POSITION pos = m_lstInvisibleButtons.FindIndex(nIndex);
	if (pos == NULL)
	{
		return FALSE;
	}

	CMFCToolBarButton* pToolbarButton = (CMFCToolBarButton*) m_lstInvisibleButtons.GetAt(pos);
	ASSERT_VALID(pToolbarButton);

	UINT nIDCmd = pToolbarButton->m_nID;

	if (!m_pWndParentToolbar->OnSendCommand(pToolbarButton) && nIDCmd != 0 && nIDCmd != (UINT) -1)
	{
		CMFCToolBar::AddCommandUsage(nIDCmd);

		if (!pToolbarButton->OnClickUp() && (afxUserToolsManager == NULL || !afxUserToolsManager->InvokeTool(nIDCmd)))
		{
			m_pWndParentToolbar->GetOwner()->PostMessage(WM_COMMAND, nIDCmd);    // send command
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdesktopalertdialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxdesktopalertdialog.h"

#include "afxdesktopalertwnd.h"
#include "afxribbonres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_MAX_CLASS_NAME 255
#define AFX_STATIC_CLASS _T("Static")
#define AFX_BUTTON_CLASS _T("Button")

#define AFX_MAX_TEXT_LEN 512

IMPLEMENT_DYNCREATE(CMFCDesktopAlertDialog, CDialogEx)

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertDialog

CMFCDesktopAlertDialog::CMFCDesktopAlertDialog()
{
	m_pParentPopup = NULL;
	m_bDefault = FALSE;
	m_sizeDlg = CSize(0, 0);
	m_bDontSetFocus = FALSE;
	m_bMenuIsActive = FALSE;
}

CMFCDesktopAlertDialog::~CMFCDesktopAlertDialog()
{
}

//{{AFX_MSG_MAP(CMFCDesktopAlertDialog)
BEGIN_MESSAGE_MAP(CMFCDesktopAlertDialog, CDialogEx)
	ON_WM_CTLCOLOR()
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_MESSAGE(WM_PRINTCLIENT, &CMFCDesktopAlertDialog::OnPrintClient)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertDialog message handlers

HBRUSH CMFCDesktopAlertDialog::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	if (nCtlColor == CTLCOLOR_STATIC)
	{
		pDC->SetBkMode(TRANSPARENT);

		if (afxGlobalData.IsHighContrastMode())
		{
			pDC->SetTextColor(afxGlobalData.clrWindowText);
		}

		return(HBRUSH) ::GetStockObject(HOLLOW_BRUSH);
	}

	return CDialogEx::OnCtlColor(pDC, pWnd, nCtlColor);
}

BOOL CMFCDesktopAlertDialog::OnEraseBkgnd(CDC* pDC)
{
	if (!afxGlobalData.IsWindowsThemingDrawParentBackground())
	{
		CRect rectClient;
		GetClientRect(&rectClient);

		CMFCVisualManager::GetInstance()->OnFillPopupWindowBackground(pDC, rectClient);
	}

	return TRUE;
}

void CMFCDesktopAlertDialog::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	CMemDC memDC(dc, this);
	CDC* pDC = &memDC.GetDC();

	OnDraw(pDC);
}

void CMFCDesktopAlertDialog::OnLButtonDown(UINT nFlags, CPoint point)
{
	CDialogEx::OnLButtonDown(nFlags, point);

	GetParent()->SendMessage(WM_LBUTTONDOWN, 0, MAKELPARAM(point.x, point.y));
	SetFocus();
}

BOOL CMFCDesktopAlertDialog::HasFocus() const
{
	if (GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	if (m_bMenuIsActive)
	{
		return TRUE;
	}

	CWnd* pWndMain = AfxGetMainWnd();
	if (pWndMain->GetSafeHwnd() == NULL)
	{
		return FALSE;
	}

	if (pWndMain->IsIconic() || !pWndMain->IsWindowVisible() || pWndMain != GetForegroundWindow())
	{
		return FALSE;
	}

	CWnd* pFocus = GetFocus();

	BOOL bActive = (pFocus->GetSafeHwnd() != NULL && (IsChild(pFocus) || pFocus->GetSafeHwnd() == GetSafeHwnd()));

	return bActive;
}

BOOL CMFCDesktopAlertDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
	ASSERT_VALID(m_pParentPopup);

	if (m_pParentPopup->ProcessCommand((HWND)lParam))
	{
		return TRUE;
	}

	if (m_btnURL.GetSafeHwnd() == (HWND) lParam && m_btnURL.GetDlgCtrlID() == LOWORD(wParam) && m_pParentPopup->OnClickLinkButton(m_btnURL.GetDlgCtrlID()))
	{
		return TRUE;
	}

	return CDialogEx::OnCommand(wParam, lParam);
}

int CMFCDesktopAlertDialog::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CDialogEx::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParentPopup = DYNAMIC_DOWNCAST(CMFCDesktopAlertWnd, GetParent());
	ASSERT_VALID(m_pParentPopup);

	return 0;
}

BOOL CMFCDesktopAlertDialog::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	CWnd* pWndChild = GetWindow(GW_CHILD);
	while (pWndChild != NULL)
	{
		ASSERT_VALID(pWndChild);

		CMFCButton* pButton = DYNAMIC_DOWNCAST(CMFCButton, pWndChild);
		if (pButton != NULL)
		{
			pButton->m_bDrawFocus = FALSE;
		}
		else
		{
			TCHAR lpszClassName [AFX_MAX_CLASS_NAME + 1];

			::GetClassName(pWndChild->GetSafeHwnd(), lpszClassName, AFX_MAX_CLASS_NAME);
			CString strClass = lpszClassName;

			if (strClass == AFX_STATIC_CLASS &&(pWndChild->GetStyle() & SS_ICON))
			{
				pWndChild->ShowWindow(SW_HIDE);
			}
		}

		pWndChild = pWndChild->GetNextWindow();
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CMFCDesktopAlertDialog::OnPrintClient(WPARAM wp, LPARAM lp)
{
	if (lp & PRF_CLIENT)
	{
		CDC* pDC = CDC::FromHandle((HDC) wp);
		ASSERT_VALID(pDC);

		OnDraw(pDC);
	}

	return 0;
}

void CMFCDesktopAlertDialog::OnDraw(CDC* pDC)
{
	ASSERT_VALID(pDC);

	CRect rectClient;
	GetClientRect(&rectClient);

	CMFCVisualManager::GetInstance()->OnFillPopupWindowBackground(pDC, rectClient);

	CWnd* pWndChild = GetWindow(GW_CHILD);

	while (pWndChild != NULL)
	{
		ASSERT_VALID(pWndChild);

		TCHAR lpszClassName [AFX_MAX_CLASS_NAME + 1];

		::GetClassName(pWndChild->GetSafeHwnd(), lpszClassName, AFX_MAX_CLASS_NAME);
		CString strClass = lpszClassName;

		if (strClass == AFX_STATIC_CLASS &&(pWndChild->GetStyle() & SS_ICON))
		{
			CRect rectIcon;
			pWndChild->GetWindowRect(rectIcon);
			ScreenToClient(rectIcon);

			HICON hIcon = ((CStatic*) pWndChild)->GetIcon();
			pDC->DrawIcon(rectIcon.TopLeft(), hIcon);
		}

		pWndChild = pWndChild->GetNextWindow();
	}
}

CSize CMFCDesktopAlertDialog::GetOptimalTextSize(CString str)
{
	if (str.IsEmpty())
	{
		return CSize(0, 0);
	}

	CRect rectScreen;
	CRect rectDlg;
	GetWindowRect(rectDlg);

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);
	if (GetMonitorInfo(MonitorFromPoint(rectDlg.TopLeft(), MONITOR_DEFAULTTONEAREST), &mi))
	{
		rectScreen = mi.rcWork;
	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
	}

	CClientDC dc(this);

	CFont* pOldFont = dc.SelectObject(&afxGlobalData.fontRegular);
	ASSERT_VALID(pOldFont);

	int nStepY = afxGlobalData.GetTextHeight();
	int nStepX = nStepY * 3;

	CRect rectText(0, 0, nStepX, nStepY);

	for (;;)
	{
		CRect rectTextSaved = rectText;

		int nHeight = dc.DrawText(str, rectText, DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX);
		int nWidth = rectText.Width();

		rectText = rectTextSaved;

		if (nHeight <= rectText.Height() || rectText.Width() > rectScreen.Width() || rectText.Height() > rectScreen.Height())
		{
			rectText.bottom = rectText.top + nHeight + 5;
			rectText.right = rectText.left + nWidth + 5;
			break;
		}

		rectText.right += nStepX;
		rectText.bottom += nStepY;
	}

	dc.SelectObject(pOldFont);
	return rectText.Size();
}

BOOL CMFCDesktopAlertDialog::CreateFromParams(CMFCDesktopAlertWndInfo& params, CMFCDesktopAlertWnd* pParent)
{
	if (!Create(IDD_AFXBARRES_POPUP_DLG, pParent))
	{
		return FALSE;
	}

	m_Params = params;

	int nXMargin = 10;
	int nYMargin = 10;

	int x = nXMargin;
	int y = nYMargin;

	int cxIcon = 0;

	CString strText = m_Params.m_strText;
	if (strText.GetLength() > AFX_MAX_TEXT_LEN)
	{
		strText = strText.Left(AFX_MAX_TEXT_LEN - 1);
	}

	CString strURL = m_Params.m_strURL;
	if (strURL.GetLength() > AFX_MAX_TEXT_LEN)
	{
		strURL = strURL.Left(AFX_MAX_TEXT_LEN - 1);
	}

	CSize sizeText = GetOptimalTextSize(strText);
	CSize sizeURL = GetOptimalTextSize(strURL);

	int cx = max(sizeText.cx, sizeURL.cx);

	if (m_Params.m_hIcon != NULL)
	{
		ICONINFO iconInfo;
		::GetIconInfo(m_Params.m_hIcon, &iconInfo);

		BITMAP bitmap;
		::GetObject(iconInfo.hbmColor, sizeof(BITMAP), &bitmap);

		::DeleteObject(iconInfo.hbmColor);
		::DeleteObject(iconInfo.hbmMask);

		CRect rectIcon = CRect(nXMargin, nYMargin, bitmap.bmWidth + nXMargin, bitmap.bmHeight + nYMargin);

		m_wndIcon.Create(_T(""), WS_CHILD | SS_ICON | SS_NOPREFIX, rectIcon, this);
		m_wndIcon.SetIcon(m_Params.m_hIcon);

		cxIcon = rectIcon.Width() + nXMargin;
		x += cxIcon;
	}

	if (!strText.IsEmpty())
	{
		CRect rectText(CPoint(x, y), CSize(cx, sizeText.cy));

		m_wndText.Create(strText, WS_CHILD | WS_VISIBLE, rectText, this);
		m_wndText.SetFont(&afxGlobalData.fontRegular);

		y = rectText.bottom + nYMargin;
	}

	if (!strURL.IsEmpty())
	{
		CRect rectURL(CPoint(x, y), CSize(cx, sizeURL.cy));

		m_btnURL.Create(strURL, WS_VISIBLE | WS_CHILD, rectURL, this, m_Params.m_nURLCmdID);

		m_btnURL.m_bMultilineText = TRUE;
		m_btnURL.m_bAlwaysUnderlineText = FALSE;
		m_btnURL.m_bDefaultClickProcess = TRUE;
		m_btnURL.m_bDrawFocus = FALSE;

		y = rectURL.bottom + nYMargin;
	}

	m_sizeDlg = CSize(cxIcon + cx + 2 * nXMargin, y);
	return TRUE;
}

CSize CMFCDesktopAlertDialog::GetDlgSize()
{
	if (!m_bDefault)
	{
		ASSERT(FALSE);
		return CSize(0, 0);
	}

	return m_sizeDlg;
}

void CMFCDesktopAlertDialog::OnSetFocus(CWnd* pOldWnd)
{
	if (m_bDontSetFocus && pOldWnd->GetSafeHwnd() != NULL)
	{
		pOldWnd->SetFocus();
		return;
	}

	CDialogEx::OnSetFocus(pOldWnd);
}

BOOL CMFCDesktopAlertDialog::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_LBUTTONDOWN && m_pParentPopup->GetSafeHwnd() != NULL)
	{
		CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);
		if (pWnd != NULL)
		{
			TCHAR lpszClassName [AFX_MAX_CLASS_NAME + 1];

			::GetClassName(pWnd->GetSafeHwnd(), lpszClassName, AFX_MAX_CLASS_NAME);
			CString strClass = lpszClassName;

			if (strClass == AFX_STATIC_CLASS || pWnd->GetSafeHwnd() == GetSafeHwnd())
			{
				m_pParentPopup->StartWindowMove();
			}
		}
	}

	return CDialogEx::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdialogimpl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxpopupmenu.h"
#include "afxtoolbarmenubutton.h"
#include "afxdialogex.h"
#include "afxpropertypage.h"
#include "afxdialogimpl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

HHOOK CDialogImpl::m_hookMouse = NULL;
CDialogImpl* CDialogImpl::m_pMenuDlgImpl = NULL;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDialogImpl::CDialogImpl(CWnd& dlg) : m_Dlg(dlg)
{
}

CDialogImpl::~CDialogImpl()
{
}

BOOL CDialogImpl::ProcessMouseClick(POINT pt)
{
	if (!CMFCToolBar::IsCustomizeMode() && CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd))
	{
		CMFCPopupMenu::MENUAREA_TYPE clickArea = CMFCPopupMenu::m_pActivePopupMenu->CheckArea(pt);

		if (clickArea == CMFCPopupMenu::OUTSIDE)
		{
			// Click outside of menu
			// Maybe secondary click on the parent button?
			CMFCToolBarMenuButton* pParentButton = CMFCPopupMenu::m_pActivePopupMenu->GetParentButton();
			if (pParentButton != NULL)
			{
				CWnd* pWndParent = pParentButton->GetParentWnd();
				if (pWndParent != NULL)
				{
					CMFCPopupMenuBar* pWndParentPopupMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, pWndParent);

					CPoint ptClient = pt;
					pWndParent->ScreenToClient(&ptClient);

					if (pParentButton->Rect().PtInRect(ptClient))
					{
						// If user clicks second time on the parent button,
						// we should close an active menu on the toolbar/menubar
						// and leave it on the popup menu:
						if (pWndParentPopupMenuBar == NULL && !CMFCPopupMenu::m_pActivePopupMenu->InCommand())
						{
							// Toolbar/menu bar: close an active menu!
							CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);
						}

						return TRUE;
					}

					if (pWndParentPopupMenuBar != NULL)
					{
						pWndParentPopupMenuBar->CloseDelayedSubMenu();

						CMFCPopupMenu* pWndParentPopupMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pWndParentPopupMenuBar->GetParent());

						if (pWndParentPopupMenu != NULL)
						{
							CMFCPopupMenu::MENUAREA_TYPE clickAreaParent = pWndParentPopupMenu->CheckArea(pt);

							switch (clickAreaParent)
							{
							case CMFCPopupMenu::MENU:
							case CMFCPopupMenu::TEAROFF_CAPTION:
							case CMFCPopupMenu::LOGO:
								return FALSE;

							case CMFCPopupMenu::SHADOW_RIGHT:
							case CMFCPopupMenu::SHADOW_BOTTOM:
								pWndParentPopupMenu->SendMessage(WM_CLOSE);
								m_Dlg.SetFocus();

								return TRUE;
							}
						}
					}
				}
			}

			if (!CMFCPopupMenu::m_pActivePopupMenu->InCommand())
			{
				CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);

				CWnd* pWndFocus = CWnd::GetFocus();
				if (pWndFocus != NULL && pWndFocus->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
				{
					m_Dlg.SetFocus();
				}

				if (clickArea != CMFCPopupMenu::OUTSIDE) // Click on shadow
				{
					return TRUE;
				}
			}
		}
		else if (clickArea == CMFCPopupMenu::SHADOW_RIGHT || clickArea == CMFCPopupMenu::SHADOW_BOTTOM)
		{
			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);
			m_Dlg.SetFocus();

			return TRUE;
		}
	}

	return FALSE;
}

BOOL CDialogImpl::ProcessMouseMove(POINT pt)
{
	if (!CMFCToolBar::IsCustomizeMode() && CMFCPopupMenu::m_pActivePopupMenu != NULL)
	{
		CRect rectMenu;
		CMFCPopupMenu::m_pActivePopupMenu->GetWindowRect(rectMenu);

		if (rectMenu.PtInRect(pt) || CMFCPopupMenu::m_pActivePopupMenu->GetMenuBar()->FindDestintationToolBar(pt) != NULL)
		{
			return FALSE; // Default processing
		}

		return TRUE; // Active menu "capturing"
	}

	return FALSE; // Default processing
}

BOOL CDialogImpl::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_SYSKEYDOWN:
	case WM_CONTEXTMENU:
		if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd) && pMsg->wParam == VK_MENU)
		{
			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);
			return TRUE;
		}
		break;

	case WM_SYSKEYUP:
		if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd))
		{
			return TRUE; // To prevent system menu opening
		}
		break;

	case WM_KEYDOWN:
		// Pass keyboard action to the active menu:
		if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd))
		{
			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_KEYDOWN, (int) pMsg->wParam);
			return TRUE;
		}
		break;

	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);

			if (pWnd != NULL && ::IsWindow(pMsg->hwnd))
			{
				pWnd->ClientToScreen(&pt);
			}

			if (ProcessMouseClick(pt))
			{
				return TRUE;
			}

			if (!::IsWindow(pMsg->hwnd))
			{
				return TRUE;
			}
		}
		break;

	case WM_NCLBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONDOWN:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONDOWN:
	case WM_NCMBUTTONUP:
		if (ProcessMouseClick(CPoint(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam))))
		{
			return TRUE;
		}
		break;

	case WM_MOUSEWHEEL:
		if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd) && CMFCPopupMenu::m_pActivePopupMenu->IsScrollable())
		{
			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_MOUSEWHEEL, pMsg->wParam, pMsg->lParam);

		}
		break;

	case WM_MOUSEMOVE:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);

			if (pWnd != NULL)
			{
				pWnd->ClientToScreen(&pt);
			}

			if (ProcessMouseMove(pt))
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}

LRESULT CALLBACK CDialogImpl::DialogMouseHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
	MOUSEHOOKSTRUCT* lpMS = (MOUSEHOOKSTRUCT*) lParam;
	ASSERT(lpMS != NULL);

	if (m_pMenuDlgImpl != NULL)
	{
		switch (wParam)
		{
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MBUTTONDOWN:
		case WM_NCLBUTTONDOWN:
		case WM_NCRBUTTONDOWN:
		case WM_NCMBUTTONDOWN:
			{
				CPoint ptCursor;
				::GetCursorPos(&ptCursor);

				CRect rectWindow;
				m_pMenuDlgImpl->m_Dlg.GetWindowRect(rectWindow);

				if (!rectWindow.PtInRect(ptCursor))
				{
					m_pMenuDlgImpl->ProcessMouseClick(ptCursor);
				}
			}
		}
	}

	return CallNextHookEx(m_hookMouse, nCode, wParam, lParam);
}

void CDialogImpl::SetActiveMenu(CMFCPopupMenu* pMenu)
{
	CMFCPopupMenu::m_pActivePopupMenu = pMenu;

	if (pMenu != NULL)
	{
		if (m_hookMouse == NULL)
		{
			m_hookMouse = ::SetWindowsHookEx(WH_MOUSE, DialogMouseHookProc, 0, GetCurrentThreadId());
		}

		m_pMenuDlgImpl = this;
	}
	else
	{
		if (m_hookMouse != NULL)
		{
			::UnhookWindowsHookEx(m_hookMouse);
			m_hookMouse = NULL;
		}

		m_pMenuDlgImpl = NULL;
	}

}

void CDialogImpl::OnDestroy()
{
	if (m_pMenuDlgImpl != NULL && m_pMenuDlgImpl->m_Dlg.GetSafeHwnd() == m_Dlg.GetSafeHwnd())
	{
		m_pMenuDlgImpl = NULL;
	}
}

BOOL CDialogImpl::OnCommand(WPARAM wParam, LPARAM /*lParam*/)
{
	if (HIWORD(wParam) == 1)
	{
		UINT uiCmd = LOWORD(wParam);

		CMFCToolBar::AddCommandUsage(uiCmd);

		// Simmulate ESC keystroke...
		if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd))
		{
			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_KEYDOWN, VK_ESCAPE);
			return TRUE;
		}

		if (afxUserToolsManager != NULL && afxUserToolsManager->InvokeTool(uiCmd))
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CDialogImpl::OnNcActivate(BOOL& bActive)
{
	// Stay active if WF_STAYACTIVE bit is on:
	if (m_Dlg.m_nFlags & WF_STAYACTIVE)
	{
		bActive = TRUE;
	}

	// But do not stay active if the window is disabled:
	if (!m_Dlg.IsWindowEnabled())
	{
		bActive = FALSE;
	}
}

void CDialogImpl::OnActivate(UINT nState, CWnd* pWndOther)
{
	m_Dlg.m_nFlags &= ~WF_STAYACTIVE;

	// Determine if this window should be active or not:
	CWnd* pWndActive = (nState == WA_INACTIVE) ? pWndOther : &m_Dlg;
	if (pWndActive != NULL)
	{
		BOOL bStayActive = (pWndActive->GetSafeHwnd() == m_Dlg.GetSafeHwnd() || pWndActive->SendMessage(WM_FLOATSTATUS, FS_SYNCACTIVE));

		if (bStayActive)
		{
			m_Dlg.m_nFlags |= WF_STAYACTIVE;
		}
	}
	else
	{
		// Force painting on our non-client area....
		m_Dlg.SendMessage(WM_NCPAINT, 1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdialogex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxdialogex.h"
#include "afxpopupmenu.h"
#include "afxtoolbarmenubutton.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CDialogEx, CDialog)

/////////////////////////////////////////////////////////////////////////////
// CDialogEx dialog

#pragma warning(disable : 4355)

CDialogEx::CDialogEx() : m_Impl(*this)
{
	CommonConstruct();
}

CDialogEx::CDialogEx(UINT nIDTemplate, CWnd *pParent/*= NULL*/) : CDialog(nIDTemplate, pParent), m_Impl(*this)
{
	CommonConstruct();
}

CDialogEx::CDialogEx(LPCTSTR lpszTemplateName, CWnd *pParentWnd/*= NULL*/) : CDialog(lpszTemplateName, pParentWnd), m_Impl(*this)
{
	CommonConstruct();
}

#pragma warning(default : 4355)

void CDialogEx::CommonConstruct()
{
	m_hBkgrBitmap = NULL;
	m_sizeBkgrBitmap = CSize(0, 0);
	m_BkgrLocation = (BackgroundLocation) -1;
	m_bAutoDestroyBmp = FALSE;
}

void CDialogEx::SetBackgroundColor(COLORREF color, BOOL bRepaint)
{
	if (m_brBkgr.GetSafeHandle() != NULL)
	{
		m_brBkgr.DeleteObject();
	}

	if (color != (COLORREF)-1)
	{
		m_brBkgr.CreateSolidBrush(color);
	}

	if (bRepaint && GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

void CDialogEx::SetBackgroundImage(HBITMAP hBitmap, BackgroundLocation location, BOOL bAutoDestroy, BOOL bRepaint)
{
	if (m_bAutoDestroyBmp && m_hBkgrBitmap != NULL)
	{
		::DeleteObject(m_hBkgrBitmap);
	}

	m_hBkgrBitmap = hBitmap;
	m_BkgrLocation = location;
	m_bAutoDestroyBmp = bAutoDestroy;

	if (hBitmap != NULL)
	{
		BITMAP bmp;
		::GetObject(hBitmap, sizeof(BITMAP), (LPVOID) &bmp);

		m_sizeBkgrBitmap = CSize(bmp.bmWidth, bmp.bmHeight);
	}
	else
	{
		m_sizeBkgrBitmap = CSize(0, 0);
	}

	if (bRepaint && GetSafeHwnd() != NULL)
	{
		Invalidate();
		UpdateWindow();
	}
}

BOOL CDialogEx::SetBackgroundImage(UINT uiBmpResId, BackgroundLocation location, BOOL bRepaint)
{
	HBITMAP hBitmap = NULL;

	if (uiBmpResId != 0)
	{
		hBitmap = ::LoadBitmapW(AfxFindResourceHandle(MAKEINTRESOURCE(uiBmpResId), RT_BITMAP),
			MAKEINTRESOURCEW(uiBmpResId));
		if (hBitmap == NULL)
		{
			ASSERT(FALSE);
			return FALSE;
		}
	}

	SetBackgroundImage(hBitmap, location, TRUE /* Autodestroy */, bRepaint);
	return TRUE;
}

BEGIN_MESSAGE_MAP(CDialogEx, CDialog)
	//{{AFX_MSG_MAP(CDialogEx)
	ON_WM_ACTIVATE()
	ON_WM_NCACTIVATE()
	ON_WM_ERASEBKGND()
	ON_WM_DESTROY()
	ON_WM_CTLCOLOR()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_SETTINGCHANGE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialogEx message handlers

void CDialogEx::OnActivate(UINT nState, CWnd *pWndOther, BOOL /*bMinimized*/)
{
	m_Impl.OnActivate(nState, pWndOther);
}

BOOL CDialogEx::OnNcActivate(BOOL bActive)
{
	m_Impl.OnNcActivate(bActive);

	// Do not call the base class because it will call Default()
	// and we may have changed bActive.
	return(BOOL) DefWindowProc(WM_NCACTIVATE, bActive, 0L);
}

BOOL CDialogEx::OnEraseBkgnd(CDC* pDC)
{
	if (m_brBkgr.GetSafeHandle() == NULL && m_hBkgrBitmap == NULL)
	{
		return CDialog::OnEraseBkgnd(pDC);
	}

	ASSERT_VALID(pDC);

	CRect rectClient;
	GetClientRect(rectClient);

	if (m_BkgrLocation != BACKGR_TILE || m_hBkgrBitmap == NULL)
	{
		if (m_brBkgr.GetSafeHandle() != NULL)
		{
			pDC->FillRect(rectClient, &m_brBkgr);
		}
		else
		{
			CDialog::OnEraseBkgnd(pDC);
		}
	}

	if (m_hBkgrBitmap == NULL)
	{
		return TRUE;
	}

	ASSERT(m_sizeBkgrBitmap != CSize(0, 0));

	if (m_BkgrLocation != BACKGR_TILE)
	{
		CPoint ptImage = rectClient.TopLeft();

		switch (m_BkgrLocation)
		{
		case BACKGR_TOPLEFT:
			break;

		case BACKGR_TOPRIGHT:
			ptImage.x = rectClient.right - m_sizeBkgrBitmap.cx;
			break;

		case BACKGR_BOTTOMLEFT:
			ptImage.y = rectClient.bottom - m_sizeBkgrBitmap.cy;
			break;

		case BACKGR_BOTTOMRIGHT:
			ptImage.x = rectClient.right - m_sizeBkgrBitmap.cx;
			ptImage.y = rectClient.bottom - m_sizeBkgrBitmap.cy;
			break;
		}

		pDC->DrawState(ptImage, m_sizeBkgrBitmap, m_hBkgrBitmap, DSS_NORMAL);
	}
	else
	{
		// Tile background image:
		for (int x = rectClient.left; x < rectClient.Width(); x += m_sizeBkgrBitmap.cx)
		{
			for (int y = rectClient.top; y < rectClient.Height(); y += m_sizeBkgrBitmap.cy)
			{
				pDC->DrawState(CPoint(x, y), m_sizeBkgrBitmap, m_hBkgrBitmap, DSS_NORMAL);
			}
		}
	}

	return TRUE;
}

void CDialogEx::OnDestroy()
{
	if (m_bAutoDestroyBmp && m_hBkgrBitmap != NULL)
	{
		::DeleteObject(m_hBkgrBitmap);
		m_hBkgrBitmap = NULL;
	}

	m_Impl.OnDestroy();

	CDialog::OnDestroy();
}

HBRUSH CDialogEx::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	if (m_brBkgr.GetSafeHandle() != NULL || m_hBkgrBitmap != NULL)
	{
#define AFX_MAX_CLASS_NAME 255
#define AFX_STATIC_CLASS _T("Static")
#define AFX_BUTTON_CLASS _T("Button")

		if (nCtlColor == CTLCOLOR_STATIC)
		{
			TCHAR lpszClassName [AFX_MAX_CLASS_NAME + 1];

			::GetClassName(pWnd->GetSafeHwnd(), lpszClassName, AFX_MAX_CLASS_NAME);
			CString strClass = lpszClassName;

			if (strClass == AFX_BUTTON_CLASS || strClass == AFX_STATIC_CLASS)
			{
				pDC->SetBkMode(TRANSPARENT);

				if (m_brBkgr.GetSafeHandle() != NULL && CThemeHelper::IsAppThemed())
				{
					return (HBRUSH)m_brBkgr.GetSafeHandle();
				}
				else
				{
					return (HBRUSH)::GetStockObject(HOLLOW_BRUSH);
				}
			}
		}
	}

	return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}

BOOL CDialogEx::PreTranslateMessage(MSG* pMsg)
{
	if (m_Impl.PreTranslateMessage(pMsg))
	{
		return TRUE;
	}

	return CDialog::PreTranslateMessage(pMsg);
}

void CDialogEx::SetActiveMenu(CMFCPopupMenu* pMenu)
{
	m_Impl.SetActiveMenu(pMenu);
}

BOOL CDialogEx::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (m_Impl.OnCommand(wParam, lParam))
	{
		return TRUE;
	}

	return CDialog::OnCommand(wParam, lParam);
}

void CDialogEx::OnSysColorChange()
{
	CDialog::OnSysColorChange();

	if (AfxGetMainWnd() == this)
	{
		afxGlobalData.UpdateSysColors();
	}
}

void CDialogEx::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CDialog::OnSettingChange(uFlags, lpszSection);

	if (AfxGetMainWnd() == this)
	{
		afxGlobalData.OnSettingChange();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdesktopalertwnd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxvisualmanager.h"
#include "afxdesktopalertwnd.h"

#include "afxdrawmanager.h"
#include "afxcontextmenumanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CMFCDesktopAlertWnd, CWnd)

// Timer IDs:
static const int nClosePopupTimerId = 1;
static const int nAnimTimerId = 2;
static const int nCheckActivityTimerId = 3;

static clock_t nLastAnimTime = 0;
static const int nSmallCaptionHeight = 7;

UINT AFX_WM_ON_CLOSEPOPUPWINDOW = ::RegisterWindowMessage(_T("AFX_WM_ON_CLOSEPOPUPWINDOW"));

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertWndButton window

void CMFCDesktopAlertWndButton::OnFillBackground(CDC* pDC, const CRect& rectClient)
{
	CMFCVisualManager::GetInstance()->OnErasePopupWindowButton(pDC, rectClient, this);
}

void CMFCDesktopAlertWndButton::OnDrawBorder(CDC* pDC, CRect& rectClient, UINT /*uiState*/)
{
	CMFCVisualManager::GetInstance()->OnDrawPopupWindowButtonBorder(pDC, rectClient, this);
}

void CMFCDesktopAlertWndButton::OnDraw(CDC* pDC, const CRect& rect, UINT uiState)
{
	if (CMFCVisualManager::GetInstance()->IsDefaultWinXPPopupButton(this))
	{
		return;
	}

	CMFCButton::OnDraw(pDC, rect, uiState);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertWnd

CMFCDesktopAlertWnd::CMFCDesktopAlertWnd()
{
	m_pWndOwner = NULL;
	m_bIsActive = FALSE;

	m_nAutoCloseTime = 3000;
	m_bSmallCaption = TRUE;
	m_bHasCloseButton = TRUE;
	m_hMenu = NULL;
	m_pWndDlg = NULL;
	m_uiDlgResID = 0;

	m_nBtnMarginVert = 2;
	m_nBtnMarginHorz = 2;

	m_nTransparency = 255; // Opaque

	m_AnimationType = CMFCPopupMenu::NO_ANIMATION;
	m_AnimationSpeed = 30;
	m_nAnimationAlpha = 0;
	m_bAnimationIsDone = FALSE;
	m_AnimSize = CSize(0, 0);
	m_FinalSize = CSize(0, 0);
	m_bIsAnimRight = FALSE;
	m_bIsAnimDown = FALSE;
	m_bFadeOutAnimation = FALSE;
	m_ptLastPos = CPoint(-1, -1);
	m_bMoving = FALSE;
	m_ptStartMove = CPoint(-1, -1);
}

CMFCDesktopAlertWnd::~CMFCDesktopAlertWnd()
{
}

//{{AFX_MSG_MAP(CMFCDesktopAlertWnd)
BEGIN_MESSAGE_MAP(CMFCDesktopAlertWnd, CWnd)
	ON_WM_TIMER()
	ON_WM_NCDESTROY()
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_WM_DESTROY()
	ON_WM_CLOSE()
	ON_WM_WINDOWPOSCHANGED()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_CANCELMODE()
	ON_WM_LBUTTONDOWN()
	ON_MESSAGE(WM_PRINTCLIENT, &CMFCDesktopAlertWnd::OnPrintClient)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCDesktopAlertWnd message handlers

BOOL CMFCDesktopAlertWnd::Create(CWnd* pWndOwner, UINT uiDlgResID, HMENU hMenu, CPoint ptPos, CRuntimeClass* pRTIDlgBar)
{
	ENSURE(pRTIDlgBar != NULL);
	ASSERT(pRTIDlgBar->IsDerivedFrom(RUNTIME_CLASS(CMFCDesktopAlertDialog)));

	m_hMenu = hMenu;
	m_pWndOwner = pWndOwner;
	m_uiDlgResID = uiDlgResID;

	m_pWndDlg = (CMFCDesktopAlertDialog*) pRTIDlgBar->CreateObject();
	ENSURE(m_pWndDlg != NULL);
	ASSERT_VALID(m_pWndDlg);

	return CommonCreate(ptPos);
}

BOOL CMFCDesktopAlertWnd::Create(CWnd* pWndOwner, CMFCDesktopAlertWndInfo& params, HMENU hMenu, CPoint ptPos)
{
	m_hMenu = hMenu;
	m_pWndOwner = pWndOwner;

	m_pWndDlg = new CMFCDesktopAlertDialog;
	ASSERT_VALID(m_pWndDlg);

	m_pWndDlg->m_bDefault = TRUE;

	return CommonCreate(ptPos, &params);
}

BOOL CMFCDesktopAlertWnd::CommonCreate(CPoint ptPos, CMFCDesktopAlertWndInfo* pParams)
{
	m_ptLastPos = ptPos;

	int nCaptionHeight = GetCaptionHeight();

	CWnd* pWndFocus = GetFocus();
	CWnd* pWndForeground = CWnd::GetForegroundWindow();

	CString strClassName = ::AfxRegisterWndClass(CS_SAVEBITS, ::LoadCursor(NULL, IDC_ARROW), (HBRUSH)(COLOR_BTNFACE + 1), NULL);

	CRect rectDummy(0, 0, 0, 0);
	DWORD dwStyleEx = WS_EX_TOOLWINDOW | WS_EX_TOPMOST;

	if (afxGlobalData.m_nBitsPerPixel > 8 && m_nTransparency < 255)
	{
		dwStyleEx |= WS_EX_LAYERED;
	}

	if (!CWnd::CreateEx(dwStyleEx, strClassName, _T(""), WS_POPUP, rectDummy, NULL, 0))
	{
		return FALSE;
	}

	CSize sizeDialog;

	m_pWndDlg->m_bDontSetFocus = TRUE;

	if (m_uiDlgResID != 0)
	{
		if (!m_pWndDlg->Create(m_uiDlgResID, this))
		{
			return FALSE;
		}

		sizeDialog = GetDialogSize();
	}
	else
	{
		ENSURE(pParams != NULL);

		if (!m_pWndDlg->CreateFromParams(*pParams, this))
		{
			return FALSE;
		}

		sizeDialog = m_pWndDlg->GetDlgSize();
	}

	m_pWndDlg->m_bDontSetFocus = FALSE;

	CSize sizeBtn = CMenuImages::Size() + CSize(6, 6);
	BOOL bButtonsOnCaption = (sizeBtn.cy + 2 <= nCaptionHeight);

	if (!bButtonsOnCaption &&(m_bHasCloseButton || m_hMenu != NULL))
	{
		sizeDialog.cx += m_nBtnMarginHorz;

		if (m_bHasCloseButton)
		{
			sizeDialog.cx += sizeBtn.cx;
		}

		if (m_hMenu != NULL)
		{
			sizeDialog.cx += sizeBtn.cx;
		}
	}

	CRect rectScreen;

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);
	if (GetMonitorInfo(MonitorFromPoint(ptPos, MONITOR_DEFAULTTONEAREST), &mi))
	{
		rectScreen = mi.rcWork;
	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
	}

	sizeDialog.cx = min(rectScreen.Width() - 2, sizeDialog.cx);
	sizeDialog.cy = min(rectScreen.Height() - nCaptionHeight - 2, sizeDialog.cy);

	m_FinalSize = sizeDialog;
	m_FinalSize.cy += nCaptionHeight + 2;
	m_FinalSize.cx += 2;

	CWnd* pBtnParent = bButtonsOnCaption ?(CWnd*) this : m_pWndDlg;

	int nBtnVertOffset = bButtonsOnCaption ? (nCaptionHeight - sizeBtn.cy) / 2 + 1 : m_nBtnMarginVert;

	CRect rectBtn = CRect( CPoint(sizeDialog.cx - sizeBtn.cx - m_nBtnMarginHorz, nBtnVertOffset), sizeBtn);
	if (m_bHasCloseButton)
	{
		m_btnClose.Create(_T(""), WS_CHILD | WS_VISIBLE, rectBtn, pBtnParent, (UINT) -1);

		m_btnClose.SetStdImage(CMenuImages::IdClose, CMenuImages::ImageBlack);
		m_btnClose.m_bDrawFocus = FALSE;
		m_btnClose.m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;

		m_btnClose.m_bIsCaptionButton = bButtonsOnCaption;
		m_btnClose.m_bIsCloseButton = TRUE;

		rectBtn.OffsetRect(-sizeBtn.cx - 1, 0);
	}

	if (m_hMenu != NULL)
	{
		m_btnMenu.Create(_T(""), WS_CHILD | WS_VISIBLE, rectBtn, pBtnParent, (UINT) -1);
		m_btnMenu.SetStdImage(CMenuImages::IdArrowDownLarge, CMenuImages::ImageBlack);
		m_btnMenu.m_bDrawFocus = FALSE;
		m_btnMenu.m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;
		m_btnMenu.m_bIsCaptionButton = bButtonsOnCaption;
	}

	if (ptPos == CPoint(-1, -1))
	{
		ptPos.x = rectScreen.right - m_FinalSize.cx;
		ptPos.y = rectScreen.bottom - m_FinalSize.cy;
	}
	else
	{
		if (ptPos.x < rectScreen.left)
		{
			ptPos.x = rectScreen.left;
		}
		else if (ptPos.x + m_FinalSize.cx > rectScreen.right)
		{
			ptPos.x = rectScreen.right - m_FinalSize.cx;
		}

		if (ptPos.y < rectScreen.top)
		{
			ptPos.y = rectScreen.top;
		}
		else if (ptPos.y + m_FinalSize.cy > rectScreen.bottom)
		{
			ptPos.y = rectScreen.bottom - m_FinalSize.cy;
		}
	}

	OnBeforeShow(ptPos);

	SetWindowPos(&wndTop, ptPos.x, ptPos.y, m_FinalSize.cx, m_FinalSize.cy, SWP_NOACTIVATE | SWP_SHOWWINDOW);

	StartAnimation();

	m_pWndDlg->SetWindowPos(NULL, 1, nCaptionHeight + 1, sizeDialog.cx, sizeDialog.cy, SWP_NOZORDER | SWP_NOACTIVATE);

	SetTimer(nCheckActivityTimerId, 100, NULL);

	if (pWndForeground->GetSafeHwnd() != NULL)
	{
		pWndForeground->SetForegroundWindow();
	}

	if (pWndFocus->GetSafeHwnd() != NULL)
	{
		pWndFocus->SetFocus();
	}

	return TRUE;
}

CSize CMFCDesktopAlertWnd::GetDialogSize()
{
	CDialogTemplate dlgt;
	if (!dlgt.Load(MAKEINTRESOURCE(m_uiDlgResID)))
	{
		ASSERT(FALSE);
		return CSize(0, 0);
	}

	CSize sizeDialog;
	dlgt.GetSizeInPixels(&sizeDialog);

	return sizeDialog;
}

void CMFCDesktopAlertWnd::OnTimer(UINT_PTR nIDEvent)
{
	switch(nIDEvent)
	{
	case nAnimTimerId:
		if (!m_bAnimationIsDone)
		{
			clock_t nCurrAnimTime = clock();

			int nDuration = nCurrAnimTime - nLastAnimTime;
			int nSteps = (int)(.5 +(float) nDuration / m_AnimationSpeed);

			if (m_bFadeOutAnimation)
			{
				nSteps = -nSteps;
			}

			switch(m_AnimationType)
			{
			case CMFCPopupMenu::UNFOLD:
				m_AnimSize.cx += nSteps * m_nAnimStepX;
				// no break intentionally

			case CMFCPopupMenu::SLIDE:
				m_AnimSize.cy += nSteps * m_nAnimStepY;
				break;

			case CMFCPopupMenu::FADE:
				m_iFadePercent += m_iFadeStep;

				if (m_iFadePercent > 100 + nSteps * m_iFadeStep)
				{
					m_iFadePercent = 101;
				}
				break;
			}

			m_AnimSize.cx = max(0, min(m_AnimSize.cx, m_FinalSize.cx));
			m_AnimSize.cy = max(0, min(m_AnimSize.cy, m_FinalSize.cy));

			if (m_bFadeOutAnimation && !m_bIsActive && (m_AnimSize.cx == 0 || m_AnimSize.cy == 0 || (m_AnimationType == CMFCPopupMenu::FADE && m_iFadePercent <= 0)))
			{
				SendMessage(WM_CLOSE);
				return;
			}

			if ((m_AnimationType != CMFCPopupMenu::FADE && m_AnimSize.cy >= m_FinalSize.cy && m_AnimSize.cx >= m_FinalSize.cx) ||
				(m_AnimationType == CMFCPopupMenu::UNFOLD && m_AnimSize.cx >= m_FinalSize.cx) || (m_AnimationType == CMFCPopupMenu::FADE && m_iFadePercent > 100) || m_bIsActive)
			{
				m_AnimSize.cx = m_FinalSize.cx;
				m_AnimSize.cy = m_FinalSize.cy;

				KillTimer(nAnimTimerId);

				if (m_btnClose.GetSafeHwnd() != NULL)
				{
					m_btnClose.ShowWindow(SW_SHOWNOACTIVATE);
				}

				if (m_btnMenu.GetSafeHwnd() != NULL)
				{
					m_btnMenu.ShowWindow(SW_SHOWNOACTIVATE);
				}

				m_pWndDlg->SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW | SWP_NOZORDER | SWP_SHOWWINDOW | SWP_NOACTIVATE);
				m_pWndDlg->ValidateRect(NULL);

				m_bAnimationIsDone = TRUE;

				if (m_nAutoCloseTime > 0)
				{
					SetTimer(nClosePopupTimerId, m_nAutoCloseTime, NULL);
				}
			}

			if (m_bFadeOutAnimation && m_AnimationType != CMFCPopupMenu::FADE)
			{
				CRect rectWnd;
				GetWindowRect(rectWnd);

				int x = m_bIsAnimRight ? rectWnd.left : rectWnd.right - m_AnimSize.cx;
				int y = m_bIsAnimDown ? rectWnd.top : rectWnd.bottom - m_AnimSize.cy;

				SetWindowPos(NULL, x, y, m_AnimSize.cx, m_AnimSize.cy, SWP_NOZORDER | SWP_NOACTIVATE);
			}
			else
			{
				Invalidate();
				UpdateWindow();
			}

			nLastAnimTime = nCurrAnimTime;
		}
		break;

	case nClosePopupTimerId:
		if (!m_bIsActive && !m_bMoving)
		{
			KillTimer(nClosePopupTimerId);
			StartAnimation(FALSE);
		}
		return;

	case nCheckActivityTimerId:
		if (!m_bMoving)
		{
			BOOL bWasActive = m_bIsActive;

			CRect rectWnd;
			GetWindowRect(rectWnd);

			CPoint ptCursor;
			GetCursorPos(&ptCursor);

			m_bIsActive = rectWnd.PtInRect(ptCursor) || m_pWndDlg->HasFocus();

			if (m_bIsActive != bWasActive && afxGlobalData.m_nBitsPerPixel > 8 && m_nTransparency < 255)
			{
				BYTE nTransparency = m_bIsActive ?(BYTE) 255 : m_nTransparency;
				SetLayeredWindowAttributes(0, nTransparency, LWA_ALPHA);
			}
		}
	}

	CWnd::OnTimer(nIDEvent);
}

void CMFCDesktopAlertWnd::OnNcDestroy()
{
	CWnd::OnNcDestroy();
	delete this;
}

BOOL CMFCDesktopAlertWnd::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMFCDesktopAlertWnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	if (!m_bAnimationIsDone)
	{
		DrawAnimation(&dc);
	}
	else
	{
		OnDraw(&dc);
	}
}

CRect CMFCDesktopAlertWnd::GetCaptionRect()
{
	int nCaptionHeight = GetCaptionHeight();

	CRect rectClient;
	GetClientRect(&rectClient);

	CRect rectCaption = rectClient;

	rectCaption.DeflateRect(1, 1);
	rectCaption.bottom = rectCaption.top + nCaptionHeight;

	return rectCaption;
}

BOOL CMFCDesktopAlertWnd::ProcessCommand(HWND hwnd)
{
	ASSERT_VALID(m_pWndDlg);

	if (hwnd == m_btnClose.GetSafeHwnd())
	{
		SendMessage(WM_CLOSE);
		return TRUE;
	}

	if (hwnd == m_btnMenu.GetSafeHwnd() && m_hMenu != NULL)
	{
		CRect rectMenuBtn;
		m_btnMenu.GetWindowRect(rectMenuBtn);

		const int x = rectMenuBtn.left;
		const int y = rectMenuBtn.bottom;

		UINT nMenuResult = 0;

		m_pWndDlg->m_bMenuIsActive = TRUE;

		if (afxContextMenuManager != NULL)
		{
			const BOOL bMenuShadows = CMFCMenuBar::IsMenuShadows();
			CMFCMenuBar::EnableMenuShadows(FALSE);

			nMenuResult = afxContextMenuManager->TrackPopupMenu(m_hMenu, x, y, this);

			CMFCMenuBar::EnableMenuShadows(bMenuShadows);
		}
		else
		{
			nMenuResult = ::TrackPopupMenu(m_hMenu, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, x, y, 0, GetSafeHwnd(), NULL);
		}

		m_pWndDlg->m_bMenuIsActive = FALSE;

		if (nMenuResult != 0)
		{
			if (m_pWndOwner != NULL)
			{
				m_pWndOwner->PostMessage(WM_COMMAND, nMenuResult);
			}
			else
			{
				m_pWndDlg->PostMessage(WM_COMMAND, nMenuResult);
			}
		}

		OnCancelMode();
		return TRUE;
	}

	return FALSE;
}

BOOL CMFCDesktopAlertWnd::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (ProcessCommand((HWND)lParam))
	{
		return TRUE;
	}

	return CWnd::OnCommand(wParam, lParam);
}

void CMFCDesktopAlertWnd::OnDestroy()
{
	if (m_pWndDlg != NULL)
	{
		m_pWndDlg->DestroyWindow();
		delete m_pWndDlg;
		m_pWndDlg = NULL;
	}

	CWnd::OnDestroy();
}

LRESULT CMFCDesktopAlertWnd::OnPrintClient(WPARAM wp, LPARAM lp)
{
	if (lp & PRF_CLIENT)
	{
		CDC* pDC = CDC::FromHandle((HDC) wp);
		ASSERT_VALID(pDC);

		OnDraw(pDC);
	}

	return 0;
}

void CMFCDesktopAlertWnd::OnDraw(CDC* pDC)
{
	ASSERT_VALID(pDC);

	CRect rectClient;
	GetClientRect(&rectClient);

	CMFCVisualManager::GetInstance()->OnDrawPopupWindowBorder(pDC, rectClient);

	CRect rectCaption = GetCaptionRect();

	COLORREF clrText = CMFCVisualManager::GetInstance()->OnDrawPopupWindowCaption(pDC, rectCaption, this);

	if (m_bSmallCaption)
	{
		return;
	}

	//--------------------
	// Draw icon and name:
	//--------------------
	CRect rectText = rectCaption;
	rectText.left += AFX_IMAGE_MARGIN;

	CWnd* pWndBtn = NULL;

	if (m_btnMenu.GetSafeHwnd() != NULL)
	{
		pWndBtn = &m_btnMenu;
	}
	else if (m_btnClose.GetSafeHwnd() != NULL)
	{
		pWndBtn = &m_btnClose;
	}

	if (pWndBtn != NULL)
	{
		CRect rectBtn;
		pWndBtn->GetWindowRect(&rectBtn);
		ScreenToClient(&rectBtn);

		rectText.right = rectBtn.left - AFX_IMAGE_MARGIN;
	}

	HICON hIcon = GetIcon(FALSE);
	if (hIcon != NULL)
	{
		CSize sizeImage = afxGlobalData.m_sizeSmallIcon;
		CRect rectImage = rectCaption;

		rectImage.top += (rectCaption.Height() - sizeImage.cy) / 2;
		rectImage.bottom = rectImage.top + sizeImage.cy;

		rectImage.left += AFX_IMAGE_MARGIN;
		rectImage.right = rectImage.left + sizeImage.cx;

		pDC->DrawState(rectImage.TopLeft(), rectImage.Size(), hIcon, DSS_NORMAL, (HBRUSH) NULL);

		rectText.left = rectImage.right + AFX_IMAGE_MARGIN;
	}

	CString strText;
	GetWindowText(strText);

	if (!strText.IsEmpty())
	{
		COLORREF clrTextOld = pDC->SetTextColor(clrText);
		pDC->SetBkMode(TRANSPARENT);
		CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontRegular);

		pDC->DrawText(strText, rectText, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);

		pDC->SelectObject(pOldFont);
		pDC->SetTextColor(clrTextOld);
	}
}

void CMFCDesktopAlertWnd::StartAnimation(BOOL bShow/* = TRUE*/)
{
	if (m_AnimationType == CMFCPopupMenu::NO_ANIMATION || afxGlobalData.bIsRemoteSession || (m_AnimationType == CMFCPopupMenu::FADE && afxGlobalData.m_nBitsPerPixel <= 8))
	{
		if (!bShow)
		{
			SendMessage(WM_CLOSE);
			return;
		}

		if (m_btnClose.GetSafeHwnd() != NULL)
		{
			m_btnClose.ShowWindow(SW_SHOWNOACTIVATE);
		}

		if (m_btnMenu.GetSafeHwnd() != NULL)
		{
			m_btnMenu.ShowWindow(SW_SHOWNOACTIVATE);
		}

		m_bAnimationIsDone = TRUE;

		if (m_nAutoCloseTime > 0)
		{
			SetTimer(nClosePopupTimerId, m_nAutoCloseTime, NULL);
		}

		m_pWndDlg->SetWindowPos(NULL,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOREDRAW|SWP_NOZORDER|SWP_SHOWWINDOW | SWP_NOACTIVATE);
		m_pWndDlg->ValidateRect(NULL);

		if (afxGlobalData.m_nBitsPerPixel > 8 && m_nTransparency < 255)
		{
			SetLayeredWindowAttributes(0, m_nTransparency, LWA_ALPHA);
		}

		return;
	}

	m_bAnimationIsDone = FALSE;
	m_bFadeOutAnimation = !bShow;

	//-------------------------
	// Set animation direction:
	//-------------------------
	CRect rectScreen;
	::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);

	CRect rectWindow;
	GetWindowRect(&rectWindow);

	m_bIsAnimRight = rectWindow.left < rectScreen.CenterPoint().x;
	m_bIsAnimDown = rectWindow.top < rectScreen.CenterPoint().y;

	m_iFadePercent = m_bFadeOutAnimation ? 100 : 0;
	m_iFadeStep = m_bFadeOutAnimation ? -10 : 10;

	if (m_FinalSize.cx > m_FinalSize.cy)
	{
		m_nAnimStepY = 10;
		m_nAnimStepX = max(1, m_nAnimStepY * m_FinalSize.cx / m_FinalSize.cy);
	}
	else
	{
		m_nAnimStepX = 10;
		m_nAnimStepY = max(1, m_nAnimStepX * m_FinalSize.cy / m_FinalSize.cx);
	}

	//--------------------------
	// Adjust initial menu size:
	//--------------------------
	m_AnimSize = m_FinalSize;

	if (bShow)
	{
		switch(m_AnimationType)
		{
		case CMFCPopupMenu::UNFOLD:
			m_AnimSize.cx = m_nAnimStepX;

		case CMFCPopupMenu::SLIDE:
			m_AnimSize.cy = m_nAnimStepY;
			break;
		}
	}

	if (m_pWndDlg != NULL && m_pWndDlg->IsWindowVisible())
	{
		m_pWndDlg->ShowWindow(SW_HIDE);
	}

	SetTimer(nAnimTimerId, m_AnimationSpeed, NULL);
	nLastAnimTime = clock();
}

void CMFCDesktopAlertWnd::DrawAnimation(CDC* pPaintDC)
{
	CRect rectClient;
	GetClientRect(&rectClient);

	int cx = m_FinalSize.cx;
	int cy = m_FinalSize.cy;

	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(pPaintDC))
	{
		return;
	}

	// create the three bitmaps if not done yet
	if (m_bmpScreenDst.GetSafeHandle() == NULL)
	{
		CBitmap* pBmpOld = NULL;

		if (m_AnimationType == CMFCPopupMenu::FADE || afxGlobalData.m_nBitsPerPixel > 8)
		{
			// Fill in the BITMAPINFOHEADER
			BITMAPINFOHEADER bih;
			bih.biSize = sizeof(BITMAPINFOHEADER);
			bih.biWidth = cx;
			bih.biHeight = cy;
			bih.biPlanes = 1;
			bih.biBitCount = 32;
			bih.biCompression = BI_RGB;
			bih.biSizeImage = cx * cy;
			bih.biXPelsPerMeter = 0;
			bih.biYPelsPerMeter = 0;
			bih.biClrUsed = 0;
			bih.biClrImportant = 0;

			HBITMAP hmbpDib;
			// Create a DIB section and attach it to the source bitmap
			hmbpDib = CreateDIBSection(dcMem.m_hDC, (LPBITMAPINFO)&bih, DIB_RGB_COLORS, (void **)&m_cFadeSrcBits, NULL, NULL);
			if (hmbpDib == NULL || m_cFadeSrcBits == NULL)
			{
				return;
			}

			m_bmpScreenSrc.Attach( hmbpDib );

			// Create a DIB section and attach it to the destination bitmap
			hmbpDib = CreateDIBSection(dcMem.m_hDC, (LPBITMAPINFO)&bih, DIB_RGB_COLORS, (void **)&m_cFadeDstBits, NULL, NULL);
			if (hmbpDib == NULL || m_cFadeDstBits == NULL)
			{
				return;
			}
			m_bmpScreenDst.Attach( hmbpDib );

			// Create a DIB section and attach it to the temporary bitmap
			hmbpDib = CreateDIBSection( dcMem.m_hDC, (LPBITMAPINFO)&bih, DIB_RGB_COLORS, (void **)&m_cFadeTmpBits, NULL, NULL);
			if (hmbpDib == NULL || m_cFadeTmpBits == NULL)
			{
				return;
			}

			m_bmpScreenTmp.Attach( hmbpDib );

			// get source image, representing the window below the popup menu
			pBmpOld = dcMem.SelectObject(&m_bmpScreenSrc);
			dcMem.BitBlt(0, 0, cx, cy, pPaintDC, rectClient.left, rectClient.top, SRCCOPY);

			// copy it to the destination so that shadow will be ok
			memcpy(m_cFadeDstBits, m_cFadeSrcBits, sizeof(COLORREF)* cx*cy);
			dcMem.SelectObject(&m_bmpScreenDst);
		}
		else
		{
			m_bmpScreenDst.CreateCompatibleBitmap(pPaintDC, cx, cy);
			pBmpOld = dcMem.SelectObject(&m_bmpScreenDst);
		}

		SendMessage(WM_PRINT, (WPARAM) dcMem.GetSafeHdc(), PRF_CHILDREN | PRF_CLIENT | PRF_ERASEBKGND);

		if (m_btnClose.GetSafeHwnd() != NULL)
		{
			m_btnClose.ShowWindow(SW_HIDE);
		}

		if (m_btnMenu.GetSafeHwnd() != NULL)
		{
			m_btnMenu.ShowWindow(SW_HIDE);
		}

		CRect rect;
		m_pWndDlg->GetWindowRect(&rect);
		ScreenToClient(&rect);

		dcMem.SetViewportOrg(rect.TopLeft());
		m_pWndDlg->SendMessage(WM_PRINT, (WPARAM) dcMem.GetSafeHdc(), PRF_CHILDREN | PRF_CLIENT | PRF_ERASEBKGND);

		dcMem.SetViewportOrg(CPoint(0,0));

		dcMem.SelectObject(pBmpOld);

		if (afxGlobalData.m_nBitsPerPixel > 8 && m_nTransparency < 255)
		{
			SetLayeredWindowAttributes(0, m_nTransparency, LWA_ALPHA);
		}
	}

	COLORREF *src = m_cFadeSrcBits;
	COLORREF *dst = m_cFadeDstBits;
	COLORREF *tmp = m_cFadeTmpBits;

	CBitmap* pBmpOld = NULL;

	switch(m_AnimationType)
	{
	case CMFCPopupMenu::UNFOLD:
	case CMFCPopupMenu::SLIDE:
		pBmpOld = dcMem.SelectObject(&m_bmpScreenDst);

		pPaintDC->BitBlt(
			m_bIsAnimRight ? rectClient.left : rectClient.right - m_AnimSize.cx,
			m_bIsAnimDown ? rectClient.top : rectClient.bottom - m_AnimSize.cy,
			m_AnimSize.cx, m_AnimSize.cy, &dcMem, 0, 0, SRCCOPY);
		break;

	case CMFCPopupMenu::FADE:
		pBmpOld = dcMem.SelectObject(&m_bmpScreenTmp);
		for (int pixel = 0; pixel < cx * cy; pixel++)
		{
			*tmp++ = CDrawingManager::PixelAlpha(*src++, *dst++, 100 - m_iFadePercent);
		}

		pPaintDC->BitBlt(rectClient.left, rectClient.top, cx, cy, &dcMem, 0, 0, SRCCOPY);
	}

	dcMem.SelectObject(pBmpOld);
}

int CMFCDesktopAlertWnd::GetCaptionHeight()
{
	if (m_bSmallCaption)
	{
		return nSmallCaptionHeight;
	}
	else
	{
		CSize sizeBtn = CMenuImages::Size() + CSize(6, 6);
		return max(::GetSystemMetrics(SM_CYSMCAPTION), sizeBtn.cy + 2);
	}
}

void CMFCDesktopAlertWnd::OnClose()
{
	if (m_pWndOwner->GetSafeHwnd() != NULL)
	{
		m_pWndOwner->SendMessage(AFX_WM_ON_CLOSEPOPUPWINDOW, 0, (LPARAM) this);
	}

	CWnd::OnClose();
}

void CMFCDesktopAlertWnd::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)
{
	CWnd::OnWindowPosChanged(lpwndpos);
}

void CMFCDesktopAlertWnd::StartWindowMove()
{
	m_bMoving = TRUE;
	GetCursorPos(&m_ptStartMove);

	SetCapture();
	KillTimer(nClosePopupTimerId);
}

void CMFCDesktopAlertWnd::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bMoving)
	{
		// ---------------------
		// Calc screen rectangle
		// ---------------------
		CRect rectScreen;

		CPoint ptCursor = point;
		ClientToScreen(&ptCursor);

		MONITORINFO mi;
		mi.cbSize = sizeof(MONITORINFO);
		if (GetMonitorInfo(MonitorFromPoint(ptCursor, MONITOR_DEFAULTTONEAREST), &mi))
		{
			rectScreen = mi.rcWork;
		}
		else
		{
			::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
		}

		CPoint ptMouse;
		GetCursorPos(&ptMouse);

		CPoint ptOffset = ptMouse - m_ptStartMove;
		m_ptStartMove = ptMouse;

		CRect rect;
		GetWindowRect(&rect);
		rect.OffsetRect(ptOffset);

		if (rect.left < rectScreen.left)
		{
			rect.OffsetRect(rectScreen.left - rect.left, 0);
		}
		else if (rect.right > rectScreen.right)
		{
			rect.OffsetRect(rectScreen.right - rect.right, 0);
		}

		if (rect.top < rectScreen.top)
		{
			rect.OffsetRect(0, rectScreen.top - rect.top);
		}
		else if (rect.bottom > rectScreen.bottom)
		{
			rect.OffsetRect(0, rectScreen.bottom - rect.bottom);
		}

		SetWindowPos(NULL, rect.left, rect.top, -1, -1, SWP_NOZORDER | SWP_NOSIZE | SWP_SHOWWINDOW);
	}

	CWnd::OnMouseMove(nFlags, point);
}

void CMFCDesktopAlertWnd::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bMoving)
	{
		ReleaseCapture();
		m_bMoving = FALSE;

		if (m_nAutoCloseTime > 0)
		{
			SetTimer(nClosePopupTimerId, m_nAutoCloseTime, NULL);
		}

		CRect rectWnd;
		GetWindowRect(rectWnd);

		m_ptLastPos = rectWnd.TopLeft();
	}

	CWnd::OnLButtonUp(nFlags, point);
}

void CMFCDesktopAlertWnd::OnCancelMode()
{
	CWnd::OnCancelMode();

	if (m_bMoving)
	{
		ReleaseCapture();
		m_bMoving = FALSE;

		if (m_nAutoCloseTime > 0)
		{
			SetTimer(nClosePopupTimerId, m_nAutoCloseTime, NULL);
		}

		CRect rectWnd;
		GetWindowRect(rectWnd);

		m_ptLastPos = rectWnd.TopLeft();
	}
}

void CMFCDesktopAlertWnd::OnLButtonDown(UINT /*nFlags*/, CPoint /*point*/)
{
	StartWindowMove();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdockablepane.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxglobals.h"
#include "afxglobalutils.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxpaneframewnd.h"
#include "afxmultipaneframewnd.h"
#include "afxbasepane.h"
#include "afxdockingpanesrow.h"
#include "afxtabbedpane.h"
#include "afxdrawmanager.h"
#include "afxautohidebutton.h"
#include "afxautohidebar.h"
#include "afxautohidedocksite.h"
#include "afxpanedivider.h"
#include "afxribbonres.h"
#include "afxdockablepane.h"
#include "afxpanecontainermanager.h"
#include "afxoutlookbar.h"
#include "afxmultipaneframewnd.h"
#include "afxpropertygridtooltipctrl.h"
#include "afxtooltipmanager.h"
#include "afxmdichildwndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

int  CDockablePane::m_nTimeOutBeforeAutoHide = 700;
int  CDockablePane::m_nSlideDefaultTimeOut   = 1;
BOOL CDockablePane::m_bHideInAutoHideMode    = FALSE;
int  CDockablePane::m_nSlideSteps            = 12;

static int g_nCloseButtonMargin = 1;
static int g_nCaptionVertMargin = 2;
static int g_nCaptionHorzMargin = 2;

CSize CDockablePane::m_sizeDragSensitivity = CSize(GetSystemMetrics(SM_CXDRAG), GetSystemMetrics(SM_CYDRAG));

BOOL CDockablePane::m_bCaptionText = FALSE;
BOOL CDockablePane::m_bHideDisabledButtons = TRUE;
BOOL CDockablePane::m_bDisableAnimation = FALSE;

IMPLEMENT_SERIAL(CDockablePane, CPane, VERSIONABLE_SCHEMA | 2)

UINT AFX_WM_ON_PRESS_CLOSE_BUTTON = ::RegisterWindowMessage(_T("AFX_WM_ON_PRESS_CLOSE_BUTTON"));

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDockablePane::CDockablePane()
{
	m_bPrepareToFloat = false;
	m_bReadyToFloat = false;

	m_pTabbedControlBarRTC = RUNTIME_CLASS(CTabbedPane);

	m_hDefaultSlider = NULL;
	m_cyGripper = 0;
	m_bHasGripper = FALSE;
	m_nBorderSize = 0;
	m_dwSCBStyle = 0;
	m_bActive = FALSE;

	m_bEnableAutoHideAll = TRUE;

	m_bPinState = FALSE;
	m_nAutoHideConditionTimerID = 0;
	m_nSlideTimer = 0;
	m_nSlideStep = 0;
	m_nSlideDelta = 0;
	m_pAutoHideButton = NULL;
	m_pAutoHideBar = NULL;

	m_ahSlideMode = CDockingManager::m_ahSlideModeGlobal;

	m_bIsSliding = FALSE;
	m_bIsHiding = FALSE;
	m_bIsResizing = FALSE;

	m_nLastPercent = 100;

	m_rectRedraw.SetRectEmpty();
	m_rectRestored.SetRectEmpty();

	m_nHot = HTNOWHERE;
	m_nHit = HTNOWHERE;
	m_bCaptionButtonsCaptured = FALSE;

	m_hRestoredDefaultSlider = NULL;
	m_pToolTip = NULL;
}

CDockablePane::~CDockablePane()
{
}

//{{AFX_MSG_MAP(CDockablePane)
BEGIN_MESSAGE_MAP(CDockablePane, CPane)
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	ON_WM_NCHITTEST()
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_CLOSE()
	ON_WM_CREATE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_DESTROY()
	ON_WM_NCMOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_TIMER()
	ON_WM_RBUTTONDOWN()
	ON_WM_SETTINGCHANGE()
	ON_WM_CONTEXTMENU()
	ON_WM_SETFOCUS()
	ON_MESSAGE(WM_SETTEXT, &CDockablePane::OnSetText)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT, 0, 0xFFFF, &CDockablePane::OnNeedTipText)
	ON_REGISTERED_MESSAGE(AFX_WM_UPDATETOOLTIPS, &CDockablePane::OnUpdateToolTips)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

BOOL CDockablePane::Create(LPCTSTR lpszCaption, CWnd* pParentWnd, const RECT& rect, BOOL bHasGripper,
	UINT nID, DWORD dwStyle, DWORD dwTabbedStyle, DWORD dwControlBarStyle, CCreateContext* pContext)
{
	ASSERT_VALID(this);
	return CDockablePane::CreateEx(0, lpszCaption, pParentWnd, rect, bHasGripper, nID, dwStyle, dwTabbedStyle, dwControlBarStyle, pContext);
}

BOOL CDockablePane::Create(LPCTSTR lpszWindowName, CWnd* pParentWnd, CSize sizeDefault, BOOL bHasGripper,
	UINT nID, DWORD dwStyle, DWORD dwTabbedStyle, DWORD dwControlBarStyle)
{
	ASSERT_VALID(this);
	CRect rect(0, 0, sizeDefault.cx, sizeDefault.cy);
	return CDockablePane::CreateEx(0, lpszWindowName, pParentWnd, rect, bHasGripper, nID, dwStyle, dwTabbedStyle, dwControlBarStyle, NULL);
}

BOOL CDockablePane::CreateEx(DWORD dwStyleEx, LPCTSTR lpszCaption, CWnd* pParentWnd, const RECT& rect, BOOL bHasGripper,
	UINT nID, DWORD dwStyle, DWORD dwTabbedStyle, DWORD dwControlBarStyle, CCreateContext* pContext)
{
	ASSERT_VALID(this);

	if (dwStyle & CBRS_FLOAT_MULTI)
	{
		m_pMiniFrameRTC = RUNTIME_CLASS(CMultiPaneFrameWnd);
	}

	if (dwTabbedStyle & AFX_CBRS_OUTLOOK_TABS)
	{
		m_pTabbedControlBarRTC = RUNTIME_CLASS(CMFCOutlookBar);
	}
	else if (dwTabbedStyle & AFX_CBRS_REGULAR_TABS)
	{
		m_pTabbedControlBarRTC = RUNTIME_CLASS(CTabbedPane);
	}

	if (dwStyle & WS_CAPTION || bHasGripper)
	{
		m_bHasGripper = bHasGripper = TRUE;
		dwStyle &= ~WS_CAPTION;
	}

	if (!CPane::CreateEx(dwStyleEx, NULL, dwStyle, rect, pParentWnd, nID, dwControlBarStyle, pContext))
	{
		return FALSE;
	}

	m_rectRestored = rect;

	SetPaneAlignment(dwStyle & CBRS_ALIGN_ANY);
	EnableGripper(bHasGripper);

	if (m_sizeDialog != CSize(0, 0))
	{
		m_sizeDialog.cy += GetCaptionHeight();
		m_rectRestored.right = m_rectRestored.left + m_sizeDialog.cx;
		m_rectRestored.bottom = m_rectRestored.top + m_sizeDialog.cy;
	}

	if (lpszCaption != NULL)
	{
		SetWindowText(lpszCaption);
	}

	return TRUE;
}

void CDockablePane::EnableGripper(BOOL bEnable)
{
	if (bEnable && m_bHasGripper)
	{
		m_cyGripper = afxGlobalData.GetTextHeight() + g_nCaptionVertMargin * 2 + 1;
	}
	else
	{
		m_cyGripper = 0;
	}

	SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
}

int CDockablePane::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPane::OnCreate(lpCreateStruct) == -1)
		return -1;

	SetCaptionButtons();

	if (CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_DOCKBAR))
	{
		for (int i = 0; i < AFX_CONTROLBAR_BUTTONS_NUM; i ++)
		{
			CRect rectDummy;
			rectDummy.SetRectEmpty();

			m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, i + 1);
		}
	}

	return 0;
}

BOOL CDockablePane::IsDocked() const
{
	ASSERT_VALID(this);
	CPaneFrameWnd* pParent = GetParentMiniFrame();

	if (pParent != NULL && pParent->GetPaneCount() == 1)
	{
		return FALSE;
	}

	return TRUE;
}

void CDockablePane::OnAfterDock(CBasePane* /*pBar*/, LPCRECT /*lpRect*/, AFX_DOCK_METHOD /*dockMethod*/)
{
	if (!CDockingManager::m_bRestoringDockState)
	{
		SetFocus();
	}

	if (GetDockingMode() == DT_IMMEDIATE)
	{
		GetCursorPos(&m_ptClientHotSpot);
		ScreenToClient(&m_ptClientHotSpot);
	}

	if (GetDlgCtrlID() != -1 && GetParentMiniFrame() == NULL)
	{
		CPaneFrameWnd::AddRemovePaneFromGlobalList(this, FALSE /* remove*/);
	}

}

void CDockablePane::OnBeforeChangeParent(CWnd* pWndNewParent, BOOL bDelay)
{
	ASSERT_VALID(this);

	if (pWndNewParent != NULL)
	{
		BOOL bIsMDIChild = pWndNewParent->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx));

		if (bIsMDIChild)
		{
			StoreRecentDockSiteInfo();
		}

		// is being floated or tabbed
		if (pWndNewParent->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)) || pWndNewParent->IsKindOf(RUNTIME_CLASS(CMFCTabCtrl)) || bIsMDIChild)
		{
			UndockPane(bDelay);
		}

		CPane::OnBeforeChangeParent(pWndNewParent);
	}
}

void CDockablePane::RemoveFromDefaultPaneDividier()
{
	ASSERT_VALID(this);

	if (m_hDefaultSlider != NULL)
	{
		// slider will be deleted here(by delete this) if it was a last
		// control bar registered with the slider
		SetDefaultPaneDivider(NULL);
	}
}

void CDockablePane::OnAfterChangeParent(CWnd* pWndOldParent)
{
	ASSERT_VALID(this);
	CPane::OnAfterChangeParent(pWndOldParent);

	CPaneFrameWnd* pMiniFrameParent = GetParentMiniFrame();
	if (pMiniFrameParent != NULL)
	{
		pMiniFrameParent->AddRemovePaneFromGlobalList(this, TRUE);
	}
}

void CDockablePane::UpdateTooltips()
{
	if (m_pToolTip->GetSafeHwnd() == NULL)
	{
		return;
	}

	CRect rcBar;
	GetWindowRect(rcBar);
	ScreenToClient(rcBar);

	for (int i = 0; i < m_arrButtons.GetSize() && i < m_pToolTip->GetToolCount( ); i ++)
	{
		CMFCCaptionButton* pbtn = m_arrButtons [i];
		ASSERT_VALID(pbtn);

		CRect rectTT = pbtn->GetRect();
		rectTT.OffsetRect(rcBar.TopLeft());
		m_pToolTip->SetToolRect(this, i + 1, rectTT);
	}
}

void CDockablePane::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	ASSERT_VALID(this);
	CPane::OnNcCalcSize(bCalcValidRects, lpncsp);

	if (IsFloating())
	{
		for (int i = 0; i < m_arrButtons.GetSize(); i ++)
		{
			CMFCCaptionButton* pbtn = m_arrButtons [i];
			ASSERT_VALID(pbtn);

			pbtn->m_bHidden = TRUE;
		}

		return;
	}

	int cyGripper = GetCaptionHeight();

	CRect rcClient = lpncsp->rgrc[0];
	rcClient.DeflateRect(0, cyGripper, 0, 0);

	// "hide" and "expand" buttons positioning:
	CSize sizeButton = CMFCCaptionButton::GetSize();
	CPoint ptOrgBtnRight = CPoint(rcClient.right - sizeButton.cx - g_nCaptionHorzMargin, rcClient.top - cyGripper - m_nBorderSize +(cyGripper - sizeButton.cy) / 2);
	CPoint ptOrgBtnLeft = CPoint(rcClient.left + g_nCaptionHorzMargin, ptOrgBtnRight.y);

	CRect rcBar;
	GetWindowRect(rcBar);
	ScreenToClient(rcBar);

	BOOL bHidePinBtn = !CanAutoHide();

	if (cyGripper > 0)
	{
		int i = 0;

		for (i = 0; i < m_arrButtons.GetSize(); i ++)
		{
			CMFCCaptionButton* pbtn = m_arrButtons [i];
			ASSERT_VALID(pbtn);

			UINT unHit = pbtn->GetHit();

			BOOL bHide = FALSE;
			if (m_bHideDisabledButtons)
			{
				bHide = bHidePinBtn && unHit == HTMAXBUTTON || !CanBeClosed() && unHit == AFX_HTCLOSE;
			}

			if (!CDockingManager::IsDockSiteMenu() && unHit == HTMINBUTTON)
			{
				bHide = TRUE;
			}

			pbtn->m_bFocused = pbtn->m_bPushed = FALSE;

			if (pbtn->m_bLeftAlign)
			{
				pbtn->Move(ptOrgBtnLeft - CRect(lpncsp->rgrc[0]).TopLeft(), bHide);

				if (!bHide)
				{
					ptOrgBtnLeft.Offset(sizeButton.cx + 2, 0);
				}
			}
			else
			{
				pbtn->Move(ptOrgBtnRight - CRect(lpncsp->rgrc[0]).TopLeft(), bHide);

				if (!bHide)
				{
					ptOrgBtnRight.Offset(- sizeButton.cx - 2, 0);
				}
			}
		}

		// Hide left aligned buttons if there is no room for them:
		for (i = 0; i < m_arrButtons.GetSize(); i ++)
		{
			CMFCCaptionButton* pbtn = m_arrButtons [i];
			ASSERT_VALID(pbtn);

			if (pbtn->m_bLeftAlign)
			{
				pbtn->m_bHidden = CRect(lpncsp->rgrc[0]).left + pbtn->GetRect().left >= ptOrgBtnRight.x;
			}
		}
	}
	else
	{
		for (int i = 0; i < m_arrButtons.GetSize(); i ++)
		{
			CMFCCaptionButton* pbtn = m_arrButtons [i];
			ASSERT_VALID(pbtn);

			pbtn->m_bHidden = TRUE;
		}
	}

	rcClient.right = max(rcClient.right, rcClient.left);
	rcClient.bottom = max(rcClient.bottom, rcClient.top);

	lpncsp->rgrc[0] = rcClient;

	UpdateTooltips();
}

void CDockablePane::OnNcPaint()
{
	if (m_bMultiThreaded)
	{
		m_CriticalSection.Lock();
	}

	ASSERT_VALID(this);

	// get window DC that is clipped to the non-client area
	CWindowDC dcPaint(this);

	CRect rectUpd;
	GetUpdateRect(rectUpd);

	CRect rcClient, rcBar;
	GetClientRect(rcClient);
	ClientToScreen(rcClient);
	GetWindowRect(rcBar);

	rcClient.OffsetRect(-rcBar.TopLeft());
	rcBar.OffsetRect(-rcBar.TopLeft());

	CDC* pDC = &dcPaint;
	BOOL m_bMemDC = FALSE;
	CDC dcMem;
	CBitmap bmp;
	CBitmap* pOldBmp = NULL;

	if (dcMem.CreateCompatibleDC(&dcPaint) && bmp.CreateCompatibleBitmap(&dcPaint, rcBar.Width(), rcBar.Height()))
	{
		// Off-screen DC successfully created. Better paint to it then!
		m_bMemDC = TRUE;
		pOldBmp = dcMem.SelectObject(&bmp);
		pDC = &dcMem;
	}

	// client area is not our bussiness :)
	dcPaint.ExcludeClipRect(rcClient);

	CRgn rgn;
	if (!m_rectRedraw.IsRectEmpty())
	{
		rgn.CreateRectRgnIndirect(m_rectRedraw);
		dcPaint.SelectClipRgn(&rgn);
	}

	// erase parts not drawn
	dcPaint.IntersectClipRect(rcBar);

	// erase NC background the hard way
	CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, this, rcBar, rcBar, TRUE /* NC area */);

	int cyGripper = GetCaptionHeight();

	if (cyGripper > 0)
	{
		// Paint caption and buttons:
		CRect rectCaption;

		GetWindowRect(&rectCaption);
		ScreenToClient(&rectCaption);

		rectCaption.OffsetRect(-rectCaption.left, -rectCaption.top);
		rectCaption.DeflateRect(0, 1);

		rectCaption.left = rcClient.left;
		rectCaption.top --;
		rectCaption.bottom = rectCaption.top + cyGripper - 2;

		DrawCaption(pDC, rectCaption);

		for (int i = 0; i < m_arrButtons.GetSize(); i ++)
		{
			CMFCCaptionButton* pbtn = m_arrButtons [i];
			ASSERT_VALID(pbtn);

			BOOL bIsMax = FALSE;

			switch (pbtn->GetHit())
			{
			case HTMAXBUTTON:
				bIsMax = m_bPinState;
				break;

			case HTMINBUTTON:
				bIsMax = TRUE;
				break;
			}

			pbtn->OnDraw(pDC, m_bActive, IsHorizontal(), bIsMax);
			pbtn->m_clrForeground = (COLORREF)-1;
		}
	}

	if (m_bMemDC)
	{
		// Copy the results to the on-screen DC:
		dcPaint.BitBlt(rcBar.left, rcBar.top, rcBar.Width(), rcBar.Height(), &dcMem, rcBar.left, rcBar.top, SRCCOPY);

		dcMem.SelectObject(pOldBmp);
	}

	dcPaint.SelectClipRgn(NULL);

	if (m_bMultiThreaded)
	{
		m_CriticalSection.Unlock();
	}
}

void CDockablePane::OnDrawDragRect(LPCRECT lprectNew, LPCRECT lprectOld)
{
	ASSERT_VALID(this);
	CWindowDC dcWnd(GetDesktopWindow());
	dcWnd.DrawDragRect(lprectNew, CSize(1, 1), lprectOld, CSize(1, 1));
}

LRESULT CDockablePane::OnNcHitTest(CPoint point)
{
	ASSERT_VALID(this);
	UINT nHitTest = HitTest(point);
	if (nHitTest != HTERROR)
	{
		return nHitTest;
	}
	return CPane::OnNcHitTest(point);
}

int CDockablePane::HitTest(CPoint point, BOOL bDetectCaption)
{
	ASSERT_VALID(this);
	CRect rectWnd;
	GetWindowRect(&rectWnd);

	if (!rectWnd.PtInRect(point))
	{
		return HTNOWHERE;
	}

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
	ENSURE(pDockManager != NULL || afxGlobalUtils.m_bDialogApp);

	// should return hite test of client or caption only in the lock update mode
	if (pDockManager != NULL && !pDockManager->m_bLockUpdate)
	{
		for (int i = 0; i < m_arrButtons.GetSize(); i ++)
		{
			CMFCCaptionButton* pbtn = m_arrButtons [i];
			ASSERT_VALID(pbtn);

			CRect rc = pbtn->GetRect();
			rc.OffsetRect(rectWnd.TopLeft());
			if (rc.PtInRect(point))
			{
				return pbtn->GetHit();
			}
		}
	}

	CRect rectClient;
	GetClientRect(&rectClient);
	ClientToScreen(&rectClient);

	if (rectClient.PtInRect(point))
	{
		return HTCLIENT;
	}

	if (IsDocked())
	{
		CRect rect;
		int nBorderWidth  = 0;
		int nBorderHeight = 1;
		// caption
		rect.SetRect(rectWnd.left + nBorderWidth, rectWnd.top + nBorderHeight, rectWnd.right - nBorderWidth, rectWnd.top + nBorderHeight + GetCaptionHeight());
		if (rect.PtInRect(point))
		{
			return bDetectCaption ? HTCAPTION : HTCLIENT;
		}
	}

	return HTERROR;
}

CSize CDockablePane::CalcFixedLayout(BOOL /*bStretch*/, BOOL /*bHorz*/)
{
	ASSERT_VALID(this);
	CRect rectWnd;
	GetWindowRect(&rectWnd);
	CSize size = rectWnd.Size();
	return size;
}

void CDockablePane::OnPaint()
{
	ASSERT_VALID(this);
	CPaintDC dc(this); // device context for painting
}

AFX_CS_STATUS CDockablePane::IsChangeState(int nOffset, CBasePane** ppTargetBar) const
{
	ASSERT_VALID(this);
	ENSURE(ppTargetBar != NULL);

	CPoint ptMouse;
	GetCursorPos(&ptMouse);

	CWnd* pParentWnd = GetParent();

	if (pParentWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
	{
		CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, pParentWnd);
		pParentWnd = pMiniFrame->GetParent();
	}

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(pParentWnd);

	if (pDockManager == NULL)
	{
		return CS_NOTHING;
	}

	return pDockManager->DeterminePaneAndStatus(ptMouse, nOffset, GetEnabledAlignment(), ppTargetBar, this, this);
}

void CDockablePane::OnLButtonDown(UINT nFlags, CPoint point)
{
	ASSERT_VALID(this);

	if (m_nHot != HTNOWHERE)
	{
		CMFCCaptionButton* pBtn = FindButtonByHit(m_nHot);
		if (pBtn != NULL)
		{
			SetFocus();

			m_nHit = m_nHot;
			pBtn->m_bPushed = TRUE;
			RedrawButton(pBtn);
			return;
		}
	}
	else
	{
		CWnd* pWndChild = GetWindow(GW_CHILD);
		CWnd* pWndFirstChild = NULL;
		int nCount = 0;

		while (pWndChild != NULL)
		{
			pWndFirstChild = pWndChild;
			pWndChild = pWndChild->GetNextWindow();
			nCount++;
		}

		if (nCount == 1)
		{
			pWndFirstChild->SetFocus();
		}
	}

	if (!IsAutoHideMode() && !IsTabbed())
	{
		if (CanFloat())
		{
			m_bPrepareToFloat = true;
		}

		CPane::OnLButtonDown(nFlags, point);
	}

	SetFocus();
}

void CDockablePane::StoreRecentDockSiteInfo()
{
	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();

	CDockablePane* pBarToSave = this;

	if (IsTabbed())
	{
		CMFCBaseTabCtrl* pTabWnd = DYNAMIC_DOWNCAST(CMFCBaseTabCtrl, GetParent());
		if (pTabWnd != NULL)
		{
			pBarToSave = DYNAMIC_DOWNCAST(CDockablePane, pTabWnd->GetParent());
		}
	}

	CPaneDivider* pDefaultSlider = pBarToSave->GetDefaultPaneDivider();

	if (pParentMiniFrame != NULL)
	{
		pParentMiniFrame->StoreRecentDockSiteInfo(pBarToSave);
	}
	else if (pDefaultSlider != NULL)
	{
		pDefaultSlider->StoreRecentDockSiteInfo(pBarToSave);
	}
}

void CDockablePane::StoreRecentTabRelatedInfo()
{
	if (!IsTabbed())
	{
		return;
	}

	CDockablePane* pParentTabbedBar = NULL;

	CMFCBaseTabCtrl* pTabWnd = DYNAMIC_DOWNCAST(CMFCBaseTabCtrl, GetParent());
	if (pTabWnd != NULL)
	{
		pParentTabbedBar = DYNAMIC_DOWNCAST(CDockablePane, pTabWnd->GetParent());
	}

	if (pParentTabbedBar == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();
	CPaneDivider* pDefaultSlider = pParentTabbedBar->GetDefaultPaneDivider();

	if (pParentMiniFrame != NULL)
	{
		pParentMiniFrame->StoreRecentTabRelatedInfo(this, pParentTabbedBar);
	}
	else if (pDefaultSlider != NULL)
	{
		pDefaultSlider->StoreRecentTabRelatedInfo(this, pParentTabbedBar);
	}
}

void CDockablePane::OnRButtonDown(UINT nFlags, CPoint point)
{
	SetFocus();

	CWnd* pMenu = CMFCPopupMenu::GetActiveMenu();

	if (pMenu != NULL && CWnd::FromHandlePermanent(pMenu->GetSafeHwnd()) != NULL)
	{
		CMFCPopupMenu::UpdateAllShadows();
	}

	CPane::OnRButtonDown(nFlags, point);
}

void CDockablePane::OnMouseMove(UINT nFlags, CPoint point)
{
	ASSERT_VALID(this);
	CPoint ptMouse;
	GetCursorPos(&ptMouse);

	if ((GetDockingMode() & DT_IMMEDIATE) != 0)
	{
		if ((!m_bCaptured && GetCapture() == this || m_bCaptured && GetCapture() != this || (GetAsyncKeyState(VK_LBUTTON) & 0x8000) == 0) && !m_bCaptionButtonsCaptured)
		{
			ReleaseCapture();
			m_bCaptured = false;
			m_bPrepareToFloat = false;
		}
		if (m_bPrepareToFloat)
		{
			CRect rectBar;
			GetWindowRect(rectBar);

			if (!m_bReadyToFloat)
			{
				m_bReadyToFloat = rectBar.PtInRect(ptMouse) == TRUE;
			}

			CRect rectLast = m_rectDragImmediate;

			CPoint ptOffset = ptMouse - m_dragFrameImpl.m_ptHot;
			m_dragFrameImpl.m_ptHot = ptMouse;

			CPoint ptClientHot = m_ptClientHotSpot;
			ClientToScreen(&ptClientHot);
			CPoint ptDragOffset = ptMouse - ptClientHot;

			UpdateVirtualRect(ptOffset);

			if ((abs(ptDragOffset.x) > m_sizeDragSensitivity.cx || abs(ptDragOffset.y) > m_sizeDragSensitivity.cy) && m_bReadyToFloat)
			{
				if (IsTabbed())
				{
					CMFCBaseTabCtrl* pParentTab = DYNAMIC_DOWNCAST(CMFCBaseTabCtrl, GetParent());
					if (pParentTab != NULL)
					{
						pParentTab->DetachTab(DM_MOUSE);
					}
				}
				else
				{
					FloatPane(m_recentDockInfo.m_rectRecentFloatingRect, DM_MOUSE);
					CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
					afxGlobalUtils.ForceAdjustLayout(pDockManager);
				}
				m_bPrepareToFloat = false;
				m_bReadyToFloat = false;
			}
			return;
		}
	}
	else if ((GetDockingMode() & DT_STANDARD) != 0 && m_bPrepareToFloat)
	{
		CPane::OnMouseMove(nFlags, point);
		return;
	}

	CPoint ptScreen = point;
	ClientToScreen(&ptScreen);

	OnTrackCaptionButtons(ptScreen);
}

void CDockablePane::OnLButtonUp(UINT nFlags, CPoint point)
{
	ASSERT_VALID(this);

	if (m_bPrepareToFloat)
	{
		m_bPrepareToFloat = false;
	}

	if (m_nHit != HTNOWHERE)
	{
		CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
		ENSURE(pDockManager != NULL || afxGlobalUtils.m_bDialogApp);

		UINT nHot = m_nHot;
		UINT nHit = m_nHit;

		StopCaptionButtonsTracking();

		CPaneDivider* pDefaultSlider = GetDefaultPaneDivider();

		if (nHot == nHit)
		{
			switch (nHit)
			{
			case AFX_HTCLOSE:
				{
					BOOL bCanClose = TRUE;
					CFrameWnd* pWndMain = AFXGetTopLevelFrame(this);
					if (pWndMain != NULL)
					{
						CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pWndMain);
						if (pMainFrame != NULL)
						{
							bCanClose = pMainFrame->OnCloseDockingPane(this);
						}
						else // Maybe, SDI frame...
						{
							CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, pWndMain);
							if (pFrame != NULL)
							{
								bCanClose = pFrame->OnCloseDockingPane(this);
							}
							else // Maybe, OLE frame...
							{
								COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, pWndMain);
								if (pOleFrame != NULL)
								{
									bCanClose = pOleFrame->OnCloseDockingPane(this);
								}
								else
								{
									COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, pWndMain);
									if (pOleDocFrame != NULL)
									{
										bCanClose = pOleDocFrame->OnCloseDockingPane(this);
									}
								}
							}
						}
					}

					if (bCanClose)
					{
						OnPressCloseButton();
					}
					break;
				}

			case HTMAXBUTTON:
				if (GetAsyncKeyState(VK_CONTROL) && IsAutohideAllEnabled())
				{
					m_pDockSite->SetRedraw(FALSE);
					if (!m_bPinState)
					{
						CObList lstBars;
						pDefaultSlider->GetPanes(lstBars);

						for (POSITION pos = lstBars.GetHeadPosition(); pos != NULL;)
						{
							CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, lstBars.GetNext(pos));
							if (pBar->IsAutohideAllEnabled())
							{
								pBar->SetAutoHideMode(TRUE, pDefaultSlider->GetCurrentAlignment(), NULL, FALSE);
							}
						}
					}
					else
					{
						CAutoHideDockSite* pParentDockBar = DYNAMIC_DOWNCAST(CAutoHideDockSite, m_pAutoHideBar->GetParentDockSite());

						if (pParentDockBar != NULL)
						{
							pParentDockBar->UnSetAutoHideMode(NULL);
						}
					}

					m_pDockSite->SetRedraw(TRUE);

					CFrameWnd* pFrame = DYNAMIC_DOWNCAST(CFrameWnd, m_pDockSite);
					if (pFrame != NULL)
					{
						pFrame->RecalcLayout();
					}

					m_pDockSite->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);
				}
				else
				{
					if (pDockManager != NULL && pDefaultSlider != NULL &&
						(pDefaultSlider->GetCurrentAlignment() & pDockManager->GetEnabledAutoHideAlignment()))
					{
						SetAutoHideMode(!m_bPinState, pDefaultSlider->GetCurrentAlignment());
					}
				}
				return;

			case HTMINBUTTON:
				if (CDockingManager::IsDockSiteMenu())
				{
					CMFCCaptionButton* pMenuButton = FindButtonByHit(HTMINBUTTON);
					if (pMenuButton == NULL)
					{
						ASSERT(FALSE);
						return;
					}

					CRect rectButton = pMenuButton->GetRect();

					CRect rcBar;
					GetWindowRect(rcBar);
					ScreenToClient(rcBar);

					rectButton.OffsetRect(rcBar.TopLeft());

					ClientToScreen(&rectButton);

					pMenuButton->m_bDroppedDown = TRUE;

					CPoint ptMenu(rectButton.left, rectButton.bottom + 1);

					if (GetExStyle() & WS_EX_LAYOUTRTL)
					{
						ptMenu.x += rectButton.Width();
					}

					HWND hwndThis = GetSafeHwnd();

					OnShowControlBarMenu(ptMenu);

					if (::IsWindow(hwndThis))
					{
						pMenuButton->m_bDroppedDown = FALSE;
						RedrawButton(pMenuButton);
					}
				}
				return;

			default:
				OnPressButtons(nHit);
			}
		}

		CWnd::OnLButtonUp(nFlags, point);
		return;
	}

	CPane::OnLButtonUp(nFlags, point);
}

void CDockablePane::OnPressCloseButton()
{
	CFrameWnd* pParentFrame = DYNAMIC_DOWNCAST(CFrameWnd, AFXGetParentFrame(this));
	ASSERT_VALID(pParentFrame);

	if (pParentFrame != NULL)
	{
		if (pParentFrame->SendMessage(AFX_WM_ON_PRESS_CLOSE_BUTTON, NULL, (LPARAM)(LPVOID) this))
		{
			return;
		}
	}

	if (IsAutoHideMode())
	{
		SetAutoHideMode(FALSE, GetCurrentAlignment());
	}
	ShowPane(FALSE, FALSE, FALSE);
	AdjustDockingLayout();
}

void CDockablePane::EnterDragMode(BOOL bChangeHotPoint)
{
	m_bPrepareToFloat = true;
	CPane::EnterDragMode(bChangeHotPoint);
}

CMFCAutoHideBar* CDockablePane::SetAutoHideMode(BOOL bMode, DWORD dwAlignment, CMFCAutoHideBar* pCurrAutoHideBar, BOOL bUseTimer)
{
	ASSERT_VALID(this);
	ASSERT(dwAlignment & CBRS_ALIGN_ANY);

	if (bMode == IsAutoHideMode())
	{
		return pCurrAutoHideBar;
	}

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
	ASSERT_VALID(pDockManager);

	if (bMode)
	{
		m_bPinState = TRUE;

		CRect rectBeforeUndock;
		GetWindowRect(rectBeforeUndock);
		GetDockSiteFrameWnd()->ScreenToClient(rectBeforeUndock);

		StoreRecentDockSiteInfo();

		// set autohide mode
		UndockPane(FALSE);

		CPaneDivider* pDefaultSlider = GetDefaultPaneDivider();
		ENSURE(pDefaultSlider == NULL);
		pDefaultSlider = CreateDefaultPaneDivider(dwAlignment, GetDockSiteFrameWnd());

		if (pDefaultSlider == NULL)
		{
			TRACE0("Failed to create default slider\n");
			DockPane(this, NULL, DM_DBL_CLICK);
			return NULL;
		}

		m_hDefaultSlider = pDefaultSlider->m_hWnd;

		pDefaultSlider->SetAutoHideMode(TRUE);
		pDefaultSlider->AddPane(this);

		SetPaneAlignment(dwAlignment);
		pDefaultSlider->SetPaneAlignment(dwAlignment);

		pCurrAutoHideBar = pDockManager->AutoHidePane(this, pCurrAutoHideBar);

		if (IsPaneVisible())
		{
			pDefaultSlider->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
			RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);

			GetDockSiteFrameWnd()->RedrawWindow(rectBeforeUndock,  NULL, RDW_INVALIDATE | RDW_UPDATENOW |  RDW_ALLCHILDREN);
		}
		else
		{
			ShowWindow(SW_SHOW);
		}

		if (bUseTimer)
		{
			m_nAutoHideConditionTimerID = SetTimer(AFX_ID_CHECK_AUTO_HIDE_CONDITION, m_nTimeOutBeforeAutoHide, NULL);
			Slide(FALSE, TRUE);
			GetDockSiteFrameWnd()->SetFocus();
		}
		else
		{
			Slide(FALSE, FALSE);
		}

		SetWindowPos(NULL, -1, -1, -1, -1, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW | SWP_FRAMECHANGED);
	}
	else if (m_pAutoHideBar != NULL)
	{
		CAutoHideDockSite* pParentDockBar = DYNAMIC_DOWNCAST(CAutoHideDockSite, m_pAutoHideBar->GetParentDockSite());

		if (pParentDockBar != NULL)
		{
			pParentDockBar->UnSetAutoHideMode(m_pAutoHideBar);
		}
	}

	return pCurrAutoHideBar;
}

void CDockablePane::UnSetAutoHideMode(CDockablePane* pFirstBarInGroup)
{
	m_bPinState = FALSE;

	if (m_nAutoHideConditionTimerID != 0)
	{
		KillTimer(m_nAutoHideConditionTimerID);
	}

	if (m_nSlideTimer != 0)
	{
		KillTimer(m_nSlideTimer);
	}

	BOOL bWasActive = m_pAutoHideBar->m_bActiveInGroup;

	m_pAutoHideBar->RemoveAutoHideWindow(this);

	RemoveFromDefaultPaneDividier();
	// unset autohide mode - make it docked back
	if (pFirstBarInGroup == NULL)
	{
		if (!DockPane(this, NULL, DM_DBL_CLICK))
		{
			return;
		}
	}
	else
	{
		AttachToTabWnd(pFirstBarInGroup, DM_SHOW, bWasActive);
	}
	ShowPane(TRUE, FALSE, bWasActive);
	AdjustDockingLayout();
}

void CDockablePane::OnTimer(UINT_PTR nIDEvent)
{
	BOOL bSlideDirection = FALSE;

	switch (nIDEvent)
	{
	case AFX_ID_CHECK_AUTO_HIDE_CONDITION:
		if (CheckAutoHideCondition())
		{
			KillTimer(m_nAutoHideConditionTimerID);
			m_nAutoHideConditionTimerID = 0;
		}
		return;

	case AFX_AUTO_HIDE_SLIDE_OUT_EVENT:
		bSlideDirection = TRUE;
		m_bIsHiding = FALSE;
		break;

	case AFX_AUTO_HIDE_SLIDE_IN_EVENT:
		bSlideDirection = FALSE;
		m_bIsHiding = TRUE;
		break;

	default:
		CPane::OnTimer(nIDEvent);
		return;
	}

	OnSlide(bSlideDirection);

	if (CheckStopSlideCondition(bSlideDirection))
	{
		KillTimer(m_nSlideTimer);

		m_bIsSliding = FALSE;
		m_nSlideTimer = 0;
		m_nSlideStep = 0;

		if (bSlideDirection) // slide out - show
		{

			RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);

			::RedrawWindow(m_hDefaultSlider, NULL, NULL, RDW_INVALIDATE);
			// one second time out to give the user ability to move the mouse over
			// miniframe
			if (m_nAutoHideConditionTimerID != 0)
			{
				KillTimer(m_nAutoHideConditionTimerID);
			}

			m_nAutoHideConditionTimerID = SetTimer(AFX_ID_CHECK_AUTO_HIDE_CONDITION, m_nTimeOutBeforeAutoHide, NULL);
		}
		else
		{
			ShowWindow(SW_HIDE);
			CPaneDivider* pDefaultSlider = GetDefaultPaneDivider();
			ASSERT_VALID(pDefaultSlider);
			pDefaultSlider->ShowWindow(SW_HIDE);
		}
	}

	CPane::OnTimer(nIDEvent);
}

// Returns TRUE when the dock bar should be hidden(strats slide in)

BOOL CDockablePane::CheckAutoHideCondition()
{
	if (m_bActive || m_bIsResizing || !IsAutoHideMode() || CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return FALSE;
	}

	if (m_pToolTip->GetSafeHwnd() != NULL && m_pToolTip->IsWindowVisible())
	{
		return FALSE;
	}

	ASSERT_VALID(m_pAutoHideButton);
	ASSERT_VALID(m_pAutoHideBar);

	CRect rectAutoHideBtn = m_pAutoHideButton->GetRect();
	m_pAutoHideBar->ClientToScreen(&rectAutoHideBtn);

	CPoint ptCursor;
	GetCursorPos(&ptCursor);

	CWnd* pWndFromPoint = WindowFromPoint(ptCursor);
	BOOL bCursorOverThisWindow = FALSE; // and this is topmost window
	while (pWndFromPoint != NULL)
	{
		if (pWndFromPoint == this || pWndFromPoint->m_hWnd == m_hDefaultSlider || pWndFromPoint->IsKindOf(RUNTIME_CLASS(CMFCPropertyGridToolTipCtrl)))
		{
			bCursorOverThisWindow = TRUE;
			break;
		}
		pWndFromPoint = pWndFromPoint->GetParent();
	}

	CRect rectWnd;
	GetWindowRect(rectWnd);
	CRect rectSlider;
	::GetWindowRect(m_hDefaultSlider, &rectSlider);

	rectWnd.UnionRect(rectWnd, rectSlider);

	if (rectWnd.PtInRect(ptCursor) ||  bCursorOverThisWindow || rectAutoHideBtn.PtInRect(ptCursor))
	{
		return FALSE;
	}

	Slide(FALSE);

	return TRUE;
}

BOOL CDockablePane::CheckStopSlideCondition(BOOL bDirection)
{
	if (!IsAutoHideMode())
	{
		return TRUE;
	}

	CRect rectWnd;
	GetWindowRect(rectWnd);

	GetDockSiteFrameWnd()->ScreenToClient(rectWnd);
	BOOL bIsRTL = GetDockSiteFrameWnd()->GetExStyle() & WS_EX_LAYOUTRTL;

	CRect rectAutoHideDockBar;
	m_pAutoHideBar->GetParentDockSite()->GetWindowRect(rectAutoHideDockBar);
	GetDockSiteFrameWnd()->ScreenToClient(rectAutoHideDockBar);

	BOOL bStop = FALSE;
	switch (GetCurrentAlignment())
	{

	case CBRS_ALIGN_RIGHT:
		if (m_ahSlideMode == AFX_AHSM_MOVE)
		{
			if (bIsRTL)
			{
				bStop = bDirection ? rectWnd.left >= rectAutoHideDockBar.right : rectWnd.right <= rectAutoHideDockBar.right;
			}
			else
			{
				bStop = bDirection ? rectWnd.right <= rectAutoHideDockBar.left : rectWnd.left >= rectAutoHideDockBar.left;
			}
		}
		else
		{
			bStop = bDirection ? rectWnd.Width() >= m_rectRestored.Width() : rectWnd.Width() <= 0;
		}
		break;

	case CBRS_ALIGN_LEFT:
		if (m_ahSlideMode == AFX_AHSM_MOVE)
		{
			if (bIsRTL)
			{
				bStop = bDirection ? rectWnd.right <= rectAutoHideDockBar.left : rectWnd.left >= rectAutoHideDockBar.left;
			}
			else
			{
				bStop = bDirection ? rectWnd.left >= rectAutoHideDockBar.right : rectWnd.right <= rectAutoHideDockBar.right;
			}
		}
		else
		{
			bStop = bDirection ? rectWnd.Width() >= m_rectRestored.Width() : rectWnd.Width() <= 0;
		}
		break;

	case CBRS_ALIGN_TOP:
		if (m_ahSlideMode == AFX_AHSM_MOVE)
		{
			bStop = bDirection ? rectWnd.top >= rectAutoHideDockBar.bottom : rectWnd.bottom <= rectAutoHideDockBar.bottom;
		}
		else
		{
		}
		break;

	case CBRS_ALIGN_BOTTOM:
		if (m_ahSlideMode == AFX_AHSM_MOVE)
		{
			bStop = bDirection ? rectWnd.bottom <= rectAutoHideDockBar.top : rectWnd.top >= rectAutoHideDockBar.top;
		}
		else
		{
			bStop = bDirection ? rectWnd.Height() >= m_rectRestored.Height() : rectWnd.Height() <= 0;
		}
		break;
	}

	return bStop;
}

void CDockablePane::OnSlide(BOOL bSlideDirection)
{
	if (!IsAutoHideMode() && !IsWindow(m_hDefaultSlider))
	{
		return;
	}

	BOOL bIsRTL = GetDockSiteFrameWnd()->GetExStyle() & WS_EX_LAYOUTRTL;

	m_nSlideStep++;

	CRect rect;
	GetWindowRect(&rect);
	GetDockSiteFrameWnd()->ScreenToClient(&rect);

	CRect rectSlider;
	::GetWindowRect(m_hDefaultSlider, &rectSlider);
	GetDockSiteFrameWnd()->ScreenToClient(&rectSlider);

	if (m_ahSlideMode == AFX_AHSM_MOVE)
	{
		OffsetRectForSliding(rect, bSlideDirection, bIsRTL);
		OffsetRectForSliding(rectSlider, bSlideDirection, bIsRTL);
		if (bSlideDirection)
		{
			CPoint pt = CalcCorrectOffset(rect, bIsRTL);
			rect.OffsetRect(pt);
			rectSlider.OffsetRect(pt);
		}
	}
	else
	{
		CalcRectForSliding(rect, rectSlider, bSlideDirection);
	}

	SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
	::SetWindowPos(m_hDefaultSlider, NULL, rectSlider.left, rectSlider.top, rectSlider.Width(), rectSlider.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
}

void CDockablePane::OffsetRectForSliding(CRect& rect, BOOL bSlideDirection, BOOL bIsRTL)
{
	if (!IsAutoHideMode())
	{
		return;
	}

	switch (GetCurrentAlignment())
	{
	case CBRS_ALIGN_LEFT:
		if (bIsRTL)
		{
			bSlideDirection ? rect.OffsetRect(-m_nSlideDelta, 0) : rect.OffsetRect(m_nSlideDelta, 0);
		}
		else
		{
			bSlideDirection ? rect.OffsetRect(m_nSlideDelta, 0) : rect.OffsetRect(-m_nSlideDelta, 0);
		}
		break;

	case CBRS_ALIGN_RIGHT:
		if (bIsRTL)
		{
			bSlideDirection  ? rect.OffsetRect(m_nSlideDelta, 0) : rect.OffsetRect(-m_nSlideDelta, 0);
		}
		else
		{
			bSlideDirection  ? rect.OffsetRect(-m_nSlideDelta, 0) : rect.OffsetRect(m_nSlideDelta, 0);
		}
		break;

	case CBRS_ALIGN_TOP:
		bSlideDirection ? rect.OffsetRect(0, m_nSlideDelta) : rect.OffsetRect(0, -m_nSlideDelta);
		break;

	case CBRS_ALIGN_BOTTOM:
		bSlideDirection ? rect.OffsetRect(0, -m_nSlideDelta) : rect.OffsetRect(0, m_nSlideDelta);
		break;
	}
}

void CDockablePane::CalcRectForSliding(CRect& rect, CRect& rectSlider, BOOL bSlideDirection)
{
	if (!IsAutoHideMode())
	{
		return;
	}

	switch (GetCurrentAlignment())
	{
	case CBRS_ALIGN_LEFT:
		if (bSlideDirection)
		{
			rect.right += m_nSlideDelta;
			if (rect.Width() > m_rectRestored.Width())
			{
				rect.right = rect.left + m_rectRestored.Width();
			}
		}
		else
		{
			rect.right -= m_nSlideDelta;
			if (rect.right < rect.left)
			{
				rect.right = rect.left;
			}
		}
		{
			int nSliderWidth = rectSlider.Width();
			rectSlider.left = rect.right;
			rectSlider.right = rectSlider.left + nSliderWidth;
		}
		break;

	case CBRS_ALIGN_RIGHT:
		if (bSlideDirection)
		{
			rect.left -= m_nSlideDelta;
			if (rect.Width() > m_rectRestored.Width())
			{
				rect.left = rect.right - m_rectRestored.Width();
			}
		}
		else
		{
			rect.left += m_nSlideDelta;
			if (rect.left > rect.right)
			{
				rect.left = rect.right;
			}
		}
		{
			int nSliderWidth = rectSlider.Width();
			rectSlider.right = rect.left;
			rectSlider.left = rectSlider.right - nSliderWidth;
		}
		break;

	case CBRS_ALIGN_TOP:
		if (bSlideDirection)
		{
			rect.bottom += m_nSlideDelta;
			if (rect.Height() > m_rectRestored.Height())
			{
				rect.bottom = rect.top + m_rectRestored.Height();
			}
		}
		else
		{
			rect.bottom -= m_nSlideDelta;
			if (rect.bottom < rect.top)
			{
				rect.bottom = rect.top;
			}
		}
		{
			int nSliderHeight = rectSlider.Height();
			rectSlider.top = rect.bottom;
			rectSlider.bottom = rectSlider.top + nSliderHeight;
		}
		break;

	case CBRS_ALIGN_BOTTOM:
		if (bSlideDirection)
		{
			rect.top -= m_nSlideDelta;
			if (rect.Height() > m_rectRestored.Height())
			{
				rect.top = rect.bottom - m_rectRestored.Height();
			}
		}
		else
		{
			rect.top += m_nSlideDelta;
			if (rect.top > rect.bottom)
			{
				rect.top = rect.bottom;
			}
		}
		{
			int nSliderHeight = rectSlider.Height();
			rectSlider.bottom = rect.top;
			rectSlider.top = rectSlider.bottom - nSliderHeight;
		}
		break;
	}
}

CPoint CDockablePane::CalcCorrectOffset(CRect rect, BOOL bIsRTL)
{
	CRect rectAutoHideDockBar;
	m_pAutoHideBar->GetParentDockSite()->GetWindowRect(rectAutoHideDockBar);
	GetDockSiteFrameWnd()->ScreenToClient(rectAutoHideDockBar);

	switch (GetCurrentAlignment())
	{
	case CBRS_ALIGN_LEFT:
		if (bIsRTL)
		{
			if (rect.right < rectAutoHideDockBar.left)
			{
				return CPoint(rectAutoHideDockBar.left - rect.right, 0);
			}
		}
		else
		{
			if (rect.left > rectAutoHideDockBar.right)
			{
				return CPoint(rectAutoHideDockBar.right - rect.left, 0);
			}
		}
		break;

	case CBRS_ALIGN_RIGHT:
		if (bIsRTL)
		{
			if (rect.left > rectAutoHideDockBar.right)
			{
				return CPoint(rectAutoHideDockBar.right - rect.left, 0);
			}
		}
		else
		{
			if (rect.right < rectAutoHideDockBar.left)
			{
				return CPoint(rectAutoHideDockBar.left - rect.right, 0);
			}
		}
		break;

	case CBRS_ALIGN_TOP:
		if (rect.top > rectAutoHideDockBar.bottom)
		{
			return CPoint(0, rectAutoHideDockBar.bottom - rect.top);
		}
		break;

	case CBRS_ALIGN_BOTTOM:
		if (rect.bottom < rectAutoHideDockBar.top)
		{
			return CPoint(0, rectAutoHideDockBar.top - rect.bottom);
		}
		break;
	}

	return CPoint(0, 0);
}

void CDockablePane::Slide(BOOL bSlideOut, BOOL bUseTimer)
{
	ASSERT_VALID(this);

	if (!IsAutoHideMode())
	{
		return;
	}

	if (m_nSlideTimer != 0)
	{
		KillTimer(m_nSlideTimer);
	}

	if (m_nAutoHideConditionTimerID != 0)
	{
		KillTimer(m_nAutoHideConditionTimerID);
		m_nAutoHideConditionTimerID = 0;
	}

	CRect rectWnd;
	GetWindowRect(rectWnd);

	if (!bUseTimer || m_bDisableAnimation || afxGlobalData.bIsRemoteSession)
	{
		m_nSlideDelta = IsHorizontal() ? rectWnd.Height() : rectWnd.Width();
	}

	if (!bUseTimer)
	{
		m_rectRestored = rectWnd;
		// just move out from the screen

		OnSlide(FALSE);
		ShowWindow(SW_HIDE);
		::ShowWindow(m_hDefaultSlider, SW_HIDE);
		return;
	}

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
	ASSERT_VALID(pDockManager);

	if (bSlideOut)
	{
		pDockManager->HideAutoHidePanes(this);
		pDockManager->AlignAutoHidePane(GetDefaultPaneDivider(), FALSE);
		ShowWindow(SW_SHOW);
		::ShowWindow(m_hDefaultSlider, SW_SHOW);
	}

	BringWindowToTop();
	::BringWindowToTop(m_hDefaultSlider);

	if (m_ahSlideMode == AFX_AHSM_MOVE)
	{
		pDockManager->BringBarsToTop();
	}

	m_nSlideTimer = SetTimer(bSlideOut ? AFX_AUTO_HIDE_SLIDE_OUT_EVENT : AFX_AUTO_HIDE_SLIDE_IN_EVENT, m_nSlideDefaultTimeOut, NULL);

	if (!m_bDisableAnimation && !afxGlobalData.bIsRemoteSession)
	{
		if (m_ahSlideMode == AFX_AHSM_MOVE)
		{
			GetDockSiteFrameWnd()->ScreenToClient(rectWnd);
			m_nSlideDelta = max(1, ((GetCurrentAlignment() & CBRS_ORIENT_HORZ) ? rectWnd.Height() : rectWnd.Width()) / m_nSlideSteps);

		}
		else if (m_ahSlideMode == AFX_AHSM_STRETCH)
		{
			if (!bSlideOut && !m_bIsSliding)
			{
				m_rectRestored = rectWnd;
				GetDockSiteFrameWnd()->ScreenToClient(m_rectRestored);
			}
			m_nSlideDelta = max(1, ((GetCurrentAlignment() & CBRS_ORIENT_HORZ) ? m_rectRestored.Height() : m_rectRestored.Width()) / m_nSlideSteps);
		}
	}

	m_nSlideStep = 0;
	m_bIsSliding = TRUE;
}

void CDockablePane::SetAutoHideParents(CMFCAutoHideBar* pToolBar, CMFCAutoHideButton* pBtn)
{
	ASSERT_VALID(pToolBar);
	ASSERT_VALID(pBtn);

	m_pAutoHideBar = pToolBar;
	m_pAutoHideButton = pBtn;
}

void CDockablePane::SetResizeMode(BOOL bResize)
{
	m_bIsResizing = bResize;
}

CPaneDivider* __stdcall CDockablePane::CreateDefaultPaneDivider(DWORD dwAlignment, CWnd* pParent, CRuntimeClass* pSliderRTC)
{
	CRect rectSlider(0, 0, CPaneDivider::GetDefaultWidth(), CPaneDivider::GetDefaultWidth());
	WORD dwSliderStyle = CPaneDivider::SS_HORZ;

	if (dwAlignment & CBRS_ALIGN_LEFT || dwAlignment & CBRS_ALIGN_RIGHT)
	{
		dwSliderStyle = CPaneDivider::SS_VERT;
	}

	// create a slider with a control bar container
	CPaneDivider* pSlider = NULL;
	if (pSliderRTC != NULL)
	{
		pSlider = DYNAMIC_DOWNCAST(CPaneDivider, pSliderRTC->CreateObject());
		ASSERT_VALID(pSlider);

		pSlider->SetDefaultMode(TRUE);
	}
	else
	{
		pSlider = DYNAMIC_DOWNCAST(CPaneDivider, CPaneDivider::m_pSliderRTC->CreateObject());
		ASSERT_VALID(pSlider);

		pSlider->Init(TRUE);
	}

	if (!pSlider->CreateEx(0, dwSliderStyle | WS_VISIBLE, rectSlider, pParent, (UINT) -1, NULL))
	{
		TRACE0("Can't create default slider while docking\n");
		delete pSlider;
		return NULL;
	}

	pSlider->SetPaneAlignment(dwAlignment);

	return pSlider;
}

void CDockablePane::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CPoint ptScreen = point;
	ClientToScreen(&ptScreen);

	CMFCCaptionButton* pBtn = FindButton(ptScreen);
	if (pBtn != NULL)
	{
		CWnd::OnLButtonDblClk(nFlags, point);
		return;
	}

	if (!IsAutoHideMode())
	{
		CDockablePane* pBarToDock = this;
		if (IsTabbed())
		{
			CMFCBaseTabCtrl* pTabWnd = DYNAMIC_DOWNCAST(CMFCBaseTabCtrl, GetParent());
			if (pTabWnd != NULL)
			{
				pBarToDock = DYNAMIC_DOWNCAST(CDockablePane, pTabWnd->GetParent());
			}
		}

		CMultiPaneFrameWnd* pParentMiniFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, GetParentMiniFrame());

		if (pParentMiniFrame != NULL)
		{
			OnProcessDblClk();
			pParentMiniFrame->DockRecentPaneToMainFrame(pBarToDock);
		}
		else if (IsWindow(m_hDefaultSlider))
		{
			// currently docked at main frame
			CMultiPaneFrameWnd* pRecentMiniFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, CWnd::FromHandlePermanent(m_recentDockInfo.m_hRecentMiniFrame));

			if (pRecentMiniFrame != NULL &&
				(m_recentDockInfo.GetRecentPaneContainer(FALSE) != NULL || m_recentDockInfo.GetRecentTabContainer(FALSE) != NULL))
			{
				OnBeforeFloat(m_recentDockInfo.m_rectRecentFloatingRect, DM_DBL_CLICK);

				OnProcessDblClk();
				UndockPane();

				HWND hwndThis = GetSafeHwnd();
				BOOL bCanFocus = CanFocus();

				pRecentMiniFrame->AddRecentPane(pBarToDock);

				if (IsWindow(hwndThis))
				{
					OnAfterFloat();
				}

				if (bCanFocus)
				{
					pRecentMiniFrame->SetFocus();
				}
			}
			else
			{
				CPane::OnLButtonDblClk(nFlags, point);
			}
		}
		else
		{
			OnProcessDblClk();
		}
	}
	else
	{
		CWnd::OnLButtonDblClk(nFlags, point);
	}
}

BOOL CDockablePane::OnBeforeFloat(CRect& rectFloat, AFX_DOCK_METHOD dockMethod)
{
	ASSERT_VALID(this);
	BOOL bResult = CPane::OnBeforeFloat(rectFloat, dockMethod);

	if (dockMethod == DM_MOUSE)
	{
		// prevent drawing of the drag rectangle on mouse up
		m_bPrepareToFloat = false;
	}

	return bResult;
}

void CDockablePane::OnNcLButtonDown(UINT nHitTest, CPoint point)
{
	ASSERT_VALID(this);

	if (!IsDocked())
	{
		CPane::OnNcLButtonDown(nHitTest, point);
	}
}

void CDockablePane::OnClose()
{
	ASSERT_VALID(this);
	DestroyWindow();
}

CDockablePane* CDockablePane::AttachToTabWnd(CDockablePane* pTabControlBarAttachTo,
	AFX_DOCK_METHOD dockMethod, BOOL bSetActive, CDockablePane** ppTabbedControlBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pTabControlBarAttachTo);

	if (ppTabbedControlBar != NULL)
	{
		*ppTabbedControlBar = NULL;
	}

	if (!pTabControlBarAttachTo->CanBeAttached() || !CanBeAttached())
	{
		return NULL; // invalid attempt to attach non-attachable control bar
	}

	// check whether pTabBar is derived from CTabbedPane. If so, we
	// can attach this bar to it immediately. Otherwise, we need to create a
	// new tabbed control bar and replace pTabControlBarAttachTo with it.
	CBaseTabbedPane* pTabbedBarAttachTo = DYNAMIC_DOWNCAST(CBaseTabbedPane, pTabControlBarAttachTo);

	BOOL bBarAttachToIsFloating = (pTabControlBarAttachTo->GetParentMiniFrame() != NULL);

	CWnd* pOldParent = GetParent();
	CRect rectWndTab; rectWndTab.SetRectEmpty();
	if (pTabbedBarAttachTo == NULL)
	{
		CWnd* pTabParent = pTabControlBarAttachTo->GetParent();
		if (DYNAMIC_DOWNCAST(CMFCBaseTabCtrl, pTabParent) != NULL)
		{
			pTabParent = pTabParent->GetParent();
		}

		pTabbedBarAttachTo = DYNAMIC_DOWNCAST(CBaseTabbedPane, pTabParent);

		if (pTabbedBarAttachTo == NULL)
		{
			pTabControlBarAttachTo->StoreRecentDockSiteInfo();

			pTabControlBarAttachTo->GetWindowRect(rectWndTab);
			pTabControlBarAttachTo->GetParent()->ScreenToClient(&rectWndTab);

			pTabbedBarAttachTo = pTabControlBarAttachTo->CreateTabbedPane();
			ASSERT_VALID(pTabbedBarAttachTo);

			pTabControlBarAttachTo->InsertPane(pTabbedBarAttachTo, pTabControlBarAttachTo);

			if (!pTabControlBarAttachTo->ReplacePane(pTabbedBarAttachTo, dockMethod))
			{
				if (!bBarAttachToIsFloating)
				{
					RemovePaneFromDockManager(pTabbedBarAttachTo);
				}
				ASSERT(FALSE);
				TRACE0("Failed to replace resizable control bar by tabbed control bar. \n");
				delete pTabbedBarAttachTo;
				return NULL;
			}

			pTabbedBarAttachTo->EnableDocking(pTabControlBarAttachTo->GetEnabledAlignment());
			pTabbedBarAttachTo->SetPaneAlignment(pTabControlBarAttachTo->GetCurrentAlignment());

			pTabControlBarAttachTo->UndockPane(TRUE);
			pTabbedBarAttachTo->AddTab(pTabControlBarAttachTo, TRUE, bSetActive);
			pTabControlBarAttachTo->EnableGripper(FALSE);
		}
	}

	if (ppTabbedControlBar != NULL)
	{
		*ppTabbedControlBar = pTabbedBarAttachTo;
	}

	EnableGripper(FALSE);

	// send before dock notification without guarantee that the bar will
	// be attached to another dock bar
	OnBeforeDock((CBasePane**)&pTabbedBarAttachTo, NULL, dockMethod);
	// reassign the parentship to the tab bar
	OnBeforeChangeParent(pTabbedBarAttachTo, TRUE);

	// remove from miniframe
	RemoveFromMiniframe(pTabbedBarAttachTo, dockMethod);

	// AddTab returns TRUE only if this pointer is not tabbed control bar
	//(tabbed control bar is destroyed by AddTab and its tab windows are copied
	// to pTabbedBarAttachTo tabbed window)
	BOOL bResult = pTabbedBarAttachTo->AddTab(this, TRUE, bSetActive);
	if (bResult)
	{
		OnAfterChangeParent(pOldParent);
		OnAfterDock(pTabbedBarAttachTo, NULL, dockMethod);
	}

	if (!rectWndTab.IsRectEmpty())
	{
		pTabbedBarAttachTo->SetWindowPos(NULL, rectWndTab.left, rectWndTab.top, rectWndTab.Width(), rectWndTab.Height(), SWP_NOZORDER | SWP_NOACTIVATE);

		if (bResult)
		{
			AdjustDockingLayout();
		}
	}

	pTabbedBarAttachTo->RecalcLayout();

	return bResult ? this : pTabbedBarAttachTo;
}

BOOL CDockablePane::ReplacePane(CDockablePane* pBarToReplaceWith, AFX_DOCK_METHOD /*dockMethod*/, BOOL bRegisterWithFrame)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBarToReplaceWith);

	CPaneFrameWnd* pParentMiniFrame = GetParentMiniFrame();

	if (pParentMiniFrame != NULL)
	{
		// this is tabbed control bar that should be replaced by docking control bar
		// within miniframe

		ASSERT_VALID(pParentMiniFrame);
		pParentMiniFrame->ReplacePane(this, pBarToReplaceWith);
		return TRUE;
	}
	else if (m_hDefaultSlider != NULL)
	{
		CPaneDivider* pDefaultSlider = GetDefaultPaneDivider();

		if (pDefaultSlider != NULL && pDefaultSlider->ReplacePane(this, pBarToReplaceWith))
		{
			// unregister from parent frame/dock manager the bar that is being replaced(this)
			if (bRegisterWithFrame)
			{
				RemovePaneFromDockManager(this, FALSE, FALSE, FALSE, pBarToReplaceWith);
			}
			else
			{
				RemovePaneFromDockManager(this, FALSE);
			}

			return TRUE;
		}
	}
	return FALSE;
}

CTabbedPane* CDockablePane::CreateTabbedPane()
{
	ASSERT_VALID(this);
	CRect rectTabBar;
	GetWindowRect(&rectTabBar);
	ASSERT_VALID(GetParent());
	GetParent()->ScreenToClient(&rectTabBar);

	CTabbedPane* pTabbedBar = (CTabbedPane*) m_pTabbedControlBarRTC->CreateObject();
	ASSERT_VALID(pTabbedBar);

	pTabbedBar->SetAutoDestroy(TRUE);

	if (!pTabbedBar->Create(_T(""), GetParent(), rectTabBar, TRUE, (UINT) -1, GetStyle() | CBRS_FLOAT_MULTI))
	{
		TRACE0("Failed to create tabbed control bar\n");
		return NULL;
	}

	// override recent floating/docking info

	pTabbedBar->m_recentDockInfo.m_recentMiniFrameInfo.m_rectDockedRect = m_recentDockInfo.m_recentMiniFrameInfo.m_rectDockedRect;
	pTabbedBar->m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect = m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect;
	pTabbedBar->m_recentDockInfo.m_rectRecentFloatingRect = m_recentDockInfo.m_rectRecentFloatingRect;

	return pTabbedBar;
}

BOOL CDockablePane::Dock(CBasePane* pTargetBar, LPCRECT lpRect, AFX_DOCK_METHOD dockMethod)
{
	CFrameWnd* pParentFrame = DYNAMIC_DOWNCAST(CFrameWnd, AFXGetParentFrame(this));
	ASSERT_VALID(pParentFrame);

	if (pTargetBar != NULL && !pTargetBar->CanAcceptPane(this) && pTargetBar != this)
	{
		return FALSE;
	}

	if (dockMethod == DM_RECT && lpRect == NULL)
	{
		TRACE0("Docking control bar must be docked by rect or by mouse!");
		ASSERT(FALSE);
		return FALSE;
	}

	m_bPrepareToFloat = false;

	if (dockMethod == DM_DBL_CLICK || dockMethod == DM_SHOW)
	{
		CPaneContainer* pRecentTabContainer = m_recentDockInfo.GetRecentTabContainer(TRUE);

		ShowWindow(SW_HIDE);

		RemoveFromMiniframe(AFXGetParentFrame(this), dockMethod);
		SetPaneAlignment(m_recentDockInfo.m_dwRecentAlignmentToFrame);

		CPaneDivider* pRecentDefaultSlider = m_recentDockInfo.GetRecentDefaultPaneDivider();
		if (pRecentDefaultSlider != NULL)
		{
			SetDefaultPaneDivider(pRecentDefaultSlider->m_hWnd);
		}

		if (pRecentTabContainer != NULL)
		{
			BOOL bRecentLeftBar = m_recentDockInfo.IsRecentLeftPane(TRUE);
			CDockablePane* pTabbedBar = (CDockablePane*)(bRecentLeftBar ? pRecentTabContainer->GetLeftPane() : pRecentTabContainer->GetRightPane());
			if (pTabbedBar != NULL)
			{
				BOOL bResult = (AttachToTabWnd(pTabbedBar, DM_DBL_CLICK) != NULL);
				if (bResult)
				{
					ShowPane(TRUE, FALSE, TRUE);
				}
				AdjustDockingLayout();
				return bResult;
			}
		}

		if (pRecentDefaultSlider != NULL)
		{
			EnableGripper(TRUE);
			/*
			SetWindowPos(NULL, m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect.left, m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect.top, m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect.Width(), m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect.Height(), SWP_NOZORDER | SWP_NOREDRAW);*/

			AdjustPaneToPaneContainer(pRecentDefaultSlider);

			InsertPane(this, pRecentDefaultSlider, FALSE);

			ShowWindow(SW_SHOW);

			CDockablePane* pAddedControlBar = pRecentDefaultSlider->AddRecentPane(this);
			if (pAddedControlBar == this)
			{
				AdjustDockingLayout();
				return TRUE;
			}
			else if (pAddedControlBar != NULL)
			{
				pAddedControlBar->AdjustDockingLayout();
				return FALSE;
			}
		}
		else
		{
			ShowWindow(SW_SHOW);
			return DockToFrameWindow(m_recentDockInfo.m_dwRecentAlignmentToFrame, (lpRect == NULL) ? &m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect : lpRect);
		}
		return FALSE;
	}

	CPoint ptMouse(0, 0);
	if (dockMethod == DM_MOUSE || dockMethod == DM_STANDARD)
	{
		GetCursorPos(&ptMouse);
	}

	DWORD dwAlignment = 0;
	if (pTargetBar == NULL)
	{
		// insert the resizable bar as first resizable if it crosses the outer edge
		// IsPointNearDockSite will return this information
		BOOL bOuterEdge = FALSE;

		if (dockMethod == DM_MOUSE  || dockMethod == DM_STANDARD)
		{
			CPoint ptMouseCur;
			GetCursorPos(&ptMouseCur);
			if (!IsPointNearDockSite(ptMouseCur, dwAlignment, bOuterEdge))
			{
				return FALSE;
			}
			return DockToFrameWindow(dwAlignment, NULL, DT_DOCK_LAST, NULL, -1, bOuterEdge);
		}
		else if (lpRect != NULL)
		{
		}
	}
	else
	{
		ASSERT_VALID(pTargetBar);

		if (dockMethod == DM_MOUSE || dockMethod == DM_STANDARD)
		{
			if (!afxGlobalUtils.CheckAlignment(ptMouse, pTargetBar, CDockingManager::m_nDockSensitivity, NULL, FALSE, dwAlignment))
			{
				return FALSE;
			}

			return DockToWindow((CDockablePane*) pTargetBar, dwAlignment, NULL);
		}
		else if (lpRect != NULL)
		{
			return DockToWindow((CDockablePane*) pTargetBar, 0, lpRect);
		}
	}

	return FALSE;
}

BOOL CDockablePane::DockToFrameWindow(DWORD dwAlignment, LPCRECT lpRect, DWORD /*dwDockFlags*/, CBasePane* /*pRelativeBar*/, int /*nRelativeIndex*/, BOOL bOuterEdge)
{
	ASSERT_VALID(this);
	ASSERT(dwAlignment & CBRS_ALIGN_ANY);

	LockWindowUpdate();

	RemoveFromMiniframe(AFXGetParentFrame(this), DM_UNKNOWN);

	if (m_hDefaultSlider != NULL && IsWindow(m_hDefaultSlider))
	{
		UndockPane(FALSE);
	}

	CPaneDivider* pDefaultSlider = NULL;
	// create a slider with a control bar container
	if ((pDefaultSlider = CreateDefaultPaneDivider(dwAlignment, GetDockSiteFrameWnd())) == NULL)
	{
		TRACE0("Failde to create default slider");
		ShowWindow(SW_SHOW);
		return FALSE;
	}

	m_hDefaultSlider = pDefaultSlider->m_hWnd;

	CRect rectBar;
	GetWindowRect(rectBar);

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
	ASSERT_VALID(pDockManager);

	CSize minSize;
	GetMinSize(minSize);
	BOOL bSetMinSize = FALSE;
	if (rectBar.Width() < minSize.cx)
	{
		rectBar.right = rectBar.left + minSize.cx;
		bSetMinSize = TRUE;
	}
	if (rectBar.Height() < minSize.cy)
	{
		rectBar.bottom = rectBar.top + minSize.cy;
		bSetMinSize = TRUE;
	}

	if (pDockManager->AdjustRectToClientArea(rectBar, dwAlignment) || bSetMinSize)
	{
		SetWindowPos(NULL, 0, 0, rectBar.Width(), rectBar.Height(), SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
	}

	pDefaultSlider->AddPane(this);

	// register this docking bar and slider with the frame's window dock manager
	if (!bOuterEdge)
	{
		AddPane(this);
		AddPane(pDefaultSlider);
	}
	else
	{
		pDockManager->AddPane(pDefaultSlider, !bOuterEdge, FALSE, bOuterEdge);
		pDockManager->AddPane(this, !bOuterEdge, FALSE, bOuterEdge);
	}

	SetPaneAlignment(dwAlignment);
	pDefaultSlider->SetPaneAlignment(GetCurrentAlignment());
	m_recentDockInfo.m_dwRecentAlignmentToFrame = GetCurrentAlignment();

	EnableGripper(TRUE);

	if (lpRect != NULL)
	{
		CRect rect(lpRect);
		SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(), SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
	}

	UnlockWindowUpdate();
	AdjustDockingLayout();
	OnAfterDock(this, NULL, DM_UNKNOWN);
	return TRUE;
}

BOOL CDockablePane::DockToWindow(CDockablePane* pTargetWindow, DWORD dwAlignment, LPCRECT lpRect)
{

	ASSERT_VALID(this);
	ASSERT_VALID(pTargetWindow);
	ASSERT(dwAlignment & CBRS_ALIGN_ANY || lpRect != NULL);
	ASSERT_KINDOF(CDockablePane, pTargetWindow);

	CPaneDivider* pSlider = pTargetWindow->GetDefaultPaneDivider();

	if (pSlider == NULL)
	{
		ShowWindow(SW_SHOW);
		return FALSE;
	}

	if (m_hDefaultSlider != NULL && IsWindow(m_hDefaultSlider))
	{
		UndockPane(FALSE);
	}

	RemoveFromMiniframe(AFXGetParentFrame(this), DM_UNKNOWN);

	if (pSlider->InsertPane(this, pTargetWindow, dwAlignment, lpRect))
	{
		// the bar was successfully inserted into slider's container. Now, we need
		// to register it with the frame
		InsertPane(this, pTargetWindow, TRUE);
		m_hDefaultSlider = pSlider->m_hWnd;

		EnableGripper(TRUE);
		// force NcCalcSize to recalculate and draw the caption(gripper)
		SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_FRAMECHANGED | SWP_SHOWWINDOW);

		AdjustDockingLayout();
		OnAfterDock(this, NULL, DM_UNKNOWN);
		return TRUE;
	}

	return FALSE;
}

BOOL CDockablePane::DockPaneContainer(CPaneContainerManager& barContainerManager, DWORD dwAlignment, AFX_DOCK_METHOD /*dockMethod*/)
{
	if (m_hDefaultSlider != NULL && IsWindow(m_hDefaultSlider))
	{
		CObList lstControlBars;
		barContainerManager.AddPanesToList(&lstControlBars, NULL);

		for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));

			InsertPane(pBar, this, TRUE);
			pBar->SetDefaultPaneDivider(m_hDefaultSlider);
			pBar->SetPaneAlignment(GetCurrentAlignment());
		}

		CPaneDivider* pDefaultSlider = GetDefaultPaneDivider();
		if (pDefaultSlider != NULL)
		{
			return pDefaultSlider->AddPaneContainer(this, barContainerManager, dwAlignment);
		}
	}

	return FALSE;
}

void CDockablePane::DrawCaption(CDC* pDC, CRect rectCaption)
{
	ASSERT_VALID(pDC);

	CRect rcbtnRight = CRect(rectCaption.BottomRight(), CSize(0, 0));
	int i = 0;

	for (i = (int) m_arrButtons.GetUpperBound(); i >= 0; i --)
	{
		if (!m_arrButtons [i]->m_bLeftAlign && !m_arrButtons [i]->m_bHidden)
		{
			rcbtnRight = m_arrButtons [i]->GetRect();
			break;
		}
	}

	CRect rcbtnLeft = CRect(rectCaption.TopLeft(), CSize(0, 0));
	for (i = (int) m_arrButtons.GetUpperBound(); i >= 0; i --)
	{
		if (m_arrButtons [i]->m_bLeftAlign && !m_arrButtons [i]->m_bHidden)
		{
			rcbtnLeft = m_arrButtons [i]->GetRect();
			break;
		}
	}

	COLORREF clrCptnText = CMFCVisualManager::GetInstance()->OnDrawPaneCaption(pDC, this, m_bActive, rectCaption, rcbtnRight);

	for (i = 0; i < m_arrButtons.GetSize(); i ++)
	{
		CMFCCaptionButton* pbtn = m_arrButtons [i];
		ASSERT_VALID(pbtn);

		pbtn->m_clrForeground = clrCptnText;
	}

	int nOldBkMode = pDC->SetBkMode(TRANSPARENT);
	COLORREF clrOldText = pDC->SetTextColor(clrCptnText);

	CFont* pOldFont = pDC->SelectObject(&afxGlobalData.fontRegular);
	ENSURE(pOldFont != NULL);

	CString strTitle;
	GetWindowText(strTitle);

	rectCaption.right = rcbtnRight.left;
	rectCaption.left = rcbtnLeft.right;
	rectCaption.top++;
	rectCaption.DeflateRect(g_nCaptionHorzMargin * 2, 0);

	pDC->DrawText(strTitle, rectCaption, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);

	pDC->SelectObject(pOldFont);
	pDC->SetBkMode(nOldBkMode);
	pDC->SetTextColor(clrOldText);
}

void CDockablePane::RedrawButton(const CMFCCaptionButton* pButton)
{
	if (pButton == NULL /*|| GetParentMiniFrame(TRUE) != NULL*/)
	{
		return;
	}

	if (!pButton->m_bEnabled)
	{
		return;
	}

	m_rectRedraw = pButton->GetRect();
	SendMessage(WM_NCPAINT);
	m_rectRedraw.SetRectEmpty();

	UpdateWindow();
}

void __stdcall CDockablePane::SetCaptionStyle(BOOL bDrawText, BOOL /*bForceGradient*/, BOOL bHideDisabledButtons)
{
	m_bCaptionText = bDrawText;
	m_bHideDisabledButtons = bHideDisabledButtons;
}

void CDockablePane::AdjustPaneToPaneContainer(CPaneDivider* pSlider)
{
	CRect rectContainer = pSlider->GetRootContainerRect();
	if (!rectContainer.IsRectEmpty())
	{
		CFrameWnd* pFrame = GetParentFrame();
		if (pFrame != NULL)
		{
			ASSERT_VALID(pFrame);
			pFrame->ScreenToClient(rectContainer);
			CRect rectWnd;
			GetWindowRect(rectWnd);
			pFrame->ScreenToClient(rectWnd);

			CRect rectUnion;
			rectUnion.UnionRect(rectWnd, rectContainer);

			if (rectUnion != rectContainer)
			{
				rectWnd.OffsetRect(rectContainer.left - rectWnd.left, rectContainer.top - rectWnd.top);
				if (rectWnd.Width() > rectContainer.Width())
				{
					rectWnd.right = rectWnd.left + rectContainer.Width();
				}
				if (rectWnd.Height() > rectContainer.Height())
				{
					rectWnd.bottom = rectWnd.top + rectContainer.Height();
				}

				SetWindowPos(NULL, rectWnd.left, rectWnd.top, rectContainer.Width(), rectContainer.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
			}
		}
	}
}

void CDockablePane::ShowPane(BOOL bShow, BOOL bDelay, BOOL bActivate)
{
	if (IsAutoHideMode())
	{
		if (IsHideInAutoHideMode())
		{
			if (IsPaneVisible() && !bShow)
			{
				m_pAutoHideButton->ShowAttachedWindow(FALSE);
			}
			m_pAutoHideBar->ShowAutoHideWindow(this, bShow, bDelay);
		}
		else
		{
			m_pAutoHideButton->ShowAttachedWindow(TRUE);
			if (bShow && bActivate)
			{
				SetFocus();
				m_bActive = TRUE;
			}
		}
	}
	else if (IsFloating() || IsTabbed())
	{
		// standard procedure - show/hide bar and its miniframe
		CPane::ShowPane(bShow, bDelay, bActivate);
		CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
		if (pMiniFrame != NULL)
		{
			pMiniFrame->OnShowPane(this, bShow);
		}
		if (IsTabbed() && bDelay)
		{
			GetParentTabbedPane()->RecalcLayout();
		}
	}
	else if (IsMDITabbed())
	{
		CWnd* pParent = GetParent();
		if (bShow)
		{
			ConvertToTabbedDocument();
			ShowWindow(SW_SHOW);
		}
		else
		{
			pParent->SendMessage(WM_CLOSE);
		}
	}
	else
	{
		CPaneDivider* pDefaultSlider = GetDefaultPaneDivider();
		ShowWindow(bShow ? SW_SHOW : SW_HIDE);
		if (bShow && pDefaultSlider != NULL)
		{
			// adjust rect to fit the container, otherwise it will break the size
			// of container;
			AdjustPaneToPaneContainer(pDefaultSlider);
		}

		CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();

		if (pMiniFrame != NULL)
		{
			pMiniFrame->OnShowPane(this, bShow);
		}
		else if (pDefaultSlider != NULL)
		{
			if (bShow)
			{
				int nLastPercent = GetLastPercentInPaneContainer();
				if (nLastPercent >= 50)
				{
					SetLastPercentInPaneContainer(50);
				}
				else
				{
					SetLastPercentInPaneContainer(nLastPercent + 1);
				}
			}

			// docked at main frame - notify to adjust container
			pDefaultSlider->OnShowPane(this, bShow);
			if (!bDelay)
			{
				AdjustDockingLayout();
			}
		}
		else
		{
			// floating with other bars on miniframe  - notify to adjust container
		}
	}

	if (IsTabbed() && bShow && bActivate)
	{
		CMFCBaseTabCtrl* pParentTab = DYNAMIC_DOWNCAST(CMFCBaseTabCtrl, GetParent());
		if (pParentTab == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		ASSERT_VALID(pParentTab);
		pParentTab->SetActiveTab(pParentTab->GetTabFromHwnd(GetSafeHwnd()));
	}
}

void CDockablePane::UndockPane(BOOL bDelay)
{
	CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, GetParentMiniFrame());

	if (pMiniFrame == NULL)
	{
		RemoveFromDefaultPaneDividier();
		// remove from dock site
		RemovePaneFromDockManager(this, FALSE, !bDelay);

		if (!bDelay && !IsFloating())
		{
			AdjustDockingLayout();
		}
	}
	else
	{
		pMiniFrame->RemovePane(this);
	}
}

void CDockablePane::OnDestroy()
{
	RemoveCaptionButtons();

	if (GetParentMiniFrame() != NULL)
	{
		RemoveFromMiniframe(NULL, DM_UNKNOWN);
	}
	else
	{
		UndockPane(TRUE);
	}

	if (IsMDITabbed())
	{
		CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
		pDockManager->RemoveHiddenMDITabbedBar(this);

		CMDIChildWndEx* pWnd = DYNAMIC_DOWNCAST(CMDIChildWndEx, GetParent());
		if (pWnd != NULL)
		{
			pWnd->PostMessage(WM_CLOSE);
		}
	}

	CTooltipManager::DeleteToolTip(m_pToolTip);

	CPane::OnDestroy();
}

void CDockablePane::OnTrackCaptionButtons(CPoint point)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return;
	}

	UINT nHot = m_nHot;

	CMFCCaptionButton* pBtn = FindButton(point);
	if (pBtn != NULL)
	{
		m_nHot = pBtn->GetHit();

		if (m_nHit == HTNOWHERE || m_nHit == m_nHot)
		{
			pBtn->m_bFocused = TRUE;
		}
	}
	else
	{
		m_nHot = HTNOWHERE;
	}

	if (m_nHot != nHot)
	{
		RedrawButton(pBtn);

		CMFCCaptionButton* pBtnOld = FindButtonByHit(nHot);
		if (pBtnOld != NULL)
		{
			pBtnOld->m_bFocused = FALSE;
			RedrawButton(pBtnOld);
		}
	}

	if (m_nHit == HTNOWHERE)
	{
		if (nHot != HTNOWHERE && m_nHot == HTNOWHERE)
		{
			::ReleaseCapture();
			m_bCaptionButtonsCaptured = FALSE;
		}
		else if (nHot == HTNOWHERE && m_nHot != HTNOWHERE)
		{
			SetCapture();
			m_bCaptionButtonsCaptured = TRUE;
		}
	}
}

void CDockablePane::OnNcMouseMove(UINT nHitTest, CPoint point)
{
	if (!m_bPrepareToFloat /*&& GetParentMiniFrame(TRUE) == NULL*/)
	{
		OnTrackCaptionButtons(point);
	}

	CPane::OnNcMouseMove(nHitTest, point);
}

void CDockablePane::StopCaptionButtonsTracking()
{
	if (m_nHit != HTNOWHERE)
	{
		CMFCCaptionButton* pBtn = FindButtonByHit(m_nHit);
		m_nHit = HTNOWHERE;

		ReleaseCapture();
		if (pBtn != NULL)
		{
			pBtn->m_bPushed = FALSE;
			RedrawButton(pBtn);
		}
	}

	if (m_nHot != HTNOWHERE)
	{
		CMFCCaptionButton* pBtn = FindButtonByHit(m_nHot);
		m_nHot = HTNOWHERE;

		ReleaseCapture();
		if (pBtn != NULL)
		{
			pBtn->m_bFocused = FALSE;
			RedrawButton(pBtn);
		}
	}
	m_bCaptionButtonsCaptured = FALSE;
}

void CDockablePane::OnCancelMode()
{
	StopCaptionButtonsTracking();
	if (m_bPrepareToFloat)
	{
		m_bPrepareToFloat = false;
	}
	CPane::OnCancelMode();
}

CMFCCaptionButton* CDockablePane::FindButton(CPoint point) const
{
	ASSERT_VALID(this);

	CRect rcBar;
	GetWindowRect(rcBar);
	ScreenToClient(rcBar);

	for (int i = 0; i < m_arrButtons.GetSize(); i ++)
	{
		CMFCCaptionButton* pbtn = m_arrButtons [i];
		ASSERT_VALID(pbtn);

		CRect rectBtn = pbtn->GetRect();
		rectBtn.OffsetRect(rcBar.TopLeft());

		ClientToScreen(rectBtn);

		if (rectBtn.PtInRect(point))
		{
			return pbtn;
		}
	}

	return NULL;
}

CMFCCaptionButton* CDockablePane::FindButtonByHit(UINT nHit) const
{
	ASSERT_VALID(this);

	for (int i = 0; i < m_arrButtons.GetSize(); i ++)
	{
		CMFCCaptionButton* pbtn = m_arrButtons [i];
		ASSERT_VALID(pbtn);

		if (pbtn->GetHit() == nHit)
		{
			return pbtn;
		}
	}

	return NULL;
}

void CDockablePane::EnableButton(UINT nHit, BOOL bEnable/* = TRUE*/)
{
	ASSERT_VALID(this);

	CMFCCaptionButton* pButton = FindButtonByHit(nHit);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	pButton->m_bEnabled = bEnable;
}

BOOL CDockablePane::IsButtonEnabled(UINT nHit) const
{
	ASSERT_VALID(this);

	CMFCCaptionButton* pButton = FindButtonByHit(nHit);
	if (pButton == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return pButton->m_bEnabled;
}

void CDockablePane::OnUpdateCmdUI(class CFrameWnd *pTarget, int bDisableIfNoHndler)
{
	UpdateDialogControls(pTarget, bDisableIfNoHndler);

	CWnd* pFocus = GetFocus();
	BOOL bActiveOld = m_bActive;

	m_bActive = (pFocus->GetSafeHwnd() != NULL && (IsChild(pFocus) || pFocus->GetSafeHwnd() == GetSafeHwnd()));

	if (m_bActive != bActiveOld)
	{
		SendMessage(WM_NCPAINT);
	}
}

BOOL CDockablePane::IsVisible() const
{
	if (IsAutoHideMode())
	{
		if (!IsHideInAutoHideMode())
		{
			return FALSE;
		}
		return m_pAutoHideBar->IsVisible();
	}
	return CPane::IsVisible();
}

BOOL CDockablePane::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_NCLBUTTONDOWN:
	case WM_NCRBUTTONDOWN:
	case WM_NCMBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONUP:
	case WM_MOUSEMOVE:
		if (m_pToolTip->GetSafeHwnd() != NULL)
		{
			m_pToolTip->RelayEvent(pMsg);
		}
		break;
	}

	if (pMsg->message == WM_KEYDOWN &&(GetDockingMode() & DT_STANDARD) != 0 && m_bPrepareToFloat && pMsg->wParam == VK_ESCAPE)
	{
		if (m_bPrepareToFloat)
		{
			PostMessage(WM_CANCELMODE);
			return TRUE;
		}
		else if (IsFloating())
		{
			CPaneFrameWnd* pParentWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, GetParent());
			if (pParentWnd != NULL && GetCapture() == pParentWnd)
			{
				pParentWnd->PostMessage(WM_CANCELMODE);
				return TRUE;
			}
		}
	}

	if (pMsg->message == WM_KEYDOWN && IsTabbed() && pMsg->wParam == VK_ESCAPE)
	{
		CBaseTabbedPane* pParentBar = GetParentTabbedPane();
		CPaneFrameWnd* pParentMiniFrame = pParentBar->GetParentMiniFrame();
		if (pParentBar != NULL && (pParentBar->IsTracked() || pParentMiniFrame != NULL && pParentMiniFrame->IsCaptured()))

		{
			if (pParentMiniFrame != NULL)
			{
				pParentMiniFrame->PostMessage(WM_CANCELMODE);
			}
			else
			{
				pParentBar->PostMessage(WM_CANCELMODE);
			}
			return TRUE;
		}
	}

	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE &&
		(GetDockingMode() & DT_SMART) != 0)
	{
		CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetParent());
		if (pDockManager != NULL)
		{
			CSmartDockingManager* pSDManager = pDockManager->GetSmartDockingManagerPermanent();
			if (pSDManager != NULL && pSDManager->IsStarted())
			{
				CPaneFrameWnd* pParentWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, GetParent());
				if (pParentWnd != NULL && GetCapture() == pParentWnd)
				{
					pParentWnd->PostMessage(WM_CANCELMODE);
					return TRUE;
				}
			}
		}
	}

	return CPane::PreTranslateMessage(pMsg);
}

void CDockablePane::SetDefaultPaneDivider(HWND hSliderWnd)
{
	if (m_hDefaultSlider != hSliderWnd)
	{
		CPaneDivider* pDefaultSlider = GetDefaultPaneDivider();
		if (pDefaultSlider != NULL)
		{
			pDefaultSlider->RemovePane(this);
		}
	}
	m_hDefaultSlider = hSliderWnd;
}

BOOL CDockablePane::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	return CPane::LoadState(lpszProfileName, nIndex, uiID);
}

BOOL CDockablePane::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	return CPane::SaveState(lpszProfileName, nIndex, uiID);
}

void CDockablePane::Serialize(CArchive& ar)
{
	CPane::Serialize(ar);
	if (ar.IsLoading())
	{
		ar >> m_recentDockInfo.m_rectRecentFloatingRect;
		ar >> m_rectSavedDockedRect;
		m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect = m_rectSavedDockedRect;
		ar >> m_bRecentFloatingState;
	}
	else
	{
		BOOL bFloating = IsFloating();

		if (bFloating)
		{
			CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
			if (pMiniFrame != NULL)
			{
				pMiniFrame->GetWindowRect(m_recentDockInfo.m_rectRecentFloatingRect);
			}
		}
		else
		{
			CalcRecentDockedRect();
		}

		ar << m_recentDockInfo.m_rectRecentFloatingRect;
		ar << m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect;
		ar << m_bRecentFloatingState;
	}
}

void CDockablePane::GetRecentSiblingPaneInfo(CList<UINT, UINT&>& /*lstBarIDs*/)
{
}

LRESULT CDockablePane::OnSetText(WPARAM, LPARAM lParam)
{
	LRESULT lRes = Default();

	if (!lRes)
	{
		return lRes;
	}

	CPaneFrameWnd* pParentMiniFrame = NULL;

	if (IsTabbed())
	{
		// If we are docked on a tabbed control bar, we have to update the tab label
		CMFCBaseTabCtrl* pParentTabWnd = DYNAMIC_DOWNCAST(CMFCBaseTabCtrl, GetParent());

		ASSERT_VALID(pParentTabWnd);

		CWnd* pWndTabbedControlBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pParentTabWnd->GetParent());

		if (pWndTabbedControlBar != NULL)
		{
			LPCTSTR lpcszTitle = reinterpret_cast<LPCTSTR>(lParam);
			int iTab = pParentTabWnd->GetTabFromHwnd(GetSafeHwnd());
			CString strLabel;
			if (iTab >= 0 && iTab < pParentTabWnd->GetTabsNum())
			{
				VERIFY(pParentTabWnd->GetTabLabel(iTab, strLabel));
				if (strLabel != lpcszTitle)
				{
					VERIFY(pParentTabWnd->SetTabLabel(iTab, lpcszTitle));
				}
			}
		}
	}
	else if ((pParentMiniFrame = GetParentMiniFrame()) != NULL)
	{
		pParentMiniFrame->SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
	}
	else if (IsAutoHideMode())
	{
		ASSERT_VALID(m_pAutoHideBar);
		m_pAutoHideBar->RedrawWindow();
		SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
		AdjustDockingLayout();
	}
	else
	{
		SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
	}

	return lRes;
}

CPane* CDockablePane::DockPaneStandard(BOOL& bWasDocked)
{
	CBasePane* pTargetBar = NULL;
	int nSensitivity = ((GetDockingMode() & DT_SMART) != 0) ? -1 : CDockingManager::m_nDockSensitivity;

	AFX_CS_STATUS status = IsChangeState(nSensitivity, &pTargetBar);

	CDockablePane* pTargetDockingBar = DYNAMIC_DOWNCAST(CDockablePane, pTargetBar);

	if (pTargetDockingBar == this || GetAsyncKeyState(VK_CONTROL) < 0)
	{
		return NULL;
	}

	CMultiPaneFrameWnd* pTargetMiniFrame = pTargetDockingBar != NULL ? DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, pTargetDockingBar->GetParentMiniFrame()) : NULL;

	if (status == CS_DELAY_DOCK) // status returned by resizable control bar
	{
		if (pTargetMiniFrame != NULL)
		{
			if ((GetPaneStyle() & CBRS_FLOAT_MULTI) == 0)
			{
				return NULL;
			}
			else if (pTargetBar != NULL)
			{
				bWasDocked = !pTargetMiniFrame->DockPane(this);
				return this;
			}
		}

		bWasDocked = DockPane(pTargetDockingBar, NULL, DM_STANDARD);
	}
	else if (status == CS_DELAY_DOCK_TO_TAB && pTargetDockingBar != NULL && pTargetDockingBar->CanAcceptPane(this) && CanBeAttached())
	{
		UndockPane(FALSE);
		CDockablePane* pBar = AttachToTabWnd(pTargetDockingBar, DM_STANDARD);
		bWasDocked = (pBar != NULL);
		return pBar;
	}

	return NULL;
}

CPaneDivider* CDockablePane::GetDefaultPaneDivider() const
{
	return DYNAMIC_DOWNCAST(CPaneDivider, CWnd::FromHandlePermanent(m_hDefaultSlider));
}

AFX_CS_STATUS CDockablePane::GetDockingStatus(CPoint pt, int nSensitivity)
{
	ASSERT_VALID(this);

	AFX_DOCK_TYPE docktype = GetDockingMode();

	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(GetDockSiteFrameWnd());
	CSmartDockingStandaloneGuide::SDMarkerPlace nHilitedSideNo = CSmartDockingStandaloneGuide::sdNONE;

	if ((docktype & DT_SMART) != 0 && pDockManager != NULL)
	{
		CSmartDockingManager* pSDManager = pDockManager->GetSmartDockingManager();
		if (pSDManager != NULL && pSDManager->IsStarted())
		{
			nHilitedSideNo = pSDManager->GetHighlightedGuideNo();
		}
	}

	// detect caption
	UINT nHitTest = HitTest(pt, TRUE);

	CRect rectTabAreaTop;
	CRect rectTabAreaBottom;
	GetTabArea(rectTabAreaTop, rectTabAreaBottom);

	if (nHitTest == HTCAPTION || rectTabAreaTop.PtInRect(pt) || rectTabAreaBottom.PtInRect(pt) || nHilitedSideNo == CSmartDockingStandaloneGuide::sdCMIDDLE)
	{
		// need to display "ready to create detachable tab" status
		return CS_DELAY_DOCK_TO_TAB;
	}
	else
	{
		CRect rectBar;
		GetWindowRect(&rectBar);

		rectBar.top += GetCaptionHeight();
		rectBar.top += rectTabAreaTop.Height();
		rectBar.bottom -= rectTabAreaBottom.Height();

		if (nSensitivity == -1)
		{
			// is it demanded?
			if (rectBar.PtInRect(pt))
			{
				// mouse over an edge
				return CS_DELAY_DOCK;
			}
		}
		else
		{
			rectBar.DeflateRect(nSensitivity, nSensitivity);
			if (!rectBar.PtInRect(pt))
			{
				// mouse over an edge
				return CS_DELAY_DOCK;
			}
		}
	}

	return CS_NOTHING;
}

BOOL CDockablePane::CanAcceptMiniFrame(CPaneFrameWnd* pMiniFrame) const
{
	return pMiniFrame->CanBeDockedToPane(this);
}

BOOL CDockablePane::IsInFloatingMultiPaneFrameWnd() const
{
	CPaneFrameWnd* pMiniFrame = GetParentMiniFrame();
	if (pMiniFrame != NULL)
	{
		return pMiniFrame->IsKindOf(RUNTIME_CLASS(CMultiPaneFrameWnd));
	}
	return FALSE;
}

void CDockablePane::SetCaptionButtons()
{
	RemoveCaptionButtons();

	m_arrButtons.Add(new CMFCCaptionButton(AFX_HTCLOSE));
	m_arrButtons.Add(new CMFCCaptionButton(HTMAXBUTTON));
	m_arrButtons.Add(new CMFCCaptionButton(HTMINBUTTON));
}

void CDockablePane::RemoveCaptionButtons()
{
	for (int i = 0; i < m_arrButtons.GetSize(); i++)
	{
		delete m_arrButtons[i];
	}
	m_arrButtons.RemoveAll();
}

void CDockablePane::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CPane::OnSettingChange(uFlags, lpszSection);

	if (m_cyGripper > 0)
	{
		m_cyGripper = 0;
		EnableGripper(TRUE);
	}
}

BOOL CDockablePane::OnNeedTipText(UINT /*id*/, NMHDR* pNMH, LRESULT* /*pResult*/)
{
	static CString strTipText;

	ENSURE(pNMH != NULL);

	if (m_pToolTip->GetSafeHwnd() == NULL || pNMH->hwndFrom != m_pToolTip->GetSafeHwnd())
	{
		return FALSE;
	}

	LPNMTTDISPINFO pTTDispInfo = (LPNMTTDISPINFO) pNMH;
	ASSERT((pTTDispInfo->uFlags & TTF_IDISHWND) == 0);

	UINT nTooltipResID = 0;

	switch (pNMH->idFrom)
	{
	case 1:
		nTooltipResID = IDS_AFXBARRES_CLOSEBAR;
		break;

	case 2:
		{
			SHORT state = GetAsyncKeyState(VK_CONTROL);
			nTooltipResID = IDS_AFXBARRES_AUTOHIDEBAR;

			if ((state & 0x8000) && IsAutohideAllEnabled())
			{
				nTooltipResID = IDS_AFXBARRES_AUTOHIDE_ALL;
			}
		}
		break;

	case 3:
		nTooltipResID = IDS_AFXBARRES_MENU;
		break;
	}

	if (nTooltipResID == 0)
	{
		return FALSE;
	}

	ENSURE(strTipText.LoadString(nTooltipResID));

	pTTDispInfo->lpszText = const_cast<LPTSTR>((LPCTSTR) strTipText);
	return TRUE;
}

void CDockablePane::OnContextMenu(CWnd* pWnd, CPoint point)
{
	if (IsTracked())
	{
		return;
	}

	if (m_bCaptionButtonsCaptured)
	{
		StopCaptionButtonsTracking();
	}

	CPane::OnContextMenu(pWnd, point);
}

void CDockablePane::OnSetFocus(CWnd* pOldWnd)
{
	CPane::OnSetFocus(pOldWnd);

	CMultiPaneFrameWnd* pParentMiniFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, GetParentMiniFrame());
	if (pParentMiniFrame != NULL)
	{
		pParentMiniFrame->SetLastFocusedPane(GetSafeHwnd());
	}
}

void CDockablePane::ToggleAutoHide()
{
	ASSERT_VALID(this);

	CPaneDivider* pDefaultSlider = GetDefaultPaneDivider();

	if (CanAutoHide() && pDefaultSlider != NULL)
	{
		SetAutoHideMode(!m_bPinState, pDefaultSlider->GetCurrentAlignment());
	}
}

BOOL CDockablePane::CanAutoHide() const
{
	ASSERT_VALID(this);

	if (!CPane::CanAutoHide())
	{
		return FALSE;
	}

	CWnd* pParentWnd = GetParent();
	if (pParentWnd == NULL)
	{
		return FALSE;
	}

	if (pParentWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
	{
		pParentWnd = pParentWnd->GetParent();
	}

	if (pParentWnd == NULL)
	{
		return FALSE;
	}

	CPaneDivider* pDefaultSlider = GetDefaultPaneDivider();
	CDockingManager* pDockManager = afxGlobalUtils.GetDockingManager(pParentWnd);

	return pDockManager != NULL && pDefaultSlider != NULL && (pDefaultSlider->GetCurrentAlignment() & pDockManager->GetEnabledAutoHideAlignment());
}

void CDockablePane::CopyState(CDockablePane* pOrgBar)
{
	ASSERT_VALID(pOrgBar);
	CPane::CopyState(pOrgBar);

	m_rectRestored = pOrgBar->GetAHRestoredRect();
	m_ahSlideMode = pOrgBar->GetAHSlideMode();
	m_nLastPercent = pOrgBar->GetLastPercentInPaneContainer();
	m_bEnableAutoHideAll = pOrgBar->IsAutohideAllEnabled();

}

LRESULT CDockablePane::OnUpdateToolTips(WPARAM wp, LPARAM)
{
	UINT nTypes = (UINT) wp;

	if (nTypes & AFX_TOOLTIP_TYPE_DOCKBAR)
	{
		CTooltipManager::CreateToolTip(m_pToolTip, this, AFX_TOOLTIP_TYPE_DOCKBAR);

		for (int i = 0; i < AFX_CONTROLBAR_BUTTONS_NUM; i ++)
		{
			CRect rectDummy;
			rectDummy.SetRectEmpty();

			m_pToolTip->AddTool(this, LPSTR_TEXTCALLBACK, &rectDummy, i + 1);
		}

		UpdateTooltips();
	}

	return 0;
}

int CDockablePane::GetCaptionHeight() const
{
	if (IsFloating() || IsMDITabbed() || m_cyGripper == 0)
	{
		return 0;
	}

	return m_cyGripper + CMFCVisualManager::GetInstance()->GetDockingPaneCaptionExtraHeight();
}

void CDockablePane::ConvertToTabbedDocument(BOOL bActiveTabOnly)
{
	ASSERT_VALID(this);

	if (IsAutoHideMode())
	{
		return;
	}

	CMDIFrameWndEx* pMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetDockSiteFrameWnd());
	if (pMDIFrame == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(pMDIFrame);
	if (IsTabbed())
	{
		CTabbedPane* pBar = DYNAMIC_DOWNCAST(CTabbedPane, GetParentTabbedPane());
		if (pBar != NULL)
		{
			pBar->ConvertToTabbedDocument(bActiveTabOnly);
		}
	}
	else
	{
		pMDIFrame->ControlBarToTabbedDocument(this);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdockingmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxglobalutils.h"
#include "afxdocksite.h"
#include "afxdockablepane.h"
#include "afxpanedivider.h"

#include "afxautohidedocksite.h"
#include "afxautohidebar.h"
#include "afxautohidebutton.h"

#include "afxdockingmanager.h"
#include "afxpaneframewnd.h"
#include "afxmultipaneframewnd.h"
#include "afxtabbedpane.h"
#include "afxmdichildwndex.h"

#include "afxcaptionbar.h"

#include "afxregpath.h"
#include "afxsettingsstore.h"

#include "afxdockingpanesrow.h"

#include "afxrebar.h"
#include "afxpopupmenu.h"
#include "afxoutlookbar.h"

#include "afxmdiframewndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_REG_SECTION_FMT _T("%sDockingManager-%d")
#define AFX_REG_ENTRY_DOCKING_PANE_AND_PANEDIVIDERS _T("DockingPaneAndPaneDividers")

static const CString strDockingManagerProfile = _T("DockingManagers");

const DWORD dwDockBarMap[4][2] =
{
	{ AFX_IDW_DOCKBAR_TOP,      CBRS_TOP    },
	{ AFX_IDW_DOCKBAR_BOTTOM,   CBRS_BOTTOM },
	{ AFX_IDW_DOCKBAR_LEFT,     CBRS_LEFT   },
	{ AFX_IDW_DOCKBAR_RIGHT,    CBRS_RIGHT  },
};

UINT CDockingManager::m_nTimeOutBeforeToolBarDock = 200;
UINT CDockingManager::m_nTimeOutBeforeDockingBarDock = 220;

AFX_DOCK_TYPE CDockingManager::m_dockModeGlobal = DT_STANDARD;
UINT CDockingManager::m_ahSlideModeGlobal = AFX_AHSM_MOVE;
int CDockingManager::m_nDockSensitivity = 15;
BOOL CDockingManager::m_bRestoringDockState = FALSE;
BOOL CDockingManager::m_bHideDockingBarsInContainerMode = TRUE;
BOOL CDockingManager::m_bDisableRecalcLayout = FALSE;
BOOL CDockingManager::m_bFullScreenMode = FALSE;

BOOL CDockingManager::m_bSavingState = FALSE;

CSmartDockingInfo CDockingManager::m_SDParams;
BOOL CDockingManager::m_bSDParamsModified = FALSE;
AFX_SMARTDOCK_THEME CDockingManager::m_SDTheme = AFX_SDT_DEFAULT;

BOOL CDockingManager::m_bDockBarMenu = FALSE;
BOOL CDockingManager::m_bIgnoreEnabledAlignment = FALSE;

CRuntimeClass* CDockingManager::m_pAutoHideToolbarRTC = RUNTIME_CLASS(CMFCAutoHideBar);

// Construction/Destruction
CDockingManager::CDockingManager() : m_pParentWnd(NULL), m_pSDManager(NULL)
{
	m_dwEnabledDockBars = 0;
	m_dwEnabledSlideBars = 0;
	m_pActiveSlidingWnd = NULL;

	m_pLastTargetBar = NULL;
	m_pLastMultiMiniFrame = NULL;
	m_clkLastTime = 0;
	m_statusLast = CS_NOTHING;

	m_rectDockBarBounds.SetRectEmpty();
	m_rectClientAreaBounds.SetRectEmpty();
	m_rectOuterEdgeBounds.SetRectEmpty();

	m_rectInPlace.SetRectEmpty();

	m_bIsPrintPreviewMode = FALSE;
	m_bEnableAdjustLayout = TRUE;

	m_bLockUpdate = FALSE;
	m_bAdjustingBarLayout = FALSE;
	m_bRecalcLayout = FALSE;
	m_bSizeFrame = FALSE;

	m_bDisableSetDockState = FALSE;

	m_bDisableRestoreDockState = FALSE;

	m_bControlBarsMenuIsShown = FALSE;

	m_bControlBarsContextMenu = FALSE;
	m_bControlBarsContextMenuToolbarsOnly = FALSE;
	m_uiCustomizeCmd = 0;

	m_bHiddenForOLE = FALSE;
}

CDockingManager::~CDockingManager()
{
	if (m_pSDManager != NULL)
	{
		delete m_pSDManager;
		m_pSDManager = NULL;
	}
}

BOOL CDockingManager::Create(CFrameWnd* pParentWnd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pParentWnd);
	m_pParentWnd = pParentWnd;

	return TRUE;
}

BOOL CDockingManager::EnableDocking(DWORD dwStyle)
{
	AFX_DOCKSITE_INFO info;
	if (dwStyle & CBRS_ALIGN_TOP &&(m_dwEnabledDockBars & CBRS_ALIGN_TOP) == 0)
	{
		info.m_dwBarAlignment = CBRS_ALIGN_TOP;
		info.pDockBarRTC = RUNTIME_CLASS(CDockSite);
		if (!AddDockSite(info))
		{
			return FALSE;
		}
		m_dwEnabledDockBars |= CBRS_ALIGN_TOP;
	}

	if (dwStyle & CBRS_ALIGN_BOTTOM &&(m_dwEnabledDockBars & CBRS_ALIGN_BOTTOM) == 0)
	{
		info.m_dwBarAlignment = CBRS_ALIGN_BOTTOM;
		info.pDockBarRTC = RUNTIME_CLASS(CDockSite);
		if (!AddDockSite(info))
		{
			return FALSE;
		}
		m_dwEnabledDockBars |= CBRS_ALIGN_BOTTOM;
	}

	if (dwStyle & CBRS_ALIGN_LEFT &&(m_dwEnabledDockBars & CBRS_ALIGN_LEFT) == 0)
	{
		info.m_dwBarAlignment = CBRS_ALIGN_LEFT;
		info.pDockBarRTC = RUNTIME_CLASS(CDockSite);
		if (!AddDockSite(info))
		{
			return FALSE;
		}
		m_dwEnabledDockBars |= CBRS_ALIGN_LEFT;
	}

	if (dwStyle & CBRS_ALIGN_RIGHT &&(m_dwEnabledDockBars & CBRS_ALIGN_RIGHT) == 0)
	{
		info.m_dwBarAlignment = CBRS_ALIGN_RIGHT;
		info.pDockBarRTC = RUNTIME_CLASS(CDockSite);
		if (!AddDockSite(info))
		{
			return FALSE;
		}
		m_dwEnabledDockBars |= CBRS_ALIGN_RIGHT;
	}
	AdjustDockingLayout();

	return TRUE;
}

BOOL CDockingManager::EnableAutoHidePanes(DWORD dwStyle)
{
	AFX_DOCKSITE_INFO info;

	if (dwStyle & CBRS_ALIGN_TOP &&(m_dwEnabledSlideBars & CBRS_ALIGN_TOP) == 0)
	{
		if ((m_dwEnabledDockBars & CBRS_ALIGN_TOP) == 0)
		{
			EnableDocking(CBRS_ALIGN_TOP);
		}
		info.m_dwBarAlignment = CBRS_ALIGN_TOP;
		info.pDockBarRTC = RUNTIME_CLASS(CAutoHideDockSite);
		if (!AddDockSite(info))
		{
			return FALSE;
		}
		m_dwEnabledSlideBars |= CBRS_ALIGN_TOP;
	}

	if (dwStyle & CBRS_ALIGN_BOTTOM  &&(m_dwEnabledSlideBars & CBRS_ALIGN_BOTTOM) == 0)
	{
		if ((m_dwEnabledDockBars & CBRS_ALIGN_BOTTOM) == 0)
		{
			EnableDocking(CBRS_ALIGN_BOTTOM);
		}

		info.m_dwBarAlignment = CBRS_ALIGN_BOTTOM;
		info.pDockBarRTC = RUNTIME_CLASS(CAutoHideDockSite);
		if (!AddDockSite(info))
		{
			return FALSE;
		}
		m_dwEnabledSlideBars |= CBRS_ALIGN_BOTTOM;
	}

	if (dwStyle & CBRS_ALIGN_LEFT &&(m_dwEnabledSlideBars & CBRS_ALIGN_LEFT) == 0)
	{
		if ((m_dwEnabledDockBars & CBRS_ALIGN_LEFT) == 0)
		{
			EnableDocking(CBRS_ALIGN_LEFT);
		}

		info.m_dwBarAlignment = CBRS_ALIGN_LEFT;
		info.pDockBarRTC = RUNTIME_CLASS(CAutoHideDockSite);
		if (!AddDockSite(info))
		{
			return FALSE;
		}
		m_dwEnabledSlideBars |= CBRS_ALIGN_LEFT;
	}

	if (dwStyle & CBRS_ALIGN_RIGHT &&(m_dwEnabledSlideBars & CBRS_ALIGN_RIGHT) == 0)
	{
		if ((m_dwEnabledDockBars & CBRS_ALIGN_RIGHT) == 0)
		{
			EnableDocking(CBRS_ALIGN_RIGHT);
		}

		info.m_dwBarAlignment = CBRS_ALIGN_RIGHT;
		info.pDockBarRTC = RUNTIME_CLASS(CAutoHideDockSite);
		if (!AddDockSite(info))
		{
			return FALSE;
		}
		m_dwEnabledSlideBars |= CBRS_ALIGN_RIGHT;
	}

	AdjustDockingLayout();
	return TRUE;
}

BOOL CDockingManager::AddDockSite(const AFX_DOCKSITE_INFO& info, CDockSite** ppDockBar)
{
	ASSERT_VALID(this);

	if (ppDockBar != NULL)
	{
		*ppDockBar = NULL;
	}

	CDockSite* pDockBar = (CDockSite*) info.pDockBarRTC->CreateObject();
	ASSERT_VALID(pDockBar);
	if (pDockBar->Create(info.m_dwBarAlignment, CRect(0, 0, 0, 0), m_pParentWnd, 0))
	{
		m_lstControlBars.AddTail(pDockBar);
	}
	else
	{
		TRACE0("Failed to create DockPane");
		delete pDockBar;
		return FALSE;
	}

	if (ppDockBar != NULL)
	{
		*ppDockBar = pDockBar;
	}

	return TRUE;
}

BOOL CDockingManager::InsertDockSite(const AFX_DOCKSITE_INFO& info, DWORD dwAlignToInsertAfter, CDockSite** ppDockBar)
{
	ASSERT_VALID(this);

	if (ppDockBar != NULL)
	{
		*ppDockBar = NULL;
	}

	CDockSite* pDockBar = (CDockSite*) info.pDockBarRTC->CreateObject();
	ASSERT_VALID(pDockBar);
	if (pDockBar->Create(info.m_dwBarAlignment, CRect(0, 0, 0, 0), m_pParentWnd, 0))
	{
		BOOL bInserted = FALSE;
		for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pNextBar = (CBasePane*) m_lstControlBars.GetNext(pos);
			ASSERT_VALID(pNextBar);

			if (pNextBar->IsKindOf(RUNTIME_CLASS(CDockSite)) && pNextBar->GetCurrentAlignment() == (dwAlignToInsertAfter & CBRS_ALIGN_ANY) && pos != NULL)
			{
				m_lstControlBars.InsertBefore(pos, pDockBar);
				bInserted = TRUE;
				break;
			}
		}

		if (!bInserted)
		{
			m_lstControlBars.AddTail(pDockBar);
		}
	}
	else
	{
		TRACE0("Failed to create DockPane");
		delete pDockBar;
		return FALSE;
	}

	if (ppDockBar != NULL)
	{
		*ppDockBar = pDockBar;
	}

	return TRUE;
}

BOOL CDockingManager::AddPane(CBasePane* pWnd, BOOL bTail, BOOL bAutoHide, BOOL bInsertForOuterEdge)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWnd);

	CObList& lstBars = bAutoHide ? m_lstAutoHideBars : m_lstControlBars;

	if (lstBars.Find(pWnd))
	{
		TRACE0("Control bar already added!!!\n");
		ASSERT(FALSE);
		return FALSE;
	}

	if (bTail)
	{
		lstBars.AddTail(pWnd);
	}
	else if (bInsertForOuterEdge)
	{
		// find first control bar with the same alignment and insert before it
		for (POSITION pos = lstBars.GetHeadPosition(); pos != NULL;)
		{
			POSITION posSave = pos;
			CBasePane* pNextBar = DYNAMIC_DOWNCAST(CBasePane, m_lstControlBars.GetNext(pos));
			ASSERT_VALID(pNextBar);

			if (pNextBar->DoesAllowDynInsertBefore())
			{
				lstBars.InsertBefore(posSave, pWnd);
				return TRUE;
			}
		}

		lstBars.AddTail(pWnd);
	}
	else
	{
		lstBars.AddHead(pWnd);
	}

	pWnd->m_pDockSite = m_pParentWnd;

	return TRUE;
}

BOOL CDockingManager::InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	if (m_lstControlBars.Find(pControlBar))
	{
		TRACE0("Control bar already added!!!\n");
		ASSERT(FALSE);
		return FALSE;
	}

	POSITION pos = m_lstControlBars.Find(pTarget);
	if (pos == NULL)
	{
		TRACE0("Control bar does not exist in the control container!!!\n");
		ASSERT(FALSE);
		return FALSE;
	}

	if (bAfter)
	{
		m_lstControlBars.InsertAfter(pos, pControlBar);
	}
	else
	{
		m_lstControlBars.InsertBefore(pos, pControlBar);
	}
	return TRUE;
}

void CDockingManager::RemovePaneFromDockManager(CBasePane* pWnd, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement)
{
	CObList& lstBars = bAutoHide ? m_lstAutoHideBars : m_lstControlBars;

	POSITION pos = lstBars.Find(pWnd);
	if (pBarReplacement != NULL)
	{
		pos != NULL ? lstBars.InsertAfter(pos, pBarReplacement) : lstBars.AddTail(pBarReplacement);
	}
	if (pos != NULL)
	{
		lstBars.RemoveAt(pos);
		if (bDestroy)
		{
			pWnd->DestroyWindow();
		}

		if (bAdjustLayout)
		{
			AdjustDockingLayout();
		}
	}
}

BOOL CDockingManager::AddMiniFrame(CPaneFrameWnd* pWnd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWnd);

	POSITION pos = m_lstMiniFrames.Find(pWnd);

	if (pos != NULL)
	{
		return FALSE;
	}

	m_lstMiniFrames.AddTail(pWnd);
	return TRUE;
}

BOOL CDockingManager::RemoveMiniFrame(CPaneFrameWnd* pWnd)
{
	ASSERT_VALID(this);

	POSITION pos = m_lstMiniFrames.Find(pWnd);
	if (pos != NULL)
	{
		m_lstMiniFrames.RemoveAt(pos);
		return TRUE;
	}

	return FALSE;
}

CBasePane* CDockingManager::PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar,
	CRuntimeClass* pRTCBarType, BOOL bCheckVisibility, const CBasePane* pBarToIgnore) const
{
	ASSERT_VALID(this);

	if (m_pSDManager != NULL)
	{
		CSmartDockingStandaloneGuide::SDMarkerPlace nHilitedSide = m_pSDManager->GetHighlightedGuideNo();
		if (nHilitedSide >= CSmartDockingStandaloneGuide::sdLEFT && nHilitedSide <= CSmartDockingStandaloneGuide::sdBOTTOM)
		{
			return NULL;
		}
	}

	CPaneFrameWnd* pMiniFrameToIgnore = NULL;
	if (pBarToIgnore != NULL)
	{
		pMiniFrameToIgnore = pBarToIgnore->GetParentMiniFrame(TRUE);
	}

	CPaneFrameWnd* pFrame = FrameFromPoint(point, pMiniFrameToIgnore, FALSE);
	if (pFrame != NULL)
	{
		CBasePane* pBar = pFrame->PaneFromPoint(point, nSensitivity, bCheckVisibility);
		if (pBar != NULL && pBar != pBarToIgnore && (pRTCBarType == NULL || pBar->IsKindOf(pRTCBarType)))
		{
			return pBar;
		}
	}

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pNextBar = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if ((pRTCBarType == NULL || pNextBar->IsKindOf(pRTCBarType)))
		{
			if (bCheckVisibility && !pNextBar->IsPaneVisible() || pNextBar == pBarToIgnore)
			{
				continue;
			}

			CRect rectWnd;
			pNextBar->GetWindowRect(rectWnd);
			if (!bExactBar)
			{
				rectWnd.InflateRect(nSensitivity, nSensitivity);
			}

			if (rectWnd.PtInRect(point))
			{
				return pNextBar;
			}
		}
	}

	return NULL;
}

CBasePane* CDockingManager::PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType, const CBasePane* pBarToIgnore) const
{
	ASSERT_VALID(this);
	dwAlignment = 0;
	CBasePane* pBar = PaneFromPoint(point, nSensitivity, true, NULL, FALSE, pBarToIgnore);

	if (pBar != NULL)
	{
		if ((pRTCBarType == NULL || pBar->IsKindOf(pRTCBarType)))
		{
			if (!afxGlobalUtils.CheckAlignment(point, pBar, nSensitivity, this, FALSE, dwAlignment))
			{
				return NULL;
			}
		}
		else
		{
			pBar = NULL;
		}
	}

	return pBar;
}

AFX_CS_STATUS CDockingManager::DeterminePaneAndStatus(CPoint pt, int nSensitivity, DWORD dwEnabledAlignment, CBasePane** ppTargetBar, const CBasePane* pBarToIgnore, const CBasePane* pBarToDock)
{
	ASSERT_VALID(pBarToDock);

	// find the exact control bar first.
	*ppTargetBar = PaneFromPoint(pt, nSensitivity, true, RUNTIME_CLASS(CDockablePane), TRUE, pBarToIgnore);

	if (*ppTargetBar == NULL)
	{
		// find a miniframe from point and check it for a single bar
		CPaneFrameWnd* pMiniFrame = FrameFromPoint(pt, NULL, TRUE);
		if (pMiniFrame != NULL && pBarToDock->GetParentMiniFrame() != pMiniFrame)
		{
			// detect caption
			LRESULT uiHitTest = pMiniFrame->HitTest(pt, TRUE);
			if (uiHitTest == HTCAPTION && pMiniFrame->GetVisiblePaneCount() == 1)
			{
				*ppTargetBar = DYNAMIC_DOWNCAST(CBasePane, pMiniFrame->GetFirstVisiblePane());
				return CS_DELAY_DOCK_TO_TAB;
			}
		}
	}
	// check this bar for caption and tab area
	if (*ppTargetBar != NULL)
	{
		if ((*ppTargetBar)->GetParentMiniFrame() != NULL && (pBarToDock->GetPaneStyle() & CBRS_FLOAT_MULTI) &&
			((*ppTargetBar)->GetPaneStyle() & CBRS_FLOAT_MULTI) || (*ppTargetBar)->GetParentMiniFrame() == NULL)
		{

			CDockablePane* pDockingBar = DYNAMIC_DOWNCAST(CDockablePane, *ppTargetBar);

			if (!pDockingBar->IsFloating() && (pDockingBar->GetCurrentAlignment() & dwEnabledAlignment) == 0)
			{
				return CS_NOTHING;
			}

			if (pDockingBar != NULL)
			{
				return pDockingBar->GetDockingStatus(pt, nSensitivity);
			}
		}
	}

	*ppTargetBar = NULL;

	// check whether the mouse cursor is at the outer edge of the dock bar
	// or at the inner edge of the most inner control bar(on client area) and the
	// bar is allowed to be docked at this side
	BOOL bOuterEdge = FALSE;
	DWORD dwAlignment = 0;

	if (IsPointNearDockSite(pt, dwAlignment, bOuterEdge) && (dwAlignment & dwEnabledAlignment))
	{
		return CS_DELAY_DOCK;
	}

	return CS_NOTHING;
}

CBasePane* CDockingManager::FindPaneByID(UINT uBarID, BOOL bSearchMiniFrames)
{
	ASSERT_VALID(this);

	POSITION pos = NULL;

	for (pos = m_lstAutoHideBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*)m_lstAutoHideBars.GetNext(pos);

		ASSERT_VALID(pBar);
		if (pBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)))
		{
			CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, pBar);
			// SLIDER CONTAINS ONLY ONE BAR IN AUTOHIDE MODE
			pBar = (CBasePane*) pSlider->GetFirstPane();
		}

		if (pBar == NULL)
		{
			continue;
		}

		UINT uID = pBar->GetDlgCtrlID();

		if (uID == uBarID)
		{
			return pBar;
		}
	}

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*)m_lstControlBars.GetNext(pos);

		UINT uID = pBar->GetDlgCtrlID();

		if (uID == uBarID)
		{
			return pBar;
		}

		if (pBar->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))
		{
			CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pBar);
			ASSERT_VALID(pTabbedBar);

			CBasePane* pControlBar = DYNAMIC_DOWNCAST(CBasePane, pTabbedBar->FindPaneByID(uBarID));
			if (pControlBar != NULL)
			{
				return pControlBar;
			}
		}
		else if (pBar->IsKindOf(RUNTIME_CLASS(CDockSite)))
		{
			CDockSite* pDockBar = (CDockSite*) pBar;
			ASSERT_VALID(pDockBar);

			CPane* pBarID = pDockBar->FindPaneByID(uBarID);
			if (pBarID != NULL)
			{
				return DYNAMIC_DOWNCAST(CBasePane, pBarID);
			}
		}
		else if (pBar->IsKindOf(RUNTIME_CLASS(CMFCReBar)))
		{
			CMFCReBar* pReBar = (CMFCReBar*) pBar;
			ASSERT_VALID(pReBar);

			CBasePane* pBarID = DYNAMIC_DOWNCAST(CBasePane, pReBar->GetDlgItem(uBarID));
			if (pBarID != NULL)
			{
				return pBarID;
			}
		}
	}

	if (bSearchMiniFrames)
	{
		for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
		{
			CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));
			if (pMiniFrame != NULL)
			{
				CBasePane* pWnd = DYNAMIC_DOWNCAST(CBasePane, pMiniFrame->GetPane());
				if (pWnd != NULL && pWnd->GetDlgCtrlID() == (int) uBarID)
				{
					return pWnd;
				}
			}
		}

		return CPaneFrameWnd::FindFloatingPaneByID(uBarID);
	}

	return NULL;
}

CDockSite* CDockingManager::FindDockSite(DWORD dwAlignment, BOOL bOuter)
{
	for (POSITION pos = bOuter ? m_lstControlBars.GetHeadPosition() : m_lstControlBars.GetTailPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*)(bOuter ? m_lstControlBars.GetNext(pos) : m_lstControlBars.GetPrev(pos));
		ASSERT_VALID(pBar);

		if (!pBar->IsKindOf(RUNTIME_CLASS(CDockSite)))
		{
			continue;
		}

		if (pBar->GetCurrentAlignment() == (dwAlignment & CBRS_ALIGN_ANY))
		{
			return DYNAMIC_DOWNCAST(CDockSite, pBar);
		}
	}

	return NULL;
}

void CDockingManager::FixupVirtualRects()
{
	ASSERT_VALID(this);
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockSite* pBar = DYNAMIC_DOWNCAST(CDockSite, m_lstControlBars.GetNext(pos));
		if (pBar != NULL)
		{
			pBar->FixupVirtualRects();
		}
	}
	AdjustDockingLayout();
}

BOOL CDockingManager::IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const
{
	ASSERT_VALID(this);
	dwBarAlignment = 0;
	// check the "outer" edge first - non resizable dock bars

	CRect rectBounds = m_rectOuterEdgeBounds;
	m_pParentWnd->ClientToScreen(rectBounds);

	bOuterEdge = TRUE;
	if (afxGlobalUtils.CheckAlignment(point, NULL, CDockingManager::m_nDockSensitivity, this, bOuterEdge, dwBarAlignment, m_dwEnabledDockBars, rectBounds))
	{
		return TRUE;
	}

	// check the innre edges - edges of the client area
	rectBounds = m_rectClientAreaBounds;
	m_pParentWnd->ClientToScreen(rectBounds);

	bOuterEdge = FALSE;
	return afxGlobalUtils.CheckAlignment(point, NULL, CDockingManager::m_nDockSensitivity, this, bOuterEdge, dwBarAlignment, m_dwEnabledDockBars, rectBounds);
}

BOOL CDockingManager::DockPaneLeftOf(CPane* pBarToDock, CPane* pTargetBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBarToDock);
	ASSERT_VALID(pTargetBar);

	if (pTargetBar->IsKindOf(RUNTIME_CLASS(CDockablePane)) && pBarToDock->IsKindOf(RUNTIME_CLASS(CDockablePane)))
	{
	}
	else if (pTargetBar->IsKindOf(RUNTIME_CLASS(CMFCToolBar)) && pBarToDock->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
	{
		CDockSite* pDockBar = FindDockSiteByPane(pTargetBar);
		if (pDockBar != NULL)
		{
			pBarToDock->UndockPane(TRUE);
			BOOL bResult = pDockBar->DockPaneLeftOf(pBarToDock, pTargetBar);
			return bResult;
		}
	}

	return FALSE;
}

CDockSite* CDockingManager::FindDockSiteByPane(CPane* pTargetBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pTargetBar);

	UINT uID = pTargetBar->GetDlgCtrlID();

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockSite* pBar = DYNAMIC_DOWNCAST(CDockSite, m_lstControlBars.GetNext(pos));
		if (pBar != NULL)
		{
			if (pBar->FindPaneByID(uID) == pTargetBar)
			{
				return pBar;
			}
		}
	}
	return NULL;
}

// Should be used for toolbars or(resizable) control bars that can be docked
// on a resizable DockPane

void CDockingManager::DockPane(CBasePane* pBar, UINT nDockBarID, LPCRECT lpRect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	if (m_lstControlBars.IsEmpty())
	{
		return;
	}

	// if the bar can be
	pBar->UndockPane(TRUE);

	if (!pBar->CanBeResized() && !pBar->CanFloat())
	{
		AddPane(pBar);
		return;
	}

	DWORD dwBarDockStyle = pBar->GetEnabledAlignment();

	if (pBar->IsResizable())
	{
		// resazable control bars are docked to frame window(their dock site)
		// directly
		if (nDockBarID == 0)
		{
			pBar->DockToFrameWindow(pBar->GetCurrentAlignment(), lpRect);
		}
		else
		{
			for (int i = 0; i < 4; i++)
			{
				DWORD dwDockBarID = dwDockBarMap [i][0];
				DWORD dwDockAlign = dwDockBarMap [i][1];

				if ((nDockBarID == 0 || nDockBarID == dwDockBarID) && (dwDockAlign & dwBarDockStyle))
				{
					pBar->DockToFrameWindow(dwDockAlign, lpRect);
					break;
				}
			}
		}
	}
	else
	{
		for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pNextBar = (CBasePane*)m_lstControlBars.GetNext(pos);
			ASSERT_VALID(pNextBar);

			if (pNextBar->IsKindOf(RUNTIME_CLASS(CDockSite)))
			{
				CDockSite* pNextDockBar = (CDockSite*) pNextBar;

				if ((nDockBarID == 0 || pNextDockBar->GetDockSiteID() == nDockBarID) && pBar->CanBeDocked(pNextDockBar) && pNextDockBar->CanAcceptPane(pBar))
				{
					if (pBar->DockPane(pNextDockBar, lpRect, DM_RECT))
					{
						pBar->InvalidateRect(NULL);
						break;
					}
				}
			}
		}
	}
}

CMFCAutoHideBar* CDockingManager::AutoHidePane(CDockablePane* pBar, CMFCAutoHideBar* pCurrAutoHideToolBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	DWORD dwAlignment = pBar->GetCurrentAlignment();

	// create autohide toolbar and button - it's always inner dockbar
	CAutoHideDockSite* pAutoHideDockBar = DYNAMIC_DOWNCAST(CAutoHideDockSite, FindDockSite(dwAlignment, FALSE));

	if (pAutoHideDockBar == NULL)
	{
		// no autohide allowed at this side
		return NULL;
	}

	CMFCAutoHideBar* pAutoHideToolBar = pCurrAutoHideToolBar;

	if (pAutoHideToolBar == NULL)
	{
		pAutoHideToolBar = DYNAMIC_DOWNCAST(CMFCAutoHideBar, m_pAutoHideToolbarRTC->CreateObject());

		ASSERT_VALID(pAutoHideToolBar);

		DWORD dwControlBarStyle = 0; // can't float...
		if (!pAutoHideToolBar->Create(NULL, WS_VISIBLE | WS_CHILD, CRect(0, 0, 0, 0), m_pParentWnd, 1, dwControlBarStyle))
		{
			TRACE0("Failde to create autohide toolbar");
			ASSERT(FALSE);
			delete pAutoHideToolBar;
			return NULL;
		}
	}
	pAutoHideToolBar->EnableDocking(CBRS_ALIGN_ANY);

	CPaneDivider* pDefaultSlider = pBar->GetDefaultPaneDivider();

	ASSERT_VALID(pDefaultSlider);

	CMFCAutoHideButton* pBtn = pAutoHideToolBar->AddAutoHideWindow(pBar, dwAlignment);

	ASSERT_VALID(pBtn);

	// NULL indicates that there was a new toolbar created here
	if (pCurrAutoHideToolBar == NULL)
	{
		if (!pAutoHideDockBar->IsPaneVisible())
		{
			pAutoHideDockBar->ShowWindow(SW_SHOW);
		}
		pAutoHideToolBar->DockPane(pAutoHideDockBar, NULL, DM_RECT);
	}

	// recalc. layout according to the newly added bar
	AdjustDockingLayout();

	// register the slider with the manager
	AddPane(pDefaultSlider, TRUE, TRUE);

	AlignAutoHidePane(pDefaultSlider);

	pBar->BringWindowToTop();
	pDefaultSlider->BringWindowToTop();

	return pAutoHideToolBar;
}

void CDockingManager::HideAutoHidePanes(CDockablePane* pBarToExclude, BOOL bImmediately)
{
	for (POSITION pos = m_lstAutoHideBars.GetHeadPosition(); pos != NULL;)
	{
		CPaneDivider* pSlider = (CPaneDivider*) m_lstAutoHideBars.GetNext(pos);
		ASSERT_VALID(pSlider);

		CDockablePane* pControlBar = (CDockablePane*)pSlider->GetFirstPane();
		ASSERT_VALID(pControlBar);

		if (pControlBar == pBarToExclude)
		{
			continue;
		}

		if (pControlBar->IsPaneVisible())
		{
			pControlBar->Slide(FALSE, !bImmediately);
		}
	}
}

void CDockingManager::AlignAutoHidePane(CPaneDivider* pDefaultSlider, BOOL bIsVisible)
{
	CRect rectSlider;

	pDefaultSlider->GetWindowRect(rectSlider);
	BOOL bHorz = pDefaultSlider->IsHorizontal();

	DWORD dwAlignment = pDefaultSlider->GetCurrentAlignment();
	BOOL bIsRTL = m_pParentWnd->GetExStyle() & WS_EX_LAYOUTRTL;

	if (bIsVisible)
	{
		CSize sizeRequered = pDefaultSlider->CalcFixedLayout(FALSE, bHorz);

		if (bHorz)
		{
			dwAlignment & CBRS_ALIGN_TOP ? rectSlider.bottom = rectSlider.top + sizeRequered.cy : rectSlider.top = rectSlider.bottom - sizeRequered.cy;
		}
		else
		{
			dwAlignment & CBRS_ALIGN_LEFT ? rectSlider.right = rectSlider.left + sizeRequered.cx : rectSlider.left = rectSlider.right - sizeRequered.cx;
		}

		// m_rectOuterEdgeBounds - the area surrounded by dock bars
		CRect rectBoundsScreen = m_rectOuterEdgeBounds;
		m_pParentWnd->ClientToScreen(rectBoundsScreen);
		AlignByRect(rectBoundsScreen, rectSlider, dwAlignment, bHorz, TRUE);

		HDWP hdwp = NULL;
		pDefaultSlider->RepositionPanes(rectSlider, hdwp);
	}
	else
	{
		// it can be nonvisible only when moved out of screen - adjust  only width/height
		CBasePane* pControlBar = (CBasePane*)pDefaultSlider->GetFirstPane();
		CRect rectControlBar;
		pControlBar->GetWindowRect(rectControlBar);

		pDefaultSlider->GetParent()->ScreenToClient(rectSlider);
		pDefaultSlider->GetParent()->ScreenToClient(rectControlBar);

		if (bHorz)
		{
			rectSlider.left = rectControlBar.left = m_rectOuterEdgeBounds.left;
			rectSlider.right = rectControlBar.right = m_rectOuterEdgeBounds.right;
		}
		else
		{
			rectSlider.top = rectControlBar.top = m_rectOuterEdgeBounds.top;
			rectSlider.bottom = rectControlBar.bottom = m_rectOuterEdgeBounds.bottom;
		}

		CPoint ptOffset(0, 0);

		// slider is not hidden completely - it is aligned by m_rectOuterEdgeBounds
		switch (dwAlignment)
		{
		case CBRS_ALIGN_LEFT:
			if (bIsRTL)
			{
				if (rectSlider.right != m_rectOuterEdgeBounds.right)
				{
					ptOffset.x = m_rectOuterEdgeBounds.right - rectSlider.right;
				}
			}
			else
			{
				if (rectSlider.left != m_rectOuterEdgeBounds.left)
				{
					ptOffset.x = m_rectOuterEdgeBounds.left - rectSlider.left;
				}
			}
			break;

		case CBRS_ALIGN_RIGHT:
			if (bIsRTL)
			{
				if (rectSlider.left != m_rectOuterEdgeBounds.left)
				{
					ptOffset.x = m_rectOuterEdgeBounds.left - rectSlider.left;
				}
			}
			else
			{
				if (rectSlider.right != m_rectOuterEdgeBounds.right)
				{
					ptOffset.x = m_rectOuterEdgeBounds.right - rectSlider.right;
				}
			}
			break;

		case CBRS_ALIGN_TOP:
			if (rectSlider.top != m_rectOuterEdgeBounds.top)
			{
				ptOffset.y = m_rectOuterEdgeBounds.top - rectSlider.top;
			}
			break;

		case CBRS_ALIGN_BOTTOM:
			if (rectSlider.bottom != m_rectOuterEdgeBounds.bottom)
			{
				ptOffset.y = m_rectOuterEdgeBounds.bottom - rectSlider.bottom;
			}
			break;
		}

		rectSlider.OffsetRect(ptOffset);
		rectControlBar.OffsetRect(ptOffset);

		pDefaultSlider->SetWindowPos(NULL, rectSlider.left, rectSlider.top, rectSlider.Width(), rectSlider.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
		pControlBar->SetWindowPos(NULL, rectControlBar.left, rectControlBar.top, rectControlBar.Width(), rectControlBar.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
		pControlBar->RecalcLayout();
	}
}

void CDockingManager::CalcExpectedDockedRect(CWnd* pWnd, CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar)
{
	ASSERT_VALID(this);

	rectResult.SetRectEmpty();

	if (GetKeyState(VK_CONTROL) < 0)
	{
		return;
	}

	BOOL bOuterEdge = FALSE;
	DWORD dwAlignment = 0;

	CPaneFrameWnd* pOtherMiniFrame = FrameFromPoint(ptMouse, DYNAMIC_DOWNCAST(CPaneFrameWnd, pWnd), TRUE);

	if (pOtherMiniFrame != NULL)
	{
		pOtherMiniFrame->CalcExpectedDockedRect(pWnd, ptMouse, rectResult, bDrawTab, ppTargetBar);
	}

	if (pOtherMiniFrame == NULL || rectResult.IsRectEmpty())
	{
		CBasePane* pThisControlBar =
			(m_pSDManager != NULL && m_pSDManager->IsStarted()) ? DYNAMIC_DOWNCAST(CBasePane, (DYNAMIC_DOWNCAST(CPaneFrameWnd, pWnd))->GetPane()) : NULL;

		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, PaneFromPoint(ptMouse, CDockingManager::m_nDockSensitivity, true, NULL, TRUE, pThisControlBar));

		if (pBar != NULL && pBar->GetDefaultPaneDivider() != NULL)
		{
			if (pWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
			{
				CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, pWnd);
				ASSERT_VALID(pMiniFrame);
				if (!pBar->CanAcceptMiniFrame(pMiniFrame))
				{
					return;
				}
			}

			CPaneDivider* pDefaultSlider = pBar->GetDefaultPaneDivider();
			ASSERT_VALID(pDefaultSlider);

			pDefaultSlider->CalcExpectedDockedRect(pWnd, ptMouse, rectResult, bDrawTab, ppTargetBar);
		}
		else if (IsPointNearDockSite(ptMouse, dwAlignment, bOuterEdge))
		{
			*ppTargetBar = NULL;

			if (pWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
			{
				CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, pWnd);
				ASSERT_VALID(pMiniFrame);

				CPane* pBarFrame = DYNAMIC_DOWNCAST(CPane, pMiniFrame->GetPane());
				if (pBarFrame != NULL &&(pBarFrame->GetEnabledAlignment() & dwAlignment) == 0)
				{
					return;
				}
			}
			else if (pWnd->IsKindOf(RUNTIME_CLASS(CDockablePane)))
			{
				CDockablePane* pBarDock = DYNAMIC_DOWNCAST(CDockablePane, pWnd);
				if ((pBarDock->GetEnabledAlignment() & dwAlignment) == 0)
				{
					return;
				}
			}

			CRect rectWnd;
			pWnd->GetWindowRect(rectWnd);

			rectResult = bOuterEdge ? m_rectOuterEdgeBounds : m_rectClientAreaBounds;

			BOOL bIsRTL = m_pParentWnd->GetExStyle() & WS_EX_LAYOUTRTL;

			switch (dwAlignment)
			{
			case CBRS_ALIGN_LEFT:
				if (bIsRTL)
				{
					rectResult.left = rectResult.right - rectWnd.Width();
				}
				else
				{
					rectResult.right = rectResult.left + rectWnd.Width();
				}
				break;

			case CBRS_ALIGN_RIGHT:
				if (bIsRTL)
				{
					rectResult.right = rectResult.left + rectWnd.Width();
				}
				else
				{
					rectResult.left = rectResult.right - rectWnd.Width();
				}
				break;

			case CBRS_ALIGN_TOP:
				rectResult.bottom = rectResult.top + rectWnd.Height();
				break;

			case CBRS_ALIGN_BOTTOM:
				rectResult.top = rectResult.bottom - rectWnd.Height();
				break;
			}

			AdjustRectToClientArea(rectResult, dwAlignment);
			m_pParentWnd->ClientToScreen(rectResult);
		}
		else
		{
			*ppTargetBar = NULL;
		}
	}
}

BOOL CDockingManager::AdjustRectToClientArea(CRect& rectResult, DWORD dwAlignment)
{
	BOOL bAdjusted = FALSE;

	int nAllowedHeight = (int)(m_rectClientAreaBounds.Height() * afxGlobalData.m_nCoveredMainWndClientAreaPercent / 100);
	int nAllowedWidth = (int)(m_rectClientAreaBounds.Width() * afxGlobalData.m_nCoveredMainWndClientAreaPercent / 100);

	if (dwAlignment & CBRS_ORIENT_HORZ && rectResult.Height() >= nAllowedHeight)
	{
		if (dwAlignment & CBRS_ALIGN_TOP)
		{
			rectResult.bottom = rectResult.top + nAllowedHeight;
			bAdjusted = TRUE;
		}
		else if (dwAlignment & CBRS_ALIGN_BOTTOM)
		{
			rectResult.top = rectResult.bottom - nAllowedHeight;
			bAdjusted = TRUE;
		}
	}
	else if (dwAlignment & CBRS_ORIENT_VERT && rectResult.Width() >= nAllowedWidth)
	{
		BOOL bIsRTL = m_pParentWnd->GetExStyle() & WS_EX_LAYOUTRTL;

		if (dwAlignment & CBRS_ALIGN_LEFT)
		{
			if (bIsRTL)
			{
				rectResult.left = rectResult.right - nAllowedWidth;
			}
			else
			{
				rectResult.right = rectResult.left + nAllowedWidth;
			}
			bAdjusted = TRUE;
		}
		else if (dwAlignment & CBRS_ALIGN_RIGHT)
		{
			if (bIsRTL)
			{
				rectResult.right = rectResult.left + nAllowedWidth;
			}
			else
			{
				rectResult.left = rectResult.right - nAllowedWidth;
			}
			bAdjusted = TRUE;
		}
	}

	return bAdjusted;
}

BOOL CDockingManager::OnMoveMiniFrame(CWnd* pFrame)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pFrame);

	if (GetKeyState(VK_CONTROL) < 0)
	{
		return TRUE;
	}

	BOOL bResult = TRUE;

	CPaneFrameWnd* pMiniFrameEx = DYNAMIC_DOWNCAST(CPaneFrameWnd, pFrame);

	BOOL bSDockingIsOn = m_pSDManager != NULL && m_pSDManager->IsStarted();

	if (pMiniFrameEx != NULL)
	{
		CRect rect;
		pFrame->GetWindowRect(rect);
		int captionHeight = pMiniFrameEx->GetCaptionHeight();
		CRect rectDelta(captionHeight, captionHeight, captionHeight, captionHeight);
		afxGlobalUtils.AdjustRectToWorkArea(rect, &rectDelta);

		pMiniFrameEx->SetWindowPos(NULL, rect.left, rect.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
	}

	if (pMiniFrameEx != NULL)
	{
		CPoint ptMouse;
		GetCursorPos(&ptMouse);

		CPane* pBar = DYNAMIC_DOWNCAST(CPane, pMiniFrameEx->GetPane());

		// first, check if there is any other miniframe around and whether
		// it is possible to dock at this miniframe - but only if the
		// current bar is docking control bar has style cbrs_float_multi

		if ((pBar == NULL) || (!bSDockingIsOn &&(pBar->GetPaneStyle() & CBRS_FLOAT_MULTI) && pBar->IsKindOf(RUNTIME_CLASS(CDockablePane))))
		{
			CPaneFrameWnd* pOtherMiniFrame = FrameFromPoint(ptMouse, pMiniFrameEx, TRUE);

			// dock only bars from miniframes that have the same parent main frame,
			// otherwise it will create problems for dockmanagers
			if (pOtherMiniFrame != NULL && pOtherMiniFrame->GetParent() == pMiniFrameEx->GetParent())
			{
				CMultiPaneFrameWnd* pMultiMiniFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, pOtherMiniFrame);

				if (pMultiMiniFrame != NULL && m_pLastMultiMiniFrame == NULL)
				{
					m_clkLastTime = clock();
					m_pLastMultiMiniFrame = pMultiMiniFrame;
				}

				if (pMultiMiniFrame != NULL && m_pLastMultiMiniFrame == pMultiMiniFrame && clock() - m_clkLastTime >(int) m_nTimeOutBeforeDockingBarDock)
				{
					bResult = pMultiMiniFrame->DockFrame(pMiniFrameEx, DM_MOUSE);
					m_clkLastTime = clock();
					m_pLastMultiMiniFrame = NULL;
					return bResult;
				}

				return TRUE;
			}
		}

		m_pLastMultiMiniFrame = NULL;

		if (pBar != NULL)
		{
			if ((pBar->GetEnabledAlignment() & CBRS_ALIGN_ANY) == 0)
			{
				// docking was not enabled for this control bar
				return TRUE;
			}

			// target control bar or dock bar
			CBasePane* pTargetBar = NULL;
			AFX_CS_STATUS status = pBar->IsChangeState(CDockingManager::m_nDockSensitivity, &pTargetBar);

			if (pBar == pTargetBar)
			{
				status = CS_NOTHING;
			}

			if ((pTargetBar != NULL || status == CS_DELAY_DOCK) && !bSDockingIsOn)
			{
				BOOL bDockBar =  pTargetBar != NULL ? pTargetBar->IsKindOf(RUNTIME_CLASS(CDockSite)) : FALSE;

				BOOL bDockingBar = pTargetBar != NULL ? pTargetBar->IsKindOf(RUNTIME_CLASS(CDockablePane)) : TRUE;

				if (bDockBar || bDockingBar)
				{
					UINT uTimeOut = bDockBar ? m_nTimeOutBeforeToolBarDock : m_nTimeOutBeforeDockingBarDock;
					if (m_pLastTargetBar != pTargetBar || status != m_statusLast)
					{
						m_clkLastTime = clock();
						m_pLastTargetBar = pTargetBar;
						m_statusLast = status;

						pMiniFrameEx->SetDockingTimer(uTimeOut);

					}

					if (clock() - m_clkLastTime <(int) uTimeOut)
					{
						return TRUE;
					}
				}
			}

			m_pLastTargetBar = NULL;
			m_clkLastTime = clock();
			m_statusLast = CS_NOTHING;
			pMiniFrameEx->KillDockingTimer();

			if (status == CS_DOCK_IMMEDIATELY && pTargetBar != NULL)
			{
				// in the case docking was delayed we need always turn off predock state
				//(usually it happens only for resizable control bars)
				pMiniFrameEx->SetPreDockState(PDS_NOTHING);
				if (pBar->DockByMouse(pTargetBar))
				{
					return FALSE;
				}
			}

			if (status == CS_DELAY_DOCK && !bSDockingIsOn) // status returned by resizable control bar
			{
				bResult = pMiniFrameEx->SetPreDockState(PDS_DOCK_REGULAR, pTargetBar);
			}
			else if (status == CS_DELAY_DOCK_TO_TAB && !bSDockingIsOn)
			{
				bResult = pMiniFrameEx->SetPreDockState(PDS_DOCK_TO_TAB, pTargetBar);
				AdjustDockingLayout();
			}
			else
			{
				bResult = pMiniFrameEx->SetPreDockState(PDS_NOTHING, pTargetBar);
			}
		}
	}
	return bResult;
}

// used for autohide to prevent wrong z-order when auto hide window is sliding
// in(collapsed)

void CDockingManager::BringBarsToTop(DWORD dwAlignment, BOOL bExcludeDockedBars)
{
	dwAlignment &= CBRS_ALIGN_ANY;

	for (POSITION pos = m_lstControlBars.GetTailPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*) m_lstControlBars.GetPrev(pos);
		ASSERT_VALID(pBar);

		if (bExcludeDockedBars && (pBar->IsKindOf(RUNTIME_CLASS(CPane)) || pBar->IsKindOf(RUNTIME_CLASS(CPaneDivider))))
		{
			continue;
		}

		// starting from first dockbar do not exclude anything(so, th stattus bar
		// and so on will be on top)
		bExcludeDockedBars = FALSE;

		DWORD dwCurrAlignment = pBar->GetCurrentAlignment();

		if (dwCurrAlignment == dwAlignment || dwAlignment == 0)
		{
			pBar->BringWindowToTop();
		}
	}
}

void CDockingManager::SetAutohideZOrder(CDockablePane* pAHDockingBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pAHDockingBar);

	DWORD dwAlignment = pAHDockingBar->GetCurrentAlignment();
	CPaneDivider* pAHSlider = pAHDockingBar->GetDefaultPaneDivider();

	for (POSITION pos = m_lstControlBars.GetTailPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*) m_lstControlBars.GetPrev(pos);
		ASSERT_VALID(pBar);

		if (pBar == pAHSlider || pBar == pAHDockingBar)
		{
			continue;
		}

		if (pBar->IsKindOf(RUNTIME_CLASS(CPane)) && (pBar->GetCurrentAlignment() == dwAlignment))
		{
			pBar->SetWindowPos(pAHDockingBar, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
		}
		else if (pBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)))
		{
			pBar->SetWindowPos(&CWnd::wndBottom, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
		}
	}

	pAHDockingBar->SetWindowPos(pAHSlider, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

}

void CDockingManager::RecalcLayout(BOOL /*bNotify*/)
{
	if (m_bDisableRecalcLayout)
	{
		return;
	}

	if (m_bRecalcLayout || m_bSizeFrame)
	{
		return;
	}

	if (!m_bEnableAdjustLayout)
	{
		return;
	}

	m_bRecalcLayout = TRUE;

	if (!IsOLEContainerMode())
	{
		POSITION pos = NULL;

		for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pNextControlBar = (CBasePane*) m_lstControlBars.GetNext(pos);
			ASSERT_VALID(pNextControlBar);
			pNextControlBar->AdjustLayout();
		}

		for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
		{
			CPaneFrameWnd* pNextMiniFrame = (CPaneFrameWnd*) m_lstMiniFrames.GetNext(pos);
			ASSERT_VALID(pNextMiniFrame);
			pNextMiniFrame->AdjustLayout();
		}
	}
	else
	{
		for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pNextControlBar = (CBasePane*) m_lstControlBars.GetNext(pos);
			ASSERT_VALID(pNextControlBar);
			if (pNextControlBar->IsPaneVisible())
			{
				pNextControlBar->AdjustLayout();
			}
		}
	}

	AdjustDockingLayout();
	m_bRecalcLayout = FALSE;
}

void CDockingManager::AdjustPaneFrames()
{
	ASSERT_VALID(this);

	UINT uiSWPFlags = SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED;

	POSITION pos = NULL;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pNextControlBar = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextControlBar);

		pNextControlBar->SetWindowPos(NULL, -1, -1, -1, -1, uiSWPFlags);
	}

	for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pNextMiniFrame = (CPaneFrameWnd*) m_lstMiniFrames.GetNext(pos);
		ASSERT_VALID(pNextMiniFrame);

		pNextMiniFrame->SetWindowPos(NULL, -1, -1, -1, -1, uiSWPFlags);
		pNextMiniFrame->AdjustPaneFrames();
	}
}

void CDockingManager::AdjustDockingLayout(HDWP hdwp)
{
	ASSERT_VALID(this);

	if (m_bDisableRecalcLayout)
	{
		return;
	}

	if (m_bAdjustingBarLayout)
	{
		return;
	}

	if (m_pParentWnd == NULL)
	{
		return;
	}

	m_pParentWnd->GetClientRect(m_rectClientAreaBounds);

	if (!m_rectInPlace.IsRectEmpty())
	{
		m_rectClientAreaBounds = m_rectInPlace;
	}

	if (!m_bEnableAdjustLayout)
	{
		return;
	}

	if (m_lstControlBars.IsEmpty())
	{
		return;
	}

	if (AFXGetTopLevelFrame(m_pParentWnd) != NULL && AFXGetTopLevelFrame(m_pParentWnd)->IsIconic())

	{
		return;
	}

	m_bAdjustingBarLayout = TRUE;

	CRect rectSaveOuterEdgeBounds = m_rectOuterEdgeBounds;

	BOOL bDeferWindowPosHere = FALSE;
	if (hdwp == NULL && !m_bIsPrintPreviewMode)
	{
		hdwp = BeginDeferWindowPos((int) m_lstControlBars.GetCount());
		bDeferWindowPosHere = TRUE;
	}

	CRect rectCurrBounds = m_rectDockBarBounds;

	m_pParentWnd->GetClientRect(rectCurrBounds);
	if (!m_rectInPlace.IsRectEmpty())
	{
		rectCurrBounds = m_rectInPlace;
	}
	m_pParentWnd->ClientToScreen(rectCurrBounds);

	CRect rectControlBar;
	POSITION posLastDockBar = NULL;

	// find position of the last dock bar in the list(actually, it will be position
	// of the next control bar right after the last dock bar in the list)

	for (posLastDockBar = m_lstControlBars.GetTailPosition(); posLastDockBar != NULL;)
	{
		CBasePane* pDockBar = (CBasePane*) m_lstControlBars.GetPrev(posLastDockBar);
		if (posLastDockBar == NULL)
		{
			break;
		}

		if (pDockBar->IsKindOf(RUNTIME_CLASS(CDockSite)) || pDockBar->IsKindOf(RUNTIME_CLASS(CAutoHideDockSite)))
		{
			m_lstControlBars.GetNext(posLastDockBar);
			if (posLastDockBar != NULL)
			{
				m_lstControlBars.GetNext(posLastDockBar);
			}
			break;
		}
	}

	POSITION posBar = NULL;
	POSITION pos = NULL;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		posBar = pos;

		CBasePane* pNextControlBar = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextControlBar);

		if (!pNextControlBar->IsPaneVisible() && (pNextControlBar->IsKindOf(RUNTIME_CLASS(CPane)) || pNextControlBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)) ||
			pNextControlBar->IsKindOf(RUNTIME_CLASS(CDockSite)) && (m_bIsPrintPreviewMode || IsOLEContainerMode() || m_bHiddenForOLE)))
		{
			continue;
		}

		// let's see whether this control bar has enough space to be displayed,
		// has to be aligned differntly and so on.

		pNextControlBar->GetWindowRect(rectControlBar);
		CRect rectSave = rectControlBar;

		DWORD dwAlignment = pNextControlBar->GetCurrentAlignment();
		BOOL  bHorizontal = pNextControlBar->IsHorizontal();
		BOOL  bResizable  = pNextControlBar->IsResizable();

		if (pNextControlBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
		{
			CDockablePane* pDockingControlBar = DYNAMIC_DOWNCAST(CDockablePane, pNextControlBar);
			if (pDockingControlBar->GetDefaultPaneDivider() != NULL)
			{
				// resizable control bars with sliders will be aligned by slider itself!!!
				continue;
			}
		}

		CSize sizeRequered = pNextControlBar->CalcFixedLayout(FALSE, bHorizontal);

		if (bHorizontal)
		{
			dwAlignment & CBRS_ALIGN_TOP ? rectControlBar.bottom = rectControlBar.top + sizeRequered.cy : rectControlBar.top = rectControlBar.bottom - sizeRequered.cy;
		}
		else
		{
			dwAlignment & CBRS_ALIGN_LEFT ? rectControlBar.right = rectControlBar.left + sizeRequered.cx : rectControlBar.left = rectControlBar.right - sizeRequered.cx;
		}

		AlignByRect(rectCurrBounds, rectControlBar, dwAlignment, bHorizontal, bResizable);

		CRect rectControlBarScreen = rectControlBar;

		ASSERT_VALID(pNextControlBar->GetParent());
		if (pNextControlBar->IsKindOf(RUNTIME_CLASS(CDockSite)))
		{
			pNextControlBar->ScreenToClient(rectControlBar);
			if (pNextControlBar->IsHorizontal() && rectControlBar.Width() > 0 || !pNextControlBar->IsHorizontal() && rectControlBar.Height() > 0)
			{
				((CDockSite*) pNextControlBar)->RepositionPanes(rectControlBar);
			}

			rectControlBar = rectControlBarScreen;
		}

		if (pNextControlBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)))
		{
			// the slider will change its position, as well as position of
			// its resizable control bars(container)
			((CPaneDivider*) pNextControlBar)->RepositionPanes(rectControlBar, hdwp);
		}
		else
		{
			pNextControlBar->GetParent()->ScreenToClient(rectControlBar);
			hdwp = pNextControlBar->SetWindowPos(NULL, rectControlBar.left, rectControlBar.top, rectControlBar.Width(), rectControlBar.Height(), SWP_NOZORDER | SWP_NOACTIVATE, hdwp);
		}

		if (dwAlignment & CBRS_ALIGN_TOP)
		{
			rectCurrBounds.top += rectControlBarScreen.Height();
		}
		else if (dwAlignment & CBRS_ALIGN_BOTTOM)
		{
			rectCurrBounds.bottom -= rectControlBarScreen.Height();
		}
		else if (dwAlignment & CBRS_ALIGN_LEFT)
		{
			rectCurrBounds.left += rectControlBarScreen.Width();
		}
		else
		{
			rectCurrBounds.right -= rectControlBarScreen.Width();
		}

		if (posLastDockBar == pos)
		{
			m_rectOuterEdgeBounds = rectCurrBounds;
		}

	}

	m_rectClientAreaBounds = rectCurrBounds;

	if (m_rectOuterEdgeBounds.IsRectEmpty() || IsOLEContainerMode())
	{
		m_rectOuterEdgeBounds = rectCurrBounds;
	}

	m_pParentWnd->ScreenToClient(m_rectClientAreaBounds);
	m_pParentWnd->ScreenToClient(m_rectOuterEdgeBounds);

	if (m_rectOuterEdgeBounds != rectSaveOuterEdgeBounds)
	{
		HideAutoHidePanes(NULL, TRUE);
	}

	// special processing for autohide dock bars
	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBar);
		if (pBar->IsKindOf(RUNTIME_CLASS(CAutoHideDockSite)))
		{
			CAutoHideDockSite* pSlidingBar = (CAutoHideDockSite*) pBar;
			pSlidingBar->SetOffsetLeft(0);
			pSlidingBar->SetOffsetRight(0);
			CalcPaneOffset((CAutoHideDockSite*) pBar);
		}
	}

	if (bDeferWindowPosHere)
	{
		EndDeferWindowPos(hdwp);
	}

	if (m_pParentWnd->m_pNotifyHook != NULL)
	{
		m_pParentWnd->RecalcLayout();
	}

	m_bAdjustingBarLayout = FALSE;
}

void CDockingManager::CalcPaneOffset(CAutoHideDockSite* pBar)
{
	ASSERT_VALID(pBar);
	DWORD dwBarAlignOrg = pBar->GetCurrentAlignment();
	CRect rectBarOrg;
	pBar->GetWindowRect(rectBarOrg);
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBarNext = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBarNext);
		if (pBarNext->IsKindOf(RUNTIME_CLASS(CAutoHideDockSite)))
		{
			CAutoHideDockSite* pNextSlidingDockBar = DYNAMIC_DOWNCAST(CAutoHideDockSite, pBarNext);

			if (pNextSlidingDockBar == pBar || pNextSlidingDockBar->IsHorizontal() && pBar->IsHorizontal() || !pNextSlidingDockBar->IsHorizontal() && !pBar->IsHorizontal())
			{
				continue;
			}

			CRect rectBarNext;
			pNextSlidingDockBar->GetWindowRect(rectBarNext);
			if (rectBarNext.IsRectEmpty())
			{
				continue;
			}

			DWORD dwBarAlignNext = pNextSlidingDockBar->GetCurrentAlignment();

			if (dwBarAlignOrg & CBRS_ALIGN_LEFT && dwBarAlignNext & CBRS_ALIGN_TOP)
			{
				if (rectBarOrg.top == rectBarNext.bottom)
				{
					pNextSlidingDockBar->SetOffsetLeft(rectBarOrg.Width());
				}

				if (rectBarOrg.right == rectBarNext.left)
				{
					pBar->SetOffsetLeft(rectBarNext.Height());
				}
			}
			else if (dwBarAlignOrg & CBRS_ALIGN_TOP && dwBarAlignNext & CBRS_ALIGN_RIGHT)
			{
				if (rectBarOrg.right == rectBarNext.left)
				{
					pNextSlidingDockBar->SetOffsetLeft(rectBarOrg.Height());
				}

				if (rectBarOrg.bottom == rectBarNext.top)
				{
					pBar->SetOffsetRight(rectBarNext.Width());
				}
			}
			else if (dwBarAlignOrg & CBRS_ALIGN_RIGHT && dwBarAlignNext & CBRS_ALIGN_BOTTOM)
			{
				if (rectBarOrg.bottom == rectBarNext.top)
				{
					pNextSlidingDockBar->SetOffsetRight(rectBarOrg.Width());
				}

				if (rectBarOrg.left == rectBarNext.right)
				{
					pBar->SetOffsetRight(rectBarOrg.Width());
				}
			}
			else if (dwBarAlignOrg & CBRS_ALIGN_LEFT && dwBarAlignNext & CBRS_ALIGN_BOTTOM)
			{
				if (rectBarOrg.bottom == rectBarNext.top)
				{
					pNextSlidingDockBar->SetOffsetLeft(rectBarOrg.Width());
				}

				if (rectBarOrg.right == rectBarNext.left)
				{
					pBar->SetOffsetRight(rectBarNext.Height());
				}
			}
		}
	}
}

void CDockingManager::AlignByRect(const CRect& rectToAlignBy, CRect& rectResult, DWORD dwAlignment, BOOL bHorizontal, BOOL bResizable)
{
	ASSERT_VALID(this);

	int nCurrWidth = rectResult.Width();
	int nCurrHeight = rectResult.Height();

	DWORD dwCurrAlignment = dwAlignment & CBRS_ALIGN_ANY;
	switch (dwCurrAlignment)
	{
	case CBRS_ALIGN_LEFT:
		rectResult.TopLeft() = rectToAlignBy.TopLeft();
		rectResult.bottom = rectResult.top + rectToAlignBy.Height();
		rectResult.right = rectResult.left + nCurrWidth;
		break;

	case CBRS_ALIGN_TOP:
		rectResult.TopLeft() = rectToAlignBy.TopLeft();
		rectResult.right = rectResult.left + rectToAlignBy.Width();
		rectResult.bottom = rectResult.top + nCurrHeight;
		break;

	case CBRS_ALIGN_RIGHT:
		rectResult.BottomRight() = rectToAlignBy.BottomRight();
		rectResult.top = rectResult.bottom - rectToAlignBy.Height();
		rectResult.left = rectResult.right - nCurrWidth;
		break;
	case CBRS_ALIGN_BOTTOM:
		rectResult.BottomRight() = rectToAlignBy.BottomRight();
		rectResult.left = rectResult.right - rectToAlignBy.Width();
		rectResult.top = rectResult.bottom - nCurrHeight;
		break;
	}

	if (bHorizontal)
	{
		int nDelta = rectResult.Width() - rectToAlignBy.Width();
		if (nDelta != 0)
		{
			rectResult.right += nDelta;
		}

		nDelta = rectResult.Height() - rectToAlignBy.Height();
		if (nDelta > 0 && bResizable)
		{
			if (dwCurrAlignment & CBRS_ALIGN_TOP)
			{
				rectResult.bottom -= nDelta;
			}
			else if (dwCurrAlignment & CBRS_ALIGN_BOTTOM)
			{
				rectResult.top += nDelta;
			}
		}
	}
	else
	{
		int nDelta = rectResult.Height() - rectToAlignBy.Height();
		if (nDelta != 0)
		{
			rectResult.bottom += nDelta;
		}

		nDelta = rectResult.Width() - rectToAlignBy.Width();
		if (rectResult.Width() > rectToAlignBy.Width() && bResizable)
		{
			if (dwCurrAlignment & CBRS_ALIGN_LEFT)
			{
				rectResult.right -= nDelta;
			}
			else if (dwCurrAlignment & CBRS_ALIGN_RIGHT)
			{
				rectResult.left += nDelta;
			}
		}
	}
}

BOOL CDockingManager::SaveState(LPCTSTR lpszProfileName, UINT uiID)
{
	ASSERT_VALID(this);

	m_bSavingState = TRUE;

	CString strProfileName = ::AFXGetRegPath(strDockingManagerProfile, lpszProfileName);

	BOOL bResult = FALSE;

	CString strSection;
	strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, uiID);

	POSITION pos = NULL;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBarNext = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBarNext);

		if (pBarNext->IsKindOf(RUNTIME_CLASS(CDockablePane)) || pBarNext->IsKindOf(RUNTIME_CLASS(CPane)) && !pBarNext->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
		{
			pBarNext->SaveState(lpszProfileName);
		}
	}

	for (pos = m_lstAutoHideBars.GetHeadPosition(); pos != NULL;)
	{
		CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, m_lstControlBars.GetNext(pos));

		if (pSlider != NULL && pSlider->IsDefault())
		{
			CObList lstBars;
			CDockablePane* pNextBar = (CDockablePane*) pSlider->GetFirstPane();
			if (pNextBar != NULL)
			{
				pNextBar->SaveState(lpszProfileName);
			}
		}
	}

	for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));
		ASSERT_VALID(pWnd);
		pWnd->SaveState(lpszProfileName);
	}

	try
	{
		CMemFile file;
		{
			CArchive ar(&file, CArchive::store);

			Serialize(ar);
			ar.Flush();
		}

		UINT uiDataSize = (UINT) file.GetLength();
		LPBYTE lpbData = file.Detach();

		if (lpbData != NULL)
		{
			CSettingsStoreSP regSP;
			CSettingsStore& reg = regSP.Create(FALSE, FALSE);

			if (reg.CreateKey(strSection))
			{
				bResult = reg.Write(AFX_REG_ENTRY_DOCKING_PANE_AND_PANEDIVIDERS, lpbData, uiDataSize);
			}

			free(lpbData);
		}
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CDockingManager::SaveState()!\n"));
	}

	m_bSavingState = FALSE;
	return bResult;
}

BOOL CDockingManager::LoadState(LPCTSTR lpszProfileName, UINT uiID)
{
	ASSERT_VALID(this);

	CString strProfileName = ::AFXGetRegPath(strDockingManagerProfile, lpszProfileName);

	BOOL bResult = FALSE;

	CString strSection;
	strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, uiID);

	POSITION pos = NULL;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBarNext = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBarNext);

		if (pBarNext->IsKindOf(RUNTIME_CLASS(CDockablePane)) || pBarNext->IsKindOf(RUNTIME_CLASS(CPane)) && !pBarNext->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
		{
			pBarNext->LoadState(lpszProfileName);
		}
	}

	for (pos = m_lstAutoHideBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*)m_lstAutoHideBars.GetNext(pos);

		ASSERT_VALID(pBar);
		if (pBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)))
		{
			CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, pBar);
			// SLIDER CONTAINS ONLY ONE BAR IN AUTOHIDE MODE
			pBar = (CBasePane*) pSlider->GetFirstPane();
			if (pBar != NULL && pBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
			{
				pBar->LoadState(lpszProfileName);
			}
		}
	}

	for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));

		ASSERT_VALID(pWnd);

		pWnd->LoadState(lpszProfileName);
	}

	LPBYTE lpbData = NULL;
	UINT uiDataSize;

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	if (!reg.Read(AFX_REG_ENTRY_DOCKING_PANE_AND_PANEDIVIDERS, &lpbData, &uiDataSize))
	{
		return FALSE;
	}

	try
	{
		CMemFile file(lpbData, uiDataSize);
		CArchive ar(&file, CArchive::load);

		Serialize(ar);
		bResult = TRUE;
		m_bDisableSetDockState = FALSE;
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CDockingManager::LoadState!\n"));
		m_bDisableSetDockState = TRUE;
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CDockingManager::LoadState()!\n"));

		// destroy loaded sliders(docking control bars are loaded by ID's and have
		// been already created by application

		for (pos = m_lstLoadedBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pNextBar = (CBasePane*) m_lstLoadedBars.GetNext(pos);
			if (pNextBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)))
			{
				pNextBar->DestroyWindow();
			}
			else
			{
				pNextBar->SetRestoredFromRegistry(FALSE);
			}
		}

		m_lstLoadedBars.RemoveAll();
		m_bDisableSetDockState = TRUE;
	}
	catch(...)
	{
		// destroy loaded sliders(docking control bars are loaded by ID's and have
		// been already created by application

		for (pos = m_lstLoadedBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pNextBar = (CBasePane*) m_lstLoadedBars.GetNext(pos);
			if (pNextBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)))
			{
				pNextBar->DestroyWindow();
			}
			else
			{
				pNextBar->SetRestoredFromRegistry(FALSE);
			}
		}

		m_lstLoadedBars.RemoveAll();
		m_bDisableSetDockState = TRUE;
	}

	if (lpbData != NULL)
	{
		delete [] lpbData;
	}

	return bResult;

}

void CDockingManager::Serialize(CArchive& ar)
{
	// calculate or load the number of docking control bars and sliders
	int nCBCount = 0;
	int nNonFloatingBarCount = 0;

	if (ar.IsStoring())
	{
		POSITION pos = NULL;

		// get rid on non-valid empty tabbed bars
		for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CBaseTabbedPane* pNextBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, m_lstControlBars.GetAt(pos));

			if (pNextBar != NULL && pNextBar->GetTabsNum() == 0 && pNextBar->CanFloat())
			{
				m_lstControlBars.GetPrev(pos);
				pNextBar->UndockPane(TRUE);
				if (pos == NULL)
				{
					pos = m_lstControlBars.GetHeadPosition();
				}
			}
			if (pos != NULL)
			{
				m_lstControlBars.GetNext(pos);
			}
		}

		for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
		{
			CPaneFrameWnd* pNextMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));

			if (pNextMiniFrame != NULL)
			{
				pNextMiniFrame->RemoveNonValidPanes();
			}
		}

		for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pNextBar = (CBasePane*) m_lstControlBars.GetNext(pos);

			if (pNextBar->IsKindOf(RUNTIME_CLASS(CDockablePane)) && pNextBar->CanFloat() || pNextBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)) &&
				((CPaneDivider*) pNextBar)->DoesContainFloatingPane())
			{
				nCBCount++;
			}
			else
			{
				// static bar that may contain detachable/floating tabs
				if (pNextBar->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))
				{
					nNonFloatingBarCount++;
				}
			}
		}

		ar << nNonFloatingBarCount;

		for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pNextBar = (CBasePane*) m_lstControlBars.GetNext(pos);
			if (!pNextBar->CanFloat() && pNextBar->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))
			{
				CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pNextBar);
				if (pTabbedBar != NULL)
				{
					ASSERT_VALID(pTabbedBar->GetUnderlyingWindow());
					ar << pTabbedBar->GetDlgCtrlID();
					pTabbedBar->GetUnderlyingWindow()->Serialize(ar);
				}
			}
		}

		ar << nCBCount;

		// START from the tail, so the sliders and embedded containers
		// will be stored bedore their control bars

		for (pos = m_lstControlBars.GetTailPosition(); pos != NULL;)
		{
			CBasePane* pNextBar = (CBasePane*) m_lstControlBars.GetPrev(pos);
			ASSERT_VALID(pNextBar);

			if (pNextBar->IsKindOf(RUNTIME_CLASS(CDockablePane)) && pNextBar->CanFloat())
			{
				int nBarID = pNextBar->GetDlgCtrlID();
				// write docking control bar tag and ID

				if (nBarID != -1)
				{
					ar << TRUE;
					ar << nBarID;
				}
				else
				{
					// this is tab control bar - write its tabbed bar ids
					CBaseTabbedPane* pTabBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pNextBar);
					ASSERT_VALID(pTabBar);

					// use first child bar as identifier of the tab control bar
					CWnd* pWnd  = pTabBar->FindBarByTabNumber(0);

					// if pWnd is NULL - write nothing! because we do not allow empty tabbed
					// bars
					if (pWnd != NULL)
					{
						int nTabbedBarID = pWnd->GetDlgCtrlID();
						ASSERT(nTabbedBarID != -1);

						ar << TRUE;
						ar << nBarID;
						ar << nTabbedBarID;
					}
				}
				continue;
			}
			else if (pNextBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)) &&((CPaneDivider*) pNextBar)->DoesContainFloatingPane())
			{
				// write slider tag and serialize the slider
				ar << FALSE;

				CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, pNextBar);
				ASSERT_VALID(pSlider);

				pSlider->Serialize(ar);
			}
		}

		int nCountMiniFrames = 0;

		for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
		{
			CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));
			ASSERT_VALID(pWnd);

			if (pWnd->GetPaneCount() > 0)
			{
				nCountMiniFrames++;
			}
		}

		ar << nCountMiniFrames;

		for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
		{
			CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));
			ASSERT_VALID(pWnd);
			if (pWnd->GetPaneCount() > 0)
			{
				ar << pWnd;
			}
		}

		// serialize autohide bars

		ar <<(int) m_lstAutoHideBars.GetCount();

		for (pos = m_lstAutoHideBars.GetHeadPosition(); pos != NULL;)
		{
			AFX_AUTOHIDE_DOCKSITE_SAVE_INFO ahSaveInfo;

			CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, m_lstAutoHideBars.GetNext(pos));

			if (pSlider == NULL)
			{
				ASSERT(FALSE);
				continue;
			}

			ahSaveInfo.m_pSavedBar = DYNAMIC_DOWNCAST(CDockablePane, pSlider->GetFirstPane());

			if (ahSaveInfo.m_pSavedBar != NULL)
			{
				ahSaveInfo.Serialize(ar);
			}
		}

		// serialize MDI Tabbed Bars
		ar <<(int) m_lstHiddenMDITabbedBars.GetCount();

		for (pos = m_lstHiddenMDITabbedBars.GetHeadPosition(); pos != NULL;)
		{
			HWND hwnd = m_lstHiddenMDITabbedBars.GetNext(pos);
			CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, CWnd::FromHandlePermanent(hwnd));
			if (pNextBar != NULL)
			{
				ar <<(int) pNextBar->GetDlgCtrlID();
			}
			else
			{
				ar <<(int) -1;
			}
		}
	}
	else
	{
		m_lstLoadedBars.RemoveAll();
		m_lstNonFloatingBars.RemoveAll();
		m_lstLoadedAutoHideBarIDs.RemoveAll();
		m_lstLoadedMiniFrames.RemoveAll();

		UINT nBarID = (UINT) -1;

		CList<UINT, UINT&> lstNotFoundBars;

		ar >> nNonFloatingBarCount;

		int i = 0;

		for (i = 0; i < nNonFloatingBarCount; i++)
		{
			ar >> nBarID;
			CBaseTabbedPane* pBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, FindPaneByID(nBarID, TRUE));
			if (pBar != NULL)
			{
				pBar->GetUnderlyingWindow()->Serialize(ar);
				m_lstNonFloatingBars.AddTail(pBar);
			}
		}

		ar >> nCBCount;

		BOOL bIsDockingControlBar = FALSE;

		CPaneDivider* pCurrentDefaultSlider = NULL;

		// the list was stored from the tail(to store sliders first)
		// therefore we need to add head
		for (i = 0; i < nCBCount; i++)
		{
			ar >> bIsDockingControlBar;

			if (bIsDockingControlBar)
			{
				ar >> nBarID;

				CDockablePane* pBar = NULL;
				if (nBarID != -1)
				{
					pBar = DYNAMIC_DOWNCAST(CDockablePane, FindPaneByID(nBarID, TRUE));
				}
				else
				{
					// tab docking bar - load first child bar
					ar >> nBarID;

					if (pCurrentDefaultSlider != NULL)
					{
						pBar = pCurrentDefaultSlider->FindTabbedPane(nBarID);
					}
				}

				if (pBar != NULL)
				{
					ASSERT_VALID(pBar);

					if (pBar->IsAutoHideMode())
					{
						pBar->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
					}

					if (pCurrentDefaultSlider != NULL)
					{
						pBar->SetRestoredDefaultPaneDivider(pCurrentDefaultSlider->m_hWnd);
						pBar->SetPaneAlignment(pCurrentDefaultSlider->GetCurrentAlignment());
					}

					m_lstLoadedBars.AddHead(pBar);
				}
				else
				{
					lstNotFoundBars.AddTail(nBarID);
				}
			}
			else
			{
				pCurrentDefaultSlider = DYNAMIC_DOWNCAST(CPaneDivider, CPaneDivider::m_pSliderRTC->CreateObject());
				ASSERT_VALID(pCurrentDefaultSlider);

				pCurrentDefaultSlider->Init(TRUE, m_pParentWnd);
				pCurrentDefaultSlider->Serialize(ar);

				m_lstLoadedBars.AddHead(pCurrentDefaultSlider);

				POSITION posSave = NULL;
				for (POSITION posNotFound = lstNotFoundBars.GetHeadPosition(); posNotFound != NULL;)
				{
					posSave = posNotFound;
					UINT nNextBarID = lstNotFoundBars.GetNext(posNotFound);
					CDockablePane* pNextBar = pCurrentDefaultSlider->FindTabbedPane(nNextBarID);
					if (pNextBar != NULL)
					{
						ASSERT_VALID(pNextBar);

						if (pNextBar->IsAutoHideMode())
						{
							pNextBar->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
						}

						pNextBar->SetRestoredDefaultPaneDivider(pCurrentDefaultSlider->m_hWnd);
						pNextBar->SetPaneAlignment(pCurrentDefaultSlider->GetCurrentAlignment());
						m_lstLoadedBars.AddHead(pNextBar);
						lstNotFoundBars.RemoveAt(posSave);
					}
				}
			}
		}

		int nMiniFrameCount = 0;

		ar >> nMiniFrameCount;

		for (i = 0; i < nMiniFrameCount; i++)
		{
			CPaneFrameWnd* pWnd = NULL;
			CPaneFrameWnd::m_pParentWndForSerialize = m_pParentWnd;
			ar >> pWnd;
			m_lstLoadedMiniFrames.AddTail(pWnd);
		}

		int nAHBarCount = 0;
		ar >> nAHBarCount;

		for (i = 0; i < nAHBarCount; i++)
		{
			AFX_AUTOHIDE_DOCKSITE_SAVE_INFO info;
			info.Serialize(ar);
			m_lstLoadedAutoHideBarIDs.AddTail(info);
		}

		int nMdiTabbedBarsCount = 0;
		ar >> nMdiTabbedBarsCount;
		
		for (i = 0; i < nMdiTabbedBarsCount; i++)
		{
			int nMDITabbedBarID = -1;
			ar >> nMDITabbedBarID;
			if (nMDITabbedBarID != -1)
			{
				CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, FindPaneByID(nMDITabbedBarID, TRUE));
				if (pBar != NULL)
				{
					if (pBar->IsFloating())
					{
						CPaneFrameWnd* pMiniFrame = pBar->GetParentMiniFrame();
						if (pMiniFrame != NULL)
						{
							pMiniFrame->RemovePane(pBar);
						}

						pBar->SetParent(m_pParentWnd);
					}
					else if (pBar->IsAutoHideMode())
					{
						pBar->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
					}
					else if (pBar->IsTabbed())
					{
						CBaseTabbedPane* pTabBar = pBar->GetParentTabbedPane();
						ASSERT_VALID(pTabBar);
						pBar->SetParent(m_pParentWnd);
						pTabBar->RemovePane(pBar);
					}
					else
					{
						pBar->UndockPane();
					}
					pBar->ShowWindow(FALSE);
					AddHiddenMDITabbedBar(pBar);
					pBar->SetMDITabbed(TRUE);
				}
			}
		}
	}
}

void CDockingManager::SetDockState()
{
	if (m_bDisableSetDockState || m_bDisableRestoreDockState)
	{
		return;
	}

	if (m_lstLoadedBars.IsEmpty() && m_lstLoadedMiniFrames.IsEmpty() && m_lstNonFloatingBars.IsEmpty() && m_lstLoadedAutoHideBarIDs.IsEmpty()  && m_lstControlBars.IsEmpty())
	{
		return;
	}

	m_bRestoringDockState = TRUE;

	m_bDisableRecalcLayout = TRUE;

	POSITION pos = NULL;
	CObList lstAutoHideBars;

	// set all autohide bars to the regular mode
	for (pos = m_lstAutoHideBars.GetHeadPosition(); pos != NULL;)
	{
		CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, m_lstAutoHideBars.GetNext(pos));
		if (pSlider != NULL)
		{
			CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, pSlider->GetFirstPane());
			if (pBar != NULL && pBar->GetAutoHideToolBar() != NULL && pBar->GetAutoHideToolBar()->m_bFirstInGroup)
			{
				lstAutoHideBars.AddTail(pBar);
			}
		}
	}

	for (pos = lstAutoHideBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, lstAutoHideBars.GetNext(pos));
		pBar->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
	}

	for (pos = m_lstLoadedBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, m_lstLoadedBars.GetNext(pos));
		if (pNextBar != NULL)
		{
			pNextBar->RestoreDefaultPaneDivider();
		}
	}

	// set up miniframes - the original list may be modified by SetDockState
	CObList lstMiniFrames;
	lstMiniFrames.AddTail(&m_lstLoadedMiniFrames);

	for (pos = lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, lstMiniFrames.GetNext(pos));
		ASSERT_VALID(pWnd);

		pWnd->SetWindowPos(NULL, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
		pWnd->SetDockState(this);
	}

	CObList lstAllBars;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBarNext = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBarNext);

		if (pBarNext->IsKindOf(RUNTIME_CLASS(CDockSite)))
		{
			CDockSite* pDockBar = (CDockSite*)DYNAMIC_DOWNCAST(CDockSite, pBarNext);

			ASSERT_VALID(pDockBar);
			lstAllBars.AddTail((CObList*)&pDockBar->GetPaneList());
		}
		else if (pBarNext->IsKindOf(RUNTIME_CLASS(CPane)))
		{
			if (pBarNext->CanFloat())
			{
				lstAllBars.AddTail(pBarNext);
			}
			else if (pBarNext->IsRestoredFromRegistry())
			{
				// set the size of non-floating bar right now
				CRect rect = ((CPane*) pBarNext)->m_rectSavedDockedRect;
				pBarNext->SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE);
				pBarNext->ShowPane(pBarNext->GetRecentVisibleState(), TRUE, FALSE);
			}
		}
	}

	// take toolbars from all originally created miniframes
	for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));

		if (pWnd != NULL)
		{
			CMFCBaseToolBar* pToolbar = DYNAMIC_DOWNCAST(CMFCBaseToolBar, pWnd->GetPane());
			if (pToolbar != NULL)
			{
				lstAllBars.AddTail(pToolbar);
			}
		}
	}

	// we must float all bars first
	for (pos = lstAllBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) lstAllBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if (pNextBar->IsRestoredFromRegistry())
		{
			if (pNextBar->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))
			{
				// contained bars will be redocked later
				// the bar itself should be destroyed
			}
			else
			{
				pNextBar->FloatPane(pNextBar->m_recentDockInfo.m_rectRecentFloatingRect, DM_SHOW, false);
			}
		}
	}

	// redock at recent rows regular control bars(toolbars and so on)
	for (pos = lstAllBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) lstAllBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if (pNextBar->IsRestoredFromRegistry() && !pNextBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
		{
			pNextBar->SetDockState(this);
			pNextBar->UpdateVirtualRect();
		}
	}

	// add docking control bars and sliders(remove from miniframe first)
	for (pos = m_lstLoadedBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pNextBar = (CBasePane*) m_lstLoadedBars.GetNext(pos);
		ASSERT_VALID(this);

		if (pNextBar->IsTabbed())
		{
			CMFCBaseTabCtrl* pTabWnd = (CMFCBaseTabCtrl*) pNextBar->GetParent();
			CBaseTabbedPane* pTabBar = (CBaseTabbedPane*) pTabWnd->GetParent();
			ASSERT_VALID(pTabBar);
			pNextBar->SetParent(m_pParentWnd);
			pTabBar->RemovePane(pNextBar);
			if (pNextBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
			{
				((CDockablePane*) pNextBar)->EnableGripper(TRUE);
			}

			pNextBar->ShowWindow(SW_SHOW);
		}

		CPaneFrameWnd* pMiniFrame = pNextBar->GetParentMiniFrame();
		if (pMiniFrame != NULL)
		{
			pMiniFrame->RemovePane(pNextBar);
		}

		pNextBar->SetParent(m_pParentWnd);

		if (pNextBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
		{
			CDockablePane* pDockingBar = DYNAMIC_DOWNCAST(CDockablePane, pNextBar);
			CRect rect = pDockingBar->m_rectSavedDockedRect;

			pDockingBar->SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE);

			BOOL bShow = pDockingBar->GetRecentVisibleState();
			pDockingBar->ShowWindow(bShow ? SW_SHOWNORMAL : SW_HIDE);

			CPaneDivider* pDefaultSlider = pDockingBar->GetDefaultPaneDivider();

			if (pDefaultSlider != NULL)
			{
				pDockingBar->SetPaneAlignment(pDefaultSlider->GetCurrentAlignment());
				pDefaultSlider->OnShowPane(pDockingBar, bShow);
			}

			if (pDockingBar->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))
			{
				BOOL bLeftBar = FALSE;

				if (pDefaultSlider != NULL)
				{
					CPaneContainer* pContainer = pDefaultSlider->FindPaneContainer(pDockingBar, bLeftBar);

					ASSERT(pContainer != NULL);

					CList<UINT, UINT>* pListBarIDs = pContainer->GetAssociatedSiblingPaneIDs(pDockingBar);

					if (pListBarIDs != NULL)
					{
						for (POSITION posList = pListBarIDs->GetHeadPosition(); posList != NULL;)
						{
							UINT nIDNext = pListBarIDs->GetNext(posList);
							CDockablePane* pBarToAttach = DYNAMIC_DOWNCAST(CDockablePane, FindPaneByID(nIDNext, TRUE));

							if (pBarToAttach != NULL)
							{
								if (pBarToAttach->IsTabbed())
								{
									CMFCBaseTabCtrl* pTabWnd = (CMFCBaseTabCtrl*) pBarToAttach->GetParent();
									CBaseTabbedPane* pTabBar = (CBaseTabbedPane*)pTabWnd->GetParent();
									ASSERT_VALID(pTabBar);

									pBarToAttach->SetParent(m_pParentWnd);
									pTabBar->RemovePane(pBarToAttach);
								}
								else if (pBarToAttach->IsAutoHideMode())
								{
									pBarToAttach->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
								}

								((CDockablePane*) pBarToAttach)->AttachToTabWnd(pDockingBar, DM_UNKNOWN, FALSE);
							}
						}
					}
					if (((CBaseTabbedPane*)pDockingBar)->GetTabsNum() == 0)
					{
						continue;
					}

					((CBaseTabbedPane*)pDockingBar)->ApplyRestoredTabInfo();
					pDockingBar->RecalcLayout();
				}
			}
		}
	}

	m_lstControlBars.AddTail(&m_lstLoadedBars);

	m_bDisableRecalcLayout = FALSE;
	AdjustDockingLayout();

	for (pos = m_lstLoadedAutoHideBarIDs.GetHeadPosition(); pos != NULL;)
	{
		AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& info = m_lstLoadedAutoHideBarIDs.GetNext(pos);
		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, FindPaneByID(info.m_nBarID, TRUE));
		if (pBar != NULL)
		{
			if (pBar->IsFloating())
			{
				pBar->DockToFrameWindow(info.m_dwBarAlignment);
			}
			else if (pBar->IsAutoHideMode())
			{
				pBar->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
			}
			else if (pBar->IsTabbed())
			{
				CMFCBaseTabCtrl* pTabWnd = (CMFCBaseTabCtrl*) pBar->GetParent();
				CBaseTabbedPane* pTabBar = (CBaseTabbedPane*)pTabWnd->GetParent();
				ASSERT_VALID(pTabBar);

				pBar->SetParent(m_pParentWnd);
				pTabBar->RemovePane(pBar);
				pBar->EnableGripper(TRUE);
				pBar->DockToFrameWindow(info.m_dwBarAlignment);
			}
			else
			{
				pBar->DockToFrameWindow(info.m_dwBarAlignment);
			}

			pBar->SetWindowPos(NULL, info.m_rectBar.left, info.m_rectBar.top, info.m_rectBar.Width(), info.m_rectBar.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
			CMFCAutoHideBar* pNewToolbar = pBar->SetAutoHideMode(TRUE, info.m_dwBarAlignment, NULL, FALSE);

			if (pNewToolbar != NULL)
			{
				pNewToolbar->m_bActiveInGroup = info.m_bActiveInGroup;
				pNewToolbar->m_bFirstInGroup = info.m_bFirstInGroup;
				pNewToolbar->m_bLastInGroup = info.m_bLastInGroup;

				info.m_pSavedBar = pBar;
				info.m_pSavedBar->m_pAutoHideBar->SetRecentVisibleState(info.m_bIsVisible); // used by dockbar when the frame is loaded
			}
		}
	}

	for (pos = m_lstLoadedAutoHideBarIDs.GetHeadPosition(); pos != NULL;)
	{
		AFX_AUTOHIDE_DOCKSITE_SAVE_INFO& info = m_lstLoadedAutoHideBarIDs.GetNext(pos);

		if (info.m_pSavedBar != NULL && info.m_pSavedBar->IsHideInAutoHideMode())
		{
			info.m_pSavedBar->ShowPane(info.m_bIsVisible, FALSE, FALSE);
		}
	}

	for (pos = m_lstNonFloatingBars.GetHeadPosition(); pos != NULL;)
	{
		CBaseTabbedPane* pBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, m_lstNonFloatingBars.GetNext(pos));
		if (pBar != NULL)
		{
			pBar->ApplyRestoredTabInfo(TRUE);
		}
	}

	CObList lstCopy;
	lstCopy.AddTail(&m_lstControlBars);

	// check for empty sliders and tabbed bars
	for (pos = lstCopy.GetTailPosition(); pos != NULL;)
	{
		CObject* pBar = lstCopy.GetPrev(pos);
		CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, pBar);

		if (pSlider != NULL)
		{
			pSlider->NotifyAboutRelease();
			continue;
		}

		CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pBar);
		if (pTabbedBar != NULL && pTabbedBar->GetTabsNum() == 0 && pTabbedBar->CanFloat())
		{
			pTabbedBar->UndockPane(TRUE);
			pTabbedBar->DestroyWindow();
		}
	}

	RecalcLayout();

	m_lstLoadedBars.RemoveAll();
	m_lstLoadedMiniFrames.RemoveAll();
	m_lstNonFloatingBars.RemoveAll();

	m_bRestoringDockState = FALSE;
}

void AFX_AUTOHIDE_DOCKSITE_SAVE_INFO::Serialize(CArchive& ar)
{
	if (ar.IsLoading())
	{
		ar >> m_nBarID;
		ar >> m_dwBarAlignment;
		ar >> m_bIsVisible;

		int nSiblingCount = 0;
		ar >> nSiblingCount;

		for (int i = 0; i < nSiblingCount; i++)
		{
			UINT nSiblingBarID = (UINT)-1;
			ar >> nSiblingBarID;
			if (nSiblingBarID != -1) // can't be tabbed or so on
			{
				m_lstSiblingBars.AddHead(nSiblingBarID);
			}
		}
		ar >> m_rectBar;

		ar >> m_bFirstInGroup;
		ar >> m_bLastInGroup;
		ar >> m_bActiveInGroup;
	}
	else
	{
		ENSURE(m_pSavedBar != NULL);

		ar << m_pSavedBar->GetDlgCtrlID();
		ar << m_pSavedBar->GetCurrentAlignment();
		ar <<(m_pSavedBar->IsHideInAutoHideMode() ? m_pSavedBar->IsVisible() : TRUE);

		CList<UINT, UINT&> lstSiblings;
		m_pSavedBar->GetRecentSiblingPaneInfo(lstSiblings);

		int nSiblingCount = (int) lstSiblings.GetCount();
		ar << nSiblingCount;

		for (POSITION pos = lstSiblings.GetHeadPosition(); pos != NULL;)
		{
			UINT nSiblingBarID = lstSiblings.GetNext(pos);
			ar << nSiblingBarID;
		}
		m_pSavedBar->GetWindowRect(&m_rectBar);
		if (m_rectBar.IsRectEmpty())
		{
			ar << m_pSavedBar->GetAHRestoredRect();
		}
		else
		{
			ar << m_rectBar;
		}

		ar << m_pSavedBar->GetAutoHideToolBar()->m_bFirstInGroup;
		ar << m_pSavedBar->GetAutoHideToolBar()->m_bLastInGroup;
		ar << m_pSavedBar->GetAutoHideToolBar()->m_bActiveInGroup;
	}
}

void CDockingManager::HideForPrintPreview(const CObList& lstBars)
{
	for (POSITION pos = lstBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*) lstBars.GetNext(pos);
		ASSERT_VALID(pBar);

		ASSERT_VALID(pBar);

		if (m_bHideDockingBarsInContainerMode || !IsOLEContainerMode())
		{
			if (pBar->IsVisible() && pBar->HideInPrintPreviewMode())
			{
				pBar->ShowPane(FALSE, TRUE, FALSE);
				m_lstBarsHiddenInPreview.AddTail(pBar);
			}

			for (POSITION posList = m_lstMiniFrames.GetHeadPosition(); posList != NULL;)
			{
				CWnd* pWnd = (CWnd*) m_lstMiniFrames.GetNext(posList);
				ASSERT_VALID(pWnd);

				if (pWnd->IsWindowVisible())
				{
					pWnd->ShowWindow(SW_HIDE);
					m_lstBarsHiddenInPreview.AddTail(pWnd);
				}
			}
		}
		else
		{
			if (pBar->IsVisible() && pBar->HideInPrintPreviewMode() && !pBar->IsKindOf(RUNTIME_CLASS(CDockablePane)) && !pBar->IsKindOf(RUNTIME_CLASS(CAutoHideDockSite)) && !pBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)))
			{
				pBar->ShowPane(FALSE, TRUE, FALSE);
				m_lstBarsHiddenInPreview.AddTail(pBar);
			}
		}
	}
}

void CDockingManager::SetPrintPreviewMode(BOOL bPreview, CPrintPreviewState* /*pState*/)
{
	ASSERT_VALID(this);

	if (bPreview)
	{
		if (m_bIsPrintPreviewMode || IsOLEContainerMode())
		{
			m_bIsPrintPreviewMode = TRUE;
			return;
		}
		m_lstBarsHiddenInPreview.RemoveAll();

		// Set visibility of standard ControlBars
		if (m_bHideDockingBarsInContainerMode || !IsOLEContainerMode())
		{
			HideForPrintPreview(m_lstAutoHideBars);
		}
		HideForPrintPreview(m_lstControlBars);
	}
	else
	{
		if (!m_bIsPrintPreviewMode || IsOLEContainerMode())
		{
			m_bIsPrintPreviewMode = FALSE;
			return;
		}
		for (POSITION pos = m_lstBarsHiddenInPreview.GetHeadPosition(); pos != NULL;)
		{
			CWnd* pWnd = DYNAMIC_DOWNCAST(CWnd, m_lstBarsHiddenInPreview.GetNext(pos));
			if (pWnd == NULL)
			{
				ASSERT(FALSE);
				continue;
			}
			ASSERT_VALID(pWnd);

			if (pWnd->IsKindOf(RUNTIME_CLASS(CBasePane)))
			{
				CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, pWnd);
				ASSERT_VALID(pBar);
				pBar->ShowPane(TRUE, TRUE, FALSE);
			}
			else
			{
				pWnd->ShowWindow(SW_SHOWNOACTIVATE);
			}

		}
	}

	m_bIsPrintPreviewMode = bPreview;
}

CPaneFrameWnd* CDockingManager::FrameFromPoint(CPoint pt, CPaneFrameWnd* pFrameToExclude, BOOL bFloatMultiOnly) const
{
	for (POSITION pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));
		ASSERT_VALID(pWnd);

		if (!pWnd->IsWindowVisible() || pWnd == pFrameToExclude)
		{
			continue;
		}

		if (!pWnd->IsKindOf(RUNTIME_CLASS(CMultiPaneFrameWnd)) && bFloatMultiOnly)
		{
			continue;
		}

		CRect rect;
		pWnd->GetWindowRect(rect);

		if (rect.PtInRect(pt))
		{
			return pWnd;
		}
	}

	return NULL;
}

BOOL CDockingManager::SendMessageToMiniFrames(UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	for (POSITION pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));

		ASSERT_VALID(pWnd);
		pWnd->SendMessage(uMessage, wParam, lParam);
	}

	return TRUE;
}

void CDockingManager::LockUpdate(BOOL bLock)
{
	if (bLock && m_pSDManager != NULL && m_pSDManager->IsStarted())
	{
		return;
	}

	m_bLockUpdate = bLock;

	bLock ? m_pParentWnd->LockWindowUpdate() : m_pParentWnd->UnlockWindowUpdate();

	POSITION pos = NULL;

	for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_lstMiniFrames.GetNext(pos));

		pWnd->ValidateRect(NULL);
		pWnd->UpdateWindow();

		ASSERT_VALID(pWnd);
		bLock ? pWnd->LockWindowUpdate() : pWnd->UnlockWindowUpdate();
	}

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CWnd* pWnd = (CWnd*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pWnd);

		pWnd->ValidateRect(NULL);
		pWnd->UpdateWindow();

		bLock ? pWnd->LockWindowUpdate() : pWnd->UnlockWindowUpdate();
	}
}

void CDockingManager::GetPaneList(CObList& lstBars, BOOL bIncludeAutohide, CRuntimeClass* pRTCFilter, BOOL bIncludeTabs)
{
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pBar);

		if (pBar->IsKindOf(RUNTIME_CLASS(CDockSite)))
		{
			CDockSite* pDockBar = DYNAMIC_DOWNCAST(CDockSite, pBar);
			ASSERT_VALID(pDockBar);

			const CObList& lstDockedBars = pDockBar->GetPaneList();

			for (POSITION posList = lstDockedBars.GetHeadPosition(); posList != NULL;)
			{
				CBasePane* pDockedBar = DYNAMIC_DOWNCAST(CBasePane, lstDockedBars.GetNext(posList));
				ASSERT_VALID(pDockedBar);

				if (pRTCFilter == NULL || pDockedBar->GetRuntimeClass() == pRTCFilter)
				{
					lstBars.AddTail(pDockedBar);
				}
			}
		}
		else if (pBar->IsKindOf(RUNTIME_CLASS(CTabbedPane)) && bIncludeTabs)
		{
			CTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CTabbedPane, pBar);
			ASSERT_VALID(pTabbedBar);
			pTabbedBar->GetPaneList(lstBars, pRTCFilter);
		}

		if (pRTCFilter == NULL || pBar->GetRuntimeClass() == pRTCFilter)
		{
			lstBars.AddTail(pBar);
		}
	}

	if (bIncludeAutohide)
	{
		for (POSITION pos = m_lstAutoHideBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, m_lstAutoHideBars.GetNext(pos));
			ASSERT_VALID(pBar);

			if (pBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)))
			{
				CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, pBar);
				// SLIDER CONTAINS ONLY ONE BAR IN AUTOHIDE MODE
				if (pSlider != NULL)
				{
					pBar = DYNAMIC_DOWNCAST(CBasePane, pSlider->GetFirstPane());
					if (pBar != NULL &&
						(pRTCFilter == NULL || pBar->GetRuntimeClass() == pRTCFilter))
					{
						lstBars.AddTail(pBar);
					}
				}
			}
		}
	}

	CPaneFrameWnd::GetPaneList(lstBars, pRTCFilter, bIncludeTabs);
}

BOOL CDockingManager::ShowPanes(BOOL bShow)
{
	if (!bShow)
	{
		if (m_bHiddenForOLE)
		{
			return FALSE;
		}

		m_lstBarsHiddenForOLE.RemoveAll();

		CObList lstBars;
		GetPaneList(lstBars, TRUE, NULL, TRUE);

		BOOL bHideInAutoHideMode = CDockablePane::m_bHideInAutoHideMode;
		CDockablePane::m_bHideInAutoHideMode = TRUE;

		m_bDisableRecalcLayout = TRUE;
		for (POSITION pos = lstBars.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, lstBars.GetNext(pos));

			if (pBar != NULL)
			{
				DWORD dwStyle = pBar->GetPaneStyle();
				if ((dwStyle & CBRS_HIDE_INPLACE) != 0 && (pBar->IsVisible() || pBar->IsAutoHideMode()))
				{
					pBar->ShowPane(FALSE, TRUE, FALSE);
					HWND hwndNext = pBar->GetSafeHwnd();
					m_lstBarsHiddenForOLE.AddTail(hwndNext);
				}
			}
		}
		m_bDisableRecalcLayout = FALSE;

		CDockablePane::m_bHideInAutoHideMode = bHideInAutoHideMode;

		m_bHiddenForOLE = TRUE;
	}
	else
	{
		if (!m_bHiddenForOLE)
		{
			return FALSE;
		}

		BOOL bHideInAutoHideMode = CDockablePane::m_bHideInAutoHideMode;
		CDockablePane::m_bHideInAutoHideMode = TRUE;

		m_bDisableRecalcLayout = TRUE;
		for (POSITION pos = m_lstBarsHiddenForOLE.GetHeadPosition(); pos != NULL;)
		{
			CBasePane* pBar = DYNAMIC_DOWNCAST(CBasePane, CWnd::FromHandlePermanent(m_lstBarsHiddenForOLE.GetNext(pos)));
			if (pBar != NULL)
			{
				pBar->ShowPane(TRUE, TRUE, FALSE);
			}
		}
		m_bDisableRecalcLayout = FALSE;
		CDockablePane::m_bHideInAutoHideMode = bHideInAutoHideMode;

		m_bHiddenForOLE = FALSE;
	}

	AdjustDockingLayout();

	// significantly reduces flickering. If we return TRUE, MFC will perform
	// additional recalc layout
	return FALSE;
}

void CDockingManager::ShowDelayShowMiniFrames(BOOL bShow)
{
	for (POSITION pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CWnd* pWndNext = (CWnd*)m_lstMiniFrames.GetNext(pos);
		if (pWndNext != NULL && pWndNext->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
		{
			CPaneFrameWnd* pFrameWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, pWndNext);
			if (pFrameWnd != NULL && pFrameWnd->IsDelayShow())
			{
				HWND hWndNext = pWndNext->GetSafeHwnd();
				if (::IsWindow(hWndNext))
				{
					::ShowWindow(hWndNext, bShow ? SW_SHOWNOACTIVATE : SW_HIDE);
				}

				pFrameWnd->SetDelayShow(FALSE);
			}
		}
	}
}

void CDockingManager::OnActivateFrame(BOOL bActivate)
{
	if (m_pParentWnd == NULL)
	{
		return;
	}

	BOOL bCheckForToolBarsOnly = !m_pParentWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx));

	if (bActivate)
	{
		for (POSITION pos = m_lstBarsHiddenOnDeactivate.GetHeadPosition(); pos != NULL;)
		{
			HWND hWndNext = m_lstBarsHiddenOnDeactivate.GetNext(pos);
			if (IsWindow(hWndNext))
			{
				CWnd* pWndNext = CWnd::FromHandle(hWndNext);
				CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, pWndNext);
				if (pMiniFrame != NULL && pMiniFrame->GetPaneCount() > 0)
				{
					ShowWindow(hWndNext, SW_SHOWNOACTIVATE);
				}
			}
		}

		m_lstBarsHiddenOnDeactivate.RemoveAll();
	}
	else
	{
		for (POSITION pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
		{
			CWnd* pWndNext = (CWnd*) m_lstMiniFrames.GetNext(pos);

			HWND hWndNext = pWndNext->GetSafeHwnd();
			if (::IsWindow(hWndNext) && IsWindowVisible(hWndNext))
			{
				if (bCheckForToolBarsOnly)
				{
					CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, pWndNext);
					ASSERT_VALID(pMiniFrame);
					CMFCBaseToolBar* pToolbar = DYNAMIC_DOWNCAST(CMFCBaseToolBar, pMiniFrame->GetPane());

					if (pToolbar == NULL)
					{
						continue;
					}
				}

				ShowWindow(hWndNext, SW_HIDE);
				if (m_lstBarsHiddenOnDeactivate.Find(hWndNext) == NULL)
				{
					m_lstBarsHiddenOnDeactivate.AddTail(hWndNext);
				}
			}
		}
	}
}

void CDockingManager::ResortMiniFramesForZOrder()
{
	int nCount = (int) m_lstMiniFrames.GetCount();

	if (nCount == 0)
	{
		return;
	}

	CWnd* pFirst = DYNAMIC_DOWNCAST(CWnd, m_lstMiniFrames.GetHead());

	if (pFirst == NULL)
	{
		return;
	}

	CWnd* pParent = pFirst->GetParent();

	if (pParent == NULL)
	{
		return;
	}

	CObList lstNewMiniFrames;

	CWnd* pNext = NULL;
	for (pNext = pParent->GetWindow(GW_HWNDFIRST); pNext != NULL; pNext = pNext->GetNextWindow() )
	{
		if (m_lstMiniFrames.Find(pNext) != NULL)
		{
			lstNewMiniFrames.AddTail(pNext);
		}
	}

	m_lstMiniFrames.RemoveAll();
	m_lstMiniFrames.AddTail(&lstNewMiniFrames);
}

void __stdcall CDockingManager::SetDockingMode(AFX_DOCK_TYPE dockMode, AFX_SMARTDOCK_THEME theme)
{
	m_dockModeGlobal = dockMode;

	if (m_dockModeGlobal == DT_SMART)
	{
		// DT_SMART should only be used along with DT_IMMEDIATE
		m_dockModeGlobal = AFX_DOCK_TYPE(DT_SMART | DT_IMMEDIATE);
		m_SDTheme = theme;
	}
}

void __stdcall CDockingManager::SetSmartDockingParams(CSmartDockingInfo& params)
{
	int nCount = 0;

	for (int i = 0; i < AFX_SD_MARKERS_NUM; i++)
	{
		if (params.m_uiMarkerBmpResID [i] != 0)
		{
			nCount++;
		}
	}

	if (nCount != 0 && nCount != AFX_SD_MARKERS_NUM)
	{
		// Unable to set part of bitmap markers!
		ASSERT(FALSE);
		return;
	}

	params.CopyTo(m_SDParams);
	m_bSDParamsModified = TRUE;
}

BOOL CDockingManager::ReplacePane(CDockablePane* pOriginalBar, CDockablePane* pNewBar)
{
	if (pOriginalBar == NULL || pNewBar == NULL)
	{
		return FALSE;
	}
	ASSERT_VALID(pNewBar);
	ASSERT_VALID(pOriginalBar);

	CRect rectOrgWnd;
	pOriginalBar->GetWindowRect(rectOrgWnd);

	CWnd* pOrgParentWnd = pOriginalBar->GetParent();
	ASSERT_VALID(pOrgParentWnd);

	pOrgParentWnd->ScreenToClient(rectOrgWnd);
	pOriginalBar->StoreRecentDockSiteInfo();
	pNewBar->CopyState(pOriginalBar);

	if (pOriginalBar->IsAutoHideMode())
	{
		// hide the original bar
		pOriginalBar->Slide(FALSE, FALSE);

		// set the same window pos for the new bar
		pNewBar->SetWindowPos(NULL, rectOrgWnd.left, rectOrgWnd.top, rectOrgWnd.Width(), rectOrgWnd.Height(), SWP_NOZORDER);

		pNewBar->ShowWindow(SW_HIDE);

		// replace bar in default slider and in the button
		CMFCAutoHideButton* pButton = pOriginalBar->GetAutoHideButton();
		ASSERT_VALID(pButton);

		CPaneDivider* pSlider = pOriginalBar->GetDefaultPaneDivider();
		if (pSlider != NULL)
		{
			ASSERT_VALID(pSlider);
			pSlider->ReplacePane(pOriginalBar, pNewBar);
		}

		if (pButton != NULL)
		{
			pButton->ReplacePane(pNewBar);
		}

		// reparent
		pNewBar->SetParent(pOrgParentWnd);

		// tell the new bar that it's in autohide mode
		pNewBar->m_bPinState = TRUE;
		pNewBar->m_nAutoHideConditionTimerID = pNewBar->SetTimer(AFX_ID_CHECK_AUTO_HIDE_CONDITION, pNewBar->m_nTimeOutBeforeAutoHide, NULL);
		AlignAutoHidePane(pSlider);

		// need to update caption buttons
		pNewBar->SetWindowPos(NULL, -1, -1, -1, -1, SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE | SWP_FRAMECHANGED);

		return TRUE;
	}

	if (pOriginalBar->IsTabbed())
	{
		HWND hwndTab = NULL;
		CMFCBaseTabCtrl* pTabWnd = pOriginalBar->GetParentTabWnd(hwndTab);

		if (pTabWnd != NULL)
		{
			ASSERT_VALID(pTabWnd);

			int nTabNum = pTabWnd->GetTabFromHwnd(pOriginalBar->GetSafeHwnd());

			CString strText;
			pOriginalBar->GetWindowText(strText);

			pTabWnd->InsertTab(pNewBar, strText, nTabNum + 1);
			pTabWnd->SetTabHicon(nTabNum + 1, pNewBar->GetIcon(FALSE));
			pTabWnd->RemoveTab(nTabNum);

			pNewBar->EnableGripper(FALSE);
			pNewBar->SetParent(pTabWnd);

			return TRUE;
		}
	}

	BOOL bResult = pOriginalBar->ReplacePane(pNewBar, DM_UNKNOWN, TRUE);
	if (bResult)
	{
		pNewBar->SetParent(pOrgParentWnd);
		pNewBar->SetWindowPos(NULL, rectOrgWnd.left, rectOrgWnd.top, rectOrgWnd.Width(), rectOrgWnd.Height(), SWP_NOZORDER);
		AdjustDockingLayout();

	}

	return bResult;
}

void CDockingManager::ReleaseEmptyPaneContainers()
{
	POSITION pos = NULL;

	for (pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, m_lstControlBars.GetNext(pos));
		if (pSlider != NULL && pSlider->IsDefault())
		{
			pSlider->ReleaseEmptyPaneContainers();
		}
	}

	for (pos = m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CMultiPaneFrameWnd* pWndNext = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, m_lstMiniFrames.GetNext(pos));
		if (pWndNext != NULL)
		{
			CPaneContainerManager& manager = pWndNext->GetPaneContainerManager();
			manager.ReleaseEmptyPaneContainers();
		}
	}
}

void CDockingManager::BuildPanesMenu(CMenu& menu, BOOL bToolbarsOnly)
{
	m_mapControlBarsInMenu.RemoveAll();

	CObList lstBars;
	GetPaneList(lstBars, TRUE);

	for (int nStep = 0; nStep < 2; nStep++) // 2 steps: 1-st: show toolbars, 2-nd other control bars
	{
		if (nStep == 1 && bToolbarsOnly)
		{
			break;
		}

		BOOL bIsFirst = TRUE;

		for (POSITION pos = lstBars.GetHeadPosition(); pos != NULL;)
		{
			CPane* pBar = DYNAMIC_DOWNCAST(CPane, lstBars.GetNext(pos));

			if (pBar == NULL || !::IsWindow(pBar->m_hWnd))
			{
				continue;
			}

			ASSERT_VALID(pBar);

			if (!pBar->AllowShowOnPaneMenu() || !pBar->CanBeClosed())
			{
				continue;
			}

			const BOOL bIsToolbar = pBar->IsKindOf(RUNTIME_CLASS(CMFCToolBar));

			if ((bIsToolbar && nStep == 1) ||(!bIsToolbar && nStep == 0))
			{
				continue;
			}

			CString strBarName;
			pBar->GetPaneName(strBarName);

			if (pBar->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)) && !pBar->IsKindOf(RUNTIME_CLASS(CMFCOutlookBar)))
			{
				CMFCBaseTabCtrl* pTabWnd = ((CBaseTabbedPane*)pBar)->GetUnderlyingWindow();
				if (pTabWnd != NULL)
				{
					for (int iTab = 0; iTab < pTabWnd->GetTabsNum(); iTab++)
					{
						CPane* pTabbedBar = DYNAMIC_DOWNCAST(CPane, pTabWnd->GetTabWnd(iTab));
						if (pTabbedBar != NULL && pTabbedBar->AllowShowOnPaneMenu())
						{
							CPane* pBarInMenu = NULL;

							if (!m_mapControlBarsInMenu.Lookup(pTabbedBar->GetDlgCtrlID(), pBarInMenu))
							{
								pTabbedBar->GetPaneName(strBarName);

								if (bIsFirst && nStep == 1 && menu.GetMenuItemCount() > 0)
								{
									menu.AppendMenu(MF_SEPARATOR);
								}

								menu.AppendMenu(MF_STRING, pTabbedBar->GetDlgCtrlID(), strBarName);

								bIsFirst = FALSE;

								m_mapControlBarsInMenu.SetAt(pTabbedBar->GetDlgCtrlID(), pTabbedBar);
							}
						}
					}
				}
			}
			else if (pBar->IsKindOf(RUNTIME_CLASS(CMFCReBar)))
			{
				CMFCReBar* pRebar = DYNAMIC_DOWNCAST(CMFCReBar, pBar);
				ASSERT_VALID(pBar);

				CReBarCtrl& wndReBar = pRebar->GetReBarCtrl();
				UINT uiReBarsCount = wndReBar.GetBandCount();

				REBARBANDINFO bandInfo;
				bandInfo.cbSize = pRebar->GetReBarBandInfoSize ();
				bandInfo.fMask = (RBBIM_CHILDSIZE | RBBIM_CHILD | RBBIM_IDEALSIZE);

				for (UINT uiBand = 0; uiBand < uiReBarsCount; uiBand++)
				{
					wndReBar.GetBandInfo(uiBand, &bandInfo);

					CPane* pRebarBand = DYNAMIC_DOWNCAST(CPane, CWnd::FromHandlePermanent(bandInfo.hwndChild));

					if (pRebarBand != NULL && pRebarBand->AllowShowOnPaneMenu())
					{
						pRebarBand->GetPaneName(strBarName);

						if (bIsFirst && nStep == 1 && menu.GetMenuItemCount() > 0)
						{
							menu.AppendMenu(MF_SEPARATOR);
						}

						menu.AppendMenu(MF_STRING, pRebarBand->GetDlgCtrlID(), strBarName);

						bIsFirst = FALSE;

						m_mapControlBarsInMenu.SetAt(pRebarBand->GetDlgCtrlID(), pRebarBand);
					}
				}
			}
			else
			{
				CPane* pBarInMenu = NULL;

				if (!m_mapControlBarsInMenu.Lookup(pBar->GetDlgCtrlID(), pBarInMenu))
				{
					if (bIsFirst && nStep == 1 && menu.GetMenuItemCount() > 0)
					{
						menu.AppendMenu(MF_SEPARATOR);
					}

					menu.AppendMenu(MF_STRING, pBar->GetDlgCtrlID(), strBarName);
					bIsFirst = FALSE;
					m_mapControlBarsInMenu.SetAt(pBar->GetDlgCtrlID(), pBar);
				}
			}
		}
	}

	// Add MDI tabbed bars(if any):
	CMDIFrameWndEx* pMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pParentWnd);

	if (pMDIFrame != NULL && !bToolbarsOnly)
	{
		HWND hwndMDIChild = ::GetWindow(pMDIFrame->m_hWndMDIClient, GW_CHILD);

		while (hwndMDIChild != NULL)
		{
			CMDIChildWndEx* pMDIChildFrame = DYNAMIC_DOWNCAST(CMDIChildWndEx, CWnd::FromHandle(hwndMDIChild));

			if (pMDIChildFrame != NULL && pMDIChildFrame->IsTabbedPane())
			{
				CDockablePane* pBar = pMDIChildFrame->GetTabbedPane();
				ASSERT_VALID(pBar);

				CString strBarName;
				pBar->GetPaneName(strBarName);

				menu.AppendMenu(MF_STRING, pBar->GetDlgCtrlID(), strBarName);
				m_mapControlBarsInMenu.SetAt(pBar->GetDlgCtrlID(), pBar);
			}

			hwndMDIChild = ::GetWindow(hwndMDIChild, GW_HWNDNEXT);
		}

		for (POSITION pos = m_lstHiddenMDITabbedBars.GetHeadPosition(); pos != NULL;)
		{
			HWND hwnd = m_lstHiddenMDITabbedBars.GetNext(pos);
			CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, CWnd::FromHandlePermanent(hwnd));

			if (pBar != NULL)
			{
				ASSERT_VALID(pBar);

				CString strBarName;
				pBar->GetPaneName(strBarName);

				menu.AppendMenu(MF_STRING, pBar->GetDlgCtrlID(), strBarName);
				m_mapControlBarsInMenu.SetAt(pBar->GetDlgCtrlID(), pBar);
			}
		}
	}

	if (m_uiCustomizeCmd != 0)
	{
		if (menu.GetMenuItemCount() > 0)
		{
			menu.AppendMenu(MF_SEPARATOR);
		}

		menu.AppendMenu(MF_STRING, m_uiCustomizeCmd, m_strCustomizeText);
	}
}

void CDockingManager::OnPaneContextMenu(CPoint point)
{
	if (!m_bControlBarsContextMenu)
	{
		return;
	}

	CFrameWnd* pFrame = AFXGetTopLevelFrame(m_pParentWnd);
	if (pFrame == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CMenu menu;
	menu.CreatePopupMenu();

	BuildPanesMenu(menu, m_bControlBarsContextMenuToolbarsOnly);

	CMFCPopupMenu* pPopupMenu = new CMFCPopupMenu;
	pPopupMenu->SetAutoDestroy(FALSE);

	m_bControlBarsMenuIsShown = TRUE;

	pPopupMenu->Create(pFrame, point.x, point.y, (HMENU) menu);
}

BOOL CDockingManager::ProcessPaneContextMenuCommand(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* /*pHandlerInfo*/)
{
	if (!m_bControlBarsContextMenu || m_mapControlBarsInMenu.IsEmpty())
	{
		return FALSE;
	}

	if (nCode == CN_UPDATE_COMMAND_UI && !m_bControlBarsMenuIsShown)
	{
		return FALSE;
	}

	CPane* pBar = NULL;
	if (!m_mapControlBarsInMenu.Lookup(nID, pBar) || pBar == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pBar);

	if (nCode == CN_UPDATE_COMMAND_UI)
	{
		CCmdUI* pCmdUI = (CCmdUI*) pExtra;
		if (pCmdUI == NULL)
		{
			return FALSE;
		}

		pCmdUI->SetCheck(pBar->IsVisible());
		return TRUE;
	}

	UINT nMsg = HIWORD(nCode);
	nCode = LOWORD(nCode);

	if ((nMsg != WM_COMMAND && nMsg != 0) || pExtra != NULL)
	{
		return TRUE;
	}

	pBar->ShowPane(!pBar->IsVisible(), FALSE, TRUE);

	CFrameWnd* pFrame = AFXGetTopLevelFrame(pBar);
	if (pFrame == NULL)
	{
		RecalcLayout();
	}
	else
	{
		pFrame->RecalcLayout();
	}

	m_mapControlBarsInMenu.RemoveAll();
	return TRUE;
}

void CDockingManager::OnClosePopupMenu()
{
	m_bControlBarsMenuIsShown = FALSE;
}

void CDockingManager::EnablePaneContextMenu(BOOL bEnable, UINT uiCustomizeCmd, const CString& strCustomizeText, BOOL bToolbarsOnly)
{
	m_bControlBarsContextMenu = bEnable;
	m_bControlBarsContextMenuToolbarsOnly = bToolbarsOnly;
	m_uiCustomizeCmd = uiCustomizeCmd;
	m_strCustomizeText = strCustomizeText;
}

void CDockingManager::AddHiddenMDITabbedBar(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	HWND hwnd = pBar->GetSafeHwnd();
	m_lstHiddenMDITabbedBars.AddTail(hwnd);
}

void CDockingManager::RemoveHiddenMDITabbedBar(CDockablePane* pBar)
{
	ASSERT_VALID(this);

	HWND hwnd = pBar->GetSafeHwnd();
	for (POSITION pos = m_lstHiddenMDITabbedBars.GetHeadPosition(); pos != NULL; m_lstHiddenMDITabbedBars.GetNext(pos))
	{
		HWND hNext = m_lstHiddenMDITabbedBars.GetAt(pos);
		if (hNext == hwnd)
		{
			m_lstHiddenMDITabbedBars.RemoveAt(pos);
			return;
		}
	}
}

CSmartDockingInfo::CSmartDockingInfo()
{
	m_sizeTotal = CSize(93, 93);
	m_nCentralGroupOffset = 5;
	m_clrTransparent = RGB(255, 0, 255);
	m_clrToneSrc = (COLORREF)-1;
	m_clrToneDest = (COLORREF)-1;

	for (int i = 0; i < AFX_SD_MARKERS_NUM; i++)
	{
		m_uiMarkerBmpResID [i] = 0;
		m_uiMarkerLightBmpResID [i] = 0;
	}

	m_uiBaseBmpResID = 0;
	m_clrBaseBackground = (COLORREF)-1;
	m_clrBaseBorder = (COLORREF)-1;
	m_bUseThemeColorInShading = FALSE;
	m_bIsAlphaMarkers = FALSE;
}

void CSmartDockingInfo::CopyTo(CSmartDockingInfo& params)
{
	params.m_sizeTotal = m_sizeTotal;
	params.m_nCentralGroupOffset = m_nCentralGroupOffset;
	params.m_clrTransparent = m_clrTransparent;
	params.m_clrToneSrc = m_clrToneSrc;
	params.m_clrToneDest = m_clrToneDest;

	for (int i = 0; i < AFX_SD_MARKERS_NUM; i++)
	{
		params.m_uiMarkerBmpResID [i] = m_uiMarkerBmpResID [i];
		params.m_uiMarkerLightBmpResID [i] = m_uiMarkerLightBmpResID [i];
	}

	params.m_clrBaseBackground = m_clrBaseBackground;
	params.m_clrBaseBorder = m_clrBaseBorder;
	params.m_bUseThemeColorInShading = m_bUseThemeColorInShading;
	params.m_uiBaseBmpResID = m_uiBaseBmpResID;
	params.m_bIsAlphaMarkers = m_bIsAlphaMarkers;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdockablepaneadapter.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxdockablepaneadapter.h"

#include "afxregpath.h"
#include "afxsettingsstore.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const CString strControlBarProfile = _T("Panes");

#define AFX_REG_SECTION_FMT _T("%sDockablePaneAdapter-%d")
#define AFX_REG_SECTION_FMT_EX _T("%sDockablePaneAdapter-%d%x")

IMPLEMENT_SERIAL(CDockablePaneAdapter, CDockablePane, VERSIONABLE_SCHEMA | 2)

/////////////////////////////////////////////////////////////////////////////
// CDockablePaneAdapter

CDockablePaneAdapter::CDockablePaneAdapter()
{
	m_pWnd = NULL;
	m_dwEnabledAlignmentInitial = CBRS_ALIGN_ANY;
	m_rectInitial.SetRect(30, 30, 180, 180);
}

CDockablePaneAdapter::~CDockablePaneAdapter()
{
}

BEGIN_MESSAGE_MAP(CDockablePaneAdapter, CDockablePane)
	//{{AFX_MSG_MAP(CDockablePaneAdapter)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDockablePaneAdapter message handlers
void CDockablePaneAdapter::OnSize(UINT nType, int cx, int cy)
{
	CDockablePane::OnSize(nType, cx, cy);

	if (m_pWnd != NULL)
	{
		m_pWnd->SetWindowPos(NULL, 0, 0, cx, cy, SWP_NOACTIVATE | SWP_NOZORDER/* | SWP_NOREDRAW*/);
	}
}
//------------------------------------------------------------------------------------
BOOL CDockablePaneAdapter::SetWrappedWnd(CWnd* pWnd)
{
	ASSERT_VALID(pWnd);
	ASSERT(IsWindow(m_hWnd));

	pWnd->SetParent(this);

	m_pWnd = pWnd;

	if (pWnd->IsKindOf(RUNTIME_CLASS(CBasePane)))
	{
		CBasePane* pBar = (CBasePane*) pWnd;
		EnableDocking(pBar->GetEnabledAlignment());
		m_bRecentVisibleState = pBar->GetRecentVisibleState();
		SetRestoredFromRegistry(pBar->IsRestoredFromRegistry());
		if (pWnd->IsKindOf(RUNTIME_CLASS(CPane)))
		{
			m_rectSavedDockedRect = ((CPane*) pBar)->m_rectSavedDockedRect;
		}
	}
	else
	{
		EnableDocking(m_dwEnabledAlignmentInitial);
	}

	return TRUE;
}
//------------------------------------------------------------------------------------
BOOL CDockablePaneAdapter::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strControlBarProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (reg.CreateKey(strSection))
	{
		CString strName;
		GetWindowText(strName);
		reg.Write(_T("BarName"), strName);

	}
	return CDockablePane::SaveState(lpszProfileName, nIndex, uiID);
}
//------------------------------------------------------------------------------------
BOOL CDockablePaneAdapter::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CString strProfileName = ::AFXGetRegPath(strControlBarProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	CString strName;
	reg.Read(_T("BarName"), strName);
	if (!strName.IsEmpty())
	{
		SetWindowText(strName);
	}

	return CDockablePane::LoadState(lpszProfileName, nIndex, uiID);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdockingpanesrow.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxpane.h"
#include "afxdocksite.h"
#include "afxdockingpanesrow.h"
#include "afxautohidebutton.h"
#include "afxvisualmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CDockingPanesRow, CObject)

// Construction/Destruction
CDockingPanesRow::CDockingPanesRow(CDockSite* pParentDockBar, int nOffset, int nHeight) : m_pParentDockBar(pParentDockBar), m_nRowOffset(nOffset), m_nRowHeight(nHeight)
{
	ASSERT_VALID(pParentDockBar);
	m_dwRowAlignment = pParentDockBar->GetCurrentAlignment();
	m_nMinHeight = 0;
	m_nExtraSpace = 0;
	m_nExtraAlignment = AFX_ROW_ALIGN_TOP;
	m_bVisible = TRUE;
	m_nRowSavedHeight = 0;
	m_bIgnoreBarVisibility = FALSE;
}

CDockingPanesRow::~CDockingPanesRow()
{
}

void CDockingPanesRow::AddPane(CPane* pControlBar, AFX_DOCK_METHOD /*dockMethod*/, LPCRECT lpRect, BOOL bAddLast)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	CRect rectRow;

	CPoint ptOffset(0, 0);
	if (lpRect != NULL && !IsRectEmpty(lpRect))
	{
		CRect rectOrg = lpRect;
		CRect rectDockBar;
		m_pParentDockBar->GetClientRect(&rectDockBar);
		GetWindowRect(rectRow);

		m_pParentDockBar->ScreenToClient(rectOrg);
		m_pParentDockBar->ScreenToClient(rectRow);

		if (IsHorizontal())
		{
			ptOffset.x = rectOrg.left - rectRow.left;
			ptOffset.y = rectDockBar.top + m_nRowOffset;
		}
		else
		{
			ptOffset.x = rectDockBar.left + m_nRowOffset;
			ptOffset.y = rectOrg.top - rectRow.top;
		}
	}
	else
	{
		int nAdditionalBarOffset = 0;
		if (bAddLast)
		{
			nAdditionalBarOffset = CalcLastPaneOffset();
			if (nAdditionalBarOffset > 0)
			{
				nAdditionalBarOffset += afxGlobalData.m_nAutoHideToolBarSpacing;
			}
		}

		GetClientRect(rectRow);
		if (IsHorizontal())
		{
			ptOffset.x = rectRow.left + nAdditionalBarOffset;
			ptOffset.y = m_nRowOffset;
			// align the bar to the bottom of the row
			if (m_nExtraAlignment == AFX_ROW_ALIGN_BOTTOM)
			{
				ptOffset.y += m_nExtraSpace;
			}
		}
		else
		{
			ptOffset.x = m_nRowOffset;
			ptOffset.y = rectRow.top + nAdditionalBarOffset;

			// align the bar to the right side of the row
			if (m_nExtraAlignment == AFX_ROW_ALIGN_BOTTOM)
			{
				ptOffset.x += m_nExtraSpace;
			}
		}
	}

	CSize szBarSize = pControlBar->CalcFixedLayout(FALSE, IsHorizontal());

	pControlBar->SetWindowPos(NULL, ptOffset.x, ptOffset.y, szBarSize.cx, szBarSize.cy, SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);

	OnInsertPane(pControlBar);
	pControlBar->UpdateVirtualRect();
}

void CDockingPanesRow::AddPaneFromRow(CPane* pControlBar, AFX_DOCK_METHOD dockMethod)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	CRect rectWnd;
	pControlBar->GetWindowRect(&rectWnd);

	int nOffsetOnRow = 0;
	if (dockMethod == DM_MOUSE)
	{
		// position the bar at the mouse cursor
		CPoint ptMouse;
		GetCursorPos(&ptMouse);
		m_pParentDockBar->ScreenToClient(&ptMouse);

		CPoint ptHot = pControlBar->GetClientHotSpot();

		// take the grippers and borders int account
		CRect rectClient;
		pControlBar->GetClientRect(rectClient);
		pControlBar->ClientToScreen(rectClient);

		int nNCOffset = rectClient.left - rectWnd.left;

		nOffsetOnRow = IsHorizontal() ? ptMouse.x - ptHot.x - nNCOffset : ptMouse.y - ptHot.y - nNCOffset;

	}
	else
	{
		m_pParentDockBar->ScreenToClient(&rectWnd);
		nOffsetOnRow = IsHorizontal()  ? rectWnd.left : rectWnd.top;
	}

	CRect rectPos;
	if (IsHorizontal())
	{
		rectPos.SetRect(nOffsetOnRow, m_nRowOffset, nOffsetOnRow + rectWnd.Width(), m_nRowOffset + rectWnd.Height());
	}
	else
	{
		rectPos.SetRect(m_nRowOffset, nOffsetOnRow, m_nRowOffset + rectWnd.Width(), nOffsetOnRow  + rectWnd.Height());
	}

	pControlBar->SetWindowPos(NULL, rectPos.left, rectPos.top, rectPos.right, rectPos.bottom, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
	OnInsertPane(pControlBar);
	pControlBar->UpdateVirtualRect();
}

void CDockingPanesRow::OnInsertPane(CPane* pControlBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	CRect rectBarWnd;
	pControlBar->GetWindowRect(&rectBarWnd);

	CPane* pPrevControlBar = NULL;

	bool bWasInserted = false;
	POSITION posSave = NULL;
	// the existing bars are ordered from the left to right or from top to bottom
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		posSave = pos;
		CPane* pBarWnd = DYNAMIC_DOWNCAST(CPane, m_lstControlBars.GetNext(pos));
		pPrevControlBar = pBarWnd;

		ASSERT_VALID(pBarWnd);

		// the new bar should be inserted before the next bar it is left of
		bWasInserted = pBarWnd->IsLeftOf(rectBarWnd);

		if (bWasInserted)
		{
			m_lstControlBars.InsertBefore(posSave, pControlBar);
			break;
		}
	}

	// if the bar wasn't inserted
	if (!bWasInserted)
	{
		m_lstControlBars.AddTail(pControlBar);
	}

	UpdateVisibleState(TRUE);

	int nNewRowHeight = IsHorizontal() ? rectBarWnd.Height() : rectBarWnd.Width();

	if (nNewRowHeight > GetRowHeight())
	{
		m_pParentDockBar->ResizeRow(this, nNewRowHeight + m_nExtraSpace);
	}

	pControlBar->GetDockSiteRow(this);
	ArrangePanes(pControlBar);
}

void CDockingPanesRow::RemovePane(CPane* pControlBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	POSITION pos = m_lstControlBars.Find(pControlBar);
	if (pos != NULL)
	{
		// expand the bar before it leaves the row
		HDWP hdwp = NULL;
		pControlBar->StretchPaneDeferWndPos(0xFFFF, hdwp);

		m_lstControlBars.RemoveAt(pos);

		pControlBar->GetDockSiteRow(NULL);

		if (!m_lstControlBars.IsEmpty())
		{
			FixupVirtualRects(true, pControlBar);
			// expand stretched bars(if any)
			ExpandStretchedPanes();
			UpdateVisibleState(FALSE);

			// find the biggest control bar and resize the row according to its size
			int nMaxBarSize = GetMaxPaneSize(FALSE);
			if (nMaxBarSize < GetRowHeight())
			{
				m_pParentDockBar->ResizeRow(this, nMaxBarSize);
				m_nRowHeight = nMaxBarSize;
			}

		}
		else
		{
			m_pParentDockBar->RemoveRow(this);
		}

	}
}

CSize CDockingPanesRow::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	if (!m_bVisible)
	{
		if (IsHorizontal())
		{
			return CSize(32767, 0);
		}
		return CSize(0, 32767);
	}

	BOOL bHorzBar = IsHorizontal();

	CSize sizeRequired(0, 0);
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pBar = DYNAMIC_DOWNCAST(CPane, m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pBar);

		if (!pBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		CSize sizeBar = pBar->CalcFixedLayout(bStretch, bHorz);

		if (bHorzBar)
		{
			sizeRequired.cx += sizeBar.cx;
			sizeRequired.cy = max(sizeRequired.cy, sizeBar.cy);
		}
		else
		{
			sizeRequired.cx = max(sizeRequired.cx, sizeBar.cx);
			sizeRequired.cy += sizeBar.cy;
		}
	}

	if (bHorzBar && sizeRequired.cy > 0)
	{
		sizeRequired.cy += m_nExtraSpace;
	}

	if (!bHorzBar && sizeRequired.cx > 0)
	{
		sizeRequired.cx += m_nExtraSpace;
	}

	return sizeRequired;
}

void CDockingPanesRow::OnResizePane(CBasePane* /*pControlBar*/)
{
}

int CDockingPanesRow::Resize(int nOffset)
{
	int nNewHeight = m_nRowHeight + nOffset;

	int nActualOffset = nNewHeight - m_nRowHeight;
	m_nRowHeight = nNewHeight;

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pBar = DYNAMIC_DOWNCAST(CPane, m_lstControlBars.GetNext(pos));
		if (pBar != NULL)
		{
			pBar->RecalcLayout();
		}
	}

	// return the actual resize offset
	return nActualOffset;
}

void CDockingPanesRow::Move(int nOffset)
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pBar = DYNAMIC_DOWNCAST(CPane, m_lstControlBars.GetNext(pos));
		if (pBar != NULL)
		{
			pBar->MoveByAlignment(m_dwRowAlignment, nOffset);
		}
	}
	m_nRowOffset += nOffset;
}

void CDockingPanesRow::GetWindowRect(CRect& rect) const
{
	ASSERT_VALID(this);
	rect.SetRectEmpty();

	if (m_pParentDockBar == NULL)
	{
		return;
	}

	m_pParentDockBar->GetWindowRect(&rect);

	if (IsHorizontal())
	{
		rect.top += m_nRowOffset;
		rect.bottom = rect.top + GetRowHeight();
	}
	else
	{
		rect.left += m_nRowOffset;
		rect.right = rect.left + GetRowHeight();
	}
}

void CDockingPanesRow::GetClientRect(CRect& rect) const
{
	ASSERT_VALID(this);

	GetWindowRect(rect);
	m_pParentDockBar->ScreenToClient(&rect);

	if (IsHorizontal())
	{
		rect.top -= m_nRowOffset;
		rect.bottom = rect.top + GetRowHeight();
	}
	else
	{
		rect.left -= m_nRowOffset;
		rect.right = rect.left + GetRowHeight();
	}
}

void CDockingPanesRow::ScreenToClient(CRect& rect) const
{
	ASSERT_VALID(this);
	m_pParentDockBar->ScreenToClient(&rect);
}

BOOL CDockingPanesRow::ShowPane(CPane* pControlBar, BOOL bShow, BOOL bDelay)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);
	if (!HasPane(pControlBar))
	{
		return FALSE;
	}

	pControlBar->ShowWindow(bShow ? SW_SHOW : SW_HIDE);
	UpdateVisibleState(bDelay);

	if (!bShow)
	{
		ExpandStretchedPanes();
	}
	else if (!bDelay)
	{
		pControlBar->AdjustLayout();
		ArrangePanes(pControlBar);
	}

	if (!bDelay)
	{
		CRect rect;
		GetClientRect(rect);
		m_pParentDockBar->RepositionPanes(rect);
		RepositionPanes(rect);
	}

	return TRUE;
}

void CDockingPanesRow::UpdateVisibleState(BOOL bDelay)
{
	BOOL bUseRecentVisibleState = !m_pParentDockBar->GetParent()->IsWindowVisible();
	BOOL bOldVisibleState = m_bVisible;
	BOOL bNewVisibleState  = FALSE;
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pNextWnd = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextWnd);

		if (bUseRecentVisibleState && pNextWnd->IsRestoredFromRegistry())
		{
			bNewVisibleState = pNextWnd->GetRecentVisibleState();
			if (bNewVisibleState)
			{
				break;
			}
		}
		else if (pNextWnd->GetStyle() & WS_VISIBLE)
		{
			bNewVisibleState = TRUE;
			break;
		}
	}

	if (bOldVisibleState != bNewVisibleState)
	{
		ShowDockSiteRow(bNewVisibleState, bDelay);
	}
	m_bVisible = bNewVisibleState;
}

void CDockingPanesRow::ShowDockSiteRow(BOOL bShow, BOOL bDelay)
{
	m_bVisible = bShow;
	m_pParentDockBar->ShowRow(this, bShow, !bDelay);
}

void CDockingPanesRow::ExpandStretchedPanes()
{
	ASSERT_VALID(this);

	if (m_lstControlBars.IsEmpty())
	{
		return;
	}

	// do not use virt. rects - we need real row space
	int nAvailableLen = GetAvailableLength(FALSE);

	HDWP hdwp = NULL;
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		int nRetSize = pNextBar->StretchPaneDeferWndPos(nAvailableLen, hdwp);

		nAvailableLen -= nRetSize;

		if (nAvailableLen <= 0)
		{
			break;
		}
	}

	ArrangePanes(NULL);

}

void CDockingPanesRow::ExpandStretchedPanesRect()
{
	ASSERT_VALID(this);

	if (m_lstControlBars.IsEmpty())
	{
		return;
	}

	BeginTrans();

	// do not use virt. rects - we need real row space
	int nAvailableLen = GetAvailableLengthRect();

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		int nRetSize = StretchPaneRect(pNextBar, nAvailableLen);

		nAvailableLen -= nRetSize;

		if (nAvailableLen <= 0)
		{
			break;
		}
	}

	ArrangePanesRect(NULL);
	CommitTrans();

}

void CDockingPanesRow::ShiftPanes(CPane* pControlBar, int nOffset, BOOL bForward)
{
	ASSERT_VALID(this);
	ASSERT(!m_lstControlBars.IsEmpty());

	if (nOffset == 0)
	{
		return;
	}

	POSITION pos = NULL;

	if (pControlBar != NULL)
	{
		pos = m_lstControlBars.Find(pControlBar);
	}
	else
	{
		pos = bForward ? m_lstControlBars.GetHeadPosition() : m_lstControlBars.GetTailPosition();
		pControlBar = (CPane*) m_lstControlBars.GetAt(pos);
	}

	int nMoveOffset = nOffset;

	CRect rectBar; rectBar.SetRectEmpty();

	while (pos != NULL)
	{
		CPane* pNextBar = (CPane*)(bForward ? m_lstControlBars.GetNext(pos) : m_lstControlBars.GetPrev(pos));

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		ASSERT_VALID(pNextBar);
		CRect rectNextBar;
		pNextBar->GetWindowRect(rectNextBar);

		if (pNextBar != pControlBar && !rectBar.IsRectEmpty())
		{
			if (IsHorizontal())
			{
				nMoveOffset -= bForward ? rectNextBar.left - rectBar.right : rectNextBar.right - rectBar.left;
			}
			else
			{
				nMoveOffset -= bForward ? rectNextBar.top - rectBar.bottom : rectNextBar.bottom - rectBar.top;
			}
		}

		if (nMoveOffset <= 0 && bForward || nMoveOffset >= 0 && !bForward)
		{
			break;
		}

		rectBar = rectNextBar;
		IsHorizontal() ? rectNextBar.OffsetRect(nMoveOffset, 0) : rectNextBar.OffsetRect(0, nMoveOffset);
		m_pParentDockBar->ScreenToClient(rectNextBar);

		pNextBar->SetWindowPos(NULL, rectNextBar.left, rectNextBar.top, rectNextBar.Width(), rectNextBar.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
	}
}

void CDockingPanesRow::MovePane(CPane* pControlBar, CPoint ptOffset, BOOL bSwapControlBars, HDWP& hdwp)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	CRect rectVirtual;
	pControlBar->GetVirtualRect(rectVirtual);

	CRect rectBarWnd;
	pControlBar->GetWindowRect(&rectBarWnd);

	CRect rectVirualNew = rectVirtual;
	rectVirualNew.OffsetRect(ptOffset);

	// the bar is being moved within the row, just move it horizontally or vertically
	bool bForward = true;
	CPoint ptMove(0, 0);
	int nAllowedOffset = 0;

	if (IsHorizontal())
	{
		nAllowedOffset = ptMove.x = ptOffset.x;
		bForward = (ptMove.x >= 0);
	}
	else
	{
		nAllowedOffset = ptMove.y = ptOffset.y;
		bForward = (ptMove.y >= 0);
	}

	if (!IsEnoughSpaceToMove(pControlBar, bForward, nAllowedOffset))
	{
		return;
	}

	if (IsHorizontal() && abs(nAllowedOffset) < abs(ptMove.x))
	{
		ptMove.x = nAllowedOffset;
	}
	else if (!IsHorizontal() && abs(nAllowedOffset) < abs(ptMove.y))
	{
		ptMove.y = nAllowedOffset;
	}

	rectBarWnd.OffsetRect(ptMove);

	if (CheckPanes(rectBarWnd, pControlBar, bForward, ptMove, bSwapControlBars, hdwp))
	{
		m_pParentDockBar->ScreenToClient(&rectBarWnd);

		pControlBar->SetWindowPos(NULL, rectBarWnd.left, rectBarWnd.top, rectBarWnd.Width(), rectBarWnd.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
	}

	ArrangePanes(pControlBar);
}

void CDockingPanesRow::MovePane(CPane* pControlBar, CRect rectTarget, HDWP& /*hdwp*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	CRect rectBarWnd;
	pControlBar->GetWindowRect(&rectBarWnd);

	if (IsHorizontal())
	{
		rectBarWnd.left = rectTarget.left;
		rectBarWnd.right = rectTarget.right;
	}
	else
	{
		rectBarWnd.top = rectTarget.top;
		rectBarWnd.bottom = rectTarget.bottom;
	}
	m_pParentDockBar->ScreenToClient(&rectBarWnd);

	pControlBar->SetWindowPos(NULL, rectBarWnd.left, rectBarWnd.top, rectBarWnd.Width(), rectBarWnd.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
}

void CDockingPanesRow::MovePane(CPane* pControlBar, int nOffset, bool bForward, HDWP& /*hdwp*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	if (nOffset == 0)
	{
		return;
	}

	CRect rectBarWnd;
	pControlBar->GetWindowRect(&rectBarWnd);

	if (IsHorizontal())
	{
		rectBarWnd.OffsetRect(bForward ? nOffset : -nOffset, 0);
	}
	else
	{
		rectBarWnd.OffsetRect(0, bForward ? nOffset : -nOffset);
	}
	m_pParentDockBar->ScreenToClient(&rectBarWnd);

	pControlBar->SetWindowPos(NULL, rectBarWnd.left, rectBarWnd.top, rectBarWnd.Width(), rectBarWnd.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
}

void CDockingPanesRow::MovePane(CPane* pControlBar, int nAbsolutOffset, HDWP& /*hdwp*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	CRect rectBarWnd;
	pControlBar->GetWindowRect(&rectBarWnd);

	CRect rectRow;
	GetWindowRect(rectRow);

	int nBarLength = 0;

	if (IsHorizontal())
	{
		nBarLength = rectBarWnd.Width();
		rectBarWnd.left = rectRow.left + nAbsolutOffset;
		rectBarWnd.right = rectBarWnd.left + nBarLength;
	}
	else
	{
		nBarLength = rectBarWnd.Height();
		rectBarWnd.top = rectRow.top + nAbsolutOffset;
		rectBarWnd.bottom = rectBarWnd.top + nBarLength;
	}

	m_pParentDockBar->ScreenToClient(&rectBarWnd);
	pControlBar->SetWindowPos(NULL, rectBarWnd.left, rectBarWnd.top, rectBarWnd.Width(), rectBarWnd.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
}

int CDockingPanesRow::GetVisibleCount()
{
	int nVisibleCount = 0;
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if (!m_bIgnoreBarVisibility)
		{
			if (pNextBar->IsVisible())
			{
				nVisibleCount++;
			}
		}
		else
		{
			nVisibleCount++;
		}
	}

	return nVisibleCount;
}

BOOL CDockingPanesRow::CheckPanes(CRect& rectCurrentBar, CPane* pCurrentBar, bool bForward, CPoint ptOffset, BOOL bSwapControlBars, HDWP& hdwp)
{
	ASSERT_VALID(this);

	if (m_lstControlBars.GetCount() < 2 || GetVisibleCount() < 2)
	{
		// nothing to check - there is only one control bar on the dock bar
		return TRUE;
	}

	CRect rectNextControlBar;
	CRect rectNextControlBarVirt;

	CPane* pNextBar = NULL;
	CRect rectIntersect;

	BOOL bIntersect = FALSE;

	POSITION posCurrentBar = m_lstControlBars.Find(pCurrentBar);
	// position of the bar which intersects with the current bar
	POSITION posIntersect = NULL;
	// find a control bar which whill intersect with the current bar
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		posIntersect = pos;
		pNextBar = (CPane*) m_lstControlBars.GetNext(pos);

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		if (pNextBar != pCurrentBar)
		{
			ASSERT_VALID(pNextBar);

			pNextBar->GetWindowRect(&rectNextControlBar);
			bIntersect = rectIntersect.IntersectRect(rectNextControlBar, rectCurrentBar);
			if (bIntersect)
			{
				break;
			}
		}
	}

	if (!bIntersect || pNextBar == NULL)
	{
		// the current bar does not intersect with any bar on the row, check whether
		// we need to move "trailing bars" - whose virtual rectangle is out of place

		MoveTrailingPanes(posCurrentBar, ptOffset, bForward, pCurrentBar, hdwp);
		return TRUE;
	}

	// get the virtual rectangle of the bar that intersects with the curr. bar
	pNextBar->GetVirtualRect(rectNextControlBarVirt);

	// if the current bar has just crossed a point when it is no more on the left side
	// from the virtual rect(when moving forward), or it is no more on the right side
	// when moving backward;
	// the next control bar should be transferred to the opposite side
	CRect rectIntersectVirt;

	if (rectIntersectVirt.IntersectRect(rectNextControlBarVirt, rectCurrentBar) && bSwapControlBars)
	{
		if (bForward && pCurrentBar->IsLeftOf(rectNextControlBarVirt) || !bForward && !pCurrentBar->IsLeftOf(rectNextControlBarVirt))
		{
			CRect rectNew = rectNextControlBar;

			if (IsHorizontal())
			{
				bForward ? rectNew.right = rectCurrentBar.left : rectNew.left = rectCurrentBar.right ;
				bForward ? rectNew.left = rectNew.right - rectNextControlBar.Width() : rectNew.right = rectNew.left + rectNextControlBar.Width();
			}
			else
			{
				bForward ? rectNew.bottom = rectCurrentBar.top : rectNew.top = rectCurrentBar.bottom;
				bForward ? rectNew.top = rectNew.bottom - rectNextControlBar.Height() : rectNew.bottom = rectNew.top + rectNextControlBar.Height();
			}
			MovePane(pNextBar, rectNew, hdwp);

			m_lstControlBars.RemoveAt(posIntersect);

			bForward ? m_lstControlBars.InsertBefore(posCurrentBar, pNextBar) : m_lstControlBars.InsertAfter(posCurrentBar, pNextBar);

			ResolveIntersection(pNextBar, !bForward, hdwp);

			// now we need to shift all control bars behind pNextBar to make them closer
			// to the current bar

			CRect rectWnd;
			CRect rectVirt;
			bForward ? m_lstControlBars.GetNext(posCurrentBar) : m_lstControlBars.GetPrev(posCurrentBar);
			for (POSITION pos = posCurrentBar; pos != NULL;)
			{
				CPane* pMovedBar = (CPane*)(bForward ? m_lstControlBars.GetNext(pos) : m_lstControlBars.GetPrev(pos));
				ASSERT_VALID(pMovedBar);

				if (!pMovedBar->IsVisible() && !m_bIgnoreBarVisibility)
				{
					continue;
				}

				pMovedBar->GetWindowRect(&rectWnd);
				pMovedBar->GetVirtualRect(rectVirt);

				if (rectWnd != rectVirt)
				{
					int nOffset = IsHorizontal() ? rectNew.Width() : rectNew.Height();
					nOffset -= IsHorizontal() ? abs(ptOffset.x) : abs(ptOffset.y);
					MovePane(pMovedBar, nOffset, !bForward, hdwp); // move in opposite direction
				}

			}
			return TRUE;
		}
	}

	int nMoveOffset = IsHorizontal() ? rectIntersect.Width() : rectIntersect.Height();
	MovePane(pNextBar, nMoveOffset, bForward, hdwp);
	ResolveIntersection(pNextBar, bForward, hdwp);

	MoveTrailingPanes(posCurrentBar, ptOffset, bForward, pCurrentBar, hdwp);

	return TRUE;
}

void CDockingPanesRow::MoveTrailingPanes(POSITION posStart, CPoint ptOffset, bool bForward, CPane* pBarToSkip, HDWP& hdwp)
{
	ASSERT_VALID(this);

	CRect rectNextControlBar;
	CRect rectNextControlBarVirt;

	for (POSITION pos = posStart; pos != NULL;)
	{
		CPane* pNextBar = (CPane*)(bForward ? m_lstControlBars.GetPrev(pos) : m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		if (pNextBar == pBarToSkip)
		{
			continue;
		}

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		pNextBar->GetWindowRect(&rectNextControlBar);
		pNextBar->GetVirtualRect(rectNextControlBarVirt);

		if (rectNextControlBar != rectNextControlBarVirt)
		{
			int nOffsetToMove = 0;

			if (bForward && pNextBar->IsLeftOf(rectNextControlBarVirt) || !bForward && !pNextBar->IsLeftOf(rectNextControlBarVirt))
			{
				nOffsetToMove = IsHorizontal() ? abs(ptOffset.x) : abs(ptOffset.y);
			}
			else if (bForward && !pNextBar->IsLeftOf(rectNextControlBarVirt) || !bForward && pNextBar->IsLeftOf(rectNextControlBarVirt))
			{
				if (IsHorizontal())
				{
					nOffsetToMove = min(abs(ptOffset.x), abs(rectNextControlBarVirt.left - rectNextControlBar.left));
				}
				else
				{
					nOffsetToMove = min(abs(ptOffset.y), abs(rectNextControlBarVirt.top - rectNextControlBar.top));
				}
			}
			MovePane(pNextBar, nOffsetToMove, bForward, hdwp);
			ResolveIntersection(pNextBar, !bForward, hdwp);
		}
	}
}

void CDockingPanesRow::ResolveIntersection(CPane* pBar, bool bForward, HDWP& hdwp)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	POSITION posStart = m_lstControlBars.Find(pBar);

	CRect rectBarWnd;
	rectBarWnd.SetRectEmpty();

	CRect rectRowWnd;
	GetWindowRect(rectRowWnd);

	CRect rectIntersect;
	CRect rectMovedBar;

	for (POSITION pos = posStart; pos != NULL;)
	{
		CPane* pNextBar = (CPane*)(bForward ? m_lstControlBars.GetNext(pos) : m_lstControlBars.GetPrev(pos));

		ASSERT_VALID(pNextBar);

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		pNextBar->GetWindowRect(&rectBarWnd);

		CPane* pMovedBar = NULL;
		POSITION posSave = NULL;
		for (POSITION posMoved = pos; posMoved != NULL;)
		{
			posSave = posMoved;
			pMovedBar = (CPane*)(bForward ? m_lstControlBars.GetNext(posMoved) : m_lstControlBars.GetPrev(posMoved));

			if (pMovedBar->IsVisible() || m_bIgnoreBarVisibility)
			{
				break;
			}
			else
			{
				pMovedBar = NULL;
			}
		}

		if (pMovedBar == NULL)
		{
			break;
		}

		pMovedBar->GetWindowRect(&rectMovedBar);

		if (bForward &&(IsHorizontal() && rectMovedBar.left > rectBarWnd.right || !IsHorizontal() && rectMovedBar.top > rectBarWnd.bottom) || !bForward &&
			(IsHorizontal() && rectMovedBar.right < rectBarWnd.left || !IsHorizontal() && rectMovedBar.bottom < rectBarWnd.top))
		{
			pos = posSave;
			continue;
		}

		int nMoveOffset = 0;
		if (bForward)
		{
			nMoveOffset = IsHorizontal() ? rectBarWnd.right - rectMovedBar.left : rectBarWnd.bottom - rectMovedBar.top;
		}
		else
		{
			nMoveOffset = IsHorizontal() ? rectMovedBar.right - rectBarWnd.left : rectMovedBar.bottom - rectBarWnd.top;
		}

		MovePane(pMovedBar, nMoveOffset, bForward, hdwp);
		pos = posSave;
	}
}

BOOL CDockingPanesRow::IsEnoughSpaceToMove(CPane* pControlBar, bool bForward, int& nAllowedOffset)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	int nLen = 0;
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CRect rectBar;
		CPane* pBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBar);

		if (!pBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		pBar->GetWindowRect(&rectBar);

		if (pBar == pControlBar)
		{
			continue;
		}

		if (bForward && !pControlBar->IsLeftOf(rectBar) || !bForward && pControlBar->IsLeftOf(rectBar))
		{
			IsHorizontal() ? nLen += rectBar.Width() : nLen += rectBar.Height();
		}
	}

	CRect rectControlBar;
	pControlBar->GetWindowRect(&rectControlBar);

	CRect rectRow;
	GetWindowRect(rectRow);

	nAllowedOffset = 0;
	if (IsHorizontal())
	{
		nAllowedOffset = bForward ? rectRow.right - rectControlBar.right : rectRow.left - rectControlBar.left;
	}
	else
	{
		nAllowedOffset = bForward ? rectRow.bottom - rectControlBar.bottom : rectRow.top - rectControlBar.top;
	}

	nAllowedOffset = bForward ? nAllowedOffset - nLen : nAllowedOffset + nLen;

	if (bForward && nAllowedOffset <= 0 || !bForward && nAllowedOffset >= 0)
	{
		return FALSE;
	}

	return TRUE;
}

void CDockingPanesRow::OffsetFromRect(const CRect& rect, CPoint& pt, bool bForward)
{
	switch (m_dwRowAlignment & CBRS_ALIGN_ANY)
	{
	case CBRS_ALIGN_TOP:
	case CBRS_ALIGN_BOTTOM:
		bForward ? pt.x = rect.Width() : pt.x = -rect.Width();
		break;

	case CBRS_ALIGN_LEFT:
	case CBRS_ALIGN_RIGHT:
		bForward ? pt.y = rect.Height() : pt.y = -rect.Height();
		break;
	}
}

void CDockingPanesRow::FixupVirtualRects(bool bMoveBackToVirtualRect, CPane* pBarToExclude)
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		if (pNextBar == pBarToExclude)
		{
			continue;
		}

		CRect rectBarWnd;
		pNextBar->GetWindowRect(&rectBarWnd);
		if (bMoveBackToVirtualRect)
		{
			CRect rectVirtual;
			pNextBar->GetVirtualRect(rectVirtual);
			if (rectVirtual != rectBarWnd)
			{
				HDWP hdwp = BeginDeferWindowPos((int) m_lstControlBars.GetCount());
				MovePane(pNextBar, rectVirtual, hdwp);
				EndDeferWindowPos(hdwp);
			}
		}
		else
		{
			pNextBar->UpdateVirtualRect();
		}
	}
}

int CDockingPanesRow::GetAvailableLength(BOOL bUseVirtualRect) const
{
	ASSERT_VALID(this);

	CRect rectRow;
	GetClientRect(rectRow);

	int nTotalBarLength = 0;
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		CRect rectWnd;
		bUseVirtualRect ? pNextBar->GetVirtualRect(rectWnd) : pNextBar->GetWindowRect(&rectWnd);

		nTotalBarLength += IsHorizontal() ? rectWnd.Width() : rectWnd.Height();
	}

	// debug variable
	int nAvailableLength = IsHorizontal() ? rectRow.Width() - nTotalBarLength : rectRow.Height() - nTotalBarLength;

	return nAvailableLength;
}

int CDockingPanesRow::GetMaxPaneSize(BOOL bSkipHiddenBars) const
{
	ASSERT_VALID(this);

	int nMaxSize = 0;
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if (!pNextBar->IsVisible() && bSkipHiddenBars && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		CRect rectWnd;
		pNextBar->GetWindowRect(&rectWnd);

		nMaxSize = max(nMaxSize, IsHorizontal() ? rectWnd.Height() : rectWnd.Width());
	}

	// don't use extra space if there are no visible bars
	if (nMaxSize != 0)
	{
		nMaxSize += m_nExtraSpace;
	}

	return nMaxSize;
}

void CDockingPanesRow::GetAvailableSpace(CRect& rect)
{
	ASSERT_VALID(this);

	GetWindowRect(rect);
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		CRect rectWnd;
		pNextBar->GetWindowRect(&rectWnd);

		IsHorizontal() ? rect.DeflateRect(rectWnd.Width(), 0) : rect.DeflateRect(0, rectWnd.Height());
	}
}

void CDockingPanesRow::ArrangePanes(int nMargin, int nSpacing)
{
	CRect rectRow;
	CRect rectBar;
	CPoint ptOffset(0, 0);

	GetWindowRect(rectRow);

	bool bFistBar = true;
	const BOOL bIsOverlapped = (CMFCVisualManager::GetInstance()->HasOverlappedAutoHideButtons());

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBar);

		if (!pBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		pBar->GetWindowRect(rectBar);

		if (bFistBar)
		{
			IsHorizontal() ? ptOffset.x = rectRow.left + nMargin : ptOffset.y = rectRow.top + nMargin;
		}

		if (!pBar->m_bFirstInGroup && !bFistBar)
		{
			const int nSize = nSpacing + CMFCAutoHideButton::m_nBorderSize;

			if (IsHorizontal())
			{
				ptOffset.x -= nSize;

				if (bIsOverlapped)
				{
					ptOffset.x -= rectBar.Height() / 2;
				}
			}
			else
			{
				ptOffset.y -= nSize;

				if (bIsOverlapped)
				{
					ptOffset.y -= rectBar.Width() / 2;
				}
			}
		}

		if (bFistBar)
		{
			bFistBar = false;
		}

		int nLen = 0;
		if (IsHorizontal())
		{
			int nWidth = rectBar.Width();
			rectBar.left = ptOffset.x;
			rectBar.right = rectBar.left + nWidth;
			nLen = nWidth;
		}
		else
		{
			int nHeight = rectBar.Height();
			rectBar.top = ptOffset.y;
			rectBar.bottom = rectBar.top + nHeight;
			nLen = nHeight;
		}

		ScreenToClient(rectBar);

		pBar->SetWindowPos(NULL, rectBar.left, rectBar.top, rectBar.Width(), rectBar.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
		pBar->StretchPane(nLen, !IsHorizontal());

		// get the rect after stretch
		pBar->GetWindowRect(rectBar);

		IsHorizontal() ? ptOffset.x += rectBar.Width() + nSpacing : ptOffset.y += rectBar.Height() + nSpacing;
	}
}

void CDockingPanesRow::ArrangePanes(CPane* pInitialBar)
{
	ASSERT_VALID(this);

	if (m_lstControlBars.IsEmpty())
	{
		return;
	}

	CRect rectRow;
	GetClientRect(rectRow);

	if (rectRow.IsRectEmpty())
	{
		// the row still is not initialized
		return;
	}

	HDWP hdwp = NULL;
	int nAvailLength = GetAvailableLength();

	// handle single bar
	if (m_lstControlBars.GetCount() == 1)
	{
		if (pInitialBar == NULL)
		{
			pInitialBar = (CPane*) m_lstControlBars.GetHead();
		}
		ASSERT_VALID(pInitialBar);

		if (nAvailLength < 0)
		{
			pInitialBar->StretchPaneDeferWndPos(nAvailLength, hdwp);

			CRect rectBar;
			pInitialBar->GetWindowRect(rectBar);
			m_pParentDockBar->ScreenToClient(rectBar);
			if (IsHorizontal())
			{
				rectBar.OffsetRect(-rectBar.TopLeft().x, -rectBar.TopLeft().y + m_nRowOffset);
			}
			else
			{
				rectBar.OffsetRect(-rectBar.TopLeft().x + m_nRowOffset, -rectBar.TopLeft().y);
			}
			pInitialBar->SetWindowPos(NULL, rectBar.left, rectBar.top, rectBar.Width(), rectBar.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
			return;
		}
	}

	if (pInitialBar != NULL)
	{
		ResolveIntersection(pInitialBar, false, hdwp);
	}

	if (pInitialBar == NULL)
	{
		pInitialBar = (CPane*) m_lstControlBars.GetHead();
	}

	ResolveIntersection(pInitialBar, true, hdwp);

	CPane* pFirstBar = FindFirstVisiblePane(TRUE);
	// how far the first bar is out of row bounds
	int nLeftOuterOffset = GetOutOfBoundsOffset(pFirstBar, TRUE);

	if (nLeftOuterOffset > 0)
	{
		ShiftPanes(pFirstBar, nLeftOuterOffset, TRUE);
	}

	CPane* pLastBar = FindFirstVisiblePane(FALSE);
	int nRightOuterOffset = GetOutOfBoundsOffset(pLastBar, FALSE);

	int nStretchSize = 0;
	if (nRightOuterOffset > 0 && nAvailLength > 0)
	{
		ShiftPanes(pLastBar, -nRightOuterOffset, FALSE);
	}
	else if (nRightOuterOffset > 0 && nAvailLength <= 0)
	{
		nStretchSize = nAvailLength;
		ShiftPanes(pLastBar, -(nRightOuterOffset - abs(nAvailLength)), FALSE);
	}
	else if (nRightOuterOffset < 0)
	{
		// nothing to do
	}

	if (nStretchSize < 0)
	{
		for (POSITION pos = m_lstControlBars.GetTailPosition(); pos != NULL;)
		{
			CPane* pPrevBar = (CPane*) m_lstControlBars.GetPrev(pos);
			ASSERT_VALID(pPrevBar);

			if (!pPrevBar->IsVisible() && !m_bIgnoreBarVisibility)
			{
				continue;
			}

			int nRetSize = pPrevBar->StretchPaneDeferWndPos(nStretchSize, hdwp);

			MovePane(pPrevBar, abs(nStretchSize) - abs(nRetSize), false, hdwp);

			if (nRetSize == nStretchSize)
			{
				break;
			}
			else
			{
				nStretchSize -= nRetSize;
			}
		}
	}
}

CPane* CDockingPanesRow::FindFirstVisiblePane(BOOL bForward)
{
	ASSERT_VALID(this);
	if (m_lstControlBars.IsEmpty())
	{
		return NULL;
	}

	for (POSITION pos = bForward ? m_lstControlBars.GetHeadPosition() : m_lstControlBars.GetTailPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*)(bForward ? m_lstControlBars.GetNext(pos) : m_lstControlBars.GetPrev(pos));

		ASSERT_VALID(pNextBar);
		if (!m_bIgnoreBarVisibility)
		{
			if (pNextBar->IsVisible())
			{
				return pNextBar;
			}
		}
		else
		{
			return pNextBar;
		}
	}

	return NULL;
}

int CDockingPanesRow::GetOutOfBoundsOffset(CPane* pBar, BOOL bLeftTopBound)
{
	ASSERT_VALID(this);

	CRect rectBar;
	CRect rectRow;

	if (pBar == NULL)
	{
		pBar = (CPane* )(bLeftTopBound ? m_lstControlBars.GetHead() : m_lstControlBars.GetTail());
	}

	ASSERT_VALID(pBar);

	pBar->GetWindowRect(rectBar);
	GetWindowRect(rectRow);

	int nBoundOffset = 0;

	// the offset is greater than zero if the bar is out of bounds
	if (IsHorizontal())
	{
		nBoundOffset = bLeftTopBound ?  rectRow.left - rectBar.left : rectBar.right - rectRow.right;
	}
	else
	{
		nBoundOffset = bLeftTopBound ? rectRow.top - rectBar.top : rectBar.bottom - rectRow.bottom;
	}

	return nBoundOffset;
}

void CDockingPanesRow::RepositionPanes(CRect& rectNewParentBarArea, UINT nSide, BOOL bExpand, int nOffset)
{
	ASSERT_VALID(this);

	if (m_lstControlBars.IsEmpty() || GetVisibleCount() == 0)
	{
		return;
	}

	CRect rectNewParentWnd = rectNewParentBarArea;

	ASSERT_VALID(m_pParentDockBar);
	m_pParentDockBar->ClientToScreen(rectNewParentWnd);

	CRect rectRowWnd;
	GetWindowRect(rectRowWnd);

	if (rectRowWnd.IsRectEmpty())
	{
		return;
	}

	int nStretchSize = IsHorizontal() ? rectNewParentWnd.Width() - rectRowWnd.Width() : rectNewParentWnd.Height() - rectRowWnd.Height();

	HDWP hdwp = NULL; //BeginDeferWindowPos(m_lstControlBars.GetCount());

	// handle exclusive bars first
	if (IsExclusiveRow())
	{
		CPane* pBar = (CPane*) m_lstControlBars.GetHead();

		ASSERT_VALID(pBar);
		ASSERT(!pBar->DoesAllowSiblingBars());

		if (IsHorizontal())
		{
			pBar->SetWindowPos(NULL, rectRowWnd.left, rectRowWnd.top, rectNewParentWnd.Width(), rectRowWnd.Height(), SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
		}
		else
		{
			pBar->SetWindowPos(NULL, rectRowWnd.left, rectRowWnd.top, rectRowWnd.Width(), rectNewParentWnd.Height(), SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
		}

		pBar->RedrawWindow();
		return;
	}

	int nAvailSpace = GetAvailableLength(TRUE);
	bool bResizeBars = nAvailSpace < 0 || !bExpand && nAvailSpace >= 0 && nAvailSpace < abs(nStretchSize);

	if (bResizeBars)
	{
		if (!bExpand)
		{
			// there is some available space on the row
			// we need to move control bars first and then stretch

			bool bTopLeftSide = (nSide == WMSZ_TOP || nSide == WMSZ_LEFT);

			int nActualStretchSize = nStretchSize;

			if (nAvailSpace >= 0)
			{
				int nSign = nStretchSize < 0 ?(-1) : 1;
				int nOutOfBoundOffset = GetOutOfBoundsOffset(NULL, bTopLeftSide);

				int nOffsetToShift = nAvailSpace - abs(nOutOfBoundOffset);

				ShiftPanes(NULL, nSign * nOffsetToShift, bTopLeftSide);
				nActualStretchSize = (abs(nStretchSize) - nAvailSpace) * nSign;
			}

			for (POSITION pos = m_lstControlBars.GetTailPosition(); pos != NULL;)
			{
				CPane* pPrevBar = (CPane*) m_lstControlBars.GetPrev(pos);
				ASSERT_VALID(pPrevBar);

				if (!pPrevBar->IsVisible() && !m_bIgnoreBarVisibility)
				{
					continue;
				}

				int nRetSize = pPrevBar->StretchPaneDeferWndPos(nActualStretchSize, hdwp);

				MovePane(pPrevBar, abs(nActualStretchSize) - abs(nRetSize), bTopLeftSide, hdwp);

				if (nRetSize == nActualStretchSize)
				{
					break;
				}
				else
				{
					nActualStretchSize -= nRetSize;
				}
			}

			return;
		}
		else
		{
			int nActualStretchSize = nStretchSize;
			for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
			{
				CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
				ASSERT_VALID(pNextBar);

				if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
				{
					continue;
				}

				int nRetSize = pNextBar->StretchPaneDeferWndPos(nActualStretchSize, hdwp);

				if (nRetSize != 0 && pos != NULL)
				{
					for (POSITION posMovedBars = pos; posMovedBars != NULL;)
					{
						CPane* pBarToMove = (CPane*) m_lstControlBars.GetNext(posMovedBars);
						ASSERT_VALID(pBarToMove);

						if (!pBarToMove->IsVisible() && !m_bIgnoreBarVisibility)
						{
							continue;
						}

						MovePane(pBarToMove, nRetSize, true, hdwp);
					}
				}

				nActualStretchSize -= nRetSize;

				if (nActualStretchSize <= 0)
				{
					break;
				}
			}
		}
	}

	// adlust control bars(first and last) to the row area and try to move
	// them as close as it possible to their virtual rectangle

	if (IsHorizontal())
	{
		rectRowWnd.left = rectNewParentWnd.left;
		rectRowWnd.right = rectNewParentWnd.right;
	}
	else
	{
		rectRowWnd.top = rectNewParentWnd.top;
		rectRowWnd.bottom = rectNewParentWnd.bottom;
	}

	// check the first and last control bars
	CPane* pBarFirst = FindFirstVisiblePane(TRUE);
	ASSERT_VALID(pBarFirst);

	AdjustPaneToRowArea(pBarFirst, rectRowWnd, hdwp);

	CPane* pBarLast = FindFirstVisiblePane(FALSE);
	ASSERT_VALID(pBarLast);

	if (pBarFirst != pBarLast)
	{
		AdjustPaneToRowArea(pBarLast, rectRowWnd, hdwp);
	}

	if (nSide != (UINT)-1 && bExpand && GetAvailableLength(TRUE) + nStretchSize > 0)
	{
		CRect rectNextControlBar;
		CRect rectNextControlBarVirt;

		for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
			ASSERT_VALID(pNextBar);

			if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
			{
				continue;
			}

			pNextBar->GetWindowRect(&rectNextControlBar);
			pNextBar->GetVirtualRect(rectNextControlBarVirt);

			if (rectNextControlBar != rectNextControlBarVirt)
			{
				// always try to move to the virtual rect's direction
				// if the bar is currently on the left side of its virtual rect
				// move it forward, otherwise - backward
				bool bMoveBackward = (IsHorizontal() && rectNextControlBar.left > rectNextControlBarVirt.left) ||
					(!IsHorizontal() && rectNextControlBar.top > rectNextControlBarVirt.top);

				int nOffsetToMove = 0;
				if (IsHorizontal() &&(nSide == WMSZ_LEFT || nSide == WMSZ_RIGHT))
				{
					nOffsetToMove = min(abs(nOffset), abs(rectNextControlBarVirt.left - rectNextControlBar.left));
				}
				else if (!IsHorizontal() &&(nSide == WMSZ_TOP || nSide == WMSZ_BOTTOM))
				{
					nOffsetToMove = min(abs(nOffset), abs(rectNextControlBarVirt.top - rectNextControlBar.top));
				}
				int nSaveOffset = nOffsetToMove;
				if (IsEnoughSpaceToMove(pNextBar, !bMoveBackward, nSaveOffset))
				{
					MovePane(pNextBar, nOffsetToMove, !bMoveBackward, hdwp);
				}
			}
		}
	}
}

void CDockingPanesRow::AdjustPaneToRowArea(CPane* pBar, const CRect& rectRow, HDWP& hdwp)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	CRect rectBarWnd;
	pBar->GetWindowRect(rectBarWnd);

	CPoint ptOffset(0, 0);
	if (IsHorizontal())
	{
		if (rectBarWnd.left < rectRow.left)
		{
			ptOffset = CPoint(rectRow.left - rectBarWnd.left, 0);
			MovePane(pBar, ptOffset, FALSE, hdwp);
		}

		if (rectBarWnd.right > rectRow.right)
		{
			ptOffset = CPoint(rectRow.right - rectBarWnd.right, 0);
			MovePane(pBar, ptOffset, FALSE, hdwp);
		}
	}
	else
	{
		if (rectBarWnd.top < rectRow.top)
		{
			ptOffset = CPoint(0, rectRow.top - rectBarWnd.top);
			MovePane(pBar, ptOffset, FALSE, hdwp);
		}

		if (rectBarWnd.bottom > rectRow.bottom)
		{
			ptOffset = CPoint(0, rectRow.bottom - rectBarWnd.bottom);
			MovePane(pBar, ptOffset, FALSE, hdwp);
		}
	}
}

BOOL CDockingPanesRow::ReplacePane(CPane* pBarOld, CPane* pBarNew)
{
	ASSERT_VALID(this);

	POSITION pos = m_lstControlBars.Find(pBarOld);
	if (pos != NULL)
	{
		m_lstControlBars.InsertAfter(pos, pBarNew);
		m_lstControlBars.RemoveAt(pos);
		return TRUE;
	}
	return FALSE;
}

BOOL CDockingPanesRow::IsExclusiveRow() const
{
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);
		if (!pNextBar->DoesAllowSiblingBars())
		{
			return TRUE;
		}
	}

	return FALSE;
}

int CDockingPanesRow::CalcLastPaneOffset()
{
	if (m_lstControlBars.IsEmpty())
	{
		return 0;
	}

	CPane* pLastBar = (CPane*) m_lstControlBars.GetTail();
	ASSERT_VALID(pLastBar);

	CRect rect;
	pLastBar->GetWindowRect(rect);

	m_pParentDockBar->ScreenToClient(rect);

	return IsHorizontal() ? rect.right : rect.bottom;
}

void CDockingPanesRow::RedrawAll()
{
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);
		pNextBar->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
	}
}

void CDockingPanesRow::GetGroupFromPane(CPane* pBar, CObList& lst)
{
	POSITION pos = m_lstControlBars.Find(pBar);
	if (pos == NULL)
	{
		return;
	}

	POSITION posGrp = NULL;

	// find first control bar in group
	for (posGrp = pos; posGrp != NULL;)
	{
		CPane* pPrevBar = (CPane*) m_lstControlBars.GetPrev(posGrp);
		ASSERT_VALID(pPrevBar);
		if (pPrevBar->m_bFirstInGroup)
		{
			if (posGrp == NULL)
			{
				posGrp =m_lstControlBars.GetHeadPosition();
			}
			else
			{
				m_lstControlBars.GetNext(posGrp);
			}
			break;
		}
	}

	// collect all bars in the group
	while (posGrp != NULL)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(posGrp);
		ASSERT_VALID(pNextBar);
		lst.AddTail(pNextBar);

		if (pNextBar->m_bLastInGroup)
		{
			break;
		}
	}
}

void CDockingPanesRow::BeginTrans()
{
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);
		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}
		pNextBar->FillWindowRect();
	}
}

void CDockingPanesRow::CommitTrans()
{
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);
		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}
		CRect rect = pNextBar->GetPaneRect();
		CRect rectWnd;
		pNextBar->GetWindowRect(rectWnd);

		if (rect == rectWnd)
		{
			continue;
		}

		pNextBar->GetParent()->ScreenToClient(rect);
		pNextBar->SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
	}
}

int CDockingPanesRow::GetAvailableLengthRect()
{
	CRect rectRow;
	GetClientRect(rectRow);

	int nTotalBarLength = 0;
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pNextBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pNextBar);
		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		CRect rectWnd = pNextBar->GetPaneRect();
		nTotalBarLength += IsHorizontal() ? rectWnd.Width() : rectWnd.Height();
	}

	// debug variable
	int nAvailableLength = IsHorizontal() ? rectRow.Width() - nTotalBarLength : rectRow.Height() - nTotalBarLength;

	return nAvailableLength;
}

int CDockingPanesRow::StretchPaneRect(CPane* pBar, int nStretchSize)
{
	// the bar is stretched - calculate how far it can be expanded and do not
	// exceed its original size
	int nAvailExpandSize = pBar->GetAvailableExpandSize();
	int nAvailStretchSize = pBar->GetAvailableStretchSize();

	int nActualStretchSize = 0;
	if (nStretchSize > 0)
	{
		if (nAvailExpandSize == 0)
		{
			return 0;
		}
		// the bar is expanded
		nActualStretchSize = nAvailExpandSize > nStretchSize ? nStretchSize : nAvailExpandSize;
	}
	else
	{
		nActualStretchSize = nAvailStretchSize < abs(nStretchSize) ? -nAvailStretchSize : nStretchSize;
	}

	CRect rect = pBar->GetPaneRect();

	if (IsHorizontal())
	{
		rect.right += nActualStretchSize;
	}
	else
	{
		rect.bottom += nActualStretchSize;
	}

	if (abs(nActualStretchSize) > 0)
	{
		pBar->SetPaneRect(rect);
	}

	return nActualStretchSize;
}

void CDockingPanesRow::ArrangePanesRect(CPane* pInitialBar)
{
	ASSERT_VALID(this);

	if (m_lstControlBars.IsEmpty())
	{
		return;
	}

	CRect rectRow;
	GetClientRect(rectRow);

	if (rectRow.IsRectEmpty())
	{
		// the row still is not initialized
		return;
	}

	HDWP hdwp = NULL;
	int nAvailLength = GetAvailableLengthRect();

	// handle single bar
	if (m_lstControlBars.GetCount() == 1)
	{
		if (pInitialBar == NULL)
		{
			pInitialBar = (CPane*) m_lstControlBars.GetHead();
		}
		ASSERT_VALID(pInitialBar);

		if (nAvailLength < 0)
		{
			StretchPaneRect(pInitialBar, nAvailLength);
			CRect rectBar = pInitialBar->GetPaneRect();
			pInitialBar->SetPaneRect(rectBar);
			return;
		}
	}

	if (pInitialBar != NULL)
	{
		ResolveIntersectionRect(pInitialBar, false);
	}

	if (pInitialBar == NULL)
	{
		pInitialBar = (CPane*) m_lstControlBars.GetHead();
	}

	ResolveIntersectionRect(pInitialBar, true);

	CPane* pFirstBar = FindFirstVisiblePane(TRUE);
	// how far the first bar is out of row bounds
	int nLeftOuterOffset = GetOutOfBoundsOffsetRect(pFirstBar, TRUE);

	if (nLeftOuterOffset > 0)
	{
		ShiftPanesRect(pFirstBar, nLeftOuterOffset, TRUE);
	}

	CPane* pLastBar = FindFirstVisiblePane(FALSE);
	int nRightOuterOffset = GetOutOfBoundsOffsetRect(pLastBar, FALSE);

	int nStretchSize = 0;
	if (nRightOuterOffset > 0 && nAvailLength > 0)
	{
		ShiftPanesRect(pLastBar, -nRightOuterOffset, FALSE);
	}
	else if (nRightOuterOffset > 0 && nAvailLength <= 0)
	{
		nStretchSize = nAvailLength;
		ShiftPanesRect(pLastBar, -(nRightOuterOffset - abs(nAvailLength)), FALSE);
	}
	else if (nRightOuterOffset < 0)
	{
		// nothing to do
	}

	if (nStretchSize < 0)
	{
		for (POSITION pos = m_lstControlBars.GetTailPosition(); pos != NULL;)
		{
			CPane* pPrevBar = (CPane*) m_lstControlBars.GetPrev(pos);
			ASSERT_VALID(pPrevBar);

			if (!pPrevBar->IsVisible() && !m_bIgnoreBarVisibility)
			{
				continue;
			}

			int nRetSize = pPrevBar->StretchPaneDeferWndPos(nStretchSize, hdwp);

			MovePaneRect(pPrevBar, abs(nStretchSize) - abs(nRetSize), false);

			if (nRetSize == nStretchSize)
			{
				break;
			}
			else
			{
				nStretchSize -= nRetSize;
			}
		}
	}
}

void CDockingPanesRow::ResolveIntersectionRect(CPane* pBar, bool bForward)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	POSITION posStart = m_lstControlBars.Find(pBar);

	CRect rectBarWnd;
	rectBarWnd.SetRectEmpty();

	CRect rectRowWnd;
	GetWindowRect(rectRowWnd);

	CRect rectIntersect;
	CRect rectMovedBar;

	for (POSITION pos = posStart; pos != NULL;)
	{
		CPane* pNextBar = (CPane*)(bForward ? m_lstControlBars.GetNext(pos) : m_lstControlBars.GetPrev(pos));

		ASSERT_VALID(pNextBar);

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		rectBarWnd = pNextBar->GetPaneRect();

		CPane* pMovedBar = NULL;
		POSITION posSave = NULL;
		for (POSITION posMoved = pos; posMoved != NULL;)
		{
			posSave = posMoved;
			pMovedBar = (CPane*)(bForward ? m_lstControlBars.GetNext(posMoved) : m_lstControlBars.GetPrev(posMoved));

			if (pMovedBar->IsVisible() || m_bIgnoreBarVisibility)
			{
				break;
			}
		}

		if (pMovedBar == NULL)
		{
			break;
		}

		rectMovedBar = pMovedBar->GetPaneRect();

		if (bForward &&(IsHorizontal() && rectMovedBar.left > rectBarWnd.right || !IsHorizontal() && rectMovedBar.top > rectBarWnd.bottom) || !bForward &&
			(IsHorizontal() && rectMovedBar.right < rectBarWnd.left || !IsHorizontal() && rectMovedBar.bottom < rectBarWnd.top))
		{
			pos = posSave;
			continue;
		}

		int nMoveOffset = 0;
		if (bForward)
		{
			nMoveOffset = IsHorizontal() ? rectBarWnd.right - rectMovedBar.left : rectBarWnd.bottom - rectMovedBar.top;
		}
		else
		{
			nMoveOffset = IsHorizontal() ? rectMovedBar.right - rectBarWnd.left : rectMovedBar.bottom - rectBarWnd.top;
		}

		MovePaneRect(pMovedBar, nMoveOffset, bForward);
		pos = posSave;
	}
}

int CDockingPanesRow::GetOutOfBoundsOffsetRect(CPane* pBar, BOOL bLeftTopBound)
{
	ASSERT_VALID(this);

	CRect rectBar;
	CRect rectRow;

	if (pBar == NULL)
	{
		pBar = (CPane* )(bLeftTopBound ? m_lstControlBars.GetHead() : m_lstControlBars.GetTail());
	}

	ASSERT_VALID(pBar);

	rectBar = pBar->GetPaneRect();
	GetWindowRect(rectRow);

	int nBoundOffset = 0;

	// the offset is greater than zero if the bar is out of bounds
	if (IsHorizontal())
	{
		nBoundOffset = bLeftTopBound ?  rectRow.left - rectBar.left : rectBar.right - rectRow.right;
	}
	else
	{
		nBoundOffset = bLeftTopBound ? rectRow.top - rectBar.top : rectBar.bottom - rectRow.bottom;
	}

	return nBoundOffset;
}

void CDockingPanesRow::ShiftPanesRect(CPane* pControlBar, int nOffset, BOOL bForward)
{
	ASSERT_VALID(this);
	ASSERT(!m_lstControlBars.IsEmpty());

	if (nOffset == 0)
	{
		return;
	}

	POSITION pos = NULL;

	if (pControlBar != NULL)
	{
		pos = m_lstControlBars.Find(pControlBar);
	}
	else
	{
		pos = bForward ? m_lstControlBars.GetHeadPosition() : m_lstControlBars.GetTailPosition();
		pControlBar = (CPane*) m_lstControlBars.GetAt(pos);
	}

	int nMoveOffset = nOffset;

	CRect rectBar; rectBar.SetRectEmpty();

	while (pos != NULL)
	{
		CPane* pNextBar = (CPane*)(bForward ? m_lstControlBars.GetNext(pos) : m_lstControlBars.GetPrev(pos));

		if (!pNextBar->IsVisible() && !m_bIgnoreBarVisibility)
		{
			continue;
		}

		ASSERT_VALID(pNextBar);
		CRect rectNextBar = pNextBar->GetPaneRect();

		if (pNextBar != pControlBar && !rectBar.IsRectEmpty())
		{
			if (IsHorizontal())
			{
				nMoveOffset -= bForward ? rectNextBar.left - rectBar.right : rectNextBar.right - rectBar.left;
			}
			else
			{
				nMoveOffset -= bForward ? rectNextBar.top - rectBar.bottom : rectNextBar.bottom - rectBar.top;
			}
		}

		if (nMoveOffset <= 0 && bForward || nMoveOffset >= 0 && !bForward)
		{
			break;
		}

		rectBar = rectNextBar;
		IsHorizontal() ? rectNextBar.OffsetRect(nMoveOffset, 0) : rectNextBar.OffsetRect(0, nMoveOffset);

		pNextBar->SetPaneRect(rectNextBar);
	}
}

void CDockingPanesRow::MovePaneRect(CPane* pControlBar, int nOffset, bool bForward)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	if (nOffset == 0)
	{
		return;
	}

	CRect rectBarWnd = pControlBar->GetPaneRect();

	if (IsHorizontal())
	{
		rectBarWnd.OffsetRect(bForward ? nOffset : -nOffset, 0);
	}
	else
	{
		rectBarWnd.OffsetRect(0, bForward ? nOffset : -nOffset);
	}

	pControlBar->SetPaneRect(rectBarWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdrawmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <math.h>
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxdrawmanager.h"
#include "afxtoolbarimages.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

const double AFX_PI = 3.1415926;

#define AFX_CLR_TO_RGBA(c) c | 0xFF000000
#define AFX_RGB_TO_RGBA(r, g, b) AFX_CLR_TO_RGBA(RGB(r, g, b))
#define AFX_RGBA(r, g, b, a) RGB(r, g, b) |(a << 24)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

HBITMAP CDrawingManager::CreateBitmap_32(const CSize& size, void** pBits)
{
	ASSERT(0 < size.cx);
	ASSERT(0 != size.cy);

	if (pBits != NULL)
	{
		*pBits = NULL;
	}

	if (size.cx <= 0 || size.cy == 0)
	{
		return NULL;
	}

	BITMAPINFO bi = {0};

	// Fill in the BITMAPINFOHEADER
	bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
	bi.bmiHeader.biWidth       = size.cx;
	bi.bmiHeader.biHeight      = size.cy;
	bi.bmiHeader.biSizeImage   = size.cx * abs(size.cy);
	bi.bmiHeader.biPlanes      = 1;
	bi.bmiHeader.biBitCount    = 32;
	bi.bmiHeader.biCompression = BI_RGB;

	LPVOID pData = NULL;
	HBITMAP hbmp = ::CreateDIBSection(NULL, &bi, DIB_RGB_COLORS, &pData, NULL, 0);

	if (pData != NULL && hbmp != NULL && pBits != NULL)
	{
		*pBits = pData;
	}

	return hbmp;
}

HBITMAP CDrawingManager::CreateBitmap_32(HBITMAP bitmap, COLORREF clrTransparent/* = -1*/)
{
	if (bitmap == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	BITMAP bmp;
	if (::GetObject(bitmap, sizeof(BITMAP), &bmp) == 0)
	{
		ASSERT(FALSE);
		return NULL;
	}

	if (bmp.bmBits == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	int nHeight = bmp.bmHeight;
	LPVOID lpBits = NULL;
	HBITMAP hbmp = CreateBitmap_32(CSize(bmp.bmWidth, nHeight), &lpBits);
	nHeight = abs(nHeight);

	if (hbmp != NULL)
	{
		DWORD nSizeImage = bmp.bmWidth * nHeight;

		if (bmp.bmBitsPixel == 32)
		{
			memcpy(lpBits, bmp.bmBits, nSizeImage * 4);
		}
		else
		{
			CDC dcSrc;
			dcSrc.CreateCompatibleDC(NULL);
			HBITMAP hbmpSrc = (HBITMAP)dcSrc.SelectObject(bitmap);

			if (hbmpSrc != NULL)
			{
				CDC dcDst;
				dcDst.CreateCompatibleDC (NULL);
				HBITMAP hbmpDst = (HBITMAP)dcDst.SelectObject(hbmp);

				dcDst.BitBlt(0, 0, bmp.bmWidth, nHeight, &dcSrc, 0, 0, SRCCOPY);

				dcDst.SelectObject(hbmpDst);
				dcSrc.SelectObject(hbmpSrc);

				COLORREF* pBits = (COLORREF*)lpBits;
				if (clrTransparent == -1)
				{
					for (DWORD i = 0; i < nSizeImage; i++)
					{
						*pBits |= 0xFF000000;
						pBits++;
					}
				}
				else
				{
					COLORREF clrTrans = RGB(GetBValue(clrTransparent), GetGValue(clrTransparent), GetRValue(clrTransparent));

					for (DWORD i = 0; i < nSizeImage; i++)
					{
						if (*pBits != clrTrans)
						{
							*pBits |= 0xFF000000;
						}
						else
						{
							*pBits = (COLORREF)0;
						}

						pBits++;
					}
				}
			}
		}
	}

	return hbmp;
}

CDrawingManager::CDrawingManager(CDC& m_dc) : m_dc(m_dc)
{
}

CDrawingManager::~CDrawingManager()
{
}

BOOL CDrawingManager::HighlightRect(CRect rect, int nPercentage, COLORREF clrTransparent, int nTolerance, COLORREF clrBlend)
{
	if (nPercentage == 100)
	{
		// Nothing to do
		return TRUE;
	}

	if (rect.Height() <= 0 || rect.Width() <= 0)
	{
		return TRUE;
	}

	if (afxGlobalData.m_nBitsPerPixel <= 8)
	{
		CMFCToolBarImages::FillDitheredRect(&m_dc, rect);
		return TRUE;
	}

	if (clrBlend != (COLORREF)-1 && nPercentage > 100)
	{
		return FALSE;
	}

	int cx = rect.Width();
	int cy = rect.Height();

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	// Gets the whole menu and changes the shadow.
	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, cx, cy))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	COLORREF* pBits;
	HBITMAP hmbpDib = CreateBitmap_32(CSize(cx, cy), (LPVOID*)&pBits);

	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	dcMem.SelectObject(hmbpDib);
	dcMem.BitBlt(0, 0, cx, cy, &m_dc, rect.left, rect.top, SRCCOPY);

	if (clrTransparent != -1)
	{
		clrTransparent = RGB(GetBValue(clrTransparent), GetGValue(clrTransparent), GetRValue(clrTransparent));
	}

#pragma warning(disable : 6269)
	for (int pixel = 0; pixel < (cx * cy); pixel++, *pBits++)
	{
		COLORREF color = (COLORREF) *pBits;

		BOOL bIgnore = FALSE;

		if (nTolerance > 0)
		{
			bIgnore = ( abs(GetRValue(color) - GetRValue(clrTransparent)) < nTolerance &&
				abs(GetGValue(color) - GetGValue(clrTransparent)) < nTolerance && abs(GetBValue(color) - GetBValue(clrTransparent)) < nTolerance);
		}
		else
		{
			bIgnore = color == clrTransparent;
		}

		if (!bIgnore)
		{
			if (nPercentage == -1)
			{
				*pBits = AFX_RGB_TO_RGBA(min(255, (2 * GetRValue(color) + GetBValue(afxGlobalData.clrBtnHilite)) / 3),
					min(255, (2 * GetGValue(color) + GetGValue(afxGlobalData.clrBtnHilite)) / 3), min(255, (2 * GetBValue(color) + GetRValue(afxGlobalData.clrBtnHilite)) / 3));
			}
			else
			{
				if (clrBlend == (COLORREF)-1)
				{
					*pBits = AFX_CLR_TO_RGBA(PixelAlpha(color, .01 * nPercentage, .01 * nPercentage, .01 * nPercentage));
				}
				else
				{
					long R = GetRValue(color);
					long G = GetGValue(color);
					long B = GetBValue(color);

					*pBits = AFX_RGB_TO_RGBA(min(255, R + ::MulDiv(GetBValue(clrBlend) - R, nPercentage, 100)),
						min(255, G + ::MulDiv(GetGValue(clrBlend) - G, nPercentage, 100)), min(255, B + ::MulDiv(GetRValue(clrBlend) - B, nPercentage, 100)));
				}
			}
		}
	}
#pragma warning(default : 6269)

	// Copy highligted bitmap back to the screen:
	m_dc.BitBlt(rect.left, rect.top, cx, cy, &dcMem, 0, 0, SRCCOPY);

	dcMem.SelectObject(pOldBmp);
	DeleteObject(hmbpDib);

	return TRUE;
}

void CDrawingManager::MirrorRect(CRect rect, BOOL bHorz/* = TRUE*/)
{
	if (rect.Height() <= 0 || rect.Width() <= 0)
	{
		return;
	}

	CRect rectClip;
	m_dc.GetClipBox(rectClip);

	CRect rectUnion;
	rectUnion.UnionRect(rectClip, rect);

	if (rectUnion != rectClip)
	{
		return;
	}

	int cx = rect.Width();
	int cy = rect.Height();

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return;
	}

	// Gets the whole menu and changes the shadow.
	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, cx, cy))
	{
		ASSERT(FALSE);
		return;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	COLORREF* pBits;
	HBITMAP hmbpDib = CreateBitmap_32(CSize(cx, cy), (LPVOID*)&pBits);

	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	dcMem.SelectObject(hmbpDib);
	dcMem.BitBlt(0, 0, cx, cy, &m_dc, rect.left, rect.top, SRCCOPY);

	if (bHorz)
	{
		for (int y = 0; y <= cy; y++)
		{
			for (int x = 0; x <= cx / 2; x++)
			{
				int xRight = cx - x - 1;
				int y1 = cy - y;

				if (cx * y1 + x >= cx * cy || cx * y1 + xRight >= cx * cy)
				{
					continue;
				}

				COLORREF* pColorLeft = (COLORREF*)(pBits + cx * y1 + x);
				COLORREF colorSaved = *pColorLeft;

				COLORREF* pColorRight = (COLORREF*)(pBits + cx * y1 + xRight);

				*pColorLeft = *pColorRight;
				*pColorRight = colorSaved;
			}
		}
	}
	else
	{
		for (int y = 0; y <= cy / 2; y++)
		{
			for (int x = 0; x < cx; x++)
			{
				int yBottom = cy - y - 1;

				COLORREF* pColorTop = (COLORREF*)(pBits + cx * y + x);
				COLORREF colorSaved = *pColorTop;

				COLORREF* pColorBottom = (COLORREF*)(pBits + cx * yBottom + x);

				*pColorTop = *pColorBottom;
				*pColorBottom = colorSaved;
			}
		}
	}

	m_dc.BitBlt(rect.left, rect.top, cx, cy, &dcMem, 0, 0, SRCCOPY);

	dcMem.SelectObject(pOldBmp);
	DeleteObject(hmbpDib);
}

BOOL CDrawingManager::GrayRect(CRect rect, int nPercentage, COLORREF clrTransparent, COLORREF clrDisabled)
{
	if (rect.Height() <= 0 || rect.Width() <= 0)
	{
		return TRUE;
	}

	if (afxGlobalData.m_nBitsPerPixel <= 8)
	{
		CMFCToolBarImages::FillDitheredRect(&m_dc, rect);
		return TRUE;
	}

	int cx = rect.Width();
	int cy = rect.Height();

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	// Gets the whole menu and changes the shadow.
	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, cx, cy))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	COLORREF* pBits;
	HBITMAP hmbpDib = CreateBitmap_32(CSize(cx, cy), (LPVOID*)&pBits);

	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	dcMem.SelectObject(hmbpDib);
	dcMem.BitBlt(0, 0, cx, cy, &m_dc, rect.left, rect.top, SRCCOPY);

	if (clrTransparent != (COLORREF)-1)
	{
		clrTransparent = RGB(GetBValue(clrTransparent), GetGValue(clrTransparent), GetRValue(clrTransparent));
	}

	if (clrDisabled == (COLORREF)-1)
	{
		clrDisabled = afxGlobalData.clrBtnHilite;
	}

#pragma warning(disable : 6269)
	for (int pixel = 0; pixel < (cx * cy); pixel++, *pBits++)
	{
		COLORREF color = (COLORREF) *pBits;
		if (color != clrTransparent)
		{
			double H,S,L;
			RGBtoHSL(color, &H, &S, &L);
			color = HLStoRGB_ONE(H,L,0);

			if (nPercentage == -1)
			{
				*pBits = AFX_RGB_TO_RGBA(min(255, GetRValue(color) +((GetBValue(clrDisabled) - GetRValue(color)) / 2)),
					min(255, GetGValue(color) +((GetGValue(clrDisabled) - GetGValue(color)) / 2)), min(255, GetBValue(color) +((GetRValue(clrDisabled) - GetBValue(color)) / 2)));
			}
			else
			{
				*pBits = AFX_CLR_TO_RGBA(PixelAlpha(color, .01 * nPercentage, .01 * nPercentage, .01 * nPercentage));
			}
		}
	}
#pragma warning(default : 6269)

	// Copy highligted bitmap back to the screen:
	m_dc.BitBlt(rect.left, rect.top, cx, cy, &dcMem, 0, 0, SRCCOPY);

	dcMem.SelectObject(pOldBmp);
	DeleteObject(hmbpDib);

	return TRUE;
}

void CDrawingManager::_FillGradient(CRect rect, COLORREF colorStart, COLORREF colorFinish, BOOL bHorz/* = TRUE*/, int nStartFlatPercentage/* = 0*/, int nEndFlatPercentage/* = 0*/)
{
	if (colorStart == colorFinish)
	{
		CBrush br(colorStart);
		m_dc.FillRect(rect, &br);
		return;
	}

	if (nStartFlatPercentage > 0)
	{
		ASSERT(nStartFlatPercentage <= 100);

		if (bHorz)
		{
			CRect rectTop = rect;
			rectTop.bottom = rectTop.top + rectTop.Height() * nStartFlatPercentage / 100;
			rect.top = rectTop.bottom;

			CBrush br(colorFinish);
			m_dc.FillRect(rectTop, &br);
		}
		else
		{
			CRect rectLeft = rect;
			rectLeft.right = rectLeft.left + rectLeft.Width() * nStartFlatPercentage / 100;
			rect.left = rectLeft.right;

			CBrush br(colorStart);
			m_dc.FillRect(rectLeft, &br);
		}
	}

	if (nEndFlatPercentage > 0)
	{
		ASSERT(nEndFlatPercentage <= 100);

		if (bHorz)
		{
			CRect rectBottom = rect;
			rectBottom.top = rectBottom.bottom - rectBottom.Height() * nEndFlatPercentage / 100;
			rect.bottom = rectBottom.top;

			CBrush br(colorStart);
			m_dc.FillRect(rectBottom, &br);
		}
		else
		{
			CRect rectRight = rect;
			rectRight.left = rectRight.right - rectRight.Width() * nEndFlatPercentage / 100;
			rect.right = rectRight.left;

			CBrush br(colorFinish);
			m_dc.FillRect(rectRight, &br);
		}
	}

	if (nEndFlatPercentage + nStartFlatPercentage > 100)
	{
		ASSERT(FALSE);
		return;
	}

	// this will make 2^6 = 64 fountain steps
	int nShift = 6;
	int nSteps = 1 << nShift;

	for (int i = 0; i < nSteps; i++)
	{
		// do a little alpha blending
		BYTE bR = (BYTE)((GetRValue(colorStart) *(nSteps - i) + GetRValue(colorFinish) * i) >> nShift);
		BYTE bG = (BYTE)((GetGValue(colorStart) *(nSteps - i) + GetGValue(colorFinish) * i) >> nShift);
		BYTE bB = (BYTE)((GetBValue(colorStart) *(nSteps - i) + GetBValue(colorFinish) * i) >> nShift);

		CBrush br(RGB(bR, bG, bB));

		// then paint with the resulting color
		CRect r2 = rect;
		if (bHorz)
		{
			r2.bottom = rect.bottom - ((i * rect.Height()) >> nShift);
			r2.top = rect.bottom - (((i + 1) * rect.Height()) >> nShift);
			if (r2.Height() > 0)
				m_dc.FillRect(r2, &br);
		}
		else
		{
			r2.left = rect.left + ((i * rect.Width()) >> nShift);
			r2.right = rect.left + (((i + 1) * rect.Width()) >> nShift);
			if (r2.Width() > 0)
				m_dc.FillRect(r2, &br);
		}
	}
}
void CDrawingManager::FillGradient(CRect rect, COLORREF colorStart, COLORREF colorFinish, BOOL bHorz/* = TRUE*/, int nStartFlatPercentage/* = 0*/, int nEndFlatPercentage/* = 0*/)
{
	if (!CMFCToolBarImages::m_bIsDrawOnGlass)
	{
		_FillGradient(rect, colorStart, colorFinish, bHorz, nStartFlatPercentage, nEndFlatPercentage);
	}
	else
	{
		CRect rt(rect);
		rt.NormalizeRect();

		CSize size(rt.Size());
		if (size.cx == 0 || size.cy == 0)
		{
			return;
		}

		// Copy screen content into the memory bitmap:
		CDC dcMem;
		if (!dcMem.CreateCompatibleDC(&m_dc))
		{
			ASSERT(FALSE);
			return;
		}

		// Gets the whole menu and changes the shadow.
		CBitmap bmpMem;
		if (!bmpMem.CreateCompatibleBitmap(&m_dc, size.cx, size.cy))
		{
			ASSERT(FALSE);
			return;
		}

		CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
		ENSURE(pOldBmp != NULL);

		COLORREF* pBits;
		HBITMAP hmbpDib = CreateBitmap_32(size, (LPVOID*)&pBits);

		if (hmbpDib == NULL || pBits == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		dcMem.SelectObject(hmbpDib);

		CDrawingManager dm(dcMem);
		dm._FillGradient(CRect(CPoint(0, 0), size), colorStart, colorFinish, bHorz, nStartFlatPercentage, nEndFlatPercentage);

		int sizeImage = size.cx * size.cy;
		for (int i = 0; i < sizeImage; i++)
		{
			*pBits |= 0xFF000000;
			pBits++;
		}

		// Copy bitmap back to the screen:
		m_dc.BitBlt(rt.left, rt.top, size.cx, size.cy, &dcMem, 0, 0, SRCCOPY);

		dcMem.SelectObject(pOldBmp);
		DeleteObject(hmbpDib);
	}
}

void CDrawingManager::FillGradient2(CRect rect, COLORREF colorStart, COLORREF colorFinish, int nAngle)
{
	if (colorStart == colorFinish)
	{
		CBrush br(colorStart);
		m_dc.FillRect(rect, &br);
		return;
	}

	// Process simple cases:
	switch (nAngle)
	{
	case 0:
	case 360:
		FillGradient(rect, colorStart, colorFinish, FALSE);
		return;

	case 90:
		FillGradient(rect, colorStart, colorFinish, TRUE);
		return;

	case 180:
		FillGradient(rect, colorFinish, colorStart, FALSE);
		return;

	case 270:
		FillGradient(rect, colorFinish, colorStart, TRUE);
		return;
	}

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return;
	}

	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, rect.Width(), rect.Height()))
	{
		ASSERT(FALSE);
		return;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	CPen* pOldPen = (CPen*) dcMem.SelectStockObject(NULL_PEN);

	int nShift = 6;
	int nSteps = 1 << nShift;

	const double fAngle = AFX_PI *(nAngle + 180) / 180;
	const int nOffset = (int)(cos(fAngle) * rect.Height());
	const int nTotalWidth = rect.Width() + abs(nOffset);

	const int xStart = nOffset > 0 ? - nOffset : 0;

	for (int i = 0; i < nSteps; i++)
	{
		// do a little alpha blending
		BYTE bR = (BYTE)((GetRValue(colorStart) *(nSteps - i) + GetRValue(colorFinish) * i) >> nShift);
		BYTE bG = (BYTE)((GetGValue(colorStart) *(nSteps - i) + GetGValue(colorFinish) * i) >> nShift);
		BYTE bB = (BYTE)((GetBValue(colorStart) *(nSteps - i) + GetBValue(colorFinish) * i) >> nShift);

		CBrush br(RGB(bR, bG, bB));

		int x11 = xStart +((i * nTotalWidth) >> nShift);
		int x12 = xStart +(((i + 1) * nTotalWidth) >> nShift);

		if (x11 == x12)
		{
			continue;
		}

		int x21 = x11 + nOffset;
		int x22 = x21 +(x12 - x11);

		POINT points [4];
		points [0].x = x11;
		points [0].y = 0;
		points [1].x = x12;
		points [1].y = 0;
		points [2].x = x22;
		points [2].y = rect.Height();
		points [3].x = x21;
		points [3].y = rect.Height();

		CBrush* pOldBrush = dcMem.SelectObject(&br);
		dcMem.Polygon(points, 4);
		dcMem.SelectObject(pOldBrush);
	}

	dcMem.SelectObject(pOldPen);

	// Copy bitmap back to the screen:
	m_dc.BitBlt(rect.left, rect.top, rect.Width(), rect.Height(), &dcMem, 0, 0, SRCCOPY);
	dcMem.SelectObject(pOldBmp);
}

void CDrawingManager::Fill4ColorsGradient(CRect rect, COLORREF colorStart1, COLORREF colorFinish1,
	COLORREF colorStart2, COLORREF colorFinish2, BOOL bHorz/* = TRUE*/, int nPercentage) /* = 50, 0 - 100 */
{
	ASSERT(nPercentage >= 0);
	ASSERT(nPercentage <= 100);

	CRect rectFirst = rect;
	CRect rectSecond = rect;

	if (!bHorz)
	{
		rectFirst.right = rectFirst.left + rectFirst.Width() * nPercentage / 100;
		rectSecond.left = rectFirst.right;
	}
	else
	{
		rectFirst.bottom = rectFirst.top + rectFirst.Height() * nPercentage / 100;
		rectSecond.top = rectFirst.bottom;
	}

	FillGradient(rectFirst, colorStart1, colorFinish1, bHorz);
	FillGradient(rectSecond, colorStart2, colorFinish2, bHorz);
}

void CDrawingManager::FillAlpha(const CRect& rect, BYTE bValue /* = 255*/)
{
	const int cx = rect.Width();
	const int cy = rect.Height();

	COLORREF* pBits = NULL;
	HBITMAP hmbpDib = CreateBitmap_32(CSize (cx, cy), (LPVOID*)&pBits);
	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CDC dcMem;
	dcMem.CreateCompatibleDC(&m_dc);

	HBITMAP hbmpOld = (HBITMAP)dcMem.SelectObject(hmbpDib);
	dcMem.BitBlt(0, 0, cx, cy, &m_dc, rect.left, rect.top, SRCCOPY);

	const DWORD dwMask = (bValue << 24) & 0xFF000000;
	for (int i = 0; i < cx * cy; i++)
	{
		*pBits |= dwMask;
		pBits++;
	}

	m_dc.BitBlt(rect.left, rect.top, cx, cy, &dcMem, 0, 0, SRCCOPY);

	dcMem.SelectObject(hbmpOld);
	DeleteObject(hmbpDib);
}

BOOL CDrawingManager::DrawGradientRing(CRect rect, COLORREF colorStart, COLORREF colorFinish, COLORREF colorBorder, int nAngle /* 0 - 360 */, int nWidth, COLORREF clrFace /* = -1 */)
{
	int cx = rect.Width();
	int cy = rect.Height();

	if (cx <= 4 || cy <= 4)
	{
		// Rectangle too small
		return FALSE;
	}

	int xOrig = rect.left;
	int yOrig = rect.top;

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, cx, cy))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	COLORREF* pBits;
	HBITMAP hmbpDib = CreateBitmap_32(CSize(cx, cy), (LPVOID*)&pBits);

	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	dcMem.SelectObject(hmbpDib);
	dcMem.BitBlt(0, 0, cx, cy, &m_dc, rect.left, rect.top, SRCCOPY);

	rect.OffsetRect(-xOrig, -yOrig);

	const int xCenter = (rect.left + rect.right) / 2;
	const int yCenter = (rect.top + rect.bottom) / 2;

	const int nSteps = 360;
	const double fDelta = 2. * AFX_PI / nSteps;
	const double fStart = AFX_PI * nAngle / 180;
	const double fFinish = fStart + 2. * AFX_PI;

	double rDelta = (double)(.5 + GetRValue(colorFinish) - GetRValue(colorStart)) / nSteps * 2;
	double gDelta = (double)(.5 + GetGValue(colorFinish) - GetGValue(colorStart)) / nSteps * 2;
	double bDelta = (double)(.5 + GetBValue(colorFinish) - GetBValue(colorStart)) / nSteps * 2;

	for (int nLevel = 0; nLevel < nWidth; nLevel++)
	{
		int i = 0;
		const int nRadius = min(rect.Width(), rect.Height()) / 2;
		const int nRectDelta = rect.Width() - rect.Height();

		if (clrFace != (COLORREF) -1 && nLevel == 0)
		{
			// Fill interior:
			CBrush brFill(clrFace);
			CBrush* pOldBrush = dcMem.SelectObject(&brFill);
			CPen* pOldPen = (CPen*) dcMem.SelectStockObject(NULL_PEN);

			if (nRectDelta == 0) // Circle
			{
				dcMem.Ellipse(rect);
			}
			else if (nRectDelta > 0) // Horizontal
			{
				dcMem.Ellipse(rect.left, rect.top, rect.left + rect.Height(), rect.bottom);
				dcMem.Ellipse(rect.right - rect.Height(), rect.top, rect.right, rect.bottom);
				dcMem.Rectangle(rect.left + rect.Height() / 2, rect.top, rect.right - rect.Height() / 2, rect.bottom);
			}
			else // Vertical
			{
				dcMem.Ellipse(rect.left, rect.top, rect.right, rect.top + rect.Width());
				dcMem.Ellipse(rect.left, rect.bottom - rect.Width(), rect.right, rect.bottom);
				dcMem.Rectangle(rect.left, rect.top + rect.Width() / 2, rect.right, rect.bottom - rect.Width() / 2);
			}

			dcMem.SelectObject(pOldBrush);
			dcMem.SelectObject(pOldPen);
		}

		int xPrev = -1;
		int yPrev = -1;

		for (double fAngle = fStart; fAngle < fFinish + fDelta; fAngle += fDelta, i ++)
		{
			const int nStep = fAngle <= (fFinish + fStart) / 2 ? i : nSteps - i;

			const BYTE bR = (BYTE) max(0, min(255, (.5 + rDelta * nStep + GetRValue(colorStart))));
			const BYTE bG = (BYTE) max(0, min(255, (.5 + gDelta * nStep + GetGValue(colorStart))));
			const BYTE bB = (BYTE) max(0, min(255, (.5 + bDelta * nStep + GetBValue(colorStart))));

			COLORREF color = nLevel == 0 && colorBorder != -1 ? colorBorder : RGB(bR, bG, bB);

			double dx = /*(fAngle >= 0 && fAngle <= AFX_PI / 2) ||(fAngle >= 3 * AFX_PI / 2) ? .5 : -.5*/0;
			double dy = /*(fAngle <= AFX_PI) ? .5 : -.5*/0;

			int x = xCenter +(int)(dx + cos(fAngle) * nRadius);
			int y = yCenter +(int)(dy + sin(fAngle) * nRadius);

			if (nRectDelta > 0)
			{
				if (x > xCenter)
				{
					x += (int)(.5 * nRectDelta);
				}
				else
				{
					x -= (int)(.5 * nRectDelta);
				}

				if (xPrev != -1 &&(xPrev > xCenter) != (x > xCenter))
				{
					for (int x1 = min(x, xPrev); x1 < max(x, xPrev); x1++)
					{
						SetPixel(pBits, cx, cy, x1, y, color);
					}
				}
			}
			else if (nRectDelta < 0)
			{
				if (y > yCenter)
				{
					y -= (int)(.5 * nRectDelta);
				}
				else
				{
					y += (int)(.5 * nRectDelta);
				}

				if (yPrev != -1 &&(yPrev > yCenter) != (y > yCenter))
				{
					for (int y1 = min(y, yPrev); y1 < max(y, yPrev); y1++)
					{
						SetPixel(pBits, cx, cy, x, y1, color);
					}
				}
			}

			SetPixel(pBits, cx, cy, x, y, color);

			xPrev = x;
			yPrev = y;
		}

		rect.DeflateRect(1, 1);
	}

	// Copy bitmap back to the screen:
	m_dc.BitBlt(xOrig, yOrig, cx, cy, &dcMem, 0, 0, SRCCOPY);

	dcMem.SelectObject(pOldBmp);
	DeleteObject(hmbpDib);

	return TRUE;
}

BOOL CDrawingManager::DrawShadow(CRect rect, int nDepth, int iMinBrightness, int iMaxBrightness,
		 CBitmap* pBmpSaveBottom, CBitmap* pBmpSaveRight, COLORREF clrBase, BOOL bRightShadow/* = TRUE*/)
{
	ASSERT(nDepth >= 0);

	if (nDepth == 0 || rect.IsRectEmpty())
	{
		return TRUE;
	}

	int cx = rect.Width();
	int cy = rect.Height();

	const BOOL bIsLeft = !bRightShadow;

	if (pBmpSaveRight != NULL && pBmpSaveRight->GetSafeHandle() != NULL && pBmpSaveBottom != NULL && pBmpSaveBottom->GetSafeHandle() != NULL)
	{
		// Shadows are already implemented, put them directly
		// to the DC:
		m_dc.DrawState(CPoint(bIsLeft ? rect.left - nDepth : rect.right, rect.top), CSize(nDepth, cy + nDepth), pBmpSaveRight, DSS_NORMAL);

		m_dc.DrawState(CPoint(bIsLeft ? rect.left - nDepth : rect.left, rect.bottom), CSize(cx + nDepth, nDepth), pBmpSaveBottom, DSS_NORMAL);
		return TRUE;
	}

	ENSURE(pBmpSaveRight == NULL || pBmpSaveRight->GetSafeHandle() == NULL);
	ENSURE(pBmpSaveBottom == NULL || pBmpSaveBottom->GetSafeHandle() == NULL);

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	// Gets the whole menu and changes the shadow.
	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, cx + nDepth, cy + nDepth))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	COLORREF* pBits;
	HBITMAP hmbpDib = CreateBitmap_32(CSize(cx + nDepth, cy + nDepth), (LPVOID*)&pBits);

	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	dcMem.SelectObject(hmbpDib);
	dcMem.BitBlt(0, 0, cx + nDepth, cy + nDepth, &m_dc, bIsLeft ? rect.left - nDepth : rect.left, rect.top, SRCCOPY);

	// Process shadowing:
	// For having a very nice shadow effect, its actually hard work. Currently,
	// I'm using a more or less "hardcoded" way to set the shadows(by using a
	// hardcoded algorythm):
	//
	// This algorithm works as follows:
	//
	// It always draws a few lines, from left to bottom, from bottom to right,
	// from right to up, and from up to left). It does this for the specified
	// shadow width and the color settings.

	// For speeding up things, iShadowOffset is the
	// value which is needed to multiply for each shadow step
	int iShadowOffset = (iMaxBrightness - iMinBrightness) / nDepth;

	// Loop for drawing the shadow
	// Actually, this was simpler to implement than I thought
	for (int c = 0; c < nDepth; c++)
	{
		// Draw the shadow from left to bottom
		for (int y = cy; y < cy +(nDepth - c); y++)
		{
			SetAlphaPixel(pBits, rect, c + nDepth, y, iMaxBrightness -((nDepth  - c) *(iShadowOffset)), nDepth, clrBase, bIsLeft);
		}

		// Draw the shadow from left to right
		for (int x = nDepth +(nDepth - c); x < cx + c; x++)
		{
			SetAlphaPixel(pBits, rect,x, cy + c, iMaxBrightness -((c) *(iShadowOffset)),nDepth, clrBase, bIsLeft);
		}

		// Draw the shadow from top to bottom
		for (int y1 = nDepth +(nDepth - c); y1 < cy + c + 1; y1++)
		{
			SetAlphaPixel(pBits, rect, cx+c, y1, iMaxBrightness -((c) *(iShadowOffset)), nDepth, clrBase, bIsLeft);
		}

		// Draw the shadow from top to left
		for (int x1 = cx; x1 < cx +(nDepth - c); x1++)
		{
			SetAlphaPixel(pBits, rect, x1, c + nDepth, iMaxBrightness -((nDepth - c) *(iShadowOffset)), nDepth, clrBase, bIsLeft);
		}
	}

	// Copy shadowed bitmap back to the screen:
	m_dc.BitBlt(bIsLeft ? rect.left - nDepth : rect.left, rect.top, cx + nDepth, cy + nDepth, &dcMem, 0, 0, SRCCOPY);

	// Save shadows in the memory bitmaps:
	if (pBmpSaveRight != NULL)
	{
		pBmpSaveRight->CreateCompatibleBitmap(&m_dc, nDepth + 1, cy + nDepth);

		dcMem.SelectObject(pBmpSaveRight);
		dcMem.BitBlt(0, 0, nDepth, cy + nDepth, &m_dc, bIsLeft ? 0 : rect.right, rect.top, SRCCOPY);
	}

	if (pBmpSaveBottom != NULL)
	{
		pBmpSaveBottom->CreateCompatibleBitmap(&m_dc, cx + nDepth, nDepth + 1);

		dcMem.SelectObject(pBmpSaveBottom);
		dcMem.BitBlt(0, 0, cx + nDepth, nDepth, &m_dc, bIsLeft ? rect.left - nDepth : rect.left, rect.bottom, SRCCOPY);
	}

	dcMem.SelectObject(pOldBmp);
	DeleteObject(hmbpDib);

	return TRUE;
}

inline int sqr(int value)
{
	return value * value;
};

inline double sqr(double value)
{
	return value * value;
};

inline int sign(int value)
{
	if (value == 0)
	{
		return 0;
	}
	else
	{
		if (value > 0)
		{
			return 1;
		}
	}

	return -1;
}

inline double sign(double value)
{
	if (value == 0.0)
	{
		return 0.0;
	}
	else
	{
		if (value > 0.0)
		{
			return 1.0;
		}
	}

	return -1.0;
}

inline double frac(double value)
{
	return value - floor(value);
}

void CDrawingManager::DrawLine(int x1, int y1, int x2, int y2, COLORREF clrLine)
{
	if (clrLine == -1)
	{
		return;
	}

	int x  = x1;
	int y  = y1;
	int dx = abs(x2 - x1);
	int dy = abs(y2 - y1);
	int sx = sign(x2 - x1);
	int sy = sign(y2 - y1);

	if (dx == 0 && dy == 0)
	{
		return;
	}

	CRect rect(x1, y1, x2, y2);
	rect.NormalizeRect();
	rect.InflateRect(0, 0, 1, 1);

	CSize size(rect.Size());
	if (size.cx == 0 || size.cy == 0)
	{
		ASSERT(FALSE);
		return;
	}

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return;
	}

	// Gets the whole menu and changes the shadow.
	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, size.cx, size.cy))
	{
		ASSERT(FALSE);
		return;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	COLORREF* pBits;
	HBITMAP hmbpDib = CreateBitmap_32(size, (LPVOID*)&pBits);

	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	dcMem.SelectObject(hmbpDib);

	bool exch = false;

	if (dy > dx)
	{
		long z = dx;
		dx = dy;
		dy = z;
		exch = true;
	}

	long e = 2 * dy - dx;
	long i = 1;

	clrLine = RGB(GetBValue(clrLine), GetGValue(clrLine), GetRValue(clrLine)) | 0xFF000000;

	do
	{
		*(pBits +(size.cy -(y - rect.top) - 1) * size.cx +(x - rect.left)) = clrLine;

		while (e >= 0)
		{
			if (exch)
			{
				x += sx;
			}
			else
			{
				y += sy;
			}

			e -= 2 * dx;
		}

		if (exch)
		{
			y += sy;
		}
		else
		{
			x += sx;
		}

		e += 2 * dy;

		i++;
	}
	while (i <= dx);

	*(pBits +(size.cy -(y - rect.top) - 1) * size.cx +(x - rect.left)) = clrLine;

	// Copy bitmap back to the screen:

	DrawAlpha(&m_dc, rect, &dcMem, CRect(CPoint(0, 0), size));

	dcMem.SelectObject(pOldBmp);
	DeleteObject(hmbpDib);
}

void CDrawingManager::DrawLineA(double x1, double y1, double x2, double y2, COLORREF clrLine)
{
	if (clrLine == -1)
	{
		return;
	}

	double xd = x2 - x1;
	double yd = y2 - y1;

	if (xd == 0 && yd == 0)
	{
		return;
	}

	bool exch = false;

	if (fabs(xd) <= fabs(yd))
	{
		exch = true;

		double tmpreal = x1;
		x1 = y1;
		y1 = tmpreal;

		tmpreal = x2;
		x2 = y2;
		y2 = tmpreal;

		tmpreal = xd;
		xd = yd;
		yd = tmpreal;
	}

	if (x1 > x2)
	{
		double tmpreal = x1;
		x1 = x2;
		x2 = tmpreal;

		tmpreal = y1;
		y1 = y2;
		y2 = tmpreal;

		xd = x2 - x1;
		yd = y2 - y1;
	}

	double f1 = 0.0;
	double f2 = 0.0;
	double f3 = 0.0;
	double f4 = 0.0;

	double grad = yd / xd;
	double yf;

	int ix1, ix2, iy1, iy2;

	{
		double xend = floor(x1 + 0.5);
		double yend = y1 + grad *(xend - x1);
		double xgap = 1.0 - frac(x1 + 0.5);
		ix1         = (int)floor(x1 + 0.5);
		iy1         = (int)floor(yend);

		f1 = (1.0 - frac(yend)) * xgap;
		f2 = frac(yend) * xgap;

		yf          = yend + grad;
		xend        = floor(x2 + 0.5);
		yend        = y2 + grad *(xend - x2);
		xgap        = 1.0 - frac(x2 - 0.5);
		ix2         = (int)floor(x2 + 0.5);
		iy2         = (int)floor(yend);

		f3 = (1.0 - frac(yend)) * xgap;
		f4 = frac(yend) * xgap;
	}

	CRect rect(ix1, iy1, ix2, iy2);

	if (exch)
	{
		rect = CRect(iy1, ix1, iy2, ix2);
	}

	rect.NormalizeRect();
	rect.InflateRect(0, 0, 1, 1);

	if (exch)
	{
		rect.right++;
	}
	else
	{
		rect.bottom++;
	}

	CSize size(rect.Size());
	if (size.cx == 0 || size.cy == 0)
	{
		ASSERT(FALSE);
		return;
	}

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return;
	}

	// Gets the whole menu and changes the shadow.
	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, size.cx, size.cy))
	{
		ASSERT(FALSE);
		return;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	COLORREF* pBits;
	HBITMAP hmbpDib = CreateBitmap_32(size, (LPVOID*)&pBits);

	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	dcMem.SelectObject(hmbpDib);

	int clrR = GetRValue(clrLine);
	int clrG = GetGValue(clrLine);
	int clrB = GetBValue(clrLine);
	int clrA = 255;

	if (exch)
	{
		COLORREF* pRow = pBits +(size.cy -(ix1 - rect.top) - 1) * size.cx +(iy1 - rect.left);
		*pRow = RGB(clrB * f1, clrG * f1, clrR * f1) |((int)(clrA * f1) << 24);
		pRow++;
		*pRow = RGB(clrB * f2, clrG * f2, clrR * f2) |((int)(clrA * f2) << 24);

		pRow = pBits +(size.cy -(ix2 - rect.top) - 1) * size.cx +(iy2 - rect.left);
		*pRow = RGB(clrB * f3, clrG * f3, clrR * f3) |((int)(clrA * f3) << 24);
		pRow++;
		*pRow = RGB(clrB * f4, clrG * f4, clrR * f4) |((int)(clrA * f4) << 24);
	}
	else
	{
		*(pBits +(size.cy -(iy1 - rect.top) - 1) * size.cx +(ix1 - rect.left)) = RGB(clrB * f1, clrG * f1, clrR * f1) |((int)(clrA * f1) << 24);
		*(pBits +(size.cy -(iy1 - rect.top + 1) - 1) * size.cx +(ix1 - rect.left)) = RGB(clrB * f2, clrG * f2, clrR * f2) |((int)(clrA * f2) << 24);

		*(pBits +(size.cy -(iy2 - rect.top) - 1) * size.cx +(ix2 - rect.left)) = RGB(clrB * f3, clrG * f3, clrR * f3) |((int)(clrA * f3) << 24);
		*(pBits +(size.cy -(iy2 - rect.top + 1) - 1) * size.cx +(ix2 - rect.left)) = RGB(clrB * f4, clrG * f4, clrR * f4) |((int)(clrA * f4) << 24);
	}

	for (int x = ix1 + 1; x <= ix2 - 1; x++)
	{
		double f = frac(yf);

		int y = (int)floor(yf);

		int B = (int)(clrB * f);
		int G = (int)(clrG * f);
		int R = (int)(clrR * f);
		int A = (int)(clrA * f);

		if (exch)
		{
			COLORREF* pRow = pBits +(size.cy -(x - rect.top) - 1) * size.cx +(y - rect.left);
			*pRow = RGB((clrB - B), (clrG - G), (clrR - R)) |((clrA - A) << 24);
			pRow++;
			*pRow = RGB(B, G, R) |(A << 24);
		}
		else
		{
			*(pBits +(size.cy -(y - rect.top) - 1) * size.cx +(x - rect.left)) = RGB((clrB - B), (clrG - G), (clrR - R)) |((clrA - A) << 24);
			*(pBits +(size.cy -(y - rect.top + 1) - 1) * size.cx +(x - rect.left)) = RGB(B, G, R) |(A << 24);
		}

		yf = yf + grad;
	}

	// Copy bitmap back to the screen:

	DrawAlpha(&m_dc, rect, &dcMem, CRect(CPoint(0, 0), size));

	dcMem.SelectObject(pOldBmp);
	DeleteObject(hmbpDib);
}

void CDrawingManager::DrawEllipse(const CRect& rect, COLORREF clrFill, COLORREF clrLine)
{
	if (clrFill == -1 && clrLine == -1)
	{
		ASSERT(FALSE);
		return;
	}

	CRect rt(rect);
	rt.NormalizeRect();

	CSize size(rt.Size());
	if (size.cx == 0 || size.cy == 0)
	{
		ASSERT(FALSE);
		return;
	}

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return;
	}

	// Gets the whole menu and changes the shadow.
	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, size.cx, size.cy))
	{
		ASSERT(FALSE);
		return;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	COLORREF* pBits;
	HBITMAP hmbpDib = CreateBitmap_32(size, (LPVOID*)&pBits);

	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	dcMem.SelectObject(hmbpDib);

	if (clrLine == -1)
	{
		clrLine = clrFill;
	}

	int brdR = GetRValue(clrLine);
	int brdG = GetGValue(clrLine);
	int brdB = GetBValue(clrLine);

	int filR = GetRValue(clrFill);
	int filG = GetGValue(clrFill);
	int filB = GetBValue(clrFill);

	BOOL bFill = clrFill != -1;
	if (bFill)
	{
		clrFill = RGB(filB, filG, filR) | 0xFF000000;
	}

	int R, G, B, A;
	COLORREF clrN, clrI;

	bool exch = false;
	double a;
	double b;
	double cx;
	double cy;

	{
		double x1 = 0;
		double x2 = size.cx - 1;
		double y1 = 0;
		double y2 = size.cy - 1;

		if (x2 < x1 )
		{
			double t  = x1;
			x1 = x2;
			x2 = t;
		}

		if (y2 < y1)
		{
			double t  = y1;
			y1 = y2;
			y2 = t;
		}

		if (y2 - y1 <= x2 - x1)
		{
			exch = true;
			double t = x1;
			x1 = y1;
			y1 = t;

			t = x2;
			x2 = y2;
			y2 = t;
		}

		a  = (x2 - x1) / 2.0;
		b  = (y2 - y1) / 2.0;
		cx = (x1 + x2) / 2.0;
		cy = (y1 + y2) / 2.0;
	}

	if (bFill)
	{
		int i1 = (int)ceil(cx - a);
		int i2 = (int)floor(cx + a);
		for (int ix = i1; ix <= i2; ix++)
		{
			double dist = 1.0 - sqr((ix - cx) / a);
			if (dist < 0)
			{
				continue;
			}

			double y = b * sqrt(dist);

			if (!exch)
			{
				int y1 = (int)ceil(cy - y);
				int y2 = (int)floor(cy + y);
				COLORREF* pRow = pBits + y1 * size.cx + ix;
				for (int i = y1; i <= y2; i++)
				{
					*pRow = clrFill;
					pRow += size.cx;
				}
			}
			else
			{
				int x1 = (int)ceil(cy - y);
				int x2 = (int)floor(cy + y);
				COLORREF* pRow = pBits + ix * size.cx + x1;
				for (int i = x1; i <= x2; i++)
				{
					*pRow = clrFill;
					pRow++;
				}
			}
		}
	}

	double t  = a * a / sqrt(a * a + b * b);
	int i1 = (int)floor(cx - t);
	int i2 = (int)ceil(cx + t);

	for (int ix = i1; ix <= i2; ix++)
	{
		double dist = 1.0 - sqr((ix - cx) / a);
		if (dist < 0)
		{
			continue;
		}

		double y  = b * sqrt(dist);
		int iy = (int)ceil(cy + y);
		double f  = iy - cy - y;

		B = (int)(brdB * f);
		G = (int)(brdG * f);
		R = (int)(brdR * f);
		A = (int)(255  * f);

		if (bFill)
		{
			double fi = 1.0 - f;
			clrN = RGB(filB * fi + B, filG * fi + G, filR * fi + R) | 0xFF000000;
		}
		else
		{
			clrN = RGB(B, G, R) |(A << 24);
		}

		clrI = RGB((brdB - B), (brdG - G), (brdR - R)) |((255 - A) << 24);

		if (!exch)
		{
			*(pBits + iy * size.cx + ix) = clrI;
			*(pBits +(iy - 1) * size.cx + ix) = clrN;
		}
		else
		{
			*(pBits + ix * size.cx + iy) = clrI;
			*(pBits + ix * size.cx + iy - 1) = clrN;
		}

		iy = (int)floor(cy - y);
		f  = cy - y - iy;

		B = (int)(brdB * f);
		G = (int)(brdG * f);
		R = (int)(brdR * f);
		A = (int)(255  * f);

		if (bFill)
		{
			double fi = 1.0 - f;
			clrN = RGB(filB * fi + B, filG * fi + G, filR * fi + R) | 0xFF000000;
		}
		else
		{
			clrN = RGB(B, G, R) |(A << 24);
		}

		clrI = RGB((brdB - B), (brdG - G), (brdR - R)) |((255 - A) << 24);

		if (!exch)
		{
			*(pBits + iy * size.cx + ix) = clrI;
			*(pBits +(iy + 1) * size.cx + ix) = clrN;
		}
		else
		{
			*(pBits + ix * size.cx + iy) = clrI;
			*(pBits + ix * size.cx + iy + 1) = clrN;
		}
	}

	t  = b * b / sqrt(a * a + b * b);
	i1 = (int)ceil(cy - t);
	i2 = (int)floor(cy + t);

	for (int iy = i1; iy <= i2; iy++)
	{
		double dist = 1.0 - sqr((iy - cy) / b);
		if (dist < 0)
		{
			continue;
		}

		double x  = a * sqrt(dist);
		int ix = (int)floor(cx - x);
		double f  = cx - x - ix;

		B = (int)(brdB * f);
		G = (int)(brdG * f);
		R = (int)(brdR * f);
		A = (int)(255  * f);

		if (bFill)
		{
			double fi = 1.0 - f;
			clrN = RGB(filB * fi + B, filG * fi + G, filR * fi + R) | 0xFF000000;
		}
		else
		{
			clrN = RGB(B, G, R) |(A << 24);
		}

		clrI = RGB((brdB - B), (brdG - G), (brdR - R)) |((255 - A) << 24);

		if (!exch)
		{
			*(pBits + iy * size.cx + ix) = clrI;
			*(pBits + iy * size.cx + ix + 1) = clrN;
		}
		else
		{
			*(pBits + ix * size.cx + iy) = clrI;
			*(pBits +(ix + 1) * size.cx + iy) = clrN;
		}

		ix = (int)ceil(cx + x);
		f  = ix - cx - x;

		B = (int)(brdB * f);
		G = (int)(brdG * f);
		R = (int)(brdR * f);
		A = (int)(255  * f);

		if (bFill)
		{
			double fi = 1.0 - f;
			clrN = RGB(filB * fi + B, filG * fi + G, filR * fi + R) | 0xFF000000;
		}
		else
		{
			clrN = RGB(B, G, R) |(A << 24);
		}

		clrI = RGB((brdB - B), (brdG - G), (brdR - R)) |((255 - A) << 24);

		if (!exch)
		{
			*(pBits + iy * size.cx + ix) = clrI;
			*(pBits + iy * size.cx + ix - 1) = clrN;
		}
		else
		{
			*(pBits + ix * size.cx + iy) = clrI;
			*(pBits +(ix - 1) * size.cx + iy) = clrN;
		}
	}

	// Copy bitmap back to the screen:
	DrawAlpha(&m_dc, rt, &dcMem, CRect(CPoint(0, 0), size));

	dcMem.SelectObject(pOldBmp);
	DeleteObject(hmbpDib);
}

void CDrawingManager::DrawRect(const CRect& rect, COLORREF clrFill, COLORREF clrLine)
{
	if (clrFill == -1 && clrLine == -1)
	{
		ASSERT(FALSE);
		return;
	}

	CRect rt(rect);
	rt.NormalizeRect();

	CSize size(rt.Size());
	if (size.cx == 0 || size.cy == 0)
	{
		ASSERT(FALSE);
		return;
	}

	// Copy screen content into the memory bitmap:
	CDC dcMem;
	if (!dcMem.CreateCompatibleDC(&m_dc))
	{
		ASSERT(FALSE);
		return;
	}

	// Gets the whole menu and changes the shadow.
	CBitmap bmpMem;
	if (!bmpMem.CreateCompatibleBitmap(&m_dc, size.cx, size.cy))
	{
		ASSERT(FALSE);
		return;
	}

	CBitmap* pOldBmp = dcMem.SelectObject(&bmpMem);
	ENSURE(pOldBmp != NULL);

	COLORREF* pBits;
	HBITMAP hmbpDib = CreateBitmap_32(size, (LPVOID*)&pBits);

	if (hmbpDib == NULL || pBits == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	dcMem.SelectObject(hmbpDib);

	int xB = 0;
	int xE = size.cx;
	int yB = 1;
	int yE = size.cy;

	if (clrLine != -1)
	{
		COLORREF clr = RGB(GetBValue(clrLine), GetGValue(clrLine), GetRValue(clrLine)) | 0xFF000000;

		for (int x = 0; x < size.cx; x++)
		{
			*pBits = clr;
			pBits++;
		}

		if (1 < size.cy)
		{
			memcpy((LPVOID)(pBits +(size.cy - 2) * size.cx), (LPCVOID)(pBits - size.cx), size.cx * sizeof(COLORREF));

			if (2 < size.cy)
			{
				*pBits = clr;
				if (2 <= size.cx)
				{
					*(pBits + size.cx - 1) = clr;
				}
				pBits++;
			}
		}

		xB++;
		xE--;
		yB++;
		yE--;
	}

	COLORREF clr = clrFill == -1 ? 0 : RGB(GetBValue(clrFill), GetGValue(clrFill), GetRValue(clrFill)) | 0xFF000000;

	if (yB <= yE)
	{
		for (int x = xB; x < xE; x++)
		{
			*pBits = clr;
			pBits++;
		}

		if (xB < xE && clrLine != -1)
		{
			pBits++;
		}
	}

	for (int y = yB; y < yE; y++)
	{
		memcpy((LPVOID)(pBits), (LPCVOID)(pBits - size.cx), size.cx * sizeof(COLORREF));
		pBits += size.cx;
	}

	// Copy bitmap back to the screen:

	if (clrFill != -1)
	{
		m_dc.BitBlt(rt.left, rt.top, size.cx, size.cy, &dcMem, 0, 0, SRCCOPY);
	}
	else
	{
		DrawAlpha(&m_dc, rt, &dcMem, CRect(CPoint(0, 0), size));
	}

	dcMem.SelectObject(pOldBmp);
	DeleteObject(hmbpDib);
}

inline void __stdcall CDrawingManager::SetAlphaPixel(COLORREF* pBits, CRect rect, int x, int y, int percent, int m_iShadowSize, COLORREF clrBase, BOOL bIsRight)
{
	// Our direct bitmap access swapped the y coordinate...
	y = (rect.Height()+m_iShadowSize)- y;

	COLORREF* pColor = (COLORREF*)(bIsRight ? (pBits +(rect.Width() + m_iShadowSize) *(y + 1) - x) : (pBits +(rect.Width() + m_iShadowSize) * y + x));

	*pColor = PixelAlpha(*pColor, percent);

	if (clrBase == (COLORREF)-1)
	{
		return;
	}

	*pColor = RGB( min(255, (3 * GetRValue(*pColor) + GetBValue(clrBase)) / 4), min(255, (3 * GetGValue(*pColor) + GetGValue(clrBase)) / 4), min(255, (3 * GetBValue(*pColor) + GetRValue(clrBase)) / 4));
}

COLORREF  __stdcall CDrawingManager::PixelAlpha(COLORREF srcPixel, int percent)
{
	// My formula for calculating the transpareny is as
	// follows(for each single color):
	//
	//							   percent
	// destPixel = sourcePixel *( ------- )
	//                               100
	//
	// This is not real alpha blending, as it only modifies the brightness,
	// but not the color(a real alpha blending had to mix the source and
	// destination pixels, e.g. mixing green and red makes yellow).
	// For our nice "menu" shadows its good enough.

	COLORREF clrFinal = RGB( min(255, (GetRValue(srcPixel) * percent) / 100), min(255, (GetGValue(srcPixel) * percent) / 100), min(255, (GetBValue(srcPixel) * percent) / 100));

	// TRACE("%d %d %d\n", GetRValue(clrFinal), GetGValue(clrFinal), GetBValue(clrFinal));
	return(clrFinal);

}

static inline int __stdcall AdjustChannel(int nValue, double nPercent)
{
	int nNewValue = (int)(.5 + nPercent * nValue);
	if (nValue == 0 && nPercent > 1.)
	{
		nNewValue = (int)(.5 +(nPercent - 1.) * 255);
	}

	return min(nNewValue, 255);
}

COLORREF __stdcall CDrawingManager::PixelAlpha(COLORREF srcPixel, double percentR, double percentG, double percentB)
{
	COLORREF clrFinal = RGB( AdjustChannel(GetRValue(srcPixel), percentR), AdjustChannel(GetGValue(srcPixel), percentG), AdjustChannel(GetBValue(srcPixel), percentB));

	return(clrFinal);

}

COLORREF __stdcall CDrawingManager::PixelAlpha(COLORREF srcPixel, COLORREF dstPixel, int percent)
{
	int ipercent = 100 - percent;
	COLORREF clrFinal = RGB((GetRValue(srcPixel) * percent + GetRValue(dstPixel) * ipercent) / 100,
		(GetGValue(srcPixel) * percent + GetGValue(dstPixel) * ipercent) / 100, (GetBValue(srcPixel) * percent + GetBValue(dstPixel) * ipercent) / 100);

	return(clrFinal);
}

void __stdcall CDrawingManager::SetPixel(COLORREF* pBits, int cx, int cy, int x, int y, COLORREF color)
{
	// Our direct bitmap access swapped the y coordinate...
	y = cy - y;

	COLORREF* pColor = (COLORREF*)(pBits + cx * y + x);
	*pColor = RGB(GetBValue(color), GetGValue(color), GetRValue(color));
}

//----------------------------------------------------------------------
// Conversion between the HSL(Hue, Saturation, and Luminosity)
// and RBG color model.
//----------------------------------------------------------------------
// The conversion algorithms presented here come from the book by
// Fundamentals of Interactive Computer Graphics by Foley and van Dam.
// In the example code, HSL values are represented as floating point
// number in the range 0 to 1. RGB tridrants use the Windows convention
// of 0 to 255 of each element.
//----------------------------------------------------------------------

double __stdcall CDrawingManager::HuetoRGB(double m1, double m2, double h )
{
	if ( h < 0 ) h += 1.0;
	if ( h > 1 ) h -= 1.0;
	if ( 6.0*h < 1 )
		return(m1+(m2-m1)*h*6.0);
	if ( 2.0*h < 1 )
		return m2;
	if ( 3.0*h < 2.0 )
		return(m1+(m2-m1)*((2.0/3.0)-h)*6.0);
	return m1;
}

BYTE __stdcall CDrawingManager::HueToRGB(float rm1, float rm2, float rh)
{
	if (rh > 360.0f)
		rh -= 360.0f;
	else if (rh < 0.0f)
		rh += 360.0f;

	if (rh <  60.0f)
		rm1 = rm1 +(rm2 - rm1) * rh / 60.0f;
	else if (rh < 180.0f)
		rm1 = rm2;
	else if (rh < 240.0f)
		rm1 = rm1 +(rm2 - rm1) *(240.0f - rh) / 60.0f;

	return static_cast<BYTE>(rm1 * 255);
}

COLORREF __stdcall CDrawingManager::HLStoRGB_ONE( double H, double L, double S )
{
	double r, g, b;
	double m1, m2;

	if (S==0)
	{
		r=g=b=L;
	}
	else
	{
		if (L <=0.5)
			m2 = L*(1.0+S);
		else if (L == 1.0)
			m2 = L;
		else
			m2 = L+S-L*S;
		m1 = 2.0*L-m2;
		r = HuetoRGB(m1, m2, H+1.0/3.0);
		g = HuetoRGB(m1, m2, H);
		b = HuetoRGB(m1, m2, H-1.0/3.0);
	}
	return RGB((BYTE)(r*255), (BYTE)(g*255), (BYTE)(b*255));
}

COLORREF __stdcall CDrawingManager::HLStoRGB_TWO( double H, double L, double S)
{
	WORD R, G, B; // RGB component values

	if (S == 0.0)
	{
		R = G = B = unsigned char(L * 255.0);
	}
	else
	{
		float rm1, rm2;

		if (L <= 0.5f)
			rm2 = (float)(L + L * S);
		else if (L == 1.0)
			rm2 = (float)L;
		else
			rm2 = (float)(L + S - L * S);

		rm1 = (float)(2.0f * L - rm2);

		R = HueToRGB(rm1, rm2, (float)(H + 120.0f));
		G = HueToRGB(rm1, rm2, (float)(H));
		B = HueToRGB(rm1, rm2, (float)(H - 120.0f));
	}

	return RGB(R, G, B);
}

void __stdcall CDrawingManager::RGBtoHSL( COLORREF rgb, double *H, double *S, double *L )
{
	double delta;
	double r = (double)GetRValue(rgb)/255;
	double g = (double)GetGValue(rgb)/255;
	double b = (double)GetBValue(rgb)/255;
	double cmax = max(r, max(g, b));
	double cmin = min(r, min(g, b));
	*L= (cmax+cmin)/2.0;

	if (cmax==cmin)
	{
		*S = 0;
		*H = 0; // it's really undefined
	}
	else
	{
		if (*L < 0.5)
			*S = (cmax-cmin)/(cmax+cmin);
		else
			*S = (cmax-cmin)/(2.0-cmax-cmin);

		delta = cmax - cmin;
		if (r==cmax)
			*H = (g-b)/delta;
		else if (g==cmax)
			*H = 2.0 +(b-r)/delta;
		else
			*H=4.0+(r-g)/delta;
		*H /= 6.0;
		if (*H < 0.0)
			*H += 1;
	}
}

void __stdcall CDrawingManager::RGBtoHSV(COLORREF rgb, double *H, double *S, double *V)
// Algorithm by A. R. Smith
{
	double r = (double) GetRValue(rgb) / 255;
	double g = (double) GetGValue(rgb) / 255;
	double b = (double) GetBValue(rgb) / 255;

	double dblMin = min(r, min(g, b));
	double dblMax = max(r, max(g, b));

	*V = dblMax; // v
	double delta = dblMax - dblMin;

	if ( dblMax != 0 )
	{
		*S = delta / dblMax; // s
	}
	else
	{
		// r = g = b = 0
		// s = 0, v is undefined
		*S = 0;
		*H = -1;
		return;
	}

	if (delta == 0.)
	{
		*H = 1;
	}
	else
	{
		if (r == dblMax)
			*H = (g - b) / delta; // between yellow & magenta
		else if ( g == dblMax )
			*H = 2 +( b - r ) / delta; // between cyan & yellow
		else
			*H = 4 +( r - g ) / delta; // between magenta & cyan
	}

	*H *= 60; // degrees

	if (*H < 0)
		*H += 360;
}

COLORREF __stdcall CDrawingManager::HSVtoRGB(double h, double s, double v)
// Algoritm by A. R. Smith
{
	int i;
	double f, p, q, t;
	double r, g, b;

	if ( s == 0 )
	{
		// achromatic(grey)
		r = g = b = v;
	}
	else
	{
		h /= 60; // sector 0 to 5
		i = (int) floor( h );
		f = h - i; // factorial part of h
		p = v *( 1 - s );
		q = v *( 1 - s * f );
		t = v *( 1 - s *( 1 - f ) );

		switch ( i )
		{
		case 0:
			r = v;
			g = t;
			b = p;
			break;

		case 1:
			r = q;
			g = v;
			b = p;
			break;

		case 2:
			r = p;
			g = v;
			b = t;
			break;

		case 3:
			r = p;
			g = q;
			b = v;
			break;

		case 4:
			r = t;
			g = p;
			b = v;
			break;

		default: // case 5:
			r = v;
			g = p;
			b = q;
			break;
		}
	}

	return RGB( (int)(.5 + r * 255), (int)(.5 + g * 255), (int)(.5 + b * 255));
}

COLORREF __stdcall CDrawingManager::SmartMixColors(COLORREF color1, COLORREF color2, double dblLumRatio, int k1, int k2)
{
	ENSURE(k1 >= 0);
	ENSURE(k2 >= 0);

	if (k1 + k2 == 0)
	{
		ASSERT(FALSE);
		return RGB(0, 0, 0);
	}

	COLORREF color = RGB( (GetRValue(color1) * k1 + GetRValue(color2) * k2) /(k1 + k2),
		(GetGValue(color1) * k1 + GetGValue(color2) * k2) /(k1 + k2), (GetBValue(color1) * k1 + GetBValue(color2) * k2) /(k1 + k2));

	double h1, s1, v1;
	RGBtoHSV(color, &h1, &s1, &v1);

	double h2, s2, v2;
	RGBtoHSV(color2, &h2, &s2, &v2);

	v1 = v2;
	s1 = (s1 *  k1 + s2 *  k2) /(k1 + k2);

	color = HSVtoRGB(h1, s1, v1);

	if (dblLumRatio != 1.)
	{
		double H, S, L;
		RGBtoHSL(color, &H, &S, &L);

		color = HLStoRGB_ONE(H, min(1., L * dblLumRatio), S);
	}

	return color;
}

void CDrawingManager::DrawAlpha(CDC* pDstDC, const CRect& rectDst, CDC* pSrcDC, const CRect& rectSrc)
{
	BLENDFUNCTION pixelblend = { AC_SRC_OVER, 0, 255, 1 /*AC_SRC_ALPHA*/};

	pDstDC->AlphaBlend(rectDst.left, rectDst.top, rectDst.Width(), rectDst.Height(), pSrcDC, rectSrc.left, rectSrc.top, rectSrc.Width(), rectSrc.Height(), pixelblend);
}

HBITMAP CDrawingManager::PrepareShadowMask (int nDepth, COLORREF clrBase, int iMinBrightness/* = 0*/, int iMaxBrightness/* = 100*/)
{
	if (nDepth == 0)
	{
		return NULL;
	}

	int nSize     = nDepth < 3 ? 3 : nDepth;
	int nDestSize = nSize * 2 + 1;

	LPBYTE lpBits = NULL;
	HBITMAP hBitmap = CreateBitmap_32(CSize(nDestSize, nDestSize), (void**)&lpBits);

	if (hBitmap == NULL || lpBits == NULL)
	{
		return NULL;
	}

	// Create mask
	int nDestLength = nDestSize * nDestSize;
	double* mask = new double[nDestLength];

	double dispersion = 1.0;
	double minValue   = iMinBrightness / 100.0;
	double maxValue   = iMaxBrightness / 100.0;
	double delta      = maxValue - minValue;

	long size2      = nDestSize / 2;
	double size2S   = nDestSize * nDestSize / 4.0;

	double* pMask = mask;

	for(long y = -size2; y <= size2; y++)
	{
		double y2 = y * y;

		for(long x = -size2; x <= size2; x++)
		{
			double d = y2 + x * x;
			double e = 0.0;

			if(d <= size2S)
			{
				e = min(maxValue, max(exp(-(d / size2S) / dispersion * 2.0) * delta + minValue, minValue));
			}

			*pMask++ = e;
		}
	}

	BYTE r = (BYTE)(GetRValue(clrBase) / 4);
	BYTE g = (BYTE)(GetGValue(clrBase) / 4);
	BYTE b = (BYTE)(GetBValue(clrBase) / 4);

	pMask = mask;
	LPRGBQUAD pQuad = (LPRGBQUAD)lpBits;
	for (int i = 0; i < nDestLength; i++)
	{
		pQuad->rgbRed      = (BYTE)(*pMask * r);
		pQuad->rgbGreen    = (BYTE)(*pMask * g);
		pQuad->rgbBlue     = (BYTE)(*pMask * b);
		pQuad->rgbReserved = (BYTE)(*pMask * 255);

		pMask++;
		pQuad++;
	}

	if (mask != NULL)
	{
		delete [] mask;
	}

	return hBitmap;
}

void CDrawingManager::DrawRotated(CRect rect, CDC& dcSrc, BOOL bClockWise)
{
	const int cx = rect.Width();
	const int cy = rect.Height();

	if (cx <= 0 || cy <= 0)
	{
		return;
	}

	for (int y = 0; y <= cy; y++)
	{
		for (int x = 0; x <= cx; x++)
		{
			int xSrc = y;
			int ySrc = bClockWise ? (cx - x - 1) : x;

			m_dc.SetPixel(rect.left + x, rect.top + y, dcSrc.GetPixel(xSrc, ySrc));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdragframeimpl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"

#include "afxdragframeimpl.h"

#include "afxtabbedpane.h"
#include "afxpaneframewnd.h"
#include "afxdockingmanager.h"
#include "afxglobals.h"
#include "afxglobalutils.h"
#include "afxmultipaneframewnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

class CDummyDockablePane : public CDockablePane
{
	virtual void DoPaint(CDC* /*pDC*/) {}

protected:
	afx_msg BOOL OnEraseBkgnd(CDC* /*pDC*/) {return FALSE;}
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CDummyDockablePane, CDockablePane)
	ON_WM_ERASEBKGND()
END_MESSAGE_MAP()

static UINT AFX_DUMMY_WND_ID = (UINT) -2;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMFCDragFrameImpl::CMFCDragFrameImpl()
{
	m_rectDrag.SetRectEmpty();
	m_rectExpectedDocked.SetRectEmpty();
	m_ptHot.x = m_ptHot.y = 0;
	m_nOldThickness = afxGlobalData.m_nDragFrameThicknessFloat;
	m_pDraggedWnd = NULL;
	m_pDockManager = NULL;
	m_pTargetBar = NULL;
	m_nInsertedTabID = -1;
	m_bDockToTab = FALSE;
	m_pFinalTargetBar = NULL;
	m_bDragStarted = FALSE;
	m_bFrameTabDrawn = FALSE;
	m_pOldTargetBar = NULL;
	m_pWndDummy = NULL;
}

CMFCDragFrameImpl::~CMFCDragFrameImpl()
{
	if (m_pWndDummy != NULL)
	{
		m_pWndDummy->DestroyWindow();
		delete m_pWndDummy;
	}
}

void CMFCDragFrameImpl::Init(CWnd* pDraggedWnd)
{
	ASSERT_VALID(pDraggedWnd);
	m_pDraggedWnd = pDraggedWnd;

	CWnd* pDockSite = NULL;
	if (m_pDraggedWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
	{
		CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_pDraggedWnd);
		pDockSite = pMiniFrame->GetParent();
	}
	else if (m_pDraggedWnd->IsKindOf(RUNTIME_CLASS(CPane)))
	{
		CPane* pBar = DYNAMIC_DOWNCAST(CPane, m_pDraggedWnd);
		ASSERT_VALID(pBar);

		CPaneFrameWnd* pParentMiniFrame = pBar->GetParentMiniFrame();
		if (pParentMiniFrame != NULL)
		{
			pDockSite = pParentMiniFrame->GetParent();
		}
		else
		{
			pDockSite = pBar->GetDockSiteFrameWnd();
		}
	}

	m_pDockManager = afxGlobalUtils.GetDockingManager(pDockSite);
	if (afxGlobalUtils.m_bDialogApp)
	{
		return;
	}

	ENSURE(m_pDockManager != NULL);
}

void CMFCDragFrameImpl::MoveDragFrame(BOOL bForceMove)
{
	ASSERT_VALID(m_pDraggedWnd);

	m_pFinalTargetBar = NULL;

	if (m_pDraggedWnd == NULL || m_pDockManager == NULL)
	{
		return;
	}

	if (m_pWndDummy == NULL)
	{
		m_pWndDummy = new CDummyDockablePane;
		m_pWndDummy->CreateEx(0, _T(""), AFXGetTopLevelFrame(m_pDraggedWnd), CRect(0, 0, 0, 0), FALSE, AFX_DUMMY_WND_ID, WS_CHILD);
	}

	CSize szSensitivity = CDockablePane::GetDragSensitivity();

	CPoint ptMouse;
	GetCursorPos(&ptMouse);

	CPoint ptOffset = ptMouse - m_ptHot;

	if (abs(ptOffset.x) < szSensitivity.cx && abs(ptOffset.y) < szSensitivity.cy && m_rectDrag.IsRectEmpty() && !bForceMove)
	{
		return;
	}

	m_bDragStarted = TRUE;

	m_pDockManager->LockUpdate(TRUE);

	CRect rectOld = m_rectExpectedDocked.IsRectEmpty() ? m_rectDrag : m_rectExpectedDocked;
	BOOL bFirstTime = FALSE;

	if (m_rectDrag.IsRectEmpty())
	{
		if (m_pDraggedWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
		{
			m_pDraggedWnd->GetWindowRect(m_rectDrag);
		}
		else if (m_pDraggedWnd->IsKindOf(RUNTIME_CLASS(CPane)))
		{
			CPane* pBar = DYNAMIC_DOWNCAST(CPane, m_pDraggedWnd);
			ASSERT_VALID(pBar);
			m_pDraggedWnd->GetWindowRect(m_rectDrag);

			// if the bar is docked then the floating rect has to be set to recent floating rect
			if (pBar->GetParentMiniFrame() == NULL)
			{
				m_rectDrag.right = m_rectDrag.left + pBar->m_recentDockInfo.m_rectRecentFloatingRect.Width();
				m_rectDrag.bottom = m_rectDrag.top + pBar->m_recentDockInfo.m_rectRecentFloatingRect.Height();
			}

			if (!m_rectDrag.PtInRect(m_ptHot))
			{
				int nOffset = m_rectDrag.left - m_ptHot.x;
				m_rectDrag.OffsetRect(-nOffset - 5, 0); // offset of mouse pointer
				// from the drag rect bound
			}
		}
		bFirstTime = TRUE;
	}

	BOOL bDrawTab = FALSE;
	CDockablePane* pOldTargetBar = m_pTargetBar;
	CRect rectExpected; rectExpected.SetRectEmpty();

	CSmartDockingManager* pSDManager = NULL;
	BOOL bSDockingIsOn = FALSE;

	if (m_pDockManager != NULL &&(pSDManager = m_pDockManager->GetSmartDockingManagerPermanent()) != NULL && pSDManager->IsStarted())
	{
		bSDockingIsOn = TRUE;
	}

	m_pDockManager->CalcExpectedDockedRect(m_pDraggedWnd, ptMouse, rectExpected, bDrawTab, &m_pTargetBar);

	if (pOldTargetBar != NULL && m_nInsertedTabID != -1 && (pOldTargetBar != m_pTargetBar || !bDrawTab))
	{
		RemoveTabPreDocking(pOldTargetBar);
		bFirstTime = TRUE;
	}

	BOOL bCanBeAttached = TRUE;
	if (m_pDraggedWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
	{
	}
	else if (m_pDraggedWnd->IsKindOf(RUNTIME_CLASS(CPane)))
	{
		CPane* pBar = DYNAMIC_DOWNCAST(CPane, m_pDraggedWnd);
		bCanBeAttached = pBar->CanBeAttached();
	}

	if (m_pTargetBar != NULL && bCanBeAttached)
	{
		CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, m_pTargetBar);
		if (pTabbedBar != NULL && bDrawTab &&
			(pTabbedBar->GetVisibleTabsNum() > 1 && pTabbedBar->IsHideSingleTab() || pTabbedBar->GetVisibleTabsNum() > 0 && !pTabbedBar->IsHideSingleTab()))
		{
			PlaceTabPreDocking(pTabbedBar, bFirstTime);
			return;
		}
		else if (bDrawTab)
		{
			if (m_nInsertedTabID != -1)
			{
				return;
			}
			if (!bFirstTime)
			{
				EndDrawDragFrame(FALSE);
			}
			DrawFrameTab(m_pTargetBar, FALSE);
			m_nInsertedTabID = 1;
			return;
		}
	}

	m_rectDrag.OffsetRect(ptOffset);
	m_ptHot = ptMouse;

	m_rectExpectedDocked = rectExpected;

	int nNewThickness = m_rectExpectedDocked.IsRectEmpty()? afxGlobalData.m_nDragFrameThicknessFloat : afxGlobalData.m_nDragFrameThicknessDock;

	CRect rectDocked;
	if (m_rectExpectedDocked.IsRectEmpty())
	{
		if (!m_rectDrag.PtInRect(ptMouse))
		{
			CPoint ptMiddleRect(m_rectDrag.TopLeft().x + m_rectDrag.Width() / 2, m_rectDrag.top + 5);

			CPoint ptOffsetMid = ptMouse - ptMiddleRect;
			m_rectDrag.OffsetRect(ptOffsetMid);
		}
		rectDocked = m_rectDrag;
	}
	else
	{
		rectDocked = m_rectExpectedDocked;
	}
	if (!bSDockingIsOn || !m_rectExpectedDocked.IsRectEmpty())
	{
		DrawDragFrame(rectOld, rectDocked, bFirstTime, nNewThickness, m_nOldThickness);
		m_nOldThickness = nNewThickness;
	}
}

void CMFCDragFrameImpl::DrawFrameTab(CDockablePane* pTargetBar, BOOL bErase)
{
	CRect rectWnd;
	pTargetBar->GetWindowRect(rectWnd);

	CSmartDockingManager* pSDManager = NULL;
	BOOL bSDockingIsOn = FALSE;

	if (m_pDockManager != NULL
		&&(pSDManager = m_pDockManager->GetSmartDockingManagerPermanent()) != NULL
		&& pSDManager->IsStarted())
	{
		bSDockingIsOn = TRUE;
	}

	int nThikness = afxGlobalData.m_nDragFrameThicknessDock;
	CRect rectSmallTab = rectWnd;
	// to be changed to tab height

	if (CTabbedPane::m_bTabsAlwaysTop)
	{
		rectWnd.top += afxGlobalData.GetTextHeight();
		rectSmallTab.bottom = rectSmallTab.top + afxGlobalData.GetTextHeight();
		rectSmallTab.left += 10;
		rectSmallTab.right = rectSmallTab.left + 40;
	}
	else
	{
		rectWnd.bottom -= afxGlobalData.GetTextHeight();
		rectSmallTab.top = rectSmallTab.bottom - afxGlobalData.GetTextHeight();
		rectSmallTab.left += 10;
		rectSmallTab.right = rectSmallTab.left + 40;
	}

	if (rectSmallTab.right >= rectWnd.right)
	{
		rectSmallTab.right = rectWnd.right - nThikness - 4;
	}

	CRect rectEmpty; rectEmpty.SetRectEmpty();

	CRect rectLine;
	if (CTabbedPane::m_bTabsAlwaysTop)
	{
		rectLine.SetRect(rectSmallTab.left + nThikness, rectSmallTab.bottom - nThikness, rectSmallTab.right - nThikness, rectSmallTab.bottom + nThikness);
	}
	else
	{
		rectLine.SetRect(rectSmallTab.left + nThikness, rectSmallTab.top  - nThikness, rectSmallTab.right - nThikness, rectSmallTab.top + nThikness);
	}

	if (bErase)
	{
		if (bSDockingIsOn)
		{
			pSDManager->HidePlace();
		}
		else
		{
			DrawDragFrame(rectEmpty, rectSmallTab, FALSE, nThikness, nThikness);
			DrawDragFrame(rectEmpty, rectWnd, FALSE, nThikness, nThikness);
			DrawDragFrame(rectEmpty, rectLine, FALSE, nThikness, nThikness);
			m_bFrameTabDrawn = FALSE;
		}
	}
	else
	{
		if (bSDockingIsOn)
		{
			pSDManager->ShowTabbedPlaceAt(&rectWnd, 10, rectSmallTab.Width(), rectSmallTab.Height());
		}
		else
		{
			DrawDragFrame(rectEmpty, rectSmallTab, TRUE, nThikness, nThikness);
			DrawDragFrame(rectEmpty, rectWnd, TRUE, nThikness, nThikness);
			DrawDragFrame(rectEmpty, rectLine, TRUE, nThikness, nThikness);
			m_bFrameTabDrawn = TRUE;
		}
	}
}

void CMFCDragFrameImpl::EndDrawDragFrame(BOOL bClearInternalRects)
{
	if (m_pDockManager == NULL)
	{
		return;
	}

	BOOL bSDockingIsOn = FALSE;
	CSmartDockingManager* pSDManager = NULL;

	if ((pSDManager = m_pDockManager->GetSmartDockingManagerPermanent()) != NULL && pSDManager->IsStarted())
	{
		bSDockingIsOn = TRUE;
		pSDManager->HidePlace();
	}

	CRect rectEmpty; rectEmpty.SetRectEmpty();
	CRect rectDocked = m_rectExpectedDocked.IsRectEmpty() ? m_rectDrag : m_rectExpectedDocked;

	// do not draw the final frame(meaning - clear) if it was not drawn because of tab
	if (m_nInsertedTabID == -1)
	{
		if (!bSDockingIsOn)
		{
			DrawDragFrame(rectEmpty, rectDocked, 0, m_nOldThickness);
		}
	}
	else
	{
		m_bDockToTab = TRUE;
	}

	if (bClearInternalRects)
	{
		RemoveTabPreDocking();

		m_rectExpectedDocked.SetRectEmpty();
		m_rectDrag.SetRectEmpty();

		m_pFinalTargetBar = m_pTargetBar;
		m_pTargetBar = NULL;
	}

	m_bDragStarted = FALSE;

	ENSURE(m_pDockManager != NULL);
	if (!bSDockingIsOn)
	{
		m_pDockManager->LockUpdate(FALSE);
	}
}

void CMFCDragFrameImpl::DrawDragFrame(LPCRECT lpRectOld, LPCRECT lpRectNew, BOOL bFirstTime, int nNewThickness, int nOldThikness)
{
	CWindowDC dc(m_pDraggedWnd->GetDesktopWindow());

	CSize szNewThickness(nNewThickness, nNewThickness);
	CSize szOldThickness(nOldThikness, nOldThikness);

	CSmartDockingManager* pSDManager = NULL;

	if (m_pDockManager != NULL &&(pSDManager = m_pDockManager->GetSmartDockingManagerPermanent()) != NULL && pSDManager->IsStarted())
	{
		pSDManager->ShowPlaceAt(lpRectNew);
	}
	else
	{
		if (bFirstTime)
		{
			dc.DrawDragRect(lpRectNew, szNewThickness, NULL, szOldThickness);
		}
		else
		{
			dc.DrawDragRect(lpRectNew, szNewThickness, lpRectOld, szOldThickness);
		}
	}
}

void CMFCDragFrameImpl::PlaceTabPreDocking(CBaseTabbedPane* pTabbedBar, BOOL bFirstTime)
{
	if (m_nInsertedTabID != -1)
	{
		return;
	}
	if (!bFirstTime)
	{
		EndDrawDragFrame(FALSE);
	}
	CString strLabel;
	if (m_pDraggedWnd->IsKindOf(RUNTIME_CLASS(CMultiPaneFrameWnd)))
	{
		CMultiPaneFrameWnd* pMultiMiniFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, m_pDraggedWnd);
		if (pMultiMiniFrame != NULL)
		{
			CWnd* pBar = pMultiMiniFrame->GetFirstVisiblePane();
			ASSERT_VALID(pBar);

			if (pBar != NULL)
			{
				pBar->GetWindowText(strLabel);
			}
		}
	}
	else
	{
		m_pDraggedWnd->GetWindowText(strLabel);
	}

	if (m_pWndDummy == NULL)
	{
		m_pWndDummy = new CDummyDockablePane;
		m_pWndDummy->CreateEx(0, _T(""), AFXGetTopLevelFrame(m_pDraggedWnd), CRect(0, 0, 0, 0), FALSE, AFX_DUMMY_WND_ID, WS_CHILD);
	}

	pTabbedBar->GetUnderlyingWindow()->AddTab(m_pWndDummy, strLabel);

	CSmartDockingManager* pSDManager = NULL;
	if ((pSDManager = m_pDockManager->GetSmartDockingManagerPermanent()) != NULL && pSDManager->IsStarted())
	{
		m_pDraggedWnd->ShowWindow(SW_HIDE);
	}

	m_nInsertedTabID = pTabbedBar->GetUnderlyingWindow()->GetTabFromHwnd(*m_pWndDummy);
	m_pOldTargetBar = pTabbedBar;
}

void CMFCDragFrameImpl::PlaceTabPreDocking(CWnd* pCBarToPlaceOn)
{
	CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pCBarToPlaceOn);
	if (pTabbedBar != NULL &&
		(pTabbedBar->GetVisibleTabsNum() > 1 && pTabbedBar->IsHideSingleTab() || pTabbedBar->GetVisibleTabsNum() > 0 && !pTabbedBar->IsHideSingleTab()))
	{
		m_pTargetBar = pTabbedBar;
		PlaceTabPreDocking(pTabbedBar, TRUE);
		return;
	}
	else if (m_nInsertedTabID == -1)
	{
		CDockablePane* pDockingControlBar = DYNAMIC_DOWNCAST(CDockablePane, pCBarToPlaceOn);
		if (pDockingControlBar != NULL)
		{
			DrawFrameTab(pDockingControlBar, FALSE);
			m_pTargetBar = pDockingControlBar;
			m_pOldTargetBar = pDockingControlBar;
			m_nInsertedTabID = 1;
		}
	}
}

void CMFCDragFrameImpl::RemoveTabPreDocking(CDockablePane* pOldTargetBar)
{
	if (pOldTargetBar == NULL)
	{
		pOldTargetBar = m_pOldTargetBar;
	}

	if (pOldTargetBar != NULL && m_nInsertedTabID != -1)
	{
		CBaseTabbedPane* pOldTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pOldTargetBar);
		if (pOldTabbedBar != NULL && !m_bFrameTabDrawn && m_pWndDummy != NULL && m_pWndDummy->GetSafeHwnd() != NULL)
		{
			CSmartDockingManager* pSDManager = NULL;
			BOOL bSDockingIsOn = FALSE;

			if (m_pDockManager != NULL &&(pSDManager = m_pDockManager->GetSmartDockingManagerPermanent()) != NULL && pSDManager->IsStarted())
			{
				bSDockingIsOn = TRUE;
			}

			m_pWndDummy->ShowWindow(SW_HIDE);
			if (!bSDockingIsOn)
			{
				m_pDockManager->LockUpdate(FALSE);
			}
			CWnd* pWnd = pOldTabbedBar->GetUnderlyingWindow()->GetTabWnd(m_nInsertedTabID);
			if (pWnd == m_pWndDummy)
			{
				pOldTabbedBar->GetUnderlyingWindow()->RemoveTab(m_nInsertedTabID);
			}
			if (!bSDockingIsOn)
			{
				m_pDockManager->LockUpdate(TRUE);
			}
		}
		else
		{
			DrawFrameTab(pOldTargetBar, TRUE);
		}

		CSmartDockingManager* pSDManager = NULL;

		if ((pSDManager = m_pDockManager->GetSmartDockingManagerPermanent()) != NULL && pSDManager->IsStarted())
		{
			m_pDraggedWnd->ShowWindow(SW_SHOW);
		}
	}

	m_nInsertedTabID = -1;
	m_pOldTargetBar = NULL;
}

void CMFCDragFrameImpl::ResetState()
{
	m_ptHot = CPoint(-1, -1);
	m_rectDrag.SetRectEmpty();
	m_rectExpectedDocked.SetRectEmpty();

	m_pFinalTargetBar = NULL;
	m_pOldTargetBar   = NULL;
	m_bDockToTab	  = FALSE;
	m_bDragStarted    = FALSE;

	m_nInsertedTabID  = -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdocksite.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxmdichildwndex.h"
#include "afxolecntrframewndex.h"

#include "afxpane.h"
#include "afxdockingpanesrow.h"
#include "afxrebar.h"

#include "afxglobalutils.h"
#include "afxdocksite.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CDockSite, CBasePane)

/////////////////////////////////////////////////////////////////////////////
// CDockSite

CDockSite::CDockSite() : m_nDockBarID(0)
{
}

CDockSite::~CDockSite()
{
	while (!m_lstDockBarRows.IsEmpty())
	{
		delete m_lstDockBarRows.RemoveHead();
	}
}

BEGIN_MESSAGE_MAP(CDockSite, CBasePane)
	//{{AFX_MSG_MAP(CDockSite)
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
	ON_WM_CONTEXTMENU()
	ON_WM_NCDESTROY()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDockSite message handlers

BOOL CDockSite::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, DWORD dwControlBarStyle, CCreateContext* pContext)
{
	ASSERT_VALID(this);
	return CDockSite::CreateEx(0, dwStyle, rect, pParentWnd, dwControlBarStyle, pContext);
}

BOOL CDockSite::CreateEx(DWORD dwStyleEx, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, DWORD dwControlBarStyle, CCreateContext* pContext)
{
	ASSERT_VALID(this);

	DWORD dwEnableAlignment = GetEnabledAlignment();
	EnableDocking(dwEnableAlignment | dwStyle);

	SetPaneAlignment(dwStyle);

	dwStyle |= WS_CHILDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPED;
	dwStyleEx = WS_EX_LEFT;

	// Align the bar along borders; initially, create the dock bar with zero height/width
	CRect rectDockBar = rect;

	CRect rectParent;
	pParentWnd->GetClientRect(&rectParent);

	rectDockBar = rectParent;

	switch (GetCurrentAlignment())
	{
	case CBRS_ALIGN_LEFT:
		rectDockBar.right = 0;
		m_nDockBarID = AFX_IDW_DOCKBAR_LEFT;
		break;

	case CBRS_ALIGN_RIGHT:
		rectDockBar.left = rectParent.right;
		m_nDockBarID = AFX_IDW_DOCKBAR_RIGHT;
		break;

	case CBRS_ALIGN_TOP:
		rectDockBar.bottom = rectParent.top;
		m_nDockBarID = AFX_IDW_DOCKBAR_TOP;
		break;

	case CBRS_ALIGN_BOTTOM:
		rectDockBar.top  = rectParent.bottom;
		m_nDockBarID = AFX_IDW_DOCKBAR_BOTTOM;
		break;
	}

	m_dwControlBarStyle = dwControlBarStyle;
	m_pDockSite = pParentWnd;

	return CWnd::CreateEx(dwStyleEx, afxGlobalData.RegisterWindowClass(_T("Afx:DockPane")), NULL, dwStyle, rectDockBar, pParentWnd, m_nDockBarID, pContext);
}

void CDockSite::AlignDockSite(const CRect& rectToAlignBy, CRect& rectResult, BOOL bMoveImmediately)
{
	ASSERT_VALID(this);
	if (rectResult.IsRectEmpty())
	{
		GetWindowRect(rectResult);
	}

	CRect rectOld;
	GetWindowRect(rectOld);

	int nCurrWidth = rectResult.Width();
	int nCurrHeight = rectResult.Height();

	switch (GetCurrentAlignment())
	{
	case CBRS_ALIGN_LEFT:
		rectResult.TopLeft() = rectToAlignBy.TopLeft();
		rectResult.bottom = rectResult.top + rectToAlignBy.Height();
		rectResult.right = rectResult.left + nCurrWidth;
		break;

	case CBRS_ALIGN_TOP:
		rectResult.TopLeft() = rectToAlignBy.TopLeft();
		rectResult.right = rectResult.left + rectToAlignBy.Width();
		rectResult.bottom = rectResult.top + nCurrHeight;
		break;

	case CBRS_ALIGN_RIGHT:
		rectResult.BottomRight() = rectToAlignBy.BottomRight();
		rectResult.top = rectResult.bottom - rectToAlignBy.Height();
		rectResult.left = rectResult.right - nCurrWidth;
		break;
	case CBRS_ALIGN_BOTTOM:
		rectResult.BottomRight() = rectToAlignBy.BottomRight();
		rectResult.left = rectResult.right - rectToAlignBy.Width();
		rectResult.top = rectResult.bottom - nCurrHeight;
		break;
	}

	if (rectResult != rectOld && bMoveImmediately)
	{
		CRect rectNew = rectResult;
		ASSERT_VALID(GetParent());
		GetParent()->ScreenToClient(rectNew);

		OnSetWindowPos(&wndBottom, rectNew, SWP_NOACTIVATE | SWP_NOZORDER);
	}
}

// Moves control bar within row; floats the bar or moves it to an adjustent row
// if the bar' virtual rectangle is being moved out of row beyond a limit
BOOL CDockSite::MovePane(CPane* pControlBar, UINT /*nFlags*/, CPoint ptOffset)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	CDockingPanesRow* pRow = pControlBar->GetDockSiteRow();
	ASSERT_VALID(pRow);

	CRect rectVirtual;
	pControlBar->GetVirtualRect(rectVirtual);

	// where the virtual rectangle will be if it's moved according to ptOffset
	rectVirtual.OffsetRect(ptOffset);

	CPoint ptMouse;
	GetCursorPos(&ptMouse);

	CRect rectRow;
	pRow->GetWindowRect(rectRow);

	CPoint ptDelta(0, 0);

	// check whether the control bar should change its state from docked to floated
	CBasePane* pDockBar = NULL;

	if (pControlBar->IsChangeState(15, &pDockBar))
	{
		pControlBar->UpdateVirtualRect(ptOffset);
		pControlBar->GetVirtualRect(rectVirtual);
		pControlBar->FloatPane(rectVirtual, DM_MOUSE);
		return TRUE; // indicates that the bar was floated and shouldn't be moved anymore within the dock bar
	}

	bool bOuterRow = false;
	CDockingPanesRow* pNextRow = RowFromPoint(rectVirtual.CenterPoint(), bOuterRow);

	int nBaseLineOffset = 0;
	int nOffsetLimit = 0;

	if (IsHorizontal())
	{
		nBaseLineOffset = min(rectRow.bottom - rectVirtual.bottom, rectRow.top - rectVirtual.top);
		nOffsetLimit = rectVirtual.Height() * 2 / 3; // / 2;
	}
	else
	{
		nBaseLineOffset = min(rectRow.right - rectVirtual.right, rectRow.left - rectVirtual.left);
		nOffsetLimit = rectVirtual.Width() * 2 /3 ; // / 2;
	}

	if (abs(nBaseLineOffset) > nOffsetLimit)
	{
		if (pRow->GetPaneCount() > 1  && nBaseLineOffset < pRow->GetRowHeight())
		{
			// the bar should be put on the separate row, find a position to insert the row
			POSITION pos = m_lstDockBarRows.Find(pRow);
			ENSURE(pos != NULL);

			if (nBaseLineOffset < 0) // moving down - find the next visible row
			{
				// the new row should be inserted before next visible row
				FindNextVisibleRow(pos);
			}
			// otherwise the new row will be inserted before the current row
			//(that's visible for sure) by AddRow(it inserts a row before spec. pos).

			pRow->RemovePane(pControlBar);
			CDockingPanesRow* pNewRow = AddRow(pos, IsHorizontal() ? rectVirtual.Height() : rectVirtual.Width());
			pNewRow->AddPaneFromRow(pControlBar, DM_MOUSE);

			return FALSE;
		}
		else if (pRow != pNextRow && pNextRow != NULL)
		{
			ASSERT_VALID(pNextRow);
			//the bar is moved from the separate row to adjustent row(if exist)

			SetRedraw (FALSE);

			if (pRow->IsExclusiveRow())
			{
				SwapRows(pNextRow, pRow);
			}
			else
			{
				if (pNextRow->IsExclusiveRow())
				{
					SwapRows(pRow, pNextRow);
				}
				else
				{
					pRow->RemovePane(pControlBar);
					pNextRow->AddPaneFromRow(pControlBar, DM_MOUSE);
				}
			}

			pControlBar->m_bDisableMove = true;

			SetRedraw (TRUE);
			RedrawWindow (NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);

			return FALSE;
		}

	}
	// just move the bar within the row
	if (abs(nBaseLineOffset) < rectRow.Height())
	{
		HDWP hdwp = BeginDeferWindowPos(pRow->GetPaneCount());
		pRow->MovePane(pControlBar, ptOffset, TRUE, hdwp);
		EndDeferWindowPos(hdwp);
		return FALSE;
	}
	return FALSE;
}

CDockingPanesRow* CDockSite::FindNextVisibleRow(POSITION& pos, BOOL bForward)
{
	if (m_lstDockBarRows.IsEmpty())
	{
		pos = NULL;
		return NULL;
	}

	if (pos == NULL)
	{
		pos = bForward  ? m_lstDockBarRows.GetHeadPosition() : m_lstDockBarRows.GetTailPosition();
	}
	else
	{
		// we need to skip to the next / prev row from the current position
		bForward ? m_lstDockBarRows.GetNext(pos) : m_lstDockBarRows.GetPrev(pos);
	}

	while (pos != NULL)
	{
		POSITION posSave = pos;
		CDockingPanesRow* pRow = (CDockingPanesRow*) (bForward ? m_lstDockBarRows.GetNext(pos) : m_lstDockBarRows.GetPrev(pos));
		ASSERT_VALID(pRow);

		if (pRow->IsVisible())
		{
			pos = posSave;
			return pRow;
		}
	}

	return NULL;
}

void CDockSite::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
	ASSERT_VALID(this);

	CWnd::CalcWindowRect(lpClientRect, nAdjustType);
}

void CDockSite::DockPane(CPane* pControlBar, AFX_DOCK_METHOD dockMethod, LPCRECT lpRect)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	CRect rectDockArea; rectDockArea.SetRectEmpty();
	if (lpRect != NULL)
	{
		rectDockArea = lpRect;
	}

	BOOL bVertDock = !IsHorizontal();
	CSize szBarSize = pControlBar->CalcFixedLayout(FALSE, !bVertDock);

	if (!m_lstControlBars.Find(pControlBar))
	{
		CDockingPanesRow* pRowToDock = NULL;
		bool bOuterRow = false;

		if (dockMethod == DM_MOUSE)
		{
			// calculate from which side the control bar is coming, using mouse cursor position.
			// the default bar width(for side bars) and height(for top/bottom bars)
			// is 30 for this example

			CPoint ptMouse;
			GetCursorPos(&ptMouse);

			CRect rectDockBar;
			GetWindowRect(&rectDockBar);

			// get pointer to the row on which the bar should be placed
			pRowToDock = RowFromPoint(ptMouse, bOuterRow);
		}
		else if (dockMethod == DM_DBL_CLICK || dockMethod == DM_RECT)
		{
			if (dockMethod == DM_DBL_CLICK && m_lstDockBarRows.Find(pControlBar->m_recentDockInfo.m_pRecentDockBarRow) != NULL)
			{
				pRowToDock = pControlBar->m_recentDockInfo.m_pRecentDockBarRow;
			}
			else
			{
				int nRowCount = (int) m_lstDockBarRows.GetCount();

				if (CDockingManager::m_bRestoringDockState)
				{
					if (pControlBar->m_recentDockInfo.m_nRecentRowIndex > nRowCount - 1)
					{
						for (int i = 0;
							i < pControlBar->m_recentDockInfo.m_nRecentRowIndex - nRowCount + 1; i++)
						{
							AddRow(NULL, bVertDock ? szBarSize.cx : szBarSize.cy);
						}
					}

					POSITION posRow = m_lstDockBarRows.FindIndex(pControlBar->m_recentDockInfo.m_nRecentRowIndex);
					pRowToDock = (CDockingPanesRow*) m_lstDockBarRows.GetAt(posRow);
				}
				else
				{
					if (pControlBar->m_recentDockInfo.m_nRecentRowIndex < nRowCount && dockMethod == DM_DBL_CLICK)
					{
						POSITION pos = m_lstDockBarRows.FindIndex(pControlBar->m_recentDockInfo.m_nRecentRowIndex);
						pRowToDock = (CDockingPanesRow*) m_lstDockBarRows.GetAt(pos);
						bOuterRow = true;
					}
					else if (dockMethod == DM_DBL_CLICK && !pControlBar->m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect.IsRectEmpty())
					{
						pRowToDock = FindRowByRect(pControlBar->m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect);
					}
					else if (dockMethod == DM_RECT && lpRect != NULL)
					{
						pRowToDock = FindRowByRect(lpRect);
					}
				}

				if (pRowToDock == NULL)
				{
					AddRow(NULL, bVertDock ? szBarSize.cx : szBarSize.cy);
					pRowToDock = (CDockingPanesRow*) m_lstDockBarRows.GetTail();
				}
			}

			ASSERT_VALID(pRowToDock);
			rectDockArea = &pControlBar->m_recentDockInfo.m_recentSliderInfo.m_rectDockedRect;
			ClientToScreen(rectDockArea);
		}

		// if the bar is being placed on the exclusive row
		//(with menu bar, for example) we should create a new row, put the
		// bar on new row and put this row after/before the exclusive row
		POSITION posSwapRow = NULL;
		if (pRowToDock != NULL && pRowToDock->IsExclusiveRow() || pRowToDock != NULL && !pControlBar->DoesAllowSiblingBars() && !pRowToDock->IsEmpty())
		{
			posSwapRow = m_lstDockBarRows.Find(pRowToDock);
			ENSURE(posSwapRow != NULL);
			pRowToDock = NULL;
		}

		if (pRowToDock == NULL)
		{
			POSITION posNewBar = NULL;

			if (posSwapRow != NULL)
			{
				// the bar is inserted before the specified position in AddRow
				posNewBar = posSwapRow;
				if (!bOuterRow)
				{
					m_lstDockBarRows.GetNext(posNewBar);
				}
			}
			else
			{
				posNewBar = bOuterRow ? m_lstDockBarRows.GetHeadPosition() : NULL;
			}

			pRowToDock = AddRow(posNewBar, bVertDock ? szBarSize.cx : szBarSize.cy);
		}

		ASSERT_VALID(pRowToDock);

		// the bar should be placed on the existing row or new row
		pRowToDock->AddPane(pControlBar, dockMethod, rectDockArea);
		// if the bar suudently changed its size we need to resize the row again
		CSize sizeBarNew = pControlBar->CalcFixedLayout(FALSE, !bVertDock);
		if (sizeBarNew != szBarSize)
		{
			ResizeRow(pRowToDock, bVertDock ? sizeBarNew.cx : sizeBarNew.cy);
		}

		m_lstControlBars.AddTail(pControlBar);
		AdjustDockingLayout();
		ShowWindow(SW_SHOW);
	}
}

CDockingPanesRow* CDockSite::FindRowByRect(CRect rectRow)
{
	bool b;
	CPoint pt = rectRow.TopLeft();
	ClientToScreen(&pt);
	return RowFromPoint(pt, b);
}

BOOL CDockSite::DockPaneLeftOf(CPane* pBarToDock, CPane* pTargetBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBarToDock);
	ASSERT_VALID(pTargetBar);

	CDockingPanesRow* pTargetRow = RowFromPane(pTargetBar);

	if (pTargetRow == NULL)
	{
		return FALSE;
	}

	CRect rectTargetBar;
	pTargetBar->GetWindowRect(rectTargetBar);
	ScreenToClient(rectTargetBar);

	BOOL bVertDock = !IsHorizontal();
	CSize szBarSize = pBarToDock->CalcFixedLayout(FALSE, !bVertDock);

	CRect rectFinal;

	if (IsHorizontal())
	{
		rectFinal.SetRect(rectTargetBar.left - szBarSize.cx - 10, rectTargetBar.top, rectTargetBar.left - 10, rectTargetBar.bottom);
	}
	else
	{
		rectFinal.SetRect(rectTargetBar.left, rectTargetBar.top - szBarSize.cy - 10, rectTargetBar.right, rectTargetBar.top - 10);
	}

	pBarToDock->PrepareToDock(this, DM_RECT);
	ClientToScreen(rectFinal);
	pTargetRow->m_bIgnoreBarVisibility = TRUE;
	pTargetRow->AddPane(pBarToDock, DM_RECT, &rectFinal);

	POSITION pos = m_lstControlBars.Find(pTargetBar);
	ENSURE(pos != NULL);

	m_lstControlBars.InsertBefore(pos, pBarToDock);

	AdjustDockingLayout();
	FixupVirtualRects();
	pTargetRow->m_bIgnoreBarVisibility = FALSE;

	return TRUE;
}

void CDockSite::RemovePane(CPane* pControlBar, AFX_DOCK_METHOD /*dockMethod*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pControlBar);

	if (!m_lstControlBars.IsEmpty())
	{
		POSITION pos = m_lstControlBars.Find(pControlBar);
		if (pos != NULL)
		{
			m_lstControlBars.RemoveAt(pos);
			// we need to reposition bars according to the new situation
			// 1. expand bars that were stretched due to presence of this bar
			// 2. remove empty rows

			CDockingPanesRow* pRow = pControlBar->GetDockSiteRow();
			if (pRow != NULL)
			{
				pRow->RemovePane(pControlBar);
			}
		}
	}
}

void CDockSite::FixupVirtualRects()
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstDockBarRows.GetHeadPosition(); pos != NULL;)
	{
		CDockingPanesRow* pNextRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
		ASSERT_VALID(pNextRow);

		pNextRow->FixupVirtualRects(false);
	}
}

void CDockSite::RepositionPanes(CRect& rectNewClientArea)
{
	ASSERT_VALID(this);

	CRect rectOldArea;
	GetClientRect(rectOldArea);
	CSize sizeNew = rectNewClientArea.Size();
	CSize sizeOld = rectOldArea.Size();
	if (sizeNew != sizeOld)
	{
		int nHorzOffset = sizeNew.cx - sizeOld.cx;
		int nVertOffset = sizeNew.cy - sizeOld.cy;

		for (POSITION pos = m_lstDockBarRows.GetHeadPosition(); pos != NULL;)
		{
			CDockingPanesRow* pNextRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
			ASSERT_VALID(pNextRow);
			if (nHorzOffset != 0)
			{
				pNextRow->RepositionPanes(rectNewClientArea, WMSZ_RIGHT, nHorzOffset > 0, abs(nHorzOffset));
			}

			if (nVertOffset != 0)
			{
				pNextRow->RepositionPanes(rectNewClientArea, WMSZ_BOTTOM, nVertOffset > 0, abs(nVertOffset));
			}
		}
	}
	else
	{
		// sanity check
		for (POSITION pos = m_lstDockBarRows.GetHeadPosition(); pos != NULL;)
		{
			CDockingPanesRow* pNextRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
			ASSERT_VALID(pNextRow);

			pNextRow->ExpandStretchedPanesRect();
		}
	}
}

CDockingPanesRow* CDockSite::CreateRow(CDockSite* /*pParentDocBar*/, int nOffset, int nRowHeight)
{
	ASSERT_VALID(this);
	CDockingPanesRow* pRow = new CDockingPanesRow(this, nOffset, nRowHeight);
	if (!pRow->Create())
	{
		delete pRow;
		return NULL;
	}
	return pRow;
}

CDockingPanesRow* CDockSite::AddRow(POSITION posRowBefore, int nRowHeight)
{
	ASSERT_VALID(this);
	// claculate the row offset
	int nOffset = 0;

	for (POSITION pos = m_lstDockBarRows.GetHeadPosition(); pos != posRowBefore;)
	{
		CDockingPanesRow* pNextRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
		ASSERT_VALID(pNextRow);
		if (pNextRow->IsVisible())
		{
			nOffset += pNextRow->GetRowHeight();
		}
	}

	ResizeDockSiteByOffset(nRowHeight);

	CDockingPanesRow* pNewRow = CreateRow(this, nOffset, nRowHeight);

	if (pNewRow == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	if (posRowBefore != NULL)
	{
		POSITION pos = m_lstDockBarRows.InsertBefore(posRowBefore, pNewRow);
		OnInsertRow(pos);
	}
	else
	{
		m_lstDockBarRows.AddTail(pNewRow);
	}

	return pNewRow;
}

void CDockSite::RemoveRow(CDockingPanesRow* pRow)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pRow);
	ASSERT(!m_lstDockBarRows.IsEmpty());

	int nRowHeight = pRow->GetRowHeight();
	if (pRow->IsVisible())
	{
		ResizeDockSiteByOffset(-nRowHeight);
	}

	POSITION pos = m_lstDockBarRows.Find(pRow);
	if (pos != NULL)
	{
		OnRemoveRow(pos);
		m_lstDockBarRows.RemoveAt(pos);
		delete pRow;
	}
}

int CDockSite::ResizeRow(CDockingPanesRow* pRow, int nNewSize, BOOL bAdjustLayout)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pRow);

	int nOffset = nNewSize - pRow->GetRowHeight();
	if (nOffset < 0 && !pRow->IsEmpty())
	{
		CSize size = pRow->CalcFixedLayout(TRUE, IsHorizontal());
		if (IsHorizontal() && nNewSize - size.cy < 0 || !IsHorizontal() && nNewSize - size.cx < 0)
		{
			return 0;
		}
	}
	int nActualOffset = OnResizeRow(pRow, nOffset);
	ResizeDockSiteByOffset(nActualOffset, bAdjustLayout);

	return nActualOffset;
}

void CDockSite::ShowRow(CDockingPanesRow* pRow, BOOL bShow, BOOL bAdjustLayout)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pRow);
	ASSERT(!m_lstDockBarRows.IsEmpty());

	POSITION pos = m_lstDockBarRows.Find(pRow);
	OnShowRow(pos, bShow);

	int nRowHeight = pRow->GetRowHeight();
	ResizeDockSiteByOffset(bShow ? nRowHeight : -nRowHeight, bAdjustLayout);

}

void CDockSite::OnInsertRow(POSITION pos)
{
	ASSERT_VALID(this);
	ENSURE(pos != NULL);

	CDockingPanesRow* pNewRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
	ASSERT_VALID(pNewRow);

	int nRowSize = pNewRow->GetRowHeight();

	// when the row is inserted, all control bars that belongs to the rows after new,
	// should be moved down
	while (pos != NULL)
	{
		CDockingPanesRow* pNextRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
		ASSERT_VALID(pNextRow);
		pNextRow->Move(nRowSize);
	}
}

void CDockSite::OnRemoveRow(POSITION pos, BOOL bByShow)
{
	ASSERT_VALID(this);
	ENSURE(pos != NULL);

	CDockingPanesRow* pRowToRemove = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
	ASSERT_VALID(pRowToRemove);

	if (!pRowToRemove->IsVisible() && !bByShow)
	{
		return;
	}

	int nRowSize = pRowToRemove->GetRowHeight();

	while (pos != NULL)
	{
		CDockingPanesRow* pNextRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
		ASSERT_VALID(pNextRow);
		pNextRow->Move(-nRowSize);
	}
}

void CDockSite::OnShowRow(POSITION pos, BOOL bShow)
{
	ASSERT_VALID(this);
	ENSURE(pos != NULL);

	bShow ? OnInsertRow(pos) : OnRemoveRow(pos, TRUE);
}

int CDockSite::OnResizeRow(CDockingPanesRow* pRowToResize, int nOffset)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pRowToResize);

	int nActualOffset = pRowToResize->Resize(nOffset);
	if (!pRowToResize->IsVisible())
	{
		return 0;
	}

	POSITION pos = m_lstDockBarRows.Find(pRowToResize);
	m_lstDockBarRows.GetNext(pos);
	// skip to next row
	while (pos != NULL)
	{
		CDockingPanesRow* pNextRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
		ASSERT_VALID(pNextRow);
		pNextRow->Move(nActualOffset);
	}

	return nActualOffset;
}

void CDockSite::SwapRows(CDockingPanesRow* pFirstRow, CDockingPanesRow* pSecondRow)
{
	POSITION posFirstRow = m_lstDockBarRows.Find(pFirstRow);
	POSITION posSecondRow = m_lstDockBarRows.Find(pSecondRow);

	ENSURE(posFirstRow != NULL);
	ENSURE(posSecondRow != NULL);

	POSITION posTmp = posFirstRow;

	FindNextVisibleRow(posTmp);

	bool bSwapDown = (posTmp == posSecondRow);

	if (!bSwapDown)
	{
		posTmp = posFirstRow;
		FindNextVisibleRow(posTmp, FALSE);
		if (posTmp != posSecondRow)
		{
			return;
		}
	}

	m_lstDockBarRows.InsertAfter(posFirstRow, pSecondRow);
	m_lstDockBarRows.InsertAfter(posSecondRow, pFirstRow);
	m_lstDockBarRows.RemoveAt(posFirstRow);
	m_lstDockBarRows.RemoveAt(posSecondRow);

	int nRowHeight = pFirstRow->GetRowHeight();
	pSecondRow->Move(bSwapDown ? -nRowHeight : nRowHeight);
	nRowHeight = pSecondRow->GetRowHeight();
	pFirstRow->Move(bSwapDown ? nRowHeight : -nRowHeight);
	FixupVirtualRects();
}

CDockingPanesRow* CDockSite::RowFromPoint(CPoint pt, bool& bOuterRow) const
{
	ASSERT_VALID(this);

	bOuterRow = false;
	CRect rectRow;
	for (POSITION pos = m_lstDockBarRows.GetHeadPosition(); pos != NULL;)
	{
		CDockingPanesRow* pRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
		ASSERT_VALID(pRow);

		if (!pRow->IsVisible())
		{
			continue;
		}

		pRow->GetWindowRect(rectRow);
		if (rectRow.PtInRect(pt))
		{
			return pRow;
		}
	}

	CRect rectWnd;
	GetWindowRect(&rectWnd);

	if (IsHorizontal() && pt.y < rectWnd.top || !IsHorizontal() && pt.x < rectWnd.left)
	{
		bOuterRow = true;
	}

	return NULL;
}

CDockingPanesRow* CDockSite::RowFromPane(CBasePane* pBar) const
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	for (POSITION pos = m_lstDockBarRows.GetHeadPosition(); pos != NULL;)
	{
		CDockingPanesRow* pRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
		ASSERT_VALID(pRow);

		if (pRow->HasPane(pBar) != NULL)
		{
			return pRow;
		}
	}

	return NULL;
}

BOOL CDockSite::ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL /*bActivate*/)
{
	CDockingPanesRow* pRow = RowFromPane(pBar);

	if (pRow != NULL)
	{
		CPane* pBarToShow = DYNAMIC_DOWNCAST(CPane, pBar);
		// allows to show/hide only CPane-derived bars(other bars
		// has no docking abilitty)
		if (pBarToShow != NULL)
		{
			return pRow->ShowPane(pBarToShow, bShow, bDelay);
		}
	}
	return FALSE;
}

void CDockSite::ResizeDockSiteByOffset(int nOffset, BOOL bAdjustLayout)
{
	ASSERT_VALID(this);

	CRect rect;
	GetWindowRect(&rect);
	GetParent()->ScreenToClient(&rect);

	switch (GetCurrentAlignment())
	{
	case CBRS_ALIGN_LEFT:
		rect.right += nOffset;
		break;

	case CBRS_ALIGN_RIGHT:
		rect.left -= nOffset;
		break;

	case CBRS_ALIGN_TOP:
		rect.bottom += nOffset;
		break;

	case CBRS_ALIGN_BOTTOM:
		rect.top  -= nOffset;
		break;
	}

	MoveWindow(rect);
	if (bAdjustLayout)
	{
		AdjustDockingLayout();
	}
}

bool CDockSite::IsLastRow(CDockingPanesRow* pRow) const
{
	ASSERT_VALID(this);
	return(!m_lstDockBarRows.IsEmpty() && (pRow == m_lstDockBarRows.GetHead() || pRow == m_lstDockBarRows.GetTail()));
}

CSize CDockSite::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	ASSERT_VALID(this);

	int nTotalHeightRequired = 0;

	BOOL bHorzBar = IsHorizontal();

	for (POSITION pos = m_lstDockBarRows.GetHeadPosition(); pos != NULL;)
	{
		CDockingPanesRow* pNextRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
		ASSERT_VALID(pNextRow);

		if (!pNextRow->IsVisible())
		{
			continue;
		}

		int nCurrHeight = pNextRow->GetRowHeight();
		CSize sizeRowRequired = pNextRow->CalcFixedLayout(bStretch, bHorz);

		int nHeightRequired =  bHorzBar ? sizeRowRequired.cy : sizeRowRequired.cx;

		if (nHeightRequired != nCurrHeight && nHeightRequired > 0)
		{
			ResizeRow(pNextRow, nHeightRequired, FALSE);
		}

		nTotalHeightRequired += nHeightRequired;
	}

	CRect rectWnd;
	GetWindowRect(rectWnd);

	return rectWnd.Size();
}

void CDockSite::ResizeDockSite(int nNewWidth, int nNewHeight) // not called from anywhere !!!
{
	ASSERT_VALID(this);
	CWnd* pParentWnd = GetParent();
	ASSERT_VALID(pParentWnd);

	CRect rectDockBar;
	GetClientRect(&rectDockBar);
	MapWindowPoints(pParentWnd, &rectDockBar);

	switch (GetCurrentAlignment())
	{
	case CBRS_ALIGN_LEFT:
		if (nNewHeight != -1)
		{
			rectDockBar.bottom = rectDockBar.top + nNewHeight;
		}
		break;

	case CBRS_ALIGN_RIGHT:
		if (nNewHeight != -1)
		{
			rectDockBar.bottom = rectDockBar.top + nNewHeight;
		}
		break;

	case CBRS_ALIGN_TOP:
		if (nNewWidth != -1)
		{
			rectDockBar.right = rectDockBar.left + nNewWidth;
		}
		break;

	case CBRS_ALIGN_BOTTOM:
		if (nNewWidth != -1)
		{
			rectDockBar.right = rectDockBar.left + nNewWidth;
		}
		break;
	}

	OnSetWindowPos(&wndBottom, rectDockBar, SWP_NOACTIVATE | SWP_NOZORDER);
}

void CDockSite::OnPaint()
{
	CPaintDC dc(this); // device context for painting
}

BOOL CDockSite::IsRectWithinDockSite(CRect rect, CPoint& ptDelta)
{
	ASSERT_VALID(this);
	CRect rectWnd;
	GetWindowRect(&rectWnd);

	ptDelta.x = ptDelta.y = 0;

	if (IsHorizontal())
	{
		if (rect.left < rectWnd.left)
		{
			ptDelta.x = rectWnd.left - rect.left;
			return FALSE;
		}
		if (rect.right >  rectWnd.right)
		{
			ptDelta.x = rectWnd.right - rect.right;
			return FALSE;
		}
	}
	else
	{
		if (rect.top < rectWnd.top)
		{
			ptDelta.y = rectWnd.top - rect.top;
			return FALSE;
		}
		if (rect.bottom > rectWnd.bottom)
		{
			ptDelta.y = rect.bottom - rectWnd.bottom;
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CDockSite::CanAcceptPane(const CBasePane* pBar) const
{
	ASSERT_VALID(this);
	if (pBar == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	return !IsResizable();
}

void CDockSite::OnSize(UINT nType, int cx, int cy)
{
	ASSERT_VALID(this);

	CWnd::OnSize(nType, cx, cy);
}

CPane* CDockSite::PaneFromPoint(CPoint pt)
{
	ASSERT_VALID(this);

	CRect rectBar;
	CPane* pBar = NULL;
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		pBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBar);

		pBar->GetWindowRect(rectBar);
		if (rectBar.PtInRect(pt))
		{
			return pBar;
		}
	}

	return NULL;
}

int __stdcall CDockSite::RectSideFromPoint(const CRect& rect, const CPoint& point)
{
	int nDeltaLeft = point.x - rect.left;
	int nDeltaTop = point.y - rect.top;
	int nDeltaRight = rect.right - point.x;
	int nDeltaBottom = rect.bottom - point.y;

	// use hit test definition to describe the side
	UINT nHitTestLR = (nDeltaLeft <= nDeltaRight) ? HTLEFT : HTRIGHT;
	UINT nHitTetsTB = (nDeltaTop <= nDeltaBottom) ? HTTOP : HTBOTTOM;

	int nHitTest = HTERROR;
	if (nHitTestLR == HTLEFT && nHitTetsTB == HTTOP)
	{
		nHitTest = (nDeltaLeft <= nDeltaTop) ? HTLEFT : HTTOP;
	}
	else if (nHitTestLR == HTRIGHT && nHitTetsTB == HTTOP)
	{
		nHitTest = (nDeltaRight <= nDeltaTop) ? HTRIGHT : HTTOP;
	}
	else if (nHitTestLR == HTLEFT && nHitTetsTB == HTBOTTOM)
	{
		nHitTest = (nDeltaLeft <= nDeltaBottom) ? HTLEFT : HTBOTTOM;
	}
	else if (nHitTestLR == HTRIGHT && nHitTetsTB == HTBOTTOM)
	{
		nHitTest = (nDeltaRight <= nDeltaBottom) ? HTRIGHT : HTBOTTOM;
	}
	else
	{
		return HTERROR;
	}
	return nHitTest;
}

BOOL CDockSite::ReplacePane(CPane* pOldBar, CPane* pNewBar)
{
	ASSERT_VALID(this);
	POSITION pos = m_lstControlBars.Find(pOldBar);

	if (pos != NULL)
	{
		m_lstControlBars.InsertAfter(pos, pNewBar);
		m_lstControlBars.RemoveAt(pos);
		return TRUE;
	}

	return FALSE;
}

BOOL CDockSite::OnSetWindowPos(const CWnd* pWndInsertAfter, const CRect& rectWnd, UINT nFlags)
{
	ASSERT_VALID(this);
	return(BOOL)(SetWindowPos(pWndInsertAfter, rectWnd.left, rectWnd.top, rectWnd.Width(), rectWnd.Height(), nFlags | SWP_NOACTIVATE) != 0);
}

void CDockSite::OnNcDestroy()
{
	CWnd::OnNcDestroy();
	delete this;
}

BOOL CDockSite::OnEraseBkgnd(CDC* pDC)
{
	CRect rect;
	GetClientRect(rect);

	CMFCVisualManager::GetInstance()->OnFillBarBackground(pDC, this, rect, rect, FALSE);
	return TRUE;
}

void CDockSite::AdjustLayout()
{
	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBar);
		pBar->AdjustLayout();
	}
}

void CDockSite::AdjustDockingLayout()
{
	ASSERT_VALID(this);

	CWnd* pParent = GetParent();
	ASSERT_VALID(pParent);

	if (pParent->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		((CFrameWndEx*) pParent)->AdjustDockingLayout();
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		((CMDIFrameWndEx*) pParent)->AdjustDockingLayout(NULL);
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		((COleIPFrameWndEx*) pParent)->AdjustDockingLayout();
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		((COleDocIPFrameWndEx*) pParent)->AdjustDockingLayout();
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		((COleCntrFrameWndEx*) pParent)->AdjustDockingLayout();
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		((CMDIChildWndEx*) pParent)->AdjustDockingLayout();
	}
	else if (pParent->IsKindOf(RUNTIME_CLASS(CDialog)))
	{
		if (pParent->GetSafeHwnd() == AfxGetMainWnd()->GetSafeHwnd())
		{
			afxGlobalUtils.m_bDialogApp = TRUE;
		}
	}
}

int CDockSite::FindRowIndex(CDockingPanesRow* pRow)
{
	ASSERT_VALID(this);

	if (pRow == NULL)
	{
		return 0;
	}

	int nIndex = 0;
	for (POSITION pos = m_lstDockBarRows.GetHeadPosition(); pos != NULL; nIndex++)
	{
		CDockingPanesRow* pNextRow = (CDockingPanesRow*) m_lstDockBarRows.GetNext(pos);
		if (pNextRow == pRow)
		{
			return nIndex;
		}
	}

	return 0;
}

void CDockSite::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return;
	}

	if (!CMFCToolBar::IsCustomizeMode() && !IsDragMode())
	{
		CFrameWnd* pParentFrame = AFXGetTopLevelFrame(this);
		if (pParentFrame == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		OnPaneContextMenu(pParentFrame, point);
	}
}

BOOL CDockSite::IsDragMode() const
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pBar = DYNAMIC_DOWNCAST(CPane, m_lstControlBars.GetNext(pos));
		if (pBar == NULL)
		{
			continue;
		}

		if (pBar->IsDragMode())
		{
			return TRUE;
		}
	}

	return FALSE;
}

CPane* CDockSite::FindPaneByID(UINT nID)
{
	ASSERT_VALID(this);

	for (POSITION pos = m_lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CPane* pBar = (CPane*) m_lstControlBars.GetNext(pos);
		ASSERT_VALID(pBar);

		if (pBar->GetDlgCtrlID() == (int) nID)
		{
			return pBar;
		}

		// Check for rebar:
		CMFCReBar* pRebar = DYNAMIC_DOWNCAST(CMFCReBar, pBar);
		if (pRebar != NULL)
		{
			ASSERT_VALID(pRebar);

			CPane* pBarPane = DYNAMIC_DOWNCAST(CPane, pRebar->GetDlgItem(nID));
			if (pBarPane != NULL)
			{
				return pBarPane;
			}
		}
	}

	return NULL;
}

void CDockSite::OnDestroy()
{
	RemovePaneFromDockManager(this, FALSE);
	CBasePane::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdropdowntoolbar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include <afxpriv.h>
#include "mmsystem.h"
#include "afxdropdowntoolbar.h"
#include "afxglobals.h"
#include "afxtoolbarmenubutton.h"
#include "afxmdiframewndex.h"
#include "afxframewndex.h"
#include "afxmenubar.h"
#include "afxsound.h"
#include "afxtoolbarmenubutton.h"
#include "afxtrackmouse.h"
#include "afxvisualmanager.h"
#include "afxdrawmanager.h"
#include "afxribbonres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const UINT uiShowBarTimerId = 1;
static const int nArrowSize = 7;

UINT CMFCDropDownToolbarButton::m_uiShowBarDelay = 500; // ms

IMPLEMENT_SERIAL(CMFCDropDownToolBar, CMFCToolBar, 1)

extern CObList afxAllToolBars;

BOOL CMFCDropDownToolBar::OnSendCommand(const CMFCToolBarButton* pButton)
{
	ASSERT_VALID(pButton);

	if ((pButton->m_nStyle & TBBS_DISABLED) != 0 || pButton->m_nID == 0 || pButton->m_nID == (UINT)-1)
	{
		return FALSE;
	}

	CMFCDropDownFrame* pParent = (CMFCDropDownFrame*)GetParent();
	ASSERT_KINDOF(CMFCDropDownFrame, pParent);

	pParent->m_pParentBtn->SetDefaultCommand(pButton->m_nID);

	// Send command to the parent frame:
	CFrameWnd* pParentFrame = GetParentFrame();
	ASSERT_VALID(pParentFrame);

	GetOwner()->PostMessage(WM_COMMAND, pButton->m_nID);
	pParentFrame->DestroyWindow();
	return TRUE;
}

void CMFCDropDownToolBar::OnUpdateCmdUI(CFrameWnd* /*pTarget*/, BOOL bDisableIfNoHndler)
{
	CMFCToolBar::OnUpdateCmdUI((CFrameWnd*)GetCommandTarget(), bDisableIfNoHndler);
}

BEGIN_MESSAGE_MAP(CMFCDropDownToolBar, CMFCToolBar)
	//{{AFX_MSG_MAP(CMFCDropDownToolBar)
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMFCDropDownToolBar::OnMouseMove(UINT /*nFlags*/, CPoint point)
{
	if (m_ptLastMouse != CPoint(-1, -1) && abs(m_ptLastMouse.x - point.x) < 1 && abs(m_ptLastMouse.y - point.y) < 1)
	{
		m_ptLastMouse = point;
		return;
	}

	m_ptLastMouse = point;

	int iPrevHighlighted = m_iHighlighted;
	m_iHighlighted = HitTest(point);

	CMFCToolBarButton* pButton = m_iHighlighted == -1 ? NULL : GetButton(m_iHighlighted);
	if (pButton != NULL && (pButton->m_nStyle & TBBS_SEPARATOR || (pButton->m_nStyle & TBBS_DISABLED && !AllowSelectDisabled())))
	{
		m_iHighlighted = -1;
	}

	if (!m_bTracked)
	{
		m_bTracked = TRUE;

		TRACKMOUSEEVENT trackmouseevent;
		trackmouseevent.cbSize = sizeof(trackmouseevent);
		trackmouseevent.dwFlags = TME_LEAVE;
		trackmouseevent.hwndTrack = GetSafeHwnd();
		trackmouseevent.dwHoverTime = HOVER_DEFAULT;
		AFXTrackMouse(&trackmouseevent);
	}

	if (iPrevHighlighted != m_iHighlighted)
	{
		BOOL bNeedUpdate = FALSE;

		m_iButtonCapture = m_iHighlighted;
		if (iPrevHighlighted != -1)
		{
			CMFCToolBarButton* pTBBCapt = GetButton(iPrevHighlighted);
			ENSURE(pTBBCapt != NULL);
			ASSERT(!(pTBBCapt->m_nStyle & TBBS_SEPARATOR));

			UINT nNewStyle = (pTBBCapt->m_nStyle & ~TBBS_PRESSED);

			if (nNewStyle != pTBBCapt->m_nStyle)
			{
				SetButtonStyle(iPrevHighlighted, nNewStyle);
			}

		}

		if (m_iButtonCapture != -1)
		{
			CMFCToolBarButton* pTBBCapt = GetButton(m_iButtonCapture);
			ENSURE(pTBBCapt != NULL);
			ASSERT(!(pTBBCapt->m_nStyle & TBBS_SEPARATOR));

			UINT nNewStyle = (pTBBCapt->m_nStyle & ~TBBS_PRESSED);
			if (m_iHighlighted == m_iButtonCapture)
			{
				nNewStyle |= TBBS_PRESSED;
			}

			if (nNewStyle != pTBBCapt->m_nStyle)
			{
				SetButtonStyle(m_iButtonCapture, nNewStyle);
				bNeedUpdate = TRUE;
			}
		}

		if ((m_iButtonCapture == -1 || iPrevHighlighted == m_iButtonCapture) && iPrevHighlighted != -1)
		{
			InvalidateButton(iPrevHighlighted);
			bNeedUpdate = TRUE;
		}

		if ((m_iButtonCapture == -1 || m_iHighlighted == m_iButtonCapture) && m_iHighlighted != -1)
		{
			InvalidateButton(m_iHighlighted);
			bNeedUpdate = TRUE;
		}

		if (bNeedUpdate)
		{
			UpdateWindow();
		}

		if (m_iHighlighted != -1 && (m_iHighlighted == m_iButtonCapture || m_iButtonCapture == -1))
		{
			ENSURE(pButton != NULL);
			ShowCommandMessageString(pButton->m_nID);
		}
		else if (m_iButtonCapture == -1 && m_hookMouseHelp == NULL)
		{
			GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);
		}

		OnChangeHot(m_iHighlighted);
	}
}

void CMFCDropDownToolBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	CRect rectClient;
	GetClientRect(&rectClient);

	if (!m_bCustomizeMode && !rectClient.PtInRect(point))
	{
		CFrameWnd* pParentFrame = GetParentFrame();
		ASSERT_VALID(pParentFrame);

		pParentFrame->DestroyWindow();
		return;
	}

	if (!m_bCustomizeMode && m_iHighlighted >= 0)
	{
		m_iButtonCapture = m_iHighlighted;

		CMFCToolBarButton* pButton = GetButton(m_iHighlighted);
		ASSERT_VALID(pButton);

		pButton->m_nStyle &= ~TBBS_PRESSED;
	}

	CMFCToolBar::OnLButtonUp(nFlags, point);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCDropDownFrame

static const int nBorderSize = 2;

CString CMFCDropDownFrame::m_strClassName;

IMPLEMENT_SERIAL(CMFCDropDownFrame, CMiniFrameWnd, VERSIONABLE_SCHEMA | 1)

CMFCDropDownFrame::CMFCDropDownFrame()
{
	m_x = m_y = 0;
	m_pParentBtn = NULL;
	m_bAutoDestroyParent = TRUE;
	m_bAutoDestroy = TRUE;
	m_pWndOriginToolbar = NULL;
}

CMFCDropDownFrame::~CMFCDropDownFrame()
{
	m_wndToolBar.m_Buttons.RemoveAll(); // toolbar has references to original buttons!

	if (m_bAutoDestroy)
	{
		m_wndToolBar.DestroyWindow();
	}
}

BEGIN_MESSAGE_MAP(CMFCDropDownFrame, CMiniFrameWnd)
	//{{AFX_MSG_MAP(CMFCDropDownFrame)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_MOUSEACTIVATE()
	ON_WM_DESTROY()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
	ON_WM_ACTIVATEAPP()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCDropDownFrame message handlers

BOOL CMFCDropDownFrame::Create(CWnd* pWndParent, int x, int y, CMFCDropDownToolBar* pWndOriginToolbar)
{
	ASSERT_VALID(pWndOriginToolbar);
	ENSURE(pWndParent != NULL);

	AFXPlaySystemSound(AFX_SOUND_MENU_POPUP);

	if (m_strClassName.IsEmpty())
	{
		m_strClassName = ::AfxRegisterWndClass(CS_SAVEBITS, ::LoadCursor(NULL, IDC_ARROW), (HBRUSH)(COLOR_BTNFACE + 1), NULL);
	}

	m_pWndOriginToolbar = pWndOriginToolbar;

	if (x == -1 && y == -1) // Undefined position
	{
		if (pWndParent != NULL)
		{
			CRect rectParent;
			pWndParent->GetClientRect(&rectParent);
			pWndParent->ClientToScreen(&rectParent);

			m_x = rectParent.left + 5;
			m_y = rectParent.top + 5;
		}
		else
		{
			m_x = 0;
			m_y = 0;
		}
	}
	else
	{
		m_x = x;
		m_y = y;
	}

	DWORD dwStyle = WS_POPUP;

	CRect rect(x, y, x, y);
	BOOL bCreated = CMiniFrameWnd::CreateEx(0, m_strClassName, m_strCaption, dwStyle, rect, pWndParent->GetOwner() == NULL ? pWndParent : pWndParent->GetOwner());
	if (!bCreated)
	{
		return FALSE;
	}

	ShowWindow(SW_SHOWNOACTIVATE);
	return TRUE;
}

int CMFCDropDownFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	ASSERT_VALID(m_pWndOriginToolbar);
	ASSERT(m_pWndOriginToolbar->m_bLocked);

	if (CMiniFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	CMFCToolBar* pParentBar = m_pParentBtn == NULL ? NULL : DYNAMIC_DOWNCAST(CMFCToolBar, m_pParentBtn->m_pWndParent);

	BOOL bHorz = pParentBar == NULL ? TRUE : pParentBar->IsHorizontal();
	DWORD style = bHorz? CBRS_ORIENT_VERT : CBRS_ORIENT_HORZ;

	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | style, CRect(1, 1, 1, 1), AFX_IDW_TOOLBAR + 39))
	{
		TRACE(_T("Can't create toolbar bar\n"));
		return -1;
	}

	m_wndToolBar.m_bLocked = TRUE;

	// "Clone" the original toolbar:
	m_pWndOriginToolbar->m_ImagesLocked.CopyTemp(m_wndToolBar.m_ImagesLocked);
	m_pWndOriginToolbar->m_ColdImagesLocked.CopyTemp(m_wndToolBar.m_ColdImagesLocked);
	m_pWndOriginToolbar->m_DisabledImagesLocked.CopyTemp(m_wndToolBar.m_DisabledImagesLocked);
	m_pWndOriginToolbar->m_LargeImagesLocked.CopyTemp(m_wndToolBar.m_LargeImagesLocked);
	m_pWndOriginToolbar->m_LargeColdImagesLocked.CopyTemp(m_wndToolBar.m_LargeColdImagesLocked);
	m_pWndOriginToolbar->m_LargeDisabledImagesLocked.CopyTemp(m_wndToolBar.m_LargeDisabledImagesLocked);

	m_wndToolBar.m_sizeButtonLocked = m_pWndOriginToolbar->m_sizeButtonLocked;
	m_wndToolBar.m_sizeImageLocked = m_pWndOriginToolbar->m_sizeImageLocked;
	m_wndToolBar.m_sizeCurButtonLocked = m_pWndOriginToolbar->m_sizeCurButtonLocked;
	m_wndToolBar.m_sizeCurImageLocked = m_pWndOriginToolbar->m_sizeCurImageLocked;

	m_wndToolBar.m_dwStyle &= ~CBRS_GRIPPER;

	m_wndToolBar.SetOwner(m_pWndOriginToolbar->GetOwner());
	m_wndToolBar.SetRouteCommandsViaFrame(m_pWndOriginToolbar->GetRouteCommandsViaFrame());

	m_wndToolBar.m_Buttons.AddTail(&m_pWndOriginToolbar->m_Buttons);

	RecalcLayout();
	::ReleaseCapture();
	m_wndToolBar.SetCapture();

	return 0;
}

void CMFCDropDownFrame::OnSize(UINT nType, int cx, int cy)
{
	CMiniFrameWnd::OnSize(nType, cx, cy);

	if (m_wndToolBar.GetSafeHwnd() != NULL)
	{
		m_wndToolBar.SetWindowPos(NULL, nBorderSize, nBorderSize, cx - nBorderSize * 2, cy - nBorderSize * 2, SWP_NOZORDER | SWP_NOACTIVATE);
	}
}

void CMFCDropDownFrame::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	CRect rectClient; // Client area rectangle
	GetClientRect(&rectClient);

	dc.Draw3dRect(rectClient, afxGlobalData.clrBarLight, afxGlobalData.clrBarDkShadow);
	rectClient.DeflateRect(1, 1);
	dc.Draw3dRect(rectClient, afxGlobalData.clrBarHilite, afxGlobalData.clrBarShadow);
}

int CMFCDropDownFrame::OnMouseActivate(CWnd* /*pDesktopWnd*/, UINT /*nHitTest*/, UINT /*message*/)
{
	return MA_NOACTIVATE;
}

void CMFCDropDownFrame::RecalcLayout(BOOL /*bNotify*/)
{
#ifdef _DEBUG
	if (m_pParentBtn != NULL)
	{
		ASSERT_VALID(m_pParentBtn);
		ASSERT(m_pParentBtn->m_pPopupMenu == this);
	}
#endif // _DEBUG

	if (!::IsWindow(m_hWnd) || !::IsWindow(m_wndToolBar.m_hWnd))
	{
		return;
	}

	CMFCToolBar* pParentBar = m_pParentBtn == NULL ? NULL : DYNAMIC_DOWNCAST(CMFCToolBar, m_pParentBtn->m_pWndParent);

	BOOL bHorz = pParentBar == NULL ? TRUE : pParentBar->IsHorizontal();

	CSize size = m_wndToolBar.CalcSize(bHorz);
	size.cx += nBorderSize * 3;
	size.cy += nBorderSize * 3;

	// Adjust the menu position by the screen size:
	CRect rectScreen;

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);
	if (GetMonitorInfo(MonitorFromPoint(CPoint(m_x, m_y), MONITOR_DEFAULTTONEAREST), &mi))
	{
		rectScreen = mi.rcWork;
	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
	}

	if (m_x + size.cx > rectScreen.right)
	{
		// Menu can't be overlapped with the parent popup menu!
		pParentBar = m_pParentBtn == NULL ? NULL : DYNAMIC_DOWNCAST(CMFCToolBar, m_pParentBtn->m_pWndParent);
		if (pParentBar != NULL && (pParentBar->IsHorizontal()) == 0)
		{
			// Parent menu bar is docked vertical, place menu
			// in the left or right side of the parent frame:
			CRect rectParent;
			pParentBar->GetWindowRect(rectParent);

			m_x = rectParent.left - size.cx;
		}
		else
		{
			m_x = rectScreen.Width() - size.cx - 1;
		}
	}

	if (m_y + size.cy > rectScreen.bottom)
	{
		m_y -= size.cy;

		if (m_pParentBtn != NULL)
		{
			m_y -= m_pParentBtn->m_rect.Height() + 4;
		}
		else if (m_y < 0)
		{
			m_y = 0;
		}
	}

	SetWindowPos(NULL, m_x, m_y, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
}

void CMFCDropDownFrame::OnDestroy()
{
	if (m_pParentBtn != NULL)
	{
		ASSERT(m_pParentBtn->m_pPopupMenu == this);

		m_pParentBtn->m_pPopupMenu = NULL;
		m_pParentBtn->m_nStyle = m_pParentBtn->m_nStyle & ~TBBS_PRESSED;

		CMFCToolBar* pparentBar = DYNAMIC_DOWNCAST(CMFCToolBar, m_pParentBtn->m_pWndParent);
		if (pparentBar)
		{
			CPoint point;
			::GetCursorPos(&point);

			pparentBar->ScreenToClient(&point);
			pparentBar->SendMessage(WM_LBUTTONUP, NULL, MAKELONG(point.x, point.y));
		}
	}

	CMiniFrameWnd::OnDestroy();
}

void CMFCDropDownFrame::PostNcDestroy()
{
	if (m_pParentBtn != NULL)
	{
		m_pParentBtn->OnCancelMode();
	}

	CMiniFrameWnd::PostNcDestroy();
}

CMFCDropDownFrame* CMFCDropDownFrame::GetParentPopupMenu() const
{
	if (m_pParentBtn == NULL)
	{
		return NULL;
	}

	CMFCPopupMenuBar* pParentBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pParentBtn->m_pWndParent);
	if (pParentBar != NULL)
	{
		CMFCDropDownFrame* pParentMenu = DYNAMIC_DOWNCAST(CMFCDropDownFrame, pParentBar->GetParentFrame());
		ASSERT_VALID(pParentMenu);

		return pParentMenu;
	}
	else
	{
		return NULL;
	}
}

CMFCMenuBar* CMFCDropDownFrame::GetParentMenuBar() const
{
	if (m_pParentBtn == NULL)
	{
		return NULL;
	}

	CMFCMenuBar* pParentBar = DYNAMIC_DOWNCAST(CMFCMenuBar, m_pParentBtn->m_pWndParent);
	return pParentBar;
}

BOOL CMFCDropDownFrame::OnEraseBkgnd(CDC* pDC)
{
	CRect rectClient; // Client area rectangle
	GetClientRect(&rectClient);

	pDC->FillSolidRect(rectClient, afxGlobalData.clrBarFace);
	return TRUE;
}

void CMFCDropDownFrame::OnActivateApp(BOOL bActive, DWORD /*dwThreadID*/)
{
	if (!bActive && !CMFCToolBar::IsCustomizeMode())
	{
		SendMessage(WM_CLOSE);
	}
}

IMPLEMENT_SERIAL(CMFCDropDownToolbarButton, CMFCToolBarButton, VERSIONABLE_SCHEMA | 1)

// Construction/Destruction
CMFCDropDownToolbarButton::CMFCDropDownToolbarButton()
{
	m_pToolBar = NULL;
	m_pPopupMenu = NULL;
	m_pWndParent = NULL;
	m_uiTimer = 0;
	m_bLocked = TRUE;
	m_iSelectedImage = 0;
	m_bInternalDraw = FALSE;
	m_bLocalUserButton = FALSE;
}

CMFCDropDownToolbarButton::CMFCDropDownToolbarButton(LPCTSTR lpszName, CMFCDropDownToolBar* pToolBar)
{
	ENSURE(lpszName != NULL);
	m_strName = lpszName;

	m_uiTimer = 0;

	m_pPopupMenu = NULL;
	m_pWndParent = NULL;

	ASSERT_VALID(pToolBar);
	m_pToolBar = pToolBar;

	CMFCToolBarButton* pbutton = pToolBar->GetButton(0);
	if (pbutton == NULL) // Toolbar is empty!
	{
		ASSERT(FALSE);
	}
	else
	{
		CMFCToolBarButton::CopyFrom(*pbutton);
	}

	m_iSelectedImage = 0;

	m_bLocalUserButton = FALSE;
}

CMFCDropDownToolbarButton::~CMFCDropDownToolbarButton()
{
}

void CMFCDropDownToolbarButton::SetDefaultCommand(UINT uiCmd)
{
	ASSERT_VALID(m_pToolBar);

	m_nID = uiCmd;

	// Find image index:
	int iImage = 0;
	m_iSelectedImage = -1;

	for (int i = 0; i < m_pToolBar->GetCount(); i ++)
	{
		CMFCToolBarButton* pButton = m_pToolBar->GetButton(i);
		ASSERT_VALID(pButton);

		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			continue;
		}

		if (pButton->m_nID == uiCmd)
		{
			m_bLocalUserButton = pButton->m_bUserButton;

			if (m_bLocalUserButton)
			{
				m_iSelectedImage = pButton->GetImage();
			}
			else
			{
				m_iSelectedImage = iImage;
			}
			break;
		}

		iImage ++;
	}

	if (m_iSelectedImage == -1)
	{
		ASSERT(FALSE);
		m_iSelectedImage = 0;
	}
}

//////////////////////////////////////////////////////////////////////
// Overrides:

void CMFCDropDownToolbarButton::CopyFrom(const CMFCToolBarButton& s)
{
	CMFCToolBarButton::CopyFrom(s);

	const CMFCDropDownToolbarButton& src = (const CMFCDropDownToolbarButton&) s;

	m_pToolBar = src.m_pToolBar;
	m_strName = src.m_strName;
	m_iSelectedImage = src.m_iSelectedImage;

	m_bDragFromCollection = FALSE;
}

void CMFCDropDownToolbarButton::Serialize(CArchive& ar)
{
	CMFCToolBarButton::Serialize(ar);

	UINT uiToolbarResID = 0;

	if (ar.IsLoading())
	{
		m_pToolBar = NULL;

		ar >> uiToolbarResID;
		ar >> m_strName;
		ar >> m_iSelectedImage;

		// Find toolbar with required resource ID:
		for (POSITION pos = afxAllToolBars.GetHeadPosition(); pos != NULL;)
		{
			CMFCDropDownToolBar* pToolBar = DYNAMIC_DOWNCAST(CMFCDropDownToolBar, afxAllToolBars.GetNext(pos));

			if (pToolBar != NULL && CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
			{
				ASSERT_VALID(pToolBar);
				if (pToolBar->m_uiOriginalResID == uiToolbarResID)
				{
					m_pToolBar = pToolBar;
					break;
				}
			}
		}

		SetDefaultCommand(m_nID);
	}
	else
	{
		if (m_pToolBar == NULL)
		{
			ASSERT(FALSE);
		}
		else
		{
			ASSERT_VALID(m_pToolBar);
			uiToolbarResID = m_pToolBar->m_uiOriginalResID;
		}

		ar << uiToolbarResID;
		ar << m_strName;
		ar << m_iSelectedImage;
	}
}

void CMFCDropDownToolbarButton::OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* /*pImages*/, BOOL bHorz, BOOL bCustomizeMode, BOOL bHighlight, BOOL bDrawBorder, BOOL bGrayDisabledButtons)
{

	ASSERT_VALID(pDC);

	// Fill button interior:
	FillInterior(pDC, rect, bHighlight);

	int nCurrArrowSize = nArrowSize;
	if (afxGlobalData.GetRibbonImageScale() != 1.)
	{
		nCurrArrowSize = (int) (afxGlobalData.GetRibbonImageScale() * nCurrArrowSize);
	}
	
	int nActualArrowSize = CMFCToolBar::IsLargeIcons() ? nCurrArrowSize * 2 : nCurrArrowSize;
	int nHalfArrowSize = CMFCToolBar::IsLargeIcons() ? nCurrArrowSize : nCurrArrowSize / 2 + 1;

	CRect rectParent = rect;
	rectParent.right -= nActualArrowSize / 2 + 1;

	if (m_pToolBar != NULL)
	{
		CAfxDrawState ds;

		BOOL bImage = m_bImage;
		m_bInternalDraw = TRUE;

		CSize sizeDest = m_pToolBar->GetImageSize();
		if (afxGlobalData.GetRibbonImageScale() != 1.)
		{
			double dblImageScale = afxGlobalData.GetRibbonImageScale();
			sizeDest = CSize((int)(.5 + sizeDest.cx * dblImageScale), (int)(.5 + sizeDest.cy * dblImageScale));
		}

		CMFCToolBarImages& images = (m_pToolBar->m_bLargeIcons && m_pToolBar->m_LargeImagesLocked.GetCount() > 0) ? m_pToolBar->m_LargeImagesLocked : m_pToolBar->m_ImagesLocked;

		if (!m_bLocalUserButton)
		{
			images.SetTransparentColor(afxGlobalData.clrBtnFace);
			images.PrepareDrawImage (ds, sizeDest);
		}
		else
		{
			m_pToolBar->m_pUserImages->SetTransparentColor(afxGlobalData.clrBtnFace);
			m_pToolBar->m_pUserImages->PrepareDrawImage (ds, sizeDest);
		}

		m_iImage = m_iSelectedImage;
		m_iUserImage = m_iSelectedImage;
		m_bImage = TRUE;

		BOOL bDisableFill = m_bDisableFill;
		m_bDisableFill = TRUE;

		if (m_bLocalUserButton)
		{
			m_bUserButton = m_bLocalUserButton;
			CMFCToolBarButton::OnDraw(pDC, rect, m_pToolBar->m_pUserImages, bHorz,  bCustomizeMode, bHighlight,  FALSE, bGrayDisabledButtons);
			m_bUserButton = FALSE;
		}
		else
		{
			CMFCToolBarButton::OnDraw(pDC, rectParent, &images, bHorz, bCustomizeMode, bHighlight, FALSE, bGrayDisabledButtons);
		}
		m_bDisableFill = bDisableFill;
		m_iImage = -1;
		m_iUserImage = -1;
		m_bImage = bImage;

		if (!m_bLocalUserButton)
		{
			images.EndDrawImage(ds);
		}
		else
		{
			m_pToolBar->m_pUserImages->EndDrawImage(ds);
		}
		m_bInternalDraw = FALSE;
	}

	int offset = (m_nStyle & TBBS_PRESSED) ? 1 : 0;

	CPoint triang [] =
	{
		CPoint(rect.right - nActualArrowSize + offset - 1, rect.bottom - nHalfArrowSize + offset + 1),
		CPoint(rect.right - nHalfArrowSize + offset + 1, rect.bottom - nHalfArrowSize + offset + 1),
		CPoint(rect.right - nHalfArrowSize + offset + 1, rect.bottom - nActualArrowSize + offset - 1)
	};

	CPen* pOldPen = (CPen*) pDC->SelectStockObject(NULL_PEN);
	ENSURE(pOldPen != NULL);

	CBrush* pOldBrush = (CBrush*) pDC->SelectObject(&afxGlobalData.brBlack);
	ENSURE(pOldBrush != NULL);

	pDC->Polygon(triang, 3);

	if (!bCustomizeMode && HaveHotBorder() && bDrawBorder)
	{
		if (m_pPopupMenu != NULL || (m_nStyle &(TBBS_PRESSED | TBBS_CHECKED)))
		{
			// Pressed in or checked:
			if (m_nID != 0 && m_nID != (UINT) -1)
			{
				CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsPressed);
			}
			else
			{
				CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsHighlighted);
			}
		}
		else if (bHighlight && !(m_nStyle & TBBS_DISABLED) && !(m_nStyle &(TBBS_CHECKED | TBBS_INDETERMINATE)))
		{
			if (m_nStyle & TBBS_PRESSED)
			{
				CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsPressed);
			}
			else
			{
				CMFCVisualManager::GetInstance()->OnDrawButtonBorder(pDC, this, rect, CMFCVisualManager::ButtonsIsHighlighted);
			}
		}
	}

	pDC->SelectObject(pOldPen);
	pDC->SelectObject(pOldBrush);
}

static CMFCDropDownToolbarButton* g_pButtonDown = NULL;

static void CALLBACK EXPORT TimerProc(HWND hWnd, UINT, UINT_PTR, DWORD)
{
	CWnd* pwnd = CWnd::FromHandle(hWnd);
	if (g_pButtonDown != NULL)
	{
		g_pButtonDown->OnClick(pwnd, FALSE);
	}
}

BOOL CMFCDropDownToolbarButton::OnClick(CWnd* pWnd, BOOL bDelay)
{
	ASSERT_VALID(pWnd);
	if (m_uiTimer == 0)
	{
		if (m_pWndParent != NULL)
		{
			m_uiTimer = (UINT) m_pWndParent->SetTimer(uiShowBarTimerId, m_uiShowBarDelay, TimerProc);
		}

		g_pButtonDown = this;
		return CMFCToolBarButton::OnClick(pWnd, bDelay);
	}

	if (m_pWndParent != NULL)
	{
		m_pWndParent->KillTimer(m_uiTimer);
	}

	m_uiTimer = 0;
	g_pButtonDown = NULL;

	CMFCMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCMenuBar, m_pWndParent);

	if (m_pPopupMenu != NULL)
	{
		// Second click to the popup menu item closes the menu:
		ASSERT_VALID(m_pPopupMenu);

		m_pPopupMenu->m_bAutoDestroyParent = FALSE;
		m_pPopupMenu->DestroyWindow();
		m_pPopupMenu = NULL;

		if (pMenuBar != NULL)
		{
			pMenuBar->SetHot(NULL);
		}
	}
	else
	{
		CMFCPopupMenuBar* pParentMenu = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, m_pWndParent);
		if (bDelay && pParentMenu != NULL && !CMFCToolBar::IsCustomizeMode())
		{
		}
		else
		{
			DropDownToolbar(pWnd);
		}

		if (pMenuBar != NULL)
		{
			pMenuBar->SetHot(this);
		}
	}

	if (m_pWndParent != NULL)
	{
		m_pWndParent->InvalidateRect(m_rect);
	}

	return FALSE;
}

BOOL CMFCDropDownToolbarButton::OnClickUp()
{
	CMFCMenuBar* pMenuBar = DYNAMIC_DOWNCAST(CMFCMenuBar, m_pWndParent);

	if (m_uiTimer)
	{
		if (m_pWndParent != NULL)
		{
			m_pWndParent->KillTimer(m_uiTimer);
		}

		m_uiTimer = 0;
		g_pButtonDown = NULL;
		return FALSE;
	}

	if (m_pPopupMenu != NULL)
	{
		// Second click to the popup menu item closes the menu:
		ASSERT_VALID(m_pPopupMenu);

		m_pPopupMenu->m_bAutoDestroyParent = FALSE;
		m_pPopupMenu->DestroyWindow();
		m_pPopupMenu = NULL;

		if (pMenuBar != NULL)
		{
			pMenuBar->SetHot(NULL);
		}
	}

	return TRUE;
}

void CMFCDropDownToolbarButton::OnChangeParentWnd(CWnd* pWndParent)
{
	CMFCToolBarButton::OnChangeParentWnd(pWndParent);

	m_bText = FALSE;
	m_strText.Empty();
	m_bUserButton = FALSE;
}

void CMFCDropDownToolbarButton::OnCancelMode()
{
	if (m_pWndParent != NULL && ::IsWindow(m_pWndParent->m_hWnd))
	{
		m_pWndParent->InvalidateRect(m_rect);
		m_pWndParent->UpdateWindow();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCDropDownToolbarButton diagnostics

#ifdef _DEBUG
void CMFCDropDownToolbarButton::AssertValid() const
{
	CObject::AssertValid();
}

void CMFCDropDownToolbarButton::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);
}

#endif

BOOL CMFCDropDownToolbarButton::DropDownToolbar(CWnd* pWnd)
{
	if (m_pToolBar == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (m_pPopupMenu != NULL)
	{
		return FALSE;
	}

	if (pWnd == NULL)
	{
		pWnd = m_pWndParent;
		if (m_pWndParent == NULL)
		{
			return FALSE;
		}
	}

	// Define a new menu position. Place the menu in the right side
	// of the current menu in the poup menu case or under the current
	// item by default:
	CPoint point;

	CMFCToolBar* pParentBar = DYNAMIC_DOWNCAST(CMFCToolBar, m_pWndParent);

	if (pParentBar != NULL && !pParentBar->IsHorizontal())
	{
		// Parent menu bar is docked vertical, place menu
		// in the left or right side of the parent frame:
		point = CPoint(m_rect.right + 1, m_rect.top);
		pWnd->ClientToScreen(&point);
	}
	else
	{
		point = CPoint(m_rect.left - 1, m_rect.bottom);
		pWnd->ClientToScreen(&point);
	}

	m_pPopupMenu = new CMFCDropDownFrame;
	m_pPopupMenu->m_pParentBtn = this;

	return m_pPopupMenu->Create(pWnd, point.x, point.y, m_pToolBar);
}

SIZE CMFCDropDownToolbarButton::OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz)
{
	if (m_nID == 0 && m_pToolBar != NULL)
	{
		ASSERT_VALID(m_pToolBar);

		CMFCToolBarButton* pButton = m_pToolBar->GetButton(0);
		if (pButton == NULL) // Toolbar is empty!
		{
			ASSERT(FALSE);
		}
		else
		{
			SetDefaultCommand(pButton->m_nID);
		}
	}

	BOOL bImage = m_bImage;

	m_iImage = m_iSelectedImage;
	m_bImage = TRUE;

	CSize sizeBtn = CMFCToolBarButton::OnCalculateSize(pDC, sizeDefault, bHorz);

	m_iImage = -1;
	m_bImage = bImage;

	int nCurrArrowSize = nArrowSize;
	if (afxGlobalData.GetRibbonImageScale() != 1.)
	{
		nCurrArrowSize = (int) (afxGlobalData.GetRibbonImageScale() * nCurrArrowSize);
	}

	int nArrowWidth = CMFCToolBar::IsLargeIcons() ? nCurrArrowSize + 2 : nCurrArrowSize / 2 + 1;
	sizeBtn.cx += nArrowWidth;

	return sizeBtn;
}

BOOL CMFCDropDownToolbarButton::ExportToMenuButton(CMFCToolBarMenuButton& menuButton) const
{
	if (m_pToolBar == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	if (!CMFCToolBarButton::ExportToMenuButton(menuButton))
	{
		return FALSE;
	}

	// Create a popup menu with all items:
	CMenu menu;
	menu.CreatePopupMenu();

	for (POSITION pos = m_pToolBar->m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_pToolBar->m_Buttons.GetNext(pos);
		ENSURE(pButton != NULL);

		if (pButton->m_nStyle & TBBS_SEPARATOR)
		{
			menu.AppendMenu(MF_SEPARATOR);
		}
		else if (pButton->m_nID != 0 && pButton->m_nID != (UINT) -1)// Ignore sub-menus
		{
			CString strItem = pButton->m_strText;
			if (strItem.IsEmpty())
			{
				CString strMessage;
				int iOffset;

				if (strMessage.LoadString(pButton->m_nID) && (iOffset = strMessage.Find(_T('\n'))) != -1)
				{
					strItem = strMessage.Mid(iOffset + 1);
				}
			}

			menu.AppendMenu(MF_STRING, pButton->m_nID, strItem);
		}
	}

	menuButton.m_nID = 0;
	menuButton.m_strText = m_strName;
	menuButton.SetImage(-1);
	menuButton.m_bImage = FALSE;
	menuButton.CreateFromMenu(menu);

	menu.DestroyMenu();
	return TRUE;
}

int CMFCDropDownToolbarButton::OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected)
{
	CString strText = m_strText;
	m_strText = m_strName;

	int iResult = CMFCToolBarButton::OnDrawOnCustomizeList(pDC, rect, bSelected);

	m_strText = strText;
	return iResult;
}

BOOL CMFCDropDownToolbarButton::OnCustomizeMenu(CMenu* pPopup)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pPopup);

	pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE, MF_GRAYED | MF_BYCOMMAND);
	pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_TEXT, MF_GRAYED | MF_BYCOMMAND);
	pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT, MF_GRAYED | MF_BYCOMMAND);
	pPopup->EnableMenuItem(ID_AFXBARRES_TOOLBAR_APPEARANCE, MF_GRAYED | MF_BYCOMMAND);
	pPopup->EnableMenuItem(ID_AFXBARRES_COPY_IMAGE, MF_GRAYED | MF_BYCOMMAND);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxeditbrowsectrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxtoolbarimages.h"
#include "afxvisualmanager.h"
#include "afxribbonres.h"
#include "afxshellmanager.h"
#include "afxeditbrowsectrl.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCEditBrowseCtrl

CMFCEditBrowseCtrl::CMFCEditBrowseCtrl()
{
	m_rectBtn.SetRectEmpty();
	m_bIsButtonPressed = FALSE;
	m_bIsButtonHighlighted = FALSE;
	m_bIsButtonCaptured = FALSE;
	m_Mode = BrowseMode_None;
	m_sizeImage = CSize(0, 0);
	m_nBrowseButtonWidth = 20;
	m_bDefaultImage = TRUE;
}

CMFCEditBrowseCtrl::~CMFCEditBrowseCtrl()
{
}

BEGIN_MESSAGE_MAP(CMFCEditBrowseCtrl, CEdit)
	//{{AFX_MSG_MAP(CMFCEditBrowseCtrl)
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	ON_WM_NCHITTEST()
	ON_WM_NCLBUTTONDBLCLK()
	ON_WM_NCMOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCEditBrowseCtrl::OnInitControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCEditBrowseCtrl message handlers

void CMFCEditBrowseCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bIsButtonCaptured)
	{
		ReleaseCapture();

		m_bIsButtonPressed = FALSE;
		m_bIsButtonCaptured = FALSE;
		m_bIsButtonHighlighted = FALSE;

		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);

		if (m_rectBtn.PtInRect(point))
		{
			OnBrowse();
		}

		return;
	}

	CEdit::OnLButtonUp(nFlags, point);
}

void CMFCEditBrowseCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bIsButtonCaptured)
	{
		BOOL bIsButtonPressed = m_rectBtn.PtInRect(point);
		if (bIsButtonPressed != m_bIsButtonPressed)
		{
			m_bIsButtonPressed = bIsButtonPressed;
			RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
		}

		return;
	}

	if (m_bIsButtonHighlighted)
	{
		if (!m_rectBtn.PtInRect(point))
		{
			m_bIsButtonHighlighted = FALSE;
			ReleaseCapture();

			RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
		}
	}

	CEdit::OnMouseMove(nFlags, point);
}

void CMFCEditBrowseCtrl::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	CEdit::OnNcCalcSize(bCalcValidRects, lpncsp);

	if (m_Mode != BrowseMode_None)
	{
		lpncsp->rgrc [0].right -= m_nBrowseButtonWidth;
	}
}

void CMFCEditBrowseCtrl::OnNcPaint()
{
	CEdit::OnNcPaint();

	if (m_Mode == BrowseMode_None)
	{
		return;
	}

	CWindowDC dc(this);

	CRect rectWindow;
	GetWindowRect(rectWindow);

	m_rectBtn = rectWindow;
	m_rectBtn.left = m_rectBtn.right -  m_nBrowseButtonWidth;

	CRect rectClient;
	GetClientRect(rectClient);
	ClientToScreen(&rectClient);

	m_rectBtn.OffsetRect(rectClient.right + m_nBrowseButtonWidth - rectWindow.right, 0);
	m_rectBtn.top += rectClient.top - rectWindow.top;
	m_rectBtn.bottom -= rectWindow.bottom - rectClient.bottom;

	CRect rect = m_rectBtn;
	rect.OffsetRect(-rectWindow.left, -rectWindow.top);

	CRgn rgnClip;
	rgnClip.CreateRectRgnIndirect(&rect);

	dc.SelectClipRgn(&rgnClip);

	OnDrawBrowseButton(&dc, rect, m_bIsButtonPressed, m_bIsButtonHighlighted);

	dc.SelectClipRgn(NULL);

	ScreenToClient(&m_rectBtn);
}

LRESULT CMFCEditBrowseCtrl::OnNcHitTest(CPoint point)
{
	CPoint ptClient = point;
	ScreenToClient(&ptClient);

	if (m_Mode != BrowseMode_None && m_rectBtn.PtInRect(ptClient))
	{
		return HTCAPTION;
	}

	return CEdit::OnNcHitTest(point);
}

void CMFCEditBrowseCtrl::OnDrawBrowseButton(CDC* pDC, CRect rect, BOOL bIsButtonPressed, BOOL bHighlight)
{
	ASSERT(m_Mode != BrowseMode_None);
	ASSERT_VALID(pDC);

	CMFCVisualManager::AFX_BUTTON_STATE state = CMFCVisualManager::ButtonsIsRegular;

	if (bIsButtonPressed)
	{
		state = CMFCVisualManager::ButtonsIsPressed;
	}
	else if (bHighlight)
	{
		state = CMFCVisualManager::ButtonsIsHighlighted;
	}

	COLORREF clrText = afxGlobalData.clrBtnText;

	if (!CMFCVisualManager::GetInstance()->OnDrawBrowseButton(pDC, rect, this, state, clrText))
	{
		return;
	}

	int iImage = 0;

	if (m_ImageBrowse.GetSafeHandle() != NULL)
	{
		if (m_bDefaultImage)
		{
			switch (m_Mode)
			{
			case BrowseMode_Folder:
				iImage = 0;
				break;

			case BrowseMode_File:
				iImage = 1;
				break;
			}
		}

		CPoint ptImage;
		ptImage.x = rect.CenterPoint().x - m_sizeImage.cx / 2;
		ptImage.y = rect.CenterPoint().y - m_sizeImage.cy / 2;

		if (bIsButtonPressed && CMFCVisualManager::GetInstance()->IsOffsetPressedButton())
		{
			ptImage.x++;
			ptImage.y++;
		}

		m_ImageBrowse.Draw(pDC, iImage, ptImage, ILD_NORMAL);
	}
	else if (!m_strLabel.IsEmpty())
	{
		COLORREF clrTextOld = pDC->SetTextColor(clrText);
		int nTextMode = pDC->SetBkMode(TRANSPARENT);
		CFont* pFont = (CFont*) pDC->SelectStockObject(DEFAULT_GUI_FONT);

		CRect rectText = rect;
		rectText.DeflateRect(1, 2);
		rectText.OffsetRect(0, -2);

		if (bIsButtonPressed)
		{
			rectText.OffsetRect(1, 1);
		}

		pDC->DrawText(m_strLabel, rectText, DT_SINGLELINE | DT_CENTER | DT_VCENTER);

		pDC->SetTextColor(clrTextOld);
		pDC->SetBkMode(nTextMode);
		pDC->SelectObject(pFont);
	}
}

void CMFCEditBrowseCtrl::EnableBrowseButton(BOOL bEnable/* = TRUE*/, LPCTSTR szLabel/* = _T("...")*/)
{
	ASSERT_VALID(this);
	ENSURE(GetSafeHwnd() != NULL);
	ENSURE(szLabel != NULL);

	m_Mode = bEnable ? BrowseMode_Default : BrowseMode_None;
	m_strLabel = szLabel;

	m_ImageBrowse.DeleteImageList();
	m_sizeImage = CSize(0, 0);

	OnChangeLayout();
}

void CMFCEditBrowseCtrl::OnChangeLayout()
{
	ASSERT_VALID(this);
	ENSURE(GetSafeHwnd() != NULL);

	m_nBrowseButtonWidth = max(20, m_sizeImage.cx + 8);

	SetWindowPos(NULL, 0, 0, 0, 0, SWP_FRAMECHANGED | SWP_NOSIZE | SWP_NOZORDER | SWP_NOMOVE);

	if (m_Mode != BrowseMode_None)
	{
		GetWindowRect(m_rectBtn);
		m_rectBtn.left = m_rectBtn.right -  m_nBrowseButtonWidth;

		ScreenToClient(&m_rectBtn);
	}
	else
	{
		m_rectBtn.SetRectEmpty();
	}
}

void CMFCEditBrowseCtrl::OnNcLButtonDblClk(UINT /*nHitTest*/, CPoint /*point*/)
{
}

void CMFCEditBrowseCtrl::OnBrowse()
{
	ASSERT_VALID(this);
	ENSURE(GetSafeHwnd() != NULL);

	switch (m_Mode)
	{
	case BrowseMode_Folder:
		if (afxShellManager != NULL)
		{
			CString strFolder;
			GetWindowText(strFolder);

			CString strResult;
			if (afxShellManager->BrowseForFolder(strResult, this, strFolder) &&
				(strResult != strFolder))
			{
				SetWindowText(strResult);
				SetModify(TRUE);
				OnAfterUpdate();
			}
		}
		else
		{
			ASSERT(FALSE);
		}
		break;

	case BrowseMode_File:
		{
			CString strFile;
			GetWindowText(strFile);

			if (!strFile.IsEmpty())
			{
				TCHAR fname [_MAX_FNAME];

				_tsplitpath_s(strFile, NULL, 0, NULL, 0, fname, _MAX_FNAME, NULL, 0);

				CString strFileName = fname;
				strFileName.TrimLeft();
				strFileName.TrimRight();

				if (strFileName.IsEmpty())
				{
					strFile.Empty();
				}

				const CString strInvalidChars = _T("*?<>|");
				if (strFile.FindOneOf(strInvalidChars) >= 0)
				{
					if (!OnIllegalFileName(strFile))
					{
						SetFocus();
						return;
					}
				}
			}

			CFileDialog dlg(TRUE, !m_strDefFileExt.IsEmpty() ? (LPCTSTR)m_strDefFileExt : (LPCTSTR)NULL, strFile, 0, !m_strFileFilter.IsEmpty() ? (LPCTSTR)m_strFileFilter : (LPCTSTR)NULL, NULL);
			if (dlg.DoModal() == IDOK && strFile != dlg.GetPathName())
			{
				SetWindowText(dlg.GetPathName());
				SetModify(TRUE);
				OnAfterUpdate();
			}

			if (GetParent() != NULL)
			{
				GetParent()->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);
			}
		}
		break;
	}

	SetFocus();
}

BOOL CMFCEditBrowseCtrl::OnIllegalFileName(CString& strFileName)
{
	CString strError;
	strError.LoadString(AFX_IDP_INVALID_FILENAME);

	CString strMessage;
	strMessage.Format(_T("%s\r\n%s"), strFileName, strError);

	MessageBox(strMessage, NULL, MB_OK | MB_ICONEXCLAMATION);
	return FALSE;
}

void CMFCEditBrowseCtrl::SetBrowseButtonImage(HICON hIcon, BOOL bAutoDestroy)
{
	if (m_ImageBrowse.GetSafeHandle() != NULL)
	{
		m_ImageBrowse.DeleteImageList();
	}

	if (hIcon == NULL)
	{
		m_sizeImage = CSize(0, 0);
		return;
	}

	ICONINFO info;
	::GetIconInfo(hIcon, &info);

	BITMAP bmp;
	::GetObject(info.hbmColor, sizeof(BITMAP), (LPVOID) &bmp);

	m_sizeImage.cx = bmp.bmWidth;
	m_sizeImage.cy = bmp.bmHeight;

	::DeleteObject(info.hbmColor);
	::DeleteObject(info.hbmMask);

	UINT nFlags = ILC_MASK;

	switch (bmp.bmBitsPixel)
	{
	case 4:
	default:
		nFlags |= ILC_COLOR4;
		break;

	case 8:
		nFlags |= ILC_COLOR8;
		break;

	case 16:
		nFlags |= ILC_COLOR16;
		break;

	case 24:
		nFlags |= ILC_COLOR24;
		break;

	case 32:
		nFlags |= ILC_COLOR32;
		break;
	}

	m_ImageBrowse.Create(bmp.bmWidth, bmp.bmHeight, nFlags, 0, 0);
	m_ImageBrowse.Add(hIcon);

	m_bDefaultImage = FALSE;

	if (bAutoDestroy)
	{
		::DestroyIcon(hIcon);
	}
}

void CMFCEditBrowseCtrl::SetBrowseButtonImage(HBITMAP hBitmap, BOOL bAutoDestroy)
{
	if (m_ImageBrowse.GetSafeHandle() != NULL)
	{
		m_ImageBrowse.DeleteImageList();
	}

	if (hBitmap == NULL)
	{
		m_sizeImage = CSize(0, 0);
		return;
	}

	BITMAP bmp;
	::GetObject(hBitmap, sizeof(BITMAP), (LPVOID) &bmp);

	m_sizeImage.cx = bmp.bmWidth;
	m_sizeImage.cy = bmp.bmHeight;

	UINT nFlags = ILC_MASK;

	switch (bmp.bmBitsPixel)
	{
	case 4:
	default:
		nFlags |= ILC_COLOR4;
		break;

	case 8:
		nFlags |= ILC_COLOR8;
		break;

	case 16:
		nFlags |= ILC_COLOR16;
		break;

	case 24:
		nFlags |= ILC_COLOR24;
		break;

	case 32:
		nFlags |= ILC_COLOR32;
		break;
	}

	m_ImageBrowse.Create(bmp.bmWidth, bmp.bmHeight, nFlags, 0, 0);

	HBITMAP hbmpCopy = (HBITMAP) ::CopyImage(hBitmap, IMAGE_BITMAP, 0, 0, 0);
	m_ImageBrowse.Add(CBitmap::FromHandle(hbmpCopy), RGB(192, 192, 192));

	::DeleteObject(hbmpCopy);

	m_bDefaultImage = FALSE;

	if (bAutoDestroy)
	{
		::DeleteObject(hBitmap);
	}
}

void CMFCEditBrowseCtrl::SetBrowseButtonImage(UINT uiBmpResId)
{
	if (m_ImageBrowse.GetSafeHandle() != NULL)
	{
		m_ImageBrowse.DeleteImageList();
	}

	if (uiBmpResId == 0)
	{
		m_sizeImage = CSize(0, 0);
		return;
	}

	CMFCToolBarImages images;
	if (!images.Load(uiBmpResId))
	{
		ASSERT(FALSE);
		return;
	}

	SetBrowseButtonImage((HBITMAP) ::CopyImage(images.GetImageWell(), IMAGE_BITMAP, 0, 0, 0), TRUE /* bAutoDestroy */);
	m_bDefaultImage = FALSE;
}

void CMFCEditBrowseCtrl::EnableFileBrowseButton(LPCTSTR lpszDefExt/* = NULL*/, LPCTSTR lpszFilter/* = NULL*/)
{
	ASSERT_VALID(this);
	ENSURE(GetSafeHwnd() != NULL);

	m_Mode = BrowseMode_File;

	m_strDefFileExt = lpszDefExt == NULL ? _T("") : lpszDefExt;
	m_strFileFilter = lpszFilter == NULL ? _T("") : lpszFilter;

	SetInternalImage();
	OnChangeLayout();
}

void CMFCEditBrowseCtrl::EnableFolderBrowseButton()
{
	ASSERT_VALID(this);
	ENSURE(GetSafeHwnd() != NULL);
	ENSURE(afxShellManager != NULL); // You need to call CWinAppEx::InitShellManager() first!

	m_Mode = BrowseMode_Folder;
	SetInternalImage();
	OnChangeLayout();
}

void CMFCEditBrowseCtrl::SetInternalImage()
{
	if (m_ImageBrowse.GetSafeHandle() != NULL)
	{
		m_ImageBrowse.DeleteImageList();
	}

	UINT uiImageListResID = afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_BROWSE32 : IDB_AFXBARRES_BROWSE;

	LPCTSTR lpszResourceName = MAKEINTRESOURCE(uiImageListResID);
	ENSURE(lpszResourceName != NULL);

	HBITMAP hbmp = (HBITMAP) ::LoadImage(
		AfxFindResourceHandle(lpszResourceName, RT_BITMAP), lpszResourceName, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

	if (hbmp == NULL)
	{
		TRACE(_T("Can't load bitmap: %x\n"), uiImageListResID);
		return;
	}

	BITMAP bmpObj;
	::GetObject(hbmp, sizeof(BITMAP), &bmpObj);

	UINT nFlags = ILC_MASK;

	switch (bmpObj.bmBitsPixel)
	{
	case 4:
	default:
		nFlags |= ILC_COLOR4;
		break;

	case 8:
		nFlags |= ILC_COLOR8;
		break;

	case 16:
		nFlags |= ILC_COLOR16;
		break;

	case 24:
		nFlags |= ILC_COLOR24;
		break;

	case 32:
		nFlags |= ILC_COLOR32;
		break;
	}

	m_ImageBrowse.Create(16, 16, nFlags, 0, 0);
	m_ImageBrowse.Add(CBitmap::FromHandle(hbmp), RGB(255, 0, 255));

	m_sizeImage = CSize(16, 16);
	m_bDefaultImage = TRUE;
}

void CMFCEditBrowseCtrl::OnAfterUpdate()
{
	if (GetOwner() == NULL)
	{
		return;
	}

	GetOwner()->PostMessage(EN_CHANGE, GetDlgCtrlID(), (LPARAM) GetSafeHwnd());
	GetOwner()->PostMessage(EN_UPDATE, GetDlgCtrlID(), (LPARAM) GetSafeHwnd());
}

void CMFCEditBrowseCtrl::OnNcMouseMove(UINT nHitTest, CPoint point)
{
	if (!m_bIsButtonCaptured)
	{
		CPoint ptClient = point;
		ScreenToClient(&ptClient);

		if (m_rectBtn.PtInRect(ptClient))
		{
			SetCapture();
			m_bIsButtonHighlighted = TRUE;

			RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
		}
	}

	CEdit::OnNcMouseMove(nHitTest, point);
}

void CMFCEditBrowseCtrl::OnCancelMode()
{
	CEdit::OnCancelMode();

	if (IsWindowEnabled())
	{
		ReleaseCapture();
	}

	m_bIsButtonPressed = FALSE;
	m_bIsButtonCaptured = FALSE;
	m_bIsButtonHighlighted = FALSE;

	RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
}

void CMFCEditBrowseCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (m_Mode != BrowseMode_None && m_rectBtn.PtInRect(point))
	{
		SetFocus();

		m_bIsButtonPressed = TRUE;
		m_bIsButtonCaptured = TRUE;

		SetCapture();

		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);
		return;
	}

	CEdit::OnLButtonDown(nFlags, point);
}

void CMFCEditBrowseCtrl::OnRButtonDown(UINT nFlags, CPoint point)
{
	if (m_Mode != BrowseMode_None && m_rectBtn.PtInRect(point))
	{
		return;
	}

	CEdit::OnRButtonDown(nFlags, point);
}

void CMFCEditBrowseCtrl::OnRButtonUp(UINT nFlags, CPoint point)
{
	if (m_Mode != BrowseMode_None && m_rectBtn.PtInRect(point))
	{
		return;
	}

	CEdit::OnRButtonUp(nFlags, point);
}

BOOL CMFCEditBrowseCtrl::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
	case WM_SYSKEYDOWN:
		if (m_Mode != BrowseMode_None && (pMsg->wParam == VK_DOWN || pMsg->wParam == VK_RIGHT))
		{
			OnBrowse();
			return TRUE;
		}
		break;
	}

	return CEdit::PreTranslateMessage(pMsg);
}

LRESULT CMFCEditBrowseCtrl::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	CString strBrowseMode;
	if (tagManager.ExcludeTag(PS_MFCEditBrowse_BrowseMode, strBrowseMode))
	{
		if (!strBrowseMode.IsEmpty())
		{
			int nBrowseMode = _ttoi((LPCTSTR)strBrowseMode);
			switch (nBrowseMode)
			{
			case MFC_EB_MODE_NONE:
				EnableBrowseButton(FALSE);
				break;
			case MFC_EB_MODE_FILE:
				EnableFileBrowseButton();
				break;
			case MFC_EB_MODE_FOLDER:
				EnableFolderBrowseButton();
				break;
			case MFC_EB_MODE_CUSTOM:
				EnableBrowseButton();
				break;
			}
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxdropdownlistbox.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxdropdownlistbox.h"
#include "afxtoolbarmenubutton.h"
#include "afxdialogex.h"
#include "afxpropertypage.h"
#include "afxribboncombobox.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

const UINT idStart = (UINT) -200;

/////////////////////////////////////////////////////////////////////////////
// CMFCDropDownListBox

IMPLEMENT_DYNAMIC(CMFCDropDownListBox, CMFCPopupMenu)

CMFCDropDownListBox::CMFCDropDownListBox()
{
	CommonInit();
}

CMFCDropDownListBox::CMFCDropDownListBox(CWnd* pEditCtrl)
{
	ASSERT_VALID(pEditCtrl);

	CommonInit();
	m_pEditCtrl = pEditCtrl;
}

CMFCDropDownListBox::CMFCDropDownListBox(CMFCRibbonComboBox* pRibbonCombo)
{
	ASSERT_VALID(pRibbonCombo);

	CommonInit();

	m_pRibbonCombo = pRibbonCombo;
	m_pEditCtrl = pRibbonCombo->m_pWndEdit;
}

void CMFCDropDownListBox::CommonInit()
{
	m_pEditCtrl = NULL;
	m_pRibbonCombo = NULL;

	m_bShowScrollBar = TRUE;
	m_nMaxHeight = -1;

	m_Menu.CreatePopupMenu();
	m_nCurSel = -1;

	m_nMinWidth = -1;
	m_bDisableAnimation = TRUE;

	SetAutoDestroy(FALSE);
}

CMFCDropDownListBox::~CMFCDropDownListBox()
{
}

BEGIN_MESSAGE_MAP(CMFCDropDownListBox, CMFCPopupMenu)
	//{{AFX_MSG_MAP(CMFCDropDownListBox)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CMFCDropDownListBox::Track(CPoint point, CWnd *pWndOwner)
{
	if (!Create(pWndOwner, point.x, point.y, m_Menu, FALSE, TRUE))
	{
		return;
	}

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	pMenuBar->m_iMinWidth = m_nMinWidth;
	pMenuBar->m_bDisableSideBarInXPMode = TRUE;

	HighlightItem(m_nCurSel);

	CRect rect;
	GetWindowRect(&rect);
	UpdateShadow(&rect);

	CDialogEx* pParentDlg = NULL;
	if (pWndOwner != NULL && pWndOwner->GetParent() != NULL)
	{
		pParentDlg = DYNAMIC_DOWNCAST(CDialogEx, pWndOwner->GetParent());
		if (pParentDlg != NULL)
		{
			pParentDlg->SetActiveMenu(this);
		}
	}

	CMFCPropertyPage* pParentPropPage = NULL;
	if (pWndOwner != NULL && pWndOwner->GetParent() != NULL)
	{
		pParentPropPage = DYNAMIC_DOWNCAST(CMFCPropertyPage, pWndOwner->GetParent());
		if (pParentPropPage != NULL)
		{
			pParentPropPage->SetActiveMenu(this);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMFCDropDownListBox message handlers

int CMFCDropDownListBox::GetCount() const
{
	ASSERT_VALID(this);
	return m_Menu.GetMenuItemCount();
}

int CMFCDropDownListBox::GetCurSel()
{
	ASSERT_VALID(this);

	if (GetSafeHwnd() == NULL)
	{
		return m_nCurSel;
	}

	CMFCPopupMenuBar* pMenuBar = ((CMFCDropDownListBox*) this)->GetMenuBar();
	ASSERT_VALID(pMenuBar);

	CMFCToolBarButton* pSel = pMenuBar->GetHighlightedButton();
	if (pSel == NULL)
	{
		return -1;
	}

	int nIndex = 0;

	for (int i = 0; i < pMenuBar->GetCount(); i++)
	{
		CMFCToolBarButton* pItem = pMenuBar->GetButton(i);
		ASSERT_VALID(pItem);

		if (!(pItem->m_nStyle & TBBS_SEPARATOR))
		{
			if (pSel == pItem)
			{
				m_nCurSel = nIndex;
				return nIndex;
			}

			nIndex++;
		}
	}

	return -1;
}

int CMFCDropDownListBox::SetCurSel(int nSelect)
{
	ASSERT_VALID(this);

	const int nSelOld = GetCurSel();

	if (GetSafeHwnd() == NULL)
	{
		m_nCurSel = nSelect;
		return nSelOld;
	}

	CMFCPopupMenuBar* pMenuBar = ((CMFCDropDownListBox*) this)->GetMenuBar();
	ASSERT_VALID(pMenuBar);

	int nIndex = 0;

	for (int i = 0; i < pMenuBar->GetCount(); i++)
	{
		CMFCToolBarButton* pItem = pMenuBar->GetButton(i);
		ASSERT_VALID(pItem);

		if (!(pItem->m_nStyle & TBBS_SEPARATOR))
		{
			if (nIndex == nSelect)
			{
				HighlightItem(i);
				return nSelOld;
			}

			nIndex++;
		}
	}

	return -1;
}

void CMFCDropDownListBox::GetText(int nIndex, CString& rString) const
{
	ASSERT_VALID(this);

	CMFCToolBarButton* pItem = GetItem(nIndex);
	if (pItem == NULL)
	{
		return;
	}

	ASSERT_VALID(pItem);
	rString = pItem->m_strText;
}

void CMFCDropDownListBox::AddString(LPCTSTR lpszItem)
{
	ASSERT_VALID(this);
	ENSURE(lpszItem != NULL);
	ENSURE(GetSafeHwnd() == NULL);

	const UINT uiID = idStart - GetCount();
	m_Menu.AppendMenu(MF_STRING, uiID, lpszItem);
}

void CMFCDropDownListBox::ResetContent()
{
	ASSERT_VALID(this);
	ENSURE(GetSafeHwnd() == NULL);

	m_Menu.DestroyMenu();
	m_Menu.CreatePopupMenu();
}

void CMFCDropDownListBox::HighlightItem(int nIndex)
{
	ASSERT_VALID(this);

	CMFCPopupMenuBar* pMenuBar = GetMenuBar();
	ASSERT_VALID(pMenuBar);

	if (nIndex < 0)
	{
		return;
	}

	pMenuBar->m_iHighlighted = nIndex;

	SCROLLINFO scrollInfo;
	ZeroMemory(&scrollInfo, sizeof(SCROLLINFO));

	scrollInfo.cbSize = sizeof(SCROLLINFO);
	scrollInfo.fMask = SIF_ALL;

	m_wndScrollBarVert.GetScrollInfo(&scrollInfo);

	int iOffset = nIndex;
	int nMaxOffset = scrollInfo.nMax;

	iOffset = min(max(0, iOffset), nMaxOffset);

	if (iOffset != pMenuBar->GetOffset())
	{
		pMenuBar->SetOffset(iOffset);

		m_wndScrollBarVert.SetScrollPos(iOffset);
		AdjustScroll();

	}
}

CMFCToolBarButton* CMFCDropDownListBox::GetItem(int nIndex) const
{
	ASSERT_VALID(this);

	CMFCPopupMenuBar* pMenuBar = ((CMFCDropDownListBox*) this)->GetMenuBar();
	ASSERT_VALID(pMenuBar);

	int nCurrIndex = 0;

	for (int i = 0; i < pMenuBar->GetCount(); i++)
	{
		CMFCToolBarButton* pItem = pMenuBar->GetButton(i);
		ASSERT_VALID(pItem);

		if (!(pItem->m_nStyle & TBBS_SEPARATOR))
		{
			if (nIndex == nCurrIndex)
			{
				return pItem;
			}
		}
	}

	return NULL;
}

void CMFCDropDownListBox::OnDrawItem(CDC* pDC, CMFCToolBarMenuButton* pItem, BOOL bHighlight)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);
	ASSERT_VALID(pItem);

	CRect rectText = pItem->Rect();
	rectText.DeflateRect(2 * AFX_TEXT_MARGIN, 0);

	if (m_pRibbonCombo != NULL)
	{
		ASSERT_VALID(m_pRibbonCombo);

		int nIndex = (int) idStart - pItem->m_nID;

		if (m_pRibbonCombo->OnDrawDropListItem(pDC, nIndex, pItem, bHighlight))
		{
			return;
		}
	}

	pDC->DrawText(pItem->m_strText, &rectText, DT_SINGLELINE | DT_VCENTER);
}

CSize CMFCDropDownListBox::OnGetItemSize(CDC* pDC, CMFCToolBarMenuButton* pItem, CSize sizeDefault)
{
	ASSERT_VALID(this);

	if (m_pRibbonCombo != NULL)
	{
		ASSERT_VALID(m_pRibbonCombo);

		int nIndex = (int) idStart - pItem->m_nID;

		CSize size = m_pRibbonCombo->OnGetDropListItemSize(pDC, nIndex, pItem, sizeDefault);

		if (size != CSize(0, 0))
		{
			return size;
		}
	}

	return sizeDefault;
}

void CMFCDropDownListBox::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	ASSERT_VALID(this);

	if (m_pEditCtrl->GetSafeHwnd() != NULL)
	{
		switch (nChar)
		{
		case VK_UP:
		case VK_DOWN:
		case VK_PRIOR:
		case VK_NEXT:
		case VK_ESCAPE:
		case VK_RETURN:
			break;

		default:
			m_pEditCtrl->SendMessage(WM_KEYDOWN, nChar, MAKELPARAM(nRepCnt, nFlags));
			return;
		}
	}

	CMFCPopupMenu::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CMFCDropDownListBox::OnChooseItem(UINT uiCommandID)
{
	ASSERT_VALID(this);

	CMFCPopupMenu::OnChooseItem(uiCommandID);

	int nIndex = (int) idStart - uiCommandID;

	if (m_pRibbonCombo != NULL)
	{
		ASSERT_VALID(m_pRibbonCombo);
		m_pRibbonCombo->OnSelectItem(nIndex);
	}
}

void CMFCDropDownListBox::OnChangeHot(int nHot)
{
	ASSERT_VALID(this);

	CMFCPopupMenu::OnChangeHot(nHot);

	if (m_pRibbonCombo != NULL)
	{
		ASSERT_VALID(m_pRibbonCombo);
		m_pRibbonCombo->NotifyHighlightListItem(nHot);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxfontcombobox.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxfontcombobox.h"
#include "afxtoolbar.h"
#include "afxtoolbarfontcombobox.h"
#include "afxribbonres.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

const int nImageHeight = 16;
const int nImageWidth = 16;

BOOL CMFCFontComboBox::m_bDrawUsingFont = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CMFCFontComboBox

CMFCFontComboBox::CMFCFontComboBox() : m_bToolBarMode(FALSE)
{
}

CMFCFontComboBox::~CMFCFontComboBox()
{
}

BEGIN_MESSAGE_MAP(CMFCFontComboBox, CComboBox)
	//{{AFX_MSG_MAP(CMFCFontComboBox)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCFontComboBox::OnInitControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCFontComboBox message handlers

BOOL CMFCFontComboBox::PreTranslateMessage(MSG* pMsg)
{
	if (m_bToolBarMode && pMsg->message == WM_KEYDOWN && !CMFCToolBarFontComboBox::IsFlatMode())
	{
		CMFCToolBar* pBar = (CMFCToolBar*) GetParent();

		switch (pMsg->wParam)
		{
		case VK_ESCAPE:
			if (AFXGetTopLevelFrame(this) != NULL)
			{
				AFXGetTopLevelFrame(this)->SetFocus();
			}
			return TRUE;

		case VK_TAB:
			if (pBar != NULL)
			{
				pBar->GetNextDlgTabItem(this)->SetFocus();
			}
			return TRUE;

		case VK_UP:
		case VK_DOWN:
			if ((GetKeyState(VK_MENU) >= 0) &&(GetKeyState(VK_CONTROL) >=0) && !GetDroppedState())
			{
				ShowDropDown();
				return TRUE;
			}
		}
	}

	return CComboBox::PreTranslateMessage(pMsg);
}

int CMFCFontComboBox::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
	ASSERT(lpCIS->CtlType == ODT_COMBOBOX);

	int id1 = (int)(WORD)lpCIS->itemID1;
	if (id1 == -1)
	{
		return -1;
	}

	CString str1;
	GetLBText(id1, str1);

	int id2 = (int)(WORD)lpCIS->itemID2;
	if (id2 == -1)
	{
		return 1;
	}

	CString str2;
	GetLBText(id2, str2);

	return str1.Collate(str2);
}

void CMFCFontComboBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	if (m_Images.GetSafeHandle() == NULL)
	{
		m_Images.Create(IDB_AFXBARRES_FONT, nImageWidth, 0, RGB(255, 255, 255));
	}

	ASSERT(lpDIS->CtlType == ODT_COMBOBOX);

	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	ASSERT_VALID(pDC);

	CRect rc = lpDIS->rcItem;

	if (lpDIS->itemState & ODS_FOCUS)
	{
		pDC->DrawFocusRect(rc);
	}

	int nIndexDC = pDC->SaveDC();

	CBrush brushFill;
	if (lpDIS->itemState & ODS_SELECTED)
	{
		brushFill.CreateSolidBrush(afxGlobalData.clrHilite);
		pDC->SetTextColor(afxGlobalData.clrTextHilite);
	}
	else
	{
		brushFill.CreateSolidBrush(pDC->GetBkColor());
	}

	pDC->SetBkMode(TRANSPARENT);
	pDC->FillRect(rc, &brushFill);

	int id = (int)lpDIS->itemID;
	if (id >= 0)
	{
		CFont fontSelected;
		CFont* pOldFont = NULL;

		CMFCFontInfo* pDesc = (CMFCFontInfo*)lpDIS->itemData;
		if (pDesc != NULL)
		{
			if (pDesc->m_nType &(DEVICE_FONTTYPE | TRUETYPE_FONTTYPE))
			{
				CPoint ptImage(rc.left, rc.top +(rc.Height() - nImageHeight) / 2);
				m_Images.Draw(pDC, (pDesc->m_nType & DEVICE_FONTTYPE) ? 0 : 1, ptImage, ILD_NORMAL);
			}

			rc.left += nImageWidth + 6;

			if (m_bDrawUsingFont && pDesc->m_nCharSet != SYMBOL_CHARSET)
			{
				LOGFONT lf;
				afxGlobalData.fontRegular.GetLogFont(&lf);

				lstrcpy(lf.lfFaceName, pDesc->m_strName);

				if (pDesc->m_nCharSet != DEFAULT_CHARSET)
				{
					lf.lfCharSet = pDesc->m_nCharSet;
				}

				if (lf.lfHeight < 0)
				{
					lf.lfHeight -= 4;
				}
				else
				{
					lf.lfHeight += 4;
				}

				fontSelected.CreateFontIndirect(&lf);
				pOldFont = pDC->SelectObject(&fontSelected);
			}
		}

		CString strText;
		GetLBText(id, strText);

		pDC->DrawText(strText, rc, DT_SINGLELINE | DT_VCENTER);

		if (pOldFont != NULL)
		{
			pDC->SelectObject(pOldFont);
		}
	}

	pDC->RestoreDC(nIndexDC);
}

void CMFCFontComboBox::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	ASSERT(lpMIS->CtlType == ODT_COMBOBOX);

	CRect rc;
	GetWindowRect(&rc);
	lpMIS->itemWidth = rc.Width();

	int nFontHeight = max(afxGlobalData.GetTextHeight(), CMFCToolBarFontComboBox::m_nFontHeight);
	lpMIS->itemHeight = max(nImageHeight, nFontHeight);
}

void CMFCFontComboBox::PreSubclassWindow()
{
	CComboBox::PreSubclassWindow();

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	if (pThreadState->m_pWndInit == NULL)
	{
		Init();
	}
}

int CMFCFontComboBox::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CComboBox::OnCreate(lpCreateStruct) == -1)
		return -1;

	Init();
	return 0;
}

void CMFCFontComboBox::Init()
{
	CWnd* pWndParent = GetParent();
	ASSERT_VALID(pWndParent);

	m_bToolBarMode = pWndParent->IsKindOf(RUNTIME_CLASS(CMFCToolBar));
	if (!m_bToolBarMode)
	{
		Setup();
	}
}

void CMFCFontComboBox::CleanUp()
{
	ASSERT_VALID(this);
	ENSURE(::IsWindow(m_hWnd));

	if (m_bToolBarMode)
	{
		// Font data will be destroyed by CMFCToolBarFontComboBox object
		return;
	}

	for (int i = 0; i < GetCount(); i++)
	{
		delete(CMFCFontInfo*) GetItemData(i);
	}

	ResetContent();
}

BOOL CMFCFontComboBox::Setup(int nFontType, BYTE nCharSet, BYTE nPitchAndFamily)
{
	ASSERT_VALID(this);
	ENSURE(::IsWindow(m_hWnd));

	if (m_bToolBarMode)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CleanUp();

	CMFCToolBarFontComboBox combo(0, (UINT)-1, nFontType, nCharSet, CBS_DROPDOWN, 0, nPitchAndFamily);

	for (int i = 0; i < combo.GetCount(); i++)
	{
		CString strFont = combo.GetItem(i);

		CMFCFontInfo* pFontDescrSrc = (CMFCFontInfo*) combo.GetItemData(i);
		ASSERT_VALID(pFontDescrSrc);

		if (FindStringExact(-1, strFont) <= 0)
		{
			CMFCFontInfo* pFontDescr = new CMFCFontInfo(*pFontDescrSrc);
			int iIndex = AddString(strFont);
			SetItemData(iIndex, (DWORD_PTR) pFontDescr);
		}
	}

	return TRUE;
}

void CMFCFontComboBox::OnDestroy()
{
	CleanUp();
	CComboBox::OnDestroy();
}

BOOL CMFCFontComboBox::SelectFont(CMFCFontInfo* pDesc)
{
	ASSERT_VALID(this);
	ENSURE(::IsWindow(m_hWnd));
	ASSERT_VALID(pDesc);

	for (int i = 0; i < GetCount(); i++)
	{
		CMFCFontInfo* pFontDescr = (CMFCFontInfo*) GetItemData(i);
		ASSERT_VALID(pFontDescr);

		if (*pDesc == *pFontDescr)
		{
			SetCurSel(i);
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCFontComboBox::SelectFont(LPCTSTR lpszName, BYTE nCharSet/* = DEFAULT_CHARSET*/)
{
	ASSERT_VALID(this);
	ENSURE(::IsWindow(m_hWnd));
	ENSURE(lpszName != NULL);

	for (int i = 0; i < GetCount(); i++)
	{
		CMFCFontInfo* pFontDescr = (CMFCFontInfo*) GetItemData(i);
		ASSERT_VALID(pFontDescr);

		if (pFontDescr->m_strName == lpszName)
		{
			if (nCharSet == DEFAULT_CHARSET || nCharSet == pFontDescr->m_nCharSet)
			{
				SetCurSel(i);
				return TRUE;
			}
		}
	}

	return FALSE;
}

CMFCFontInfo* CMFCFontComboBox::GetSelFont() const
{
	ASSERT_VALID(this);
	ENSURE(::IsWindow(m_hWnd));

	int iIndex = GetCurSel();
	if (iIndex < 0)
	{
		return NULL;
	}

	return(CMFCFontInfo*) GetItemData(iIndex);
}

LRESULT CMFCFontComboBox::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	BOOL bDrawUsingFont = TRUE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCComboBox_DrawUsingFont, bDrawUsingFont))
	{
		m_bDrawUsingFont = bDrawUsingFont;
	}

	BOOL bShowTrueTypeFonts = TRUE;
	CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCComboBox_ShowTrueTypeFonts, bShowTrueTypeFonts);

	BOOL bShowRasterTypeFonts = TRUE;
	CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCComboBox_ShowRasterTypeFonts, bShowRasterTypeFonts);

	BOOL bShowDeviceTypeFonts = TRUE;
	CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCComboBox_ShowDeviceTypeFonts, bShowDeviceTypeFonts);
	
	int nFontType = 0;
	if (bShowTrueTypeFonts)
	{
		nFontType |= TRUETYPE_FONTTYPE;
	}
	if (bShowRasterTypeFonts)
	{
		nFontType |= RASTER_FONTTYPE;
	}
	if (bShowDeviceTypeFonts)
	{
		nFontType |= DEVICE_FONTTYPE;
	}
	Setup(nFontType);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxframewndex.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxpriv.h"
#include "afxframewndex.h"
#include "afxmenubar.h"
#include "afxpopupmenu.h"
#include "afxpaneframewnd.h"
#include "afxusertoolsmanager.h"
#include "afxpreviewviewex.h"
#include "afxpanedivider.h"
#include "afxribbonbar.h"
#include "afxribbonstatusbar.h"
#include "afxvisualmanager.h"
#include "afxglobalutils.h"

#pragma comment(lib,"imm32") // ImmXxx

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#pragma comment(lib, "imm32.lib")

/////////////////////////////////////////////////////////////////////////////
// CFrameWndEx

IMPLEMENT_DYNCREATE(CFrameWndEx, CFrameWnd)

#pragma warning(disable : 4355)

CFrameWndEx::CFrameWndEx() :
	m_Impl(this), m_bContextHelp(FALSE), m_bWasMaximized(FALSE), m_bIsMinimized(FALSE), m_pPrintPreviewFrame(NULL)
{
}

#pragma warning(default : 4355)

CFrameWndEx::~CFrameWndEx()
{
}

//{{AFX_MSG_MAP(CFrameWndEx)
BEGIN_MESSAGE_MAP(CFrameWndEx, CFrameWnd)
	ON_WM_MENUCHAR()
	ON_WM_ACTIVATE()
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	ON_WM_SIZING()
	ON_WM_SIZE()
	ON_WM_GETMINMAXINFO()
	ON_WM_NCPAINT()
	ON_WM_NCACTIVATE()
	ON_WM_CREATE()
	ON_WM_NCMOUSEMOVE()
	ON_WM_NCHITTEST()
	ON_WM_NCCALCSIZE()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_WINDOWPOSCHANGED()
	ON_WM_ACTIVATEAPP()
	ON_WM_SYSCOLORCHANGE()
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &CFrameWndEx::OnIdleUpdateCmdUI)
	ON_MESSAGE(WM_SETTEXT, &CFrameWndEx::OnSetText)
	ON_MESSAGE(WM_DWMCOMPOSITIONCHANGED, &CFrameWndEx::OnDWMCompositionChanged)
	ON_UPDATE_COMMAND_UI(ID_VIEW_STATUS_BAR, &CFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_STATUS_BAR, &CFrameWndEx::OnPaneCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, &CFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, &CFrameWndEx::OnPaneCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_REBAR, &CFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_REBAR, &CFrameWndEx::OnPaneCheck)
	ON_REGISTERED_MESSAGE(AFX_WM_TOOLBARMENU, &CFrameWndEx::OnToolbarContextMenu)
	ON_REGISTERED_MESSAGE(AFX_WM_CHANGEVISUALMANAGER, &CFrameWndEx::OnChangeVisualManager)
	ON_REGISTERED_MESSAGE(AFX_WM_POSTSETPREVIEWFRAME, &CFrameWndEx::OnPostPreviewFrame)
	ON_REGISTERED_MESSAGE(AFX_WM_CREATETOOLBAR, &CFrameWndEx::OnToolbarCreateNew)
	ON_REGISTERED_MESSAGE(AFX_WM_DELETETOOLBAR, &CFrameWndEx::OnToolbarDelete)
	ON_MESSAGE(WM_POWERBROADCAST, &OnPowerBroadcast)
	ON_MESSAGE(WM_EXITSIZEMOVE, &CFrameWndEx::OnExitSizeMove)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CFrameWndEx message handlers

LRESULT CFrameWndEx::OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu)
{
	if (m_Impl.OnMenuChar(nChar))
	{
		return MAKELPARAM(MNC_EXECUTE, -1);
	}

	return CFrameWnd::OnMenuChar(nChar, nFlags, pMenu);
}

afx_msg LRESULT CFrameWndEx::OnSetMenu(WPARAM wp, LPARAM lp)
{
	OnSetMenu((HMENU) wp);
	return DefWindowProc(WM_MDISETMENU, NULL, lp);
}

BOOL CFrameWndEx::OnSetMenu(HMENU hmenu)
{
	if (m_Impl.m_pMenuBar != NULL)
	{
		m_Impl.m_pMenuBar->CreateFromMenu(hmenu == NULL ? m_Impl.m_hDefaultMenu : hmenu);
		return TRUE;
	}

	return FALSE;
}

BOOL CFrameWndEx::PreTranslateMessage(MSG* pMsg)
{
	BOOL bProcessAccel = TRUE;

	switch (pMsg->message)
	{
	case WM_SYSKEYDOWN:

		if (m_Impl.m_pRibbonBar != NULL && m_Impl.m_pRibbonBar->OnSysKeyDown(this, pMsg->wParam, pMsg->lParam))
		{
			return TRUE;
		}

	case WM_CONTEXTMENU:
		if (!afxGlobalData.m_bSysUnderlineKeyboardShortcuts && !afxGlobalData.m_bUnderlineKeyboardShortcuts)
		{
			afxGlobalData.m_bUnderlineKeyboardShortcuts = TRUE;
			CMFCToolBar::RedrawUnderlines ();
		}

		if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd) && pMsg->wParam == VK_MENU)
		{
			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);
			return TRUE;
		}
		else if (m_Impl.ProcessKeyboard((int) pMsg->wParam))
		{
			return TRUE;
		}
		break;

	case WM_SYSKEYUP:
		{
			if (m_Impl.m_pRibbonBar != NULL && m_Impl.m_pRibbonBar->OnSysKeyUp(this, pMsg->wParam, pMsg->lParam))
			{
				return TRUE;
			}

			BOOL  isCtrlPressed = (0x8000 & GetKeyState(VK_CONTROL)) != 0;
			BOOL  isShiftPressed = (0x8000 & GetKeyState(VK_SHIFT)) != 0;

			HIMC hContext = ImmGetContext(m_hWnd);
			BOOL bIMEActive = ((hContext != NULL) && ImmGetOpenStatus(hContext));
			if (hContext != NULL)
			{
				ImmReleaseContext(m_hWnd, hContext);
			}

			if (m_Impl.m_pMenuBar != NULL && (pMsg->wParam == VK_MENU || (pMsg->wParam == VK_F10 && !isCtrlPressed && !isShiftPressed && !bIMEActive)))
			{
				if (m_Impl.m_pMenuBar == GetFocus())
				{
					SetFocus();
				}
				else
				{
					if ((pMsg->lParam &(1 << 29)) == 0)
					{
						m_Impl.m_pMenuBar->SetFocus();
					}
				}
				return TRUE;
			}

			if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd))
			{
				return TRUE; // To prevent system menu opening
			}
		}
		break;

	case WM_KEYDOWN:
		// Pass keyboard action to the active menu:
		if (!CFrameImpl::IsHelpKey(pMsg) && m_Impl.ProcessKeyboard((int) pMsg->wParam, &bProcessAccel))
		{
			return TRUE;
		}

		if (pMsg->wParam == VK_ESCAPE)
		{
			if (IsFullScreen())
			{
				m_Impl.m_FullScreenMgr.RestoreState(this);
			}

			CSmartDockingManager* pSDManager = NULL;
			if ((pSDManager = m_dockManager.GetSmartDockingManagerPermanent()) != NULL && pSDManager->IsStarted())
			{
				pSDManager->CauseCancelMode();
			}

			CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, GetCapture());
			if (pSlider != NULL)
			{
				pSlider->SendMessage(WM_CANCELMODE);
				return TRUE;
			}
		}

		if (!bProcessAccel)
		{
			return FALSE;
		}
		break;

	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);

			if (pWnd != NULL && ::IsWindow(pMsg->hwnd))
			{
				pWnd->ClientToScreen(&pt);
			}

			if (m_Impl.ProcessMouseClick(pMsg->message, pt, pMsg->hwnd))
			{
				return TRUE;
			}

			if (!::IsWindow(pMsg->hwnd))
			{
				return TRUE;
			}
		}
		break;

	case WM_NCLBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONDOWN:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONDOWN:
	case WM_NCMBUTTONUP:
		if (m_Impl.ProcessMouseClick(pMsg->message, CPoint(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam)), pMsg->hwnd))
		{
			return TRUE;
		}
		break;

	case WM_MOUSEWHEEL:
		if (m_Impl.ProcessMouseWheel(pMsg->wParam, pMsg->lParam))
		{
			return TRUE;
		}
		break;

	case WM_MOUSEMOVE:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);

			if (pWnd != NULL)
			{
				pWnd->ClientToScreen(&pt);
			}

			if (m_Impl.ProcessMouseMove(pt))
			{
				return TRUE;
			}
		}
	}

	return CFrameWnd::PreTranslateMessage(pMsg);
}

BOOL CFrameWndEx::ShowPopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (!m_Impl.OnShowPopupMenu(pMenuPopup, this))
	{
		return FALSE;
	}

	if (pMenuPopup != NULL && pMenuPopup->m_bShown)
	{
		return TRUE;
	}

	return OnShowPopupMenu(pMenuPopup);
}

void CFrameWndEx::OnClosePopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (afxGlobalData.IsAccessibilitySupport() && pMenuPopup != NULL)
	{
		CMFCPopupMenu* pPopupParent = pMenuPopup->GetParentPopupMenu();
		CMFCToolBarMenuButton* pParentButton  = pMenuPopup->GetParentButton();

		if (pMenuPopup->IsEscClose() || pPopupParent != NULL || pParentButton == NULL)
		{
			::NotifyWinEvent(EVENT_SYSTEM_MENUPOPUPEND, pMenuPopup->GetSafeHwnd(), OBJID_WINDOW, CHILDID_SELF);
		}
		else
		{
			::NotifyWinEvent(EVENT_SYSTEM_MENUEND, pMenuPopup->GetSafeHwnd(), OBJID_WINDOW, CHILDID_SELF);
		}
	}

	if (CMFCPopupMenu::m_pActivePopupMenu == pMenuPopup)
	{
		CMFCPopupMenu::m_pActivePopupMenu = NULL;
	}

	m_dockManager.OnClosePopupMenu();
}

BOOL CFrameWndEx::OnDrawMenuImage(CDC* pDC, const CMFCToolBarMenuButton* pMenuButton, const CRect& rectImage)
{
	ASSERT_VALID(this);

	if (m_Impl.m_pRibbonBar != NULL)
	{
		ASSERT_VALID(m_Impl.m_pRibbonBar);
		return m_Impl.m_pRibbonBar->DrawMenuImage(pDC, pMenuButton, rectImage);
	}

	return FALSE;
}

BOOL CFrameWndEx::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (HIWORD(wParam) == 1)
	{
		UINT uiCmd = LOWORD(wParam);

		CMFCToolBar::AddCommandUsage(uiCmd);

		// Simmulate ESC keystroke...
		if (m_Impl.ProcessKeyboard(VK_ESCAPE))
		{
			return TRUE;
		}

		if (afxUserToolsManager != NULL && afxUserToolsManager->InvokeTool(uiCmd))
		{
			return TRUE;
		}
	}

	if (!CMFCToolBar::IsCustomizeMode())
	{
		return CFrameWnd::OnCommand(wParam, lParam);
	}

	return FALSE;
}

BOOL CFrameWndEx::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle, CWnd* pParentWnd, CCreateContext* pContext)
{
	m_Impl.m_nIDDefaultResource = nIDResource;
	m_Impl.LoadLargeIconsState();

	if (!CFrameWnd::LoadFrame(nIDResource, dwDefaultStyle, pParentWnd, pContext))
	{
		return FALSE;
	}

	m_Impl.OnLoadFrame();
	return TRUE;
}

void CFrameWndEx::OnClose()
{
	if (m_pPrintPreviewFrame != NULL)
	{
		m_pPrintPreviewFrame->SendMessage(WM_COMMAND, AFX_ID_PREVIEW_CLOSE);
		m_pPrintPreviewFrame = NULL;
		return;
	}

	// Deactivate OLE container first:
	COleClientItem* pActiveItem = GetInPlaceActiveItem();
	if (pActiveItem != NULL)
	{
		pActiveItem->Deactivate();
	}

	m_Impl.OnCloseFrame();
	CFrameWnd::OnClose();
}

BOOL CFrameWndEx::PreCreateWindow(CREATESTRUCT& cs)
{
	m_dockManager.Create(this);
	m_Impl.SetDockingManager(&m_dockManager);

	m_Impl.RestorePosition(cs);
	return CFrameWnd::PreCreateWindow(cs);
}

void CFrameWndEx::HtmlHelp(DWORD_PTR dwData, UINT nCmd)
{
	if (dwData > 0 || !m_bContextHelp)
	{
		CFrameWnd::HtmlHelp(dwData, nCmd);
	}
	else
	{
		OnContextHelp();
	}
}

void CFrameWndEx::WinHelp(DWORD dwData, UINT nCmd)
{
	if (dwData > 0 || !m_bContextHelp)
	{
		CFrameWnd::WinHelp(dwData, nCmd);
	}
	else
	{
		OnContextHelp();
	}
}

void CFrameWndEx::OnContextHelp()
{
	m_bContextHelp = TRUE;

	if (!m_bHelpMode && CanEnterHelpMode())
	{
		CMFCToolBar::SetHelpMode();
	}

	CFrameWnd::OnContextHelp();

	if (!m_bHelpMode)
	{
		CMFCToolBar::SetHelpMode(FALSE);
	}

	m_bContextHelp = FALSE;
}

LRESULT CFrameWndEx::OnToolbarCreateNew(WPARAM,LPARAM lp)
{
	ENSURE(lp != 0);
	return(LRESULT) m_Impl.CreateNewToolBar((LPCTSTR) lp);
}

LRESULT CFrameWndEx::OnToolbarDelete(WPARAM,LPARAM lp)
{
	ENSURE(lp != 0);

	CMFCToolBar* pToolbar = (CMFCToolBar*) lp;
	ASSERT_VALID(pToolbar);

	return(LRESULT) m_Impl.DeleteToolBar(pToolbar);
}

BOOL CFrameWndEx::DockPaneLeftOf(CPane* pBar, CPane* pLeftOf)
{
	return m_dockManager.DockPaneLeftOf(pBar, pLeftOf);
}

void CFrameWndEx::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	CFrameWnd::OnActivate(nState, pWndOther, bMinimized);

	switch (nState)
	{
	case WA_CLICKACTIVE:
		UpdateWindow();
		break;

	case WA_INACTIVE:
		if (!CMFCToolBar::IsCustomizeMode())
		{
			m_Impl.DeactivateMenu();
		}
		break;
	}
}

void CFrameWndEx::OnActivateApp(BOOL bActive, DWORD /*dwThreadID*/)
{
	m_dockManager.OnActivateFrame(bActive);
	m_Impl.OnActivateApp(bActive);
}

void CFrameWndEx::DelayUpdateFrameMenu(HMENU hMenuAlt)
{
	OnUpdateFrameMenu(hMenuAlt);
	CFrameWnd::DelayUpdateFrameMenu(hMenuAlt);
}

COleClientItem* CFrameWndEx::GetInPlaceActiveItem()
{
	CFrameWnd* pActiveFrame = GetActiveFrame();
	if (pActiveFrame == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pActiveFrame);

	CView* pView = pActiveFrame->GetActiveView();
	if (pView == NULL || pView->IsKindOf(RUNTIME_CLASS(CPreviewViewEx)))
	{
		return NULL;
	}

	ASSERT_VALID(pView);

	COleDocument* pDoc = DYNAMIC_DOWNCAST(COleDocument, pView->GetDocument());
	if (pDoc == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pDoc);
	return pDoc->GetInPlaceActiveItem(pView);
}

void CFrameWndEx::OnUpdateFrameMenu(HMENU hMenuAlt)
{
	CFrameWnd::OnUpdateFrameMenu(hMenuAlt);

	BOOL bIsMenuBar = m_Impl.m_pMenuBar != NULL && (m_Impl.m_pMenuBar->GetStyle() & WS_VISIBLE);
	BOOL bIsRibbon = FALSE;

	if (m_Impl.m_pRibbonBar != NULL && (m_Impl.m_pRibbonBar->GetStyle() & WS_VISIBLE))
	{
		bIsRibbon = TRUE;
	}

	if (bIsMenuBar || bIsRibbon)
	{
		COleClientItem* pActiveItem = GetInPlaceActiveItem();
		if (pActiveItem == NULL || pActiveItem->GetInPlaceWindow() == NULL)
		{
			SetMenu(NULL);
		}
		else
		{
			SetMenu(CMenu::FromHandle(hMenuAlt));
		}
	}
}

void CFrameWndEx::OnDestroy()
{
	if (m_hAccelTable != NULL)
	{
		::DestroyAcceleratorTable(m_hAccelTable);
		m_hAccelTable = NULL;
	}

	m_dockManager.m_bEnableAdjustLayout = FALSE;

	CList<HWND, HWND> lstChildren;

	for (int i = 0; i < 2; i++)
	{
		CWnd* pNextWnd = GetTopWindow();
		while (pNextWnd != NULL)
		{
			const BOOL bIsPaneDivider = pNextWnd->IsKindOf(RUNTIME_CLASS(CPaneDivider));

			if ((i == 0 && !bIsPaneDivider) || (i == 1 && bIsPaneDivider))
			{
				lstChildren.AddTail(pNextWnd->m_hWnd);
			}

			pNextWnd = pNextWnd->GetNextWindow();
		}

		for (POSITION pos = lstChildren.GetHeadPosition(); pos != NULL;)
		{
			HWND hwndNext = lstChildren.GetNext(pos);
			if (IsWindow(hwndNext) && ::GetParent(hwndNext) == m_hWnd)
			{
				::DestroyWindow(hwndNext);
			}
		}
	}

	CFrameImpl::RemoveFrame(this);
	CFrameWnd::OnDestroy();
}

void CFrameWndEx::AddDockSite()
{
	ASSERT_VALID(this);
}

BOOL CFrameWndEx::AddPane(CBasePane* pControlBar, BOOL bTail)
{
	ASSERT_VALID(this);

	CMFCRibbonBar* pRibbonBar = DYNAMIC_DOWNCAST(CMFCRibbonBar, pControlBar);
	if (pRibbonBar != NULL)
	{
		ASSERT_VALID(pRibbonBar);

		if (pRibbonBar->IsMainRibbonBar())
		{
			m_Impl.m_pRibbonBar = pRibbonBar;
		}
	}

	CMFCRibbonStatusBar* pRibbonStatusBar = DYNAMIC_DOWNCAST(CMFCRibbonStatusBar, pControlBar);
	if (pRibbonStatusBar != NULL)
	{
		ASSERT_VALID(pRibbonStatusBar);
		m_Impl.m_pRibbonStatusBar = pRibbonStatusBar;
	}

	return m_dockManager.AddPane(pControlBar, bTail);
}

BOOL CFrameWndEx::InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter)
{
	ASSERT_VALID(this);
	return m_dockManager.InsertPane(pControlBar, pTarget, bAfter);
}

void CFrameWndEx::RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement)
{
	ASSERT_VALID(this);
	m_dockManager.RemovePaneFromDockManager(pControlBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
}

void CFrameWndEx::DockPane(CBasePane* pBar, UINT nDockBarID, LPCRECT lpRect)
{
	ASSERT_VALID(this);
	m_dockManager.DockPane(pBar, nDockBarID, lpRect);
}

CBasePane* CFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
}

CBasePane* CFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, dwAlignment, pRTCBarType);
}

BOOL CFrameWndEx::IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const
{
	ASSERT_VALID(this);
	return m_dockManager.IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
}

void CFrameWndEx::AdjustDockingLayout(HDWP hdwp)
{
	ASSERT_VALID(this);

	if (m_dockManager.IsInAdjustLayout())
	{
		return;
	}

	m_dockManager.AdjustDockingLayout(hdwp);

	AdjustClientArea();
	if (m_dockManager.IsOLEContainerMode())
	{
		RecalcLayout();
	}
}

void CFrameWndEx::AdjustClientArea()
{
	CWnd* pChildWnd = GetDlgItem(AFX_IDW_PANE_FIRST);
	if (pChildWnd != NULL)
	{
		CRect rectClientAreaBounds = m_dockManager.GetClientAreaBounds();

		rectClientAreaBounds.left += m_rectBorder.left;
		rectClientAreaBounds.top  += m_rectBorder.top;
		rectClientAreaBounds.right -= m_rectBorder.right;
		rectClientAreaBounds.bottom -= m_rectBorder.bottom;

		pChildWnd->CalcWindowRect(rectClientAreaBounds);

		if (!pChildWnd->IsKindOf(RUNTIME_CLASS(CSplitterWnd)) && !pChildWnd->IsKindOf(RUNTIME_CLASS(CFormView)))
		{
			pChildWnd->ModifyStyle(0, WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
		}
		else
		{
			pChildWnd->ModifyStyle(0, WS_CLIPSIBLINGS);
		}

		pChildWnd->SetWindowPos(&wndBottom, rectClientAreaBounds.left, rectClientAreaBounds.top, rectClientAreaBounds.Width(), rectClientAreaBounds.Height(), SWP_NOACTIVATE);
	}
}

BOOL CFrameWndEx::OnMoveMiniFrame(CWnd* pFrame)
{
	ASSERT_VALID(this);
	return m_dockManager.OnMoveMiniFrame(pFrame);
}

BOOL CFrameWndEx::EnableDocking(DWORD dwDockStyle)
{
	return m_dockManager.EnableDocking(dwDockStyle);
}

BOOL CFrameWndEx::EnableAutoHidePanes(DWORD dwDockStyle)
{
	return m_dockManager.EnableAutoHidePanes(dwDockStyle);
}

CBasePane* CFrameWndEx::GetPane(UINT nID)
{
	ASSERT_VALID(this);

	CBasePane* pBar = m_dockManager.FindPaneByID(nID, TRUE);
	return pBar;
}

void CFrameWndEx::ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	pBar->ShowPane(bShow, bDelay, bActivate);
}

void CFrameWndEx::OnUpdatePaneMenu(CCmdUI* pCmdUI)
{
	CBasePane* pBar = GetPane(pCmdUI->m_nID);
	if (pBar != NULL)
	{
		pCmdUI->SetCheck((pBar->GetStyle() & WS_VISIBLE) != 0);
		return;
	}

	pCmdUI->ContinueRouting();
}

BOOL CFrameWndEx::OnPaneCheck(UINT nID)
{
	ASSERT_VALID(this);

	CBasePane* pBar = GetPane(nID);
	if (pBar != NULL)
	{
		ShowPane(pBar, (pBar->GetStyle() & WS_VISIBLE) == 0, FALSE, FALSE);
		return TRUE;
	}

	return FALSE;
}

void CFrameWndEx::OnSizing(UINT fwSide, LPRECT pRect)
{
	CFrameWnd::OnSizing(fwSide, pRect);

	AdjustDockingLayout();
}

void CFrameWndEx::RecalcLayout(BOOL bNotify)
{
	if (m_bInRecalcLayout)
		return;

	m_bInRecalcLayout = TRUE;

	BOOL bWasOleInPlaceActive = m_Impl.m_bIsOleInPlaceActive;
	m_Impl.m_bIsOleInPlaceActive = FALSE;

	COleClientItem* pActiveItem = GetInPlaceActiveItem();

	if (pActiveItem != NULL && pActiveItem->m_pInPlaceFrame != NULL && pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		m_Impl.m_bIsOleInPlaceActive = TRUE;
		m_Impl.m_bHadCaption = (GetStyle() & WS_CAPTION) != 0;
	}

	if (!m_bIsMinimized)
	{
		CView* pView = GetActiveView();

		if (m_dockManager.IsPrintPreviewValid() || m_pNotifyHook != NULL)
		{
			if (pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPreviewViewEx)))
			{
				m_dockManager.RecalcLayout(bNotify);
				CRect rectClient = m_dockManager.GetClientAreaBounds();
				pView->SetWindowPos(NULL, rectClient.left, rectClient.top, rectClient.Width(), rectClient.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);
			}
			else
			{
				if (bNotify && m_pNotifyHook != NULL)
				{
					ActiveItemRecalcLayout();
				}
				else
				{
					m_bInRecalcLayout = FALSE;
					CFrameWnd::RecalcLayout(bNotify);

					AdjustClientArea();
				}
			}
		}
		else
		{
			m_dockManager.RecalcLayout(bNotify);
			AdjustClientArea();
		}
	}

	m_bInRecalcLayout = FALSE;

	if (bWasOleInPlaceActive != m_Impl.m_bIsOleInPlaceActive)
	{
		if (!m_Impl.m_bHadCaption)
		{
			if (m_Impl.m_bIsOleInPlaceActive)
			{
				ModifyStyle(0, WS_CAPTION);
			}
			else
			{
				ModifyStyle(WS_CAPTION, 0);
			}
		}

		m_Impl.OnChangeVisualManager();
		SetWindowPos(NULL, -1, -1, -1, -1, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
	}
}

void CFrameWndEx::ActiveItemRecalcLayout()
{
	COleClientItem* pActiveItem = GetInPlaceActiveItem();

	if (pActiveItem != NULL && pActiveItem->m_pInPlaceFrame != NULL)
	{
		CRect rectBounds = m_dockManager.GetClientAreaBounds();
		pActiveItem->m_pInPlaceFrame->OnRecalcLayout();
	}

	AdjustClientArea();
}

BOOL CFrameWndEx::NegotiateBorderSpace( UINT nBorderCmd, LPRECT lpRectBorder )
{
	CRect border, request;

	switch (nBorderCmd)
	{
	case borderGet:
		{
			CFrameWnd::NegotiateBorderSpace(nBorderCmd, lpRectBorder);
			CRect rectBounds = m_dockManager.GetClientAreaBounds();
			ENSURE(lpRectBorder != NULL);

			*lpRectBorder = rectBounds;
			break;
		}
	case borderRequest:
		return TRUE;

	case borderSet:
		return CFrameWnd::NegotiateBorderSpace(nBorderCmd, lpRectBorder);

	default:
		ASSERT(FALSE);  // invalid CFrameWnd::BorderCmd
	}

	return TRUE;
}

void CFrameWndEx::OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState)
{
	ASSERT_VALID(this);

	CFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CFrameWndEx, AFXGetTopLevelFrame(this));
	if (pMainFrame != NULL)
	{
		pMainFrame->SetPrintPreviewFrame(bPreview ? this : NULL);
	}

	m_dockManager.SetPrintPreviewMode(bPreview, pState);
	DWORD dwSavedState = pState->dwStates;
	CFrameWnd::OnSetPreviewMode(bPreview, pState);
	pState->dwStates = dwSavedState;

	AdjustDockingLayout();
	RecalcLayout();

	if (m_Impl.m_pRibbonBar != NULL && m_Impl.m_pRibbonBar->IsReplaceFrameCaption())
	{
		PostMessage(AFX_WM_POSTSETPREVIEWFRAME, bPreview);
	}
}

BOOL CFrameWndEx::OnShowPanes(BOOL bShow)
{
	ASSERT_VALID(this);
	BOOL bResult = m_dockManager.ShowPanes(bShow);
	AdjustDockingLayout();

	return bResult;
}

LRESULT CFrameWndEx::OnIdleUpdateCmdUI(WPARAM, LPARAM)
{
	m_dockManager.SendMessageToMiniFrames(WM_IDLEUPDATECMDUI);
	return 0L;
}

void CFrameWndEx::OnSize(UINT nType, int cx, int cy)
{
	m_bIsMinimized = (nType == SIZE_MINIMIZED);

	if (m_Impl.m_pRibbonBar || m_Impl.IsOwnerDrawCaption())
	{
		CRect rectWindow;
		GetWindowRect(rectWindow);

		WINDOWPOS wndpos;
		wndpos.flags = SWP_FRAMECHANGED;
		wndpos.x     = rectWindow.left;
		wndpos.y     = rectWindow.top;
		wndpos.cx    = rectWindow.Width();
		wndpos.cy    = rectWindow.Height();

		m_Impl.OnWindowPosChanging(&wndpos);
	}

	m_Impl.UpdateCaption();
	m_dockManager.OnActivateFrame(!m_bIsMinimized);

	if (!m_bIsMinimized && nType != SIZE_MAXIMIZED && !m_bWasMaximized)
	{
		m_dockManager.m_bSizeFrame = TRUE;
		CFrameWnd::OnSize(nType, cx, cy);
		AdjustDockingLayout();
		m_dockManager.m_bSizeFrame = FALSE;
		return;
	}

	CFrameWnd::OnSize(nType, cx, cy);

	if (nType == SIZE_MAXIMIZED ||(nType == SIZE_RESTORED && m_bWasMaximized))
	{
		RecalcLayout();
	}

	m_bWasMaximized = (nType == SIZE_MAXIMIZED);
}

LRESULT CFrameWndEx::OnExitSizeMove(WPARAM, LPARAM)
{
	RecalcLayout ();
	m_dockManager.FixupVirtualRects();
	return 0;
}

void CFrameWndEx::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
	if (IsFullScreen())
	{
		m_Impl.m_FullScreenMgr.OnGetMinMaxInfo(lpMMI);
	}
	else
	{
		m_Impl.OnGetMinMaxInfo(lpMMI);
		CFrameWnd::OnGetMinMaxInfo(lpMMI);
	}
}

BOOL CFrameWndEx::OnShowPopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (afxGlobalData.IsAccessibilitySupport() && pMenuPopup != NULL)
	{
		::NotifyWinEvent(EVENT_SYSTEM_MENUPOPUPSTART, pMenuPopup->GetSafeHwnd(), OBJID_WINDOW , CHILDID_SELF);
	}

	return TRUE;
}

LRESULT CFrameWndEx::OnToolbarContextMenu(WPARAM,LPARAM)
{
	return 1l;
}

BOOL CFrameWndEx::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
	{
		return TRUE;
	}

	return m_dockManager.ProcessPaneContextMenuCommand(nID, nCode, pExtra, pHandlerInfo);
}

void CFrameWndEx::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)
{
	if ((lpwndpos->flags & SWP_FRAMECHANGED) == SWP_FRAMECHANGED)
	{
		m_Impl.OnWindowPosChanging(lpwndpos);
	}

	CFrameWnd::OnWindowPosChanged(lpwndpos);
}

void CFrameWndEx::OnNcPaint()
{
	if (!m_Impl.OnNcPaint())
	{
		Default();
	}
}

LRESULT CFrameWndEx::OnSetText(WPARAM, LPARAM lParam)
{
	LRESULT lRes = Default();

	m_Impl.OnSetText((LPCTSTR)lParam);
	return lRes;
}

BOOL CFrameWndEx::OnNcActivate(BOOL bActive)
{
	if (m_Impl.OnNcActivate(bActive))
	{
		return TRUE;
	}

	return CFrameWnd::OnNcActivate(bActive);
}

int CFrameWndEx::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_Impl.m_bHasBorder = (lpCreateStruct->style & WS_BORDER) != NULL;

	CFrameImpl::AddFrame(this);
	OnChangeVisualManager(0, 0);
	return 0;
}

LRESULT CFrameWndEx::OnChangeVisualManager(WPARAM, LPARAM)
{
	m_Impl.OnChangeVisualManager();
	return 0;
}

void CFrameWndEx::OnNcMouseMove(UINT nHitTest, CPoint point)
{
	m_Impl.OnNcMouseMove(nHitTest, point);

	if (nHitTest == HTCAPTION &&(GetStyle() & WS_MAXIMIZE) == WS_MAXIMIZE)
	{
		BOOL bIsRibbonCaption = FALSE;

		if (m_Impl.m_pRibbonBar != NULL && m_Impl.m_pRibbonBar->IsWindowVisible() && m_Impl.m_pRibbonBar->IsReplaceFrameCaption())
		{
			bIsRibbonCaption = TRUE;
		}
		if (!bIsRibbonCaption && CMFCVisualManager::GetInstance()->IsOwnerDrawCaption())
		{
			return;
		}
	}

	CFrameWnd::OnNcMouseMove(nHitTest, point);
}

LRESULT CFrameWndEx::OnNcHitTest(CPoint point)
{
	UINT nHit = m_Impl.OnNcHitTest(point);
	if (nHit != HTNOWHERE)
	{
		return nHit;
	}

	return CFrameWnd::OnNcHitTest(point);
}

void CFrameWndEx::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	if (!m_Impl.OnNcCalcSize(bCalcValidRects, lpncsp))
	{
		CFrameWnd::OnNcCalcSize(bCalcValidRects, lpncsp);
	}
}

void CFrameWndEx::OnLButtonUp(UINT nFlags, CPoint point)
{
	m_Impl.OnLButtonUp(point);
	CFrameWnd::OnLButtonUp(nFlags, point);
}

void CFrameWndEx::OnMouseMove(UINT nFlags, CPoint point)
{
	m_Impl.OnMouseMove(point);
	CFrameWnd::OnMouseMove(nFlags, point);
}

void CFrameWndEx::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_Impl.OnLButtonDown(point);
	CFrameWnd::OnLButtonDown(nFlags, point);
}

LRESULT CFrameWndEx::OnPostPreviewFrame(WPARAM, LPARAM)
{
	return 0;
}

LRESULT CFrameWndEx::OnDWMCompositionChanged(WPARAM,LPARAM)
{
	m_Impl.OnDWMCompositionChanged();
	return 0;
}

void CFrameWndEx::OnUpdateFrameTitle(BOOL bAddToTitle)
{
	BOOL bIsRibbonCaption = FALSE;

	if (m_Impl.m_pRibbonBar != NULL && (m_Impl.m_pRibbonBar->IsWindowVisible() || !IsWindowVisible()) && m_Impl.m_pRibbonBar->IsReplaceFrameCaption())
	{
		bIsRibbonCaption = TRUE;
	}

	if (!m_Impl.IsOwnerDrawCaption() || !IsWindowVisible() || bIsRibbonCaption)
	{
		CFrameWnd::OnUpdateFrameTitle(bAddToTitle);
		return;
	}

	CString strTitle1;
	GetWindowText(strTitle1);

	CFrameWnd::OnUpdateFrameTitle(bAddToTitle);

	CString strTitle2;
	GetWindowText(strTitle2);

	if (strTitle1 != strTitle2)
	{
		SendMessage(WM_NCPAINT, 0, 0);
	}
}

LRESULT CFrameWndEx::OnPowerBroadcast(WPARAM wp, LPARAM)
{
	LRESULT lres = Default();

	if (wp == PBT_APMRESUMESUSPEND)
	{
		afxGlobalData.Resume();
	}

	return lres;
}

void CFrameWndEx::OnSysColorChange()
{
	CFrameWnd::OnSysColorChange();
	m_Impl.OnChangeVisualManager();
	SetWindowRgn(NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxfullscreenimpl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxfullscreenimpl.h"
#include "afxmdiframewndex.h"
#include "afxmdichildwndex.h"
#include "afxframewndex.h"
#include "afxwinappex.h"
#include "afxtoolbar.h"
#include "afxpaneframewnd.h"
#include "afxdockablepane.h"
#include "afxdropdowntoolbar.h"
#include "afxbasetabbedpane.h"
#include "afxdocksite.h"
#include "afxribbonres.h"
#include "afxstatusbar.h"
#include "afxrebar.h"
#include "afxribbonbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

class CFullScreenToolbar : public CMFCToolBar
{
	virtual BOOL CanBeClosed() const
	{
		return FALSE;
	}
};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFullScreenImpl::CFullScreenImpl(CFrameImpl* pFrameImpl)
{
	m_pImpl = pFrameImpl;
	m_pwndFullScreenBar = NULL;
	m_bFullScreen = FALSE;
	m_bShowMenu = TRUE;
	m_bTabsArea = TRUE;
	m_uiFullScreenID = (UINT)-1;
	m_strRegSection = _T("");
}

CFullScreenImpl::~CFullScreenImpl()
{
}

void CFullScreenImpl::ShowFullScreen(CFrameWnd* pFrame)
{
	ASSERT(m_uiFullScreenID != -1);
	if (m_uiFullScreenID == -1)
	{
		return;
	}

	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp == NULL)
	{
		// Your application class should be derived from CWinAppEx
		ASSERT(FALSE);
		return;
	}

	CMDIFrameWndEx* pTabbedMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pFrame);
	if (pTabbedMDIFrame != NULL)
	{
		CMDIChildWndEx* pChildWnd = DYNAMIC_DOWNCAST(CMDIChildWndEx, pTabbedMDIFrame->MDIGetActive());
		if (pChildWnd != NULL)
		{
			CWnd* pViewWnd = pChildWnd->GetActiveView();
			if (pViewWnd == NULL && !pChildWnd->IsTabbedPane())
			{
				return;
			}
		}
	}
	else
	{
		CFrameWndEx* pFrameEx = DYNAMIC_DOWNCAST(CFrameWndEx, pFrame);
		if (pFrameEx == NULL)
		{
			return;
		}
	}

	CRect rectFrame, rectView, rectChild, rcScreen;

	pFrame->GetWindowRect(&rectFrame);
	m_rectFramePrev = rectFrame;

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);
	if (GetMonitorInfo(MonitorFromPoint(rectFrame.TopLeft(), MONITOR_DEFAULTTONEAREST), &mi))
	{
		rcScreen = mi.rcMonitor;

	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0);
	}

	m_strRegSection = pApp->GetRegistryBase();

	if (pTabbedMDIFrame != NULL)
	{
		pApp->SaveState(pTabbedMDIFrame, m_strRegSection);
		pApp->CleanState(_T("FullScreeenState"));
	}
	else
	{
		CFrameWndEx* pFrameEx = DYNAMIC_DOWNCAST(CFrameWndEx, pFrame);
		if (pFrameEx != NULL)
		{
			pApp->SaveState(pFrameEx, m_strRegSection);
			pApp->CleanState(_T("FullScreeenState"));
		}
		else
		{
			return;
		}
	}

	pFrame->SetRedraw(FALSE);
	UndockAndHidePanes(pFrame);

	CMDIChildWndEx* pChildWnd = NULL;
	if (pTabbedMDIFrame != NULL)
	{
		pChildWnd = DYNAMIC_DOWNCAST(CMDIChildWndEx, pTabbedMDIFrame->MDIGetActive());
	}

	if (pTabbedMDIFrame != NULL && pChildWnd != NULL)
	{
		CWnd* pViewWnd = NULL;
		if (pChildWnd->IsTabbedPane())
		{
			pViewWnd = pChildWnd->GetTabbedPane();
		}
		else
		{
			pViewWnd = pChildWnd->GetActiveView();
		}

		if (pViewWnd == NULL)
		{
			return;
		}

		pChildWnd->GetWindowRect(&rectView);
		pViewWnd->GetWindowRect(&rectChild);

		if (pTabbedMDIFrame->AreMDITabs())
		{
			if (m_bTabsArea)
			{
				CDockingManager* pDockMgr = m_pImpl->m_pDockManager;
				pDockMgr->AdjustDockingLayout();
				CRect rectClient;
				pTabbedMDIFrame->GetClientRect(&rectClient);
				pTabbedMDIFrame->ClientToScreen(&rectClient);

				rectFrame.InflateRect((rectClient.left - rcScreen.left), (rectClient.top - rcScreen.top) , (rcScreen.right - rectClient.right), rcScreen.bottom - rectClient.bottom);
			}
			else
			{
				rectFrame.InflateRect(rectChild.left - rcScreen.left, rectChild.top - rcScreen.top, rcScreen.right - rectChild.right, rcScreen.bottom - rectChild.bottom);
			}
		}
		else
		{
			rectFrame.InflateRect(rectChild.left - rcScreen.left,
				(rectChild.top - rcScreen.top) ,
				(rcScreen.right - rectChild.right), rcScreen.bottom - rectChild.bottom);
		}
	}
	else // Maybe SDI
	{
		CFrameWndEx* pFrameEx = DYNAMIC_DOWNCAST(CFrameWndEx, pFrame);

		if (pFrameEx != NULL)
		{
			CWnd* pViewWnd = pFrame->GetActiveView();
			if (pViewWnd == NULL)
			{
				CRect rectFrmClient;
				pFrameEx->GetClientRect(&rectFrmClient);
				pFrameEx->ClientToScreen(&rectFrmClient);

				rectFrame.InflateRect(rectFrmClient.left - rcScreen.left, rectFrmClient.top - rcScreen.top, rcScreen.right - rectFrmClient.right, rcScreen.bottom - rectFrmClient.bottom);
			}
			else
			{
				pViewWnd->GetWindowRect(&rectView);
				pFrameEx->GetWindowRect(&rectFrame);
				rectFrame.InflateRect(rectView.left - rcScreen.left, rectView.top - rcScreen.top, rcScreen.right - rectView.right, rcScreen.bottom - rectView.bottom);
			}
		}
	}

	if (pTabbedMDIFrame != NULL && pChildWnd == NULL)
	{
		CRect rectFrmClient;
		pTabbedMDIFrame->GetClientRect(&rectFrmClient);
		pTabbedMDIFrame->ClientToScreen(&rectFrmClient);

		rectFrame.InflateRect(rectFrmClient.left - rcScreen.left, rectFrmClient.top - rcScreen.top, rcScreen.right - rectFrmClient.right, rcScreen.bottom - rectFrmClient.bottom);
	}

	// Remember this for OnGetMinMaxInfo()
	m_rectFullScreenWindow = rectFrame;

	m_pwndFullScreenBar = new CFullScreenToolbar;

	if (!m_pwndFullScreenBar->Create(pFrame))
	{
		TRACE0("Failed to create toolbar\n");
		return;      // fail to create
	}

	CString strCaption;
	ENSURE(strCaption.LoadString(IDS_AFXBARRES_FULLSCREEN));

	CString strLabel;
	ENSURE(strLabel.LoadString(IDS_AFXBARRES_FULLSCREEN_CLOSE));

	CMFCToolBarButton button(m_uiFullScreenID, -1, strLabel, FALSE, TRUE);
	m_pwndFullScreenBar->InsertButton(button);
	m_pwndFullScreenBar->EnableDocking(0);
	m_pwndFullScreenBar->SetWindowPos(0, 100, 100, 100, 100, SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);
	m_pwndFullScreenBar->SetWindowText(strCaption);
	m_pwndFullScreenBar->FloatPane(CRect(100, 100, 200, 200));
	m_bFullScreen = true;

	pFrame->SetWindowPos(NULL, rectFrame.left, rectFrame.top, rectFrame.Width(), rectFrame.Height(), SWP_NOZORDER);

	if (m_bShowMenu)
	{
		if (pTabbedMDIFrame != NULL)
		{
			const CMFCMenuBar* pMenuBar = pTabbedMDIFrame->GetMenuBar();

			if (pMenuBar != NULL)
			{
				if (m_bTabsArea)
				{
					if (pMenuBar->CanFloat())
					{
						pTabbedMDIFrame->DockPane((CBasePane*)pMenuBar);
					}
					pTabbedMDIFrame->ShowPane((CBasePane*)pMenuBar, TRUE,FALSE, FALSE);
				}
				else
				{
					if (pMenuBar->CanFloat())
					{
						pTabbedMDIFrame->DockPane((CBasePane*)pMenuBar);
						((CBasePane*)pMenuBar)->FloatPane(CRect(300, 200, 500, 500));
					}
					pTabbedMDIFrame->ShowPane((CBasePane*)pMenuBar, TRUE,FALSE, FALSE);
				}
			}
		}
		else
		{
			CFrameWndEx* pFrameEx = DYNAMIC_DOWNCAST(CFrameWndEx, pFrame);
			if (pFrameEx != NULL)
			{
				const CMFCMenuBar* pMenuBar = pFrameEx->GetMenuBar();

				if (pMenuBar != NULL)
				{
					if (pMenuBar->CanFloat())
					{
						pFrameEx->DockPane((CBasePane*)pMenuBar);
					}
					pFrameEx->ShowPane((CBasePane*)pMenuBar, TRUE,FALSE, FALSE);
				}
			}
		}
	}

	pFrame->SetRedraw(TRUE);
	pFrame->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);

	if (pTabbedMDIFrame != NULL && pTabbedMDIFrame->IsMDITabbedGroup())
	{
		pTabbedMDIFrame->AdjustClientArea();
	}
}

void CFullScreenImpl::RestoreState(CFrameWnd* pFrame)
{
	ASSERT(m_uiFullScreenID != -1);
	if (m_uiFullScreenID == -1)
	{
		return;
	}

	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp == NULL)
	{
		// Your application class should be derived from CWinAppEx
		ASSERT(FALSE);
		return;
	}

	// Destroy the toolbar
	CWnd* pWnd = m_pwndFullScreenBar->GetParentMiniFrame();
	if (pWnd == NULL)
		pWnd = m_pwndFullScreenBar;
	VERIFY(pWnd->DestroyWindow());

	delete m_pwndFullScreenBar;

	m_pwndFullScreenBar = NULL;
	m_bFullScreen = false;

	CMDIFrameWndEx* pTabbedMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pFrame);

	//Restore window pos
	pFrame->SetWindowPos(NULL, m_rectFramePrev.left, m_rectFramePrev.top, m_rectFramePrev.Width(), m_rectFramePrev.Height(), SWP_NOZORDER);

	//restore layout
	pFrame->SetRedraw(FALSE);

	pApp->m_bLoadUserToolbars = FALSE;

	if (pTabbedMDIFrame != NULL)
	{
		pApp->LoadState(pTabbedMDIFrame, m_strRegSection);
	}
	else
	{
		CFrameWndEx* pFrameEx = DYNAMIC_DOWNCAST(CFrameWndEx, pFrame);
		if (pFrameEx != NULL)
		{
			pApp->LoadState(pFrameEx, m_strRegSection);
		}
	}

	pFrame->SetRedraw(TRUE);
	pFrame->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);

	if (!m_bShowMenu)
	{
		if (pTabbedMDIFrame != NULL)
		{
			const CMFCMenuBar* pMenuBar = pTabbedMDIFrame->GetMenuBar();

			if (pMenuBar != NULL)
			{
				pTabbedMDIFrame->ShowPane((CBasePane*)pMenuBar, TRUE,FALSE, FALSE);
				if (pMenuBar->IsFloating())
				{
					pTabbedMDIFrame->SetFocus();
				}
			}
		}
		else
		{
			CFrameWndEx* pFrameEx = DYNAMIC_DOWNCAST(CFrameWndEx, pFrame);
			if (pFrameEx != NULL)
			{
				const CMFCMenuBar* pMenuBar = pFrameEx->GetMenuBar();
				if (pMenuBar != NULL)
				{
					pFrameEx->ShowPane((CBasePane*)pMenuBar, TRUE,FALSE, FALSE);
					if (pMenuBar->IsFloating())
					{
						pFrameEx->SetFocus();
					}
				}
			}
		}
	}

	if (pTabbedMDIFrame != NULL && pTabbedMDIFrame->IsMDITabbedGroup())
	{
		pTabbedMDIFrame->AdjustClientArea();
	}

	if (m_pImpl != NULL && m_pImpl->m_pRibbonBar != NULL && m_pImpl->m_pRibbonBar->IsWindowVisible() && m_pImpl->m_pRibbonBar->IsReplaceFrameCaption())
	{
		m_pImpl->OnChangeVisualManager();
	}
}

void CFullScreenImpl::ShowFullScreen()
{
	if (!m_bFullScreen)
	{
		ShowFullScreen(m_pImpl->m_pFrame);
	}
	else
	{
		RestoreState(m_pImpl->m_pFrame);
	}
}

void CFullScreenImpl::UndockAndHidePanes(CFrameWnd* pFrame)
{
	CMDIFrameWndEx* pTabbedMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, pFrame);
	CFrameWndEx* pFrameEx = DYNAMIC_DOWNCAST(CFrameWndEx, pFrame);

	CDockingManager* pDockMgr = m_pImpl->m_pDockManager;

	if (pDockMgr == NULL)
	{
		return;
	}

	CObList list;
	pDockMgr->GetPaneList(list, TRUE);

	// UnDock and hide DockingControlBars

	POSITION pos;
	for (pos = list.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBarNext = (CBasePane*) list.GetNext(pos);

		if (!::IsWindow(pBarNext->m_hWnd))
		{
			continue;
		}

		CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, pBarNext);
		if (pBar != NULL)
		{
			if (pBar->IsAutoHideMode())
			{
				pBar->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
			}

			if (pBar->IsMDITabbed ())
			{
				continue;
			}

			if (pBar->IsTabbed())
			{
				CMFCBaseTabCtrl* pTabWnd = (CMFCBaseTabCtrl*) pBar->GetParent();
				CBaseTabbedPane* pTabBar = (CBaseTabbedPane*) pTabWnd->GetParent();
				pTabBar->DetachPane(pBar);
			}

			if (pBar->CanFloat())
			{
				pBar->FloatPane(CRect(300, 200, 500, 500));
			}

			if (pTabbedMDIFrame != NULL)
			{
				pTabbedMDIFrame->ShowPane(pBar, FALSE,FALSE, FALSE);

			}
			else if (pFrameEx != NULL)
			{
				pFrameEx->ShowPane(pBar, FALSE,FALSE, FALSE);
			}

		}
		else
		{
			CPane* pControlBar =  DYNAMIC_DOWNCAST(CPane, pBarNext);

			if (pControlBar != NULL)
			{
				if (pTabbedMDIFrame != NULL)
				{
					pTabbedMDIFrame->ShowPane(pControlBar, FALSE,FALSE, FALSE);
				}
				else if (pFrameEx != NULL)
				{
					pFrameEx->ShowPane(pControlBar, FALSE,FALSE, FALSE);
				}

				continue;
			}
		}
	}

	// UnDock and hide all Toolbars
	const CObList& afxAllToolBars = CMFCToolBar::GetAllToolbars();

	for (pos = afxAllToolBars.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(pos);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);

			// Don't touch dropdown toolbars!
			if (!pToolBar->IsKindOf(RUNTIME_CLASS(CMFCDropDownToolBar)))
			{
				if (pToolBar->IsKindOf(RUNTIME_CLASS(CMFCMenuBar)))
				{
					if (pToolBar->CanFloat())
					{
						pToolBar->FloatPane(CRect(0, -1024, 0, -1024));

						if (pTabbedMDIFrame != NULL)
						{
							pTabbedMDIFrame->ShowPane(pToolBar, FALSE,FALSE, FALSE);
						}
						else if (pFrameEx != NULL)
						{
							pFrameEx->ShowPane(pToolBar, FALSE,FALSE, FALSE);
						}
					}
					continue;
				}

				// Don't touch toolbars resids on the DockingControlBars

				CWnd* pWnd = pToolBar->GetParent();
				if (pWnd->IsKindOf(RUNTIME_CLASS(CDockSite)) || pWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
				{
					if (pTabbedMDIFrame != NULL)
					{
						if (pToolBar->CanFloat())
						{
							pToolBar->FloatPane(CRect(300, 200, 500, 500));
						}

						pTabbedMDIFrame->ShowPane(pToolBar, FALSE,FALSE, FALSE);
					}
					else if (pFrameEx != NULL)
					{

						if (pToolBar->CanFloat())
						{
							pToolBar->FloatPane(CRect(300, 200, 500, 500));
						}
						pFrameEx->ShowPane(pToolBar, FALSE,FALSE, FALSE);
					}
				}
			}
		}
	}
}

void CFullScreenImpl::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
	if (m_bFullScreen)
	{
		lpMMI->ptMaxSize.x = lpMMI->ptMaxTrackSize.x = m_rectFullScreenWindow.Width();
		lpMMI->ptMaxSize.y = lpMMI->ptMaxTrackSize.y = m_rectFullScreenWindow.Height();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxglobals.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "comdef.h"
#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxvisualmanager.h"
#include "afxkeyboardmanager.h"
#include "afxmenuhash.h"
#include "afxtoolbar.h"
#include "afxmenuimages.h"
#include "afxpaneframewnd.h"
#include "afxdockingmanager.h"
#include "afxvisualmanageroffice2007.h"
#include "afxribbonres.h"

#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxmdichildwndex.h"

extern CObList afxAllToolBars;

BOOL CMemDC::m_bUseMemoryDC = TRUE;

static const CString strOfficeFontName = _T("Tahoma");
static const CString strOffice2007FontName = _T("Segoe UI");
static const CString strDefaultFontName = _T("MS Sans Serif");
static const CString strVertFontName = _T("Arial");
static const CString strMarlettFontName = _T("Marlett");

CMemDC::CMemDC(CDC& dc, CWnd* pWnd) :
	m_dc(dc), m_bMemDC(FALSE), m_hBufferedPaint(NULL), m_pOldBmp(NULL)
{
	ASSERT_VALID(pWnd);

	pWnd->GetClientRect(m_rect);

	m_rect.right += pWnd->GetScrollPos(SB_HORZ);
	m_rect.bottom += pWnd->GetScrollPos(SB_VERT);

	if (afxGlobalData.m_pfBeginBufferedPaint != NULL && afxGlobalData.m_pfEndBufferedPaint != NULL)
	{
		HDC hdcPaint = NULL;

		if (!afxGlobalData.m_bBufferedPaintInited && afxGlobalData.m_pfBufferedPaintInit != NULL && afxGlobalData.m_pfBufferedPaintUnInit != NULL)
		{
			afxGlobalData.m_pfBufferedPaintInit();
			afxGlobalData.m_bBufferedPaintInited = TRUE;
		}

		m_hBufferedPaint = (*afxGlobalData.m_pfBeginBufferedPaint)(dc.GetSafeHdc(), m_rect, AFX_BPBF_TOPDOWNDIB, NULL, &hdcPaint);

		if (m_hBufferedPaint != NULL && hdcPaint != NULL)
		{
			m_bMemDC = TRUE;
			m_dcMem.Attach(hdcPaint);
		}
	}
	else
	{
		if (m_bUseMemoryDC && m_dcMem.CreateCompatibleDC(&m_dc) && m_bmp.CreateCompatibleBitmap(&m_dc, m_rect.Width(), m_rect.Height()))
		{
			//-------------------------------------------------------------
			// Off-screen DC successfully created. Better paint to it then!
			//-------------------------------------------------------------
			m_bMemDC = TRUE;
			m_pOldBmp = m_dcMem.SelectObject(&m_bmp);
		}
	}
}

CMemDC::CMemDC(CDC& dc, const CRect& rect) :
	m_dc(dc), m_bMemDC(FALSE), m_hBufferedPaint(NULL), m_pOldBmp(NULL), m_rect(rect)
{
	ASSERT(!m_rect.IsRectEmpty());

	if (afxGlobalData.m_pfBeginBufferedPaint != NULL && afxGlobalData.m_pfEndBufferedPaint != NULL)
	{
		HDC hdcPaint = NULL;

		if (!afxGlobalData.m_bBufferedPaintInited && afxGlobalData.m_pfBufferedPaintInit != NULL && afxGlobalData.m_pfBufferedPaintUnInit != NULL)
		{
			afxGlobalData.m_pfBufferedPaintInit();
			afxGlobalData.m_bBufferedPaintInited = TRUE;
		}

		m_hBufferedPaint = (*afxGlobalData.m_pfBeginBufferedPaint)(dc.GetSafeHdc(), m_rect, AFX_BPBF_TOPDOWNDIB, NULL, &hdcPaint);

		if (m_hBufferedPaint != NULL && hdcPaint != NULL)
		{
			m_bMemDC = TRUE;
			m_dcMem.Attach(hdcPaint);
		}
	}
	else
	{
		if (m_bUseMemoryDC && m_dcMem.CreateCompatibleDC(&m_dc) && m_bmp.CreateCompatibleBitmap(&m_dc, m_rect.Width(), m_rect.Height()))
		{
			//-------------------------------------------------------------
			// Off-screen DC successfully created. Better paint to it then!
			//-------------------------------------------------------------
			m_bMemDC = TRUE;
			m_pOldBmp = m_dcMem.SelectObject(&m_bmp);
		}
	}
}

CMemDC::~CMemDC()
{
	if (m_hBufferedPaint != NULL)
	{
		m_dcMem.Detach();
		(*afxGlobalData.m_pfEndBufferedPaint)(m_hBufferedPaint, TRUE);
	}
	else if (m_bMemDC)
	{
		//--------------------------------------
		// Copy the results to the on-screen DC:
		//--------------------------------------
		CRect rectClip;
		int nClipType = m_dc.GetClipBox(rectClip);

		if (nClipType != NULLREGION)
		{
			if (nClipType != SIMPLEREGION)
			{
				rectClip = m_rect;
			}

			m_dc.BitBlt(rectClip.left, rectClip.top, rectClip.Width(), rectClip.Height(), &m_dcMem, rectClip.left, rectClip.top, SRCCOPY);
		}

		m_dcMem.SelectObject(m_pOldBmp);
	}
}

static int CALLBACK FontFamalyProcFonts(const LOGFONT FAR* lplf, const TEXTMETRIC FAR* /*lptm*/, ULONG /*ulFontType*/, LPARAM lParam)
{
	ENSURE(lplf != NULL);
	ENSURE(lParam != NULL);

	CString strFont = lplf->lfFaceName;
	return strFont.CollateNoCase((LPCTSTR) lParam) == 0 ? 0 : 1;
}

/////////////////////////////////////////////////////////////////////////////
// Cached system metrics, etc
AFX_GLOBAL_DATA afxGlobalData;

// Initialization code
AFX_GLOBAL_DATA::AFX_GLOBAL_DATA()
{
	// Detect the kind of OS:
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	::GetVersionEx(&osvi);

	bIsRemoteSession = GetSystemMetrics(SM_REMOTESESSION);

	bIsWindowsVista = (osvi.dwMajorVersion >= 6);
	bIsWindows7 = (osvi.dwMajorVersion == 6) && (osvi.dwMinorVersion >= 1) || (osvi.dwMajorVersion > 6) ;
	bDisableAero = FALSE;

	m_bIsRibbonImageScale = TRUE;

	// Cached system values(updated in CWnd::OnSysColorChange)
	hbrBtnShadow = NULL;
	hbrBtnHilite = NULL;
	hbrWindow = NULL;

	UpdateSysColors();

	m_hinstUXThemeDLL = ::AfxCtxLoadLibraryW(L"UxTheme.dll");
	if (m_hinstUXThemeDLL != NULL)
	{
		m_pfDrawThemeBackground = (DRAWTHEMEPARENTBACKGROUND)::GetProcAddress(m_hinstUXThemeDLL, "DrawThemeParentBackground");
		m_pfDrawThemeTextEx = (DRAWTHEMETEXTEX)::GetProcAddress(m_hinstUXThemeDLL, "DrawThemeTextEx");

		m_pfBufferedPaintInit = (BUFFEREDPAINTINIT)::GetProcAddress(m_hinstUXThemeDLL, "BufferedPaintInit");
		m_pfBufferedPaintUnInit = (BUFFEREDPAINTUNINIT)::GetProcAddress(m_hinstUXThemeDLL, "BufferedPaintUnInit");

		m_pfBeginBufferedPaint = (BEGINBUFFEREDPAINT)::GetProcAddress(m_hinstUXThemeDLL, "BeginBufferedPaint");
		m_pfEndBufferedPaint = (ENDBUFFEREDPAINT)::GetProcAddress(m_hinstUXThemeDLL, "EndBufferedPaint");
	}
	else
	{
		m_pfDrawThemeBackground = NULL;
		m_pfDrawThemeTextEx = NULL;

		m_pfBufferedPaintInit = NULL;
		m_pfBufferedPaintUnInit = NULL;

		m_pfBeginBufferedPaint = NULL;
		m_pfEndBufferedPaint = NULL;
	}

	m_hinstDwmapiDLL = ::AfxCtxLoadLibraryW(L"dwmapi.dll");
	if (m_hinstDwmapiDLL != NULL)
	{
		m_pfDwmExtendFrameIntoClientArea = (DWMEXTENDFRAMEINTOCLIENTAREA)::GetProcAddress(m_hinstDwmapiDLL, "DwmExtendFrameIntoClientArea");
		m_pfDwmDefWindowProc = (DWMDEFWINDOWPROC) ::GetProcAddress(m_hinstDwmapiDLL, "DwmDefWindowProc");
		m_pfDwmIsCompositionEnabled = (DWMISCOMPOSITIONENABLED)::GetProcAddress(m_hinstDwmapiDLL, "DwmIsCompositionEnabled");
	}
	else
	{
		m_pfDwmExtendFrameIntoClientArea = NULL;
		m_pfDwmDefWindowProc = NULL;
		m_pfDwmIsCompositionEnabled = NULL;
	}

	m_hcurStretch = NULL;
	m_hcurStretchVert = NULL;
	m_hcurHand = NULL;
	m_hcurSizeAll = NULL;
	m_hiconTool = NULL;
	m_hiconLink = NULL;
	m_hiconColors = NULL;
	m_hcurMoveTab = NULL;
	m_hcurNoMoveTab = NULL;

	m_bUseSystemFont = FALSE;
	m_bInSettingChange = FALSE;

	UpdateFonts();
	OnSettingChange();

	m_bIsRTL = FALSE;
	m_bBufferedPaintInited = FALSE;

	m_nDragFrameThicknessFloat = 4;  // pixels
	m_nDragFrameThicknessDock = 3;   // pixels

	m_nAutoHideToolBarSpacing = 14; // pixels
	m_nAutoHideToolBarMargin  = 4;  // pixels

	m_nCoveredMainWndClientAreaPercent = 50; // percents

	m_nMaxToolTipWidth = -1;
	m_bIsBlackHighContrast = FALSE;
	m_bIsWhiteHighContrast = FALSE;

	m_bUseBuiltIn32BitIcons = TRUE;

	m_bComInitialized = FALSE;

	m_pTaskbarList = NULL;
	m_pTaskbarList3 = NULL;
	m_bTaskBarInterfacesAvailable = TRUE;

	EnableAccessibilitySupport();
}

AFX_GLOBAL_DATA::~AFX_GLOBAL_DATA()
{
	CleanUp();
}

void AFX_GLOBAL_DATA::UpdateFonts()
{
	CWindowDC dc(NULL);
	m_dblRibbonImageScale = dc.GetDeviceCaps(LOGPIXELSX) / 96.0f;

	if (m_dblRibbonImageScale > 1. && m_dblRibbonImageScale < 1.1)
	{
		m_dblRibbonImageScale = 1.;
	}

	if (fontRegular.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontRegular.Detach());
	}

	if (fontTooltip.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontTooltip.Detach());
	}

	if (fontBold.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontBold.Detach());
	}

	if (fontDefaultGUIBold.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontDefaultGUIBold.Detach());
	}

	if (fontUnderline.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontUnderline.Detach());
	}

	if (fontDefaultGUIUnderline.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontDefaultGUIUnderline.Detach());
	}

	if (fontVert.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontVert.Detach());
	}

	if (fontVertCaption.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontVertCaption.Detach());
	}

	if (fontMarlett.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontMarlett.Detach());
	}

	if (fontSmall.GetSafeHandle() != NULL)
	{
		::DeleteObject(fontSmall.Detach());
	}

	// Initialize fonts:

	NONCLIENTMETRICS info;
	GetNonClientMetrics (info);

	LOGFONT lf;
	memset(&lf, 0, sizeof(LOGFONT));

	lf.lfCharSet = (BYTE) GetTextCharsetInfo(dc.GetSafeHdc(), NULL, 0);

	lf.lfHeight = info.lfMenuFont.lfHeight;
	lf.lfWeight = info.lfMenuFont.lfWeight;
	lf.lfItalic = info.lfMenuFont.lfItalic;

	//------------------
	// Adjust font size:
	//------------------
	int nFontHeight = lf.lfHeight < 0 ? -lf.lfHeight : lf.lfHeight;
	if (nFontHeight <= 12)
	{
		nFontHeight = 11;
	}
	else
	{
		nFontHeight--;
	}

	lf.lfHeight = (lf.lfHeight < 0) ? -nFontHeight : nFontHeight;

	// Check if we should use system font
	lstrcpy(lf.lfFaceName, info.lfMenuFont.lfFaceName);

	BOOL fUseSystemFont = m_bUseSystemFont || (info.lfMenuFont.lfCharSet > SYMBOL_CHARSET);
	if (!fUseSystemFont)
	{
		// Check for "Segoe UI" or "Tahoma" font existance:
		if (::EnumFontFamilies(dc.GetSafeHdc(), NULL, FontFamalyProcFonts, (LPARAM)(LPCTSTR) strOffice2007FontName) == 0)
		{
			// Found! Use MS Office 2007 font!
			lstrcpy(lf.lfFaceName, strOffice2007FontName);
			lf.lfQuality = 5 /*CLEARTYPE_QUALITY*/;
		}
		else if (::EnumFontFamilies(dc.GetSafeHdc(), NULL, FontFamalyProcFonts, (LPARAM)(LPCTSTR) strOfficeFontName) == 0)
		{
			// Found! Use MS Office font!
			lstrcpy(lf.lfFaceName, strOfficeFontName);
		}
		else
		{
			// Not found. Use default font:
			lstrcpy(lf.lfFaceName, strDefaultFontName);
		}
	}
	
	fontRegular.CreateFontIndirect(&lf);

	// Create small font:
	LONG lfHeightSaved = lf.lfHeight;

	lf.lfHeight = (long)((1. + abs(lf.lfHeight)) * 2 / 3);
	if (lfHeightSaved < 0)
	{
		lf.lfHeight = -lf.lfHeight;
	}

	fontSmall.CreateFontIndirect(&lf);
	lf.lfHeight = lfHeightSaved;

	// Create tooltip font:
	NONCLIENTMETRICS ncm;
	GetNonClientMetrics (ncm);

	lf.lfItalic = ncm.lfStatusFont.lfItalic;
	lf.lfWeight = ncm.lfStatusFont.lfWeight;
	fontTooltip.CreateFontIndirect(&lf);

	lf.lfItalic = info.lfMenuFont.lfItalic;
	lf.lfWeight = info.lfMenuFont.lfWeight;

	// Create "underline" font:
	lf.lfUnderline = TRUE;
	fontUnderline.CreateFontIndirect(&lf);
	lf.lfUnderline = FALSE;

	// Create bold font:
	lf.lfWeight = FW_BOLD;
	fontBold.CreateFontIndirect(&lf);

	// Create Marlett font:
	BYTE bCharSet = lf.lfCharSet;
	lf.lfWeight = info.lfMenuFont.lfWeight;
	lf.lfCharSet = SYMBOL_CHARSET;
	lf.lfWeight = 0;
	lf.lfHeight = ::GetSystemMetrics(SM_CYMENUCHECK) - 1;
	lstrcpy(lf.lfFaceName, strMarlettFontName);

	fontMarlett.CreateFontIndirect(&lf);
	lf.lfCharSet = bCharSet; // Restore charset

	// Create vertical font:
	CFont font;
	if (font.CreateStockObject(DEFAULT_GUI_FONT))
	{
		if (font.GetLogFont(&lf) != 0)
		{
			lf.lfOrientation = 900;
			lf.lfEscapement = 2700;

			lf.lfHeight = info.lfMenuFont.lfHeight;
			lf.lfWeight = info.lfMenuFont.lfWeight;
			lf.lfItalic = info.lfMenuFont.lfItalic;

			{
				lstrcpy(lf.lfFaceName, strVertFontName);
			}

			fontVert.CreateFontIndirect(&lf);

			lf.lfEscapement = 900;
			fontVertCaption.CreateFontIndirect(&lf);
		}
	}

	// Create dialog underline and bold fonts:
	CFont* pDefaultGUIFont = CFont::FromHandle((HFONT) GetStockObject(DEFAULT_GUI_FONT));
	ASSERT_VALID(pDefaultGUIFont);
	pDefaultGUIFont->GetLogFont(&lf);

	lf.lfUnderline = TRUE;
	fontDefaultGUIUnderline.CreateFontIndirect(&lf);
	lf.lfUnderline = FALSE;

	lf.lfWeight = FW_BOLD;
	fontDefaultGUIBold.CreateFontIndirect(&lf);

	UpdateTextMetrics();

	// Notify toolbars about font changing:
	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);
			pToolBar->OnGlobalFontsChanged();
		}
	}
}

static BOOL CALLBACK InfoEnumProc( HMONITOR hMonitor, HDC /*hdcMonitor*/, LPRECT /*lprcMonitor*/, LPARAM dwData)
{
	CRect* pRect = (CRect*) dwData;

	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);

	if (GetMonitorInfo(hMonitor, &mi))
	{
		CRect rectMon = mi.rcWork;

		pRect->left = min(pRect->left, rectMon.left);
		pRect->right = max(pRect->right, rectMon.right);
		pRect->top = min(pRect->top, rectMon.top);
		pRect->bottom = max(pRect->bottom, rectMon.bottom);
	}

	return TRUE;
}

void AFX_GLOBAL_DATA::OnSettingChange()
{
	m_bInSettingChange = TRUE;

	m_sizeSmallIcon.cx = ::GetSystemMetrics(SM_CXSMICON);
	m_sizeSmallIcon.cy = ::GetSystemMetrics(SM_CYSMICON);

	m_rectVirtual.SetRectEmpty();

	if (!EnumDisplayMonitors(NULL, NULL, InfoEnumProc, (LPARAM) &m_rectVirtual))
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &m_rectVirtual, 0);
	}

	// Get system menu animation type:
	m_bMenuAnimation = FALSE;
	m_bMenuFadeEffect = FALSE;

	if (!bIsRemoteSession)
	{
		::SystemParametersInfo(SPI_GETMENUANIMATION, 0, &m_bMenuAnimation, 0);

		if (m_bMenuAnimation)
		{
			::SystemParametersInfo(SPI_GETMENUFADE, 0, &m_bMenuFadeEffect, 0);
		}
	}

	m_nShellAutohideBars = 0;
	m_bRefreshAutohideBars = TRUE;

	::SystemParametersInfo(SPI_GETMENUUNDERLINES, 0, &m_bSysUnderlineKeyboardShortcuts, 0);
	m_bUnderlineKeyboardShortcuts = m_bSysUnderlineKeyboardShortcuts;

	m_bInSettingChange = FALSE;
}

void AFX_GLOBAL_DATA::UpdateSysColors()
{
	m_bIsBlackHighContrast = ::GetSysColor(COLOR_3DLIGHT) == RGB(255, 255, 255) && ::GetSysColor(COLOR_3DFACE) == RGB(0, 0, 0);
	m_bIsWhiteHighContrast = ::GetSysColor(COLOR_3DDKSHADOW) == RGB(0, 0, 0) && ::GetSysColor(COLOR_3DFACE) == RGB(255, 255, 255);

	CWindowDC dc(NULL);
	m_nBitsPerPixel = dc.GetDeviceCaps(BITSPIXEL);

	clrBarFace = clrBtnFace = ::GetSysColor(COLOR_BTNFACE);
	clrBarShadow = clrBtnShadow = ::GetSysColor(COLOR_BTNSHADOW);
	clrBarDkShadow = clrBtnDkShadow = ::GetSysColor(COLOR_3DDKSHADOW);
	clrBarLight = clrBtnLight = ::GetSysColor(COLOR_3DLIGHT);
	clrBarHilite = clrBtnHilite = ::GetSysColor(COLOR_BTNHIGHLIGHT);
	clrBarText = clrBtnText = ::GetSysColor(COLOR_BTNTEXT);
	clrGrayedText = ::GetSysColor(COLOR_GRAYTEXT);
	clrWindowFrame = ::GetSysColor(COLOR_WINDOWFRAME);

	clrHilite = ::GetSysColor(COLOR_HIGHLIGHT);
	clrTextHilite = ::GetSysColor(COLOR_HIGHLIGHTTEXT);

	clrBarWindow = clrWindow = ::GetSysColor(COLOR_WINDOW);
	clrWindowText = ::GetSysColor(COLOR_WINDOWTEXT);

	clrCaptionText = ::GetSysColor(COLOR_CAPTIONTEXT);
	clrMenuText = ::GetSysColor(COLOR_MENUTEXT);

	clrActiveCaption = ::GetSysColor(COLOR_ACTIVECAPTION);
	clrInactiveCaption = ::GetSysColor(COLOR_INACTIVECAPTION);

	clrActiveCaptionGradient = ::GetSysColor(COLOR_GRADIENTACTIVECAPTION);
	clrInactiveCaptionGradient = ::GetSysColor(COLOR_GRADIENTINACTIVECAPTION);

	clrActiveBorder = ::GetSysColor(COLOR_ACTIVEBORDER);
	clrInactiveBorder = ::GetSysColor(COLOR_INACTIVEBORDER);

	clrInactiveCaptionText = ::GetSysColor(COLOR_INACTIVECAPTIONTEXT);

	if (m_bIsBlackHighContrast)
	{
		clrHotLinkNormalText = clrWindowText;
		clrHotLinkHoveredText = clrWindowText;
		clrHotLinkVisitedText = clrWindowText;
	}
	else
	{
		clrHotLinkNormalText = ::GetSysColor(COLOR_HOTLIGHT);
		clrHotLinkHoveredText = RGB(0, 0, 255);   // Bright blue
		clrHotLinkVisitedText = RGB(128, 0, 128); // Violet
	}

	hbrBtnShadow = ::GetSysColorBrush(COLOR_BTNSHADOW);
	ENSURE(hbrBtnShadow != NULL);

	hbrBtnHilite = ::GetSysColorBrush(COLOR_BTNHIGHLIGHT);
	ENSURE(hbrBtnHilite != NULL);

	hbrWindow = ::GetSysColorBrush(COLOR_WINDOW);
	ENSURE(hbrWindow != NULL);

	brBtnFace.DeleteObject();
	brBtnFace.CreateSolidBrush(clrBtnFace);

	brBarFace.DeleteObject();
	brBarFace.CreateSolidBrush(clrBarFace);

	brActiveCaption.DeleteObject();
	brActiveCaption.CreateSolidBrush(clrActiveCaption);

	brInactiveCaption.DeleteObject();
	brInactiveCaption.CreateSolidBrush(clrInactiveCaption);

	brHilite.DeleteObject();
	brHilite.CreateSolidBrush(clrHilite);

	brBlack.DeleteObject();
	brBlack.CreateSolidBrush(clrBtnDkShadow);

	brWindow.DeleteObject();
	brWindow.CreateSolidBrush(clrWindow);

	penHilite.DeleteObject();
	penHilite.CreatePen(PS_SOLID, 1, afxGlobalData.clrHilite);

	penBarFace.DeleteObject();
	penBarFace.CreatePen(PS_SOLID, 1, afxGlobalData.clrBarFace);

	penBarShadow.DeleteObject();
	penBarShadow.CreatePen(PS_SOLID, 1, afxGlobalData.clrBarShadow);

	if (brLight.GetSafeHandle())
	{
		brLight.DeleteObject();
	}

	if (m_nBitsPerPixel > 8)
	{
		COLORREF clrLight = RGB(GetRValue(clrBtnFace) +((GetRValue(clrBtnHilite) - GetRValue(clrBtnFace)) / 2 ),
			GetGValue(clrBtnFace) +((GetGValue(clrBtnHilite) - GetGValue(clrBtnFace)) / 2),
			GetBValue(clrBtnFace) +((GetBValue(clrBtnHilite) - GetBValue(clrBtnFace)) / 2));

		brLight.CreateSolidBrush(clrLight);
	}
	else
	{
		HBITMAP hbmGray = CreateDitherBitmap(dc.GetSafeHdc());
		ENSURE(hbmGray != NULL);

		CBitmap bmp;
		bmp.Attach(hbmGray);

		brLight.CreatePatternBrush(&bmp);
	}

	CMenuImages::CleanUp();
	CDockingManager::m_bSDParamsModified = TRUE;
}

BOOL AFX_GLOBAL_DATA::SetMenuFont(LPLOGFONT lpLogFont, BOOL bHorz)
{
	ENSURE(lpLogFont != NULL);

	if (bHorz)
	{
		// Create regular font:
		fontRegular.DeleteObject();
		if (!fontRegular.CreateFontIndirect(lpLogFont))
		{
			ASSERT(FALSE);
			return FALSE;
		}

		// Create underline font:
		lpLogFont->lfUnderline = TRUE;
		fontUnderline.DeleteObject();
		fontUnderline.CreateFontIndirect(lpLogFont);
		lpLogFont->lfUnderline = FALSE;

		// Create bold font(used in the default menu items):
		long lSavedWeight = lpLogFont->lfWeight;
		lpLogFont->lfWeight = 700;

		fontBold.DeleteObject();
		BOOL bResult = fontBold.CreateFontIndirect(lpLogFont);

		lpLogFont->lfWeight = lSavedWeight; // Restore weight

		if (!bResult)
		{
			ASSERT(FALSE);
			return FALSE;
		}
	}
	else // Vertical font
	{
		fontVert.DeleteObject();
		if (!fontVert.CreateFontIndirect(lpLogFont))
		{
			ASSERT(FALSE);
			return FALSE;
		}
	}

	UpdateTextMetrics();
	return TRUE;
}

void AFX_GLOBAL_DATA::UpdateTextMetrics()
{
	CWindowDC dc(NULL);

	CFont* pOldFont = dc.SelectObject(&fontRegular);
	ENSURE(pOldFont != NULL);

	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);

	int nExtra = tm.tmHeight < 15 ? 2 : 5;

	m_nTextHeightHorz = tm.tmHeight + nExtra;
	m_nTextWidthHorz = tm.tmMaxCharWidth + nExtra;

	dc.SelectObject(&fontVert);
	dc.GetTextMetrics(&tm);

	nExtra = tm.tmHeight < 15 ? 2 : 5;

	m_nTextHeightVert = tm.tmHeight + nExtra;
	m_nTextWidthVert = tm.tmMaxCharWidth + nExtra;

	dc.SelectObject(pOldFont);
}

HBITMAP AFX_GLOBAL_DATA::CreateDitherBitmap(HDC hDC)
{
	struct  // BITMAPINFO with 16 colors
	{
		BITMAPINFOHEADER bmiHeader;
		RGBQUAD      bmiColors[16];
	}
	bmi;
	memset(&bmi, 0, sizeof(bmi));

	bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bmi.bmiHeader.biWidth = 8;
	bmi.bmiHeader.biHeight = 8;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biBitCount = 1;
	bmi.bmiHeader.biCompression = BI_RGB;

	COLORREF clr = afxGlobalData.clrBtnFace;

	bmi.bmiColors[0].rgbBlue = GetBValue(clr);
	bmi.bmiColors[0].rgbGreen = GetGValue(clr);
	bmi.bmiColors[0].rgbRed = GetRValue(clr);

	clr = ::GetSysColor(COLOR_BTNHIGHLIGHT);
	bmi.bmiColors[1].rgbBlue = GetBValue(clr);
	bmi.bmiColors[1].rgbGreen = GetGValue(clr);
	bmi.bmiColors[1].rgbRed = GetRValue(clr);

	// initialize the brushes
	long patGray[8];
	for (int i = 0; i < 8; i++)
		patGray[i] = (i & 1) ? 0xAAAA5555L : 0x5555AAAAL;

	HBITMAP hbm = CreateDIBitmap(hDC, &bmi.bmiHeader, CBM_INIT, (LPBYTE)patGray, (LPBITMAPINFO)&bmi, DIB_RGB_COLORS);
	return hbm;
}

#if (WINVER >= 0x0601)
ITaskbarList* AFX_GLOBAL_DATA::GetITaskbarList()
{
	HRESULT hr = S_OK;

	if (!bIsWindows7 || !m_bTaskBarInterfacesAvailable)
	{
		return NULL;
	}

	if (m_pTaskbarList != NULL)
	{
		return m_pTaskbarList;
	}

	if (!m_bComInitialized)
	{
		hr = CoInitialize(NULL);
		if (SUCCEEDED(hr))
		{
			m_bComInitialized = TRUE;
		}
	}

	if (SUCCEEDED(hr))
	{
		hr = CoCreateInstance(CLSID_TaskbarList, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&m_pTaskbarList));
	}

	ASSERT(SUCCEEDED(hr));
	return m_pTaskbarList;
}

ITaskbarList3* AFX_GLOBAL_DATA::GetITaskbarList3()
{
	HRESULT hr = S_OK;

	if (!bIsWindows7 || !m_bTaskBarInterfacesAvailable)
	{
		return NULL;
	}

	if (m_pTaskbarList3 != NULL)
	{
		return m_pTaskbarList3;
	}

	if (!m_bComInitialized)
	{
		hr = CoInitialize(NULL);
		if (SUCCEEDED(hr))
		{
			m_bComInitialized = TRUE;
		}
	}

	if (SUCCEEDED(hr))
	{
		hr = CoCreateInstance(CLSID_TaskbarList, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&m_pTaskbarList3));
	}

	ASSERT(SUCCEEDED(hr));
	return m_pTaskbarList3;
}

void AFX_GLOBAL_DATA::ReleaseTaskBarRefs()
{
	m_bTaskBarInterfacesAvailable = FALSE;

	if (m_pTaskbarList != NULL)
	{
		RELEASE(m_pTaskbarList);
		m_pTaskbarList = NULL;
	}

	if (m_pTaskbarList3 != NULL)
	{
		RELEASE(m_pTaskbarList3);
		m_pTaskbarList3 = NULL;
	}

	if (m_bComInitialized)
	{
		CoUninitialize();
		m_bComInitialized = FALSE;
	}
}
#endif

void AFX_GLOBAL_DATA::CleanUp()
{
	if (brLight.GetSafeHandle())
	{
		brLight.DeleteObject();
	}

	// cleanup fonts:
	fontRegular.DeleteObject();
	fontBold.DeleteObject();
	fontUnderline.DeleteObject();
	fontVert.DeleteObject();
	fontVertCaption.DeleteObject();
	fontTooltip.DeleteObject();

	ReleaseTaskBarRefs();

	if (m_bBufferedPaintInited && m_pfBufferedPaintUnInit != NULL)
	{
		m_pfBufferedPaintUnInit();
		m_bBufferedPaintInited = FALSE;
	}

	if (m_hinstUXThemeDLL != NULL)
	{
		::FreeLibrary(m_hinstUXThemeDLL);
		m_hinstUXThemeDLL = NULL;
	}

	if (m_hinstDwmapiDLL != NULL)
	{
		::FreeLibrary(m_hinstDwmapiDLL);
		m_hinstDwmapiDLL = NULL;
	}

	m_bEnableAccessibility = FALSE;
}

void ControlBarCleanUp()
{
	afxGlobalData.CleanUp();

	afxMenuHash.CleanUp();

	CMFCToolBar::CleanUpImages();
	CMenuImages::CleanUp();

	if (GetCmdMgr() != NULL)
	{
		GetCmdMgr()->CleanUp();
	}

	CKeyboardManager::CleanUp();

	// Destroy visualization manager:
	CMFCVisualManager::DestroyInstance(TRUE /* bAutoDestroyOnly */);
	CMFCVisualManagerOffice2007::CleanStyle();
}

BOOL AFX_GLOBAL_DATA::DrawParentBackground(CWnd* pWnd, CDC* pDC, LPRECT rectClip)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(pWnd);

	BOOL bRes = FALSE;

	CRgn rgn;
	if (rectClip != NULL)
	{
		rgn.CreateRectRgnIndirect(rectClip);
		pDC->SelectClipRgn(&rgn);
	}

	CWnd* pParent = pWnd->GetParent();
	ASSERT_VALID(pParent);

	// In Windows XP, we need to call DrawThemeParentBackground function to implement
	// transparent controls
	if (m_pfDrawThemeBackground != NULL)
	{
		bRes = (*m_pfDrawThemeBackground)(pWnd->GetSafeHwnd(), pDC->GetSafeHdc(), rectClip) == S_OK;
	}

	if (!bRes)
	{
		CPoint pt(0, 0);
		pWnd->MapWindowPoints(pParent, &pt, 1);
		pt = pDC->OffsetWindowOrg(pt.x, pt.y);

		bRes = (BOOL) pParent->SendMessage(WM_ERASEBKGND, (WPARAM)pDC->m_hDC);

		pDC->SetWindowOrg(pt.x, pt.y);
	}

	pDC->SelectClipRgn(NULL);

	return bRes;
}

CFrameWnd* AFXGetParentFrame(const CWnd* pWnd)
{
	if (pWnd->GetSafeHwnd() == NULL)
	{
		return NULL;
	}
	ASSERT_VALID(pWnd);

	const CWnd* pParentWnd = pWnd;

	while (pParentWnd != NULL)
	{
		if (pParentWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
		{
			CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, pParentWnd);
			pParentWnd = pMiniFrame->GetParent();
		}
		else
		{
			pParentWnd = pParentWnd->GetParent();
		}

		if (pParentWnd == NULL)
		{
			return NULL;
		}

		if (pParentWnd->IsFrameWnd())
		{
			return(CFrameWnd*)pParentWnd;
		}
	}

	return NULL;
}

COLORREF AFX_GLOBAL_DATA::GetColor(int nColor)
{
	switch(nColor)
	{
		case COLOR_BTNFACE:             return clrBtnFace;
		case COLOR_BTNSHADOW:           return clrBtnShadow;
		case COLOR_3DDKSHADOW:          return clrBtnDkShadow;
		case COLOR_3DLIGHT:             return clrBtnLight;
		case COLOR_BTNHIGHLIGHT:        return clrBtnHilite;
		case COLOR_BTNTEXT:             return clrBtnText;
		case COLOR_GRAYTEXT:            return clrGrayedText;
		case COLOR_WINDOWFRAME:         return clrWindowFrame;

		case COLOR_HIGHLIGHT:           return clrHilite;
		case COLOR_HIGHLIGHTTEXT:       return clrTextHilite;

		case COLOR_WINDOW:              return clrWindow;
		case COLOR_WINDOWTEXT:          return clrWindowText;

		case COLOR_CAPTIONTEXT:         return clrCaptionText;
		case COLOR_MENUTEXT:            return clrMenuText;

		case COLOR_ACTIVECAPTION:       return clrActiveCaption;
		case COLOR_INACTIVECAPTION:     return clrInactiveCaption;

		case COLOR_ACTIVEBORDER:        return clrActiveBorder;
		case COLOR_INACTIVEBORDER:      return clrInactiveBorder;

		case COLOR_INACTIVECAPTIONTEXT: return clrInactiveCaptionText;
	}

	return ::GetSysColor(nColor);
}

BOOL AFX_GLOBAL_DATA::SetLayeredAttrib(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
{
	return(::SetLayeredWindowAttributes(hwnd, crKey, bAlpha, dwFlags));
}

void AFX_GLOBAL_DATA::EnableAccessibilitySupport(BOOL bEnable/* = TRUE*/)
{
	m_bEnableAccessibility = bEnable;
}

CString AFX_GLOBAL_DATA::RegisterWindowClass(LPCTSTR lpszClassNamePrefix)
{
	ENSURE(lpszClassNamePrefix != NULL);

	// Register a new window class:
	HINSTANCE hInst = AfxGetInstanceHandle();
	UINT uiClassStyle = CS_DBLCLKS;
	HCURSOR hCursor = ::LoadCursor(NULL, IDC_ARROW);
	HBRUSH hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);

	CString strClassName;
	strClassName.Format(_T("%s:%x:%x:%x:%x"), lpszClassNamePrefix, (UINT_PTR)hInst, uiClassStyle, (UINT_PTR)hCursor, (UINT_PTR)hbrBackground);

	// See if the class already exists:
	WNDCLASS wndcls;
	if (::GetClassInfo(hInst, strClassName, &wndcls))
	{
		// Already registered, assert everything is good:
		ASSERT(wndcls.style == uiClassStyle);
	}
	else
	{
		// Otherwise we need to register a new class:
		wndcls.style = uiClassStyle;
		wndcls.lpfnWndProc = ::DefWindowProc;
		wndcls.cbClsExtra = wndcls.cbWndExtra = 0;
		wndcls.hInstance = hInst;
		wndcls.hIcon = NULL;
		wndcls.hCursor = hCursor;
		wndcls.hbrBackground = hbrBackground;
		wndcls.lpszMenuName = NULL;
		wndcls.lpszClassName = strClassName;

		if (!AfxRegisterClass(&wndcls))
		{
			AfxThrowResourceException();
		}
	}

	return strClassName;
}

BOOL AFX_GLOBAL_DATA::ExcludeTag(CString& strBuffer, LPCTSTR lpszTag, CString& strTag, BOOL bIsCharsList /* = FALSE*/)
{
	const int iBufLen = strBuffer.GetLength();

	CString strTagStart = _T("<");
	strTagStart += lpszTag;
	strTagStart += _T(">");

	const int iTagStartLen = strTagStart.GetLength();

	int iStart = -1;

	int iIndexStart = strBuffer.Find(strTagStart);
	if (iIndexStart < 0)
	{
		return FALSE;
	}

	iStart = iIndexStart + iTagStartLen;

	CString strTagEnd = _T("</");
	strTagEnd += lpszTag;
	strTagEnd += _T('>');

	const int iTagEndLen = strTagEnd.GetLength();

	int iIndexEnd =  -1;
	int nBalanse = 1;
	for (int i = iStart; i < iBufLen - iTagEndLen + 1; i ++)
	{
		if (strBuffer [i] != '<')
		{
			continue;
		}

		if (i < iBufLen - iTagStartLen && _tcsncmp(strBuffer.Mid(i), strTagStart, iTagStartLen) == 0)
		{
			i += iTagStartLen - 1;
			nBalanse ++;
			continue;
		}

		if (_tcsncmp(strBuffer.Mid(i), strTagEnd, iTagEndLen) == 0)
		{
			nBalanse --;
			if (nBalanse == 0)
			{
				iIndexEnd = i;
				break;
			}

			i += iTagEndLen - 1;
		}
	}

	if (iIndexEnd == -1 || iStart > iIndexEnd)
	{
		return FALSE;
	}

	strTag = strBuffer.Mid(iStart, iIndexEnd - iStart);
	strTag.TrimLeft();
	strTag.TrimRight();

	strBuffer.Delete(iIndexStart, iIndexEnd + iTagEndLen - iIndexStart);

	if (bIsCharsList)
	{
		if (strTag.GetLength() > 1 && strTag [0] == _T('\"'))
		{
			strTag = strTag.Mid(1, strTag.GetLength() - 2);
		}

		strTag.Replace(_T("\\t"), _T("\t"));
		strTag.Replace(_T("\\n"), _T("\n"));
		strTag.Replace(_T("\\r"), _T("\r"));
		strTag.Replace(_T("\\b"), _T("\b"));
		strTag.Replace(_T("LT"), _T("<"));
		strTag.Replace(_T("GT"), _T(">"));
		strTag.Replace(_T("AMP"), _T("&"));
	}

	return TRUE;
}

BOOL AFX_GLOBAL_DATA::DwmExtendFrameIntoClientArea(HWND hWnd, AFX_MARGINS* pMargins)
{
	if (m_pfDwmExtendFrameIntoClientArea == NULL)
	{
		return FALSE;
	}

	HRESULT hres = (*m_pfDwmExtendFrameIntoClientArea)(hWnd, pMargins);
	return hres == S_OK;
}

LRESULT AFX_GLOBAL_DATA::DwmDefWindowProc(HWND hWnd, UINT message, WPARAM wp, LPARAM lp)
{
	if (m_pfDwmDefWindowProc == NULL)
	{
		return(LRESULT)-1;
	}

	LRESULT lres = 0;
	(*m_pfDwmDefWindowProc)(hWnd, message, wp, lp, &lres);

	return lres;
}

BOOL AFX_GLOBAL_DATA::DwmIsCompositionEnabled()
{
	if (m_pfDwmIsCompositionEnabled == NULL || bDisableAero)
	{
		return FALSE;
	}

	BOOL bEnabled = FALSE;

	(*m_pfDwmIsCompositionEnabled)(&bEnabled);
	return bEnabled;
}

BOOL AFX_GLOBAL_DATA::DrawTextOnGlass(HTHEME hTheme, CDC* pDC, int iPartId, int iStateId, CString strText, CRect rect, DWORD dwFlags, int nGlowSize, COLORREF clrText)
{
	//---- bits used in dwFlags of DTTOPTS ----
#define AFX_DTT_TEXTCOLOR    (1UL << 0)      // crText has been specified
#define AFX_DTT_BORDERCOLOR  (1UL << 1)      // crBorder has been specified
#define AFX_DTT_SHADOWCOLOR  (1UL << 2)      // crShadow has been specified
#define AFX_DTT_SHADOWTYPE   (1UL << 3)      // iTextShadowType has been specified
#define AFX_DTT_SHADOWOFFSET (1UL << 4)      // ptShadowOffset has been specified
#define AFX_DTT_BORDERSIZE   (1UL << 5)      // nBorderSize has been specified
#define AFX_DTT_FONTPROP     (1UL << 6)      // iFontPropId has been specified
#define AFX_DTT_COLORPROP    (1UL << 7)      // iColorPropId has been specified
#define AFX_DTT_STATEID      (1UL << 8)      // IStateId has been specified
#define AFX_DTT_CALCRECT     (1UL << 9)      // Use pRect as and in/out parameter
#define AFX_DTT_APPLYOVERLAY (1UL << 10)     // fApplyOverlay has been specified
#define AFX_DTT_GLOWSIZE     (1UL << 11)     // iGlowSize has been specified
#define AFX_DTT_CALLBACK     (1UL << 12)     // pfnDrawTextCallback has been specified
#define AFX_DTT_COMPOSITED   (1UL << 13)     // Draws text with antialiased alpha(needs a DIB section)

	if (hTheme == NULL || m_pfDrawThemeTextEx == NULL || !DwmIsCompositionEnabled())
	{
		pDC->DrawText(strText, rect, dwFlags);
		return FALSE;
	}

	CComBSTR bstmp = (LPCTSTR)strText;

	wchar_t* wbuf = new wchar_t[bstmp.Length() + 1];
	wcscpy_s(wbuf, bstmp.Length() + 1, bstmp);

	AFX_DTTOPTS dto;
	memset(&dto, 0, sizeof(AFX_DTTOPTS));
	dto.dwSize = sizeof(AFX_DTTOPTS);
	dto.dwFlags = AFX_DTT_COMPOSITED;

	if (nGlowSize > 0)
	{
		dto.dwFlags |= AFX_DTT_GLOWSIZE;
		dto.iGlowSize = nGlowSize;
	}

	if (clrText != (COLORREF)-1)
	{
		dto.dwFlags |= AFX_DTT_TEXTCOLOR;
		dto.crText = clrText;
	}

	(*m_pfDrawThemeTextEx)(hTheme, pDC->GetSafeHdc(), iPartId, iStateId, wbuf, -1, dwFlags, rect, &dto);

	delete [] wbuf;

	return TRUE;
}

HCURSOR AFX_GLOBAL_DATA::GetHandCursor()
{
	if (m_hcurHand == NULL)
	{
		m_hcurHand = ::LoadCursorW(NULL, MAKEINTRESOURCEW(IDC_HAND));
	}

	return m_hcurHand;
}

BOOL AFX_GLOBAL_DATA::Resume()
{
	m_hinstUXThemeDLL = ::AfxCtxLoadLibraryW(L"UxTheme.dll");

	if (m_hinstUXThemeDLL != NULL)
	{
		m_pfDrawThemeBackground = (DRAWTHEMEPARENTBACKGROUND)::GetProcAddress (m_hinstUXThemeDLL, "DrawThemeParentBackground");
		m_pfDrawThemeTextEx = (DRAWTHEMETEXTEX)::GetProcAddress (m_hinstUXThemeDLL, "DrawThemeTextEx");
		m_pfBeginBufferedPaint = (BEGINBUFFEREDPAINT)::GetProcAddress (m_hinstUXThemeDLL, "BeginBufferedPaint");
		m_pfEndBufferedPaint = (ENDBUFFEREDPAINT)::GetProcAddress (m_hinstUXThemeDLL, "EndBufferedPaint");
	}
	else
	{
		m_pfDrawThemeBackground = NULL;
		m_pfDrawThemeTextEx = NULL;
		m_pfBeginBufferedPaint = NULL;
		m_pfEndBufferedPaint = NULL;
	}

	if (m_hinstDwmapiDLL != NULL)
	{
		m_hinstDwmapiDLL = ::AfxCtxLoadLibraryW(L"dwmapi.dll");
		ENSURE(m_hinstDwmapiDLL != NULL);

		m_pfDwmExtendFrameIntoClientArea = (DWMEXTENDFRAMEINTOCLIENTAREA)::GetProcAddress (m_hinstDwmapiDLL, "DwmExtendFrameIntoClientArea");
		m_pfDwmDefWindowProc = (DWMDEFWINDOWPROC) ::GetProcAddress (m_hinstDwmapiDLL, "DwmDefWindowProc");
		m_pfDwmIsCompositionEnabled = (DWMISCOMPOSITIONENABLED)::GetProcAddress (m_hinstDwmapiDLL, "DwmIsCompositionEnabled");
	}

	if (m_bEnableAccessibility)
	{
		EnableAccessibilitySupport();
	}

	CMFCVisualManagerOffice2007::CleanStyle ();

	if (CMFCVisualManager::m_pRTIDefault != NULL)
	{
		CMFCVisualManager::SetDefaultManager (CMFCVisualManager::m_pRTIDefault);
	}

	return TRUE;
}

BOOL AFX_GLOBAL_DATA::GetNonClientMetrics (NONCLIENTMETRICS& info)
{
	struct AFX_OLDNONCLIENTMETRICS
	{
		UINT    cbSize;
		int     iBorderWidth;
		int     iScrollWidth;
		int     iScrollHeight;
		int     iCaptionWidth;
		int     iCaptionHeight;
		LOGFONT lfCaptionFont;
		int     iSmCaptionWidth;
		int     iSmCaptionHeight;
		LOGFONT lfSmCaptionFont;
		int     iMenuWidth;
		int     iMenuHeight;
		LOGFONT lfMenuFont;
		LOGFONT lfStatusFont;
		LOGFONT lfMessageFont;
	};

	const UINT cbProperSize = (_AfxGetComCtlVersion() < MAKELONG(1, 6))
		? sizeof(AFX_OLDNONCLIENTMETRICS) : sizeof(NONCLIENTMETRICS);

	info.cbSize = cbProperSize;

	return ::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, cbProperSize, &info, 0);
}


BOOL AFXAPI AfxIsExtendedFrameClass(CWnd* pWnd)
{
	ENSURE( pWnd );
	if (pWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		return TRUE;
	}
	if (pWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		return TRUE;
	}
	if (pWnd->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		return TRUE;
	}
	if (pWnd->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		return TRUE;
	}
	if (pWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		return TRUE;
	}
	return FALSE;
}


BOOL AFXAPI AfxIsMFCToolBar(CWnd* pWnd)
{
	ENSURE( pWnd );
	if (pWnd->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
	{
		return TRUE;
	}
	return FALSE;
}

HRESULT AFX_GLOBAL_DATA::ShellCreateItemFromParsingName(PCWSTR pszPath, IBindCtx *pbc, REFIID riid, void **ppv)
{
	static HMODULE hShellDll = AfxCtxLoadLibrary(_T("Shell32.dll"));
	ENSURE(hShellDll != NULL);

	typedef	HRESULT (__stdcall *PFNSHCREATEITEMFROMPARSINGNAME)(
		PCWSTR,
		IBindCtx*,
		REFIID,
		void**
		);

	PFNSHCREATEITEMFROMPARSINGNAME pSHCreateItemFromParsingName =
		(PFNSHCREATEITEMFROMPARSINGNAME)GetProcAddress(hShellDll, "SHCreateItemFromParsingName");
	if (pSHCreateItemFromParsingName == NULL)
	{
		return E_FAIL;
	}

	return (*pSHCreateItemFromParsingName)(pszPath, pbc, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxglobalutils.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxglobalutils.h"
#include "afxdockingmanager.h"
#include "afxpanecontainermanager.h"
#include "afxdockablepane.h"
#include "afxpaneframewnd.h"
#include "afxmultipaneframewnd.h"
#include "afxbasetabbedpane.h"

#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxmdichildwndex.h"
#include "afxolecntrframewndex.h"
#include "afxlinkctrl.h"
#include "afxribbonres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CGlobalUtils afxGlobalUtils;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGlobalUtils::CGlobalUtils()
{
	m_bDialogApp = FALSE;
	m_bIsDragging = FALSE;
}

CGlobalUtils::~CGlobalUtils()
{
}

BOOL CGlobalUtils::CheckAlignment(CPoint point, CBasePane* pBar, int nSensitivity, const CDockingManager* pDockManager,
	BOOL bOuterEdge, DWORD& dwAlignment, DWORD dwEnabledDockBars, LPCRECT lpRectBounds) const
{
	BOOL bSmartDocking = FALSE;
	CSmartDockingStandaloneGuide::SDMarkerPlace nHilitedSide = CSmartDockingStandaloneGuide::sdNONE;

	if (pDockManager == NULL && pBar != NULL)
	{
		pDockManager = afxGlobalUtils.GetDockingManager(pBar->GetParent());
	}

	if (pDockManager != NULL)
	{
		CSmartDockingManager* pSDManager = pDockManager->GetSmartDockingManagerPermanent();
		if (pSDManager != NULL && pSDManager->IsStarted())
		{
			bSmartDocking = TRUE;
			nHilitedSide = pSDManager->GetHighlightedGuideNo();
		}
	}

	CRect rectBounds;
	if (pBar != NULL)
	{
		pBar->GetWindowRect(rectBounds);
	}
	else if (lpRectBounds != NULL)
	{
		rectBounds = *lpRectBounds;
	}
	else
	{
		ASSERT(FALSE);
		return FALSE;
	}

	int nCaptionHeight = 0;
	int nTabAreaTopHeight = 0;
	int nTabAreaBottomHeight = 0;

	CDockablePane* pDockingBar = DYNAMIC_DOWNCAST(CDockablePane, pBar);

	if (pDockingBar != NULL)
	{
		nCaptionHeight = pDockingBar->GetCaptionHeight();

		CRect rectTabAreaTop;
		CRect rectTabAreaBottom;
		pDockingBar->GetTabArea(rectTabAreaTop, rectTabAreaBottom);
		nTabAreaTopHeight = rectTabAreaTop.Height();
		nTabAreaBottomHeight = rectTabAreaBottom.Height();
	}

	// build rect for top area
	if (bOuterEdge)
	{
		if (bSmartDocking)
		{
			switch(nHilitedSide)
			{
			case CSmartDockingStandaloneGuide::sdLEFT:
				dwAlignment = CBRS_ALIGN_LEFT;
				return TRUE;
			case CSmartDockingStandaloneGuide::sdRIGHT:
				dwAlignment = CBRS_ALIGN_RIGHT;
				return TRUE;
			case CSmartDockingStandaloneGuide::sdTOP:
				dwAlignment = CBRS_ALIGN_TOP;
				return TRUE;
			case CSmartDockingStandaloneGuide::sdBOTTOM:
				dwAlignment = CBRS_ALIGN_BOTTOM;
				return TRUE;
			}
		}
		else
		{
			CRect rectToCheck(rectBounds.left - nSensitivity, rectBounds.top - nSensitivity, rectBounds.right + nSensitivity, rectBounds.top);
			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_TOP)
			{
				dwAlignment = CBRS_ALIGN_TOP;
				return TRUE;
			}

			// build rect for left area
			rectToCheck.right = rectBounds.left;
			rectToCheck.bottom = rectBounds.bottom + nSensitivity;

			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_LEFT)
			{
				dwAlignment = CBRS_ALIGN_LEFT;
				return TRUE;
			}

			// build rect for bottom area
			rectToCheck.left = rectBounds.left - nSensitivity;
			rectToCheck.top = rectBounds.bottom;
			rectToCheck.right = rectBounds.right + nSensitivity;
			rectToCheck.bottom = rectBounds.bottom + nSensitivity;

			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_BOTTOM)
			{
				dwAlignment = CBRS_ALIGN_BOTTOM;
				return TRUE;
			}

			// build rect for right area
			rectToCheck.left = rectBounds.right;
			rectToCheck.top = rectBounds.top - nSensitivity;

			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_RIGHT)
			{
				dwAlignment = CBRS_ALIGN_RIGHT;
				return TRUE;
			}
		}
	}
	else
	{
		if (bSmartDocking)
		{
			switch(nHilitedSide)
			{
			case CSmartDockingStandaloneGuide::sdCLEFT:
				dwAlignment = CBRS_ALIGN_LEFT;
				return TRUE;
			case CSmartDockingStandaloneGuide::sdCRIGHT:
				dwAlignment = CBRS_ALIGN_RIGHT;
				return TRUE;
			case CSmartDockingStandaloneGuide::sdCTOP:
				dwAlignment = CBRS_ALIGN_TOP;
				return TRUE;
			case CSmartDockingStandaloneGuide::sdCBOTTOM:
				dwAlignment = CBRS_ALIGN_BOTTOM;
				return TRUE;
			}
		}
		else
		{
#ifdef __BOUNDS_FIX__
			CRect rectToCheck(rectBounds.left, rectBounds.top, rectBounds.right, rectBounds.top + nSensitivity + nCaptionHeight);
			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_TOP)
			{
				dwAlignment = CBRS_ALIGN_TOP;
				return TRUE;
			}

			// build rect for left area
			rectToCheck.right = rectBounds.left + nSensitivity;
			rectToCheck.bottom = rectBounds.bottom + nSensitivity;

			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_LEFT)
			{
				dwAlignment = CBRS_ALIGN_LEFT;
				return TRUE;
			}

			// build rect for bottom area
			rectToCheck.left = rectBounds.left;
			rectToCheck.top = rectBounds.bottom - nSensitivity - nTabAreaBottomHeight;
			rectToCheck.right = rectBounds.right;
			rectToCheck.bottom = rectBounds.bottom;

			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_BOTTOM)
			{
				dwAlignment = CBRS_ALIGN_BOTTOM;
				return TRUE;
			}

			// build rect for right area
			rectToCheck.left = rectBounds.right - nSensitivity;
			rectToCheck.top = rectBounds.top - nSensitivity;

			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_RIGHT)
			{
				dwAlignment = CBRS_ALIGN_RIGHT;
				return TRUE;
			}
#else

			// build rect for top area
			CRect rectToCheck(rectBounds.left - nSensitivity, rectBounds.top - nSensitivity, rectBounds.right + nSensitivity, rectBounds.top + nSensitivity + nCaptionHeight);
			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_TOP)
			{
				dwAlignment = CBRS_ALIGN_TOP;
				return TRUE;
			}

			// build rect for left area
			rectToCheck.right = rectBounds.left + nSensitivity;
			rectToCheck.bottom = rectBounds.bottom + nSensitivity;

			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_LEFT)
			{
				dwAlignment = CBRS_ALIGN_LEFT;
				return TRUE;
			}

			// build rect for bottom area
			rectToCheck.left = rectBounds.left - nSensitivity;
			rectToCheck.top = rectBounds.bottom - nSensitivity - nTabAreaBottomHeight;
			rectToCheck.right = rectBounds.right + nSensitivity;
			rectToCheck.bottom = rectBounds.bottom + nSensitivity;

			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_BOTTOM)
			{
				dwAlignment = CBRS_ALIGN_BOTTOM;
				return TRUE;
			}

			// build rect for right area
			rectToCheck.left = rectBounds.right - nSensitivity;
			rectToCheck.top = rectBounds.top - nSensitivity;

			if (rectToCheck.PtInRect(point) && dwEnabledDockBars & CBRS_ALIGN_RIGHT)
			{
				dwAlignment = CBRS_ALIGN_RIGHT;
				return TRUE;
			}
#endif
		}
	}

	return FALSE;
}

CDockingManager* CGlobalUtils::GetDockingManager(CWnd* pWnd)
{
	if (pWnd == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pWnd);

	if (pWnd->IsKindOf(RUNTIME_CLASS(CFrameWndEx)))
	{
		return((CFrameWndEx*) pWnd)->GetDockingManager();
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWndEx)))
	{
		return((CMDIFrameWndEx*) pWnd)->GetDockingManager();
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(COleIPFrameWndEx)))
	{
		return((COleIPFrameWndEx*) pWnd)->GetDockingManager();
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(COleDocIPFrameWndEx)))
	{
		return((COleDocIPFrameWndEx*) pWnd)->GetDockingManager();
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(CMDIChildWndEx)))
	{
		return((CMDIChildWndEx*) pWnd)->GetDockingManager();
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(CDialog)) || pWnd->IsKindOf(RUNTIME_CLASS(CPropertySheet)))
	{
		if (pWnd->GetSafeHwnd() == AfxGetMainWnd()->GetSafeHwnd())
		{
			m_bDialogApp = TRUE;
		}
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(COleCntrFrameWndEx)))
	{
		return((COleCntrFrameWndEx*) pWnd)->GetDockingManager();
	}
	else if (pWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
	{
		CPaneFrameWnd* pMiniFrameWnd = DYNAMIC_DOWNCAST(CPaneFrameWnd, pWnd);
		ASSERT_VALID(pMiniFrameWnd);

		CDockingManager* pManager = pMiniFrameWnd->GetDockingManager();
		return pManager != NULL ? pManager : GetDockingManager(pWnd->GetParent());
	}

	return NULL;
}

void CGlobalUtils::FlipRect(CRect& rect, int nDegrees)
{
	CRect rectTmp = rect;
	switch(nDegrees)
	{
	case 90:
		rect.top = rectTmp.left;
		rect.right = rectTmp.top;
		rect.bottom = rectTmp.right;
		rect.left = rectTmp.bottom;
		break;
	case 180:
		rect.top = rectTmp.bottom;
		rect.bottom = rectTmp.top;
		break;
	case 270:
	case -90:
		rect.left = rectTmp.top;
		rect.top = rectTmp.right;
		rect.right = rectTmp.bottom;
		rect.bottom = rectTmp.left;
		break;
	}
}

DWORD CGlobalUtils::GetOppositeAlignment(DWORD dwAlign)
{
	switch(dwAlign & CBRS_ALIGN_ANY)
	{
	case CBRS_ALIGN_LEFT:
		return CBRS_ALIGN_RIGHT;
	case CBRS_ALIGN_RIGHT:
		return CBRS_ALIGN_LEFT;
	case CBRS_ALIGN_TOP:
		return CBRS_ALIGN_BOTTOM;
	case CBRS_ALIGN_BOTTOM:
		return CBRS_ALIGN_TOP;
	}
	return 0;
}

void CGlobalUtils::SetNewParent(CObList& lstControlBars, CWnd* pNewParent, BOOL bCheckVisibility)
{
	ASSERT_VALID(pNewParent);
	for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*) lstControlBars.GetNext(pos);

		if (bCheckVisibility && !pBar->IsPaneVisible())
		{
			continue;
		}
		if (!pBar->IsKindOf(RUNTIME_CLASS(CPaneDivider)))
		{
			pBar->ShowWindow(SW_HIDE);
			pBar->SetParent(pNewParent);
			CRect rectWnd;
			pBar->GetWindowRect(rectWnd);
			pNewParent->ScreenToClient(rectWnd);

			pBar->SetWindowPos(NULL, -rectWnd.Width(), -rectWnd.Height(), 100, 100, SWP_NOZORDER | SWP_NOSIZE  | SWP_NOACTIVATE);
			pBar->ShowWindow(SW_SHOW);
		}
		else
		{
			pBar->SetParent(pNewParent);
		}
	}
}

void CGlobalUtils::CalcExpectedDockedRect(CPaneContainerManager& barContainerManager,
	CWnd* pWndToDock, CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar)
{
	ENSURE(ppTargetBar != NULL);

	DWORD dwAlignment = CBRS_ALIGN_LEFT;
	BOOL bTabArea = FALSE;
	BOOL bCaption = FALSE;
	bDrawTab = FALSE;
	*ppTargetBar = NULL;

	rectResult.SetRectEmpty();

	if (GetKeyState(VK_CONTROL) < 0)
	{
		return;
	}

	if (!GetPaneAndAlignFromPoint(barContainerManager, ptMouse, ppTargetBar, dwAlignment, bTabArea, bCaption) || *ppTargetBar == NULL)
	{
		return;
	}

	CPane* pBar = NULL;

	if (pWndToDock->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
	{
		CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, pWndToDock);
		ASSERT_VALID(pMiniFrame);
		pBar = DYNAMIC_DOWNCAST(CPane, pMiniFrame->GetFirstVisiblePane());
	}
	else
	{
		pBar = DYNAMIC_DOWNCAST(CPane, pWndToDock);
	}

	if (*ppTargetBar != NULL)
	{
		DWORD dwTargetEnabledAlign = (*ppTargetBar)->GetEnabledAlignment();
		DWORD dwTargetCurrentAlign = (*ppTargetBar)->GetCurrentAlignment();
		BOOL bTargetBarIsFloating = ((*ppTargetBar)->GetParentMiniFrame() != NULL);

		if (pBar != NULL)
		{
			if (pBar->GetEnabledAlignment() != dwTargetEnabledAlign && bTargetBarIsFloating ||
				(pBar->GetEnabledAlignment() & dwTargetCurrentAlign) == 0 && !bTargetBarIsFloating)
			{
				return;
			}
		}
	}

	if (bTabArea || bCaption)
	{
		// can't make tab on miniframe
		bDrawTab = ((*ppTargetBar) != NULL);

		if (bDrawTab)
		{
			bDrawTab = (*ppTargetBar)->CanBeAttached() && CanBeAttached(pWndToDock) &&
				pBar != NULL &&((*ppTargetBar)->GetEnabledAlignment() == pBar->GetEnabledAlignment());
		}

		if (!bDrawTab)
		{
			return;
		}
	}

	if ((*ppTargetBar) != NULL &&(*ppTargetBar)->GetParentMiniFrame() != NULL && !CanPaneBeInFloatingMultiPaneFrameWnd(pWndToDock))
	{
		bDrawTab = FALSE;
		return;
	}

	if ((*ppTargetBar) != NULL && pWndToDock->IsKindOf(RUNTIME_CLASS(CBasePane)) && !(*ppTargetBar)->CanAcceptPane((CBasePane*) pWndToDock))
	{
		bDrawTab = FALSE;
		return;
	}

	CRect rectOriginal;
	(*ppTargetBar)->GetWindowRect(rectOriginal);

	if ((*ppTargetBar) == pWndToDock || pWndToDock->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)) &&(*ppTargetBar)->GetParentMiniFrame() == pWndToDock)
	{
		bDrawTab = FALSE;
		return;
	}

	CRect rectInserted;
	CRect rectSlider;
	DWORD dwSliderStyle;
	CSize sizeMinOriginal(0, 0);
	CSize sizeMinInserted(0, 0);

	pWndToDock->GetWindowRect(rectInserted);

	if (pBar == NULL)
	{
		return;
	}

	if ((dwAlignment & pBar->GetEnabledAlignment()) != 0 ||
		CDockingManager::m_bIgnoreEnabledAlignment)
	{
		barContainerManager.CalcRects(rectOriginal, rectInserted, rectSlider, dwSliderStyle, dwAlignment, sizeMinOriginal, sizeMinInserted);
		rectResult = rectInserted;
	}
}

BOOL CGlobalUtils::CanBeAttached(CWnd* pWnd) const
{
	ASSERT_VALID(pWnd);

	if (pWnd->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
	{
		return((CPaneFrameWnd*) pWnd)->CanBeAttached();
	}

	if (pWnd->IsKindOf(RUNTIME_CLASS(CPane)))
	{
		return((CPane*) pWnd)->CanBeAttached();
	}

	return FALSE;
}

BOOL CGlobalUtils::CanPaneBeInFloatingMultiPaneFrameWnd(CWnd* pWnd) const
{
	CPane* pBar = NULL;

	CPaneFrameWnd* pMiniFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, pWnd);

	if (pMiniFrame != NULL)
	{
		pBar = DYNAMIC_DOWNCAST(CPane, pMiniFrame->GetPane());
	}
	else
	{
		pBar = DYNAMIC_DOWNCAST(CPane, pWnd);
	}

	if (pBar == NULL)
	{
		return FALSE;
	}

	if (pBar->IsTabbed())
	{
		CWnd* pParentMiniFrame = pBar->GetParentMiniFrame();
		// tabbed bar that is floating in multi miniframe
		if (pParentMiniFrame != NULL && pParentMiniFrame->IsKindOf(RUNTIME_CLASS(CMultiPaneFrameWnd)))
		{
			return TRUE;
		}
	}

	return((pBar->GetPaneStyle() & CBRS_FLOAT_MULTI) != 0);
}

BOOL CGlobalUtils::GetPaneAndAlignFromPoint(CPaneContainerManager& barContainerManager, CPoint pt,
	CDockablePane** ppTargetControlBar, DWORD& dwAlignment, BOOL& bTabArea, BOOL& bCaption)
{
	ENSURE(ppTargetControlBar != NULL);
	*ppTargetControlBar = NULL;

	BOOL bOuterEdge = FALSE;

	// if the mouse is over a miniframe's caption and this miniframe has only one
	// visible docking control bar, we need to draw a tab
	bCaption = barContainerManager.CheckForMiniFrameAndCaption(pt, ppTargetControlBar);
	if (bCaption)
	{
		return TRUE;
	}

	*ppTargetControlBar = barContainerManager.PaneFromPoint(pt, CDockingManager::m_nDockSensitivity, TRUE, bTabArea, bCaption);

	if ((bCaption || bTabArea) && *ppTargetControlBar != NULL)
	{
		return TRUE;
	}

	if (*ppTargetControlBar == NULL)
	{
		barContainerManager.PaneFromPoint(pt, CDockingManager::m_nDockSensitivity, FALSE, bTabArea, bCaption);
		// the exact bar was not found - it means the docked frame at the outer edge
		bOuterEdge = TRUE;
		return TRUE;
	}

	if (*ppTargetControlBar != NULL)
	{
		if (!afxGlobalUtils.CheckAlignment(pt, *ppTargetControlBar, CDockingManager::m_nDockSensitivity, NULL, bOuterEdge, dwAlignment))
		{
			// unable for some reason to determine alignment
			*ppTargetControlBar = NULL;
		}
	}

	return TRUE;
}

void CGlobalUtils::AdjustRectToWorkArea(CRect& rect, CRect* pRectDelta)
{
	CPoint ptStart;

	if (m_bIsDragging)
	{
		::GetCursorPos(&ptStart);
	}
	else
	{
		ptStart = rect.TopLeft();
	}

	CRect rectScreen;
	MONITORINFO mi;
	mi.cbSize = sizeof(MONITORINFO);
	if (GetMonitorInfo(MonitorFromPoint(ptStart, MONITOR_DEFAULTTONEAREST), &mi))
	{
		rectScreen = mi.rcWork;
	}
	else
	{
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectScreen, 0);
	}

	int nDelta = pRectDelta != NULL ? pRectDelta->left : 0;

	if (rect.right <= rectScreen.left + nDelta)
	{
		rect.OffsetRect(rectScreen.left - rect.right + nDelta, 0);
	}

	nDelta = pRectDelta != NULL ? pRectDelta->right : 0;
	if (rect.left >= rectScreen.right - nDelta)
	{
		rect.OffsetRect(rectScreen.right - rect.left - nDelta, 0);
	}

	nDelta = pRectDelta != NULL ? pRectDelta->bottom : 0;
	if (rect.top >= rectScreen.bottom - nDelta)
	{
		rect.OffsetRect(0, rectScreen.bottom - rect.top - nDelta);
	}

	nDelta = pRectDelta != NULL ? pRectDelta->top : 0;
	if (rect.bottom < rectScreen.top + nDelta)
	{
		rect.OffsetRect(0, rectScreen.top - rect.bottom + nDelta);
	}
}

void CGlobalUtils::ForceAdjustLayout(CDockingManager* pDockManager, BOOL bForce, BOOL bForceInvisible)
{
	if (pDockManager != NULL &&(CPane::m_bHandleMinSize || bForce))
	{
		CWnd* pDockSite = pDockManager->GetDockSiteFrameWnd();

		if (pDockSite == NULL)
		{
			return;
		}

		if (!pDockSite->IsWindowVisible() && !bForceInvisible)
		{
			return;
		}

		CRect rectWnd;
		pDockManager->GetDockSiteFrameWnd()->SetRedraw(FALSE);
		pDockManager->GetDockSiteFrameWnd()->GetWindowRect(rectWnd);
		pDockManager->GetDockSiteFrameWnd()->SetWindowPos(NULL, -1, -1, rectWnd.Width() + 1, rectWnd.Height() + 1, SWP_NOZORDER |  SWP_NOMOVE | SWP_NOACTIVATE);
		pDockManager->GetDockSiteFrameWnd()->SetWindowPos(NULL, -1, -1, rectWnd.Width(), rectWnd.Height(), SWP_NOZORDER |  SWP_NOMOVE  | SWP_NOACTIVATE);
		pDockManager->GetDockSiteFrameWnd()->SetRedraw(TRUE);
		pDockManager->GetDockSiteFrameWnd()->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
	}
}

BOOL CGlobalUtils::StringFromCy(CString& str, CY& cy)
{
	VARIANTARG varCy;
	VARIANTARG varBstr;
	AfxVariantInit(&varCy);
	AfxVariantInit(&varBstr);
	V_VT(&varCy) = VT_CY;
	V_CY(&varCy) = cy;
	if (FAILED(VariantChangeType(&varBstr, &varCy, 0, VT_BSTR)))
	{
		VariantClear(&varCy);
		VariantClear(&varBstr);
		return FALSE;
	}
	str = V_BSTR(&varBstr);
	VariantClear(&varCy);
	VariantClear(&varBstr);
	return TRUE;
}

BOOL CGlobalUtils::CyFromString(CY& cy, LPCTSTR psz)
{
	USES_CONVERSION;

	if (psz == NULL || _tcslen(psz) == 0)
	{
		psz = _T("0");
	}

	VARIANTARG varBstr;
	VARIANTARG varCy;
	AfxVariantInit(&varBstr);
	AfxVariantInit(&varCy);
	V_VT(&varBstr) = VT_BSTR;
	V_BSTR(&varBstr) = SysAllocString(T2COLE(psz));
	if (FAILED(VariantChangeType(&varCy, &varBstr, 0, VT_CY)))
	{
		VariantClear(&varBstr);
		VariantClear(&varCy);
		return FALSE;
	}
	cy = V_CY(&varCy);
	VariantClear(&varBstr);
	VariantClear(&varCy);
	return TRUE;
}

BOOL CGlobalUtils::StringFromDecimal(CString& str, DECIMAL& decimal)
{
	VARIANTARG varDecimal;
	VARIANTARG varBstr;
	AfxVariantInit(&varDecimal);
	AfxVariantInit(&varBstr);
	V_VT(&varDecimal) = VT_DECIMAL;
	V_DECIMAL(&varDecimal) = decimal;
	if (FAILED(VariantChangeType(&varBstr, &varDecimal, 0, VT_BSTR)))
	{
		VariantClear(&varDecimal);
		VariantClear(&varBstr);
		return FALSE;
	}
	str = V_BSTR(&varBstr);
	VariantClear(&varDecimal);
	VariantClear(&varBstr);
	return TRUE;
}

BOOL CGlobalUtils::DecimalFromString(DECIMAL& decimal, LPCTSTR psz)
{
	USES_CONVERSION;

	if (psz == NULL || _tcslen(psz) == 0)
	{
		psz = _T("0");
	}

	VARIANTARG varBstr;
	VARIANTARG varDecimal;
	AfxVariantInit(&varBstr);
	AfxVariantInit(&varDecimal);
	V_VT(&varBstr) = VT_BSTR;
	V_BSTR(&varBstr) = SysAllocString(T2COLE(psz));
	if (FAILED(VariantChangeType(&varDecimal, &varBstr, 0, VT_DECIMAL)))
	{
		VariantClear(&varBstr);
		VariantClear(&varDecimal);
		return FALSE;
	}
	decimal = V_DECIMAL(&varDecimal);
	VariantClear(&varBstr);
	VariantClear(&varDecimal);
	return TRUE;
}

HICON CGlobalUtils::GetWndIcon(CWnd* pWnd)
{
	ASSERT_VALID(pWnd);

	if (pWnd->GetSafeHwnd() == NULL)
	{
		return NULL;
	}

	HICON hIcon = pWnd->GetIcon(FALSE);

	if (hIcon == NULL)
	{
		hIcon = pWnd->GetIcon(TRUE);

		if (hIcon != NULL)
		{
			CImageList il;
			il.Create(16, 16, ILC_COLOR32 | ILC_MASK, 0, 1);
			il.Add(hIcon);

			if (il.GetImageCount() == 1)
			{
				hIcon = il.ExtractIcon(0);
			}
		}
	}

	if (hIcon == NULL)
	{
		hIcon = (HICON)(LONG_PTR)::GetClassLongPtr(pWnd->GetSafeHwnd(), GCLP_HICONSM);
	}

	if (hIcon == NULL)
	{
		hIcon = (HICON)(LONG_PTR)::GetClassLongPtr(pWnd->GetSafeHwnd(), GCLP_HICON);
	}

	return hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxframeimpl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxframeimpl.h"
#include "afxtoolbar.h"
#include "afxmenubar.h"
#include "afxribbonres.h"
#include "afxpopupmenu.h"
#include "afxtoolbarmenubutton.h"
#include "afxwinappex.h"
#include "afxregpath.h"
#include "afxsettingsstore.h"
#include "afxmenutearoffmanager.h"
#include "afxdocksite.h"
#include "afxkeyboardmanager.h"
#include "afxpaneframewnd.h"
#include "afxpreviewviewex.h"
#include "afxcustomizemenubutton.h"
#include "afxcustomizebutton.h"
#include "afxtoolbarscustomizedialog.h"
#include "afxvisualmanager.h"
#include "afxdropdowntoolbar.h"
#include "afxmdiframewndex.h"
#include "afxframewndex.h"
#include "afxoleipframewndex.h"
#include "afxoledocipframewndex.h"
#include "afxribbonbar.h"
#include "afxribbonstatusbar.h"
#include "afxcaptionbutton.h"
#include "afxglobalutils.h"
#include "afxdropdownlistbox.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

extern CObList afxAllToolBars;

class CMFCCustomizeButton;

static const CString strTearOffBarsRegEntry = _T("ControlBars-TearOff");

BOOL CFrameImpl::m_bControlBarExtraPixel = TRUE;
CList<CFrameWnd*, CFrameWnd*> CFrameImpl::m_lstFrames;

UINT AFX_WM_POSTSETPREVIEWFRAME = ::RegisterWindowMessage(_T("AFX_WM_POSTSETPREVIEWFRAME"));

#pragma warning(disable : 4355)

// Construction/Destruction
CFrameImpl::CFrameImpl(CFrameWnd* pFrame) : m_pFrame(pFrame), m_pDockManager(NULL), m_uiUserToolbarFirst((UINT)-1), m_uiUserToolbarLast((UINT)-1), m_pMenuBar(NULL), m_hDefaultMenu(NULL), m_nIDDefaultResource(0), m_FullScreenMgr(this), m_bLoadDockState(TRUE), m_uiControlbarsMenuEntryID(0), m_bViewMenuShowsToolbarsOnly(FALSE), m_pRibbonBar(NULL), m_pRibbonStatusBar(NULL), m_bCaptured(FALSE), m_nHotSysButton(HTNOWHERE), m_nHitSysButton(HTNOWHERE), m_bIsWindowRgn(FALSE), m_bHasBorder(FALSE), m_bIsOleInPlaceActive(FALSE), m_bHadCaption(TRUE), m_bWindowPosChanging(FALSE)
{
	ASSERT_VALID(m_pFrame);

	m_pCustomUserToolBarRTC = RUNTIME_CLASS(CMFCToolBar);
	m_rectRedraw.SetRectEmpty();

	m_bIsMDIChildFrame = m_pFrame->IsKindOf(RUNTIME_CLASS(CMDIChildWnd));
}

#pragma warning(default : 4355)

CFrameImpl::~CFrameImpl()
{
	// Clear user-defined toolbars:
	while (!m_listUserDefinedToolbars.IsEmpty())
	{
		delete m_listUserDefinedToolbars.RemoveHead();
	}

	// Clear tear-off toolbars:
	while (!m_listTearOffToolbars.IsEmpty())
	{
		delete m_listTearOffToolbars.RemoveHead();
	}

	// Clear caption system buttons:
	while (!m_lstCaptionSysButtons.IsEmpty())
	{
		delete m_lstCaptionSysButtons.RemoveHead();
	}
}

void CFrameImpl::OnCloseFrame()
{
	ASSERT_VALID(m_pFrame);

	// Automatically load state and frame position if CWinAppEx is used:
	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp != NULL)
	{
		if (m_FullScreenMgr.IsFullScreen())
		{
			if (::IsWindow(m_pFrame->GetSafeHwnd()))
			{
				m_FullScreenMgr.RestoreState(m_pFrame);
			}
		}

		pApp->OnClosingMainFrame(this);

		// Store the Windowplacement:
		StoreWindowPlacement();
	}
}

void CFrameImpl::StoreWindowPlacement()
{
	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp != NULL && ::IsWindow(m_pFrame->GetSafeHwnd()))
	{
		WINDOWPLACEMENT wp;
		wp.length = sizeof(WINDOWPLACEMENT);

		if (m_pFrame->GetWindowPlacement(&wp))
		{
			// Make sure we don't pop up
			// minimized the next time
			if (wp.showCmd != SW_SHOWMAXIMIZED)
			{
				wp.showCmd = SW_SHOWNORMAL;
			}

			RECT rectDesktop;
			SystemParametersInfo(SPI_GETWORKAREA,0, (PVOID)&rectDesktop,0);
			OffsetRect(&wp.rcNormalPosition, rectDesktop.left, rectDesktop.top);

			pApp->StoreWindowPlacement(wp.rcNormalPosition, wp.flags, wp.showCmd);
		}
	}
}

void CFrameImpl::RestorePosition(CREATESTRUCT& cs)
{
	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp != NULL && cs.hInstance != NULL)
	{
		CRect rectNormal(CPoint(cs.x, cs.y), CSize(cs.cx, cs.cy));
		int nFlags = 0;
		int nShowCmd = SW_SHOWNORMAL;

		if (!pApp->LoadWindowPlacement(rectNormal, nFlags, nShowCmd))
		{
			return;
		}

		if (nShowCmd != SW_MAXIMIZE)
		{
			nShowCmd = SW_SHOWNORMAL;
		}

		switch (AfxGetApp()->m_nCmdShow)
		{
		case SW_MAXIMIZE:
		case SW_MINIMIZE:
		case SW_SHOWMINIMIZED:
		case SW_SHOWMINNOACTIVE:
			break; // don't change!

		default:
			AfxGetApp()->m_nCmdShow = nShowCmd;
		}

		CRect rectDesktop;
		CRect rectInter;

		MONITORINFO mi;
		mi.cbSize = sizeof(MONITORINFO);
		if (GetMonitorInfo(MonitorFromPoint(rectNormal.TopLeft(), MONITOR_DEFAULTTONEAREST), &mi))
		{
			rectDesktop = mi.rcWork;
		}
		else
		{
			::SystemParametersInfo(SPI_GETWORKAREA, 0, &rectDesktop, 0);
		}

		if (nShowCmd == SW_MAXIMIZE)
		{
			cs.x = rectDesktop.left;
			cs.y = rectDesktop.top;
			cs.cx = rectDesktop.Width();
			cs.cy = rectDesktop.Height();

			return;
		}

		if (rectInter.IntersectRect(&rectDesktop, &rectNormal))
		{
			cs.x = rectInter.left;
			cs.y = rectInter.top;
			cs.cx = rectNormal.Width();
			cs.cy = rectNormal.Height();
		}
	}
}

void CFrameImpl::OnLoadFrame()
{
	ASSERT_VALID(m_pFrame);

	// Automatically load state if CWinAppEx is used:
	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp != NULL)
	{
		pApp->LoadState(0, this);
	}

	if (m_pRibbonStatusBar->GetSafeHwnd() != NULL)
	{
		m_pFrame->SetWindowPos(NULL, -1, -1, -1, -1, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
	}
	else if (m_pRibbonBar->GetSafeHwnd() != NULL)
	{
		m_pRibbonBar->RecalcLayout();
	}

	afxGlobalData.m_bIsRTL = (m_pFrame->GetExStyle() & WS_EX_LAYOUTRTL);
}

void CFrameImpl::LoadUserToolbars()
{
	ASSERT_VALID(m_pFrame);
	ENSURE(m_pCustomUserToolBarRTC != NULL);

	if (m_uiUserToolbarFirst == (UINT) -1 || m_uiUserToolbarLast == (UINT) -1)
	{
		return;
	}

	for (UINT uiNewToolbarID = m_uiUserToolbarFirst; uiNewToolbarID <= m_uiUserToolbarLast; uiNewToolbarID ++)
	{
		CMFCToolBar* pNewToolbar = (CMFCToolBar*) m_pCustomUserToolBarRTC->CreateObject();
		if (!pNewToolbar->Create(m_pFrame, AFX_DEFAULT_TOOLBAR_STYLE, uiNewToolbarID))
		{
			TRACE0("Failed to create a new toolbar!\n");
			delete pNewToolbar;
			continue;
		}

		if (!pNewToolbar->LoadState(m_strControlBarRegEntry))
		{
			pNewToolbar->DestroyWindow();
			delete pNewToolbar;
		}
		else
		{
			pNewToolbar->SetPaneStyle(pNewToolbar->GetPaneStyle() | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
			pNewToolbar->EnableDocking(CBRS_ALIGN_ANY);

			ASSERT_VALID(m_pDockManager);
			m_pDockManager->DockPane(pNewToolbar);
			m_listUserDefinedToolbars.AddTail(pNewToolbar);
		}
	}
}

void CFrameImpl::SaveUserToolbars(BOOL bFrameBarsOnly)
{
	for (POSITION pos = m_listUserDefinedToolbars.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBar* pUserToolBar = (CMFCToolBar*) m_listUserDefinedToolbars.GetNext(pos);
		ASSERT_VALID(pUserToolBar);

		if (!bFrameBarsOnly || pUserToolBar->GetTopLevelFrame() == m_pFrame)
		{
			pUserToolBar->SaveState(m_strControlBarRegEntry);
		}
	}
}

CMFCToolBar* CFrameImpl::GetUserToolBarByIndex(int iIndex) const
{
	POSITION pos = m_listUserDefinedToolbars.FindIndex(iIndex);
	if (pos == NULL)
	{
		return NULL;
	}

	CMFCToolBar* pUserToolBar = (CMFCToolBar*) m_listUserDefinedToolbars.GetAt(pos);
	ASSERT_VALID(pUserToolBar);

	return pUserToolBar;
}

BOOL CFrameImpl::IsUserDefinedToolbar(const CMFCToolBar* pToolBar) const
{
	ASSERT_VALID(pToolBar);

	UINT uiCtrlId = pToolBar->GetDlgCtrlID();
	return uiCtrlId >= m_uiUserToolbarFirst && uiCtrlId <= m_uiUserToolbarLast;
}

BOOL CFrameImpl::IsDockStateValid(const CDockState& /*state*/)
{
	ASSERT_VALID(m_pFrame);
	return TRUE;
}

void CFrameImpl::InitUserToolbars( LPCTSTR lpszRegEntry, UINT uiUserToolbarFirst, UINT uiUserToolbarLast)
{
	ASSERT(uiUserToolbarLast >= uiUserToolbarFirst);

	if (uiUserToolbarFirst == (UINT) -1 || uiUserToolbarLast == (UINT) -1)
	{
		ASSERT(FALSE);
		return;
	}

	m_uiUserToolbarFirst = uiUserToolbarFirst;
	m_uiUserToolbarLast = uiUserToolbarLast;

	// Get Path automatically from CWinAppEx if needed
	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());

	m_strControlBarRegEntry = (lpszRegEntry == NULL) ? (pApp != NULL ? pApp->GetRegSectionPath() : _T("") ) : lpszRegEntry;
}

UINT __stdcall CFrameImpl::GetFreeCtrlBarID(UINT uiFirstID, UINT uiLastID, const CObList& lstCtrlBars)
{
	if (uiFirstID == (UINT)-1 || uiLastID == (UINT)-1)
	{
		return 0;
	}

	int iMaxToolbars = uiLastID - uiFirstID + 1;
	if (lstCtrlBars.GetCount() == iMaxToolbars)
	{
		return 0;
	}

	for (UINT uiNewToolbarID = uiFirstID; uiNewToolbarID <= uiLastID; uiNewToolbarID ++)
	{
		BOOL bUsed = FALSE;

		for (POSITION pos = lstCtrlBars.GetHeadPosition(); !bUsed && pos != NULL;)
		{
			CMFCToolBar* pToolBar = (CMFCToolBar*) lstCtrlBars.GetNext(pos);
			ASSERT_VALID(pToolBar);

			bUsed = (pToolBar->GetDlgCtrlID() == (int) uiNewToolbarID);
		}

		if (!bUsed)
		{
			return uiNewToolbarID;
		}
	}

	return 0;
}

void CFrameImpl::SetNewUserToolBarRTC(CRuntimeClass* pCustomUserToolBarRTC)
{
	ENSURE(pCustomUserToolBarRTC != NULL);
	m_pCustomUserToolBarRTC = pCustomUserToolBarRTC;
}

const CMFCToolBar* CFrameImpl::CreateNewToolBar(LPCTSTR lpszName)
{
	ASSERT_VALID(m_pFrame);
	ENSURE(lpszName != NULL);

	UINT uiNewToolbarID = GetFreeCtrlBarID(m_uiUserToolbarFirst, m_uiUserToolbarLast, m_listUserDefinedToolbars);

	if (uiNewToolbarID == 0)
	{
		CString strError;
		strError.Format(IDS_AFXBARRES_TOO_MANY_TOOLBARS_FMT, m_uiUserToolbarLast - m_uiUserToolbarFirst + 1);

		AfxMessageBox(strError, MB_OK | MB_ICONASTERISK);
		return NULL;
	}

	CMFCToolBar* pNewToolbar = (CMFCToolBar*) m_pCustomUserToolBarRTC->CreateObject();
	if (!pNewToolbar->Create(m_pFrame, AFX_DEFAULT_TOOLBAR_STYLE, uiNewToolbarID))
	{
		TRACE0("Failed to create a new toolbar!\n");
		delete pNewToolbar;
		return NULL;
	}

	pNewToolbar->SetWindowText(lpszName);

	pNewToolbar->SetPaneStyle(pNewToolbar->GetPaneStyle() | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
	pNewToolbar->EnableDocking(CBRS_ALIGN_ANY);

	CRect rectBar;
	pNewToolbar->GetWindowRect(rectBar);
	int nLeft = ::GetSystemMetrics(SM_CXFULLSCREEN) / 2;
	int nTop  = ::GetSystemMetrics(SM_CYFULLSCREEN) / 2;

	CRect rectFloat(nLeft, nTop, nLeft + rectBar.Width(), nTop + rectBar.Height());
	pNewToolbar->FloatPane(rectFloat, DM_UNKNOWN);
	pNewToolbar->m_nMRUWidth = 32767;
	m_pFrame->RecalcLayout();

	m_listUserDefinedToolbars.AddTail(pNewToolbar);
	return pNewToolbar;
}

void CFrameImpl::AddTearOffToolbar(CBasePane* pToolBar)
{
	ASSERT_VALID(pToolBar);
	m_listTearOffToolbars.AddTail(pToolBar);
}

void CFrameImpl::RemoveTearOffToolbar(CBasePane* pToolBar)
{
	ASSERT_VALID(pToolBar);

	POSITION pos = m_listTearOffToolbars.Find(pToolBar);
	if (pos != NULL)
	{
		m_listTearOffToolbars.RemoveAt(pos);
	}
}

void CFrameImpl::LoadTearOffMenus()
{
	ASSERT_VALID(m_pFrame);

	// Remove current tear-off bars:
	for (POSITION pos = m_listTearOffToolbars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pBar = (CBasePane*) m_listTearOffToolbars.GetNext(pos);
		ASSERT_VALID(pBar);

		if (pBar->IsDocked())
		{
			pBar->UndockPane(TRUE);
		}

		pBar->DestroyWindow();
		delete pBar;
	}

	m_listTearOffToolbars.RemoveAll();

	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	CString strProfileName = pApp != NULL ? pApp->GetRegSectionPath() : _T("");

	strProfileName += strTearOffBarsRegEntry;

	for (int iIndex = 0;; iIndex++)
	{
		CString strKey;
		strKey.Format(_T("%s-%d"), (LPCTSTR)strProfileName, iIndex);

		int iId = 0;
		CMFCToolBar* pToolBar = NULL;
		CString strName;

		CSettingsStoreSP regSP;
		CSettingsStore& reg = regSP.Create(FALSE, TRUE);

		if (!reg.Open(strKey) || !reg.Read(_T("ID"), iId) || !reg.Read(_T("Name"), strName) || !reg.Read(_T("State"), (CObject*&) pToolBar))
		{
			break;
		}

		ASSERT_VALID(pToolBar);

		if (!pToolBar->Create(m_pFrame, AFX_DEFAULT_TOOLBAR_STYLE, (UINT) iId))
		{
			TRACE0("Failed to create a new toolbar!\n");
			delete pToolBar;
			break;
		}

		pToolBar->SetWindowText(strName);

		pToolBar->SetPaneStyle(pToolBar->GetPaneStyle() | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
		pToolBar->EnableDocking(CBRS_ALIGN_ANY);

		ASSERT_VALID(m_pDockManager);
		m_listTearOffToolbars.AddTail(pToolBar);
		pToolBar->LoadState(strProfileName, iIndex);
		m_pDockManager->DockPane(pToolBar);
	}
}

void CFrameImpl::SaveTearOffMenus(BOOL bFrameBarsOnly)
{
	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());

	CString strProfileName = pApp != NULL ? pApp->GetRegSectionPath() : _T("");
	strProfileName += strTearOffBarsRegEntry;

	int iIndex = 0;

	// First, clear old tear-off toolbars in registry:
	for (iIndex = 0;; iIndex++)
	{
		CString strKey;
		strKey.Format(_T("%s-%d"), (LPCTSTR)strProfileName, iIndex);

		CSettingsStoreSP regSP;
		CSettingsStore& reg = regSP.Create(FALSE, FALSE);

		if (!reg.DeleteKey(strKey))
		{
			break;
		}
	}

	iIndex = 0;

	for (POSITION pos = m_listTearOffToolbars.GetHeadPosition(); pos != NULL; iIndex ++)
	{
		CBasePane* pBar = (CBasePane*) m_listTearOffToolbars.GetNext(pos);
		ASSERT_VALID(pBar);

		if ((!bFrameBarsOnly || pBar->GetTopLevelFrame() == m_pFrame) && pBar->IsPaneVisible())
		{
			CString strName;
			pBar->GetWindowText(strName);

			CString strKey;
			strKey.Format(_T("%s-%d"), (LPCTSTR)strProfileName, iIndex);

			CSettingsStoreSP regSP;
			CSettingsStore& reg = regSP.Create(FALSE, FALSE);

			reg.CreateKey(strKey);

			reg.Write(_T("ID"), (int) pBar->GetDlgCtrlID());
			reg.Write(_T("Name"), strName);
			reg.Write(_T("State"), pBar);
			pBar->SaveState(strProfileName, iIndex);
		}
	}
}

BOOL CFrameImpl::DeleteToolBar(CMFCToolBar* pToolBar)
{
	ASSERT_VALID(m_pFrame);
	ASSERT_VALID(pToolBar);

	POSITION pos = m_listUserDefinedToolbars.Find(pToolBar);
	if (pos == NULL)
	{
		return FALSE;
	}

	m_listUserDefinedToolbars.RemoveAt(pos);
	pToolBar->RemoveStateFromRegistry(m_strControlBarRegEntry);

	CDockSite* pParentDockBar = pToolBar->GetParentDockSite();
	CPaneFrameWnd* pParentMiniFrame = pToolBar->GetParentMiniFrame();
	if (pParentDockBar != NULL)
	{
		ASSERT_VALID(pParentDockBar);
		pParentDockBar->RemovePane(pToolBar, DM_UNKNOWN);
	}
	else if (pParentMiniFrame != NULL)
	{
		ASSERT_VALID(pParentMiniFrame);
		pParentMiniFrame->RemovePane(pToolBar);
	}

	pToolBar->DestroyWindow();
	delete pToolBar;

	m_pFrame->RecalcLayout();
	return TRUE;
}

void CFrameImpl::SetMenuBar(CMFCMenuBar* pMenuBar)
{
	ASSERT_VALID(m_pFrame);
	ASSERT_VALID(pMenuBar);
	ENSURE(m_pMenuBar == NULL); // Method should be called once!

	m_pMenuBar = pMenuBar;

	m_hDefaultMenu=*m_pFrame->GetMenu();

	// Support for dynamic menu
	m_pMenuBar->OnDefaultMenuLoaded(m_hDefaultMenu);
	m_pMenuBar->CreateFromMenu(m_hDefaultMenu, TRUE /* Default menu */);

	m_pFrame->SetMenu(NULL);

	m_pMenuBar->SetDefaultMenuResId(m_nIDDefaultResource);
}

BOOL CFrameImpl::ProcessKeyboard(int nKey, BOOL* pbProcessAccel)
{
	ASSERT_VALID(m_pFrame);

	if (pbProcessAccel != NULL)
	{
		*pbProcessAccel = TRUE;
	}

	// If popup menu is active, pass keyboard control to menu:
	if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd))
	{
		CWnd* pFocus = CWnd::GetFocus();

		if (CMFCPopupMenu::m_pActivePopupMenu->IsRibbonMiniToolBar())
		{
			BOOL bIsFloatyActive = (pFocus->GetSafeHwnd() != NULL &&
				(CMFCPopupMenu::m_pActivePopupMenu->IsChild(pFocus) || pFocus->GetSafeHwnd() == CMFCPopupMenu::m_pActivePopupMenu->GetSafeHwnd()));

			if (bIsFloatyActive)
			{
				return FALSE;
			}

			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);
			return FALSE;
		}

		if (pFocus->GetSafeHwnd() != NULL && CMFCPopupMenu::m_pActivePopupMenu->IsChild(pFocus))
		{
			return FALSE;
		}

		BOOL bIsDropList = CMFCPopupMenu::m_pActivePopupMenu->GetMenuBar()->IsDropDownListMode();

		CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_KEYDOWN, nKey);
		if (!bIsDropList)
		{
			return TRUE;
		}

		CMFCDropDownListBox* pDropDownList = DYNAMIC_DOWNCAST(CMFCDropDownListBox, CMFCPopupMenu::m_pActivePopupMenu);

		return pDropDownList == NULL || !pDropDownList->IsEditFocused();
	}

	// If appication is minimized, don't handle
	// any keyboard accelerators:
	if (m_pFrame->IsIconic())
	{
		return TRUE;
	}

	// Don't handle keybaord accererators in customization mode:
	if (CMFCToolBar::IsCustomizeMode())
	{
		return FALSE;
	}

	// Is any toolbar control(such as combobox) has focus?
	BOOL bIsToolbarCtrlFocus = FALSE;
	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); !bIsToolbarCtrlFocus && posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);

			for (int i = 0; i < pToolBar->GetCount(); i++)
			{
				CMFCToolBarButton* pButton = pToolBar->GetButton(i);
				ASSERT_VALID(pButton);

				if (pButton->HasFocus())
				{
					bIsToolbarCtrlFocus = TRUE;
					break;
				}
			}
		}
	}

	// Check for the keyboard accelerators:
	BYTE fVirt = 0;

	if (::GetAsyncKeyState(VK_CONTROL) & 0x8000)
	{
		fVirt |= FCONTROL;
	}

	if (::GetAsyncKeyState(VK_MENU) & 0x8000)
	{
		fVirt |= FALT;
	}

	if (::GetAsyncKeyState(VK_SHIFT) & 0x8000)
	{
		fVirt |= FSHIFT;
	}

	if (!bIsToolbarCtrlFocus)
	{
		if (CKeyboardManager::IsKeyHandled((WORD) nKey, (BYTE)(fVirt | FVIRTKEY), m_pFrame, TRUE) ||
			CKeyboardManager::IsKeyHandled((WORD) nKey, (BYTE)(fVirt | FVIRTKEY), m_pFrame->GetActiveFrame(), FALSE))
		{
			return FALSE;
		}
	}

	if (m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible() && fVirt == FCONTROL && nKey == VK_F1 && m_pRibbonBar->GetActiveCategory() != NULL)
	{
		m_pRibbonBar->ToggleMimimizeState();
		return TRUE;
	}

	if (fVirt == FALT)
	{
		// Handle menu accelerators(such as "Alt-F"):
		if (OnMenuChar(nKey))
		{
			return TRUE;
		}
	}

	if (bIsToolbarCtrlFocus && pbProcessAccel != NULL)
	{
		// Don't process default keyboard accelerators:
		*pbProcessAccel = FALSE;
	}

	return FALSE;
}

BOOL CFrameImpl::ProcessMouseClick(UINT uiMsg, POINT pt, HWND hwnd)
{
	ASSERT_VALID(m_pFrame);

	if (m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible())
	{
		CRect rectRibbon;
		m_pRibbonBar->GetWindowRect (rectRibbon);

		m_pRibbonBar->DeactivateKeyboardFocus (rectRibbon.PtInRect (pt));
	}

	// Maybe user start drag the button with control?
	if (uiMsg == WM_LBUTTONDOWN && (CMFCToolBar::IsCustomizeMode() || (::GetAsyncKeyState(VK_MENU) & 0x8000))) // ALT is pressed
	{
		for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
		{
			CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
			ENSURE(pToolBar != NULL);

			if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
			{
				ASSERT_VALID(pToolBar);

				CPoint ptToolBar = pt;
				pToolBar->ScreenToClient(&ptToolBar);

				int iHit = pToolBar->HitTest(ptToolBar);
				if (iHit >= 0)
				{
					CMFCToolBarButton* pButton = pToolBar->GetButton(iHit);
					ASSERT_VALID(pButton);

					if (pButton->GetHwnd() != NULL && pButton->GetHwnd() == hwnd && pButton->Rect().PtInRect(ptToolBar))
					{
						pToolBar->SendMessage(WM_LBUTTONDOWN, 0, MAKELPARAM(ptToolBar.x, ptToolBar.y));
						return TRUE;
					}

					break;
				}
			}
		}
	}

	BOOL bStopProcessing = FALSE;

	if (!CMFCToolBar::IsCustomizeMode() && CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd))
	{
		CMFCPopupMenu::MENUAREA_TYPE clickArea = CMFCPopupMenu::m_pActivePopupMenu->CheckArea(pt);

		if (clickArea == CMFCPopupMenu::OUTSIDE)
		{
			// Click outside of menu
			// Maybe click on connected floaty?
			CMFCPopupMenu* pMenuWithFloaty = CMFCPopupMenu::FindMenuWithConnectedFloaty();

			if (pMenuWithFloaty != NULL && ::IsWindow(pMenuWithFloaty->m_hwndConnectedFloaty))
			{
				CRect rectFloaty;
				::GetWindowRect(pMenuWithFloaty->m_hwndConnectedFloaty, &rectFloaty);

				if (rectFloaty.PtInRect(pt))
				{
					// Disconnect floaty from the menu:

					CMFCPopupMenu* pFloaty = DYNAMIC_DOWNCAST(CMFCPopupMenu, CWnd::FromHandlePermanent(pMenuWithFloaty->m_hwndConnectedFloaty));

					pMenuWithFloaty->m_hwndConnectedFloaty = NULL;
					pMenuWithFloaty->SendMessage(WM_CLOSE);

					CMFCPopupMenu::m_pActivePopupMenu = pFloaty;
					return FALSE;
				}
			}

			// Maybe secondary click on the parent button?
			CRect rectParentBtn;
			CWnd* pWndParent = CMFCPopupMenu::m_pActivePopupMenu-> GetParentArea(rectParentBtn);

			if (pWndParent != NULL)
			{
				CMFCPopupMenuBar* pWndParentPopupMenuBar = DYNAMIC_DOWNCAST(CMFCPopupMenuBar, pWndParent);

				CPoint ptClient = pt;
				pWndParent->ScreenToClient(&ptClient);

				if (rectParentBtn.PtInRect(ptClient))
				{
					// If user clicks second time on the parent button,
					// we should close an active menu on the toolbar/menubar
					// and leave it on the popup menu:
					if ((pWndParentPopupMenuBar == NULL || pWndParentPopupMenuBar->IsRibbonPanelInRegularMode()) && !CMFCPopupMenu::m_pActivePopupMenu->InCommand())
					{
						// Toolbar/menu bar: close an active menu!
						CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);
					}
					else if ((uiMsg == WM_RBUTTONDOWN || uiMsg == WM_RBUTTONUP) && CMFCPopupMenu::m_pActivePopupMenu->GetParentRibbonElement() != NULL)
					{
						return FALSE;
					}

					return TRUE;
				}

				if (pWndParentPopupMenuBar != NULL && !pWndParentPopupMenuBar->IsRibbonPanelInRegularMode())
				{
					pWndParentPopupMenuBar->CloseDelayedSubMenu();

					CMFCPopupMenu* pWndParentPopupMenu = DYNAMIC_DOWNCAST(CMFCPopupMenu, pWndParentPopupMenuBar->GetParent());

					if (pWndParentPopupMenu != NULL)
					{
						CMFCPopupMenu::MENUAREA_TYPE clickAreaParent = pWndParentPopupMenu->CheckArea(pt);

						switch (clickAreaParent)
						{
						case CMFCPopupMenu::MENU:
						case CMFCPopupMenu::TEAROFF_CAPTION:
						case CMFCPopupMenu::LOGO:
							return FALSE;

						case CMFCPopupMenu::SHADOW_RIGHT:
						case CMFCPopupMenu::SHADOW_BOTTOM:
							pWndParentPopupMenu->SendMessage(WM_CLOSE);
							m_pFrame->SetFocus();

							return TRUE;
						}
					}
				}
			}

			if (!CMFCPopupMenu::m_pActivePopupMenu->InCommand())
			{
				bStopProcessing = !CMFCPopupMenu::m_pActivePopupMenu->DefaultMouseClickOnClose();

				CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);

				CWnd* pWndFocus = CWnd::GetFocus();
				if (pWndFocus != NULL && pWndFocus->IsKindOf(RUNTIME_CLASS(CMFCToolBar)))
				{
					m_pFrame->SetFocus();
				}

				if (clickArea != CMFCPopupMenu::OUTSIDE) // Click on shadow
				{
					return TRUE;
				}

				if (bStopProcessing)
				{
					// We need to stop processing in case of clicking inside the active view only!
					CView* pView = DYNAMIC_DOWNCAST(CView, CWnd::WindowFromPoint(pt));
					if (pView->GetSafeHwnd() == NULL)
					{
						bStopProcessing = FALSE;
					}
				}
			}
		}
		else if (clickArea == CMFCPopupMenu::SHADOW_RIGHT || clickArea == CMFCPopupMenu::SHADOW_BOTTOM)
		{
			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);
			m_pFrame->SetFocus();

			return TRUE;
		}
	}

	if (uiMsg == WM_NCRBUTTONUP && hwnd == m_pFrame->GetSafeHwnd() && IsOwnerDrawCaption())
	{
		UINT nHit = OnNcHitTest(pt);

		if (nHit == HTCAPTION || nHit == HTSYSMENU || nHit == HTMINBUTTON || nHit == HTMAXBUTTON || nHit == HTCLOSE)
		{
			CMenu* pMenu = m_pFrame->GetSystemMenu(FALSE);
			if (pMenu->GetSafeHmenu() != NULL && ::IsMenu(pMenu->GetSafeHmenu()))
			{
				pMenu->EnableMenuItem(SC_MAXIMIZE, MF_BYCOMMAND | MF_ENABLED);
				pMenu->EnableMenuItem(SC_RESTORE, MF_BYCOMMAND | MF_ENABLED);

				if (m_pFrame->IsZoomed())
				{
					pMenu->EnableMenuItem(SC_MAXIMIZE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
				}
				else if (!m_pFrame->IsIconic())
				{
					pMenu->EnableMenuItem(SC_RESTORE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
				}

				UINT uiRes = ::TrackPopupMenu (pMenu->GetSafeHmenu(), TPM_LEFTBUTTON | TPM_RETURNCMD, pt.x, pt.y, 0, m_pFrame->GetSafeHwnd(), NULL);
				if (uiRes != 0)
				{
					m_pFrame->SendMessage(WM_SYSCOMMAND, uiRes);
					bStopProcessing = TRUE;
				}
			}
		}
	}

	return bStopProcessing;
}

BOOL CFrameImpl::ProcessMouseMove(POINT pt)
{
	if (!CMFCToolBar::IsCustomizeMode() && CMFCPopupMenu::m_pActivePopupMenu != NULL)
	{
		CMFCPopupMenu* pMenuWithFloaty = CMFCPopupMenu::FindMenuWithConnectedFloaty();

		if (pMenuWithFloaty != NULL && ::IsWindow(pMenuWithFloaty->m_hwndConnectedFloaty))
		{
			CRect rectFloaty;
			::GetWindowRect(pMenuWithFloaty->m_hwndConnectedFloaty, &rectFloaty);

			if (rectFloaty.PtInRect(pt))
			{
				return FALSE; // Default processing
			}
		}

		CRect rectMenu;
		CMFCPopupMenu::m_pActivePopupMenu->GetWindowRect(rectMenu);

		if (rectMenu.PtInRect(pt) || CMFCPopupMenu::m_pActivePopupMenu->GetMenuBar()->FindDestintationToolBar(pt) != NULL)
		{
			return FALSE; // Default processing
		}

		return TRUE; // Active menu "capturing"
	}

	return FALSE; // Default processing
}

BOOL CFrameImpl::ProcessMouseWheel(WPARAM wParam, LPARAM lParam)
{
	if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd))
	{
		if (CMFCPopupMenu::m_pActivePopupMenu->IsScrollable())
		{
			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_MOUSEWHEEL, wParam, lParam);
		}

		if (CMFCPopupMenu::m_pActivePopupMenu->IsRibbonMiniToolBar ())
		{
			CWnd* pFocus = CWnd::GetFocus();

			BOOL bIsFloatyActive = (pFocus->GetSafeHwnd () != NULL && 
				(CMFCPopupMenu::m_pActivePopupMenu->IsChild (pFocus) || 
				pFocus->GetSafeHwnd () == CMFCPopupMenu::m_pActivePopupMenu->GetSafeHwnd ()));

			if (!bIsFloatyActive)
			{
				CMFCPopupMenu::m_pActivePopupMenu->SendMessage (WM_CLOSE);
			}
		}

		return TRUE;
	}

	if (m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible())
	{
		return(BOOL) m_pRibbonBar->SendMessage(WM_MOUSEWHEEL, wParam, lParam);
	}

	return FALSE;
}

BOOL CFrameImpl::OnShowPopupMenu(CMFCPopupMenu* pMenuPopup, CFrameWnd* /*pWndFrame*/)
{
	CSmartDockingManager* pSDMananger = m_pDockManager == NULL ? NULL : m_pDockManager->GetSmartDockingManagerPermanent();
	if (pSDMananger != NULL && pSDMananger->IsStarted())
	{
		return FALSE;
	}

	if (pMenuPopup != NULL && m_uiControlbarsMenuEntryID != 0)
	{
		CMFCPopupMenuBar* pPopupMenuBar = pMenuPopup->GetMenuBar();

		if (m_pDockManager != NULL && pPopupMenuBar->CommandToIndex(m_uiControlbarsMenuEntryID) >= 0)
		{
			if (CMFCToolBar::IsCustomizeMode())
			{
				return FALSE;
			}

			pMenuPopup->RemoveAllItems();

			CMenu menu;
			menu.CreatePopupMenu();

			m_pDockManager->BuildPanesMenu(menu, m_bViewMenuShowsToolbarsOnly);

			pMenuPopup->GetMenuBar()->ImportFromMenu((HMENU) menu, TRUE);
			m_pDockManager->m_bControlBarsMenuIsShown = TRUE;
		}
	}

	CMFCPopupMenu::m_pActivePopupMenu = pMenuPopup;

	if (pMenuPopup != NULL && IsCustomizePane(pMenuPopup))
	{
		ShowQuickCustomizePane(pMenuPopup);
	}

	if (pMenuPopup != NULL && !CMFCToolBar::IsCustomizeMode())
	{
		ASSERT_VALID(pMenuPopup);

		CBasePane* pTopLevelBar = NULL;

		for (CMFCPopupMenu* pMenu = pMenuPopup; pMenu != NULL; pMenu = pMenu->GetParentPopupMenu())
		{
			CMFCToolBarMenuButton* pParentButton = pMenu->GetParentButton();
			if (pParentButton == NULL)
			{
				break;
			}

			pTopLevelBar = DYNAMIC_DOWNCAST(CBasePane, pParentButton->GetParentWnd());
		}

		if (pTopLevelBar != NULL && !pTopLevelBar->IsKindOf(RUNTIME_CLASS(CMFCPopupMenuBar)))
		{
			ASSERT_VALID(pTopLevelBar);

			if (pTopLevelBar->IsDocked() && ::GetFocus() != pTopLevelBar->GetSafeHwnd() && CMFCPopupMenu::GetForceMenuFocus())
			{
				pTopLevelBar->SetFocus();
			}
		}
	}

	return TRUE;
}

void CFrameImpl::SetupToolbarMenu(CMenu& menu, const UINT uiViewUserToolbarCmdFirst, const UINT uiViewUserToolbarCmdLast)
{
	// Replace toolbar dummy items to the user-defined toolbar names:
	for (int i = 0; i < menu.GetMenuItemCount();)
	{
		UINT uiCmd = menu.GetMenuItemID(i);

		if (uiCmd >= uiViewUserToolbarCmdFirst && uiCmd <= uiViewUserToolbarCmdLast)
		{
			// "User toolbar" item. First check that toolbar number 'x' is exist:
			CMFCToolBar* pToolBar = GetUserToolBarByIndex(uiCmd - uiViewUserToolbarCmdFirst);
			if (pToolBar != NULL)
			{
				ASSERT_VALID(pToolBar);

				// Modify the current menu item text to the toolbar title and
				// move next:
				CString strToolbarName;
				pToolBar->GetWindowText(strToolbarName);

				menu.ModifyMenu(i ++, MF_BYPOSITION | MF_STRING, uiCmd, strToolbarName);
			}
			else
			{
				menu.DeleteMenu(i, MF_BYPOSITION);
			}
		}
		else // Not "user toolbar" item, move next
		{
			i ++;
		}
	}
}

BOOL CFrameImpl::OnMenuChar(UINT nChar)
{
	ASSERT_VALID(m_pFrame);

	if (m_pRibbonBar != NULL && (m_pRibbonBar->GetStyle() & WS_VISIBLE) && m_pRibbonBar->TranslateChar(nChar))
	{
		return TRUE;
	}

	BOOL bInPrintPreview = m_pDockManager != NULL && m_pDockManager->IsPrintPreviewValid();

	if (!bInPrintPreview)
	{
		if (m_pMenuBar != NULL && (m_pMenuBar->GetStyle() & WS_VISIBLE) && m_pMenuBar->TranslateChar(nChar))
		{
			return TRUE;
		}
	}

	for (POSITION posTlb = afxAllToolBars.GetHeadPosition(); posTlb != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(posTlb);
		ENSURE(pToolBar != NULL);

		if (bInPrintPreview && !pToolBar->IsKindOf(RUNTIME_CLASS(CMFCPrintPreviewToolBar)))
		{
			continue;
		}

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL && pToolBar != m_pMenuBar &&
			(pToolBar->GetStyle() & WS_VISIBLE) && pToolBar->GetTopLevelFrame() == m_pFrame && pToolBar->TranslateChar(nChar))
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CFrameImpl::SaveDockState(LPCTSTR lpszSectionName)
{
	if (m_pDockManager != NULL)
	{
		m_pDockManager->SaveState(lpszSectionName, m_nIDDefaultResource);
	}
}

void CFrameImpl::LoadDockState(LPCTSTR lpszSectionName)
{
	if (m_pDockManager != NULL && m_bLoadDockState)
	{
		m_pDockManager->LoadState(lpszSectionName, m_nIDDefaultResource);
	}
}

void CFrameImpl::SetDockState(const CDockState& /*state*/)
{
	ASSERT_VALID(m_pFrame);
	ASSERT_VALID(m_pDockManager);

	if (m_pDockManager != NULL)
	{
		m_pDockManager->SetDockState();
	}
}

BOOL __stdcall CFrameImpl::IsHelpKey(LPMSG lpMsg)
{
	return lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1 && !(HIWORD(lpMsg->lParam) & KF_REPEAT) &&
		GetKeyState(VK_SHIFT) >= 0 && GetKeyState(VK_CONTROL) >= 0 && GetKeyState(VK_MENU) >= 0;
}

void CFrameImpl::DeactivateMenu()
{
	if (!CMFCToolBar::IsCustomizeMode() && CMFCPopupMenu::m_pActivePopupMenu != NULL)
	{
		if (m_pMenuBar != NULL)
		{
			m_pMenuBar->Deactivate();
		}
	}

	if (m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible())
	{
		m_pRibbonBar->DeactivateKeyboardFocus(FALSE);
	}
}

BOOL CFrameImpl::LoadLargeIconsState()
{
	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp != NULL)
	{
		return CMFCToolBar::LoadLargeIconsState(pApp->GetRegSectionPath());
	}
	else
	{
		return FALSE;
	}
}

void CFrameImpl::ShowQuickCustomizePane(CMFCPopupMenu* pMenuPopup)
{
	// Get Actual toolbar pointer
	CMFCToolBar* pWndParentToolbar = NULL;

	CMFCPopupMenu* pPopupLevel2 = pMenuPopup->GetParentPopupMenu();
	if (pPopupLevel2 == NULL)
	{
		return;
	}

	CMFCPopupMenu* pPopupLevel1 = pPopupLevel2->GetParentPopupMenu();
	if (pPopupLevel1 == NULL)
	{
		return;
	}

	CMFCCustomizeButton* pCustom = (CMFCCustomizeButton*)pPopupLevel1->GetParentButton();
	if (pCustom == NULL)
	{
		//May be MiniFrameWnd
		CWnd* pFrame = pPopupLevel1->GetOwner();
		if (pFrame == NULL)
		{
			return;
		}

		if (pFrame->IsKindOf(RUNTIME_CLASS(CPaneFrameWnd)))
		{
			CPaneFrameWnd* pMinFrm = (CPaneFrameWnd*)pFrame;

			pWndParentToolbar = (CMFCToolBar*)pMinFrm->GetPane();

		}else
		{
			return;
		}
	}
	else
	{
		if (!pCustom->IsKindOf(RUNTIME_CLASS(CMFCCustomizeButton)))
		{
			return;
		}

		CMFCToolBar* pCurrentToolBar = pCustom->GetParentToolbar();

		CMFCToolBarMenuButton* btnDummy = pMenuPopup->GetMenuItem(0);
		int nID = _ttoi(btnDummy->m_strText);

		const CObList& lstAllToolbars = CMFCToolBar::GetAllToolbars();

		CMFCToolBar* pRealToolBar = NULL;
		for (POSITION pos = lstAllToolbars.GetHeadPosition(); pos != NULL;)
		{
			pRealToolBar = (CMFCToolBar*) lstAllToolbars.GetNext(pos);
			ENSURE(pRealToolBar != NULL);
			if (nID == pRealToolBar->GetDlgCtrlID() && pRealToolBar->IsAddRemoveQuickCustomize())
			{
				break;
			}

			pRealToolBar = NULL;
		}

		if (pRealToolBar == NULL)
		{
			pWndParentToolbar = pCurrentToolBar;
		}
		else
		{
			pWndParentToolbar = pRealToolBar;
		}
	}

	pMenuPopup->RemoveAllItems();

	CMFCToolBarsCustomizeDialog* pStdCust = new CMFCToolBarsCustomizeDialog(m_pFrame, TRUE, AFX_CUSTOMIZE_MENUAMPERS);

	CMFCCustomizeMenuButton::SetParentToolbar(pWndParentToolbar);

	// Populate pop-up menu
	UINT uiRealCount = 0;
	CMFCCustomizeMenuButton::m_mapPresentIDs.RemoveAll();

	UINT uiCount = pWndParentToolbar->GetCount();
	for (UINT i=0; i< uiCount; i++)
	{
		CMFCToolBarButton* pBtn = pWndParentToolbar->GetButton(i);

		if (pBtn->IsKindOf(RUNTIME_CLASS(CMFCCustomizeButton)) ||(pBtn->m_nStyle & TBBS_SEPARATOR))
		{
			continue;
		}

		CMFCCustomizeMenuButton::m_mapPresentIDs.SetAt(pBtn->m_nID, 0);

		//Find Command Text if empty
		CString strText = pBtn->m_strText;
		if (pBtn->m_strText.IsEmpty())
		{
			strText = pStdCust->GetCommandName(pBtn->m_nID);
		}

		UINT uiID = pBtn->m_nID;
		if ((pBtn->m_nID == 0) ||(pBtn->m_nID == -1))
		{
			uiID = AFX_CUSTOMIZE_INTERNAL_ID;
		}

		CMFCCustomizeMenuButton button(uiID, NULL, pBtn->GetImage(), strText, pBtn->m_bUserButton);
		button.SetItemIndex(i);
		pMenuPopup->InsertItem(button);

		uiRealCount++;
	}

	delete pStdCust;

	pMenuPopup->SetQuickCustomizeType(CMFCPopupMenu::QUICK_CUSTOMIZE_PANE);

	//Give User ability to customize pane
	OnShowCustomizePane(pMenuPopup, pWndParentToolbar->GetResourceID());

	if (uiRealCount > 0)
	{
		pMenuPopup->InsertSeparator();
	}

	// Add Reset Toolbar Button
	CString strCommand;
	ENSURE(strCommand.LoadString(IDS_AFXBARRES_RESET_TOOLBAR));

	CMFCCustomizeMenuButton btnReset(AFX_CUSTOMIZE_INTERNAL_ID, NULL, -1, strCommand, FALSE);
	btnReset.SetItemIndex(ID_AFXBARRES_TOOLBAR_RESET_PROMT);

	pMenuPopup->InsertItem(btnReset);
}

BOOL CFrameImpl::OnShowCustomizePane(CMFCPopupMenu* pMenuPane, UINT uiToolbarID)
{
	BOOL bResult = FALSE;

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pFrame);

	if (pMainFrame != NULL)
	{
		bResult = pMainFrame->OnShowCustomizePane(pMenuPane, uiToolbarID);
	}
	else // Maybe, SDI frame...
	{
		CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, m_pFrame);
		if (pFrame != NULL)
		{
			bResult = pFrame->OnShowCustomizePane(pMenuPane, uiToolbarID);

		}else // Maybe, OLE frame
		{
			COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, m_pFrame);
			if (pOleFrame != NULL)
			{
				bResult = pOleFrame->OnShowCustomizePane(pMenuPane, uiToolbarID);
			}
			else
			{
				COleDocIPFrameWndEx* pOleDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, m_pFrame);
				if (pOleDocFrame != NULL)
				{
					bResult = pOleDocFrame->OnShowCustomizePane(pMenuPane, uiToolbarID);
				}
			}
		}
	}

	return bResult;
}

void CFrameImpl::AddDefaultButtonsToCustomizePane(CMFCPopupMenu* pMenuPane, UINT /*uiToolbarID*/)
{
	CMFCToolBar* pWndParentToolbar = CMFCCustomizeMenuButton::GetParentToolbar();

	if (pWndParentToolbar == NULL)
	{
		return;
	}

	CMFCToolBarsCustomizeDialog* pStdCust = new CMFCToolBarsCustomizeDialog(m_pFrame, TRUE, AFX_CUSTOMIZE_MENUAMPERS);

	const CObList& lstOrigButtons = pWndParentToolbar->GetOrigResetButtons();

	int i = 0;
	int nTmp = 0;
	for (POSITION posCurr = lstOrigButtons.GetHeadPosition(); posCurr != NULL; i++)
	{
		CMFCToolBarButton* pButtonCurr = (CMFCToolBarButton*)lstOrigButtons.GetNext(posCurr);

		UINT uiID = pButtonCurr->m_nID;

		if ((pButtonCurr == NULL) ||
			(pButtonCurr->m_nStyle & TBBS_SEPARATOR) ||
			(pButtonCurr->IsKindOf(RUNTIME_CLASS(CMFCCustomizeButton))) || CMFCCustomizeMenuButton::m_mapPresentIDs.Lookup(uiID, nTmp))
		{
			continue;
		}

		if (pButtonCurr->IsKindOf(RUNTIME_CLASS(CMFCDropDownToolbarButton)))
		{
			CMFCDropDownToolbarButton* pDropButton = DYNAMIC_DOWNCAST(CMFCDropDownToolbarButton, pButtonCurr);

			CMFCToolBar* pDropToolBar = pDropButton->GetDropDownToolBar();
			if (pDropToolBar != NULL)
			{
				int nIndex = pDropToolBar->CommandToIndex(uiID);
				if (nIndex != -1)
				{
					continue;
				}
			}
		}

		if (pButtonCurr->IsKindOf(RUNTIME_CLASS(CMFCToolBarMenuButton)))
		{
			CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, pButtonCurr);

			if (pMenuButton->IsMenuPaletteMode())
			{
				const CObList& lstMenuItems = pMenuButton->GetCommands();
				BOOL bIsExist = FALSE;

				for (POSITION posCommand = lstMenuItems.GetHeadPosition(); !bIsExist && posCommand != NULL;)
				{
					CMFCToolBarMenuButton* pMenuItem = (CMFCToolBarMenuButton*) lstMenuItems.GetNext(posCommand);
					ASSERT_VALID(pMenuItem);

					bIsExist = (pMenuItem->m_nID == uiID);
				}

				if (bIsExist)
				{
					continue;
				}
			}
		}

		if ((pButtonCurr->m_nID == 0) ||(pButtonCurr->m_nID == -1))
		{
			uiID = AFX_CUSTOMIZE_INTERNAL_ID;
		}

		CMFCCustomizeMenuButton button(uiID, NULL, pButtonCurr->GetImage(), pStdCust->GetCommandName(pButtonCurr->m_nID), pButtonCurr->m_bUserButton);

		button.SetItemIndex(i, FALSE);

		int nIndex = pMenuPane->InsertItem(button, i);
		if (nIndex == -1)
		{
			pMenuPane->InsertItem(button);
		}
	}

	delete pStdCust;
}

BOOL CFrameImpl::IsCustomizePane(const CMFCPopupMenu* pMenuPopup) const
{
	CMFCPopupMenu* pPopupLevel2 = pMenuPopup->GetParentPopupMenu();

	if (pPopupLevel2 == NULL)
	{
		return FALSE;
	}

	CString strLabel;
	ENSURE(strLabel.LoadString(IDS_AFXBARRES_ADD_REMOVE_BTNS));

	CMFCToolBarMenuButton* pButton = pPopupLevel2->GetParentButton();
	if (pButton != NULL && pButton->m_strText.Find(strLabel) == -1)
	{
		return FALSE;
	}

	CMFCPopupMenu* pPopupLevel1 = pPopupLevel2->GetParentPopupMenu();

	if (pPopupLevel1 == NULL)
	{
		return FALSE;
	}

	if (pPopupLevel1->GetQuickCustomizeType() == CMFCPopupMenu::QUICK_CUSTOMIZE_ADDREMOVE)
	{
		return TRUE;
	}

	return FALSE;
}

void CFrameImpl::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos)
{
	if (m_bWindowPosChanging)
	{
		return;
	}

	ASSERT_VALID(m_pFrame);

	if (m_bIsOleInPlaceActive)
	{
		return;
	}

	if (((lpwndpos->flags & SWP_NOSIZE) == 0 ||(lpwndpos->flags & SWP_FRAMECHANGED)) && (m_pRibbonBar != NULL || IsOwnerDrawCaption()))
	{
		m_bWindowPosChanging = TRUE;

		BOOL oldState = FALSE;

		if (m_pDockManager != NULL)
		{
			oldState = m_pDockManager->m_bDisableRecalcLayout;
			m_pDockManager->m_bDisableRecalcLayout = TRUE;
		}

		m_bIsWindowRgn = CMFCVisualManager::GetInstance()->OnSetWindowRegion(m_pFrame, CSize(lpwndpos->cx, lpwndpos->cy));

		if (m_pDockManager != NULL)
		{
			m_pDockManager->m_bDisableRecalcLayout = oldState;
		}

		m_bWindowPosChanging = FALSE;
	}
}

BOOL CFrameImpl::OnNcPaint()
{
	ASSERT_VALID(m_pFrame);

	BOOL bIsRibbonCaption = FALSE;
	if (m_pRibbonBar->GetSafeHwnd() != NULL && (m_pRibbonBar->IsWindowVisible() || !m_pFrame->IsWindowVisible()) && m_pRibbonBar->IsReplaceFrameCaption())
	{
		bIsRibbonCaption = !afxGlobalData.DwmIsCompositionEnabled();
	}

	if ((!IsOwnerDrawCaption() && !bIsRibbonCaption) || afxGlobalData.m_bInSettingChange)
	{
		return FALSE;
	}

	return CMFCVisualManager::GetInstance()->OnNcPaint(m_pFrame, m_lstCaptionSysButtons, m_rectRedraw);
}

void CFrameImpl::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
	ASSERT_VALID(m_pFrame);
	ENSURE(lpMMI != NULL);

	if ((m_pFrame->GetStyle() & WS_CAPTION) == 0 || (m_pFrame->GetStyle() & WS_BORDER) == 0)
	{
		CRect rectWindow;
		m_pFrame->GetWindowRect(&rectWindow);

		CRect rect(0, 0, 0, 0);

		MONITORINFO mi;
		mi.cbSize = sizeof(MONITORINFO);

		if (GetMonitorInfo(MonitorFromPoint(rectWindow.CenterPoint(), MONITOR_DEFAULTTONEAREST), &mi))
		{
			CRect rectWork = mi.rcWork;
			CRect rectScreen = mi.rcMonitor;

			rect.left = rectWork.left - rectScreen.left;
			rect.top = rectWork.top - rectScreen.top;

			rect.right = rect.left + rectWork.Width();
			rect.bottom = rect.top + rectWork.Height();
		}
		else
		{
			::SystemParametersInfo(SPI_GETWORKAREA, 0, &rect, 0);
		}

		int nShellAutohideBars = afxGlobalData.GetShellAutohideBars();

		if (nShellAutohideBars & AFX_AUTOHIDE_BOTTOM)
		{
			rect.bottom -= 2;
		}

		if (nShellAutohideBars & AFX_AUTOHIDE_TOP)
		{
			rect.top += 2;
		}

		if (nShellAutohideBars & AFX_AUTOHIDE_RIGHT)
		{
			rect.right -= 2;
		}

		if (nShellAutohideBars & AFX_AUTOHIDE_LEFT)
		{
			rect.left += 2;
		}

		lpMMI->ptMaxPosition.x = rect.left;
		lpMMI->ptMaxPosition.y = rect.top;
		lpMMI->ptMaxSize.x = rect.Width();
		lpMMI->ptMaxSize.y = rect.Height();

		if (m_pRibbonBar->GetSafeHwnd() != NULL && m_pRibbonBar->IsReplaceFrameCaption() && !afxGlobalData.DwmIsCompositionEnabled())
		{
			lpMMI->ptMinTrackSize.x = ::GetSystemMetrics(SM_CXMINTRACK);
			lpMMI->ptMinTrackSize.y = ::GetSystemMetrics(SM_CYMINTRACK);
		}
	}
}

BOOL CFrameImpl::OnNcCalcSize(BOOL /*bCalcValidRects*/, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	ASSERT_VALID(m_pFrame);
	ENSURE(lpncsp != NULL);

	BOOL bIsRibbonCaption = FALSE;

	if (m_pRibbonBar->GetSafeHwnd() != NULL && (m_pRibbonBar->IsWindowVisible() || !m_pFrame->IsWindowVisible()) && m_pRibbonBar->IsReplaceFrameCaption())
	{
		bIsRibbonCaption = TRUE;

		if (afxGlobalData.DwmIsCompositionEnabled())
		{
			lpncsp->rgrc[0].bottom -= GetSystemMetrics(SM_CYSIZEFRAME);
			lpncsp->rgrc[0].left += GetSystemMetrics(SM_CYSIZEFRAME);
			lpncsp->rgrc[0].right -= GetSystemMetrics(SM_CXSIZEFRAME);

			return TRUE;
		}
	}

	if (m_pRibbonStatusBar->GetSafeHwnd() != NULL && (m_pRibbonStatusBar->IsWindowVisible() || !m_pFrame->IsWindowVisible()))
	{
		ASSERT_VALID(m_pRibbonStatusBar);

		BOOL bBottomFrame = m_pRibbonStatusBar->m_bBottomFrame;

		if (IsOwnerDrawCaption() && !m_pFrame->IsZoomed())
		{
			m_pRibbonStatusBar->m_bBottomFrame = TRUE;
			lpncsp->rgrc[0].bottom += GetSystemMetrics(SM_CYSIZEFRAME);
		}
		else
		{
			m_pRibbonStatusBar->m_bBottomFrame = FALSE;
		}

		if (bBottomFrame != m_pRibbonStatusBar->m_bBottomFrame)
		{
			m_pRibbonStatusBar->RecalcLayout();
		}
	}

	if (!bIsRibbonCaption && IsOwnerDrawCaption())
	{
		lpncsp->rgrc[0].top += ::GetSystemMetrics(SM_CYCAPTION);
	}

	return(m_pFrame->GetStyle() & WS_MAXIMIZE) == WS_MAXIMIZE && (bIsRibbonCaption || IsOwnerDrawCaption());
}

void CFrameImpl::OnActivateApp(BOOL bActive)
{
	ASSERT_VALID(m_pFrame);

	if (m_bIsOleInPlaceActive)
	{
		return;
	}

	CMFCVisualManager::GetInstance()->OnActivateApp(m_pFrame, bActive);

	if (!bActive && m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible())
	{
		m_pRibbonBar->HideKeyTips();
		m_pRibbonBar->OnCancelMode();
	}

	if (!bActive && !afxGlobalData.m_bSysUnderlineKeyboardShortcuts && afxGlobalData.m_bUnderlineKeyboardShortcuts)
	{
		afxGlobalData.m_bUnderlineKeyboardShortcuts = FALSE;
		CMFCToolBar::RedrawUnderlines();
	}
}

void CFrameImpl::OnSetText(LPCTSTR /*lpszText*/)
{
	ASSERT_VALID(m_pFrame);

	if (m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible() && m_pRibbonBar->IsReplaceFrameCaption())
	{
		m_pRibbonBar->RedrawWindow();
	}
}

BOOL CFrameImpl::OnNcActivate(BOOL bActive)
{
	ASSERT_VALID(m_pFrame);

	if (m_bIsOleInPlaceActive)
	{
		return FALSE;
	}

	if (!bActive && m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible())
	{
		m_pRibbonBar->HideKeyTips();
		m_pRibbonBar->DeactivateKeyboardFocus(FALSE);
	}

	if (!m_pFrame->IsWindowVisible())
	{
		return FALSE;
	}

	BOOL bRes = CMFCVisualManager::GetInstance()->OnNcActivate(m_pFrame, bActive);
	BOOL bFrameIsRedrawn = FALSE;

	if (bRes && m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible() && m_pRibbonBar->IsReplaceFrameCaption())
	{
		m_pRibbonBar->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);

		m_pFrame->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW);

		bFrameIsRedrawn = TRUE;
	}

	if (m_pRibbonStatusBar->GetSafeHwnd() != NULL)
	{
		m_pRibbonStatusBar->RedrawWindow();
	}

	if (!bFrameIsRedrawn && IsOwnerDrawCaption())
	{
		m_pFrame->RedrawWindow(CRect(0, 0, 0, 0), NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_NOCHILDREN);
	}

	return bRes && !afxGlobalData.DwmIsCompositionEnabled();
}

CRect CFrameImpl::GetCaptionRect()
{
	ASSERT_VALID(m_pFrame);

	CSize szSystemBorder(::GetSystemMetrics(SM_CXSIZEFRAME), ::GetSystemMetrics(SM_CYSIZEFRAME));

	if (m_pFrame->IsIconic() || (m_pFrame->GetStyle() & WS_MAXIMIZE) == WS_MAXIMIZE)
	{
		szSystemBorder = CSize(0, 0);
	}

	CRect rectWnd;
	m_pFrame->GetWindowRect(&rectWnd);

	m_pFrame->ScreenToClient(&rectWnd);

	int cyOffset = szSystemBorder.cy;
	if (!m_pFrame->IsIconic())
	{
		cyOffset += ::GetSystemMetrics(SM_CYCAPTION);
	}

	rectWnd.OffsetRect(szSystemBorder.cx, cyOffset);

	CRect rectCaption(rectWnd.left + szSystemBorder.cx, rectWnd.top + szSystemBorder.cy,
		rectWnd.right - szSystemBorder.cx, rectWnd.top + szSystemBorder.cy + ::GetSystemMetrics(SM_CYCAPTION));

	if (m_pFrame->IsIconic())
	{
		rectCaption.top += ::GetSystemMetrics(SM_CYSIZEFRAME);
		rectCaption.right -= ::GetSystemMetrics(SM_CXSIZEFRAME);
	}

	return rectCaption;
}

void CFrameImpl::UpdateCaption()
{
	ASSERT_VALID(m_pFrame);

	if (!IsOwnerDrawCaption())
	{
		return;
	}

	if (m_lstCaptionSysButtons.IsEmpty())
	{
		// Create caption buttons:
		const DWORD dwStyle = m_pFrame->GetStyle();

		HMENU hSysMenu = NULL;
		CMenu* pSysMenu = m_pFrame->GetSystemMenu(FALSE);

		if (pSysMenu != NULL && ::IsMenu(pSysMenu->m_hMenu))
		{
			hSysMenu = pSysMenu->GetSafeHmenu();
			if (!::IsMenu(hSysMenu) ||(m_pFrame->GetStyle() & WS_SYSMENU) == 0)
			{
				hSysMenu = NULL;
			}
		}

		if (hSysMenu != NULL)
		{
			m_lstCaptionSysButtons.AddTail(new CMFCCaptionButtonEx(AFX_HTCLOSE));

			if ((dwStyle & WS_MAXIMIZEBOX) == WS_MAXIMIZEBOX)
			{
				m_lstCaptionSysButtons.AddTail(new CMFCCaptionButtonEx(AFX_HTMAXBUTTON));
			}

			if ((dwStyle & WS_MINIMIZEBOX) == WS_MINIMIZEBOX)
			{
				m_lstCaptionSysButtons.AddTail(new CMFCCaptionButtonEx(AFX_HTMINBUTTON));
			}
		}
	}

	CRect rectCaption = GetCaptionRect();

	CSize sizeButton = CMFCVisualManager::GetInstance()->GetNcBtnSize(FALSE);
	sizeButton.cy = min(sizeButton.cy, rectCaption.Height() - 2);

	int x = rectCaption.right - sizeButton.cx;
	int y = rectCaption.top + max(0, (rectCaption.Height() - sizeButton.cy) / 2);

	for (POSITION pos = m_lstCaptionSysButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButtonEx* pButton = (CMFCCaptionButtonEx*)m_lstCaptionSysButtons.GetNext(pos);
		ASSERT_VALID(pButton);

		pButton->SetRect(CRect(CPoint(x, y), sizeButton));

		x -= sizeButton.cx;
	}

	m_pFrame->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_NOCHILDREN);
}

void __stdcall CFrameImpl::AddFrame(CFrameWnd* pFrame)
{
	ASSERT_VALID(pFrame);

	for (POSITION pos = m_lstFrames.GetHeadPosition(); pos != NULL;)
	{
		CFrameWnd* pListFrame = m_lstFrames.GetNext(pos);

		if (pListFrame->GetSafeHwnd() == pFrame->GetSafeHwnd())
		{
			return;
		}
	}

	m_lstFrames.AddTail(pFrame);
}

void __stdcall CFrameImpl::RemoveFrame(CFrameWnd* pFrame)
{
	for (POSITION pos = m_lstFrames.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CFrameWnd* pListFrame = m_lstFrames.GetNext(pos);

		if (pListFrame->GetSafeHwnd() == pFrame->GetSafeHwnd())
		{
			m_lstFrames.RemoveAt(posSave);
			return;
		}
	}
}

UINT CFrameImpl::OnNcHitTest(CPoint point)
{
	ASSERT_VALID(m_pFrame);

	if (m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible() && m_pRibbonBar->IsReplaceFrameCaption() && m_pRibbonBar->IsTransparentCaption() && afxGlobalData.DwmIsCompositionEnabled())
	{
		return(UINT) afxGlobalData.DwmDefWindowProc(m_pFrame->GetSafeHwnd(), WM_NCHITTEST, 0, MAKELPARAM(point.x, point.y));
	}

	if (!IsOwnerDrawCaption())
	{
		return HTNOWHERE;
	}

	m_pFrame->ScreenToClient(&point);

	const CSize szSystemBorder(::GetSystemMetrics(SM_CXSIZEFRAME), ::GetSystemMetrics(SM_CYSIZEFRAME));

	int cyOffset = szSystemBorder.cy;
	if (!m_pFrame->IsIconic())
	{
		cyOffset += ::GetSystemMetrics(SM_CYCAPTION);
	}

	point.Offset(szSystemBorder.cx, cyOffset);

	for (POSITION pos = m_lstCaptionSysButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButtonEx* pButton = (CMFCCaptionButtonEx*)m_lstCaptionSysButtons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (pButton->GetRect().PtInRect(point))
		{
			return pButton->m_nHit;
		}
	}

	CRect rectCaption = GetCaptionRect();
	if (rectCaption.PtInRect(point))
	{
		CRect rectSysMenu = rectCaption;
		rectSysMenu.right = rectSysMenu.left + ::GetSystemMetrics(SM_CYCAPTION) + 2 * szSystemBorder.cx;

		return rectSysMenu.PtInRect(point) ? HTSYSMENU : HTCAPTION;
	}

	return HTNOWHERE;
}

void CFrameImpl::OnNcMouseMove(UINT /*nHitTest*/, CPoint point)
{
	if (!IsOwnerDrawCaption())
	{
		return;
	}

	if (!m_bCaptured)
	{
		OnTrackCaptionButtons(point);
	}
}

void CFrameImpl::OnLButtonDown(CPoint /*point*/)
{
	if (m_nHotSysButton == HTNOWHERE)
	{
		return;
	}

	CMFCCaptionButtonEx* pBtn = GetSysButton(m_nHotSysButton);
	if (pBtn != NULL)
	{
		m_nHitSysButton = m_nHotSysButton;
		pBtn->m_bPushed = TRUE;
		RedrawCaptionButton(pBtn);
	}
}

void CFrameImpl::OnLButtonUp(CPoint /*point*/)
{
	ASSERT_VALID(m_pFrame);

	if (!IsOwnerDrawCaption())
	{
		return;
	}

	if (m_bCaptured)
	{
		return;
	}

	switch (m_nHitSysButton)
	{
	case AFX_HTCLOSE:
	case AFX_HTMAXBUTTON:
	case AFX_HTMINBUTTON:
		{
			UINT nHot = m_nHotSysButton;
			UINT nHit = m_nHitSysButton;

			StopCaptionButtonsTracking();

			if (nHot == nHit)
			{
				UINT nSysCmd = 0;

				switch (nHot)
				{
				case AFX_HTCLOSE:
					nSysCmd = SC_CLOSE;
					break;

				case AFX_HTMAXBUTTON:
					nSysCmd =
						(m_pFrame->GetStyle() & WS_MAXIMIZE) == WS_MAXIMIZE ? SC_RESTORE : SC_MAXIMIZE;
					break;

				case AFX_HTMINBUTTON:
					nSysCmd = m_pFrame->IsIconic() ? SC_RESTORE : SC_MINIMIZE;
					break;
				}

				m_pFrame->PostMessage(WM_SYSCOMMAND, nSysCmd);
			}
		}
	}
}

void CFrameImpl::OnMouseMove(CPoint point)
{
	if (!IsOwnerDrawCaption())
	{
		return;
	}

	CPoint ptScreen = point;
	m_pFrame->ClientToScreen(&ptScreen);

	OnTrackCaptionButtons(ptScreen);
}

CMFCCaptionButtonEx* CFrameImpl::GetSysButton(UINT nHit)
{
	for (POSITION pos = m_lstCaptionSysButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButtonEx* pButton = (CMFCCaptionButtonEx*)
			m_lstCaptionSysButtons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (pButton->m_nHit == nHit)
		{
			return pButton;
		}
	}

	return NULL;
}

void CFrameImpl::SetHighlightedSysButton(UINT nHit)
{
	BOOL bRedraw = FALSE;

	for (POSITION pos = m_lstCaptionSysButtons.GetHeadPosition(); pos != NULL;)
	{
		CMFCCaptionButtonEx* pButton = (CMFCCaptionButtonEx*)
			m_lstCaptionSysButtons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (pButton->m_nHit == nHit)
		{
			if (pButton->m_bFocused)
			{
				return;
			}

			pButton->m_bFocused = TRUE;
			bRedraw = TRUE;
		}
	}
}

void CFrameImpl::OnTrackCaptionButtons(CPoint point)
{
	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return;
	}

	UINT nHot = m_nHotSysButton;
	CMFCCaptionButtonEx* pBtn = GetSysButton(OnNcHitTest(point));

	if (pBtn != NULL && pBtn->m_bEnabled)
	{
		m_nHotSysButton = pBtn->GetHit();
		pBtn->m_bFocused = TRUE;
	}
	else
	{
		m_nHotSysButton = HTNOWHERE;
	}

	if (m_nHotSysButton != nHot)
	{
		RedrawCaptionButton(pBtn);

		CMFCCaptionButtonEx* pBtnOld = GetSysButton(nHot);
		if (pBtnOld != NULL)
		{
			pBtnOld->m_bFocused = FALSE;
			RedrawCaptionButton(pBtnOld);
		}
	}

	if (m_nHitSysButton == HTNOWHERE)
	{
		if (nHot != HTNOWHERE && m_nHotSysButton == HTNOWHERE)
		{
			::ReleaseCapture();
		}
		else if (nHot == HTNOWHERE && m_nHotSysButton != HTNOWHERE)
		{
			m_pFrame->SetCapture();
		}
	}
}

void CFrameImpl::StopCaptionButtonsTracking()
{
	if (m_nHitSysButton != HTNOWHERE)
	{
		CMFCCaptionButtonEx* pBtn = GetSysButton(m_nHitSysButton);
		m_nHitSysButton = HTNOWHERE;

		ReleaseCapture();
		if (pBtn != NULL)
		{
			pBtn->m_bPushed = FALSE;
			RedrawCaptionButton(pBtn);
		}
	}

	if (m_nHotSysButton != HTNOWHERE)
	{
		CMFCCaptionButtonEx* pBtn = GetSysButton(m_nHotSysButton);
		m_nHotSysButton = HTNOWHERE;

		ReleaseCapture();
		if (pBtn != NULL)
		{
			pBtn->m_bFocused = FALSE;
			RedrawCaptionButton(pBtn);
		}
	}
}

void CFrameImpl::RedrawCaptionButton(CMFCCaptionButtonEx* pBtn)
{
	ASSERT_VALID(m_pFrame);

	if (pBtn == NULL)
	{
		return;
	}

	ASSERT_VALID(pBtn);

	m_rectRedraw = pBtn->GetRect();
	m_pFrame->SendMessage(WM_NCPAINT);
	m_rectRedraw.SetRectEmpty();

	m_pFrame->UpdateWindow();
}

void CFrameImpl::OnChangeVisualManager()
{
	ASSERT_VALID(m_pFrame);

	BOOL bIsRibbonCaption = FALSE;

	if (m_pRibbonBar != NULL && (m_pRibbonBar->IsWindowVisible() || !m_pFrame->IsWindowVisible()) && m_pRibbonBar->IsReplaceFrameCaption())
	{
		bIsRibbonCaption = TRUE;
		m_pRibbonBar->RecalcLayout();

		if (afxGlobalData.DwmIsCompositionEnabled())
		{
			return;
		}
	}

	CRect rectWindow;
	m_pFrame->GetWindowRect(rectWindow);

	BOOL bZoomed = m_pFrame->IsZoomed();

	if (bIsRibbonCaption || IsOwnerDrawCaption())
	{
		BOOL bChangeBorder = FALSE;

		if ((m_pFrame->GetStyle() & WS_BORDER) == WS_BORDER && m_bHasBorder && !m_bIsMDIChildFrame)
		{
			bChangeBorder = TRUE;
			m_bWindowPosChanging = TRUE;
			m_pFrame->ModifyStyle(WS_BORDER, 0, SWP_FRAMECHANGED);
			m_bWindowPosChanging = FALSE;
		}

		m_bIsWindowRgn = CMFCVisualManager::GetInstance()->OnSetWindowRegion(m_pFrame, rectWindow.Size());

		if (bZoomed && bChangeBorder && !m_bIsMDIChildFrame)
		{
			MINMAXINFO mi;
			ZeroMemory(&mi, sizeof(MINMAXINFO));
			OnGetMinMaxInfo(&mi);

			rectWindow = CRect(mi.ptMaxPosition, CSize(mi.ptMaxSize.x, mi.ptMaxSize.y));

			m_pFrame->SetWindowPos(NULL, rectWindow.left, rectWindow.top, rectWindow.Width(), rectWindow.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
		}
	}
	else
	{
		BOOL bChangeBorder = FALSE;

		if ((m_pFrame->GetStyle() & WS_BORDER) == 0 && m_bHasBorder && !m_bIsMDIChildFrame)
		{
			bChangeBorder = TRUE;
			m_bWindowPosChanging = TRUE;
			m_pFrame->ModifyStyle(0, WS_BORDER, SWP_FRAMECHANGED);
			m_bWindowPosChanging = FALSE;
		}

		if (m_bIsWindowRgn)
		{
			m_bIsWindowRgn = FALSE;
			m_pFrame->SetWindowRgn(NULL, TRUE);
		}

		if (bZoomed && bChangeBorder && !m_bIsMDIChildFrame)
		{
			NCCALCSIZE_PARAMS params;
			ZeroMemory(&params, sizeof(NCCALCSIZE_PARAMS));
			params.rgrc[0].left   = rectWindow.left;
			params.rgrc[0].top    = rectWindow.top;
			params.rgrc[0].right  = rectWindow.right;
			params.rgrc[0].bottom = rectWindow.bottom;

			m_pFrame->CalcWindowRect(&params.rgrc[0], CFrameWnd::adjustBorder);

			if ((m_pFrame->GetStyle() & WS_CAPTION) == WS_CAPTION)
			{
				params.rgrc[0].top += ::GetSystemMetrics(SM_CYCAPTION);
			}

			m_pFrame->SetWindowPos(NULL, params.rgrc[0].left, params.rgrc[0].top,
				params.rgrc[0].right - params.rgrc[0].left, params.rgrc[0].bottom - params.rgrc[0].top, SWP_NOACTIVATE | SWP_NOZORDER);
		}
		else
		{
			m_pFrame->SetWindowPos(NULL, -1, -1, rectWindow.Width() + 1, rectWindow.Height() + 1, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
			m_pFrame->SetWindowPos(NULL, -1, -1, rectWindow.Width(), rectWindow.Height(), SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
		}
	}

	UpdateCaption();
}

BOOL CFrameImpl::IsPrintPreview()
{
	return m_pDockManager != NULL && m_pDockManager->IsPrintPreviewValid();
}

void CFrameImpl::OnDWMCompositionChanged()
{
	if (m_pRibbonBar != NULL && m_pRibbonBar->IsWindowVisible() && m_pRibbonBar->IsReplaceFrameCaption())
	{
		m_pRibbonBar->DWMCompositionChanged();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afximageeditordialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include <afxpriv.h>
#include "afxribbonres.h"
#include "afxglobals.h"
#include "afximageeditordialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static void __stdcall Create16ColorsStdPalette(CPalette& pal);

/////////////////////////////////////////////////////////////////////////////
// CMFCImageEditorDialog dialog

#pragma warning(disable : 4355)

CMFCImageEditorDialog::CMFCImageEditorDialog(CBitmap* pBitmap, CWnd* pParent /*=NULL*/, int nBitsPixel /* = -1 */) :
	CDialogEx(CMFCImageEditorDialog::IDD, pParent), m_pBitmap(pBitmap), m_wndLargeDrawArea(this)
{
	ASSERT_VALID(m_pBitmap);

	BITMAP bmp;
	m_pBitmap->GetBitmap(&bmp);

	m_sizeImage = CSize(bmp.bmWidth, bmp.bmHeight);

	m_nBitsPixel = (nBitsPixel == -1) ? bmp.bmBitsPixel : nBitsPixel;
	ASSERT(m_nBitsPixel >= 4); // Monochrome bitmaps are not supported
}

#pragma warning(default : 4355)

void CMFCImageEditorDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCImageEditorDialog)
	DDX_Control(pDX, IDC_AFXBARRES_COLORS, m_wndColorPickerLocation);
	DDX_Control(pDX, IDC_AFXBARRES_PALETTE, m_wndPaletteBarLocation);
	DDX_Control(pDX, IDC_AFXBARRES_PREVIEW_AREA, m_wndPreview);
	DDX_Control(pDX, IDC_AFXBARRES_DRAW_AREA, m_wndLargeDrawArea);
	//}}AFX_DATA_MAP
}

//{{AFX_MSG_MAP(CMFCImageEditorDialog)
BEGIN_MESSAGE_MAP(CMFCImageEditorDialog, CDialogEx)
	ON_WM_PAINT()
	ON_COMMAND(ID_AFX_TOOL_CLEAR, &CMFCImageEditorDialog::OnToolClear)
	ON_COMMAND(ID_AFX_TOOL_COPY, &CMFCImageEditorDialog::OnToolCopy)
	ON_COMMAND(ID_AFX_TOOL_PASTE, &CMFCImageEditorDialog::OnToolPaste)
	ON_UPDATE_COMMAND_UI(ID_AFX_TOOL_PASTE, &CMFCImageEditorDialog::OnUpdateToolPaste)
	ON_COMMAND(ID_AFX_TOOL_ELLIPSE, &CMFCImageEditorDialog::OnToolEllipse)
	ON_COMMAND(ID_AFX_TOOL_FILL, &CMFCImageEditorDialog::OnToolFill)
	ON_COMMAND(ID_AFX_TOOL_LINE, &CMFCImageEditorDialog::OnToolLine)
	ON_COMMAND(ID_AFX_TOOL_PEN, &CMFCImageEditorDialog::OnToolPen)
	ON_COMMAND(ID_AFX_TOOL_PICK, &CMFCImageEditorDialog::OnToolPick)
	ON_COMMAND(ID_AFX_TOOL_RECT, &CMFCImageEditorDialog::OnToolRect)
	ON_UPDATE_COMMAND_UI(ID_AFX_TOOL_ELLIPSE, &CMFCImageEditorDialog::OnUpdateToolEllipse)
	ON_UPDATE_COMMAND_UI(ID_AFX_TOOL_FILL, &CMFCImageEditorDialog::OnUpdateToolFill)
	ON_UPDATE_COMMAND_UI(ID_AFX_TOOL_LINE, &CMFCImageEditorDialog::OnUpdateToolLine)
	ON_UPDATE_COMMAND_UI(ID_AFX_TOOL_PEN, &CMFCImageEditorDialog::OnUpdateToolPen)
	ON_UPDATE_COMMAND_UI(ID_AFX_TOOL_PICK, &CMFCImageEditorDialog::OnUpdateToolPick)
	ON_UPDATE_COMMAND_UI(ID_AFX_TOOL_RECT, &CMFCImageEditorDialog::OnUpdateToolRect)
	ON_MESSAGE(WM_KICKIDLE, &CMFCImageEditorDialog::OnKickIdle)
	ON_COMMAND(IDC_AFXBARRES_COLORS, &CMFCImageEditorDialog::OnColors)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCImageEditorDialog message handlers

BOOL CMFCImageEditorDialog::OnInitDialog()
{
	const int iBorderWidth = 10;
	const int iBorderHeight = 5;
	const int iPreviewBorderSize = 4;

	CDialogEx::OnInitDialog();

	if (AfxGetMainWnd() != NULL && (AfxGetMainWnd()->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		ModifyStyleEx(0, WS_EX_LAYOUTRTL);
	}

	m_wndLargeDrawArea.SetBitmap(m_pBitmap);

	//------------------------
	// Create the palette bar:
	//------------------------
	{
		CRect rectPaletteBarWnd;
		m_wndPaletteBarLocation.GetWindowRect (&rectPaletteBarWnd);

		CRect rectPaletteBar;
		m_wndPaletteBarLocation.GetClientRect(&rectPaletteBar);
		m_wndPaletteBarLocation.MapWindowPoints(this, &rectPaletteBar);
		rectPaletteBar.DeflateRect(2, 2);

		m_wndPaletteBar.EnableLargeIcons(FALSE);
		m_wndPaletteBar.Create(this);

		const UINT uiToolbarHotID = afxGlobalData.Is32BitIcons() ? IDR_AFXRES_PALETTE32 : 0;

		m_wndPaletteBar.LoadToolBar( IDR_AFXRES_PALETTE, 0, 0, TRUE /* Locked bar */, 0, 0, uiToolbarHotID);
		m_wndPaletteBar.SetPaneStyle(m_wndPaletteBar.GetPaneStyle() | CBRS_TOOLTIPS | CBRS_FLYBY);
		m_wndPaletteBar.SetPaneStyle(m_wndPaletteBar.GetPaneStyle() & ~(CBRS_GRIPPER | CBRS_BORDER_TOP | CBRS_BORDER_BOTTOM | CBRS_BORDER_LEFT | CBRS_BORDER_RIGHT));
		m_wndPaletteBar.SetBorders(iBorderWidth, iBorderHeight, iBorderWidth, iBorderHeight);

		const int nButtonWidth = m_wndPaletteBar.GetButtonSize().cx;
		m_wndPaletteBar.WrapToolBar(nButtonWidth * 3);

		const CSize szLayout = m_wndPaletteBar.CalcSize (FALSE);
		rectPaletteBar.bottom = rectPaletteBar.top + szLayout.cy + iBorderHeight * 2;

		m_wndPaletteBar.MoveWindow(rectPaletteBar);

		if (rectPaletteBar.Height () > rectPaletteBarWnd.Height ())
		{
			m_wndPaletteBarLocation.SetWindowPos (NULL, -1, -1, rectPaletteBarWnd.Width (), rectPaletteBar.Height () + iBorderHeight + 2,
													SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
		}

		m_wndPaletteBar.SetWindowPos(&wndTop, -1, -1, -1, -1, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
		m_wndPaletteBar.SetOwner(this);

		// All commands will be routed via this dialog, not via the parent frame:
		m_wndPaletteBar.SetRouteCommandsViaFrame(FALSE);
	}

	// Create color picker:
	{
		CRect rectColorBar;
		m_wndColorPickerLocation.GetClientRect(&rectColorBar);
		m_wndColorPickerLocation.MapWindowPoints(this, &rectColorBar);
		rectColorBar.DeflateRect(2, 2);

		m_wndColorBar.m_bInternal = TRUE;

		int nColumns = 4;

		// If bitmap has 256 or less colors, create 16 colors palette:
		CPalette pal;
		if (m_nBitsPixel <= 8)
		{
			Create16ColorsStdPalette(pal);
		}
		else
		{
			m_wndColorBar.EnableOtherButton(_T("Other"));

			nColumns = 5;
			m_wndColorBar.SetVertMargin(1);
			m_wndColorBar.SetHorzMargin(1);
		}

		m_wndColorBar.CreateControl(this, rectColorBar, IDC_AFXBARRES_COLORS, nColumns, m_nBitsPixel <= 8 ? &pal : NULL);
		m_wndColorBar.SetColor(RGB(0, 0, 0));
	}

	//---------------------
	// Define preview area:
	//---------------------
	m_wndPreview.GetClientRect(&m_rectPreviewImage);
	m_wndPreview.MapWindowPoints(this, &m_rectPreviewImage);

	m_rectPreviewImage.left = (m_rectPreviewImage.left + m_rectPreviewImage.right - m_sizeImage.cx) / 2;
	m_rectPreviewImage.right = m_rectPreviewImage.left + m_sizeImage.cx;

	m_rectPreviewImage.top = (m_rectPreviewImage.top + m_rectPreviewImage.bottom - m_sizeImage.cy) / 2;
	m_rectPreviewImage.bottom = m_rectPreviewImage.top + m_sizeImage.cy;

	m_rectPreviewFrame = m_rectPreviewImage;
	m_rectPreviewFrame.InflateRect(iPreviewBorderSize, iPreviewBorderSize);

	m_wndLargeDrawArea.m_rectParentPreviewArea = m_rectPreviewImage;
	m_wndLargeDrawArea.ModifyStyle(WS_TABSTOP, 0);

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCImageEditorDialog::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	dc.FillRect(m_rectPreviewFrame, &afxGlobalData.brBtnFace);

	CBitmap* pbmOld = NULL;
	CDC dcMem;

	dcMem.CreateCompatibleDC(&dc);
	pbmOld = dcMem.SelectObject(m_pBitmap);

	dc.BitBlt(m_rectPreviewImage.left, m_rectPreviewImage.top, m_sizeImage.cx, m_sizeImage.cy, &dcMem, 0, 0, SRCCOPY);
	dc.Draw3dRect(&m_rectPreviewFrame, afxGlobalData.clrBtnHilite, afxGlobalData.clrBtnShadow);

	dcMem.SelectObject(pbmOld);
	dcMem.DeleteDC();
}

LRESULT CMFCImageEditorDialog::OnKickIdle(WPARAM, LPARAM)
{
	m_wndPaletteBar.OnUpdateCmdUI((CFrameWnd*) this, TRUE);
	return 0;
}

void CMFCImageEditorDialog::OnColors()
{
	COLORREF color = m_wndColorBar.GetColor();
	if (color == RGB(192, 192, 192))
	{
		color = afxGlobalData.clrBtnFace;
	}

	m_wndLargeDrawArea.SetColor(color);
}

BOOL CMFCImageEditorDialog::OnPickColor(COLORREF color)
{
	m_wndColorBar.SetColor(color);
	m_wndLargeDrawArea.SetColor(color);

	//-----------------------------------------
	// Move to the pen mode(not so good :-(!):
	//-----------------------------------------
	m_wndLargeDrawArea.SetMode(CMFCImagePaintArea::IMAGE_EDIT_MODE_PEN);
	return TRUE;
}

void CMFCImageEditorDialog::OnToolClear()
{
	CWindowDC dc(this);
	CDC 		memDC;

	memDC.CreateCompatibleDC(&dc);

	CBitmap* pOldBitmap = memDC.SelectObject(m_pBitmap);

	CRect rect(0, 0, m_sizeImage.cx, m_sizeImage.cy);
	memDC.FillRect(&rect, &afxGlobalData.brBtnFace);

	memDC.SelectObject(pOldBitmap);

	InvalidateRect(m_rectPreviewImage);
	m_wndLargeDrawArea.Invalidate();
}

void CMFCImageEditorDialog::OnToolCopy()
{
	if (m_pBitmap == NULL)
	{
		return;
	}

	try
	{
		CWindowDC dc(this);

		//----------------------
		// Create a bitmap copy:
		//----------------------
		CDC memDCDest;
		memDCDest.CreateCompatibleDC(NULL);

		CDC memDCSrc;
		memDCSrc.CreateCompatibleDC(NULL);

		CBitmap bitmapCopy;
		if (!bitmapCopy.CreateCompatibleBitmap(&dc, m_sizeImage.cx, m_sizeImage.cy))
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			return;
		}

		CBitmap* pOldBitmapDest = memDCDest.SelectObject(&bitmapCopy);
		CBitmap* pOldBitmapSrc = memDCSrc.SelectObject(m_pBitmap);

		memDCDest.BitBlt(0, 0, m_sizeImage.cx, m_sizeImage.cy, &memDCSrc, 0, 0, SRCCOPY);

		memDCDest.SelectObject(pOldBitmapDest);
		memDCSrc.SelectObject(pOldBitmapSrc);

		if (!OpenClipboard())
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			return;
		}

		if (!::EmptyClipboard())
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			::CloseClipboard();
			return;
		}


		HANDLE hclipData = ::SetClipboardData(CF_BITMAP, bitmapCopy.Detach());
		if (hclipData == NULL)
		{
			AfxMessageBox(IDP_AFXBARRES_CANT_COPY_BITMAP);
			TRACE(_T("CMFCImageEditorDialog::Copy() error. Error code = %x\n"), GetLastError());
		}

		::CloseClipboard();
	}
	catch(...)
	{
		AfxMessageBox(IDP_AFXBARRES_INTERLAL_ERROR);
	}
}

void CMFCImageEditorDialog::OnToolPaste()
{
	COleDataObject data;
	if (!data.AttachClipboard())
	{
		AfxMessageBox(IDP_AFXBARRES_CANT_PASTE_BITMAP);
		return;
	}

	if (!data.IsDataAvailable(CF_BITMAP))
	{
		AfxMessageBox(IDP_AFXBARRES_CANT_PASTE_BITMAP);
		return;
	}

	tagSTGMEDIUM dataMedium;
	if (!data.GetData(CF_BITMAP, &dataMedium))
	{
		AfxMessageBox(IDP_AFXBARRES_CANT_PASTE_BITMAP);
		return;
	}

	CBitmap* pBmpClip = CBitmap::FromHandle(dataMedium.hBitmap);
	if (pBmpClip == NULL)
	{
		AfxMessageBox(IDP_AFXBARRES_CANT_PASTE_BITMAP);
		return;
	}

	BITMAP bmp;
	pBmpClip->GetBitmap(&bmp);

	CDC memDCDst;
	CDC memDCSrc;

	memDCSrc.CreateCompatibleDC(NULL);
	memDCDst.CreateCompatibleDC(NULL);

	CBitmap* pSrcOldBitmap = memDCSrc.SelectObject(pBmpClip);
	if (pSrcOldBitmap == NULL)
	{
		AfxMessageBox(IDP_AFXBARRES_CANT_PASTE_BITMAP);
		return;
	}

	CBitmap* pDstOldBitmap = memDCDst.SelectObject(m_pBitmap);
	if (pDstOldBitmap == NULL)
	{
		AfxMessageBox(IDP_AFXBARRES_CANT_PASTE_BITMAP);

		memDCSrc.SelectObject(pSrcOldBitmap);
		return;
	}

	memDCDst.FillRect(CRect(0, 0, m_sizeImage.cx, m_sizeImage.cy), &afxGlobalData.brBtnFace);

	int x = max(0, (m_sizeImage.cx - bmp.bmWidth) / 2);
	int y = max(0, (m_sizeImage.cy - bmp.bmHeight) / 2);

	int cx = min((m_sizeImage.cx - x), (bmp.bmWidth));
	int cy = min((m_sizeImage.cy - y), (bmp.bmHeight));

	if (cx > 0 && cy > 0)
	{
		CMFCToolBarImages::TransparentBlt(memDCDst.GetSafeHdc(), x, y, cx, cy, &memDCSrc, 0, 0, RGB(192, 192, 192));
	}

	memDCDst.SelectObject(pDstOldBitmap);
	memDCSrc.SelectObject(pSrcOldBitmap);

	InvalidateRect(m_rectPreviewImage);
	m_wndLargeDrawArea.Invalidate();
}

void CMFCImageEditorDialog::OnUpdateToolPaste(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(::IsClipboardFormatAvailable(CF_BITMAP));
}

void CMFCImageEditorDialog::OnToolEllipse()
{
	SetMode(CMFCImagePaintArea::IMAGE_EDIT_MODE_ELLIPSE);
}

void CMFCImageEditorDialog::OnToolFill()
{
	SetMode(CMFCImagePaintArea::IMAGE_EDIT_MODE_FILL);
}

void CMFCImageEditorDialog::OnToolLine()
{
	SetMode(CMFCImagePaintArea::IMAGE_EDIT_MODE_LINE);
}

void CMFCImageEditorDialog::OnToolPen()
{
	SetMode(CMFCImagePaintArea::IMAGE_EDIT_MODE_PEN);
}

void CMFCImageEditorDialog::OnToolPick()
{
	SetMode(CMFCImagePaintArea::IMAGE_EDIT_MODE_COLOR);
}

void CMFCImageEditorDialog::OnToolRect()
{
	SetMode(CMFCImagePaintArea::IMAGE_EDIT_MODE_RECT);
}

void CMFCImageEditorDialog::OnUpdateToolEllipse(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(GetMode() == CMFCImagePaintArea::IMAGE_EDIT_MODE_ELLIPSE);
}

void CMFCImageEditorDialog::OnUpdateToolFill(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(GetMode() == CMFCImagePaintArea::IMAGE_EDIT_MODE_FILL);
}

void CMFCImageEditorDialog::OnUpdateToolLine(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(GetMode() == CMFCImagePaintArea::IMAGE_EDIT_MODE_LINE);
}

void CMFCImageEditorDialog::OnUpdateToolPen(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(GetMode() == CMFCImagePaintArea::IMAGE_EDIT_MODE_PEN);
}

void CMFCImageEditorDialog::OnUpdateToolPick(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(GetMode() == CMFCImagePaintArea::IMAGE_EDIT_MODE_COLOR);
}

void CMFCImageEditorDialog::OnUpdateToolRect(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(GetMode() == CMFCImagePaintArea::IMAGE_EDIT_MODE_RECT);
}

void __stdcall Create16ColorsStdPalette(CPalette& pal)
{
	const int nStdColorCount = 20;
	CPalette* pPalDefault = CPalette::FromHandle((HPALETTE) ::GetStockObject(DEFAULT_PALETTE));
	if (pPalDefault == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	const int nColors = 16;
	UINT nSize = sizeof(LOGPALETTE) +(sizeof(PALETTEENTRY) * nColors);
	LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];

	pLP->palVersion = 0x300;
	pLP->palNumEntries = (USHORT) nColors;

	pal.CreatePalette(pLP);

	delete[] pLP;

	PALETTEENTRY palEntry;
	int iDest = 0;

	for (int i = 0; i < nStdColorCount; i++)
	{
		if (i < 8 || i >= 12)
		{
			pPalDefault->GetPaletteEntries(i, 1, &palEntry);
			pal.SetPaletteEntries(iDest++, 1, &palEntry);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afximagepaintarea.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxribbonres.h"
#include "afximagepaintarea.h"
#include "afxtoolbarimages.h"
#include "afximageeditordialog.h"
#include "afxglobals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCImagePaintArea

CMFCImagePaintArea::CMFCImagePaintArea(CMFCImageEditorDialog* pParentDlg)
{
	ENSURE(pParentDlg != NULL);

	m_pParentDlg = pParentDlg;

	m_sizeImage.cx = 0;
	m_sizeImage.cy = 0;

	m_pBitmap = NULL;
	m_rgbColor = RGB(0, 0, 0); // Black

	m_rectParentPreviewArea.SetRectEmpty();
	m_memDC.CreateCompatibleDC(NULL);

	m_Mode = IMAGE_EDIT_MODE_PEN;
	m_rectDraw.SetRectEmpty();

	m_penDraw.CreatePen(PS_SOLID, 1, m_rgbColor);
}

CMFCImagePaintArea::~CMFCImagePaintArea()
{
	::DestroyCursor(m_hcurPen);
	::DestroyCursor(m_hcurFill);
	::DestroyCursor(m_hcurLine);
	::DestroyCursor(m_hcurRect);
	::DestroyCursor(m_hcurEllipse);
	::DestroyCursor(m_hcurColor);
}

BEGIN_MESSAGE_MAP(CMFCImagePaintArea, CButton)
	//{{AFX_MSG_MAP(CMFCImagePaintArea)
	ON_WM_ERASEBKGND()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_CANCELMODE()
	ON_WM_SETCURSOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCImagePaintArea message handlers

void CMFCImagePaintArea::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC* pDC = CDC::FromHandle(lpDIS->hDC);
	ASSERT_VALID(pDC);

	CRect rectClient = lpDIS->rcItem;

	pDC->FillRect(&rectClient, &afxGlobalData.brBtnFace);
	rectClient.InflateRect(-1, -1);

	CRect rectDraw = rectClient;

	rectDraw.right = rectDraw.left + m_sizeCell.cx * m_sizeImage.cx;
	rectDraw.bottom = rectDraw.top + m_sizeCell.cy * m_sizeImage.cy;

	rectClient = rectDraw;
	rectClient.InflateRect(1, 1);

	pDC->Draw3dRect(rectDraw, afxGlobalData.clrBtnDkShadow, afxGlobalData.clrBtnHilite);

	// Draw grid:
	CPen penGrid(PS_SOLID, 1, afxGlobalData.clrBtnShadow);
	CPen* pOldPen = (CPen*) pDC->SelectObject(&penGrid);

	int x = 0;
	int y = 0;

	for (x = rectDraw.left + m_sizeCell.cx;
		x <= rectDraw.right - m_sizeCell.cx; x += m_sizeCell.cx)
	{
		pDC->MoveTo(x, rectDraw.top + 1);
		pDC->LineTo(x, rectDraw.bottom - 1);
	}

	for (y = rectDraw.top + m_sizeCell.cy;
		y <= rectDraw.bottom - m_sizeCell.cy; y += m_sizeCell.cy)
	{
		pDC->MoveTo(rectDraw.left + 1, y);
		pDC->LineTo(rectDraw.right - 1, y);
	}

	pDC->SelectObject(pOldPen);

	// Draw bitmap:
	if (m_pBitmap == NULL)
	{
		return;
	}

	CBitmap* pOldBitmap = m_memDC.SelectObject(m_pBitmap);

	for (x = 0; x < m_sizeImage.cx; x ++)
	{
		for (y = 0; y < m_sizeImage.cy; y ++)
		{
			COLORREF rgbPixel = CMFCToolBarImages::MapFromSysColor(m_memDC.GetPixel(x, y), FALSE);
			if (rgbPixel != (COLORREF) -1)
			{
				CRect rect(CPoint(rectDraw.left + x * m_sizeCell.cx, rectDraw.top + y * m_sizeCell.cy), m_sizeCell);
				rect.InflateRect(-1, -1);

				pDC->FillSolidRect(rect, rgbPixel);
			}
		}
	}

	m_memDC.SelectObject(pOldBitmap);
}

BOOL CMFCImagePaintArea::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMFCImagePaintArea::OnMouseMove(UINT nFlags, CPoint point)
{
	if ((nFlags & MK_LBUTTON) == 0)
	{
		return;
	}

	CRect rectClient; // Client area rectangle
	GetClientRect(&rectClient);

	point.x = min(max(point.x, rectClient.left), rectClient.right);
	point.y = min(max(point.y, rectClient.top), rectClient.bottom);

	if (m_Mode == IMAGE_EDIT_MODE_PEN)
	{
		DrawPixel(point);
		return;
	}

	if (m_Mode != IMAGE_EDIT_MODE_LINE && m_Mode != IMAGE_EDIT_MODE_RECT && m_Mode != IMAGE_EDIT_MODE_ELLIPSE)
	{
		return;
	}

	CRect rectDraw = rectClient;

	rectDraw.right = rectDraw.left + m_sizeCell.cx * m_sizeImage.cx;
	rectDraw.bottom = rectDraw.top + m_sizeCell.cy * m_sizeImage.cy;

	rectDraw.DeflateRect(1, 1);

	if (m_rectDraw == rectDraw)
	{
		return;
	}

	CRgn rgnClip;
	rgnClip.CreateRectRgnIndirect(&rectDraw);

	CClientDC dc(this);
	dc.SelectObject(&rgnClip);

	CPen* pOldPen = (CPen*) dc.SelectObject(&m_penStretch);
	CBrush* pOldBrush = (CBrush*) dc.SelectStockObject(NULL_BRUSH);
	int nOldROP = dc.SetROP2(R2_NOT);

	switch (m_Mode)
	{
	case IMAGE_EDIT_MODE_LINE:
		{
			// Erase old:
			CRect rectScreen = m_rectDraw;
			BitmapToClient(rectScreen);

			if (m_rectDraw.Width() != 0 || m_rectDraw.Height() != 0)
			{
				dc.MoveTo(rectScreen.left, rectScreen.top);
				dc.LineTo(rectScreen.right, rectScreen.bottom);
			}

			ScreenToBitmap(point);
			m_rectDraw.right = point.x;
			m_rectDraw.bottom = point.y;

			// Draw new:
			rectScreen = m_rectDraw;
			BitmapToClient(rectScreen);

			if (m_rectDraw.Width() != 0 || m_rectDraw.Height() != 0)
			{
				dc.MoveTo(rectScreen.left, rectScreen.top);
				dc.LineTo(rectScreen.right, rectScreen.bottom);
			}
		}
		break;

	case IMAGE_EDIT_MODE_RECT:
		{
			// Erase old:
			CRect rectScreen = m_rectDraw;
			BitmapToClient(rectScreen);

			if (m_rectDraw.Width() != 0 || m_rectDraw.Height() != 0)
			{
				dc.Rectangle(rectScreen);
			}

			ScreenToBitmap(point);
			m_rectDraw.right = point.x;
			m_rectDraw.bottom = point.y;

			// Draw new:
			rectScreen = m_rectDraw;
			BitmapToClient(rectScreen);

			if (m_rectDraw.Width() != 0 || m_rectDraw.Height() != 0)
			{
				dc.Rectangle(rectScreen);
			}
		}
		break;

	case IMAGE_EDIT_MODE_ELLIPSE:
		{
			// Erase old:
			CRect rectScreen = m_rectDraw;
			BitmapToClient(rectScreen);

			if (m_rectDraw.Width() != 0 || m_rectDraw.Height() != 0)
			{
				dc.Ellipse(rectScreen);
			}

			ScreenToBitmap(point);
			m_rectDraw.right = point.x;
			m_rectDraw.bottom = point.y;

			// Draw new:
			rectScreen = m_rectDraw;
			BitmapToClient(rectScreen);

			if (m_rectDraw.Width() != 0 || m_rectDraw.Height() != 0)
			{
				dc.Ellipse(rectScreen);
			}
		}
		break;
	}

	dc.SetROP2(nOldROP);
	dc.SelectObject(pOldBrush);
	dc.SelectObject(pOldPen);
	dc.SelectClipRgn(NULL);
}

void CMFCImagePaintArea::OnLButtonDown(UINT /*nFlags*/, CPoint point)
{
	if (m_pBitmap == NULL)
	{
		return;
	}

	CRect rectDraw;
	GetClientRect(rectDraw);

	rectDraw.right = rectDraw.left + m_sizeCell.cx * m_sizeImage.cx;
	rectDraw.bottom = rectDraw.top + m_sizeCell.cy * m_sizeImage.cy;

	rectDraw.DeflateRect(1, 1);

	if (!rectDraw.PtInRect(point))
	{
		return;
	}

	switch (m_Mode)
	{
	case IMAGE_EDIT_MODE_PEN:
		DrawPixel(point);
		break;

	case IMAGE_EDIT_MODE_LINE:
	case IMAGE_EDIT_MODE_RECT:
	case IMAGE_EDIT_MODE_ELLIPSE:
		ScreenToBitmap(point);
		m_rectDraw = CRect(point, CSize(0, 0));
		break;
	}

	SetCapture();
}

void CMFCImagePaintArea::OnLButtonUp(UINT /*nFlags*/, CPoint point)
{
	if (GetCapture() == this)
	{
		ReleaseCapture();
	}

	if (m_Mode == IMAGE_EDIT_MODE_RECT || m_Mode == IMAGE_EDIT_MODE_ELLIPSE)
	{
		if (m_rectDraw.Height() != 0)
		{
			if (m_rectDraw.top < m_rectDraw.bottom)
			{
				m_rectDraw.bottom ++;
			}
			else
			{
				m_rectDraw.top ++;
			}
		}

		if (m_rectDraw.Width() != 0)
		{
			if (m_rectDraw.left < m_rectDraw.right)
			{
				m_rectDraw.right ++;
			}
			else
			{
				m_rectDraw.left ++;
			}
		}
	}

	switch (m_Mode)
	{
	case IMAGE_EDIT_MODE_PEN:
		DrawPixel(point);
		break;

	case IMAGE_EDIT_MODE_LINE:
		if (m_rectDraw.Height() == 0 && m_rectDraw.Width() == 0)
		{
			DrawPixel(point);
		}
		else
		{
			CBitmap* pOldBitmap = m_memDC.SelectObject(m_pBitmap);
			CPen* pOldPen = (CPen*) m_memDC.SelectObject(&m_penDraw);

			m_memDC.MoveTo(m_rectDraw.left, m_rectDraw.top);
			m_memDC.LineTo(m_rectDraw.right, m_rectDraw.bottom);

			DrawPixel(point);

			m_memDC.SelectObject(pOldBitmap);
			m_memDC.SelectObject(pOldPen);

			Invalidate();
			UpdateWindow();

			GetParent()->InvalidateRect(m_rectParentPreviewArea);
		}
		break;

	case IMAGE_EDIT_MODE_RECT:
		if (m_rectDraw.Height() == 0 && m_rectDraw.Width() == 0)
		{
			DrawPixel(point);
		}
		else
		{
			CBitmap* pOldBitmap = m_memDC.SelectObject(m_pBitmap);
			CPen* pOldPen = (CPen*) m_memDC.SelectObject(&m_penDraw);
			CBrush* pOldBrush = (CBrush*) m_memDC.SelectStockObject(NULL_BRUSH);

			m_memDC.Rectangle(m_rectDraw);

			m_memDC.SelectObject(pOldBitmap);
			m_memDC.SelectObject(pOldPen);
			m_memDC.SelectObject(pOldBrush);

			Invalidate();
			UpdateWindow();

			GetParent()->InvalidateRect(m_rectParentPreviewArea);
		}
		break;

	case IMAGE_EDIT_MODE_ELLIPSE:
		if (m_rectDraw.Height() == 0 && m_rectDraw.Width() == 0)
		{
			DrawPixel(point);
		}
		else
		{
			CBitmap* pOldBitmap = m_memDC.SelectObject(m_pBitmap);
			CPen* pOldPen = (CPen*) m_memDC.SelectObject(&m_penDraw);
			CBrush* pOldBrush = (CBrush*) m_memDC.SelectStockObject(NULL_BRUSH);

			m_memDC.Ellipse(m_rectDraw);

			m_memDC.SelectObject(pOldBitmap);
			m_memDC.SelectObject(pOldPen);
			m_memDC.SelectObject(pOldBrush);

			Invalidate();
			UpdateWindow();

			GetParent()->InvalidateRect(m_rectParentPreviewArea);
		}
		break;

	case IMAGE_EDIT_MODE_FILL:
		ScreenToBitmap(point);
		FloodFill(point);
		break;

	case IMAGE_EDIT_MODE_COLOR:
		{
			ScreenToBitmap(point);

			CBitmap* pOldBitmap = m_memDC.SelectObject(m_pBitmap);
			COLORREF color = m_memDC.GetPixel(point);
			m_memDC.SelectObject(pOldBitmap);

			m_pParentDlg->OnPickColor(color);
		}
		break;
	}

	m_rectDraw.SetRectEmpty();
}

void CMFCImagePaintArea::OnCancelMode()
{
	if (GetCapture() == this)
	{
		ReleaseCapture();
	}
}

void CMFCImagePaintArea::DrawPixel(POINT point)
{
	CRect rectClient; // Client area rectangle
	GetClientRect(&rectClient);

	rectClient.InflateRect(-1, -1);

	CPoint ptBmp = point;
	ScreenToBitmap(ptBmp);

	CRect rect(CPoint(rectClient.left + ptBmp.x * m_sizeCell.cx, rectClient.top + ptBmp.y * m_sizeCell.cy), m_sizeCell);
	rect.InflateRect(-1, -1);

	CClientDC dc(this);
	dc.FillSolidRect(rect, m_rgbColor);

	// Update bitmap:
	CBitmap* pOldBitmap = m_memDC.SelectObject(m_pBitmap);
	m_memDC.SetPixel(ptBmp.x, ptBmp.y, CMFCToolBarImages::MapToSysColor(m_rgbColor));
	m_memDC.SelectObject(pOldBitmap);

	GetParent()->InvalidateRect(m_rectParentPreviewArea);
}

void CMFCImagePaintArea::SetBitmap(CBitmap* pBitmap)
{
	m_pBitmap = pBitmap;
	m_sizeCell = CSize(0, 0);

	if (m_pBitmap == NULL)
	{
		m_sizeImage.cx = 0;
		m_sizeImage.cy = 0;
		return;
	}

	BITMAP bmp;
	m_pBitmap->GetBitmap(&bmp);

	m_sizeImage.cx = bmp.bmWidth;
	m_sizeImage.cy = bmp.bmHeight;

	CRect rectClient;
	GetClientRect(rectClient);
	rectClient.DeflateRect(1, 1);

	m_sizeCell = CSize(rectClient.Width() / m_sizeImage.cx, rectClient.Height() / m_sizeImage.cy);

	if (m_penStretch.GetSafeHandle() != NULL)
	{
		m_penStretch.DeleteObject();
	}

	m_penStretch.CreatePen(PS_SOLID, min(m_sizeCell.cx, m_sizeCell.cy), afxGlobalData.clrBtnText);
}

BOOL CMFCImagePaintArea::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	CPoint ptCursor;
	::GetCursorPos(&ptCursor);
	ScreenToClient(&ptCursor);

	CRect rectDraw;
	GetClientRect(rectDraw);

	rectDraw.right = rectDraw.left + m_sizeCell.cx * m_sizeImage.cx;
	rectDraw.bottom = rectDraw.top + m_sizeCell.cy * m_sizeImage.cy;

	if (rectDraw.PtInRect(ptCursor))
	{
		switch (m_Mode)
		{
		case IMAGE_EDIT_MODE_PEN:
			::SetCursor(m_hcurPen);
			return TRUE;

		case IMAGE_EDIT_MODE_FILL:
			::SetCursor(m_hcurFill);
			return TRUE;

		case IMAGE_EDIT_MODE_LINE:
			::SetCursor(m_hcurLine);
			return TRUE;

		case IMAGE_EDIT_MODE_RECT:
			::SetCursor(m_hcurRect);
			return TRUE;

		case IMAGE_EDIT_MODE_ELLIPSE:
			::SetCursor(m_hcurEllipse);
			return TRUE;

		case IMAGE_EDIT_MODE_COLOR:
			::SetCursor(m_hcurColor);
			return TRUE;
		}
	}

	return CButton::OnSetCursor(pWnd, nHitTest, message);
}

void CMFCImagePaintArea::PreSubclassWindow()
{
	m_hcurPen = AfxGetApp()->LoadCursor(IDC_AFXBARRES_PEN);
	m_hcurFill = AfxGetApp()->LoadCursor(IDC_AFXBARRES_FILL);
	m_hcurLine = AfxGetApp()->LoadCursor(IDC_AFXBARRES_LINE);
	m_hcurRect = AfxGetApp()->LoadCursor(IDC_AFXBARRES_RECT);
	m_hcurEllipse = AfxGetApp()->LoadCursor(IDC_AFXBARRES_ELLIPSE);
	m_hcurColor = AfxGetApp()->LoadCursor(IDC_AFXBARRES_COLOR);

	CButton::PreSubclassWindow();
}

void CMFCImagePaintArea::ScreenToBitmap(CPoint& point)
{
	int x = (point.x - 1) / m_sizeCell.cx;
	int y = (point.y - 1) / m_sizeCell.cy;

	point.x = max(min(x, m_sizeImage.cx - 1), 0);
	point.y = max(min(y, m_sizeImage.cy - 1), 0);
}

void CMFCImagePaintArea::BitmapToClient(CRect& rect)
{
	rect.left = rect.left * m_sizeCell.cx + 1;
	rect.top = rect.top * m_sizeCell.cy + 1;
	rect.right = rect.right * m_sizeCell.cx + 1;
	rect.bottom = rect.bottom * m_sizeCell.cy + 1;

	rect.OffsetRect(m_sizeCell.cx / 2, m_sizeCell.cy / 2);
}

void CMFCImagePaintArea::FloodFill(const CPoint& point)
{
	ENSURE(m_pBitmap != NULL);

	CBitmap* pOldBitmap = m_memDC.SelectObject(m_pBitmap);

	CBrush br(m_rgbColor);
	CBrush* pBrOld = (CBrush*) m_memDC.SelectObject(&br);

	m_memDC.ExtFloodFill(point.x, point.y, m_memDC.GetPixel(point), FLOODFILLSURFACE);

	m_memDC.SelectObject(pOldBitmap);
	m_memDC.SelectObject(pBrOld);

	Invalidate();
	UpdateWindow();

	GetParent()->InvalidateRect(m_rectParentPreviewArea);
}

void CMFCImagePaintArea::SetColor(COLORREF color)
{
	m_rgbColor = color;

	if (m_penDraw.GetSafeHandle() != NULL)
	{
		m_penDraw.DeleteObject();
	}

	m_penDraw.CreatePen(PS_SOLID, 1, m_rgbColor);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxinl1.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifndef _AFX_ENABLE_INLINES


#define _AFX_INLINE
#include "afx.inl"

#define _AFXCOLL_INLINE
#include "afxcoll.inl"

// the main 'afxwin.inl' is in a separate file

#define _AFXDLGS_INLINE
#include "afxdlgs.inl"

// expand inlines
#define _AFXEXT_INLINE
#include "afxext.inl"

#endif //!_AFX_ENABLE_INLINES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxinl2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifndef _AFX_ENABLE_INLINES


#define _AFXWIN_INLINE
#include "afxwin1.inl"

#endif //!_AFX_ENABLE_INLINES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afximpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "sal.h"

#ifdef SetWindowLongPtrA
#undef SetWindowLongPtrA
inline LONG_PTR SetWindowLongPtrA( HWND hWnd, int nIndex, LONG_PTR dwNewLong )
{
	return( ::SetWindowLongA( hWnd, nIndex, LONG( dwNewLong ) ) );
}
#endif

#ifdef SetWindowLongPtrW
#undef SetWindowLongPtrW
inline LONG_PTR SetWindowLongPtrW( HWND hWnd, int nIndex, LONG_PTR dwNewLong )
{
	return( ::SetWindowLongW( hWnd, nIndex, LONG( dwNewLong ) ) );
}
#endif

#ifdef GetWindowLongPtrA
#undef GetWindowLongPtrA
inline LONG_PTR GetWindowLongPtrA( HWND hWnd, int nIndex )
{
	return( ::GetWindowLongA( hWnd, nIndex ) );
}
#endif

#ifdef GetWindowLongPtrW
#undef GetWindowLongPtrW
inline LONG_PTR GetWindowLongPtrW( HWND hWnd, int nIndex )
{
	return( ::GetWindowLongW( hWnd, nIndex ) );
}
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

struct AUX_DATA
{
	// system metrics
	int cxVScroll, cyHScroll;
	int cxIcon, cyIcon;

	int cxBorder2, cyBorder2;

	// device metrics for screen
	int cxPixelsPerInch, cyPixelsPerInch;

	// convenient system color
	HBRUSH hbrWindowFrame;
	HBRUSH hbrBtnFace;

	// color values of system colors used for CToolBar
	COLORREF clrBtnFace, clrBtnShadow, clrBtnHilite;
	COLORREF clrBtnText, clrWindowFrame;

	// standard cursors
	HCURSOR hcurWait;
	HCURSOR hcurArrow;
	HCURSOR hcurHelp;       // cursor used in Shift+F1 help

	// special GDI objects allocated on demand
	HFONT   hStatusFont;
	HFONT   hToolTipsFont;
	HBITMAP hbmMenuDot;

// Implementation
	AUX_DATA();
	~AUX_DATA();
	void UpdateSysColors();
	void UpdateSysMetrics();
};

extern AFX_DATA AUX_DATA afxData;

/////////////////////////////////////////////////////////////////////////////
// _AFX_EDIT_STATE

class _AFX_EDIT_STATE : public CNoTrackObject
{
public:
	_AFX_EDIT_STATE();
	virtual ~_AFX_EDIT_STATE();

	CFindReplaceDialog* pFindReplaceDlg; // find or replace dialog
	BOOL bFindOnly; // Is pFindReplace the find or replace?
	CString strFind;    // last find string
	CString strReplace; // last replace string
	BOOL bCase; // TRUE==case sensitive, FALSE==not
	int bNext;  // TRUE==search down, FALSE== search up
	BOOL bWord; // TRUE==match whole word, FALSE==not
};

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

class _AFX_RICHEDIT_STATE : public _AFX_EDIT_STATE
{
public:
	HINSTANCE m_hInstRichEdit;      // handle to RICHED32.DLL
	HINSTANCE m_hInstRichEdit2;      // handle to RICHED20.DLL
	virtual ~_AFX_RICHEDIT_STATE();
};

AFX_DATA EXTERN_PROCESS_LOCAL(_AFX_RICHEDIT_STATE, _afxRichEditState)

_AFX_RICHEDIT_STATE* AFX_CDECL AfxGetRichEditState();

/////////////////////////////////////////////////////////////////////////////
// _AFX_HTMLHELP_STATE

// for dll builds we just delay load it
#ifndef _AFXDLL
typedef HWND (WINAPI HTMLHELPPROC)(HWND hwndCaller, LPCTSTR pszFile, UINT uCommand, DWORD_PTR dwData);

class _AFX_HTMLHELP_STATE : public CNoTrackObject
{
public:
	virtual ~_AFX_HTMLHELP_STATE();

	HINSTANCE m_hInstHtmlHelp;
	HTMLHELPPROC *m_pfnHtmlHelp;
};
EXTERN_PROCESS_LOCAL(_AFX_HTMLHELP_STATE, _afxHtmlHelpState)
#endif

HWND WINAPI AfxHtmlHelp(HWND hWnd, LPCTSTR szHelpFilePath, UINT nCmd, DWORD_PTR dwData);

#undef AFX_DATA
#define AFX_DATA

////////////////////////////////////////////////////////////////////////////
// other global state

class CPushRoutingView
{
protected:
	CView* pOldRoutingView;
	_AFX_THREAD_STATE* pThreadState;
	CPushRoutingView* pOldPushRoutingView;

public:
	CPushRoutingView(CView* pNewRoutingView)
	{
		pThreadState = AfxGetThreadState();
		if (pThreadState != NULL)
		{
			pOldPushRoutingView = pThreadState->m_pPushRoutingView;
			pOldRoutingView = pThreadState->m_pRoutingView;
			pThreadState->m_pRoutingView = pNewRoutingView;
			pThreadState->m_pPushRoutingView = this;
		}
	}
	~CPushRoutingView()
	{ 
		if (pThreadState != NULL)
		{
			ASSERT( pThreadState->m_pPushRoutingView == this );
			pThreadState->m_pRoutingView = pOldRoutingView;
			pThreadState->m_pPushRoutingView = pOldPushRoutingView;
		}
	}
	void Pop()
	{
		ASSERT( pThreadState != NULL );
		if (pThreadState != NULL)
		{
			ASSERT( pThreadState->m_pPushRoutingView == this );
			pThreadState->m_pRoutingView = pOldRoutingView;
			pThreadState->m_pPushRoutingView = pOldPushRoutingView;
			pThreadState = NULL;
		}
	}
};

// Note: afxData.cxBorder and afxData.cyBorder aren't used anymore
#define AFX_CX_BORDER   1
#define AFX_CY_BORDER   1

// states for Shift+F1 hep mode
#define HELP_INACTIVE   0   // not in Shift+F1 help mode (must be 0)
#define HELP_ACTIVE     1   // in Shift+F1 help mode (non-zero)
#define HELP_ENTERING   2   // entering Shift+F1 help mode (non-zero)

/////////////////////////////////////////////////////////////////////////////
// Window class names and other window creation support

// from wincore.cpp
extern const TCHAR _afxWnd[];           // simple child windows/controls
extern const TCHAR _afxWndControlBar[]; // controls with gray backgrounds
extern const TCHAR _afxWndMDIFrame[];
extern const TCHAR _afxWndFrameOrView[];
extern const TCHAR _afxWndOleControl[];

#define AFX_WND_REG                     0x00001
#define AFX_WNDCONTROLBAR_REG           0x00002
#define AFX_WNDMDIFRAME_REG             0x00004
#define AFX_WNDFRAMEORVIEW_REG          0x00008
#define AFX_WNDCOMMCTLS_REG             0x00010 // means all original Win95
#define AFX_WNDOLECONTROL_REG           0x00020
#define AFX_WNDCOMMCTL_UPDOWN_REG       0x00040 // these are original Win95
#define AFX_WNDCOMMCTL_TREEVIEW_REG     0x00080
#define AFX_WNDCOMMCTL_TAB_REG          0x00100
#define AFX_WNDCOMMCTL_PROGRESS_REG     0x00200
#define AFX_WNDCOMMCTL_LISTVIEW_REG     0x00400
#define AFX_WNDCOMMCTL_HOTKEY_REG       0x00800
#define AFX_WNDCOMMCTL_BAR_REG          0x01000
#define AFX_WNDCOMMCTL_ANIMATE_REG      0x02000
#define AFX_WNDCOMMCTL_INTERNET_REG     0x04000 // these are new in IE4
#define AFX_WNDCOMMCTL_COOL_REG         0x08000
#define AFX_WNDCOMMCTL_USEREX_REG       0x10000
#define AFX_WNDCOMMCTL_DATE_REG         0x20000
#define AFX_WNDCOMMCTL_LINK_REG         0x40000 // new in IE6 (Unicode only control)
#define AFX_WNDCOMMCTL_PAGER_REG        0x80000 // new in IE5? (Unicode only control)

#define AFX_WIN95CTLS_MASK              0x03FC0 // UPDOWN -> ANIMATE
#ifndef _UNICODE
#define AFX_WNDCOMMCTLSALL_REG          0x3C010 // COMMCTLS|INTERNET|COOL|USEREX|DATE
#define AFX_WNDCOMMCTLSNEW_REG          0x3C000 // INTERNET|COOL|USEREX|DATE
#else
#define AFX_WNDCOMMCTLSALL_REG          0xFC010 // COMMCTLS|INTERNET|COOL|USEREX|DATE|LINK|PAGER
#define AFX_WNDCOMMCTLSNEW_REG          0xFC000 // INTERNET|COOL|USEREX|DATE|LINK|PAGER
#endif

#define AfxDeferRegisterClass(fClass) AfxEndDeferRegisterClass(fClass)

BOOL AFXAPI AfxEndDeferRegisterClass(LONG fToRegister);

// MFC needs to call this function before creating CNetAddressCtrl
BOOL AFXAPI AfxInitNetworkAddressControl();

// MFC has its own version of the TOOLINFO structure containing the
// the Win2K base version of the structure. Since MFC targets Win2K base,
// we need this structure so calls into that old library don't fail.

typedef struct tagAFX_OLDTOOLINFO {
	UINT cbSize;
	UINT uFlags;
	HWND hwnd;
	UINT uId;
	RECT rect;
	HINSTANCE hinst;
	LPTSTR lpszText;
	LPARAM lParam;
} AFX_OLDTOOLINFO;

typedef struct tagAFX_OLDREBARBANDINFO{
	UINT cbSize;
	UINT fMask;
	UINT fStyle;
	COLORREF clrFore;
	COLORREF clrBack;
	LPTSTR lpText;
	UINT cch;
	int iImage;
	HWND hwndChild;
	UINT cxMinChild;
	UINT cyMinChild;
	UINT cx;
	HBITMAP hbmBack;
	UINT wID;
#if (_WIN32_IE >= 0x0400)
	UINT cyChild;  
	UINT cyMaxChild;
	UINT cyIntegral;
	UINT cxIdeal;
	LPARAM lParam;
	UINT cxHeader;
#endif
 } AFX_OLDREBARBANDINFO;

// special AFX window class name mangling

#ifndef _UNICODE
#define _UNICODE_SUFFIX
#else
#define _UNICODE_SUFFIX _T("u")
#endif

#ifndef _DEBUG
#define _DEBUG_SUFFIX
#else
#define _DEBUG_SUFFIX _T("d")
#endif

#ifdef _AFXDLL
#define _STATIC_SUFFIX
#else
#define _STATIC_SUFFIX _T("s")
#endif

#define AFX_WNDCLASS(s) \
	_T("Afx") _T(s) _T(_MFC_FILENAME_VER) _STATIC_SUFFIX _UNICODE_SUFFIX _DEBUG_SUFFIX

#define AFX_WND             AFX_WNDCLASS("Wnd")
#define AFX_WNDCONTROLBAR   AFX_WNDCLASS("ControlBar")
#define AFX_WNDMDIFRAME     AFX_WNDCLASS("MDIFrame")
#define AFX_WNDFRAMEORVIEW  AFX_WNDCLASS("FrameOrView")
#define AFX_WNDOLECONTROL   AFX_WNDCLASS("OleControl")

// dialog/commdlg hook procs
INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);
UINT_PTR CALLBACK _AfxCommDlgProc(HWND hWnd, UINT, WPARAM, LPARAM);

// support for standard dialogs
extern UINT _afxMsgSETRGB;
typedef UINT_PTR (CALLBACK* COMMDLGPROC)(HWND, UINT, WPARAM, LPARAM);

// conversion helpers
//int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
//int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

/////////////////////////////////////////////////////////////////////////////
// Extended dialog templates (new in Win95)

#pragma pack(push, 1)

typedef struct
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;
} DLGTEMPLATEEX;

typedef struct
{
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	short x;
	short y;
	short cx;
	short cy;
	DWORD id;
} DLGITEMTEMPLATEEX;

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// Special helpers

void AFXAPI AfxCancelModes(HWND hWndRcvr);
HWND AFXAPI AfxGetParentOwner(HWND hWnd);
BOOL AFXAPI AfxIsDescendant(HWND hWndParent, HWND hWndChild);
BOOL AFXAPI AfxHelpEnabled();  // determine if ID_HELP handler exists
void AFXAPI AfxDeleteObject(HGDIOBJ* pObject);
BOOL AFXAPI AfxCustomLogFont(UINT nIDS, LOGFONT* pLogFont);
BOOL AFXAPI AfxGetPropSheetFont(CString& strFace, WORD& wSize, BOOL bWizard);

BOOL AFXAPI _AfxIsComboBoxControl(HWND hWnd, UINT nStyle);
BOOL AFXAPI _AfxCheckCenterDialog(LPCTSTR lpszResource);
BOOL AFXAPI _AfxCompareClassName(HWND hWnd, LPCTSTR lpszClassName);
HWND AFXAPI _AfxChildWindowFromPoint(HWND, POINT);
HWND AFXAPI _AfxTopChildWindowFromPoint(HWND, POINT);

// for determining version of COMCTL32.DLL
#define VERSION_WIN4    MAKELONG(0, 4)
#define VERSION_IE3             MAKELONG(70, 4)
#define VERSION_IE4             MAKELONG(71, 4)
#define VERSION_IE401   MAKELONG(72, 4)
#define VERSION_6		MAKELONG(0, 6)
extern int _afxComCtlVersion;
DWORD AFXAPI _AfxGetComCtlVersion();

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

// UNICODE/MBCS abstractions
#ifdef _MBCS
	extern AFX_DATA const BOOL _afxDBCS;
#else
	#define _afxDBCS FALSE
#endif

#undef AFX_DATA
#define AFX_DATA

// determine number of elements in an array (not bytes)
#ifndef _countof
#define _countof(array) (sizeof(array)/sizeof(array[0]))
#endif

#ifndef _AFX_PORTABLE
int AFX_CDECL AfxCriticalNewHandler(size_t nSize);
#endif

void AFXAPI AfxGlobalFree(HGLOBAL hGlobal);

/////////////////////////////////////////////////////////////////////////////
// locale-invariant comparison helpers till CRT gets that support
inline int AfxInvariantStrICmp(const char *pszLeft, const char *pszRight)
{
    return ::CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT),
                            NORM_IGNORECASE,
                            pszLeft,
                            -1,
                            pszRight,
                            -1)-CSTR_EQUAL;
}

inline int AfxInvariantStrICmp(const wchar_t *pwszLeft, const wchar_t *pwszRight)
{
    return ::CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT),
                            NORM_IGNORECASE,
                            pwszLeft,
                            -1,
                            pwszRight,
                            -1)-CSTR_EQUAL;
}


/////////////////////////////////////////////////////////////////////////////
// static exceptions

extern CNotSupportedException _simpleNotSupportedException;
extern CMemoryException _simpleMemoryException;
extern CUserException _simpleUserException;
extern CResourceException _simpleResourceException;

/////////////////////////////////////////////////////////////////////////////
// useful message ranges

#define WM_SYSKEYFIRST  WM_SYSKEYDOWN
#define WM_SYSKEYLAST   WM_SYSDEADCHAR

#define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
#define WM_NCMOUSELAST  WM_NCMBUTTONDBLCLK


/////////////////////////////////////////////////////////////////////////////
// AFX_CRITICAL_SECTION

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

// these globals are protected by the same critical section
#define CRIT_DYNLINKLIST    0
#define CRIT_RUNTIMECLASSLIST   0
#define CRIT_OBJECTFACTORYLIST  0
#define CRIT_LOCKSHARED 0
// these globals are not protected by independent critical sections
#define CRIT_REGCLASSLIST   1
#define CRIT_WAITCURSOR     2
#define CRIT_DROPSOURCE     3
#define CRIT_DROPTARGET     4
#define CRIT_RECTTRACKER    5
#define CRIT_EDITVIEW       6
#define CRIT_WINMSGCACHE    7
#define CRIT_HALFTONEBRUSH  8
#define CRIT_SPLITTERWND    9
#define CRIT_MINIFRAMEWND   10
#define CRIT_CTLLOCKLIST    11
#define CRIT_DYNDLLLOAD     12
#define CRIT_TYPELIBCACHE   13
#define CRIT_STOCKMASK      14
#define CRIT_ODBC           15
#define CRIT_PROCESSLOCAL   16
#define CRIT_MAX    17  // Note: above plus one!

#ifdef _MT
void AFXAPI AfxLockGlobals(int nLockType);
void AFXAPI AfxUnlockGlobals(int nLockType);
BOOL AFXAPI AfxCriticalInit();
void AFXAPI AfxCriticalTerm();
#else
#define AfxLockGlobals(nLockType)
#define AfxUnlockGlobals(nLockType)
#define AfxCriticalInit() (TRUE)
#define AfxCriticalTerm()
#endif

class CInternalGlobalLock {
public:	
	
	
	CInternalGlobalLock(int nLockType = INT_MAX)
	: m_nLockType(nLockType)
	{
		if (m_nLockType!=INT_MAX)
		{
			Lock();
		}
	}
	~CInternalGlobalLock()
	{
		Unlock();
	}
	void Lock(int nLockType = INT_MAX) //Pass locktype in first call to lock, to avoid error C2362: initialization of 'winMsgLock' is skipped by 'goto LReturnTrue'
	{		
		if (nLockType!=INT_MAX)
		{
			ENSURE(m_nLockType == INT_MAX || m_nLockType == nLockType);
			m_nLockType = nLockType;
		}
		ENSURE(m_nLockType != INT_MAX);
		AfxLockGlobals(m_nLockType);
	}
	void Unlock()
	{		
		if (m_nLockType!=INT_MAX)
		{
			AfxUnlockGlobals(m_nLockType);			
			m_nLockType = INT_MAX;
		}		
	}
private:
	int m_nLockType;
};
/////////////////////////////////////////////////////////////////////////////
// Portability abstractions

#define _AfxSetDlgCtrlID(hWnd, nID)     SetWindowLong(hWnd, GWL_ID, nID)
#define _AfxGetDlgCtrlID(hWnd)          ((UINT)::GetDlgCtrlID(hWnd))

// misc helpers
BOOL AFXAPI AfxFullPath(_Pre_notnull_ _Post_z_ LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
BOOL AFXAPI AfxComparePath(LPCTSTR lpszPath1, LPCTSTR lpszPath2);

UINT AFXAPI AfxGetFileTitle(LPCTSTR lpszPathName, _Out_cap_(nMax) LPTSTR lpszTitle, UINT nMax);
UINT AFXAPI AfxGetFileName(LPCTSTR lpszPathName, _Out_opt_cap_(nMax) LPTSTR lpszTitle, UINT nMax);
void AFX_CDECL AfxTimeToFileTime(const CTime& time, LPFILETIME pFileTime);
void AFXAPI AfxGetRoot(LPCTSTR lpszPath, CString& strRoot);

#ifndef _AFX_NO_OLE_SUPPORT
class AFX_COM
{
public:
	HRESULT CreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
		REFIID riid, LPVOID* ppv);
	HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
};

CString AFXAPI AfxStringFromCLSID(REFCLSID rclsid);
BOOL AFXAPI AfxGetInProcServer(LPCTSTR lpszCLSID, CString& str);
BOOL AFXAPI AfxResolveShortcut(CWnd* pWnd, LPCTSTR pszShortcutFile,
	_Out_cap_(cchPath) LPTSTR pszPath, int cchPath);
#endif // _AFX_NO_OLE_SUPPORT

#define NULL_TLS ((DWORD)-1)

/////////////////////////////////////////////////////////////////////////////
// Message map and message dispatch

const AFX_MSGMAP_ENTRY* AFXAPI
AfxFindMessageEntry(const AFX_MSGMAP_ENTRY* lpEntry,
	UINT nMsg, UINT nCode, UINT nID);

union MessageMapFunctions
{
	AFX_PMSG pfn;   // generic member function pointer

	BOOL (AFX_MSG_CALL CCmdTarget::*pfn_b_D)(CDC*);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfn_b_b)(BOOL);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfn_b_u)(UINT);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfn_b_h)(HANDLE);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfn_b_W_u_u)(CWnd*, UINT, UINT);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfn_b_W_COPYDATASTRUCT)(CWnd*, COPYDATASTRUCT*);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfn_b_HELPINFO)(LPHELPINFO);
	HBRUSH (AFX_MSG_CALL CCmdTarget::*pfn_B_D_W_u)(CDC*, CWnd*, UINT);
	HBRUSH (AFX_MSG_CALL CCmdTarget::*pfn_B_D_u)(CDC*, UINT);
	int (AFX_MSG_CALL CCmdTarget::*pfn_i_u_W_u)(UINT, CWnd*, UINT);
	int (AFX_MSG_CALL CCmdTarget::*pfn_i_u_u)(UINT, UINT);
	int (AFX_MSG_CALL CCmdTarget::*pfn_i_W_u_u)(CWnd*, UINT, UINT);
	int (AFX_MSG_CALL CWnd::*pfn_i_s)(LPTSTR);
	LRESULT (AFX_MSG_CALL CWnd::*pfn_l_w_l)(WPARAM, LPARAM);
	LRESULT (AFX_MSG_CALL CWnd::*pfn_l_u_u_M)(UINT, UINT, CMenu*);
	void (AFX_MSG_CALL CWnd::*pfn_v_b_h)(BOOL, HANDLE);
	void (AFX_MSG_CALL CWnd::*pfn_v_h)(HANDLE);
	void (AFX_MSG_CALL CWnd::*pfn_v_h_h)(HANDLE,HANDLE);
	void (AFX_MSG_CALL CWnd::*pfn_v_v)();
	int (AFX_MSG_CALL CWnd::*pfn_i_u)(UINT);
	HCURSOR (AFX_MSG_CALL CWnd::*pfn_C_v)();
	UINT (AFX_MSG_CALL CWnd::*pfn_u_u)(UINT);
	BOOL (AFX_MSG_CALL CWnd::*pfn_b_v)();
	void (AFX_MSG_CALL CWnd::*pfn_v_u)(UINT);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_u)(UINT, UINT);
	void (AFX_MSG_CALL CWnd::*pfn_v_i_i)(int, int);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_u_u)(UINT, UINT, UINT);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_i_i)(UINT, int, int);
	void (AFX_MSG_CALL CWnd::*pfn_v_w_l)(WPARAM, LPARAM);
	void (AFX_MSG_CALL CWnd::*pfn_v_b_W_W)(BOOL, CWnd*, CWnd*);
	void (AFX_MSG_CALL CWnd::*pfn_v_D)(CDC*);
	void (AFX_MSG_CALL CWnd::*pfn_v_M)(CMenu*);
	void (AFX_MSG_CALL CWnd::*pfn_v_M_u_b)(CMenu*, UINT, BOOL);
	void (AFX_MSG_CALL CWnd::*pfn_v_W)(CWnd*);
	void (AFX_MSG_CALL CWnd::*pfn_v_W_u_u)(CWnd*, UINT, UINT);
	void (AFX_MSG_CALL CWnd::*pfn_v_W_p)(CWnd*, CPoint);
	void (AFX_MSG_CALL CWnd::*pfn_v_W_h)(CWnd*, HANDLE);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_W)(UINT, CWnd*);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_W_b)(UINT, CWnd*, BOOL);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_u_W)(UINT, UINT, CWnd*);
	void (AFX_MSG_CALL CWnd::*pfn_v_s)(LPTSTR);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_cs)(UINT, LPCTSTR);
	void (AFX_MSG_CALL CWnd::*pfn_v_i_s)(int, LPTSTR);
	int (AFX_MSG_CALL CWnd::*pfn_i_i_s)(int, LPTSTR);
	UINT (AFX_MSG_CALL CWnd::*pfn_u_p)(CPoint);
	LRESULT (AFX_MSG_CALL CWnd::*pfn_l_p)(CPoint);
	UINT (AFX_MSG_CALL CWnd::*pfn_u_v)();
	void (AFX_MSG_CALL CWnd::*pfn_v_b_NCCALCSIZEPARAMS)(BOOL, NCCALCSIZE_PARAMS*);
	void (AFX_MSG_CALL CWnd::*pfn_v_v_WINDOWPOS)(WINDOWPOS*);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_u_M)(UINT, UINT, HMENU);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_p)(UINT, CPoint);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_pr)(UINT, LPRECT);
	BOOL (AFX_MSG_CALL CWnd::*pfn_b_u_s_p)(UINT, short, CPoint);
	void (AFX_MSG_CALL CWnd::*pfn_MOUSEHWHEEL)(UINT, short, CPoint);
	LRESULT (AFX_MSG_CALL CWnd::*pfn_l_v)();
	UINT (AFX_MSG_CALL CWnd::*pfn_u_W_u)(CWnd*, UINT);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_M)(UINT, CMenu*);
	UINT (AFX_MSG_CALL CWnd::*pfn_u_u_M)(UINT, CMenu*);
	UINT (AFX_MSG_CALL CWnd::*pfn_u_v_MENUGETOBJECTINFO)(MENUGETOBJECTINFO*);
	void (AFX_MSG_CALL CWnd::*pfn_v_M_u)(CMenu*, UINT);
	void (AFX_MSG_CALL CWnd::*pfn_v_u_LPMDINEXTMENU)(UINT, LPMDINEXTMENU);
	void (AFX_MSG_CALL CWnd::*pfn_APPCOMMAND)(CWnd*, UINT, UINT, UINT);
	BOOL (AFX_MSG_CALL CWnd::*pfn_RAWINPUT)(UINT, HRAWINPUT);
	UINT (AFX_MSG_CALL CWnd::*pfn_u_u_u)(UINT, UINT);
	void (AFX_MSG_CALL CWnd::*pfn_MOUSE_XBUTTON)(UINT, UINT, CPoint);
	void (AFX_MSG_CALL CWnd::*pfn_MOUSE_NCXBUTTON)(short, UINT, CPoint);
	void (AFX_MSG_CALL CWnd::*pfn_INPUTLANGCHANGE)(UINT, UINT);
	BOOL (AFX_MSG_CALL CWnd::*pfn_v_u_h)(UINT, HANDLE);
	void (AFX_MSG_CALL CWnd::*pfn_INPUTDEVICECHANGE)(unsigned short, HANDLE);

	// type safe variant for thread messages
	void (AFX_MSG_CALL CWinThread::*pfn_THREAD)(WPARAM, LPARAM);

	// specific type safe variants for WM_COMMAND and WM_NOTIFY messages
	void (AFX_MSG_CALL CCmdTarget::*pfnCmd_v_v)();
	BOOL (AFX_MSG_CALL CCmdTarget::*pfnCmd_b_v)();
	void (AFX_MSG_CALL CCmdTarget::*pfnCmd_v_u)(UINT);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfnCmd_b_u)(UINT);

	void (AFX_MSG_CALL CCmdTarget::*pfnNotify_v_NMHDR_pl)(NMHDR*, LRESULT*);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfnNotify_b_NMHDR_pl)(NMHDR*, LRESULT*);
	void (AFX_MSG_CALL CCmdTarget::*pfnNotify_v_u_NMHDR_pl)(UINT, NMHDR*, LRESULT*);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfnNotify_b_u_NMHDR_pl)(UINT, NMHDR*, LRESULT*);
	void (AFX_MSG_CALL CCmdTarget::*pfnCmdUI_v_C)(CCmdUI*);
	void (AFX_MSG_CALL CCmdTarget::*pfnCmdUI_v_C_u)(CCmdUI*, UINT);

	void (AFX_MSG_CALL CCmdTarget::*pfnCmd_v_pv)(void*);
	BOOL (AFX_MSG_CALL CCmdTarget::*pfnCmd_b_pv)(void*);

//OLD
	// specific type safe variants for WM-style messages
//	BOOL    (AFX_MSG_CALL CWnd::*pfn_bD)(CDC*);
//	BOOL    (AFX_MSG_CALL CWnd::*pfn_bb)(BOOL);
//	BOOL    (AFX_MSG_CALL CWnd::*pfn_bWww)(CWnd*, UINT, UINT);
//	BOOL    (AFX_MSG_CALL CWnd::*pfn_bHELPINFO)(HELPINFO*);
//	BOOL    (AFX_MSG_CALL CWnd::*pfn_bWCDS)(CWnd*, COPYDATASTRUCT*);
//	HBRUSH  (AFX_MSG_CALL CWnd::*pfn_hDWw)(CDC*, CWnd*, UINT);
//	HBRUSH  (AFX_MSG_CALL CWnd::*pfn_hDw)(CDC*, UINT);
//	int     (AFX_MSG_CALL CWnd::*pfn_iwWw)(UINT, CWnd*, UINT);
//	int     (AFX_MSG_CALL CWnd::*pfn_iww)(UINT, UINT);
//	int     (AFX_MSG_CALL CWnd::*pfn_iWww)(CWnd*, UINT, UINT);
//	int     (AFX_MSG_CALL CWnd::*pfn_is)(LPTSTR);
//	LRESULT (AFX_MSG_CALL CWnd::*pfn_lwl)(WPARAM, LPARAM);
//	LRESULT (AFX_MSG_CALL CWnd::*pfn_lwwM)(UINT, UINT, CMenu*);
//	void    (AFX_MSG_CALL CWnd::*pfn_vv)(void);

//	void    (AFX_MSG_CALL CWnd::*pfn_vw)(UINT);
//	void    (AFX_MSG_CALL CWnd::*pfn_vww)(UINT, UINT);
//	void    (AFX_MSG_CALL CWnd::*pfn_vvii)(int, int);
//	void    (AFX_MSG_CALL CWnd::*pfn_vwww)(UINT, UINT, UINT);
//	void    (AFX_MSG_CALL CWnd::*pfn_vwii)(UINT, int, int);
//	void    (AFX_MSG_CALL CWnd::*pfn_vwl)(WPARAM, LPARAM);
//	void    (AFX_MSG_CALL CWnd::*pfn_vbWW)(BOOL, CWnd*, CWnd*);
//	void    (AFX_MSG_CALL CWnd::*pfn_vD)(CDC*);
//	void    (AFX_MSG_CALL CWnd::*pfn_vM)(CMenu*);
//	void    (AFX_MSG_CALL CWnd::*pfn_vMwb)(CMenu*, UINT, BOOL);

//	void    (AFX_MSG_CALL CWnd::*pfn_vW)(CWnd*);
//	void    (AFX_MSG_CALL CWnd::*pfn_vWww)(CWnd*, UINT, UINT);
//	void    (AFX_MSG_CALL CWnd::*pfn_vWp)(CWnd*, CPoint);
//	void    (AFX_MSG_CALL CWnd::*pfn_vWh)(CWnd*, HANDLE);
//	void    (AFX_MSG_CALL CWnd::*pfn_vwW)(UINT, CWnd*);
//	void    (AFX_MSG_CALL CWnd::*pfn_vwWb)(UINT, CWnd*, BOOL);
//	void    (AFX_MSG_CALL CWnd::*pfn_vwwW)(UINT, UINT, CWnd*);
//	void    (AFX_MSG_CALL CWnd::*pfn_vwwx)(UINT, UINT);
//	void    (AFX_MSG_CALL CWnd::*pfn_vs)(LPTSTR);
//	void    (AFX_MSG_CALL CWnd::*pfn_vOWNER)(int, LPTSTR);   // force return TRUE
//	int     (AFX_MSG_CALL CWnd::*pfn_iis)(int, LPTSTR);
//	UINT    (AFX_MSG_CALL CWnd::*pfn_wp)(CPoint);
//	UINT    (AFX_MSG_CALL CWnd::*pfn_wv)(void);
	void    (AFX_MSG_CALL CWnd::*pfn_vPOS)(WINDOWPOS*);
	void    (AFX_MSG_CALL CWnd::*pfn_vCALC)(BOOL, NCCALCSIZE_PARAMS*);
	void    (AFX_MSG_CALL CWnd::*pfn_vwp)(UINT, CPoint);
	void    (AFX_MSG_CALL CWnd::*pfn_vwwh)(UINT, UINT, HANDLE);
	BOOL    (AFX_MSG_CALL CWnd::*pfn_bwsp)(UINT, short, CPoint);
//	void    (AFX_MSG_CALL CWnd::*pfn_vws)(UINT, LPCTSTR);
};

CHandleMap* PASCAL afxMapHWND(BOOL bCreate = FALSE);
CHandleMap* PASCAL afxMapHIMAGELIST(BOOL bCreate = FALSE);
CHandleMap* PASCAL afxMapHDC(BOOL bCreate = FALSE);
CHandleMap* PASCAL afxMapHGDIOBJ(BOOL bCreate = FALSE);
CHandleMap* PASCAL afxMapHMENU(BOOL bCreate = FALSE);

/////////////////////////////////////////////////////////////////////////////
// Debugging/Tracing helpers

#ifdef _DEBUG
	void AFXAPI _AfxTraceMsg(LPCTSTR lpszPrefix, const MSG* pMsg);
	BOOL AFXAPI _AfxCheckDialogTemplate(LPCTSTR lpszResource,
		BOOL bInvisibleChild);
#endif


#undef AFX_DATA
#define AFX_DATA

class CVariantBoolPair
{
public:
	CVariantBoolPair()
	: m_pbool(NULL),m_pvarbool(NULL) 
	{
	}
	CVariantBoolPair(BOOL* pbool,VARIANT_BOOL* pvarbool,BOOL bOwnBOOLMem = TRUE)
	: m_pbool(pbool),m_pvarbool(pvarbool),m_bOwnBOOLMem(bOwnBOOLMem)
	{
		ENSURE(m_pbool!=NULL && m_pvarbool!=NULL);
	}
	~CVariantBoolPair()
	{
		if (m_bOwnBOOLMem)
		{
			delete m_pbool;		
		}
#ifdef _DEBUG
		m_pbool = NULL;
		m_pvarbool=NULL;
#endif
		
	}
	CVariantBoolPair& operator =(const CVariantBoolPair& rhs)
	{
		if (this != &rhs ) 
		{ 
			m_pbool	      = rhs.Detach();
			m_pvarbool    = rhs.m_pvarbool;
			m_bOwnBOOLMem = rhs.m_bOwnBOOLMem;
		}
		return *this; 
	}

	CVariantBoolPair(const CVariantBoolPair& rhs)
	{		
		m_pbool	      = rhs.Detach();
		m_pvarbool    = rhs.m_pvarbool;
		m_bOwnBOOLMem = rhs.m_bOwnBOOLMem;
	}
	BOOL* Detach() const
	{
		BOOL* pb=m_pbool;
		if (m_bOwnBOOLMem)
		{
			m_pbool=NULL;
		}
		return pb;
	}
	mutable BOOL* m_pbool;
	VARIANT_BOOL* m_pvarbool;
	BOOL m_bOwnBOOLMem;
};
class CVariantBoolConverter 
{
protected:
	CArray<CVariantBoolPair> m_boolArgs;
public:
	void AddPair(const CVariantBoolPair& newPair)
	{
		m_boolArgs.Add(newPair);
	}
	void CopyBOOLsIntoVarBools()
	{
		for (int i=0 ; i < m_boolArgs.GetCount() ; ++i)
		{
			ENSURE(m_boolArgs[i].m_pbool!=NULL && m_boolArgs[i].m_pvarbool!=NULL);
			*m_boolArgs[i].m_pvarbool = *m_boolArgs[i].m_pbool ? VARIANT_TRUE : VARIANT_FALSE;
		}
	}

	void CopyVarBoolsIntoBOOLs()
	{
		for (int i=0 ; i < m_boolArgs.GetCount() ; ++i)
		{
			ENSURE(m_boolArgs[i].m_pbool!=NULL && m_boolArgs[i].m_pvarbool!=NULL);
			*m_boolArgs[i].m_pbool = (*m_boolArgs[i].m_pvarbool == 0)  ? FALSE : TRUE;
		}
	}
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxheaderctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxheaderctrl.h"
#include "afxglobals.h"
#include "afxvisualmanager.h"
#include "afxtrackmouse.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CMFCHeaderCtrl, CHeaderCtrl)

/////////////////////////////////////////////////////////////////////////////
// CMFCHeaderCtrl

CMFCHeaderCtrl::CMFCHeaderCtrl()
{
	m_bIsMousePressed = FALSE;
	m_bMultipleSort = FALSE;
	m_bAscending = TRUE;
	m_nHighlightedItem = -1;
	m_bTracked = FALSE;
	m_bIsDlgControl = FALSE;
	m_hFont = NULL;
}

CMFCHeaderCtrl::~CMFCHeaderCtrl()
{
}

//{{AFX_MSG_MAP(CMFCHeaderCtrl)
BEGIN_MESSAGE_MAP(CMFCHeaderCtrl, CHeaderCtrl)
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CANCELMODE()
	ON_WM_CREATE()
	ON_MESSAGE(WM_MOUSELEAVE, &CMFCHeaderCtrl::OnMouseLeave)
	ON_MESSAGE(WM_SETFONT, &CMFCHeaderCtrl::OnSetFont)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCHeaderCtrl message handlers

void CMFCHeaderCtrl::OnDrawItem(CDC* pDC, int iItem, CRect rect, BOOL bIsPressed, BOOL bIsHighlighted)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	const int nTextMargin = 5;

	// Draw border:
	CMFCVisualManager::GetInstance()->OnDrawHeaderCtrlBorder(this, pDC, rect, bIsPressed, bIsHighlighted);

	if (iItem < 0)
	{
		return;
	}

	int nSortVal = 0;
	if (m_mapColumnsStatus.Lookup(iItem, nSortVal) && nSortVal != 0)
	{
		// Draw sort arrow:
		CRect rectArrow = rect;
		rectArrow.DeflateRect(5, 5);
		rectArrow.left = rectArrow.right - rectArrow.Height();

		if (bIsPressed)
		{
			rectArrow.right++;
			rectArrow.bottom++;
		}

		rect.right = rectArrow.left - 1;

		int dy2 = (int)(.134 * rectArrow.Width());
		rectArrow.DeflateRect(0, dy2);

		m_bAscending = nSortVal > 0;
		OnDrawSortArrow(pDC, rectArrow);
	}

	HD_ITEM hdItem;
	memset(&hdItem, 0, sizeof(hdItem));
	hdItem.mask = HDI_FORMAT | HDI_BITMAP | HDI_TEXT | HDI_IMAGE;

	TCHAR szText [256];
	hdItem.pszText = szText;
	hdItem.cchTextMax = 255;

	if (!GetItem(iItem, &hdItem))
	{
		return;
	}

	// Draw bitmap and image:
	if ((hdItem.fmt & HDF_IMAGE) && hdItem.iImage >= 0)
	{
		// By Max Khiszinsky:

		// The column has a image from imagelist:
		CImageList* pImageList = GetImageList();
		if (pImageList != NULL)
		{
			int cx = 0;
			int cy = 0;

			VERIFY(::ImageList_GetIconSize(*pImageList, &cx, &cy));

			CPoint pt = rect.TopLeft();
			pt.x ++;
			pt.y = (rect.top + rect.bottom - cy) / 2;

			VERIFY(pImageList->Draw(pDC, hdItem.iImage, pt, ILD_NORMAL));

			rect.left += cx;
		}
	}

	if ((hdItem.fmt &(HDF_BITMAP | HDF_BITMAP_ON_RIGHT)) && hdItem.hbm != NULL)
	{
		CBitmap* pBmp = CBitmap::FromHandle(hdItem.hbm);
		ASSERT_VALID(pBmp);

		BITMAP bmp;
		pBmp->GetBitmap(&bmp);

		CRect rectBitmap = rect;
		if (hdItem.fmt & HDF_BITMAP_ON_RIGHT)
		{
			rectBitmap.right--;
			rect.right = rectBitmap.left = rectBitmap.right - bmp.bmWidth;
		}
		else
		{
			rectBitmap.left++;
			rect.left = rectBitmap.right = rectBitmap.left + bmp.bmWidth;
		}

		rectBitmap.top += max(0, (rectBitmap.Height() - bmp.bmHeight) / 2);
		rectBitmap.bottom = rectBitmap.top + bmp.bmHeight;

		pDC->DrawState(rectBitmap.TopLeft(), rectBitmap.Size(), pBmp, DSS_NORMAL);
	}

	// Draw text:
	if ((hdItem.fmt & HDF_STRING) && hdItem.pszText != NULL)
	{
		CRect rectLabel = rect;
		rectLabel.DeflateRect(nTextMargin, 0);

		CString strLabel = hdItem.pszText;

		UINT uiTextFlags = DT_VCENTER | DT_SINGLELINE | DT_END_ELLIPSIS | DT_NOPREFIX;
		if (hdItem.fmt & HDF_CENTER)
		{
			uiTextFlags |= DT_CENTER;
		}
		else if (hdItem.fmt & HDF_RIGHT)
		{
			uiTextFlags |= DT_RIGHT;
		}

		pDC->DrawText(strLabel, rectLabel, uiTextFlags);
	}
}

void CMFCHeaderCtrl::SetSortColumn(int iColumn, BOOL bAscending, BOOL bAdd)
{
	ASSERT_VALID(this);

	if (iColumn < 0)
	{
		m_mapColumnsStatus.RemoveAll();
		return;
	}

	if (bAdd)
	{
		if (!m_bMultipleSort)
		{
			ASSERT(FALSE);
			bAdd = FALSE;
		}
	}

	if (!bAdd)
	{
		m_mapColumnsStatus.RemoveAll();
	}

	m_mapColumnsStatus.SetAt(iColumn, bAscending ? 1 : -1);
	RedrawWindow();
}

void CMFCHeaderCtrl::RemoveSortColumn(int iColumn)
{
	ASSERT_VALID(this);
	m_mapColumnsStatus.RemoveKey(iColumn);
	RedrawWindow();
}

BOOL CMFCHeaderCtrl::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMFCHeaderCtrl::OnPaint()
{
	if (GetStyle() & HDS_FILTERBAR)
	{
		Default();
		return;
	}

	CPaintDC dc(this); // device context for painting
	CMemDC memDC(dc, this);
	CDC* pDC = &memDC.GetDC();

	CRect rectClip;
	dc.GetClipBox(rectClip);

	CRect rectClient;
	GetClientRect(rectClient);

	OnFillBackground(pDC);

	CFont* pOldFont = SelectFont(pDC);
	ASSERT_VALID(pOldFont);

	pDC->SetTextColor(afxGlobalData.clrBtnText);
	pDC->SetBkMode(TRANSPARENT);

	CRect rect;
	GetClientRect(rect);

	CRect rectItem;
	int nCount = GetItemCount();

	int xMax = 0;

	for (int i = 0; i < nCount; i++)
	{
		// Is item pressed?
		CPoint ptCursor;
		::GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);

		HDHITTESTINFO hdHitTestInfo;
		hdHitTestInfo.pt = ptCursor;

		int iHit = (int) SendMessage(HDM_HITTEST, 0, (LPARAM) &hdHitTestInfo);

		BOOL bIsHighlighted = iHit == i &&(hdHitTestInfo.flags & HHT_ONHEADER);
		BOOL bIsPressed = m_bIsMousePressed && bIsHighlighted;

		GetItemRect(i, rectItem);

		CRgn rgnClip;
		rgnClip.CreateRectRgnIndirect(&rectItem);
		pDC->SelectClipRgn(&rgnClip);

		// Draw item:
		OnDrawItem(pDC, i, rectItem, bIsPressed, m_nHighlightedItem == i);

		pDC->SelectClipRgn(NULL);

		xMax = max(xMax, rectItem.right);
	}

	// Draw "tail border":
	if (nCount == 0)
	{
		rectItem = rect;
		rectItem.right++;
	}
	else
	{
		rectItem.left = xMax;
		rectItem.right = rect.right + 1;
	}

	OnDrawItem(pDC, -1, rectItem, FALSE, FALSE);

	pDC->SelectObject(pOldFont);
}

void CMFCHeaderCtrl::OnFillBackground(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CRect rectClient;
	GetClientRect(rectClient);

	CMFCVisualManager::GetInstance()->OnFillHeaderCtrlBackground(this, pDC, rectClient);
}

CFont* CMFCHeaderCtrl::SelectFont(CDC *pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CFont* pOldFont = NULL;

	if (m_hFont != NULL)
	{
		pOldFont = pDC->SelectObject(CFont::FromHandle(m_hFont));
	}
	else
	{
		pOldFont = m_bIsDlgControl ? (CFont*) pDC->SelectStockObject(DEFAULT_GUI_FONT) : pDC->SelectObject(&afxGlobalData.fontRegular);
	}

	return pOldFont;
}

void CMFCHeaderCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_bIsMousePressed = TRUE;
	CHeaderCtrl::OnLButtonDown(nFlags, point);
}

void CMFCHeaderCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	m_bIsMousePressed = FALSE;
	CHeaderCtrl::OnLButtonUp(nFlags, point);
}

void CMFCHeaderCtrl::OnDrawSortArrow(CDC* pDC, CRect rectArrow)
{
	ASSERT_VALID(pDC);
	ASSERT_VALID(this);

	CMFCVisualManager::GetInstance()->OnDrawHeaderCtrlSortArrow(this, pDC, rectArrow, m_bAscending);
}

void CMFCHeaderCtrl::EnableMultipleSort(BOOL bEnable)
{
	ASSERT_VALID(this);

	if (m_bMultipleSort == bEnable)
	{
		return;
	}

	m_bMultipleSort = bEnable;

	if (!m_bMultipleSort)
	{
		m_mapColumnsStatus.RemoveAll();

		if (GetSafeHwnd() != NULL)
		{
			RedrawWindow();
		}
	}
}

int CMFCHeaderCtrl::GetSortColumn() const
{
	ASSERT_VALID(this);

	if (m_bMultipleSort)
	{
		TRACE0("Call CMFCHeaderCtrl::GetColumnState for muliple sort\n");
		ASSERT(FALSE);
		return -1;
	}

	int nCount = GetItemCount();
	for (int i = 0; i < nCount; i++)
	{
		int nSortVal = 0;
		if (m_mapColumnsStatus.Lookup(i, nSortVal) && nSortVal != 0)
		{
			return i;
		}
	}

	return -1;
}

BOOL CMFCHeaderCtrl::IsAscending() const
{
	ASSERT_VALID(this);

	if (m_bMultipleSort)
	{
		TRACE0("Call CMFCHeaderCtrl::GetColumnState for muliple sort\n");
		ASSERT(FALSE);
		return FALSE;
	}

	int nCount = GetItemCount();

	for (int i = 0; i < nCount; i++)
	{
		int nSortVal = 0;
		if (m_mapColumnsStatus.Lookup(i, nSortVal) && nSortVal != 0)
		{
			return nSortVal > 0;
		}
	}

	return FALSE;
}

int CMFCHeaderCtrl::GetColumnState(int iColumn) const
{
	int nSortVal = 0;
	m_mapColumnsStatus.Lookup(iColumn, nSortVal);

	return nSortVal;
}

void CMFCHeaderCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	if ((nFlags & MK_LBUTTON) == 0)
	{
		HDHITTESTINFO hdHitTestInfo;
		hdHitTestInfo.pt = point;

		int nPrevHighlightedItem = m_nHighlightedItem;
		m_nHighlightedItem = (int) SendMessage(HDM_HITTEST, 0, (LPARAM) &hdHitTestInfo);

		if ((hdHitTestInfo.flags & HHT_ONHEADER) == 0)
		{
			m_nHighlightedItem = -1;
		}

		if (!m_bTracked)
		{
			m_bTracked = TRUE;

			TRACKMOUSEEVENT trackmouseevent;
			trackmouseevent.cbSize = sizeof(trackmouseevent);
			trackmouseevent.dwFlags = TME_LEAVE;
			trackmouseevent.hwndTrack = GetSafeHwnd();
			trackmouseevent.dwHoverTime = HOVER_DEFAULT;
			::AFXTrackMouse(&trackmouseevent);
		}

		if (nPrevHighlightedItem != m_nHighlightedItem)
		{
			RedrawWindow();
		}
	}

	CHeaderCtrl::OnMouseMove(nFlags, point);
}

LRESULT CMFCHeaderCtrl::OnMouseLeave(WPARAM,LPARAM)
{
	m_bTracked = FALSE;

	if (m_nHighlightedItem >= 0)
	{
		m_nHighlightedItem = -1;
		RedrawWindow();
	}

	return 0;
}

void CMFCHeaderCtrl::OnCancelMode()
{
	CHeaderCtrl::OnCancelMode();

	if (m_nHighlightedItem >= 0)
	{
		m_nHighlightedItem = -1;
		RedrawWindow();
	}
}

int CMFCHeaderCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CHeaderCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	CommonInit();

	return 0;
}

void CMFCHeaderCtrl::PreSubclassWindow()
{
	CommonInit();
	CHeaderCtrl::PreSubclassWindow();
}

void CMFCHeaderCtrl::CommonInit()
{
	ASSERT_VALID(this);

	for (CWnd* pParentWnd = GetParent(); pParentWnd != NULL;
		pParentWnd = pParentWnd->GetParent())
	{
		if (pParentWnd->IsKindOf(RUNTIME_CLASS(CDialog)))
		{
			m_bIsDlgControl = TRUE;
			break;
		}
	}
}

LRESULT CMFCHeaderCtrl::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	BOOL bRedraw = (BOOL) LOWORD(lParam);

	m_hFont = (HFONT) wParam;

	if (bRedraw)
	{
		Invalidate();
		UpdateWindow();
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxinl3.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifndef _AFX_ENABLE_INLINES


#define _AFXWIN_INLINE
#include "afxwin2.inl"

#endif //!_AFX_ENABLE_INLINES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxinl4.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifndef _AFX_ENABLE_INLINES


#define _AFXWIN_INLINE
#include "afxwin3.inl"

#endif //!_AFX_ENABLE_INLINES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxlinkctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxlinkctrl.h"
#include "afxglobals.h"
#include "afxribbonres.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CMFCLinkCtrl, CMFCButton)

/////////////////////////////////////////////////////////////////////////////
// CMFCLinkCtrl

CMFCLinkCtrl::CMFCLinkCtrl()
{
	m_nFlatStyle = BUTTONSTYLE_NOBORDERS;
	m_sizePushOffset = CSize(0, 0);
	m_bTransparent = TRUE;

	m_bMultilineText = FALSE;
	m_bAlwaysUnderlineText = TRUE;
	m_bDefaultClickProcess = FALSE;
	m_bVisited = FALSE;

	SetMouseCursorHand();
}

CMFCLinkCtrl::~CMFCLinkCtrl()
{
}

BEGIN_MESSAGE_MAP(CMFCLinkCtrl, CMFCButton)
	//{{AFX_MSG_MAP(CMFCLinkCtrl)
	ON_CONTROL_REFLECT_EX(BN_CLICKED, &CMFCLinkCtrl::OnClicked)
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCLinkCtrl::OnInitControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCLinkCtrl message handlers

void CMFCLinkCtrl::OnDraw(CDC* pDC, const CRect& rect, UINT /*uiState*/)
{
	ASSERT_VALID(pDC);

	// Set font:
	CFont* pOldFont = NULL;

	if (m_bAlwaysUnderlineText || m_bHover)
	{
		pOldFont = pDC->SelectObject(&afxGlobalData.fontDefaultGUIUnderline);
	}
	else
	{
		pOldFont = CMFCButton::SelectFont(pDC);
	}

	ENSURE(pOldFont != NULL);

	// Set text parameters:
	pDC->SetTextColor(m_bHover ? afxGlobalData.clrHotLinkHoveredText : (m_bVisited ? afxGlobalData.clrHotLinkVisitedText : afxGlobalData.clrHotLinkNormalText));
	pDC->SetBkMode(TRANSPARENT);

	// Obtain label:
	CString strLabel;
	GetWindowText(strLabel);

	CRect rectText = rect;
	pDC->DrawText(strLabel, rectText, m_bMultilineText ? DT_WORDBREAK : DT_SINGLELINE);

	pDC->SelectObject(pOldFont);
}

BOOL CMFCLinkCtrl::OnClicked()
{
	ASSERT_VALID(this);

	if (!IsWindowEnabled())
	{
		return TRUE;
	}

	if (m_bDefaultClickProcess)
	{
		m_bHover = FALSE;
		Invalidate();
		UpdateWindow();

		return FALSE;
	}

	CWaitCursor wait;

	CString strURL = m_strURL;
	if (strURL.IsEmpty())
	{
		GetWindowText(strURL);
	}

	if (::ShellExecute(NULL, NULL, m_strPrefix + strURL, NULL, NULL, SW_SHOWNORMAL) <(HINSTANCE) 32)
	{
		TRACE(_T("Can't open URL: %s\n"), strURL);
	}

	m_bVisited = TRUE;
	m_bHover = FALSE;
	Invalidate();
	UpdateWindow();

	return TRUE;
}

void CMFCLinkCtrl::SetURL(LPCTSTR lpszURL)
{
	if (lpszURL == NULL)
	{
		m_strURL.Empty();
	}
	else
	{
		m_strURL = lpszURL;
	}
}

void CMFCLinkCtrl::SetURLPrefix(LPCTSTR lpszPrefix)
{
	ENSURE(lpszPrefix != NULL);
	m_strPrefix = lpszPrefix;
}

CSize CMFCLinkCtrl::SizeToContent(BOOL bVCenter, BOOL bHCenter)
{
	if (m_sizeImage != CSize(0, 0))
	{
		return CMFCButton::SizeToContent();
	}

	ASSERT_VALID(this);
	ENSURE(GetSafeHwnd() != NULL);

	CClientDC dc(this);

	// Set font:
	CFont* pOldFont = dc.SelectObject(&afxGlobalData.fontDefaultGUIUnderline);
	ENSURE(pOldFont != NULL);

	// Obtain label:
	CString strLabel;
	GetWindowText(strLabel);

	CRect rectClient;
	GetClientRect(rectClient);

	CRect rectText = rectClient;
	dc.DrawText(strLabel, rectText, DT_SINGLELINE | DT_CALCRECT);
	rectText.InflateRect(3, 3);

	if (bVCenter || bHCenter)
	{
		ASSERT(GetParent()->GetSafeHwnd() != NULL);
		MapWindowPoints(GetParent(), rectClient);

		int dx = bHCenter ?(rectClient.Width() - rectText.Width()) / 2 : 0;
		int dy = bVCenter ?(rectClient.Height() - rectText.Height()) / 2 : 0;

		SetWindowPos(NULL, rectClient.left + dx, rectClient.top + dy, rectText.Width(), rectText.Height(), SWP_NOZORDER | SWP_NOACTIVATE);
	}
	else
	{
		SetWindowPos(NULL, -1, -1, rectText.Width(), rectText.Height(), SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
	}

	dc.SelectObject(pOldFont);
	return rectText.Size();
}

void CMFCLinkCtrl::OnDrawFocusRect(CDC* pDC, const CRect& rectClient)
{
	ASSERT_VALID(pDC);

	CRect rectFocus = rectClient;
	pDC->DrawFocusRect(rectFocus);
}

BOOL CMFCLinkCtrl::PreTranslateMessage(MSG* pMsg)
{
	switch(pMsg->message)
	{
	case WM_KEYDOWN:
		if (pMsg->wParam == VK_SPACE || pMsg->wParam == VK_RETURN)
		{
			return TRUE;
		}
		break;

	case WM_KEYUP:
		if (pMsg->wParam == VK_SPACE)
		{
			return TRUE;
		}
		else if (pMsg->wParam == VK_RETURN)
		{
			OnClicked();
			return TRUE;
		}
		break;
	}

	return CMFCButton::PreTranslateMessage(pMsg);
}

LRESULT CMFCLinkCtrl::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	CString strUrl;
	if (tagManager.ExcludeTag(PS_MFCLink_Url, strUrl))
	{
		SetURL(strUrl);
	}

	CString strUrlPrefix;
	if (tagManager.ExcludeTag(PS_MFCLink_UrlPrefix, strUrlPrefix))
	{
		SetURLPrefix(strUrlPrefix);
	}

	CString strFullTextTooltip;
	if (tagManager.ExcludeTag(PS_MFCLink_FullTextTooltip, strFullTextTooltip))
	{
		if (!strFullTextTooltip.IsEmpty())
		{
			strFullTextTooltip.MakeUpper();
			EnableFullTextTooltip(strFullTextTooltip == PS_True);
		}
	}

	CString strTooltip;
	if (tagManager.ExcludeTag(PS_MFCLink_Tooltip, strTooltip))
	{
		SetTooltip(strTooltip);
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxkeyboardmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxkeyboardmanager.h"
#include "afxmultidoctemplateex.h"
#include "afxframewndex.h"
#include "afxmdiframewndex.h"
#include "afxoleipframewndex.h"
#include "afxsettingsstore.h"
#include "afxacceleratorkey.h"
#include "afxtoolbar.h"
#include "afxregpath.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_REG_SECTION_FMT _T("%sKeyboard-%d")
#define AFX_REG_ENTRY_DATA _T("Accelerators")

CKeyboardManager* afxKeyboardManager = NULL;

static const CString strKbProfile = _T("KeyboardManager");

LPACCEL CKeyboardManager::m_lpAccel = NULL;
LPACCEL CKeyboardManager::m_lpAccelDefault = NULL;
int CKeyboardManager::m_nAccelDefaultSize = 0;
int CKeyboardManager::m_nAccelSize = 0;
HACCEL CKeyboardManager::m_hAccelDefaultLast = NULL;
HACCEL CKeyboardManager::m_hAccelLast = NULL;
BOOL CKeyboardManager::m_bAllAccelerators = FALSE;
CString CKeyboardManager::m_strDelimiter = _T("; ");

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CKeyboardManager::CKeyboardManager()
{
	ENSURE(afxKeyboardManager == NULL);
	afxKeyboardManager = this;
}

CKeyboardManager::~CKeyboardManager()
{
	afxKeyboardManager = NULL;
}

BOOL CKeyboardManager::UpdateAccelTable(CMultiDocTemplate* pTemplate, LPACCEL lpAccel, int nSize, CFrameWnd* pDefaultFrame)
{
	ENSURE(lpAccel != NULL);

	// Create a new accelerator table:
	HACCEL hAccelNew = ::CreateAcceleratorTable(lpAccel, nSize);
	if (hAccelNew == NULL)
	{
		TRACE(_T("Can't create accelerator table!\n"));
		return FALSE;
	}

	if (!UpdateAccelTable(pTemplate, hAccelNew, pDefaultFrame))
	{
		::DestroyAcceleratorTable(hAccelNew);
		return FALSE;
	}

	return TRUE;
}

BOOL CKeyboardManager::UpdateAccelTable(CMultiDocTemplate* pTemplate, HACCEL hAccelNew, CFrameWnd* pDefaultFrame)
{
	ENSURE(hAccelNew != NULL);

	// Find an existing accelerator table associated with template:
	HACCEL hAccelTable = NULL;

	if (pTemplate != NULL)
	{
		ENSURE(pDefaultFrame == NULL);

		ASSERT_VALID(pTemplate);
		hAccelTable = pTemplate->m_hAccelTable;
		ENSURE(hAccelTable != NULL);

		pTemplate->m_hAccelTable = hAccelNew;

		// Walk trougth all template's documents and change
		// frame's accelerator tables:
		for (POSITION pos = pTemplate->GetFirstDocPosition(); pos != NULL;)
		{
			CDocument* pDoc = pTemplate->GetNextDoc(pos);
			ASSERT_VALID(pDoc);

			for (POSITION posView = pDoc->GetFirstViewPosition(); posView != NULL;)
			{
				CView* pView = pDoc->GetNextView(posView);
				ASSERT_VALID(pView);

				CFrameWnd* pFrame = pView->GetParentFrame();
				ASSERT_VALID(pFrame);

				if (pFrame->m_hAccelTable == hAccelTable)
				{
					pFrame->m_hAccelTable = hAccelNew;
				}
			}
		}
	}
	else
	{
		if (pDefaultFrame == NULL)
		{
			pDefaultFrame = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());
		}

		if (pDefaultFrame != NULL)
		{
			hAccelTable = pDefaultFrame->m_hAccelTable;
			pDefaultFrame->m_hAccelTable = hAccelNew;
		}
	}

	if (hAccelTable == NULL)
	{
		TRACE(_T("Accelerator table not found!\n"));
		return FALSE;
	}

	::DestroyAcceleratorTable(hAccelTable);
	return TRUE;
}

BOOL CKeyboardManager::SaveAcceleratorState(LPCTSTR lpszProfileName, UINT uiResId, HACCEL hAccelTable)
{
	ENSURE(hAccelTable != NULL);

	CString strSection;
	strSection.Format(AFX_REG_SECTION_FMT, lpszProfileName, uiResId);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	int nAccelSize = ::CopyAcceleratorTable(hAccelTable, NULL, 0);
	if (nAccelSize == 0)
	{
		return FALSE;
	}

	if (!reg.CreateKey(strSection))
	{
		return FALSE;
	}

	LPACCEL lpAccel = new ACCEL [nAccelSize];
	ENSURE(lpAccel != NULL);

	::CopyAcceleratorTable(hAccelTable, lpAccel, nAccelSize);

	reg.Write(AFX_REG_ENTRY_DATA, (LPBYTE) lpAccel, nAccelSize * sizeof(ACCEL));

	delete [] lpAccel;
	return TRUE;
}

BOOL CKeyboardManager::LoadAcceleratorState(LPCTSTR lpszProfileName, UINT uiResId, HACCEL& hAccelTable)
{
	ENSURE(hAccelTable == NULL);

	CString strSection;
	strSection.Format(AFX_REG_SECTION_FMT, lpszProfileName, uiResId);

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, FALSE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	UINT uiSize;
	LPACCEL lpAccel;

	if (reg.Read(AFX_REG_ENTRY_DATA, (LPBYTE*) &lpAccel, &uiSize))
	{
		int nAccelSize = uiSize / sizeof(ACCEL);

		ENSURE(lpAccel != NULL);

		for (int i = 0; i < nAccelSize; i ++)
		{
			if (!CMFCToolBar::IsCommandPermitted(lpAccel [i].cmd))
			{
				lpAccel [i].cmd = 0;
			}
		}

		hAccelTable = ::CreateAcceleratorTable(lpAccel, nAccelSize);
	}

	delete [] lpAccel;
	return hAccelTable != NULL;
}

BOOL CKeyboardManager::LoadState(LPCTSTR lpszProfileName, CFrameWnd* pDefaultFrame)
{
	CString strProfileName = ::AFXGetRegPath(strKbProfile, lpszProfileName);

	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interessing CMultiDocTemplate objects with
			// the sahred menu only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hAccelTable == NULL)
			{
				continue;
			}

			UINT uiResId = pTemplate->GetResId();
			ENSURE(uiResId != 0);

			HACCEL hAccelTable = NULL;
			if (LoadAcceleratorState(strProfileName, uiResId, hAccelTable))
			{
				UpdateAccelTable(pTemplate, hAccelTable);
			}
		}
	}

	// Save default accelerator table:
	if (pDefaultFrame == NULL)
	{
		pDefaultFrame = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());
	}

	if (pDefaultFrame != NULL && pDefaultFrame->m_hAccelTable != NULL)
	{
		HACCEL hAccelTable = NULL;
		if (LoadAcceleratorState(strProfileName, 0, hAccelTable))
		{
			UpdateAccelTable(NULL, hAccelTable, pDefaultFrame);
		}
	}

	return TRUE;
}

BOOL CKeyboardManager::SaveState(LPCTSTR lpszProfileName, CFrameWnd* pDefaultFrame)
{
	CString strProfileName = ::AFXGetRegPath(strKbProfile, lpszProfileName);

	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interessing CMultiDocTemplate objects in
			// the shared accelerator table only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hAccelTable == NULL)
			{
				continue;
			}

			UINT uiResId = pTemplate->GetResId();
			ENSURE(uiResId != 0);

			SaveAcceleratorState(strProfileName, uiResId, pTemplate->m_hAccelTable);
		}
	}

	// Save default accelerator table:
	if (pDefaultFrame == NULL)
	{
		pDefaultFrame = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());
	}

	if (pDefaultFrame != NULL && pDefaultFrame->m_hAccelTable != NULL)
	{
		SaveAcceleratorState(strProfileName, 0, pDefaultFrame->m_hAccelTable);
	}

	return TRUE;
}

void CKeyboardManager::ResetAll()
{
	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interessing CMultiDocTemplate objects in
			// the shared accelerator table only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hAccelTable == NULL)
			{
				continue;
			}

			UINT uiResId = pTemplate->GetResId();
			ENSURE(uiResId != 0);

			HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(uiResId), RT_MENU);

			HACCEL hAccellTable = ::LoadAcceleratorsW(hInst, MAKEINTRESOURCEW(uiResId));
			if (hAccellTable != NULL)
			{
				UpdateAccelTable(pTemplate, hAccellTable);
			}
		}
	}

	// Restore default accelerator table:
	CFrameWnd* pWndMain = DYNAMIC_DOWNCAST(CFrameWnd, AfxGetMainWnd());
	if (pWndMain != NULL && pWndMain->m_hAccelTable != NULL)
	{
		UINT uiResId = 0;

		CMDIFrameWndEx* pMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, AfxGetMainWnd());
		if (pMDIFrame != NULL)
		{
			uiResId = pMDIFrame->GetDefaultResId();
		}
		else // Maybe, SDI frame...
		{
			CFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CFrameWndEx, AfxGetMainWnd());
			if (pFrame != NULL)
			{
				uiResId = pFrame->GetDefaultResId();
			}
			else // Maybe, OLE frame...
			{
				COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, AfxGetMainWnd());
				if (pOleFrame != NULL)
				{
					uiResId = pOleFrame->GetDefaultResId();
				}
			}
		}

		if (uiResId != 0)
		{
			HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(uiResId), RT_MENU);

			HACCEL hAccellTable = ::LoadAcceleratorsW(hInst, MAKEINTRESOURCEW(uiResId));
			if (hAccellTable != NULL)
			{
				UpdateAccelTable(NULL, hAccellTable);
			}
		}
	}
}

BOOL __stdcall CKeyboardManager::FindDefaultAccelerator(UINT uiCmd, CString& str, CFrameWnd* pWndFrame, BOOL bIsDefaultFrame)
{
	str.Empty();

	if (pWndFrame == NULL)
	{
		return FALSE;
	}

	HACCEL hAccelTable = pWndFrame->GetDefaultAccelerator();
	if (hAccelTable == NULL)
	{
		return FALSE;
	}

	int& nSize = bIsDefaultFrame ? m_nAccelDefaultSize : m_nAccelSize;
	LPACCEL& lpAccel = bIsDefaultFrame ? m_lpAccelDefault : m_lpAccel;

	SetAccelTable( lpAccel, bIsDefaultFrame ? m_hAccelDefaultLast : m_hAccelLast, nSize, hAccelTable);

	ENSURE(lpAccel != NULL);

	BOOL bFound = FALSE;
	for (int i = 0; i < nSize; i ++)
	{
		if (lpAccel [i].cmd == uiCmd)
		{
			bFound = TRUE;

			CMFCAcceleratorKey helper(&lpAccel [i]);

			CString strKey;
			helper.Format(strKey);

			if (!str.IsEmpty())
			{
				str += m_strDelimiter;
			}

			str += strKey;

			if (!m_bAllAccelerators)
			{
				break;
			}
		}
	}

	return bFound;
}

void __stdcall CKeyboardManager::SetAccelTable(LPACCEL& lpAccel, HACCEL& hAccelLast, int& nSize, const HACCEL hAccelCur)
{
	ENSURE(hAccelCur != NULL);
	if (hAccelCur == hAccelLast)
	{
		ENSURE(lpAccel != NULL);
		return;
	}

	// Destroy old acceleration table:
	if (lpAccel != NULL)
	{
		delete [] lpAccel;
		lpAccel = NULL;
	}

	nSize = ::CopyAcceleratorTable(hAccelCur, NULL, 0);

	lpAccel = new ACCEL [nSize];
	ENSURE(lpAccel != NULL);

	::CopyAcceleratorTable(hAccelCur, lpAccel, nSize);

	hAccelLast = hAccelCur;
}

BOOL __stdcall CKeyboardManager::IsKeyPrintable(const UINT nChar)
{
	// Ensure the key is printable:
	BYTE lpKeyState [256];
	ENSURE(::GetKeyboardState(lpKeyState));

#ifndef _UNICODE
	WORD wChar = 0;
	int nRes = ::ToAsciiEx(nChar, MapVirtualKey(nChar, 0), lpKeyState, &wChar, 0, //FOR BETA 6.8 - CHANGE BACK TO 1 IF USERS REPORT ANY PROBLEMS
		::GetKeyboardLayout(AfxGetThread()->m_nThreadID));

#else
	TCHAR szChar [2];
	memset(szChar, 0, sizeof(TCHAR) * 2);

	int nRes = ::ToUnicodeEx(nChar, MapVirtualKey(nChar, 0), lpKeyState, szChar, 2, 0, //FOR BETA 6.8 - CHANGE BACK TO 1 IF USERS REPORT ANY PROBLEMS
		::GetKeyboardLayout(AfxGetThread()->m_nThreadID));
#endif // _UNICODE

	return nRes > 0;
}

UINT __stdcall CKeyboardManager::TranslateCharToUpper(const UINT nChar)
{
	if (nChar < VK_NUMPAD0 || nChar > VK_NUMPAD9 ||
		(::GetAsyncKeyState(VK_MENU) & 0x8000))
	{
		if (!CMFCToolBar::m_bExtCharTranslation)
		{
			// locale independent code:
			if ((nChar < 0x41 || nChar > 0x5A))
			{
				if (::GetAsyncKeyState(VK_MENU) & 0x8000)
				{
					return nChar;
				}
				else
				{
					return toupper(nChar);
				}
			}
			else // virt codes(A - Z)
			{
				return nChar;
			}
		}
	}

	// locale dependent code:
#ifndef _UNICODE
	WORD wChar = 0;
	BYTE lpKeyState [256];
	::GetKeyboardState(lpKeyState);

	::ToAsciiEx(nChar, MapVirtualKey(nChar, 0), lpKeyState, &wChar, 1, ::GetKeyboardLayout(AfxGetThread()->m_nThreadID));

	TCHAR szChar [2] = {(TCHAR) wChar, '\0'};
#else
	TCHAR szChar [2];
	memset(szChar, 0, sizeof(TCHAR) * 2);
	BYTE lpKeyState [256];
	ENSURE(::GetKeyboardState(lpKeyState));

	::ToUnicodeEx(nChar, MapVirtualKey(nChar, 0), lpKeyState, szChar, 2, 1, ::GetKeyboardLayout(AfxGetThread()->m_nThreadID));
#endif // _UNICODE

	CharUpper(szChar);

	return(UINT)szChar [0];
}

void __stdcall CKeyboardManager::CleanUp()
{
	if (m_lpAccel != NULL)
	{
		delete [] m_lpAccel;
		m_lpAccel = NULL;

	}

	if (m_lpAccelDefault != NULL)
	{
		delete [] m_lpAccelDefault;
		m_lpAccelDefault = NULL;
	}
}

BOOL __stdcall CKeyboardManager::IsKeyHandled(WORD nKey, BYTE fVirt, CFrameWnd* pWndFrame, BOOL bIsDefaultFrame)
{
	if (pWndFrame == NULL)
	{
		return FALSE;
	}

	HACCEL hAccelTable = pWndFrame->GetDefaultAccelerator();
	if (hAccelTable == NULL)
	{
		return FALSE;
	}

	int& nSize = bIsDefaultFrame ? m_nAccelDefaultSize : m_nAccelSize;
	LPACCEL& lpAccel = bIsDefaultFrame ? m_lpAccelDefault : m_lpAccel;

	SetAccelTable( lpAccel, bIsDefaultFrame ? m_hAccelDefaultLast : m_hAccelLast, nSize, hAccelTable);

	ENSURE(lpAccel != NULL);

	for (int i = 0; i < nSize; i ++)
	{
		if (lpAccel [i].key == nKey && lpAccel [i].fVirt == fVirt)
		{
			return TRUE;
		}
	}

	return FALSE;
}

void __stdcall CKeyboardManager::ShowAllAccelerators(BOOL bShowAll, LPCTSTR lpszDelimiter)
{
	if (bShowAll)
	{
		m_bAllAccelerators = TRUE;

		if (lpszDelimiter != NULL)
		{
			m_strDelimiter = lpszDelimiter;
		}
	}
	else
	{
		m_bAllAccelerators = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxlistctrl.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxlistctrl.h"
#include "afxdrawmanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCListCtrl

IMPLEMENT_DYNAMIC(CMFCListCtrl, CListCtrl)

CMFCListCtrl::CMFCListCtrl()
{
	m_iSortedColumn = -1;
	m_bAscending = TRUE;
	m_bMarkSortedColumn = FALSE;
	m_clrSortedColumn = (COLORREF)-1;
	m_hOldFont = NULL;
}

CMFCListCtrl::~CMFCListCtrl()
{
}

//{{AFX_MSG_MAP(CMFCListCtrl)
BEGIN_MESSAGE_MAP(CMFCListCtrl, CListCtrl)
	ON_WM_CREATE()
	ON_WM_ERASEBKGND()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_SIZE()
	ON_MESSAGE(WM_STYLECHANGED, &CMFCListCtrl::OnStyleChanged)
	ON_NOTIFY_REFLECT(NM_CUSTOMDRAW, &CMFCListCtrl::OnCustomDraw)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, &CMFCListCtrl::OnColumnClick)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCListCtrl message handlers

BOOL CMFCListCtrl::InitList()
{
	InitHeader();
	InitColors();
	return TRUE;
}

void CMFCListCtrl::InitHeader()
{
	// Initialize header control:
	m_wndHeader.SubclassDlgItem(0, this);
}

void CMFCListCtrl::PreSubclassWindow()
{
	CListCtrl::PreSubclassWindow();

	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	if (pThreadState->m_pWndInit == NULL)
	{
		if (!InitList())
		{
			ASSERT(FALSE);
		}
	}
}

int CMFCListCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CListCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!InitList())
	{
		return -1;
	}

	return 0;
}

void CMFCListCtrl::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	ENSURE(pNMListView != NULL);

	int iColumn = pNMListView->iSubItem;
	BOOL bShiftIsPressed = (::GetAsyncKeyState(VK_SHIFT) & 0x8000);
	int nColumnState = GetHeaderCtrl().GetColumnState(iColumn);
	BOOL bAscending = TRUE;

	if (nColumnState != 0)
	{
		bAscending = nColumnState <= 0;
	}

	Sort(iColumn, bAscending, bShiftIsPressed && IsMultipleSort());
	*pResult = 0;
}

void CMFCListCtrl::Sort(int iColumn, BOOL bAscending, BOOL bAdd)
{
	CWaitCursor wait;

	GetHeaderCtrl().SetSortColumn(iColumn, bAscending, bAdd);

	m_iSortedColumn = iColumn;
	m_bAscending = bAscending;

	SortItems(CompareProc, (LPARAM) this);
}

void CMFCListCtrl::SetSortColumn(int iColumn, BOOL bAscending, BOOL bAdd)
{
	GetHeaderCtrl().SetSortColumn(iColumn, bAscending, bAdd);
}

void CMFCListCtrl::RemoveSortColumn(int iColumn)
{
	GetHeaderCtrl().RemoveSortColumn(iColumn);
}

void CMFCListCtrl::EnableMultipleSort(BOOL bEnable)
{
	GetHeaderCtrl().EnableMultipleSort(bEnable);
}

BOOL CMFCListCtrl::IsMultipleSort() const
{
	return((CMFCListCtrl*) this)->GetHeaderCtrl().IsMultipleSort();
}

int CMFCListCtrl::OnCompareItems(LPARAM /*lParam1*/, LPARAM /*lParam2*/, int /*iColumn*/)
{
	return 0;
}

int CALLBACK CMFCListCtrl::CompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	CMFCListCtrl* pList = (CMFCListCtrl*) lParamSort;
	ASSERT_VALID(pList);

	int nRes = pList->OnCompareItems(lParam1, lParam2, pList->m_iSortedColumn);
	nRes = pList->m_bAscending ? nRes : -nRes;

	return nRes;
}

void CMFCListCtrl::OnCustomDraw(NMHDR* pNMHDR, LRESULT* pResult)
{
	ENSURE(pNMHDR != NULL);
	LPNMLVCUSTOMDRAW lplvcd = (LPNMLVCUSTOMDRAW)pNMHDR;

	switch (lplvcd->nmcd.dwDrawStage)
	{
	case CDDS_PREPAINT:
		*pResult = CDRF_NOTIFYITEMDRAW;
		break;

	case CDDS_ITEMPREPAINT:
		*pResult = CDRF_NOTIFYSUBITEMDRAW;
		break;

	case CDDS_ITEMPREPAINT | CDDS_SUBITEM:
		{
			int iColumn = lplvcd->iSubItem;
			int iRow = (int) lplvcd->nmcd.dwItemSpec;

			lplvcd->clrTextBk = OnGetCellBkColor(iRow, iColumn);
			lplvcd->clrText = OnGetCellTextColor(iRow, iColumn);

			if (iColumn == m_iSortedColumn && m_bMarkSortedColumn && lplvcd->clrTextBk == GetBkColor())
			{
				lplvcd->clrTextBk = m_clrSortedColumn;
			}

			HFONT hFont = OnGetCellFont( iRow, iColumn, (DWORD) lplvcd->nmcd.lItemlParam);
			if (hFont != NULL)
			{
				m_hOldFont = (HFONT) SelectObject(lplvcd->nmcd.hdc, hFont);
				ENSURE(m_hOldFont != NULL);

				*pResult = CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
			}
			else
			{
				*pResult = CDRF_DODEFAULT;
			}
		}
		break;

	case CDDS_ITEMPOSTPAINT | CDDS_SUBITEM:
		if (m_hOldFont != NULL)
		{
			SelectObject(lplvcd->nmcd.hdc, m_hOldFont);
			m_hOldFont = NULL;
		}

		*pResult = CDRF_DODEFAULT;
		break;
	}
}

void CMFCListCtrl::EnableMarkSortedColumn(BOOL bMark/* = TRUE*/, BOOL bRedraw/* = TRUE */)
{
	m_bMarkSortedColumn = bMark;

	if (GetSafeHwnd() != NULL && bRedraw)
	{
		RedrawWindow();
	}
}

BOOL CMFCListCtrl::OnEraseBkgnd(CDC* pDC)
{
	BOOL bRes = CListCtrl::OnEraseBkgnd(pDC);

	if (m_iSortedColumn >= 0 && m_bMarkSortedColumn)
	{
		CRect rectClient;
		GetClientRect(&rectClient);

		CRect rectHeader;
		GetHeaderCtrl().GetItemRect(m_iSortedColumn, &rectHeader);
		GetHeaderCtrl().MapWindowPoints(this, rectHeader);

		CRect rectColumn = rectClient;
		rectColumn.left = rectHeader.left;
		rectColumn.right = rectHeader.right;

		CBrush br(m_clrSortedColumn);
		pDC->FillRect(rectColumn, &br);
	}

	return bRes;
}

void CMFCListCtrl::OnSysColorChange()
{
	CListCtrl::OnSysColorChange();

	InitColors();
	RedrawWindow();
}

void CMFCListCtrl::InitColors()
{
	m_clrSortedColumn = CDrawingManager::PixelAlpha(GetBkColor(), .97, .97, .97);
}

LRESULT CMFCListCtrl::OnStyleChanged(WPARAM wp, LPARAM lp)
{
	int nStyleType = (int) wp;
	LPSTYLESTRUCT lpStyleStruct = (LPSTYLESTRUCT) lp;

	CListCtrl::OnStyleChanged(nStyleType, lpStyleStruct);

	if ((lpStyleStruct->styleNew & LVS_REPORT) && (lpStyleStruct->styleOld & LVS_REPORT) == 0)
	{
		if (GetHeaderCtrl().GetSafeHwnd() == NULL)
		{
			InitHeader();
		}
	}

	return 0;
}

void CMFCListCtrl::OnSize(UINT nType, int cx, int cy)
{
	CListCtrl::OnSize(nType, cx, cy);

	if (m_wndHeader.GetSafeHwnd() != NULL)
	{
		m_wndHeader.RedrawWindow();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxkeymapdialog.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxcontrolbarutil.h"
#include "afxkeymapdialog.h"
#include "afxtoolbarscustomizedialog.h"
#include "afxmultidoctemplateex.h"
#include "afxtoolbarbutton.h"
#include "afxwinappex.h"
#include "afxsettingsstore.h"
#include "afxglobals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#ifdef _UNICODE
#define AFX_TCF_TEXT CF_UNICODETEXT
#else
#define AFX_TCF_TEXT CF_TEXT
#endif

static const int nColumnCommand = 0;
static const int nColumnKeys = 1;
static const int nColumnDescr = 2;

static const CString strWindowPlacementRegSection = _T("KeyMapWindowPlacement");
static const CString strRectKey = _T("KeyMapWindowRect");

static int CALLBACK listCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	// lParamSort contains a pointer to the dialog.
	// The lParam of an item is just its index.

	CMFCKeyMapDialog* pDlg = (CMFCKeyMapDialog*) lParamSort;
	ASSERT_VALID(pDlg);

	LVFINDINFO info;
	info.flags = LVFI_PARAM;

	info.lParam = lParam1;
	int iIndex1 = pDlg->m_KeymapList.FindItem(&info);
	ASSERT(iIndex1 >= 0);

	info.lParam = lParam2;
	int iIndex2 = pDlg->m_KeymapList.FindItem(&info);
	ASSERT(iIndex2 >= 0);

	CString strItem1 = pDlg->m_KeymapList.GetItemText(iIndex1, pDlg->m_nSortedCol);
	CString strItem2 = pDlg->m_KeymapList.GetItemText(iIndex2, pDlg->m_nSortedCol);

	return pDlg->m_bSortAscending ? strItem1.Compare(strItem2) : strItem2.Compare(strItem1);
}

/////////////////////////////////////////////////////////////////////////////
// CMFCKeyMapDialog dialog

CMFCKeyMapDialog::CMFCKeyMapDialog(CFrameWnd* pWndParentFrame, BOOL bEnablePrint /* = FALSE */) :
	CDialogEx(CMFCKeyMapDialog::IDD, pWndParentFrame), m_bEnablePrint(bEnablePrint)
{
	m_pWndParentFrame = pWndParentFrame;

	m_hAccelTable = NULL;
	m_lpAccel = NULL;
	m_nAccelSize = 0;

	m_nSortedCol = 0;
	m_bSortAscending = TRUE;
}

CMFCKeyMapDialog::~CMFCKeyMapDialog()
{
	if (m_pDlgCust != NULL)
	{
		delete m_pDlgCust;
	}

	if (m_lpAccel != NULL)
	{
		delete [] m_lpAccel;
	}
}

void CMFCKeyMapDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCKeyMapDialog)
	DDX_Control(pDX, IDC_AFXBARRES_ACCEL_LABEL, m_wndAccelLabel);
	DDX_Control(pDX, IDC_AFXBARRES_KEYLIST, m_KeymapList);
	DDX_Control(pDX, IDC_AFXBARRES_CATEGORY, m_wndCategoryList);
	DDX_Control(pDX, IDC_AFXBARRES_VIEW_ICON, m_wndViewIcon);
	DDX_Control(pDX, IDC_AFXBARRES_VIEW_TYPE, m_wndViewTypeList);
	DDX_Control(pDX, IDC_AFXBARRES_PRINT_KEYMAP, m_ButtonPrint);
	DDX_Control(pDX, IDC_AFXBARRES_COPY_KEYMAP, m_ButtonCopy);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCKeyMapDialog, CDialogEx)
	//{{AFX_MSG_MAP(CMFCKeyMapDialog)
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_AFXBARRES_VIEW_TYPE, &CMFCKeyMapDialog::OnSelchangeViewType)
	ON_CBN_SELCHANGE(IDC_AFXBARRES_CATEGORY, &CMFCKeyMapDialog::OnSelchangeCategory)
	ON_BN_CLICKED(IDC_AFXBARRES_COPY_KEYMAP, &CMFCKeyMapDialog::OnCopy)
	ON_BN_CLICKED(IDC_AFXBARRES_PRINT_KEYMAP, &CMFCKeyMapDialog::OnPrint)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCKeyMapDialog message handlers

BOOL CMFCKeyMapDialog::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	if (AfxGetMainWnd() != NULL && (AfxGetMainWnd()->GetExStyle() & WS_EX_LAYOUTRTL))
	{
		ModifyStyleEx(0, WS_EX_LAYOUTRTL);
	}

	{
		// Set dialog icon:
		SetIcon((HICON) ::LoadImageW(
				AfxFindResourceHandle(MAKEINTRESOURCE(IDI_AFXBARRES_HELP), RT_GROUP_ICON),
				MAKEINTRESOURCEW(IDI_AFXBARRES_HELP),
				IMAGE_ICON,
				::GetSystemMetrics(SM_CXSMICON),
				::GetSystemMetrics(SM_CYSMICON),
				LR_SHARED),
			FALSE);

		// Setup buttons:
		m_ButtonPrint.m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;
		m_ButtonCopy.m_nFlatStyle = CMFCButton::BUTTONSTYLE_FLAT;

		CString strTT;

		if (m_bEnablePrint)
		{
			m_ButtonPrint.SetImage(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_PRINT32 : IDB_AFXBARRES_PRINT, NULL);
			m_ButtonPrint.GetWindowText(strTT);
			m_ButtonPrint.SetWindowText(_T(""));
			m_ButtonPrint.SetTooltip(strTT);
			m_ButtonPrint.SizeToContent();
			m_ButtonPrint.m_bDrawFocus = FALSE;
		}
		else
		{
			m_ButtonPrint.ShowWindow(SW_HIDE);
		}

		m_ButtonCopy.SetImage(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_COPY32 : IDB_AFXBARRES_COPY, NULL);
		m_ButtonCopy.GetWindowText(strTT);
		m_ButtonCopy.SetWindowText(_T(""));
		m_ButtonCopy.SetTooltip(strTT);
		m_ButtonCopy.SizeToContent();
		m_ButtonCopy.m_bDrawFocus = FALSE;

		// Add columns:
		OnSetColumns();
		SetColumnsWidth();
	}

	// Find all application document templates and fill accelerator tables  combobox by document template data:
	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interested in CMultiDocTemplateEx objects with the shared menu only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hAccelTable == NULL)
			{
				continue;
			}

			CString strName;
			pTemplate->GetDocString(strName, CDocTemplate::fileNewName);

			int iIndex = m_wndViewTypeList.AddString(strName);
			m_wndViewTypeList.SetItemData(iIndex, (DWORD_PTR) pTemplate);
		}
	}

	// Add a default application:
	CFrameWnd* pWndMain = DYNAMIC_DOWNCAST(CFrameWnd, m_pWndParentFrame);
	if (pWndMain != NULL && pWndMain->m_hAccelTable != NULL)
	{
		CString strName;
		ENSURE(strName.LoadString(IDS_AFXBARRES_DEFAULT_VIEW));

		int iIndex = m_wndViewTypeList.AddString(strName);
		m_wndViewTypeList.SetItemData(iIndex, (DWORD_PTR) NULL);

		m_wndViewTypeList.SetCurSel(iIndex);
		OnSelchangeViewType();
	}

	m_KeymapList.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);

	OnSelchangeViewType();

	// Initialize commands by category:
	m_pDlgCust = new CMFCToolBarsCustomizeDialog(m_pWndParentFrame, TRUE);
	m_pDlgCust->EnableUserDefinedToolbars();
	m_pDlgCust->FillCategoriesComboBox(m_wndCategoryList);

	m_wndCategoryList.SetCurSel(0);
	OnSelchangeCategory();

	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());

	// Restore window position and size:
	if (pApp != NULL)
	{
		ASSERT_VALID(pApp);

		CSettingsStoreSP regSP;
		CSettingsStore& reg = regSP.Create(FALSE, TRUE);

		CRect rectPosition;

		if (reg.Open(pApp->GetRegSectionPath(strWindowPlacementRegSection)) && reg.Read(strRectKey, rectPosition))
		{
			MoveWindow(rectPosition);
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCKeyMapDialog::OnSelchangeViewType()
{
	m_hAccelTable = NULL;

	if (m_lpAccel != NULL)
	{
		delete [] m_lpAccel;
		m_lpAccel = NULL;
	}

	int iIndex = m_wndViewTypeList.GetCurSel();
	if (iIndex == CB_ERR)
	{
		m_wndViewIcon.SetIcon(NULL);
		return;
	}

	HICON hicon = NULL;

	CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) m_wndViewTypeList.GetItemData(iIndex);
	if (pTemplate != NULL)
	{
		ASSERT_VALID(pTemplate);

		hicon = AfxGetApp ()->LoadIcon (pTemplate->GetResId());
		m_hAccelTable = pTemplate->m_hAccelTable;
	}
	else
	{
		CFrameWnd* pWndMain = DYNAMIC_DOWNCAST(CFrameWnd, m_pWndParentFrame);
		if (pWndMain != NULL)
		{
			hicon = (HICON)(LONG_PTR) GetClassLongPtr(*pWndMain, GCLP_HICON);
			m_hAccelTable = pWndMain->m_hAccelTable;
		}
	}

	if (hicon == NULL)
	{
		hicon = ::LoadIcon(NULL, IDI_APPLICATION);
	}

	m_wndViewIcon.SetIcon(hicon);

	ENSURE(m_hAccelTable != NULL);

	m_nAccelSize = ::CopyAcceleratorTable(m_hAccelTable, NULL, 0);

	m_lpAccel = new ACCEL [m_nAccelSize];
	ENSURE(m_lpAccel != NULL);

	::CopyAcceleratorTable(m_hAccelTable, m_lpAccel, m_nAccelSize);
	OnSelchangeCategory();
}

void CMFCKeyMapDialog::OnSelchangeCategory()
{
	UpdateData();

	ENSURE(m_lpAccel != NULL);

	int iIndex = m_wndCategoryList.GetCurSel();
	if (iIndex == LB_ERR)
	{
		return;
	}

	CObList* pCategoryButtonsList = (CObList*) m_wndCategoryList.GetItemData(iIndex);
	ASSERT_VALID(pCategoryButtonsList);

	int nItem = 0;
	m_KeymapList.DeleteAllItems();

	for (POSITION pos = pCategoryButtonsList->GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) pCategoryButtonsList->GetNext(pos);
		ENSURE(pButton != NULL);

		if (pButton->m_nID > 0 && pButton->m_nID != (UINT) -1)
		{
			OnInsertItem(pButton, nItem ++);
		}
	}

	m_KeymapList.SortItems(listCompareFunc, (LPARAM) this);
}

void CMFCKeyMapDialog::OnCopy()
{
	m_KeymapList.SetFocus();
	CopyKeyMap();
}

void CMFCKeyMapDialog::OnPrint()
{
	m_KeymapList.SetFocus();
	PrintKeyMap();
}

void CMFCKeyMapDialog::OnSize(UINT nType, int cx, int cy)
{
	CDialogEx::OnSize(nType, cx, cy);

	if (m_KeymapList.GetSafeHwnd() == NULL)
	{
		return;
	}

	// List of keys should cover the whole bottom part of the dialog:
	CRect rectList;
	m_KeymapList.GetClientRect(rectList);
	m_KeymapList.MapWindowPoints(this, &rectList);

	CRect rectClient;
	GetClientRect(rectClient);

	rectList.right = rectClient.right;
	rectList.bottom = rectClient.bottom;

	m_KeymapList.SetWindowPos(NULL, -1, -1, rectList.Width(), rectList.Height(), SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);

	// Adjust the columns width:
	SetColumnsWidth();
}

BOOL CMFCKeyMapDialog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	NMHDR* pNMHDR = (NMHDR*) lParam;
	if (pNMHDR != NULL && pNMHDR->code == HDN_ITEMCLICK)
	{
		HD_NOTIFY *phdn = (HD_NOTIFY *) pNMHDR;

		if (phdn->iButton == 0) // Left button
		{
			if (phdn->iItem == m_nSortedCol)
				m_bSortAscending = !m_bSortAscending;
			else
				m_bSortAscending = TRUE;

			m_nSortedCol = phdn->iItem;
			m_KeymapList.SortItems(listCompareFunc, (LPARAM) this);
			m_KeymapList.SetSortColumn(m_nSortedCol, m_bSortAscending);
		}
	}

	return CDialogEx::OnNotify(wParam, lParam, pResult);
}

void CMFCKeyMapDialog::CopyKeyMap()
{
	int i = m_KeymapList.GetSelectedCount();
	if (i <= 0)
	{
		MessageBeep((UINT)-1);
		return;
	}

	CString strText;
	int nItem = -1;
	int nFlag = (m_KeymapList.GetSelectedCount() > 0)  ?  LVNI_SELECTED : LVNI_ALL;

	while ((nItem = m_KeymapList.GetNextItem(nItem, nFlag)) >= 0)
	{
		strText += FormatItem(nItem) + _T("\r\n");
	}

	if (!strText.IsEmpty () && OpenClipboard())
	{
		EmptyClipboard();

		HGLOBAL hClipbuffer = ::GlobalAlloc(GHND, (strText.GetLength() + 1) * sizeof(TCHAR));
		ENSURE(hClipbuffer != NULL);

		LPTSTR lpszBuffer = (LPTSTR) GlobalLock(hClipbuffer);
		ENSURE(lpszBuffer != NULL);

#pragma warning(disable : 6383)
		_tcscpy_s (lpszBuffer, (strText.GetLength() + 1) * sizeof(TCHAR), (LPCTSTR) strText);
#pragma warning(default : 6383)

		::GlobalUnlock(hClipbuffer);
		::SetClipboardData(AFX_TCF_TEXT, hClipbuffer);

		CloseClipboard();
	}
}

void CMFCKeyMapDialog::PrintKeyMap()
{
	CWaitCursor WaitCursor;

	int nItem = -1;
	int nFlag = (m_KeymapList.GetSelectedCount() > 0)  ?  LVNI_SELECTED : LVNI_ALL;

	CPrintDialog dlgPrint(FALSE, PD_ALLPAGES | PD_RETURNDC | PD_NOSELECTION, NULL);
	if (dlgPrint.DoModal() != IDOK)
	{
		return;
	}

	// Obtain a handle to the device context.
	HDC hdcPrn = dlgPrint.GetPrinterDC();
	if (hdcPrn == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	CDC dc;
	dc.Attach(hdcPrn);

	CSize szPage(dc.GetDeviceCaps(HORZRES), dc.GetDeviceCaps(VERTRES));

	dc.StartDoc(_T("AfxKeyMapDlg"));  // begin a new print job
	dc.StartPage();

	int nPage = 1;
	int y = OnPrintHeader(dc, nPage, szPage.cx);

	while ((nItem = m_KeymapList.GetNextItem(nItem, nFlag)) >= 0)
	{
		int nItemHeight = OnPrintItem(dc, nItem, y, szPage.cx, TRUE /* Calc height */);
		if (y + nItemHeight > szPage.cy)
		{
			dc.EndPage();

			dc.StartPage();
			y = OnPrintHeader(dc, ++nPage, szPage.cx);
		}

		y += OnPrintItem(dc, nItem, y, szPage.cx, FALSE /* Draw */);
	}

	dc.EndPage();
	dc.EndDoc();
}

int CMFCKeyMapDialog::OnPrintHeader(CDC& dc, int nPage, int cx) const
{
	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);

	int nYMargin = tm.tmHeight * 2;

	CString strAppName = (AfxGetApp()->m_pszAppName == NULL) ? _T("") : AfxGetApp()->m_pszAppName;

	CString strTitle;
	GetWindowText(strTitle);

	CString strCaption;
	strCaption.Format(_T("- %d -\r\n%s: %s"), nPage, (LPCTSTR)strAppName, (LPCTSTR)strTitle);

	CRect rectText(0, nYMargin, cx, 32767);
	return dc.DrawText(strCaption, rectText, DT_WORDBREAK | DT_CENTER) + 2 * nYMargin;
}

int CMFCKeyMapDialog::OnPrintItem(CDC& dc, int nItem, int y, int cx, BOOL bCalcHeight) const
{
	ASSERT_VALID(this);
	ASSERT(nItem >= 0);

	TEXTMETRIC tm;
	dc.GetTextMetrics(&tm);

	int nXMargin = tm.tmMaxCharWidth * 2;

	CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_KeymapList.GetItemData(nItem);
	ASSERT_VALID(pButton);

	CString strCommand = pButton->m_strText;
	CString strKeys = m_KeymapList.GetItemText(nItem, nColumnKeys);
	CString strDescr = m_KeymapList.GetItemText(nItem, nColumnDescr);

	// Define column width:
	int nKeyColumWidth = dc.GetTextExtent(CString(_T("Ctrl+Shift+W"))).cx + nXMargin;
	int nRestOfWidth = cx - nKeyColumWidth - 2 * nXMargin;

	int nHeight = 1;

	for (int iStep = 0; iStep <(bCalcHeight ? 1 : 2); iStep ++)
	{
		UINT uiFormat = iStep == 0 ? (DT_CALCRECT | DT_WORDBREAK) : (DT_WORDBREAK | DT_END_ELLIPSIS);

		CRect rectCmd(CPoint(nXMargin, y), CSize(nRestOfWidth / 3, 32676));
		int nCmdHeight = dc.DrawText(strCommand, rectCmd, uiFormat);

		CRect rectKey(CPoint(rectCmd.right + nXMargin, y), CSize(nKeyColumWidth, 32676));
		int nKeyHeight = dc.DrawText(strKeys, rectKey, uiFormat);

		CRect rectDescr(rectKey.right + nXMargin, y, cx, 32676);
		int nDescrHeight = dc.DrawText(strDescr, rectDescr, uiFormat);

		nHeight = max(nCmdHeight, max(nKeyHeight, nDescrHeight));
	}

	return nHeight;
}

void CMFCKeyMapDialog::SetColumnsWidth()
{
	CRect rectList;
	m_KeymapList.GetClientRect(rectList);

	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(m_KeymapList.GetFont());
	ASSERT_VALID(pOldFont);

	int nKeyColumWidth = dc.GetTextExtent(CString(_T("Ctrl+Shift+W"))).cx + 10;

	dc.SelectObject(pOldFont);

	int nRestOfWidth = rectList.Width() - nKeyColumWidth - ::GetSystemMetrics(SM_CXHSCROLL);

	m_KeymapList.SetColumnWidth(nColumnCommand, nRestOfWidth / 3);
	m_KeymapList.SetColumnWidth(nColumnKeys, nKeyColumWidth);
	m_KeymapList.SetColumnWidth(nColumnDescr, nRestOfWidth * 2 / 3);
}

void CMFCKeyMapDialog::OnDestroy()
{
	//----------------------------------
	// Save window position and size:
	//----------------------------------
	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp != NULL)
	{
		ASSERT_VALID(pApp);

		CRect rectPosition;
		GetWindowRect(rectPosition);

		CSettingsStoreSP regSP;
		CSettingsStore& reg = regSP.Create(FALSE, FALSE);

		if (reg.CreateKey(pApp->GetRegSectionPath(strWindowPlacementRegSection)))
		{
			reg.Write(strRectKey, rectPosition);
		}
	}

	CDialogEx::OnDestroy();
}

CString CMFCKeyMapDialog::FormatItem(int nItem) const
{
	ASSERT_VALID(this);

	CString strKeys = m_KeymapList.GetItemText(nItem, nColumnKeys);
	if (strKeys.IsEmpty())
	{
		strKeys = _T("-");
	}

	CString strItem;
	strItem.Format(_T("%-30s\t%-20s\t%s"), (LPCTSTR)m_KeymapList.GetItemText(nItem, nColumnCommand), (LPCTSTR)strKeys, (LPCTSTR)m_KeymapList.GetItemText(nItem, nColumnDescr));
	return strItem;
}

void CMFCKeyMapDialog::OnSetColumns()
{
	CString strCaption;

	ENSURE(strCaption.LoadString(IDS_AFXBARRES_COMMAND));
	m_KeymapList.InsertColumn(nColumnCommand, strCaption);

	ENSURE(strCaption.LoadString(IDS_AFXBARRES_KEYS));
	m_KeymapList.InsertColumn(nColumnKeys, strCaption);

	ENSURE(strCaption.LoadString(IDS_AFXBARRES_DESCRIPTION));
	m_KeymapList.InsertColumn(nColumnDescr, strCaption);
}

void CMFCKeyMapDialog::OnInsertItem(CMFCToolBarButton* pButton, int nItem)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pButton);

	// Set command name:
	CString strText = pButton->m_strTextCustom.IsEmpty() ? pButton->m_strText : pButton->m_strTextCustom;

	int iIndex = m_KeymapList.InsertItem(nItem, strText, -1);
	m_KeymapList.SetItemData(iIndex, (DWORD_PTR) pButton);

	m_KeymapList.SetItemText(iIndex, nColumnKeys, GetCommandKeys(pButton->m_nID));

	// Set command description:
	CString strDescr;
	CFrameWnd* pParent = GetParentFrame();

	if (pParent != NULL && pParent->GetSafeHwnd() != NULL)
	{
		pParent->GetMessageString(pButton->m_nID, strDescr);
	}

	m_KeymapList.SetItemText(iIndex, nColumnDescr, strDescr);
}

CString CMFCKeyMapDialog::GetCommandKeys(UINT uiCmdID) const
{
	// Fill keys associated with selected command:
	CString strKey;

	for (int i = 0; i < m_nAccelSize; i ++)
	{
		if (uiCmdID == m_lpAccel [i].cmd)
		{
			ENSURE(&m_lpAccel [i] != NULL);

			CMFCAcceleratorKey helper(&m_lpAccel [i]);
			CString sNewKey;
			helper.Format(sNewKey);

			if (!strKey.IsEmpty())
			{
				strKey += _T("; ");
			}

			strKey += sNewKey;
		}
	}

	return strKey;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmaskededit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxmaskededit.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCMaskedEdit

IMPLEMENT_DYNAMIC(CMFCMaskedEdit, CEdit)

//{{AFX_MSG_MAP(CMFCMaskedEdit)
BEGIN_MESSAGE_MAP(CMFCMaskedEdit, CEdit)
	ON_WM_CHAR()
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_CREATE()
	ON_CONTROL_REFLECT(EN_SETFOCUS, &CMFCMaskedEdit::OnSetFocusR)
	ON_MESSAGE(WM_CUT, &CMFCMaskedEdit::OnCut)
	ON_MESSAGE(WM_CLEAR, &CMFCMaskedEdit::OnClear)
	ON_MESSAGE(WM_PASTE, &CMFCMaskedEdit::OnPaste)
	ON_MESSAGE(WM_SETTEXT, &CMFCMaskedEdit::OnSetText)
	ON_MESSAGE(WM_GETTEXT, &CMFCMaskedEdit::OnGetText)
	ON_MESSAGE(WM_GETTEXTLENGTH, &CMFCMaskedEdit::OnGetTextLength)
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCMaskedEdit::OnInitControl)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

CMFCMaskedEdit::CMFCMaskedEdit()
{
	m_bGetMaskedCharsOnly = TRUE;
	m_bSetMaskedCharsOnly = FALSE;
	m_bSelectByGroup = TRUE;
	m_bMaskKeyInProgress = FALSE;
	m_bPasteProcessing = FALSE;
	m_bSetTextProcessing = FALSE;
}

CMFCMaskedEdit::~CMFCMaskedEdit()
{
}

void CMFCMaskedEdit::EnableMask(LPCTSTR lpszMask, LPCTSTR lpszInputTemplate, TCHAR chMaskInputTemplate, LPCTSTR lpszValid)
{
	ENSURE(lpszMask != NULL);
	ENSURE(lpszInputTemplate != NULL);
	ASSERT(_istprint(chMaskInputTemplate));
	m_strMask = lpszMask;
	m_strInputTemplate = lpszInputTemplate;
	m_chMaskInputTemplate = chMaskInputTemplate;
	m_str = lpszInputTemplate;
	ASSERT(m_strMask.GetLength() == m_strInputTemplate.GetLength());

	if (lpszValid != NULL)
	{
		m_strValid = lpszValid;
	}
	else
	{
		m_strValid.Empty();
	}
}

void CMFCMaskedEdit::DisableMask()
{
	m_strMask.Empty();
	m_strInputTemplate.Empty();
}

void CMFCMaskedEdit::SetValidChars(LPCTSTR lpszValid)
{
	if (lpszValid != NULL)
	{
		m_strValid = lpszValid;
	}
	else
	{
		m_strValid.Empty();
	}
}

BOOL CMFCMaskedEdit::IsMaskedChar(TCHAR chChar, TCHAR chMaskChar) const
{
	// Check the key against the mask
	switch (chMaskChar)
	{
	case _T('D'): // digit only
		if (_istdigit(chChar))
		{
			return TRUE;
		}
		break;
	case _T('d'): // digit or space
		if (_istdigit(chChar))
		{
			return TRUE;
		}
		if (_istspace(chChar))
		{
			return TRUE;
		}
		break;
	case _T('+'): // '+' or '-' or space
		if (chChar == _T('+') || chChar == _T('-'))
		{
			return TRUE;
		}
		if (_istspace(chChar))
		{
			return TRUE;
		}
		break;
	case _T('C'): // alpha only
		if (_istalpha(chChar))
		{
			return TRUE;
		}
		break;
	case _T('c'): // alpha or space
		if (_istalpha(chChar))
		{
			return TRUE;
		}
		if (_istspace(chChar))
		{
			return TRUE;
		}
		break;
	case _T('A'): // alpha numeric only
		if (_istalnum(chChar))
		{
			return TRUE;
		}
		break;
	case _T('a'): // alpha numeric or space
		if (_istalnum(chChar))
		{
			return TRUE;
		}
		if (_istspace(chChar))
		{
			return TRUE;
		}
		break;
	case _T('*'): // a printable character
		if (_istprint(chChar))
		{
			return TRUE;
		}
		break;
	}
	return FALSE; // not allowed symbol
}

BOOL CMFCMaskedEdit::SetValue(LPCTSTR lpszString, BOOL bWithDelimiters)
{
	ASSERT(m_strMask.IsEmpty() == m_strInputTemplate.IsEmpty());
	ASSERT(m_strMask.GetLength() == m_strInputTemplate.GetLength());
	ENSURE(lpszString != NULL);

	// Make sure the string is not longer than the mask
	CString strSource = lpszString;
	if (!m_strMask.IsEmpty())
	{
		if (bWithDelimiters)
		{
			if (strSource.GetLength() > m_strMask.GetLength())
			{
				return FALSE;
			}
		}
		else
		{
			// Count _T('_') in m_strInputTemplate
			int nCount = 0;
			for (int i = 0; i < m_strInputTemplate.GetLength(); i++)
			{
				if (m_strInputTemplate[i] == _T('_'))
				{
					nCount++;
				}

			}
			if (strSource.GetLength() > nCount)
			{
				return FALSE;
			}
		}
	}

	// Make sure the value has only valid string characters
	if (!m_strValid.IsEmpty())
	{
		BOOL bOk = TRUE;
		for (int iPos = 0; bOk && iPos < strSource.GetLength(); iPos++)
		{
			if (m_strInputTemplate.IsEmpty() || m_strInputTemplate[iPos] == _T('_'))
			{
				if (m_strInputTemplate.IsEmpty() || strSource[iPos] != m_chMaskInputTemplate) // allow m_chMaskInputTemplate
				{
					bOk = (m_strValid.Find(strSource[iPos]) != -1);
				}
			}
		}

		if (!bOk)
		{
			return FALSE;
		}
	}

	// Use mask, validate against the mask
	if (!m_strMask.IsEmpty())
	{
		ASSERT(m_str.GetLength() == m_strMask.GetLength());

		CString strResult = m_strInputTemplate;

		// Replace '_' with default char
		for (int i=0; i<strResult.GetLength(); i++)
		{
			if (m_strInputTemplate[i] == _T('_'))
			{
				strResult.SetAt(i, m_chMaskInputTemplate);
			}
		}

		int iSrcChar = 0;
		int iDstChar = 0;
		while ((iSrcChar<strSource.GetLength()) &&
			(iDstChar<m_strInputTemplate.GetLength()))
		{
			// iDstChar - character entry position("_" char)
			if (m_strInputTemplate[iDstChar] == _T('_'))
			{
				TCHAR chChar = strSource[iSrcChar];
				if (chChar != m_chMaskInputTemplate) // allow m_chMaskInputTemplate
				{
					if (!IsMaskedChar(chChar, m_strMask[iDstChar]))
					{
						return FALSE;
					}
				}
				strResult.SetAt(iDstChar, chChar);
				iSrcChar++;
				iDstChar++;
			}

			// iDstChar - delimeter
			else
			{
				if (bWithDelimiters)
				{
					if (m_strInputTemplate[iDstChar] != strSource[iSrcChar])
					{
						return FALSE;
					}

					iSrcChar++;
					iDstChar++;
				}
				else
				{
					iDstChar++;
				}
			}
		}
		m_str = strResult;
	}
	else // Don't use mask
	{
		m_str = strSource;
	}

	return TRUE;
}

const CString CMFCMaskedEdit::GetMaskedValue(BOOL bWithSpaces) const
{
	ASSERT(m_strMask.IsEmpty() == m_strInputTemplate.IsEmpty());
	ASSERT(m_strMask.GetLength() == m_strInputTemplate.GetLength());

	// Don't use mask
	if (m_strMask.IsEmpty())
	{
		return m_str;
	}

	// Use mask
	ASSERT(m_str.GetLength() == m_strMask.GetLength());

	CString strResult;
	for (int iChar=0; iChar < m_strInputTemplate.GetLength(); iChar++)
	{
		if (m_strInputTemplate[iChar] == _T('_'))
		{
			TCHAR ch = m_str[iChar];
			if (ch == m_chMaskInputTemplate)
			{
				if (bWithSpaces)
				{
					strResult += ch;
				}
			}
			else
			{
				ASSERT((!m_strValid.IsEmpty()) ?(m_strValid.Find(ch) != -1) : TRUE);
				ASSERT(IsMaskedChar(ch, m_strMask[iChar]));
				strResult += ch;
			}
		}
	}
	return strResult;
}

///////////////////////////////////
// Replace standard CWnd operations

void CMFCMaskedEdit::SetWindowText(LPCTSTR lpszString)
{
	CEdit::SetWindowText(lpszString);
}

int CMFCMaskedEdit::GetWindowText(_Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpszStringBuf, _In_ int nMaxCount) const
{
	return CEdit::GetWindowText(lpszStringBuf, nMaxCount);
}

void CMFCMaskedEdit::GetWindowText(CString& strString) const
{
	CEdit::GetWindowText(strString);
}

///////////////////////////////////
// Handlers

int CMFCMaskedEdit::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CEdit::OnCreate(lpCreateStruct) == -1)
		return -1;

	CWnd::SetWindowText(m_str);
	return 0;
}

void CMFCMaskedEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// Make sure the mask has entry positions
	int nStartBound, nEndBound;
	GetGroupBounds(nStartBound, nEndBound);
	if (nStartBound == -1)
	{
		// mask has no entry positions
		MessageBeep((UINT)-1);
		return;
	}

	switch (nChar)
	{
	case VK_END:
		{
			// Calc last group bounds
			int nGroupStart, nGroupEnd;
			CEdit::GetSel(nGroupStart, nGroupEnd);
			ASSERT(nGroupStart != -1);
			GetGroupBounds(nGroupStart, nGroupEnd, nGroupEnd, TRUE);
			if (nGroupStart == -1)
			{
				GetGroupBounds(nGroupStart, nGroupEnd, m_str.GetLength(), FALSE);
			}
			ASSERT(nGroupStart != -1);

			CEdit::SetSel(nGroupEnd, nGroupEnd);
			return;
		}
	case VK_HOME:
		{
			// Calc first group bounds
			int nGroupStart, nGroupEnd;
			CEdit::GetSel(nGroupStart, nGroupEnd);
			ASSERT(nGroupStart != -1);
			GetGroupBounds(nGroupStart, nGroupEnd, nGroupStart, FALSE);
			if (nGroupStart == -1)
			{
				GetGroupBounds(nGroupStart, nGroupEnd, 0, TRUE);
			}
			ASSERT(nGroupStart != -1);

			CEdit::SetSel(nGroupStart, nGroupStart);
			return;
		}
	case VK_UP:
	case VK_LEFT:
		{
			// Calc first group bounds
			int nGroupStart, nGroupEnd;
			CEdit::GetSel(nGroupStart, nGroupEnd);
			ASSERT(nGroupStart != -1);
			GetGroupBounds(nGroupStart, nGroupEnd, nGroupStart, FALSE);
			if (nGroupStart == -1)
			{
				GetGroupBounds(nGroupStart, nGroupEnd, 0, TRUE);
			}
			ASSERT(nGroupStart != -1);

			if (::GetKeyState(VK_SHIFT)&0x80)
			{
				int nStart, nEnd;
				CEdit::GetSel(nStart, nEnd);
				if (m_bSelectByGroup)
				{
					int nNewStart = max(nStart-1, nGroupStart);
					// additional
					nNewStart = min(nNewStart, nGroupEnd);
					CEdit::SetSel(nNewStart, nEnd);
				}
				else
				{
					CEdit::SetSel(nStart-1, nEnd);
				}
				return;
			}
			else if (::GetKeyState(VK_CONTROL)&0x80)
			{
				// move to the previous group
				int nStart, nEnd;
				CEdit::GetSel(nStart, nEnd);
				ASSERT(nStart != -1);

				if (nStart > 1)  // can search previous group
				{
					GetGroupBounds(nGroupStart, nGroupEnd, nStart-1, FALSE);
				}
				if ((nGroupStart != -1) &&                        // if previous group was found
					(nGroupStart != nStart || nGroupEnd != nEnd)) // and it's not the same
				{
					CEdit::SetSel(nGroupStart, nGroupEnd);
				}
				else // no more groups
				{
					MessageBeep((UINT)-1);
				}
				return;
			}
			else
			{
				int nStart, nEnd;
				CEdit::GetSel(nStart, nEnd);
				// move to the previous group
				if ((nStart==nEnd) &&(nStart==nGroupStart))
				{
					if (nStart > 1)  // can search previous group
					{
						GetGroupBounds(nGroupStart, nGroupEnd, nStart-1, FALSE);
					}
					if ((nGroupStart != -1) &&(nGroupEnd < nStart))  // if previous group was found
					{
						CEdit::SetSel(nGroupEnd, nGroupEnd);
					}
					else // no more groups
					{
						MessageBeep((UINT)-1);
					}
				}
				else
				{
					int nNewStart = max(nStart-1, nGroupStart);
					// additional
					nNewStart = min(nNewStart, nGroupEnd);
					CEdit::SetSel(nNewStart, nNewStart);
				}
				return;
			}
		}

	case VK_DOWN:
	case VK_RIGHT:
		{
			// Calc last group bounds
			int nGroupStart, nGroupEnd;
			CEdit::GetSel(nGroupStart, nGroupEnd);
			ASSERT(nGroupStart != -1);
			GetGroupBounds(nGroupStart, nGroupEnd, nGroupEnd, TRUE);
			if (nGroupStart == -1)
			{
				GetGroupBounds(nGroupStart, nGroupEnd, m_str.GetLength(), FALSE);
			}
			ASSERT(nGroupStart != -1);

			if (::GetKeyState(VK_SHIFT)&0x80)
			{
				int nStart, nEnd;
				CEdit::GetSel(nStart, nEnd);
				if (m_bSelectByGroup)
				{
					int nNewEnd = min(nEnd+1, nGroupEnd);
					// additional
					nNewEnd = max(nNewEnd, nGroupStart);
					CEdit::SetSel(nStart, nNewEnd);
				}
				else
				{
					CEdit::SetSel(nStart, nEnd+1);
				}
				return;
			}
			else if (::GetKeyState(VK_CONTROL)&0x80)
			{
				// move to the next group
				int nStart, nEnd;
				CEdit::GetSel(nStart, nEnd);
				ASSERT(nStart != -1);

				if (nEnd < m_str.GetLength()-1) // can search next group
				{
					GetGroupBounds(nGroupStart, nGroupEnd, nEnd+1, TRUE);
				}
				if ((nGroupStart != -1) &&                        // if previous group was found
					(nGroupStart != nStart || nGroupEnd != nEnd)) // and it's not the same
				{
					CEdit::SetSel(nGroupStart, nGroupEnd);
				}
				else // no more groups
				{
					MessageBeep((UINT)-1);
				}
				return;
			}
			else
			{
				int nStart, nEnd;
				CEdit::GetSel(nStart, nEnd);
				// move to the next group
				if ((nStart==nEnd) &&(nEnd==nGroupEnd))
				{
					if (nEnd < m_str.GetLength()-1) // can search next group
					{
						GetGroupBounds(nGroupStart, nGroupEnd, nStart+1, TRUE);
					}
					if ((nGroupStart != -1) &&(nGroupStart > nEnd)) // if next group was found
					{
						CEdit::SetSel(nGroupStart, nGroupStart);
					}
					else // no more groups
					{
						MessageBeep((UINT)-1);
					}
				}
				else
				{
					int nNewEnd = min(nEnd+1, nGroupEnd);
					// additional
					nNewEnd = max(nNewEnd, nGroupStart);
					CEdit::SetSel(nNewEnd, nNewEnd);
				}
				return;
			}
		}

	case VK_BACK:
		{
			// Special processing
			OnCharBackspace(nChar, nRepCnt, nFlags);
			return;
		}
	case VK_DELETE:
		{
			if (::GetKeyState(VK_SHIFT)&0x80)
			{
				break;
			}
			// Special processing
			OnCharDelete(nChar, nRepCnt, nFlags);
			return;
		}

	case VK_INSERT:
		{
			if ((::GetKeyState(VK_CONTROL)&0x80) ||(::GetKeyState(VK_SHIFT)&0x80))
			{
				break;
			}
			if (!m_strMask.IsEmpty())
			{
				return;
			}
			break;
		}
	}

	CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CMFCMaskedEdit::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bSelectByGroup)
	{
		// Calc group bounds
		int nGroupStart, nGroupEnd;
		CEdit::GetSel(nGroupStart, nGroupEnd);
		GetGroupBounds(nGroupStart, nGroupEnd, nGroupStart, TRUE);
		if (nGroupStart == -1)
		{
			CEdit::GetSel(nGroupStart, nGroupEnd);
			GetGroupBounds(nGroupStart, nGroupEnd, nGroupStart, FALSE);
		}

		// Correct selection
		int nStart, nEnd;
		CEdit::GetSel(nStart, nEnd);

		int nNewStart = max(nStart, nGroupStart);
		int nNewEnd = min(nEnd, nGroupEnd);
		// additional
		nNewStart = min(nNewStart, nGroupEnd);
		nNewEnd = max(nNewEnd ,nGroupStart);
		if ((nNewEnd != nEnd) ||(nNewStart != nStart))
		{
			CEdit::SetSel(nNewStart, nNewEnd);
		}
	}

	CEdit::OnLButtonUp(nFlags, point);
}

void CMFCMaskedEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	TCHAR chChar = (TCHAR) nChar;
	if (_istprint(chChar) && !(::GetKeyState(VK_CONTROL)&0x80))
	{
		OnCharPrintchar(nChar, nRepCnt, nFlags);
		return;
	}
	else if ((nChar == VK_DELETE || nChar == VK_BACK) &&(!m_strMask.IsEmpty()))
	{
		return;
	}

	int nBeginOld, nEndOld;
	CEdit::GetSel(nBeginOld, nEndOld);

	CEdit::OnChar(nChar, nRepCnt, nFlags);

	DoUpdate(TRUE, nBeginOld, nEndOld);
}

//////////////////////////////
// Char routines

BOOL CMFCMaskedEdit::CheckChar(TCHAR chChar, int nPos) // returns TRUE if the symbol is valid
{
	ASSERT(m_strMask.IsEmpty() == m_strInputTemplate.IsEmpty());
	ASSERT(m_strMask.GetLength() == m_strInputTemplate.GetLength());
	ASSERT(_istprint(chChar) != FALSE);

	ASSERT(nPos >= 0);

	// Don't use mask
	if (m_strMask.IsEmpty())
	{
		// Use valid string characters
		if (!m_strValid.IsEmpty())
		{
			return(m_strValid.Find(chChar) != -1);
		}
		// Don't use valid string characters
		else
		{
			return TRUE;
		}
	}
	else
	{
		ASSERT(nPos < m_strMask.GetLength());
	}

	// Use mask
	ASSERT(m_str.GetLength() == m_strMask.GetLength());
	if (m_strInputTemplate[nPos] == _T('_'))
	{
		BOOL bIsMaskedChar = IsMaskedChar(chChar, m_strMask[nPos]);

		// Use valid string characters
		if (!m_strValid.IsEmpty())
		{
			return bIsMaskedChar &&(m_strValid.Find(chChar) != -1);
		}
		// Don't use valid string characters
		else
		{
			return bIsMaskedChar;
		}
	}
	else
	{
		return FALSE;
	}
}

void CMFCMaskedEdit::OnCharPrintchar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	ASSERT(m_strMask.IsEmpty() == m_strInputTemplate.IsEmpty());
	ASSERT(m_strMask.GetLength() == m_strInputTemplate.GetLength());

	TCHAR chChar = (TCHAR) nChar;
	ASSERT(_istprint(chChar) != FALSE);

	// Processing ES_UPPERCASE and ES_LOWERCASE styles
	DWORD dwStyle = GetStyle();
	if (dwStyle & ES_UPPERCASE)
	{
		chChar = (TCHAR)_totupper(chChar);
	}
	else if (dwStyle & ES_LOWERCASE)
	{
		chChar = (TCHAR)_totlower(chChar);
	}

	int nStartPos, nEndPos;

	CEdit::GetSel(nStartPos, nEndPos);

	ASSERT(nStartPos>=0);
	ASSERT(nEndPos>=0);
	ASSERT(nEndPos>=nStartPos);

	// Calc group bounds
	int nGroupStart, nGroupEnd;
	GetGroupBounds(nGroupStart, nGroupEnd, nStartPos);

	// Out of range
	if ((nStartPos<0) &&(nEndPos > m_str.GetLength()) || (nStartPos < nGroupStart) ||(nStartPos > nGroupEnd) || (nEndPos < nGroupStart) ||(nEndPos > nGroupEnd))
	{
		MessageBeep((UINT)-1);
		CEdit::SetSel(nGroupStart, nGroupEnd);
		return;
	}

	// No selected chars
	if (nStartPos == nEndPos)
	{
		// Use m_strMask
		if (!m_strMask.IsEmpty())
		{
			// Automaticaly move the cursor to the next group
			if (nEndPos==nGroupEnd || // at the end of group
				nStartPos < nGroupStart || nStartPos > nGroupEnd) // not in the middle of a group
			{
				// no space for new char
				if (nEndPos >= m_str.GetLength()-1)
				{
					MessageBeep((UINT)-1);
					return;
				}

				// can search next group
				else if (nEndPos < m_str.GetLength()-1)
				{
					GetGroupBounds(nGroupStart, nGroupEnd, nEndPos+1, TRUE);
				}

				// if next group was found
				if ((nGroupStart != -1) &&(nGroupStart > nEndPos))
				{
					CEdit::SetSel(nGroupStart, nGroupStart);
					nStartPos = nGroupStart;
					nEndPos = nGroupStart;
				}

				// no more groups
				else
				{
					MessageBeep((UINT)-1);
					return;
				}
			}

			// Check char in position
			if (!CheckChar(chChar, nStartPos))
			{
				MessageBeep((UINT)-1);
				return;
			}

			// Replace char in Editbox and m_str
			CEdit::SetSel(nStartPos, nEndPos+1);
			CEdit::ReplaceSel(CString(chChar), TRUE);
			m_str.SetAt(nEndPos, chChar);
			CEdit::SetSel(nEndPos+1, nEndPos+1);

			// Automaticaly move the cursor to the next group
			CEdit::GetSel(nStartPos, nEndPos);
			if (nEndPos==nGroupEnd) // at the end of group
			{
				// can search next group
				if (nEndPos < m_str.GetLength()-1)
				{
					GetGroupBounds(nGroupStart, nGroupEnd, nEndPos+1, TRUE);
				}

				// if next group was found
				if ((nGroupStart != -1) &&(nGroupStart > nEndPos))
				{
					CEdit::SetSel(nGroupStart, nGroupStart);
					nStartPos = nGroupStart;
					nEndPos = nGroupStart;
				}
			}
		}

		// Don't use m_strMask
		else
		{
			// Check char in position
			if (!CheckChar(chChar, nStartPos))
			{
				MessageBeep((UINT)-1);
				return;
			}

			// Don't use m_chMask
			int nBeginOld, nEndOld;
			CEdit::GetSel(nBeginOld, nEndOld);

			CEdit::OnChar(nChar, nRepCnt, nFlags);

			DoUpdate(TRUE, nBeginOld, nEndOld);
		}
	}
	else // Have one or more chars selected
	{
		// Check char in position
		if (!CheckChar(chChar, nStartPos))
		{
			MessageBeep((UINT)-1);
			return;
		}

		// Replace chars in Editbox and m_str
		if (!m_strInputTemplate.IsEmpty()) // Use m_strInputTemplate
		{
			// Calc the number of literals with the same mask char
			ASSERT(nStartPos >= 0);
			ASSERT(nEndPos > 0);
			ASSERT(nStartPos <= m_strInputTemplate.GetLength());

			int nSameMaskCharsNum = 1;
			int nIndex = nStartPos; // an index of the first selected char
			TCHAR chMaskChar = m_strMask[nIndex];
			BOOL bScanMore = TRUE;
			while (bScanMore &&(nIndex + nSameMaskCharsNum < nGroupEnd))
			{
				if (m_strMask[nIndex + nSameMaskCharsNum] == chMaskChar)
				{
					nSameMaskCharsNum++;
				}
				else
				{
					bScanMore = FALSE;
				}
			}

			// Make sure the selection has the same mask char
			if (nEndPos - nStartPos > nSameMaskCharsNum)
			{
				MessageBeep((UINT)-1);
				CEdit::SetSel(nIndex, nIndex+nSameMaskCharsNum);
				return;
			}

			// Form the shifted replace string
			ASSERT(nIndex >= nGroupStart);
			ASSERT(nIndex + nSameMaskCharsNum <= nGroupEnd);

			CString strReplace = m_str.Mid(nIndex, nSameMaskCharsNum);
			if (nSameMaskCharsNum > 0)
			{
				ASSERT(nStartPos <= m_strInputTemplate.GetLength());
				ASSERT(nEndPos <= m_strInputTemplate.GetLength());
				int nRange = nEndPos - nStartPos;
				ASSERT(nRange>0);

				strReplace = strReplace.Right(nSameMaskCharsNum - nRange + 1);
				strReplace += CString(m_chMaskInputTemplate, nRange - 1);
				ASSERT(strReplace.GetLength() > 0);
				strReplace.SetAt(0, chChar);
			}

			// Replace the content with the shifted string
			CEdit::SetSel(nIndex, nIndex+nSameMaskCharsNum);
			CEdit::ReplaceSel(strReplace, TRUE);
			CEdit::SetSel(nIndex, nIndex);
			for (int i=0; i < strReplace.GetLength(); i++)
			{
				m_str.SetAt(nIndex+i, strReplace[i]);
			}
			CEdit::SetSel(nStartPos+1, nStartPos+1);
		}
		else
		{
			// Don't use m_chMaskInputTemplate
			int nBeginOld, nEndOld;
			CEdit::GetSel(nBeginOld, nEndOld);

			CEdit::OnChar(nChar, nRepCnt, nFlags);

			DoUpdate(TRUE, nBeginOld, nEndOld);
		}
	}
}

void CMFCMaskedEdit::OnCharBackspace(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	ASSERT(m_strMask.IsEmpty() == m_strInputTemplate.IsEmpty());
	ASSERT(m_strMask.GetLength() == m_strInputTemplate.GetLength());

	int nStartPos, nEndPos;
	CEdit::GetSel(nStartPos, nEndPos);

	ASSERT(nStartPos>=0);
	ASSERT(nEndPos>=0);
	ASSERT(nEndPos>=nStartPos);

	// Calc group bounds
	int nGroupStart, nGroupEnd;
	GetGroupBounds(nGroupStart, nGroupEnd, nStartPos);

	// Out of range
	if ((nStartPos<0) &&(nEndPos > m_str.GetLength()) || (nStartPos < nGroupStart) ||(nStartPos > nGroupEnd) || (nEndPos < nGroupStart) ||(nEndPos > nGroupEnd))
	{
		MessageBeep((UINT)-1);
		CEdit::SetSel(nGroupStart, nGroupEnd);
		return;
	}

	// No selected chars
	if (nStartPos == nEndPos)
	{

		// Use m_strMask
		if (!m_strMask.IsEmpty())
		{
			// Automaticaly move the cursor to the previous group
			if (nEndPos==nGroupStart) // at the start of group
			{
				// can search previous group
				if (nEndPos > 1)
				{
					GetGroupBounds(nGroupStart, nGroupEnd, nEndPos-1, FALSE);
				}

				// if previous group was found
				if ((nGroupStart != -1) &&(nGroupEnd < nEndPos))
				{
					CEdit::SetSel(nGroupEnd, nGroupEnd);
					return;
				}

				// no more group
				else
				{
					MessageBeep((UINT)-1);
					return;
				}
			}

			// Calc the number of literals with the same mask char
			ASSERT(nStartPos > 0);
			ASSERT(nEndPos > 0);
			ASSERT(nGroupEnd <= m_strInputTemplate.GetLength());

			int nSameMaskCharsNum = 1;
			int nIndex = nStartPos-1; // an index of the char to delete
			TCHAR chMaskChar = m_strMask[nIndex];
			BOOL bScanMore = TRUE;
			while (bScanMore &&(nIndex + nSameMaskCharsNum < nGroupEnd))
			{
				if (m_strMask[nIndex + nSameMaskCharsNum] == chMaskChar)
				{
					nSameMaskCharsNum++;
				}
				else
				{
					bScanMore = FALSE;
				}
			}

			// Validate new string(dispensable)
			int i = nIndex;
			for (;(i + nSameMaskCharsNum < nGroupEnd); i++)
			{
				if (m_str[i] != m_chMaskInputTemplate) // allow m_chMaskInputTemplate
				{
					if (!IsMaskedChar(m_str[i], m_strMask[i]))
					{
						MessageBeep((UINT)-1);
						return;
					}
				}
			}

			// Form the shifted string
			ASSERT(nIndex >= nGroupStart);
			ASSERT(nIndex + nSameMaskCharsNum <= nGroupEnd);

			CString strReplace = m_str.Mid(nIndex, nSameMaskCharsNum);
			if (nSameMaskCharsNum > 0)
			{
				strReplace = strReplace.Right(nSameMaskCharsNum - 1);
				strReplace += m_chMaskInputTemplate;
			}

			// Replace the content with the shifted string
			CEdit::SetSel(nIndex, nIndex+nSameMaskCharsNum);
			CEdit::ReplaceSel(strReplace, TRUE);
			CEdit::SetSel(nIndex, nIndex);
			for (i=0; i < strReplace.GetLength(); i++)
			{
				m_str.SetAt(nIndex+i, strReplace[i]);
			}

		}
		else // Don't use m_chMaskInputTemplate - delete symbol
		{
			int nBeginOld, nEndOld;
			CEdit::GetSel(nBeginOld, nEndOld);

			CWnd::OnKeyDown(nChar, nRepCnt, nFlags);

			DoUpdate(TRUE, nBeginOld, nEndOld);
		}
	}

	// Have one or more chars selected
	else
	{
		if (!m_strInputTemplate.IsEmpty()) // Use m_strInputTemplate
		{
			// Calc the number of literals with the same mask char
			ASSERT(nStartPos >= 0);
			ASSERT(nEndPos > 0);
			ASSERT(nStartPos <= m_strInputTemplate.GetLength());

			int nSameMaskCharsNum = 1;
			int nIndex = nStartPos; // an index of the first selected char
			TCHAR chMaskChar = m_strMask[nIndex];
			BOOL bScanMore = TRUE;
			while (bScanMore &&(nIndex + nSameMaskCharsNum < nGroupEnd))
			{
				if (m_strMask[nIndex + nSameMaskCharsNum] == chMaskChar)
				{
					nSameMaskCharsNum++;
				}
				else
				{
					bScanMore = FALSE;
				}
			}

			// Make sure the selection has the same mask char
			if (nEndPos - nStartPos > nSameMaskCharsNum)
			{
				MessageBeep((UINT)-1);
				CEdit::SetSel(nIndex, nIndex+nSameMaskCharsNum);
				return;
			}

			// Form the shifted replace string
			ASSERT(nIndex >= nGroupStart);
			ASSERT(nIndex + nSameMaskCharsNum <= nGroupEnd);

			CString strReplace = m_str.Mid(nIndex, nSameMaskCharsNum);
			if (nSameMaskCharsNum > 0)
			{
				ASSERT(nStartPos <= m_strInputTemplate.GetLength());
				ASSERT(nEndPos <= m_strInputTemplate.GetLength());
				int nRange = nEndPos - nStartPos;
				ASSERT(nRange>0);

				strReplace = strReplace.Right(nSameMaskCharsNum - nRange);
				strReplace += CString(m_chMaskInputTemplate, nRange);
			}

			// Replace the content with the shifted string
			CEdit::SetSel(nIndex, nIndex+nSameMaskCharsNum);
			CEdit::ReplaceSel(strReplace, TRUE);
			CEdit::SetSel(nIndex, nIndex);
			for (int i=0; i < strReplace.GetLength(); i++)
			{
				m_str.SetAt(nIndex+i, strReplace[i]);
			}
		}
		else
		{
			// Don't use m_chMaskInputTemplate - delete symbols
			int nBeginOld, nEndOld;
			CEdit::GetSel(nBeginOld, nEndOld);

			CWnd::OnKeyDown(nChar, nRepCnt, nFlags);

			DoUpdate(TRUE, nBeginOld, nEndOld);
		}
	}
}

void CMFCMaskedEdit::OnCharDelete(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	ASSERT(m_strMask.IsEmpty() == m_strInputTemplate.IsEmpty());
	ASSERT(m_strMask.GetLength() == m_strInputTemplate.GetLength());

	int nStartPos, nEndPos;
	CEdit::GetSel(nStartPos, nEndPos);
	ASSERT(nStartPos>=0);
	ASSERT(nEndPos>=0);
	ASSERT(nEndPos>=nStartPos);

	// Calc group bounds
	int nGroupStart, nGroupEnd;
	CEdit::GetSel(nGroupStart, nGroupEnd);
	GetGroupBounds(nGroupStart, nGroupEnd, nGroupStart);

	// Out of range
	if ((nStartPos<0) &&(nEndPos > m_str.GetLength()) || (nStartPos < nGroupStart) ||(nStartPos > nGroupEnd) || (nEndPos < nGroupStart) ||(nEndPos > nGroupEnd))
	{
		MessageBeep((UINT)-1);
		CEdit::SetSel(nGroupStart, nGroupEnd);
		return;
	}

	// No selected chars
	if (nStartPos == nEndPos)
	{
		if (!m_strMask.IsEmpty()) // Don't use m_strMask
		{
			// Make sure the cursor is not at the end of group
			if (nEndPos == nGroupEnd)
			{
				MessageBeep((UINT)-1);
				return;
			}

			// Calc the number of literals with the same mask char
			ASSERT(nStartPos >= 0);
			ASSERT(nEndPos >= 0);
			ASSERT(nGroupEnd <= m_strInputTemplate.GetLength());

			int nSameMaskCharsNum = 1;
			int nIndex = nStartPos; // an index of the char to delete
			TCHAR chMaskChar = m_strMask[nIndex];
			BOOL bScanMore = TRUE;
			while (bScanMore &&(nIndex + nSameMaskCharsNum < nGroupEnd))
			{
				if (m_strMask[nIndex + nSameMaskCharsNum] == chMaskChar)
				{
					nSameMaskCharsNum++;
				}
				else
				{
					bScanMore = FALSE;
				}
			}

			// Validate new string(dispensable)
			int i = nIndex;
			for (;(i + nSameMaskCharsNum < nGroupEnd); i++)
			{
				if (m_str[i] != m_chMaskInputTemplate) // allow m_chMaskInputTemplate
				{
					if (!IsMaskedChar(m_str[i], m_strMask[i]))
					{
						MessageBeep((UINT)-1);
						return;
					}
				}
			}

			// Form the shifted string
			ASSERT(nIndex >= nGroupStart);
			ASSERT(nIndex + nSameMaskCharsNum <= nGroupEnd);

			CString strReplace = m_str.Mid(nIndex, nSameMaskCharsNum);
			if (nSameMaskCharsNum > 0)
			{
				strReplace = strReplace.Right(nSameMaskCharsNum - 1);
				strReplace += m_chMaskInputTemplate;
			}

			// Replace the content with the shifted string
			CEdit::SetSel(nIndex, nIndex+nSameMaskCharsNum);
			CEdit::ReplaceSel(strReplace, TRUE);
			CEdit::SetSel(nIndex, nIndex);
			for (i=0; i < strReplace.GetLength(); i++)
			{
				m_str.SetAt(nIndex+i, strReplace[i]);
			}

		}
		else // Don't use m_chMaskInputTemplate - delete symbol
		{
			int nBeginOld, nEndOld;
			CEdit::GetSel(nBeginOld, nEndOld);

			CWnd::OnKeyDown(nChar, nRepCnt, nFlags);

			DoUpdate(TRUE, nBeginOld, nEndOld);
		}
	}

	// Have one or more chars selected
	else
	{
		if (!m_strInputTemplate.IsEmpty()) // Use m_strInputTemplate
		{
			// Calc the number of literals with the same mask char
			ASSERT(nStartPos >= 0);
			ASSERT(nEndPos > 0);
			ASSERT(nStartPos <= m_strInputTemplate.GetLength());

			int nSameMaskCharsNum = 1;
			int nIndex = nStartPos; // an index of the first selected char
			TCHAR chMaskChar = m_strMask[nIndex];
			BOOL bScanMore = TRUE;
			while (bScanMore &&(nIndex + nSameMaskCharsNum < nGroupEnd))
			{
				if (m_strMask[nIndex + nSameMaskCharsNum] == chMaskChar)
				{
					nSameMaskCharsNum++;
				}
				else
				{
					bScanMore = FALSE;
				}
			}

			// Make sure the selection has the same mask char
			if (nEndPos - nStartPos > nSameMaskCharsNum)
			{
				MessageBeep((UINT)-1);
				CEdit::SetSel(nIndex, nIndex+nSameMaskCharsNum);
				return;
			}

			// Form the shifted replace string
			ASSERT(nIndex >= nGroupStart);
			ASSERT(nIndex + nSameMaskCharsNum <= nGroupEnd);

			CString strReplace = m_str.Mid(nIndex, nSameMaskCharsNum);
			if (nSameMaskCharsNum > 0)
			{
				ASSERT(nStartPos <= m_strInputTemplate.GetLength());
				ASSERT(nEndPos <= m_strInputTemplate.GetLength());
				int nRange = nEndPos - nStartPos;
				ASSERT(nRange>0);

				strReplace = strReplace.Right(nSameMaskCharsNum - nRange);
				strReplace += CString(m_chMaskInputTemplate, nRange);
			}

			// Replace the content with the shifted string
			CEdit::SetSel(nIndex, nIndex+nSameMaskCharsNum);
			CEdit::ReplaceSel(strReplace, TRUE);
			CEdit::SetSel(nIndex, nIndex);
			for (int i=0; i < strReplace.GetLength(); i++)
			{
				m_str.SetAt(nIndex+i, strReplace[i]);
			}
		}
		else
		{
			// Don't use m_chMaskInputTemplate - delete symbols
			int nBeginOld, nEndOld;
			CEdit::GetSel(nBeginOld, nEndOld);

			CWnd::OnKeyDown(nChar, nRepCnt, nFlags);

			DoUpdate(TRUE, nBeginOld, nEndOld);
		}
	}
}

void CMFCMaskedEdit::GetGroupBounds(int &nBegin, int &nEnd, int nStartPos, BOOL bForward)
{
	ASSERT(m_strMask.IsEmpty() == m_strInputTemplate.IsEmpty());
	ASSERT(m_strMask.GetLength() == m_strInputTemplate.GetLength());

	if (!m_strInputTemplate.IsEmpty()) // use mask
	{
		ASSERT(m_str.GetLength() == m_strMask.GetLength());
		ASSERT(nStartPos >= 0);
		ASSERT(nStartPos <= m_strInputTemplate.GetLength());

		if (bForward)
		{
			// If nStartPos is in the middle of a group
			// Reverse search for the begin of a group
			int i = nStartPos;
			if (nStartPos>0)
			{
				if (m_strInputTemplate[nStartPos-1] == _T('_'))
				{
					do
					{
						i--;
					}
					while ((i>0) &&(m_strInputTemplate[i]==_T('_')));
				}
			}
			if (i == m_strInputTemplate.GetLength())
			{
				nBegin = -1; // no group
				nEnd = 0;
				return;
			}

			// i points between groups or to the begin of a group
			// Search for the begin of a group
			if (m_strInputTemplate[i] != _T('_'))
			{
				i = m_strInputTemplate.Find(_T('_'), i);
				if (i == -1)
				{
					nBegin = -1; // no group
					nEnd = 0;
					return;
				}
			}
			nBegin = i;

			// Search for the end of a group
			while ((i < m_strInputTemplate.GetLength()) &&(m_strInputTemplate[i]==_T('_')))
			{
				i++;
			}
			nEnd = i;
		}

		else // backward
		{
			// If nStartPos is in the middle of a group
			// Search for the end of a group
			int i = nStartPos;
			while ((i < m_str.GetLength()) &&(m_strInputTemplate[i] == _T('_')))
			{
				i++;
			}
			if (i==0)
			{
				nBegin = -1; // no group
				nEnd = 0;
				return;
			}

			// i points between groups or to the end of a group
			// Reverse search for the end of a group
			if (m_strInputTemplate[i-1] != _T('_'))
			{
				do
				{
					i--;
				}
				while ((i>0) &&(m_strInputTemplate[i-1] != _T('_')));
				if (i==0)
				{
					nBegin = -1; // no group
					nEnd = 0;
					return;
				}
			}
			nEnd = i;

			// Search for the begin of a group
			do
			{
				i--;
			}
			while ((i>0) &&(m_strInputTemplate[i-1]==_T('_')));
			nBegin = i;
		}
	}

	else // don't use mask
	{
		// nStartPos ignored
		nBegin = 0;
		nEnd = m_str.GetLength();
	}
}

BOOL CMFCMaskedEdit::DoUpdate(BOOL bRestoreLastGood, int nBeginOld, int nEndOld)
{
	if (m_bPasteProcessing)
	{
		return FALSE;
	}

	m_bPasteProcessing = TRUE;

	CString strNew;
	GetWindowText(strNew);

	BOOL bRet = SetValue(strNew, TRUE);
	if (!bRet)
	{
		MessageBeep((UINT)-1);
	}

	if (!bRet && bRestoreLastGood)
	{
		CString strOld = m_str;
		SetWindowText (strOld);

		if (nBeginOld != -1)
		{
			CEdit::SetSel(nBeginOld, nEndOld);
		}
	}

	m_bPasteProcessing = FALSE;
	return bRet;
}

BOOL CMFCMaskedEdit::OnUpdateR()
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CEdit::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_UPDATE flag ORed into the lParam mask.

	// TODO: Add your control notification handler code here
	CString str;
	CWnd::GetWindowText(str);

	if (m_str != str && !m_bPasteProcessing)
	{
		// work incorrect for Paste when m_bSetMaskedCharsOnly==TRUE
		if (!SetValue(str, TRUE/*!m_bSetMaskedCharsOnly*/))
		{
			MessageBeep((UINT)-1);
			CWnd::SetWindowText(m_str);
			return FALSE;
		}
		if (str != m_str) // str may be empty
		{
			CWnd::SetWindowText(m_str);

			if (m_bSelectByGroup)
			{
				int nBegin, nEnd;
				GetGroupBounds(nBegin, nEnd, 0, TRUE);

				CEdit::SetSel(nBegin, nEnd);
			}
			else
			{
				CEdit::SetSel(0, -1);
			}
		}
	}
	return FALSE;
}

void CMFCMaskedEdit::OnSetFocusR()
{
	if (m_bSelectByGroup)
	{
		int nBegin, nEnd;
		GetGroupBounds(nBegin, nEnd, 0, TRUE);
		if (nBegin == -1)
		{
		}
		CEdit::SetSel(nBegin, nEnd);
	}
	else
	{
		CEdit::SetSel(0, -1);
	}
}

LRESULT CMFCMaskedEdit::OnCut(WPARAM, LPARAM)
{
	m_bPasteProcessing = TRUE;

	int nBeginOld, nEndOld;
	CEdit::GetSel(nBeginOld, nEndOld);

	Default();

	CString strNew;
	CWnd::GetWindowText(strNew);

	if (!SetValue(strNew, TRUE))
	{
		MessageBeep((UINT)-1);
	}

	CWnd::SetWindowText(m_str);

	if (m_bSelectByGroup)
	{
		GetGroupBounds(nBeginOld, nEndOld, nBeginOld, TRUE);
	}

	CEdit::SetSel(nBeginOld, nBeginOld);
	m_bPasteProcessing = FALSE;

	return 0;
}

LRESULT CMFCMaskedEdit::OnClear(WPARAM, LPARAM)
{
	m_bPasteProcessing = TRUE;

	int nBeginOld, nEndOld;
	CEdit::GetSel(nBeginOld, nEndOld);

	Default();

	CString strNew;
	CWnd::GetWindowText(strNew);

	if (!SetValue(strNew, TRUE))
	{
		MessageBeep((UINT)-1);
	}

	CWnd::SetWindowText(m_str);

	if (m_bSelectByGroup)
	{
		GetGroupBounds(nBeginOld, nEndOld, nBeginOld, TRUE);
	}

	CEdit::SetSel(nBeginOld, nBeginOld);
	m_bPasteProcessing = FALSE;

	return 0;
}

LRESULT CMFCMaskedEdit::OnPaste(WPARAM, LPARAM)
{
	m_bPasteProcessing = TRUE;

	int nBeginOld, nEndOld;
	CEdit::GetSel(nBeginOld, nEndOld);

	Default();

	int nBegin, nEnd;
	CEdit::GetSel(nBegin, nEnd);
	nEnd = max(nBegin, nEnd);

	CString str;
	CWnd::GetWindowText(str);

	CString strPaste = str.Mid(nBeginOld, nEnd - nBeginOld);
	CString strOld;
	int nLeft = nBeginOld;

	if (m_bSetMaskedCharsOnly)
	{
		strOld = GetMaskedValue();

		if (!m_strMask.IsEmpty())
		{
			for (int iChar = 0; iChar < m_strInputTemplate.GetLength() && iChar < nBeginOld;
				iChar++)
			{
				if (m_strInputTemplate[iChar] != _T('_'))
				{
					nLeft--;
				}
			}
		}
	}
	else
	{
		strOld = GetValue();
	}

	CString strNew = strOld.Left(nLeft) + strPaste;
	BOOL bOverwrite = !m_strMask.IsEmpty();
	int nRight = nLeft +(bOverwrite ? strPaste.GetLength() : 0);
	if (nRight < strOld.GetLength())
	{
		strNew += strOld.Mid(nRight);
	}

	if (!SetValue(strNew, !m_bSetMaskedCharsOnly))
	{
		MessageBeep((UINT)-1);
	}

	CWnd::SetWindowText(m_str);

	if (m_bSelectByGroup)
	{
		GetGroupBounds(nBeginOld, nEndOld, nBeginOld, TRUE);
	}
	CEdit::SetSel(nBeginOld, nBeginOld);

	m_bPasteProcessing = FALSE;

	return 0L;
}

///////////////////////////////////
// Replace standard CWnd operations

LRESULT CMFCMaskedEdit::OnSetText(WPARAM, LPARAM lParam)
{
	if (m_bSetTextProcessing || m_bPasteProcessing)
	{
		return Default();
	}

	m_bSetTextProcessing = TRUE;

	BOOL bSetValueRes = SetValue((LPCTSTR)lParam, !m_bSetMaskedCharsOnly);
	if (bSetValueRes)
	{
		LRESULT lRes = FALSE;
		CString strNewValidated = GetValue();
		if (strNewValidated.Compare((LPCTSTR)lParam) != 0)
		{
			// validated new value should differ from lParam
			lRes = (LRESULT)::SetWindowText(GetSafeHwnd(), (LPCTSTR)strNewValidated);
		}
		else
		{
			lRes = Default();
		}

		m_bSetTextProcessing = FALSE;
		return lRes;
	}

	m_bSetTextProcessing = FALSE;
	return FALSE;
}

LRESULT CMFCMaskedEdit::OnGetText(WPARAM wParam, LPARAM lParam)
{
	if (m_bPasteProcessing)
	{
		return Default();
	}

	int nMaxCount = (int)wParam;
	if (nMaxCount == 0)
	{
		return 0;       // nothing copied
	}

	LPTSTR lpszDestBuf = (LPTSTR)lParam;
	if (lpszDestBuf == NULL)
	{
		return 0;       // nothing copied
	}

	CString strText;
	if (m_bGetMaskedCharsOnly)
	{
		strText = GetMaskedValue();
	}
	else
	{
		strText = GetValue();
	}

	// Copy text
	int nCount = min(nMaxCount, strText.GetLength());
	LPCTSTR lpcszTmp = strText;
	CopyMemory(lpszDestBuf, lpcszTmp, nCount * sizeof(TCHAR));

	// Add terminating null character if possible
	if (nMaxCount > nCount)
	{
		lpszDestBuf[nCount] = _T('\0');
	}
	
	return(nCount * sizeof(TCHAR));
}

LRESULT CMFCMaskedEdit::OnGetTextLength(WPARAM, LPARAM)
{
	if (m_bPasteProcessing)
	{
		return Default();
	}

	CString strText;
	if (m_bGetMaskedCharsOnly)
	{
		strText = GetMaskedValue();
	}
	else
	{
		strText = GetValue();
	}

	return (LRESULT) strText.GetLength();
}

LRESULT CMFCMaskedEdit::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	BOOL bSelectByGroup = TRUE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCMaskedEdit_SelectByGroup, bSelectByGroup))
	{
		EnableSelectByGroup(bSelectByGroup);
	}

	// Set mask:
	BOOL bEnableMask = FALSE;
	CString strMask;
	if (tagManager.ExcludeTag(PS_MFCMaskedEdit_Mask, strMask, TRUE))
	{
		bEnableMask = !strMask.IsEmpty();
	}

	CString strInputTemplate;
	if (tagManager.ExcludeTag(PS_MFCMaskedEdit_InputTemplate, strInputTemplate, TRUE))
	{
		// InputTemplate and Mask must be same size
		if (strInputTemplate.GetLength () != strMask.GetLength())
		{
			bEnableMask = FALSE;
		}
	}

	TCHAR chDefault = _T('_');
	CString strDefaultChar;
	if (tagManager.ExcludeTag(PS_MFCMaskedEdit_DefaultChar, strDefaultChar, TRUE))
	{
		if (!strDefaultChar.IsEmpty ())
		{
			if (strDefaultChar.GetLength() > 1)
			{
				chDefault = strDefaultChar[0];
			}
		}
	}

	try
	{
		if (bEnableMask)
		{
			EnableMask(strMask, strInputTemplate, chDefault);
		}
		else
		{
			DisableMask();
		}
	}
	catch(...)
	{
		// TRACE(_T("CMFCMaskedEdit: Can't EnableMask.\n"));
		// strMask and strInputTemplate are not suitable
	}

	CString strValidChars;
	if (tagManager.ExcludeTag(PS_MFCMaskedEdit_ValidChars, strValidChars, TRUE))
	{
		SetValidChars(strValidChars);
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxjumplist.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#ifndef __AFXADV_H__
#include <afxadv.h>
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#include <propkey.h>
#include <atlconv.h>
#include <propvarutil.h>

#include "afxglobals.h"

#if (WINVER >= 0x0601)
CJumpList::CJumpList(BOOL bAutoCommit) 
{
	m_bInitialized = FALSE;
	m_nMaxSlots = 0;
	m_bAutoCommit = bAutoCommit;
}

CJumpList::~CJumpList()
{
	if (!afxGlobalData.bIsWindows7)
	{
		return;
	}

	if (m_bInitialized && !m_bAutoCommit)
	{
		TRACE0("Jump list is being destroyed without a call on CJumpList::CommitList.\n");
	}

	if (m_bAutoCommit)
	{
		// calls ClearAll as well
		// can be called when m_bInitialized is FALSE
		CommitList();
	}
	else
	{
		ClearAll();
	}
}

void CJumpList::ClearAll()
{
	if (!afxGlobalData.bIsWindows7)
	{
		return;
	}

	ClearAllDestinations();
	ReleaseObjectArray(m_tasksPtr.Detach());
	ReleaseObjectArray(m_removedItemsPtr.Detach());

	m_bInitialized = FALSE;
}

BOOL CJumpList::InitializeList()
{
	if (!afxGlobalData.bIsWindows7)
	{
		return FALSE;
	}

	HRESULT hr = S_OK;
	if (m_destListPtr == NULL)
	{
		hr = m_destListPtr.CoCreateInstance(CLSID_DestinationList, NULL, CLSCTX_INPROC_SERVER);
		if (FAILED(hr))
		{
			TRACE1("Error initializing Jump List, code: %x", hr);
			return FALSE;
		}
	}

	if (m_tasksPtr == NULL)
	{
		hr = m_tasksPtr.CoCreateInstance(CLSID_EnumerableObjectCollection, NULL, CLSCTX_INPROC_SERVER);
		if (FAILED(hr))
		{
			TRACE1("Error initializing task collection, code: %x", hr);
			return FALSE;
		}
	}

	if (!m_bInitialized)
	{
		CString strAppID = m_strAppID; 
		if (strAppID.IsEmpty ())
		{
			// try WinApp
			CWinApp* pApp = AfxGetApp();
			ASSERT(pApp != NULL);
			strAppID = pApp->m_pszAppID;
		}

		if(!strAppID.IsEmpty())
		{
#ifdef UNICODE
			m_destListPtr->SetAppID(strAppID);
#else
			USES_CONVERSION;
			LPCWSTR lpAppID = A2W(strAppID);
			m_destListPtr->SetAppID(lpAppID);
#endif
		}

		hr = m_destListPtr->BeginList(&m_nMaxSlots, IID_IObjectArray, (LPVOID*)&m_removedItemsPtr);
		if (FAILED(hr))
		{
			TRACE1("ICustomDestinationList::BeginList failed, initialization canceled, HRESULT: %x", hr);
			return FALSE;
		}
		m_bInitialized = TRUE;
	}

	return TRUE;
}

UINT CJumpList::GetMaxSlots() const
{
	if (!afxGlobalData.bIsWindows7)
	{
		return 0;
	}

	ASSERT(m_bInitialized);
	return m_nMaxSlots;
}

BOOL CJumpList::AddKnownCategory(KNOWNDESTCATEGORY category)
{
	if (!InitializeList()) // always returns FALSE if OS < Win7 
	{
		return FALSE;
	}

	HRESULT hr = m_destListPtr->AppendKnownCategory(category);
	if (FAILED(hr))
	{
		TRACE1("CJumpList::AddKnownCategory failed, HRESULT: %x\n", hr);
		return FALSE;
	}

	return TRUE;
}

BOOL CJumpList::AddTask(LPCTSTR strTargetExecutablePath, LPCTSTR strCommandLineArgs, 
						LPCTSTR strTitle, LPCTSTR strIconPath, int iIconIndex)
{
	if (!InitializeList()) // always returns FALSE if OS < Win7 
	{
		return FALSE;
	}

	AfxIsValidString(strTargetExecutablePath);
	AfxIsValidString(strTitle);

	if (strTargetExecutablePath == NULL || strTitle == NULL)
	{
		return FALSE;
	}

	CComPtr<IShellLink> shellLinkPtr;
	if (FAILED(shellLinkPtr.CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER)))
	{
		return FALSE;
	}

	shellLinkPtr->SetPath(strTargetExecutablePath);
	shellLinkPtr->SetArguments(strCommandLineArgs);
	shellLinkPtr->SetIconLocation(strIconPath, iIconIndex);

	CComQIPtr<IPropertyStore> propPtr = shellLinkPtr;

	if (propPtr != NULL)
	{
		PROPVARIANT var;
#ifdef UNICODE
		if (FAILED(InitPropVariantFromString(strTitle, &var)))
		{
			return FALSE;
		}
#else
		USES_CONVERSION;
		LPCWSTR lpTitle = A2W(strTitle);
		if (FAILED(InitPropVariantFromString(lpTitle, &var)))
		{
			return FALSE;
		}
#endif

		if (FAILED(propPtr->SetValue(PKEY_Title, var)))
		{
			PropVariantClear(&var);
			return FALSE;
		}

		HRESULT hr = propPtr->Commit();
		PropVariantClear(&var);
		if (FAILED(hr))
		{
			return FALSE;
		}
	}

	return (SUCCEEDED(m_tasksPtr->AddObject(shellLinkPtr.Detach())));
}

BOOL CJumpList::AddTaskSeparator()
{
	if (!InitializeList()) // always returns FALSE if OS < Win7 
	{
		return FALSE;
	}

	CComPtr<IShellLink> shellLinkPtr;
	if (FAILED(shellLinkPtr.CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER)))
	{
		return FALSE;
	}

	CComQIPtr<IPropertyStore> propPtr = shellLinkPtr;
	PROPVARIANT var;
	var.vt = VT_BOOL;
	var.boolVal = VARIANT_TRUE;

	if (FAILED(propPtr->SetValue(PKEY_AppUserModel_IsDestListSeparator, var)))
	{
		PropVariantClear(&var);
		return FALSE;
	}

	HRESULT hr = propPtr->Commit();
	PropVariantClear(&var);
	if (FAILED(hr))
	{
		return FALSE;
	}

	return (SUCCEEDED(m_tasksPtr->AddObject(shellLinkPtr.Detach())));
}

BOOL CJumpList::AddTask(IShellLink* pShellLink)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return FALSE;
	}

	ASSERT(pShellLink != NULL);

	if (pShellLink == NULL)
	{
		return FALSE;
	}

	if (!InitializeList())
	{
		return FALSE;
	}

	if (FAILED(m_tasksPtr->AddObject(pShellLink)))
	{
		return FALSE;
	}

	pShellLink->AddRef();
	return TRUE;
}

BOOL CJumpList::AddTasks(IObjectArray* pObjectCollection)
{
	if (!InitializeList()) // always returns FALSE if OS < Win7 
	{
		return FALSE;
	}

	ASSERT(pObjectCollection != NULL);

	if (pObjectCollection == NULL)
	{
		return FALSE;
	}

	return SUCCEEDED(m_tasksPtr->AddFromArray(pObjectCollection));
}

BOOL CJumpList::AddDestination(LPCTSTR lpcszCategoryName, LPCTSTR lpcszDestinationPath)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return FALSE;
	}

	ASSERT(lpcszCategoryName != NULL);
	ASSERT(lpcszDestinationPath != NULL);

	if (lpcszCategoryName == NULL || lpcszDestinationPath == NULL)
	{
		return FALSE;
	}

	IObjectCollection* pColl = GetObjectCollection(lpcszCategoryName);

	if (pColl == NULL)
	{
		TRACE0("AddDestination - GetObjectCollection returned NULL collection.\n");
		return FALSE;
	}

	IShellItem* psi = NULL;
#ifdef UNICODE
	HRESULT hr = afxGlobalData.ShellCreateItemFromParsingName(lpcszDestinationPath, NULL, IID_IShellItem, (LPVOID*)&psi);
#else
	USES_CONVERSION;
	LPWSTR lpDestPath = A2W(lpcszDestinationPath);
	HRESULT hr = afxGlobalData.ShellCreateItemFromParsingName(lpDestPath, NULL, IID_IShellItem, (LPVOID*)&psi);
#endif

	if (FAILED(hr))
	{
		TRACE1("Can't obtain IShellItem from specified destination, HRESULT: %x.\n", hr);
		return FALSE;
	}

	hr = pColl->AddObject(psi);

	if (FAILED(hr))
	{
		TRACE1("Add object to collection failed, HRESULT: %x.\n", hr);
		psi->Release();
		return FALSE;
	}

	return TRUE;
}

BOOL CJumpList::AddDestination(LPCTSTR lpcszCategoryName, IShellItem* pShellItem)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return FALSE;
	}

	ASSERT(pShellItem != NULL);

	if (pShellItem == NULL)
	{
		return FALSE;
	}

	IObjectCollection* pColl = GetObjectCollection(lpcszCategoryName);

	if (pColl == NULL)
	{
		return FALSE;
	}

	HRESULT hr = pColl->AddObject(pShellItem);

	if (FAILED(hr))
	{
		TRACE1("Add object to collection failed, HRESULT: %x.\n", hr);
		return FALSE;
	}

	return TRUE;
}

BOOL CJumpList::AddDestination(LPCTSTR lpcszCategoryName, IShellLink* pShellLink)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return FALSE;
	}

	ASSERT(pShellLink != NULL);

	if (pShellLink == NULL)
	{
		return FALSE;
	}

	IObjectCollection* pColl = GetObjectCollection(lpcszCategoryName);

	if (pColl == NULL)
	{
		return FALSE;
	}

	HRESULT hr = pColl->AddObject(pShellLink);

	if (FAILED(hr))
	{
		TRACE1("Add object to collection failed, HRESULT: %x.\n", hr);
		return FALSE;
	}

	return TRUE;
}

IObjectCollection* CJumpList::GetObjectCollection(LPCTSTR lpcszCategoryName)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return NULL;
	}

	ASSERT(lpcszCategoryName);

	if (lpcszCategoryName == NULL)
	{
		return NULL;
	}

	IObjectCollection* pColl = NULL;
	m_mapDestinations.Lookup(lpcszCategoryName, pColl);
	if(pColl == NULL)
	{
		HRESULT hr = CoCreateInstance(CLSID_EnumerableObjectCollection, NULL, CLSCTX_INPROC_SERVER, 
			IID_IObjectCollection, (LPVOID*) &pColl);
		if (FAILED(hr))
		{
			TRACE1("Creation of object collection failed with HRESULT: %x.\n", hr);
			return NULL;
		}

		m_mapDestinations.SetAt(lpcszCategoryName, pColl);
	}

	return pColl;
}

BOOL CJumpList::CommitList()
{
	if (!InitializeList()) // always returns FALSE if OS < Win7 
	{
		return FALSE;
	}

	for (POSITION pos = m_mapDestinations.GetStartPosition(); pos != NULL;)
	{
		CString strCategory;
		IObjectCollection* pColl = NULL;
		m_mapDestinations.GetNextAssoc(pos, strCategory, pColl);

		// remove items that could be in "removed" list from the collection being added  
		IObjectCollection* pFinalCollection = CheckRemovedItems(pColl);

		ASSERT(pFinalCollection != NULL);
		if (pFinalCollection == NULL)
		{
			TRACE1("A final collection for Category \"%s\" is NULL. This category is not committed. \n", strCategory);
			continue;
		}

		UINT nDocCount = 0;
		pFinalCollection->GetCount(&nDocCount);

		if (nDocCount == 0)
		{
			TRACE1("WARNING: A final collection for Category \"%s\" is empty. \n", strCategory);
		}

#ifdef UNICODE
		HRESULT hr = m_destListPtr->AppendCategory(strCategory, pFinalCollection);
#else
		USES_CONVERSION;
		LPWSTR lpCategory = A2W(strCategory);
		HRESULT hr = m_destListPtr->AppendCategory(lpCategory, pFinalCollection);
#endif
		if(FAILED(hr))
		{
			TRACE2("Append category %s failed , HRESULT: %x.\n", strCategory, hr);
		}

		ReleaseObjectArray(pFinalCollection);
	}

	ASSERT(m_tasksPtr != NULL);
	UINT nTaskCount = 0;
	m_tasksPtr->GetCount(&nTaskCount);

	if (nTaskCount > 0)
	{
		HRESULT hr = m_destListPtr->AddUserTasks(m_tasksPtr);
		if (FAILED(hr))
		{
			TRACE1("Add tasks failed, code: %x\n", hr);
		}
		IObjectCollection* pTaskColl = m_tasksPtr.Detach();
		ReleaseObjectArray(pTaskColl);
	}

	m_mapDestinations.RemoveAll();

	BOOL bResult = TRUE;
	HRESULT hr = m_destListPtr->CommitList();

	if (FAILED(hr))
	{
		TRACE1("CommitList failed, HRESULT: %x\n", hr);
		bResult = FALSE;
	}

	ClearAll(); //set m_bInitialized to FALSE

	// prevent calling CommitList for second time from destructor
	m_bAutoCommit = FALSE;

	return bResult;
}

IObjectCollection* CJumpList::CheckRemovedItems(IObjectCollection* pColl)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return NULL;
	}

	ASSERT(pColl != NULL);
	ASSERT(m_bInitialized);
	ASSERT(m_destListPtr != NULL);

	if (m_removedItemsPtr == NULL)
	{
		return pColl;
	}

	UINT nRemovedObjCount = 0; 
	UINT nCheckObjCount = 0;

	if (FAILED(m_removedItemsPtr->GetCount(&nRemovedObjCount)) || nRemovedObjCount == 0)
	{
		return pColl;
	}

	if (FAILED(pColl->GetCount(&nCheckObjCount)) || nCheckObjCount == 0)
	{
		return pColl;
	}

	IObjectCollection* pFinalCollection = NULL;

	HRESULT hr = CoCreateInstance(CLSID_EnumerableObjectCollection, NULL, CLSCTX_INPROC_SERVER, 
		IID_IObjectCollection, (LPVOID*) &pFinalCollection);

	if (FAILED(hr))
	{
		return pColl;
	}

	for (UINT i = 0; i < nCheckObjCount; i++)
	{
		IShellItem* pShellItemChk = NULL;
		if (FAILED (pColl->GetAt(i, IID_IShellItem, (LPVOID*) &pShellItemChk)) || pShellItemChk == NULL)
		{
			continue;
		}

		for (UINT j = 0; j < nRemovedObjCount; j++)
		{
			IShellItem* pShellItemRemoved = NULL;
			if (FAILED (m_removedItemsPtr->GetAt(i, IID_IShellItem, (LPVOID*) &pShellItemRemoved)) || pShellItemRemoved == NULL)
			{
				continue;
			}

			int nOrder = 0;
			if (SUCCEEDED(pShellItemChk->Compare(pShellItemRemoved, 0, &nOrder)) && nOrder != 0)
			{
				pFinalCollection->AddObject(pShellItemChk);
			}
			else
			{
				pShellItemChk->Release();
			}
		}
	}

	pColl->Release();
	return pFinalCollection;

}

void CJumpList::ClearAllDestinations()
{
	if (!afxGlobalData.bIsWindows7)
	{
		return;
	}

	for (POSITION pos = m_mapDestinations.GetStartPosition(); pos != NULL;)
	{
		CString strCategory;
		IObjectCollection* pColl = NULL;
		m_mapDestinations.GetNextAssoc(pos, strCategory, pColl);

		ReleaseObjectArray(pColl);
	}

	m_mapDestinations.RemoveAll();
}

void CJumpList::ReleaseObjectArray(IObjectArray* pColl, BOOL bReleaseItemsOnly)
{
	if (pColl == NULL)
	{
		return;
	}

	UINT nObjCount = 0;
	HRESULT hr = pColl->GetCount(&nObjCount);
	if (FAILED(hr))
	{
		return;
	}

	for (UINT i = 0; i < nObjCount; i++)
	{
		IUnknown* pUnk = NULL;
		if (SUCCEEDED (pColl->GetAt(i, IID_IUnknown, (LPVOID*) &pUnk)) && pUnk != NULL)
		{
			pUnk->Release();
		}
	}

	if (!bReleaseItemsOnly)
	{
		pColl->Release();
	}
}

CAppDestinations::CAppDestinations()
{
	CWinApp* pApp = AfxGetApp();

	if (pApp != NULL)
	{
		SetAppID(pApp->m_pszAppID);	
	}
}

CAppDestinations::CAppDestinations(LPCTSTR lpszAppID)
{
	SetAppID(lpszAppID);
}

void CAppDestinations::SetAppID(LPCTSTR lpszAppID)
{
#ifdef UNICODE
	m_strAppID = lpszAppID;
#else
	USES_CONVERSION;
	m_strAppID = A2W(lpszAppID);
#endif
}

BOOL CAppDestinations::RemoveDestination(IUnknown* pUnk)
{
	if (!Init() || pUnk == NULL) // always returns FALSE for OS < Win7
	{
		return FALSE;
	}

	ENSURE(m_appDests != NULL);
	HRESULT hr = m_appDests->RemoveDestination(pUnk);

	if (FAILED(hr))
	{
		TRACE1("RemoveDestination failed with code %x.", hr);
		return FALSE;
	}

	return TRUE;
}

BOOL CAppDestinations::RemoveAllDestinations()
{
	if (!Init()) // always returns FALSE for OS < Win7
	{
		return FALSE;
	}

	ENSURE(m_appDests != NULL);
	HRESULT hr = m_appDests->RemoveAllDestinations();

	if (FAILED(hr))
	{
		TRACE1("RemoveAllDestinations failed with code %x.", hr);
		return FALSE;
	}

	return TRUE;
}

BOOL CAppDestinations::Init()
{
	if (!afxGlobalData.bIsWindows7)
	{
		return FALSE;
	}

	if (m_appDests != NULL) // already initialized
	{
		return TRUE;
	}

	HRESULT hr = m_appDests.CoCreateInstance(CLSID_ApplicationDestinations, NULL, CLSCTX_INPROC_SERVER);

	if (FAILED(hr))
	{
		TRACE1("Creation of Application Destinations object failed with HRESULT %x. \n", hr);
		return FALSE;
	}

	if (m_strAppID.IsEmpty ())
	{
		// try WinApp again
		CWinApp* pApp = AfxGetApp();
		ASSERT(pApp != NULL);

		SetAppID(pApp->m_pszAppID);
	}

	hr = m_appDests->SetAppID(m_strAppID);
	if (FAILED(hr))
	{
		TRACE1("IApplicationDestinations::SetAppID failed with HRESULT %x. \n", hr);
		return FALSE;
	}

	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\atl\atls\ia64\qithunk.s ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

	.global ?f3@_QIThunk@ATL@@UEAAJXZ
	.proc	?f3@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f3@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=3*8,r14	// r14 = &m_pUnk->vtbl[3] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[3]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[3].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[3].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f3@_QIThunk@ATL@@UEAAJXZ


	.global ?f4@_QIThunk@ATL@@UEAAJXZ
	.proc	?f4@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f4@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=4*8,r14	// r14 = &m_pUnk->vtbl[4] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[4]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[4].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[4].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f4@_QIThunk@ATL@@UEAAJXZ


	.global ?f5@_QIThunk@ATL@@UEAAJXZ
	.proc	?f5@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f5@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=5*8,r14	// r14 = &m_pUnk->vtbl[5] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[5]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[5].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[5].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f5@_QIThunk@ATL@@UEAAJXZ


	.global ?f6@_QIThunk@ATL@@UEAAJXZ
	.proc	?f6@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f6@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=6*8,r14	// r14 = &m_pUnk->vtbl[6] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[6]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[6].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[6].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f6@_QIThunk@ATL@@UEAAJXZ


	.global ?f7@_QIThunk@ATL@@UEAAJXZ
	.proc	?f7@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f7@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=7*8,r14	// r14 = &m_pUnk->vtbl[7] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[7]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[7].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[7].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f7@_QIThunk@ATL@@UEAAJXZ


	.global ?f8@_QIThunk@ATL@@UEAAJXZ
	.proc	?f8@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f8@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=8*8,r14	// r14 = &m_pUnk->vtbl[8] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[8]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[8].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[8].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f8@_QIThunk@ATL@@UEAAJXZ


	.global ?f9@_QIThunk@ATL@@UEAAJXZ
	.proc	?f9@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f9@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=9*8,r14	// r14 = &m_pUnk->vtbl[9] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[9]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[9].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[9].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f9@_QIThunk@ATL@@UEAAJXZ


	.global ?f10@_QIThunk@ATL@@UEAAJXZ
	.proc	?f10@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f10@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=10*8,r14	// r14 = &m_pUnk->vtbl[10] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[10]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[10].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[10].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f10@_QIThunk@ATL@@UEAAJXZ


	.global ?f11@_QIThunk@ATL@@UEAAJXZ
	.proc	?f11@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f11@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=11*8,r14	// r14 = &m_pUnk->vtbl[11] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[11]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[11].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[11].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f11@_QIThunk@ATL@@UEAAJXZ


	.global ?f12@_QIThunk@ATL@@UEAAJXZ
	.proc	?f12@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f12@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=12*8,r14	// r14 = &m_pUnk->vtbl[12] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[12]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[12].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[12].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f12@_QIThunk@ATL@@UEAAJXZ


	.global ?f13@_QIThunk@ATL@@UEAAJXZ
	.proc	?f13@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f13@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=13*8,r14	// r14 = &m_pUnk->vtbl[13] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[13]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[13].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[13].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f13@_QIThunk@ATL@@UEAAJXZ


	.global ?f14@_QIThunk@ATL@@UEAAJXZ
	.proc	?f14@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f14@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=14*8,r14	// r14 = &m_pUnk->vtbl[14] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[14]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[14].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[14].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f14@_QIThunk@ATL@@UEAAJXZ


	.global ?f15@_QIThunk@ATL@@UEAAJXZ
	.proc	?f15@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f15@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=15*8,r14	// r14 = &m_pUnk->vtbl[15] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[15]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[15].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[15].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f15@_QIThunk@ATL@@UEAAJXZ


	.global ?f16@_QIThunk@ATL@@UEAAJXZ
	.proc	?f16@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f16@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=16*8,r14	// r14 = &m_pUnk->vtbl[16] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[16]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[16].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[16].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f16@_QIThunk@ATL@@UEAAJXZ


	.global ?f17@_QIThunk@ATL@@UEAAJXZ
	.proc	?f17@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f17@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=17*8,r14	// r14 = &m_pUnk->vtbl[17] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[17]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[17].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[17].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f17@_QIThunk@ATL@@UEAAJXZ


	.global ?f18@_QIThunk@ATL@@UEAAJXZ
	.proc	?f18@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f18@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=18*8,r14	// r14 = &m_pUnk->vtbl[18] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[18]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[18].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[18].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f18@_QIThunk@ATL@@UEAAJXZ


	.global ?f19@_QIThunk@ATL@@UEAAJXZ
	.proc	?f19@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f19@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=19*8,r14	// r14 = &m_pUnk->vtbl[19] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[19]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[19].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[19].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f19@_QIThunk@ATL@@UEAAJXZ


	.global ?f20@_QIThunk@ATL@@UEAAJXZ
	.proc	?f20@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f20@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=20*8,r14	// r14 = &m_pUnk->vtbl[20] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[20]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[20].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[20].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f20@_QIThunk@ATL@@UEAAJXZ


	.global ?f21@_QIThunk@ATL@@UEAAJXZ
	.proc	?f21@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f21@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=21*8,r14	// r14 = &m_pUnk->vtbl[21] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[21]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[21].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[21].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f21@_QIThunk@ATL@@UEAAJXZ


	.global ?f22@_QIThunk@ATL@@UEAAJXZ
	.proc	?f22@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f22@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=22*8,r14	// r14 = &m_pUnk->vtbl[22] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[22]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[22].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[22].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f22@_QIThunk@ATL@@UEAAJXZ


	.global ?f23@_QIThunk@ATL@@UEAAJXZ
	.proc	?f23@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f23@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=23*8,r14	// r14 = &m_pUnk->vtbl[23] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[23]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[23].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[23].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f23@_QIThunk@ATL@@UEAAJXZ


	.global ?f24@_QIThunk@ATL@@UEAAJXZ
	.proc	?f24@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f24@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=24*8,r14	// r14 = &m_pUnk->vtbl[24] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[24]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[24].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[24].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f24@_QIThunk@ATL@@UEAAJXZ


	.global ?f25@_QIThunk@ATL@@UEAAJXZ
	.proc	?f25@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f25@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=25*8,r14	// r14 = &m_pUnk->vtbl[25] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[25]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[25].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[25].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f25@_QIThunk@ATL@@UEAAJXZ


	.global ?f26@_QIThunk@ATL@@UEAAJXZ
	.proc	?f26@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f26@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=26*8,r14	// r14 = &m_pUnk->vtbl[26] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[26]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[26].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[26].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f26@_QIThunk@ATL@@UEAAJXZ


	.global ?f27@_QIThunk@ATL@@UEAAJXZ
	.proc	?f27@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f27@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=27*8,r14	// r14 = &m_pUnk->vtbl[27] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[27]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[27].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[27].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f27@_QIThunk@ATL@@UEAAJXZ


	.global ?f28@_QIThunk@ATL@@UEAAJXZ
	.proc	?f28@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f28@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=28*8,r14	// r14 = &m_pUnk->vtbl[28] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[28]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[28].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[28].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f28@_QIThunk@ATL@@UEAAJXZ


	.global ?f29@_QIThunk@ATL@@UEAAJXZ
	.proc	?f29@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f29@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=29*8,r14	// r14 = &m_pUnk->vtbl[29] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[29]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[29].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[29].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f29@_QIThunk@ATL@@UEAAJXZ


	.global ?f30@_QIThunk@ATL@@UEAAJXZ
	.proc	?f30@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f30@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=30*8,r14	// r14 = &m_pUnk->vtbl[30] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[30]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[30].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[30].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f30@_QIThunk@ATL@@UEAAJXZ


	.global ?f31@_QIThunk@ATL@@UEAAJXZ
	.proc	?f31@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f31@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=31*8,r14	// r14 = &m_pUnk->vtbl[31] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[31]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[31].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[31].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f31@_QIThunk@ATL@@UEAAJXZ


	.global ?f32@_QIThunk@ATL@@UEAAJXZ
	.proc	?f32@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f32@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=32*8,r14	// r14 = &m_pUnk->vtbl[32] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[32]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[32].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[32].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f32@_QIThunk@ATL@@UEAAJXZ


	.global ?f33@_QIThunk@ATL@@UEAAJXZ
	.proc	?f33@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f33@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=33*8,r14	// r14 = &m_pUnk->vtbl[33] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[33]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[33].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[33].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f33@_QIThunk@ATL@@UEAAJXZ


	.global ?f34@_QIThunk@ATL@@UEAAJXZ
	.proc	?f34@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f34@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=34*8,r14	// r14 = &m_pUnk->vtbl[34] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[34]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[34].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[34].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f34@_QIThunk@ATL@@UEAAJXZ


	.global ?f35@_QIThunk@ATL@@UEAAJXZ
	.proc	?f35@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f35@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=35*8,r14	// r14 = &m_pUnk->vtbl[35] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[35]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[35].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[35].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f35@_QIThunk@ATL@@UEAAJXZ


	.global ?f36@_QIThunk@ATL@@UEAAJXZ
	.proc	?f36@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f36@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=36*8,r14	// r14 = &m_pUnk->vtbl[36] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[36]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[36].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[36].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f36@_QIThunk@ATL@@UEAAJXZ


	.global ?f37@_QIThunk@ATL@@UEAAJXZ
	.proc	?f37@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f37@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=37*8,r14	// r14 = &m_pUnk->vtbl[37] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[37]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[37].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[37].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f37@_QIThunk@ATL@@UEAAJXZ


	.global ?f38@_QIThunk@ATL@@UEAAJXZ
	.proc	?f38@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f38@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=38*8,r14	// r14 = &m_pUnk->vtbl[38] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[38]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[38].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[38].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f38@_QIThunk@ATL@@UEAAJXZ


	.global ?f39@_QIThunk@ATL@@UEAAJXZ
	.proc	?f39@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f39@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=39*8,r14	// r14 = &m_pUnk->vtbl[39] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[39]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[39].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[39].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f39@_QIThunk@ATL@@UEAAJXZ


	.global ?f40@_QIThunk@ATL@@UEAAJXZ
	.proc	?f40@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f40@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=40*8,r14	// r14 = &m_pUnk->vtbl[40] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[40]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[40].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[40].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f40@_QIThunk@ATL@@UEAAJXZ


	.global ?f41@_QIThunk@ATL@@UEAAJXZ
	.proc	?f41@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f41@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=41*8,r14	// r14 = &m_pUnk->vtbl[41] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[41]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[41].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[41].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f41@_QIThunk@ATL@@UEAAJXZ


	.global ?f42@_QIThunk@ATL@@UEAAJXZ
	.proc	?f42@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f42@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=42*8,r14	// r14 = &m_pUnk->vtbl[42] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[42]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[42].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[42].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f42@_QIThunk@ATL@@UEAAJXZ


	.global ?f43@_QIThunk@ATL@@UEAAJXZ
	.proc	?f43@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f43@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=43*8,r14	// r14 = &m_pUnk->vtbl[43] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[43]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[43].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[43].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f43@_QIThunk@ATL@@UEAAJXZ


	.global ?f44@_QIThunk@ATL@@UEAAJXZ
	.proc	?f44@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f44@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=44*8,r14	// r14 = &m_pUnk->vtbl[44] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[44]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[44].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[44].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f44@_QIThunk@ATL@@UEAAJXZ


	.global ?f45@_QIThunk@ATL@@UEAAJXZ
	.proc	?f45@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f45@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=45*8,r14	// r14 = &m_pUnk->vtbl[45] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[45]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[45].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[45].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f45@_QIThunk@ATL@@UEAAJXZ


	.global ?f46@_QIThunk@ATL@@UEAAJXZ
	.proc	?f46@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f46@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=46*8,r14	// r14 = &m_pUnk->vtbl[46] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[46]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[46].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[46].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f46@_QIThunk@ATL@@UEAAJXZ


	.global ?f47@_QIThunk@ATL@@UEAAJXZ
	.proc	?f47@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f47@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=47*8,r14	// r14 = &m_pUnk->vtbl[47] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[47]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[47].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[47].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f47@_QIThunk@ATL@@UEAAJXZ


	.global ?f48@_QIThunk@ATL@@UEAAJXZ
	.proc	?f48@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f48@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=48*8,r14	// r14 = &m_pUnk->vtbl[48] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[48]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[48].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[48].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f48@_QIThunk@ATL@@UEAAJXZ


	.global ?f49@_QIThunk@ATL@@UEAAJXZ
	.proc	?f49@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f49@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=49*8,r14	// r14 = &m_pUnk->vtbl[49] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[49]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[49].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[49].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f49@_QIThunk@ATL@@UEAAJXZ


	.global ?f50@_QIThunk@ATL@@UEAAJXZ
	.proc	?f50@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f50@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=50*8,r14	// r14 = &m_pUnk->vtbl[50] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[50]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[50].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[50].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f50@_QIThunk@ATL@@UEAAJXZ


	.global ?f51@_QIThunk@ATL@@UEAAJXZ
	.proc	?f51@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f51@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=51*8,r14	// r14 = &m_pUnk->vtbl[51] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[51]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[51].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[51].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f51@_QIThunk@ATL@@UEAAJXZ


	.global ?f52@_QIThunk@ATL@@UEAAJXZ
	.proc	?f52@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f52@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=52*8,r14	// r14 = &m_pUnk->vtbl[52] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[52]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[52].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[52].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f52@_QIThunk@ATL@@UEAAJXZ


	.global ?f53@_QIThunk@ATL@@UEAAJXZ
	.proc	?f53@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f53@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=53*8,r14	// r14 = &m_pUnk->vtbl[53] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[53]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[53].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[53].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f53@_QIThunk@ATL@@UEAAJXZ


	.global ?f54@_QIThunk@ATL@@UEAAJXZ
	.proc	?f54@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f54@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=54*8,r14	// r14 = &m_pUnk->vtbl[54] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[54]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[54].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[54].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f54@_QIThunk@ATL@@UEAAJXZ


	.global ?f55@_QIThunk@ATL@@UEAAJXZ
	.proc	?f55@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f55@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=55*8,r14	// r14 = &m_pUnk->vtbl[55] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[55]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[55].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[55].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f55@_QIThunk@ATL@@UEAAJXZ


	.global ?f56@_QIThunk@ATL@@UEAAJXZ
	.proc	?f56@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f56@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=56*8,r14	// r14 = &m_pUnk->vtbl[56] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[56]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[56].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[56].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f56@_QIThunk@ATL@@UEAAJXZ


	.global ?f57@_QIThunk@ATL@@UEAAJXZ
	.proc	?f57@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f57@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=57*8,r14	// r14 = &m_pUnk->vtbl[57] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[57]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[57].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[57].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f57@_QIThunk@ATL@@UEAAJXZ


	.global ?f58@_QIThunk@ATL@@UEAAJXZ
	.proc	?f58@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f58@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=58*8,r14	// r14 = &m_pUnk->vtbl[58] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[58]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[58].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[58].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f58@_QIThunk@ATL@@UEAAJXZ


	.global ?f59@_QIThunk@ATL@@UEAAJXZ
	.proc	?f59@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f59@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=59*8,r14	// r14 = &m_pUnk->vtbl[59] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[59]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[59].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[59].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f59@_QIThunk@ATL@@UEAAJXZ


	.global ?f60@_QIThunk@ATL@@UEAAJXZ
	.proc	?f60@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f60@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=60*8,r14	// r14 = &m_pUnk->vtbl[60] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[60]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[60].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[60].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f60@_QIThunk@ATL@@UEAAJXZ


	.global ?f61@_QIThunk@ATL@@UEAAJXZ
	.proc	?f61@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f61@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=61*8,r14	// r14 = &m_pUnk->vtbl[61] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[61]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[61].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[61].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f61@_QIThunk@ATL@@UEAAJXZ


	.global ?f62@_QIThunk@ATL@@UEAAJXZ
	.proc	?f62@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f62@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=62*8,r14	// r14 = &m_pUnk->vtbl[62] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[62]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[62].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[62].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f62@_QIThunk@ATL@@UEAAJXZ


	.global ?f63@_QIThunk@ATL@@UEAAJXZ
	.proc	?f63@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f63@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=63*8,r14	// r14 = &m_pUnk->vtbl[63] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[63]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[63].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[63].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f63@_QIThunk@ATL@@UEAAJXZ


	.global ?f64@_QIThunk@ATL@@UEAAJXZ
	.proc	?f64@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f64@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=64*8,r14	// r14 = &m_pUnk->vtbl[64] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[64]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[64].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[64].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f64@_QIThunk@ATL@@UEAAJXZ


	.global ?f65@_QIThunk@ATL@@UEAAJXZ
	.proc	?f65@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f65@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=65*8,r14	// r14 = &m_pUnk->vtbl[65] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[65]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[65].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[65].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f65@_QIThunk@ATL@@UEAAJXZ


	.global ?f66@_QIThunk@ATL@@UEAAJXZ
	.proc	?f66@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f66@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=66*8,r14	// r14 = &m_pUnk->vtbl[66] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[66]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[66].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[66].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f66@_QIThunk@ATL@@UEAAJXZ


	.global ?f67@_QIThunk@ATL@@UEAAJXZ
	.proc	?f67@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f67@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=67*8,r14	// r14 = &m_pUnk->vtbl[67] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[67]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[67].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[67].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f67@_QIThunk@ATL@@UEAAJXZ


	.global ?f68@_QIThunk@ATL@@UEAAJXZ
	.proc	?f68@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f68@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=68*8,r14	// r14 = &m_pUnk->vtbl[68] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[68]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[68].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[68].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f68@_QIThunk@ATL@@UEAAJXZ


	.global ?f69@_QIThunk@ATL@@UEAAJXZ
	.proc	?f69@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f69@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=69*8,r14	// r14 = &m_pUnk->vtbl[69] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[69]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[69].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[69].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f69@_QIThunk@ATL@@UEAAJXZ


	.global ?f70@_QIThunk@ATL@@UEAAJXZ
	.proc	?f70@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f70@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=70*8,r14	// r14 = &m_pUnk->vtbl[70] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[70]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[70].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[70].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f70@_QIThunk@ATL@@UEAAJXZ


	.global ?f71@_QIThunk@ATL@@UEAAJXZ
	.proc	?f71@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f71@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=71*8,r14	// r14 = &m_pUnk->vtbl[71] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[71]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[71].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[71].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f71@_QIThunk@ATL@@UEAAJXZ


	.global ?f72@_QIThunk@ATL@@UEAAJXZ
	.proc	?f72@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f72@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=72*8,r14	// r14 = &m_pUnk->vtbl[72] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[72]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[72].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[72].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f72@_QIThunk@ATL@@UEAAJXZ


	.global ?f73@_QIThunk@ATL@@UEAAJXZ
	.proc	?f73@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f73@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=73*8,r14	// r14 = &m_pUnk->vtbl[73] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[73]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[73].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[73].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f73@_QIThunk@ATL@@UEAAJXZ


	.global ?f74@_QIThunk@ATL@@UEAAJXZ
	.proc	?f74@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f74@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=74*8,r14	// r14 = &m_pUnk->vtbl[74] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[74]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[74].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[74].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f74@_QIThunk@ATL@@UEAAJXZ


	.global ?f75@_QIThunk@ATL@@UEAAJXZ
	.proc	?f75@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f75@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=75*8,r14	// r14 = &m_pUnk->vtbl[75] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[75]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[75].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[75].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f75@_QIThunk@ATL@@UEAAJXZ


	.global ?f76@_QIThunk@ATL@@UEAAJXZ
	.proc	?f76@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f76@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=76*8,r14	// r14 = &m_pUnk->vtbl[76] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[76]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[76].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[76].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f76@_QIThunk@ATL@@UEAAJXZ


	.global ?f77@_QIThunk@ATL@@UEAAJXZ
	.proc	?f77@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f77@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=77*8,r14	// r14 = &m_pUnk->vtbl[77] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[77]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[77].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[77].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f77@_QIThunk@ATL@@UEAAJXZ


	.global ?f78@_QIThunk@ATL@@UEAAJXZ
	.proc	?f78@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f78@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=78*8,r14	// r14 = &m_pUnk->vtbl[78] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[78]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[78].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[78].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f78@_QIThunk@ATL@@UEAAJXZ


	.global ?f79@_QIThunk@ATL@@UEAAJXZ
	.proc	?f79@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f79@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=79*8,r14	// r14 = &m_pUnk->vtbl[79] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[79]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[79].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[79].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f79@_QIThunk@ATL@@UEAAJXZ


	.global ?f80@_QIThunk@ATL@@UEAAJXZ
	.proc	?f80@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f80@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=80*8,r14	// r14 = &m_pUnk->vtbl[80] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[80]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[80].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[80].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f80@_QIThunk@ATL@@UEAAJXZ


	.global ?f81@_QIThunk@ATL@@UEAAJXZ
	.proc	?f81@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f81@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=81*8,r14	// r14 = &m_pUnk->vtbl[81] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[81]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[81].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[81].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f81@_QIThunk@ATL@@UEAAJXZ


	.global ?f82@_QIThunk@ATL@@UEAAJXZ
	.proc	?f82@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f82@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=82*8,r14	// r14 = &m_pUnk->vtbl[82] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[82]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[82].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[82].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f82@_QIThunk@ATL@@UEAAJXZ


	.global ?f83@_QIThunk@ATL@@UEAAJXZ
	.proc	?f83@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f83@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=83*8,r14	// r14 = &m_pUnk->vtbl[83] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[83]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[83].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[83].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f83@_QIThunk@ATL@@UEAAJXZ


	.global ?f84@_QIThunk@ATL@@UEAAJXZ
	.proc	?f84@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f84@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=84*8,r14	// r14 = &m_pUnk->vtbl[84] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[84]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[84].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[84].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f84@_QIThunk@ATL@@UEAAJXZ


	.global ?f85@_QIThunk@ATL@@UEAAJXZ
	.proc	?f85@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f85@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=85*8,r14	// r14 = &m_pUnk->vtbl[85] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[85]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[85].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[85].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f85@_QIThunk@ATL@@UEAAJXZ


	.global ?f86@_QIThunk@ATL@@UEAAJXZ
	.proc	?f86@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f86@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=86*8,r14	// r14 = &m_pUnk->vtbl[86] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[86]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[86].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[86].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f86@_QIThunk@ATL@@UEAAJXZ


	.global ?f87@_QIThunk@ATL@@UEAAJXZ
	.proc	?f87@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f87@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=87*8,r14	// r14 = &m_pUnk->vtbl[87] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[87]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[87].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[87].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f87@_QIThunk@ATL@@UEAAJXZ


	.global ?f88@_QIThunk@ATL@@UEAAJXZ
	.proc	?f88@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f88@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=88*8,r14	// r14 = &m_pUnk->vtbl[88] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[88]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[88].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[88].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f88@_QIThunk@ATL@@UEAAJXZ


	.global ?f89@_QIThunk@ATL@@UEAAJXZ
	.proc	?f89@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f89@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=89*8,r14	// r14 = &m_pUnk->vtbl[89] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[89]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[89].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[89].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f89@_QIThunk@ATL@@UEAAJXZ


	.global ?f90@_QIThunk@ATL@@UEAAJXZ
	.proc	?f90@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f90@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=90*8,r14	// r14 = &m_pUnk->vtbl[90] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[90]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[90].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[90].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f90@_QIThunk@ATL@@UEAAJXZ


	.global ?f91@_QIThunk@ATL@@UEAAJXZ
	.proc	?f91@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f91@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=91*8,r14	// r14 = &m_pUnk->vtbl[91] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[91]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[91].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[91].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f91@_QIThunk@ATL@@UEAAJXZ


	.global ?f92@_QIThunk@ATL@@UEAAJXZ
	.proc	?f92@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f92@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=92*8,r14	// r14 = &m_pUnk->vtbl[92] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[92]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[92].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[92].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f92@_QIThunk@ATL@@UEAAJXZ


	.global ?f93@_QIThunk@ATL@@UEAAJXZ
	.proc	?f93@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f93@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=93*8,r14	// r14 = &m_pUnk->vtbl[93] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[93]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[93].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[93].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f93@_QIThunk@ATL@@UEAAJXZ


	.global ?f94@_QIThunk@ATL@@UEAAJXZ
	.proc	?f94@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f94@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=94*8,r14	// r14 = &m_pUnk->vtbl[94] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[94]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[94].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[94].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f94@_QIThunk@ATL@@UEAAJXZ


	.global ?f95@_QIThunk@ATL@@UEAAJXZ
	.proc	?f95@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f95@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=95*8,r14	// r14 = &m_pUnk->vtbl[95] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[95]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[95].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[95].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f95@_QIThunk@ATL@@UEAAJXZ


	.global ?f96@_QIThunk@ATL@@UEAAJXZ
	.proc	?f96@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f96@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=96*8,r14	// r14 = &m_pUnk->vtbl[96] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[96]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[96].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[96].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f96@_QIThunk@ATL@@UEAAJXZ


	.global ?f97@_QIThunk@ATL@@UEAAJXZ
	.proc	?f97@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f97@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=97*8,r14	// r14 = &m_pUnk->vtbl[97] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[97]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[97].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[97].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f97@_QIThunk@ATL@@UEAAJXZ


	.global ?f98@_QIThunk@ATL@@UEAAJXZ
	.proc	?f98@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f98@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=98*8,r14	// r14 = &m_pUnk->vtbl[98] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[98]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[98].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[98].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f98@_QIThunk@ATL@@UEAAJXZ


	.global ?f99@_QIThunk@ATL@@UEAAJXZ
	.proc	?f99@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f99@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=99*8,r14	// r14 = &m_pUnk->vtbl[99] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[99]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[99].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[99].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f99@_QIThunk@ATL@@UEAAJXZ


	.global ?f100@_QIThunk@ATL@@UEAAJXZ
	.proc	?f100@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f100@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=100*8,r14	// r14 = &m_pUnk->vtbl[100] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[100]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[100].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[100].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f100@_QIThunk@ATL@@UEAAJXZ


	.global ?f101@_QIThunk@ATL@@UEAAJXZ
	.proc	?f101@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f101@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=101*8,r14	// r14 = &m_pUnk->vtbl[101] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[101]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[101].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[101].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f101@_QIThunk@ATL@@UEAAJXZ


	.global ?f102@_QIThunk@ATL@@UEAAJXZ
	.proc	?f102@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f102@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=102*8,r14	// r14 = &m_pUnk->vtbl[102] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[102]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[102].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[102].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f102@_QIThunk@ATL@@UEAAJXZ


	.global ?f103@_QIThunk@ATL@@UEAAJXZ
	.proc	?f103@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f103@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=103*8,r14	// r14 = &m_pUnk->vtbl[103] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[103]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[103].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[103].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f103@_QIThunk@ATL@@UEAAJXZ


	.global ?f104@_QIThunk@ATL@@UEAAJXZ
	.proc	?f104@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f104@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=104*8,r14	// r14 = &m_pUnk->vtbl[104] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[104]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[104].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[104].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f104@_QIThunk@ATL@@UEAAJXZ


	.global ?f105@_QIThunk@ATL@@UEAAJXZ
	.proc	?f105@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f105@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=105*8,r14	// r14 = &m_pUnk->vtbl[105] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[105]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[105].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[105].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f105@_QIThunk@ATL@@UEAAJXZ


	.global ?f106@_QIThunk@ATL@@UEAAJXZ
	.proc	?f106@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f106@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=106*8,r14	// r14 = &m_pUnk->vtbl[106] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[106]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[106].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[106].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f106@_QIThunk@ATL@@UEAAJXZ


	.global ?f107@_QIThunk@ATL@@UEAAJXZ
	.proc	?f107@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f107@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=107*8,r14	// r14 = &m_pUnk->vtbl[107] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[107]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[107].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[107].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f107@_QIThunk@ATL@@UEAAJXZ


	.global ?f108@_QIThunk@ATL@@UEAAJXZ
	.proc	?f108@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f108@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=108*8,r14	// r14 = &m_pUnk->vtbl[108] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[108]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[108].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[108].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f108@_QIThunk@ATL@@UEAAJXZ


	.global ?f109@_QIThunk@ATL@@UEAAJXZ
	.proc	?f109@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f109@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=109*8,r14	// r14 = &m_pUnk->vtbl[109] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[109]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[109].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[109].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f109@_QIThunk@ATL@@UEAAJXZ


	.global ?f110@_QIThunk@ATL@@UEAAJXZ
	.proc	?f110@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f110@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=110*8,r14	// r14 = &m_pUnk->vtbl[110] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[110]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[110].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[110].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f110@_QIThunk@ATL@@UEAAJXZ


	.global ?f111@_QIThunk@ATL@@UEAAJXZ
	.proc	?f111@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f111@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=111*8,r14	// r14 = &m_pUnk->vtbl[111] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[111]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[111].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[111].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f111@_QIThunk@ATL@@UEAAJXZ


	.global ?f112@_QIThunk@ATL@@UEAAJXZ
	.proc	?f112@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f112@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=112*8,r14	// r14 = &m_pUnk->vtbl[112] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[112]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[112].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[112].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f112@_QIThunk@ATL@@UEAAJXZ


	.global ?f113@_QIThunk@ATL@@UEAAJXZ
	.proc	?f113@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f113@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=113*8,r14	// r14 = &m_pUnk->vtbl[113] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[113]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[113].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[113].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f113@_QIThunk@ATL@@UEAAJXZ


	.global ?f114@_QIThunk@ATL@@UEAAJXZ
	.proc	?f114@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f114@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=114*8,r14	// r14 = &m_pUnk->vtbl[114] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[114]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[114].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[114].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f114@_QIThunk@ATL@@UEAAJXZ


	.global ?f115@_QIThunk@ATL@@UEAAJXZ
	.proc	?f115@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f115@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=115*8,r14	// r14 = &m_pUnk->vtbl[115] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[115]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[115].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[115].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f115@_QIThunk@ATL@@UEAAJXZ


	.global ?f116@_QIThunk@ATL@@UEAAJXZ
	.proc	?f116@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f116@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=116*8,r14	// r14 = &m_pUnk->vtbl[116] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[116]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[116].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[116].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f116@_QIThunk@ATL@@UEAAJXZ


	.global ?f117@_QIThunk@ATL@@UEAAJXZ
	.proc	?f117@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f117@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=117*8,r14	// r14 = &m_pUnk->vtbl[117] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[117]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[117].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[117].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f117@_QIThunk@ATL@@UEAAJXZ


	.global ?f118@_QIThunk@ATL@@UEAAJXZ
	.proc	?f118@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f118@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=118*8,r14	// r14 = &m_pUnk->vtbl[118] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[118]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[118].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[118].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f118@_QIThunk@ATL@@UEAAJXZ


	.global ?f119@_QIThunk@ATL@@UEAAJXZ
	.proc	?f119@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f119@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=119*8,r14	// r14 = &m_pUnk->vtbl[119] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[119]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[119].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[119].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f119@_QIThunk@ATL@@UEAAJXZ


	.global ?f120@_QIThunk@ATL@@UEAAJXZ
	.proc	?f120@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f120@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=120*8,r14	// r14 = &m_pUnk->vtbl[120] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[120]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[120].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[120].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f120@_QIThunk@ATL@@UEAAJXZ


	.global ?f121@_QIThunk@ATL@@UEAAJXZ
	.proc	?f121@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f121@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=121*8,r14	// r14 = &m_pUnk->vtbl[121] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[121]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[121].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[121].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f121@_QIThunk@ATL@@UEAAJXZ


	.global ?f122@_QIThunk@ATL@@UEAAJXZ
	.proc	?f122@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f122@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=122*8,r14	// r14 = &m_pUnk->vtbl[122] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[122]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[122].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[122].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f122@_QIThunk@ATL@@UEAAJXZ


	.global ?f123@_QIThunk@ATL@@UEAAJXZ
	.proc	?f123@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f123@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=123*8,r14	// r14 = &m_pUnk->vtbl[123] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[123]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[123].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[123].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f123@_QIThunk@ATL@@UEAAJXZ


	.global ?f124@_QIThunk@ATL@@UEAAJXZ
	.proc	?f124@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f124@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=124*8,r14	// r14 = &m_pUnk->vtbl[124] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[124]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[124].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[124].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f124@_QIThunk@ATL@@UEAAJXZ


	.global ?f125@_QIThunk@ATL@@UEAAJXZ
	.proc	?f125@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f125@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=125*8,r14	// r14 = &m_pUnk->vtbl[125] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[125]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[125].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[125].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f125@_QIThunk@ATL@@UEAAJXZ


	.global ?f126@_QIThunk@ATL@@UEAAJXZ
	.proc	?f126@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f126@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=126*8,r14	// r14 = &m_pUnk->vtbl[126] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[126]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[126].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[126].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f126@_QIThunk@ATL@@UEAAJXZ


	.global ?f127@_QIThunk@ATL@@UEAAJXZ
	.proc	?f127@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f127@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=127*8,r14	// r14 = &m_pUnk->vtbl[127] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[127]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[127].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[127].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f127@_QIThunk@ATL@@UEAAJXZ


	.global ?f128@_QIThunk@ATL@@UEAAJXZ
	.proc	?f128@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f128@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=128*8,r14	// r14 = &m_pUnk->vtbl[128] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[128]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[128].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[128].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f128@_QIThunk@ATL@@UEAAJXZ


	.global ?f129@_QIThunk@ATL@@UEAAJXZ
	.proc	?f129@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f129@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=129*8,r14	// r14 = &m_pUnk->vtbl[129] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[129]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[129].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[129].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f129@_QIThunk@ATL@@UEAAJXZ


	.global ?f130@_QIThunk@ATL@@UEAAJXZ
	.proc	?f130@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f130@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=130*8,r14	// r14 = &m_pUnk->vtbl[130] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[130]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[130].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[130].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f130@_QIThunk@ATL@@UEAAJXZ


	.global ?f131@_QIThunk@ATL@@UEAAJXZ
	.proc	?f131@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f131@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=131*8,r14	// r14 = &m_pUnk->vtbl[131] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[131]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[131].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[131].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f131@_QIThunk@ATL@@UEAAJXZ


	.global ?f132@_QIThunk@ATL@@UEAAJXZ
	.proc	?f132@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f132@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=132*8,r14	// r14 = &m_pUnk->vtbl[132] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[132]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[132].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[132].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f132@_QIThunk@ATL@@UEAAJXZ


	.global ?f133@_QIThunk@ATL@@UEAAJXZ
	.proc	?f133@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f133@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=133*8,r14	// r14 = &m_pUnk->vtbl[133] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[133]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[133].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[133].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f133@_QIThunk@ATL@@UEAAJXZ


	.global ?f134@_QIThunk@ATL@@UEAAJXZ
	.proc	?f134@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f134@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=134*8,r14	// r14 = &m_pUnk->vtbl[134] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[134]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[134].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[134].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f134@_QIThunk@ATL@@UEAAJXZ


	.global ?f135@_QIThunk@ATL@@UEAAJXZ
	.proc	?f135@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f135@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=135*8,r14	// r14 = &m_pUnk->vtbl[135] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[135]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[135].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[135].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f135@_QIThunk@ATL@@UEAAJXZ


	.global ?f136@_QIThunk@ATL@@UEAAJXZ
	.proc	?f136@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f136@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=136*8,r14	// r14 = &m_pUnk->vtbl[136] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[136]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[136].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[136].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f136@_QIThunk@ATL@@UEAAJXZ


	.global ?f137@_QIThunk@ATL@@UEAAJXZ
	.proc	?f137@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f137@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=137*8,r14	// r14 = &m_pUnk->vtbl[137] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[137]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[137].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[137].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f137@_QIThunk@ATL@@UEAAJXZ


	.global ?f138@_QIThunk@ATL@@UEAAJXZ
	.proc	?f138@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f138@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=138*8,r14	// r14 = &m_pUnk->vtbl[138] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[138]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[138].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[138].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f138@_QIThunk@ATL@@UEAAJXZ


	.global ?f139@_QIThunk@ATL@@UEAAJXZ
	.proc	?f139@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f139@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=139*8,r14	// r14 = &m_pUnk->vtbl[139] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[139]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[139].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[139].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f139@_QIThunk@ATL@@UEAAJXZ


	.global ?f140@_QIThunk@ATL@@UEAAJXZ
	.proc	?f140@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f140@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=140*8,r14	// r14 = &m_pUnk->vtbl[140] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[140]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[140].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[140].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f140@_QIThunk@ATL@@UEAAJXZ


	.global ?f141@_QIThunk@ATL@@UEAAJXZ
	.proc	?f141@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f141@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=141*8,r14	// r14 = &m_pUnk->vtbl[141] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[141]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[141].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[141].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f141@_QIThunk@ATL@@UEAAJXZ


	.global ?f142@_QIThunk@ATL@@UEAAJXZ
	.proc	?f142@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f142@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=142*8,r14	// r14 = &m_pUnk->vtbl[142] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[142]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[142].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[142].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f142@_QIThunk@ATL@@UEAAJXZ


	.global ?f143@_QIThunk@ATL@@UEAAJXZ
	.proc	?f143@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f143@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=143*8,r14	// r14 = &m_pUnk->vtbl[143] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[143]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[143].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[143].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f143@_QIThunk@ATL@@UEAAJXZ


	.global ?f144@_QIThunk@ATL@@UEAAJXZ
	.proc	?f144@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f144@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=144*8,r14	// r14 = &m_pUnk->vtbl[144] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[144]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[144].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[144].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f144@_QIThunk@ATL@@UEAAJXZ


	.global ?f145@_QIThunk@ATL@@UEAAJXZ
	.proc	?f145@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f145@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=145*8,r14	// r14 = &m_pUnk->vtbl[145] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[145]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[145].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[145].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f145@_QIThunk@ATL@@UEAAJXZ


	.global ?f146@_QIThunk@ATL@@UEAAJXZ
	.proc	?f146@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f146@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=146*8,r14	// r14 = &m_pUnk->vtbl[146] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[146]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[146].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[146].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f146@_QIThunk@ATL@@UEAAJXZ


	.global ?f147@_QIThunk@ATL@@UEAAJXZ
	.proc	?f147@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f147@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=147*8,r14	// r14 = &m_pUnk->vtbl[147] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[147]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[147].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[147].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f147@_QIThunk@ATL@@UEAAJXZ


	.global ?f148@_QIThunk@ATL@@UEAAJXZ
	.proc	?f148@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f148@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=148*8,r14	// r14 = &m_pUnk->vtbl[148] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[148]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[148].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[148].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f148@_QIThunk@ATL@@UEAAJXZ


	.global ?f149@_QIThunk@ATL@@UEAAJXZ
	.proc	?f149@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f149@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=149*8,r14	// r14 = &m_pUnk->vtbl[149] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[149]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[149].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[149].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f149@_QIThunk@ATL@@UEAAJXZ


	.global ?f150@_QIThunk@ATL@@UEAAJXZ
	.proc	?f150@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f150@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=150*8,r14	// r14 = &m_pUnk->vtbl[150] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[150]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[150].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[150].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f150@_QIThunk@ATL@@UEAAJXZ


	.global ?f151@_QIThunk@ATL@@UEAAJXZ
	.proc	?f151@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f151@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=151*8,r14	// r14 = &m_pUnk->vtbl[151] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[151]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[151].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[151].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f151@_QIThunk@ATL@@UEAAJXZ


	.global ?f152@_QIThunk@ATL@@UEAAJXZ
	.proc	?f152@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f152@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=152*8,r14	// r14 = &m_pUnk->vtbl[152] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[152]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[152].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[152].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f152@_QIThunk@ATL@@UEAAJXZ


	.global ?f153@_QIThunk@ATL@@UEAAJXZ
	.proc	?f153@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f153@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=153*8,r14	// r14 = &m_pUnk->vtbl[153] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[153]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[153].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[153].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f153@_QIThunk@ATL@@UEAAJXZ


	.global ?f154@_QIThunk@ATL@@UEAAJXZ
	.proc	?f154@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f154@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=154*8,r14	// r14 = &m_pUnk->vtbl[154] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[154]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[154].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[154].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f154@_QIThunk@ATL@@UEAAJXZ


	.global ?f155@_QIThunk@ATL@@UEAAJXZ
	.proc	?f155@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f155@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=155*8,r14	// r14 = &m_pUnk->vtbl[155] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[155]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[155].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[155].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f155@_QIThunk@ATL@@UEAAJXZ


	.global ?f156@_QIThunk@ATL@@UEAAJXZ
	.proc	?f156@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f156@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=156*8,r14	// r14 = &m_pUnk->vtbl[156] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[156]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[156].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[156].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f156@_QIThunk@ATL@@UEAAJXZ


	.global ?f157@_QIThunk@ATL@@UEAAJXZ
	.proc	?f157@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f157@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=157*8,r14	// r14 = &m_pUnk->vtbl[157] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[157]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[157].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[157].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f157@_QIThunk@ATL@@UEAAJXZ


	.global ?f158@_QIThunk@ATL@@UEAAJXZ
	.proc	?f158@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f158@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=158*8,r14	// r14 = &m_pUnk->vtbl[158] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[158]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[158].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[158].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f158@_QIThunk@ATL@@UEAAJXZ


	.global ?f159@_QIThunk@ATL@@UEAAJXZ
	.proc	?f159@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f159@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=159*8,r14	// r14 = &m_pUnk->vtbl[159] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[159]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[159].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[159].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f159@_QIThunk@ATL@@UEAAJXZ


	.global ?f160@_QIThunk@ATL@@UEAAJXZ
	.proc	?f160@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f160@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=160*8,r14	// r14 = &m_pUnk->vtbl[160] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[160]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[160].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[160].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f160@_QIThunk@ATL@@UEAAJXZ


	.global ?f161@_QIThunk@ATL@@UEAAJXZ
	.proc	?f161@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f161@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=161*8,r14	// r14 = &m_pUnk->vtbl[161] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[161]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[161].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[161].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f161@_QIThunk@ATL@@UEAAJXZ


	.global ?f162@_QIThunk@ATL@@UEAAJXZ
	.proc	?f162@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f162@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=162*8,r14	// r14 = &m_pUnk->vtbl[162] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[162]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[162].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[162].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f162@_QIThunk@ATL@@UEAAJXZ


	.global ?f163@_QIThunk@ATL@@UEAAJXZ
	.proc	?f163@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f163@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=163*8,r14	// r14 = &m_pUnk->vtbl[163] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[163]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[163].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[163].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f163@_QIThunk@ATL@@UEAAJXZ


	.global ?f164@_QIThunk@ATL@@UEAAJXZ
	.proc	?f164@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f164@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=164*8,r14	// r14 = &m_pUnk->vtbl[164] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[164]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[164].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[164].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f164@_QIThunk@ATL@@UEAAJXZ


	.global ?f165@_QIThunk@ATL@@UEAAJXZ
	.proc	?f165@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f165@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=165*8,r14	// r14 = &m_pUnk->vtbl[165] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[165]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[165].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[165].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f165@_QIThunk@ATL@@UEAAJXZ


	.global ?f166@_QIThunk@ATL@@UEAAJXZ
	.proc	?f166@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f166@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=166*8,r14	// r14 = &m_pUnk->vtbl[166] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[166]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[166].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[166].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f166@_QIThunk@ATL@@UEAAJXZ


	.global ?f167@_QIThunk@ATL@@UEAAJXZ
	.proc	?f167@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f167@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=167*8,r14	// r14 = &m_pUnk->vtbl[167] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[167]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[167].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[167].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f167@_QIThunk@ATL@@UEAAJXZ


	.global ?f168@_QIThunk@ATL@@UEAAJXZ
	.proc	?f168@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f168@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=168*8,r14	// r14 = &m_pUnk->vtbl[168] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[168]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[168].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[168].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f168@_QIThunk@ATL@@UEAAJXZ


	.global ?f169@_QIThunk@ATL@@UEAAJXZ
	.proc	?f169@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f169@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=169*8,r14	// r14 = &m_pUnk->vtbl[169] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[169]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[169].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[169].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f169@_QIThunk@ATL@@UEAAJXZ


	.global ?f170@_QIThunk@ATL@@UEAAJXZ
	.proc	?f170@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f170@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=170*8,r14	// r14 = &m_pUnk->vtbl[170] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[170]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[170].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[170].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f170@_QIThunk@ATL@@UEAAJXZ


	.global ?f171@_QIThunk@ATL@@UEAAJXZ
	.proc	?f171@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f171@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=171*8,r14	// r14 = &m_pUnk->vtbl[171] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[171]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[171].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[171].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f171@_QIThunk@ATL@@UEAAJXZ


	.global ?f172@_QIThunk@ATL@@UEAAJXZ
	.proc	?f172@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f172@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=172*8,r14	// r14 = &m_pUnk->vtbl[172] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[172]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[172].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[172].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f172@_QIThunk@ATL@@UEAAJXZ


	.global ?f173@_QIThunk@ATL@@UEAAJXZ
	.proc	?f173@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f173@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=173*8,r14	// r14 = &m_pUnk->vtbl[173] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[173]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[173].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[173].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f173@_QIThunk@ATL@@UEAAJXZ


	.global ?f174@_QIThunk@ATL@@UEAAJXZ
	.proc	?f174@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f174@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=174*8,r14	// r14 = &m_pUnk->vtbl[174] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[174]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[174].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[174].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f174@_QIThunk@ATL@@UEAAJXZ


	.global ?f175@_QIThunk@ATL@@UEAAJXZ
	.proc	?f175@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f175@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=175*8,r14	// r14 = &m_pUnk->vtbl[175] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[175]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[175].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[175].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f175@_QIThunk@ATL@@UEAAJXZ


	.global ?f176@_QIThunk@ATL@@UEAAJXZ
	.proc	?f176@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f176@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=176*8,r14	// r14 = &m_pUnk->vtbl[176] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[176]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[176].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[176].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f176@_QIThunk@ATL@@UEAAJXZ


	.global ?f177@_QIThunk@ATL@@UEAAJXZ
	.proc	?f177@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f177@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=177*8,r14	// r14 = &m_pUnk->vtbl[177] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[177]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[177].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[177].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f177@_QIThunk@ATL@@UEAAJXZ


	.global ?f178@_QIThunk@ATL@@UEAAJXZ
	.proc	?f178@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f178@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=178*8,r14	// r14 = &m_pUnk->vtbl[178] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[178]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[178].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[178].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f178@_QIThunk@ATL@@UEAAJXZ


	.global ?f179@_QIThunk@ATL@@UEAAJXZ
	.proc	?f179@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f179@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=179*8,r14	// r14 = &m_pUnk->vtbl[179] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[179]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[179].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[179].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f179@_QIThunk@ATL@@UEAAJXZ


	.global ?f180@_QIThunk@ATL@@UEAAJXZ
	.proc	?f180@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f180@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=180*8,r14	// r14 = &m_pUnk->vtbl[180] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[180]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[180].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[180].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f180@_QIThunk@ATL@@UEAAJXZ


	.global ?f181@_QIThunk@ATL@@UEAAJXZ
	.proc	?f181@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f181@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=181*8,r14	// r14 = &m_pUnk->vtbl[181] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[181]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[181].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[181].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f181@_QIThunk@ATL@@UEAAJXZ


	.global ?f182@_QIThunk@ATL@@UEAAJXZ
	.proc	?f182@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f182@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=182*8,r14	// r14 = &m_pUnk->vtbl[182] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[182]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[182].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[182].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f182@_QIThunk@ATL@@UEAAJXZ


	.global ?f183@_QIThunk@ATL@@UEAAJXZ
	.proc	?f183@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f183@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=183*8,r14	// r14 = &m_pUnk->vtbl[183] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[183]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[183].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[183].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f183@_QIThunk@ATL@@UEAAJXZ


	.global ?f184@_QIThunk@ATL@@UEAAJXZ
	.proc	?f184@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f184@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=184*8,r14	// r14 = &m_pUnk->vtbl[184] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[184]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[184].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[184].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f184@_QIThunk@ATL@@UEAAJXZ


	.global ?f185@_QIThunk@ATL@@UEAAJXZ
	.proc	?f185@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f185@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=185*8,r14	// r14 = &m_pUnk->vtbl[185] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[185]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[185].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[185].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f185@_QIThunk@ATL@@UEAAJXZ


	.global ?f186@_QIThunk@ATL@@UEAAJXZ
	.proc	?f186@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f186@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=186*8,r14	// r14 = &m_pUnk->vtbl[186] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[186]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[186].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[186].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f186@_QIThunk@ATL@@UEAAJXZ


	.global ?f187@_QIThunk@ATL@@UEAAJXZ
	.proc	?f187@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f187@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=187*8,r14	// r14 = &m_pUnk->vtbl[187] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[187]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[187].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[187].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f187@_QIThunk@ATL@@UEAAJXZ


	.global ?f188@_QIThunk@ATL@@UEAAJXZ
	.proc	?f188@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f188@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=188*8,r14	// r14 = &m_pUnk->vtbl[188] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[188]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[188].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[188].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f188@_QIThunk@ATL@@UEAAJXZ


	.global ?f189@_QIThunk@ATL@@UEAAJXZ
	.proc	?f189@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f189@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=189*8,r14	// r14 = &m_pUnk->vtbl[189] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[189]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[189].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[189].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f189@_QIThunk@ATL@@UEAAJXZ


	.global ?f190@_QIThunk@ATL@@UEAAJXZ
	.proc	?f190@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f190@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=190*8,r14	// r14 = &m_pUnk->vtbl[190] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[190]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[190].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[190].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f190@_QIThunk@ATL@@UEAAJXZ


	.global ?f191@_QIThunk@ATL@@UEAAJXZ
	.proc	?f191@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f191@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=191*8,r14	// r14 = &m_pUnk->vtbl[191] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[191]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[191].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[191].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f191@_QIThunk@ATL@@UEAAJXZ


	.global ?f192@_QIThunk@ATL@@UEAAJXZ
	.proc	?f192@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f192@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=192*8,r14	// r14 = &m_pUnk->vtbl[192] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[192]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[192].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[192].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f192@_QIThunk@ATL@@UEAAJXZ


	.global ?f193@_QIThunk@ATL@@UEAAJXZ
	.proc	?f193@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f193@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=193*8,r14	// r14 = &m_pUnk->vtbl[193] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[193]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[193].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[193].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f193@_QIThunk@ATL@@UEAAJXZ


	.global ?f194@_QIThunk@ATL@@UEAAJXZ
	.proc	?f194@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f194@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=194*8,r14	// r14 = &m_pUnk->vtbl[194] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[194]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[194].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[194].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f194@_QIThunk@ATL@@UEAAJXZ


	.global ?f195@_QIThunk@ATL@@UEAAJXZ
	.proc	?f195@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f195@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=195*8,r14	// r14 = &m_pUnk->vtbl[195] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[195]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[195].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[195].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f195@_QIThunk@ATL@@UEAAJXZ


	.global ?f196@_QIThunk@ATL@@UEAAJXZ
	.proc	?f196@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f196@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=196*8,r14	// r14 = &m_pUnk->vtbl[196] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[196]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[196].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[196].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f196@_QIThunk@ATL@@UEAAJXZ


	.global ?f197@_QIThunk@ATL@@UEAAJXZ
	.proc	?f197@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f197@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=197*8,r14	// r14 = &m_pUnk->vtbl[197] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[197]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[197].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[197].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f197@_QIThunk@ATL@@UEAAJXZ


	.global ?f198@_QIThunk@ATL@@UEAAJXZ
	.proc	?f198@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f198@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=198*8,r14	// r14 = &m_pUnk->vtbl[198] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[198]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[198].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[198].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f198@_QIThunk@ATL@@UEAAJXZ


	.global ?f199@_QIThunk@ATL@@UEAAJXZ
	.proc	?f199@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f199@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=199*8,r14	// r14 = &m_pUnk->vtbl[199] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[199]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[199].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[199].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f199@_QIThunk@ATL@@UEAAJXZ


	.global ?f200@_QIThunk@ATL@@UEAAJXZ
	.proc	?f200@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f200@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=200*8,r14	// r14 = &m_pUnk->vtbl[200] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[200]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[200].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[200].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f200@_QIThunk@ATL@@UEAAJXZ


	.global ?f201@_QIThunk@ATL@@UEAAJXZ
	.proc	?f201@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f201@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=201*8,r14	// r14 = &m_pUnk->vtbl[201] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[201]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[201].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[201].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f201@_QIThunk@ATL@@UEAAJXZ


	.global ?f202@_QIThunk@ATL@@UEAAJXZ
	.proc	?f202@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f202@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=202*8,r14	// r14 = &m_pUnk->vtbl[202] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[202]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[202].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[202].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f202@_QIThunk@ATL@@UEAAJXZ


	.global ?f203@_QIThunk@ATL@@UEAAJXZ
	.proc	?f203@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f203@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=203*8,r14	// r14 = &m_pUnk->vtbl[203] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[203]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[203].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[203].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f203@_QIThunk@ATL@@UEAAJXZ


	.global ?f204@_QIThunk@ATL@@UEAAJXZ
	.proc	?f204@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f204@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=204*8,r14	// r14 = &m_pUnk->vtbl[204] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[204]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[204].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[204].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f204@_QIThunk@ATL@@UEAAJXZ


	.global ?f205@_QIThunk@ATL@@UEAAJXZ
	.proc	?f205@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f205@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=205*8,r14	// r14 = &m_pUnk->vtbl[205] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[205]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[205].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[205].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f205@_QIThunk@ATL@@UEAAJXZ


	.global ?f206@_QIThunk@ATL@@UEAAJXZ
	.proc	?f206@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f206@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=206*8,r14	// r14 = &m_pUnk->vtbl[206] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[206]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[206].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[206].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f206@_QIThunk@ATL@@UEAAJXZ


	.global ?f207@_QIThunk@ATL@@UEAAJXZ
	.proc	?f207@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f207@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=207*8,r14	// r14 = &m_pUnk->vtbl[207] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[207]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[207].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[207].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f207@_QIThunk@ATL@@UEAAJXZ


	.global ?f208@_QIThunk@ATL@@UEAAJXZ
	.proc	?f208@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f208@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=208*8,r14	// r14 = &m_pUnk->vtbl[208] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[208]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[208].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[208].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f208@_QIThunk@ATL@@UEAAJXZ


	.global ?f209@_QIThunk@ATL@@UEAAJXZ
	.proc	?f209@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f209@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=209*8,r14	// r14 = &m_pUnk->vtbl[209] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[209]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[209].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[209].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f209@_QIThunk@ATL@@UEAAJXZ


	.global ?f210@_QIThunk@ATL@@UEAAJXZ
	.proc	?f210@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f210@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=210*8,r14	// r14 = &m_pUnk->vtbl[210] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[210]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[210].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[210].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f210@_QIThunk@ATL@@UEAAJXZ


	.global ?f211@_QIThunk@ATL@@UEAAJXZ
	.proc	?f211@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f211@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=211*8,r14	// r14 = &m_pUnk->vtbl[211] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[211]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[211].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[211].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f211@_QIThunk@ATL@@UEAAJXZ


	.global ?f212@_QIThunk@ATL@@UEAAJXZ
	.proc	?f212@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f212@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=212*8,r14	// r14 = &m_pUnk->vtbl[212] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[212]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[212].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[212].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f212@_QIThunk@ATL@@UEAAJXZ


	.global ?f213@_QIThunk@ATL@@UEAAJXZ
	.proc	?f213@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f213@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=213*8,r14	// r14 = &m_pUnk->vtbl[213] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[213]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[213].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[213].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f213@_QIThunk@ATL@@UEAAJXZ


	.global ?f214@_QIThunk@ATL@@UEAAJXZ
	.proc	?f214@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f214@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=214*8,r14	// r14 = &m_pUnk->vtbl[214] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[214]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[214].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[214].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f214@_QIThunk@ATL@@UEAAJXZ


	.global ?f215@_QIThunk@ATL@@UEAAJXZ
	.proc	?f215@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f215@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=215*8,r14	// r14 = &m_pUnk->vtbl[215] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[215]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[215].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[215].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f215@_QIThunk@ATL@@UEAAJXZ


	.global ?f216@_QIThunk@ATL@@UEAAJXZ
	.proc	?f216@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f216@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=216*8,r14	// r14 = &m_pUnk->vtbl[216] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[216]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[216].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[216].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f216@_QIThunk@ATL@@UEAAJXZ


	.global ?f217@_QIThunk@ATL@@UEAAJXZ
	.proc	?f217@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f217@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=217*8,r14	// r14 = &m_pUnk->vtbl[217] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[217]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[217].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[217].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f217@_QIThunk@ATL@@UEAAJXZ


	.global ?f218@_QIThunk@ATL@@UEAAJXZ
	.proc	?f218@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f218@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=218*8,r14	// r14 = &m_pUnk->vtbl[218] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[218]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[218].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[218].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f218@_QIThunk@ATL@@UEAAJXZ


	.global ?f219@_QIThunk@ATL@@UEAAJXZ
	.proc	?f219@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f219@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=219*8,r14	// r14 = &m_pUnk->vtbl[219] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[219]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[219].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[219].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f219@_QIThunk@ATL@@UEAAJXZ


	.global ?f220@_QIThunk@ATL@@UEAAJXZ
	.proc	?f220@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f220@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=220*8,r14	// r14 = &m_pUnk->vtbl[220] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[220]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[220].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[220].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f220@_QIThunk@ATL@@UEAAJXZ


	.global ?f221@_QIThunk@ATL@@UEAAJXZ
	.proc	?f221@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f221@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=221*8,r14	// r14 = &m_pUnk->vtbl[221] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[221]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[221].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[221].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f221@_QIThunk@ATL@@UEAAJXZ


	.global ?f222@_QIThunk@ATL@@UEAAJXZ
	.proc	?f222@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f222@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=222*8,r14	// r14 = &m_pUnk->vtbl[222] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[222]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[222].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[222].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f222@_QIThunk@ATL@@UEAAJXZ


	.global ?f223@_QIThunk@ATL@@UEAAJXZ
	.proc	?f223@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f223@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=223*8,r14	// r14 = &m_pUnk->vtbl[223] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[223]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[223].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[223].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f223@_QIThunk@ATL@@UEAAJXZ


	.global ?f224@_QIThunk@ATL@@UEAAJXZ
	.proc	?f224@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f224@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=224*8,r14	// r14 = &m_pUnk->vtbl[224] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[224]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[224].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[224].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f224@_QIThunk@ATL@@UEAAJXZ


	.global ?f225@_QIThunk@ATL@@UEAAJXZ
	.proc	?f225@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f225@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=225*8,r14	// r14 = &m_pUnk->vtbl[225] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[225]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[225].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[225].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f225@_QIThunk@ATL@@UEAAJXZ


	.global ?f226@_QIThunk@ATL@@UEAAJXZ
	.proc	?f226@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f226@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=226*8,r14	// r14 = &m_pUnk->vtbl[226] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[226]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[226].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[226].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f226@_QIThunk@ATL@@UEAAJXZ


	.global ?f227@_QIThunk@ATL@@UEAAJXZ
	.proc	?f227@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f227@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=227*8,r14	// r14 = &m_pUnk->vtbl[227] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[227]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[227].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[227].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f227@_QIThunk@ATL@@UEAAJXZ


	.global ?f228@_QIThunk@ATL@@UEAAJXZ
	.proc	?f228@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f228@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=228*8,r14	// r14 = &m_pUnk->vtbl[228] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[228]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[228].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[228].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f228@_QIThunk@ATL@@UEAAJXZ


	.global ?f229@_QIThunk@ATL@@UEAAJXZ
	.proc	?f229@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f229@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=229*8,r14	// r14 = &m_pUnk->vtbl[229] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[229]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[229].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[229].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f229@_QIThunk@ATL@@UEAAJXZ


	.global ?f230@_QIThunk@ATL@@UEAAJXZ
	.proc	?f230@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f230@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=230*8,r14	// r14 = &m_pUnk->vtbl[230] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[230]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[230].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[230].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f230@_QIThunk@ATL@@UEAAJXZ


	.global ?f231@_QIThunk@ATL@@UEAAJXZ
	.proc	?f231@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f231@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=231*8,r14	// r14 = &m_pUnk->vtbl[231] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[231]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[231].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[231].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f231@_QIThunk@ATL@@UEAAJXZ


	.global ?f232@_QIThunk@ATL@@UEAAJXZ
	.proc	?f232@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f232@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=232*8,r14	// r14 = &m_pUnk->vtbl[232] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[232]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[232].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[232].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f232@_QIThunk@ATL@@UEAAJXZ


	.global ?f233@_QIThunk@ATL@@UEAAJXZ
	.proc	?f233@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f233@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=233*8,r14	// r14 = &m_pUnk->vtbl[233] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[233]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[233].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[233].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f233@_QIThunk@ATL@@UEAAJXZ


	.global ?f234@_QIThunk@ATL@@UEAAJXZ
	.proc	?f234@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f234@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=234*8,r14	// r14 = &m_pUnk->vtbl[234] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[234]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[234].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[234].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f234@_QIThunk@ATL@@UEAAJXZ


	.global ?f235@_QIThunk@ATL@@UEAAJXZ
	.proc	?f235@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f235@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=235*8,r14	// r14 = &m_pUnk->vtbl[235] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[235]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[235].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[235].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f235@_QIThunk@ATL@@UEAAJXZ


	.global ?f236@_QIThunk@ATL@@UEAAJXZ
	.proc	?f236@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f236@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=236*8,r14	// r14 = &m_pUnk->vtbl[236] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[236]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[236].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[236].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f236@_QIThunk@ATL@@UEAAJXZ


	.global ?f237@_QIThunk@ATL@@UEAAJXZ
	.proc	?f237@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f237@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=237*8,r14	// r14 = &m_pUnk->vtbl[237] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[237]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[237].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[237].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f237@_QIThunk@ATL@@UEAAJXZ


	.global ?f238@_QIThunk@ATL@@UEAAJXZ
	.proc	?f238@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f238@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=238*8,r14	// r14 = &m_pUnk->vtbl[238] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[238]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[238].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[238].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f238@_QIThunk@ATL@@UEAAJXZ


	.global ?f239@_QIThunk@ATL@@UEAAJXZ
	.proc	?f239@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f239@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=239*8,r14	// r14 = &m_pUnk->vtbl[239] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[239]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[239].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[239].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f239@_QIThunk@ATL@@UEAAJXZ


	.global ?f240@_QIThunk@ATL@@UEAAJXZ
	.proc	?f240@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f240@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=240*8,r14	// r14 = &m_pUnk->vtbl[240] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[240]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[240].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[240].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f240@_QIThunk@ATL@@UEAAJXZ


	.global ?f241@_QIThunk@ATL@@UEAAJXZ
	.proc	?f241@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f241@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=241*8,r14	// r14 = &m_pUnk->vtbl[241] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[241]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[241].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[241].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f241@_QIThunk@ATL@@UEAAJXZ


	.global ?f242@_QIThunk@ATL@@UEAAJXZ
	.proc	?f242@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f242@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=242*8,r14	// r14 = &m_pUnk->vtbl[242] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[242]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[242].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[242].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f242@_QIThunk@ATL@@UEAAJXZ


	.global ?f243@_QIThunk@ATL@@UEAAJXZ
	.proc	?f243@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f243@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=243*8,r14	// r14 = &m_pUnk->vtbl[243] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[243]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[243].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[243].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f243@_QIThunk@ATL@@UEAAJXZ


	.global ?f244@_QIThunk@ATL@@UEAAJXZ
	.proc	?f244@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f244@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=244*8,r14	// r14 = &m_pUnk->vtbl[244] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[244]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[244].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[244].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f244@_QIThunk@ATL@@UEAAJXZ


	.global ?f245@_QIThunk@ATL@@UEAAJXZ
	.proc	?f245@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f245@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=245*8,r14	// r14 = &m_pUnk->vtbl[245] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[245]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[245].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[245].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f245@_QIThunk@ATL@@UEAAJXZ


	.global ?f246@_QIThunk@ATL@@UEAAJXZ
	.proc	?f246@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f246@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=246*8,r14	// r14 = &m_pUnk->vtbl[246] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[246]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[246].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[246].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f246@_QIThunk@ATL@@UEAAJXZ


	.global ?f247@_QIThunk@ATL@@UEAAJXZ
	.proc	?f247@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f247@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=247*8,r14	// r14 = &m_pUnk->vtbl[247] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[247]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[247].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[247].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f247@_QIThunk@ATL@@UEAAJXZ


	.global ?f248@_QIThunk@ATL@@UEAAJXZ
	.proc	?f248@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f248@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=248*8,r14	// r14 = &m_pUnk->vtbl[248] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[248]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[248].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[248].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f248@_QIThunk@ATL@@UEAAJXZ


	.global ?f249@_QIThunk@ATL@@UEAAJXZ
	.proc	?f249@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f249@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=249*8,r14	// r14 = &m_pUnk->vtbl[249] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[249]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[249].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[249].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f249@_QIThunk@ATL@@UEAAJXZ


	.global ?f250@_QIThunk@ATL@@UEAAJXZ
	.proc	?f250@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f250@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=250*8,r14	// r14 = &m_pUnk->vtbl[250] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[250]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[250].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[250].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f250@_QIThunk@ATL@@UEAAJXZ


	.global ?f251@_QIThunk@ATL@@UEAAJXZ
	.proc	?f251@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f251@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=251*8,r14	// r14 = &m_pUnk->vtbl[251] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[251]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[251].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[251].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f251@_QIThunk@ATL@@UEAAJXZ


	.global ?f252@_QIThunk@ATL@@UEAAJXZ
	.proc	?f252@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f252@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=252*8,r14	// r14 = &m_pUnk->vtbl[252] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[252]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[252].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[252].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f252@_QIThunk@ATL@@UEAAJXZ


	.global ?f253@_QIThunk@ATL@@UEAAJXZ
	.proc	?f253@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f253@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=253*8,r14	// r14 = &m_pUnk->vtbl[253] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[253]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[253].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[253].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f253@_QIThunk@ATL@@UEAAJXZ


	.global ?f254@_QIThunk@ATL@@UEAAJXZ
	.proc	?f254@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f254@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=254*8,r14	// r14 = &m_pUnk->vtbl[254] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[254]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[254].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[254].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f254@_QIThunk@ATL@@UEAAJXZ


	.global ?f255@_QIThunk@ATL@@UEAAJXZ
	.proc	?f255@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f255@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=255*8,r14	// r14 = &m_pUnk->vtbl[255] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[255]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[255].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[255].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f255@_QIThunk@ATL@@UEAAJXZ


	.global ?f256@_QIThunk@ATL@@UEAAJXZ
	.proc	?f256@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f256@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=256*8,r14	// r14 = &m_pUnk->vtbl[256] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[256]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[256].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[256].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f256@_QIThunk@ATL@@UEAAJXZ


	.global ?f257@_QIThunk@ATL@@UEAAJXZ
	.proc	?f257@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f257@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=257*8,r14	// r14 = &m_pUnk->vtbl[257] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[257]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[257].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[257].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f257@_QIThunk@ATL@@UEAAJXZ


	.global ?f258@_QIThunk@ATL@@UEAAJXZ
	.proc	?f258@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f258@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=258*8,r14	// r14 = &m_pUnk->vtbl[258] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[258]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[258].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[258].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f258@_QIThunk@ATL@@UEAAJXZ


	.global ?f259@_QIThunk@ATL@@UEAAJXZ
	.proc	?f259@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f259@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=259*8,r14	// r14 = &m_pUnk->vtbl[259] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[259]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[259].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[259].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f259@_QIThunk@ATL@@UEAAJXZ


	.global ?f260@_QIThunk@ATL@@UEAAJXZ
	.proc	?f260@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f260@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=260*8,r14	// r14 = &m_pUnk->vtbl[260] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[260]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[260].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[260].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f260@_QIThunk@ATL@@UEAAJXZ


	.global ?f261@_QIThunk@ATL@@UEAAJXZ
	.proc	?f261@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f261@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=261*8,r14	// r14 = &m_pUnk->vtbl[261] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[261]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[261].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[261].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f261@_QIThunk@ATL@@UEAAJXZ


	.global ?f262@_QIThunk@ATL@@UEAAJXZ
	.proc	?f262@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f262@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=262*8,r14	// r14 = &m_pUnk->vtbl[262] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[262]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[262].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[262].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f262@_QIThunk@ATL@@UEAAJXZ


	.global ?f263@_QIThunk@ATL@@UEAAJXZ
	.proc	?f263@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f263@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=263*8,r14	// r14 = &m_pUnk->vtbl[263] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[263]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[263].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[263].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f263@_QIThunk@ATL@@UEAAJXZ


	.global ?f264@_QIThunk@ATL@@UEAAJXZ
	.proc	?f264@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f264@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=264*8,r14	// r14 = &m_pUnk->vtbl[264] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[264]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[264].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[264].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f264@_QIThunk@ATL@@UEAAJXZ


	.global ?f265@_QIThunk@ATL@@UEAAJXZ
	.proc	?f265@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f265@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=265*8,r14	// r14 = &m_pUnk->vtbl[265] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[265]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[265].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[265].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f265@_QIThunk@ATL@@UEAAJXZ


	.global ?f266@_QIThunk@ATL@@UEAAJXZ
	.proc	?f266@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f266@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=266*8,r14	// r14 = &m_pUnk->vtbl[266] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[266]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[266].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[266].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f266@_QIThunk@ATL@@UEAAJXZ


	.global ?f267@_QIThunk@ATL@@UEAAJXZ
	.proc	?f267@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f267@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=267*8,r14	// r14 = &m_pUnk->vtbl[267] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[267]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[267].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[267].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f267@_QIThunk@ATL@@UEAAJXZ


	.global ?f268@_QIThunk@ATL@@UEAAJXZ
	.proc	?f268@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f268@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=268*8,r14	// r14 = &m_pUnk->vtbl[268] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[268]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[268].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[268].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f268@_QIThunk@ATL@@UEAAJXZ


	.global ?f269@_QIThunk@ATL@@UEAAJXZ
	.proc	?f269@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f269@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=269*8,r14	// r14 = &m_pUnk->vtbl[269] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[269]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[269].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[269].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f269@_QIThunk@ATL@@UEAAJXZ


	.global ?f270@_QIThunk@ATL@@UEAAJXZ
	.proc	?f270@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f270@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=270*8,r14	// r14 = &m_pUnk->vtbl[270] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[270]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[270].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[270].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f270@_QIThunk@ATL@@UEAAJXZ


	.global ?f271@_QIThunk@ATL@@UEAAJXZ
	.proc	?f271@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f271@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=271*8,r14	// r14 = &m_pUnk->vtbl[271] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[271]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[271].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[271].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f271@_QIThunk@ATL@@UEAAJXZ


	.global ?f272@_QIThunk@ATL@@UEAAJXZ
	.proc	?f272@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f272@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=272*8,r14	// r14 = &m_pUnk->vtbl[272] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[272]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[272].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[272].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f272@_QIThunk@ATL@@UEAAJXZ


	.global ?f273@_QIThunk@ATL@@UEAAJXZ
	.proc	?f273@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f273@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=273*8,r14	// r14 = &m_pUnk->vtbl[273] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[273]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[273].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[273].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f273@_QIThunk@ATL@@UEAAJXZ


	.global ?f274@_QIThunk@ATL@@UEAAJXZ
	.proc	?f274@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f274@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=274*8,r14	// r14 = &m_pUnk->vtbl[274] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[274]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[274].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[274].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f274@_QIThunk@ATL@@UEAAJXZ


	.global ?f275@_QIThunk@ATL@@UEAAJXZ
	.proc	?f275@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f275@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=275*8,r14	// r14 = &m_pUnk->vtbl[275] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[275]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[275].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[275].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f275@_QIThunk@ATL@@UEAAJXZ


	.global ?f276@_QIThunk@ATL@@UEAAJXZ
	.proc	?f276@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f276@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=276*8,r14	// r14 = &m_pUnk->vtbl[276] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[276]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[276].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[276].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f276@_QIThunk@ATL@@UEAAJXZ


	.global ?f277@_QIThunk@ATL@@UEAAJXZ
	.proc	?f277@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f277@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=277*8,r14	// r14 = &m_pUnk->vtbl[277] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[277]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[277].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[277].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f277@_QIThunk@ATL@@UEAAJXZ


	.global ?f278@_QIThunk@ATL@@UEAAJXZ
	.proc	?f278@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f278@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=278*8,r14	// r14 = &m_pUnk->vtbl[278] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[278]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[278].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[278].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f278@_QIThunk@ATL@@UEAAJXZ


	.global ?f279@_QIThunk@ATL@@UEAAJXZ
	.proc	?f279@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f279@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=279*8,r14	// r14 = &m_pUnk->vtbl[279] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[279]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[279].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[279].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f279@_QIThunk@ATL@@UEAAJXZ


	.global ?f280@_QIThunk@ATL@@UEAAJXZ
	.proc	?f280@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f280@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=280*8,r14	// r14 = &m_pUnk->vtbl[280] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[280]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[280].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[280].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f280@_QIThunk@ATL@@UEAAJXZ


	.global ?f281@_QIThunk@ATL@@UEAAJXZ
	.proc	?f281@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f281@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=281*8,r14	// r14 = &m_pUnk->vtbl[281] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[281]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[281].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[281].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f281@_QIThunk@ATL@@UEAAJXZ


	.global ?f282@_QIThunk@ATL@@UEAAJXZ
	.proc	?f282@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f282@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=282*8,r14	// r14 = &m_pUnk->vtbl[282] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[282]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[282].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[282].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f282@_QIThunk@ATL@@UEAAJXZ


	.global ?f283@_QIThunk@ATL@@UEAAJXZ
	.proc	?f283@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f283@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=283*8,r14	// r14 = &m_pUnk->vtbl[283] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[283]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[283].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[283].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f283@_QIThunk@ATL@@UEAAJXZ


	.global ?f284@_QIThunk@ATL@@UEAAJXZ
	.proc	?f284@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f284@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=284*8,r14	// r14 = &m_pUnk->vtbl[284] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[284]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[284].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[284].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f284@_QIThunk@ATL@@UEAAJXZ


	.global ?f285@_QIThunk@ATL@@UEAAJXZ
	.proc	?f285@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f285@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=285*8,r14	// r14 = &m_pUnk->vtbl[285] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[285]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[285].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[285].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f285@_QIThunk@ATL@@UEAAJXZ


	.global ?f286@_QIThunk@ATL@@UEAAJXZ
	.proc	?f286@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f286@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=286*8,r14	// r14 = &m_pUnk->vtbl[286] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[286]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[286].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[286].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f286@_QIThunk@ATL@@UEAAJXZ


	.global ?f287@_QIThunk@ATL@@UEAAJXZ
	.proc	?f287@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f287@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=287*8,r14	// r14 = &m_pUnk->vtbl[287] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[287]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[287].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[287].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f287@_QIThunk@ATL@@UEAAJXZ


	.global ?f288@_QIThunk@ATL@@UEAAJXZ
	.proc	?f288@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f288@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=288*8,r14	// r14 = &m_pUnk->vtbl[288] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[288]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[288].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[288].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f288@_QIThunk@ATL@@UEAAJXZ


	.global ?f289@_QIThunk@ATL@@UEAAJXZ
	.proc	?f289@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f289@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=289*8,r14	// r14 = &m_pUnk->vtbl[289] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[289]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[289].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[289].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f289@_QIThunk@ATL@@UEAAJXZ


	.global ?f290@_QIThunk@ATL@@UEAAJXZ
	.proc	?f290@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f290@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=290*8,r14	// r14 = &m_pUnk->vtbl[290] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[290]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[290].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[290].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f290@_QIThunk@ATL@@UEAAJXZ


	.global ?f291@_QIThunk@ATL@@UEAAJXZ
	.proc	?f291@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f291@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=291*8,r14	// r14 = &m_pUnk->vtbl[291] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[291]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[291].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[291].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f291@_QIThunk@ATL@@UEAAJXZ


	.global ?f292@_QIThunk@ATL@@UEAAJXZ
	.proc	?f292@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f292@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=292*8,r14	// r14 = &m_pUnk->vtbl[292] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[292]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[292].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[292].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f292@_QIThunk@ATL@@UEAAJXZ


	.global ?f293@_QIThunk@ATL@@UEAAJXZ
	.proc	?f293@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f293@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=293*8,r14	// r14 = &m_pUnk->vtbl[293] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[293]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[293].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[293].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f293@_QIThunk@ATL@@UEAAJXZ


	.global ?f294@_QIThunk@ATL@@UEAAJXZ
	.proc	?f294@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f294@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=294*8,r14	// r14 = &m_pUnk->vtbl[294] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[294]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[294].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[294].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f294@_QIThunk@ATL@@UEAAJXZ


	.global ?f295@_QIThunk@ATL@@UEAAJXZ
	.proc	?f295@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f295@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=295*8,r14	// r14 = &m_pUnk->vtbl[295] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[295]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[295].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[295].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f295@_QIThunk@ATL@@UEAAJXZ


	.global ?f296@_QIThunk@ATL@@UEAAJXZ
	.proc	?f296@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f296@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=296*8,r14	// r14 = &m_pUnk->vtbl[296] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[296]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[296].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[296].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f296@_QIThunk@ATL@@UEAAJXZ


	.global ?f297@_QIThunk@ATL@@UEAAJXZ
	.proc	?f297@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f297@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=297*8,r14	// r14 = &m_pUnk->vtbl[297] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[297]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[297].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[297].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f297@_QIThunk@ATL@@UEAAJXZ


	.global ?f298@_QIThunk@ATL@@UEAAJXZ
	.proc	?f298@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f298@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=298*8,r14	// r14 = &m_pUnk->vtbl[298] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[298]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[298].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[298].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f298@_QIThunk@ATL@@UEAAJXZ


	.global ?f299@_QIThunk@ATL@@UEAAJXZ
	.proc	?f299@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f299@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=299*8,r14	// r14 = &m_pUnk->vtbl[299] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[299]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[299].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[299].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f299@_QIThunk@ATL@@UEAAJXZ


	.global ?f300@_QIThunk@ATL@@UEAAJXZ
	.proc	?f300@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f300@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=300*8,r14	// r14 = &m_pUnk->vtbl[300] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[300]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[300].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[300].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f300@_QIThunk@ATL@@UEAAJXZ


	.global ?f301@_QIThunk@ATL@@UEAAJXZ
	.proc	?f301@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f301@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=301*8,r14	// r14 = &m_pUnk->vtbl[301] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[301]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[301].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[301].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f301@_QIThunk@ATL@@UEAAJXZ


	.global ?f302@_QIThunk@ATL@@UEAAJXZ
	.proc	?f302@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f302@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=302*8,r14	// r14 = &m_pUnk->vtbl[302] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[302]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[302].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[302].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f302@_QIThunk@ATL@@UEAAJXZ


	.global ?f303@_QIThunk@ATL@@UEAAJXZ
	.proc	?f303@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f303@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=303*8,r14	// r14 = &m_pUnk->vtbl[303] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[303]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[303].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[303].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f303@_QIThunk@ATL@@UEAAJXZ


	.global ?f304@_QIThunk@ATL@@UEAAJXZ
	.proc	?f304@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f304@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=304*8,r14	// r14 = &m_pUnk->vtbl[304] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[304]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[304].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[304].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f304@_QIThunk@ATL@@UEAAJXZ


	.global ?f305@_QIThunk@ATL@@UEAAJXZ
	.proc	?f305@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f305@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=305*8,r14	// r14 = &m_pUnk->vtbl[305] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[305]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[305].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[305].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f305@_QIThunk@ATL@@UEAAJXZ


	.global ?f306@_QIThunk@ATL@@UEAAJXZ
	.proc	?f306@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f306@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=306*8,r14	// r14 = &m_pUnk->vtbl[306] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[306]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[306].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[306].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f306@_QIThunk@ATL@@UEAAJXZ


	.global ?f307@_QIThunk@ATL@@UEAAJXZ
	.proc	?f307@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f307@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=307*8,r14	// r14 = &m_pUnk->vtbl[307] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[307]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[307].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[307].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f307@_QIThunk@ATL@@UEAAJXZ


	.global ?f308@_QIThunk@ATL@@UEAAJXZ
	.proc	?f308@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f308@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=308*8,r14	// r14 = &m_pUnk->vtbl[308] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[308]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[308].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[308].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f308@_QIThunk@ATL@@UEAAJXZ


	.global ?f309@_QIThunk@ATL@@UEAAJXZ
	.proc	?f309@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f309@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=309*8,r14	// r14 = &m_pUnk->vtbl[309] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[309]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[309].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[309].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f309@_QIThunk@ATL@@UEAAJXZ


	.global ?f310@_QIThunk@ATL@@UEAAJXZ
	.proc	?f310@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f310@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=310*8,r14	// r14 = &m_pUnk->vtbl[310] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[310]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[310].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[310].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f310@_QIThunk@ATL@@UEAAJXZ


	.global ?f311@_QIThunk@ATL@@UEAAJXZ
	.proc	?f311@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f311@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=311*8,r14	// r14 = &m_pUnk->vtbl[311] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[311]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[311].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[311].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f311@_QIThunk@ATL@@UEAAJXZ


	.global ?f312@_QIThunk@ATL@@UEAAJXZ
	.proc	?f312@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f312@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=312*8,r14	// r14 = &m_pUnk->vtbl[312] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[312]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[312].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[312].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f312@_QIThunk@ATL@@UEAAJXZ


	.global ?f313@_QIThunk@ATL@@UEAAJXZ
	.proc	?f313@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f313@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=313*8,r14	// r14 = &m_pUnk->vtbl[313] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[313]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[313].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[313].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f313@_QIThunk@ATL@@UEAAJXZ


	.global ?f314@_QIThunk@ATL@@UEAAJXZ
	.proc	?f314@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f314@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=314*8,r14	// r14 = &m_pUnk->vtbl[314] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[314]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[314].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[314].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f314@_QIThunk@ATL@@UEAAJXZ


	.global ?f315@_QIThunk@ATL@@UEAAJXZ
	.proc	?f315@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f315@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=315*8,r14	// r14 = &m_pUnk->vtbl[315] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[315]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[315].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[315].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f315@_QIThunk@ATL@@UEAAJXZ


	.global ?f316@_QIThunk@ATL@@UEAAJXZ
	.proc	?f316@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f316@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=316*8,r14	// r14 = &m_pUnk->vtbl[316] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[316]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[316].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[316].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f316@_QIThunk@ATL@@UEAAJXZ


	.global ?f317@_QIThunk@ATL@@UEAAJXZ
	.proc	?f317@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f317@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=317*8,r14	// r14 = &m_pUnk->vtbl[317] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[317]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[317].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[317].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f317@_QIThunk@ATL@@UEAAJXZ


	.global ?f318@_QIThunk@ATL@@UEAAJXZ
	.proc	?f318@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f318@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=318*8,r14	// r14 = &m_pUnk->vtbl[318] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[318]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[318].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[318].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f318@_QIThunk@ATL@@UEAAJXZ


	.global ?f319@_QIThunk@ATL@@UEAAJXZ
	.proc	?f319@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f319@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=319*8,r14	// r14 = &m_pUnk->vtbl[319] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[319]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[319].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[319].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f319@_QIThunk@ATL@@UEAAJXZ


	.global ?f320@_QIThunk@ATL@@UEAAJXZ
	.proc	?f320@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f320@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=320*8,r14	// r14 = &m_pUnk->vtbl[320] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[320]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[320].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[320].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f320@_QIThunk@ATL@@UEAAJXZ


	.global ?f321@_QIThunk@ATL@@UEAAJXZ
	.proc	?f321@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f321@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=321*8,r14	// r14 = &m_pUnk->vtbl[321] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[321]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[321].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[321].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f321@_QIThunk@ATL@@UEAAJXZ


	.global ?f322@_QIThunk@ATL@@UEAAJXZ
	.proc	?f322@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f322@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=322*8,r14	// r14 = &m_pUnk->vtbl[322] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[322]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[322].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[322].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f322@_QIThunk@ATL@@UEAAJXZ


	.global ?f323@_QIThunk@ATL@@UEAAJXZ
	.proc	?f323@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f323@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=323*8,r14	// r14 = &m_pUnk->vtbl[323] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[323]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[323].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[323].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f323@_QIThunk@ATL@@UEAAJXZ


	.global ?f324@_QIThunk@ATL@@UEAAJXZ
	.proc	?f324@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f324@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=324*8,r14	// r14 = &m_pUnk->vtbl[324] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[324]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[324].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[324].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f324@_QIThunk@ATL@@UEAAJXZ


	.global ?f325@_QIThunk@ATL@@UEAAJXZ
	.proc	?f325@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f325@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=325*8,r14	// r14 = &m_pUnk->vtbl[325] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[325]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[325].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[325].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f325@_QIThunk@ATL@@UEAAJXZ


	.global ?f326@_QIThunk@ATL@@UEAAJXZ
	.proc	?f326@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f326@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=326*8,r14	// r14 = &m_pUnk->vtbl[326] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[326]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[326].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[326].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f326@_QIThunk@ATL@@UEAAJXZ


	.global ?f327@_QIThunk@ATL@@UEAAJXZ
	.proc	?f327@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f327@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=327*8,r14	// r14 = &m_pUnk->vtbl[327] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[327]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[327].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[327].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f327@_QIThunk@ATL@@UEAAJXZ


	.global ?f328@_QIThunk@ATL@@UEAAJXZ
	.proc	?f328@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f328@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=328*8,r14	// r14 = &m_pUnk->vtbl[328] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[328]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[328].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[328].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f328@_QIThunk@ATL@@UEAAJXZ


	.global ?f329@_QIThunk@ATL@@UEAAJXZ
	.proc	?f329@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f329@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=329*8,r14	// r14 = &m_pUnk->vtbl[329] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[329]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[329].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[329].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f329@_QIThunk@ATL@@UEAAJXZ


	.global ?f330@_QIThunk@ATL@@UEAAJXZ
	.proc	?f330@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f330@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=330*8,r14	// r14 = &m_pUnk->vtbl[330] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[330]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[330].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[330].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f330@_QIThunk@ATL@@UEAAJXZ


	.global ?f331@_QIThunk@ATL@@UEAAJXZ
	.proc	?f331@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f331@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=331*8,r14	// r14 = &m_pUnk->vtbl[331] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[331]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[331].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[331].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f331@_QIThunk@ATL@@UEAAJXZ


	.global ?f332@_QIThunk@ATL@@UEAAJXZ
	.proc	?f332@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f332@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=332*8,r14	// r14 = &m_pUnk->vtbl[332] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[332]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[332].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[332].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f332@_QIThunk@ATL@@UEAAJXZ


	.global ?f333@_QIThunk@ATL@@UEAAJXZ
	.proc	?f333@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f333@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=333*8,r14	// r14 = &m_pUnk->vtbl[333] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[333]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[333].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[333].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f333@_QIThunk@ATL@@UEAAJXZ


	.global ?f334@_QIThunk@ATL@@UEAAJXZ
	.proc	?f334@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f334@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=334*8,r14	// r14 = &m_pUnk->vtbl[334] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[334]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[334].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[334].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f334@_QIThunk@ATL@@UEAAJXZ


	.global ?f335@_QIThunk@ATL@@UEAAJXZ
	.proc	?f335@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f335@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=335*8,r14	// r14 = &m_pUnk->vtbl[335] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[335]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[335].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[335].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f335@_QIThunk@ATL@@UEAAJXZ


	.global ?f336@_QIThunk@ATL@@UEAAJXZ
	.proc	?f336@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f336@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=336*8,r14	// r14 = &m_pUnk->vtbl[336] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[336]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[336].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[336].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f336@_QIThunk@ATL@@UEAAJXZ


	.global ?f337@_QIThunk@ATL@@UEAAJXZ
	.proc	?f337@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f337@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=337*8,r14	// r14 = &m_pUnk->vtbl[337] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[337]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[337].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[337].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f337@_QIThunk@ATL@@UEAAJXZ


	.global ?f338@_QIThunk@ATL@@UEAAJXZ
	.proc	?f338@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f338@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=338*8,r14	// r14 = &m_pUnk->vtbl[338] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[338]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[338].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[338].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f338@_QIThunk@ATL@@UEAAJXZ


	.global ?f339@_QIThunk@ATL@@UEAAJXZ
	.proc	?f339@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f339@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=339*8,r14	// r14 = &m_pUnk->vtbl[339] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[339]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[339].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[339].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f339@_QIThunk@ATL@@UEAAJXZ


	.global ?f340@_QIThunk@ATL@@UEAAJXZ
	.proc	?f340@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f340@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=340*8,r14	// r14 = &m_pUnk->vtbl[340] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[340]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[340].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[340].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f340@_QIThunk@ATL@@UEAAJXZ


	.global ?f341@_QIThunk@ATL@@UEAAJXZ
	.proc	?f341@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f341@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=341*8,r14	// r14 = &m_pUnk->vtbl[341] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[341]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[341].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[341].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f341@_QIThunk@ATL@@UEAAJXZ


	.global ?f342@_QIThunk@ATL@@UEAAJXZ
	.proc	?f342@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f342@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=342*8,r14	// r14 = &m_pUnk->vtbl[342] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[342]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[342].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[342].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f342@_QIThunk@ATL@@UEAAJXZ


	.global ?f343@_QIThunk@ATL@@UEAAJXZ
	.proc	?f343@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f343@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=343*8,r14	// r14 = &m_pUnk->vtbl[343] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[343]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[343].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[343].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f343@_QIThunk@ATL@@UEAAJXZ


	.global ?f344@_QIThunk@ATL@@UEAAJXZ
	.proc	?f344@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f344@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=344*8,r14	// r14 = &m_pUnk->vtbl[344] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[344]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[344].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[344].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f344@_QIThunk@ATL@@UEAAJXZ


	.global ?f345@_QIThunk@ATL@@UEAAJXZ
	.proc	?f345@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f345@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=345*8,r14	// r14 = &m_pUnk->vtbl[345] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[345]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[345].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[345].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f345@_QIThunk@ATL@@UEAAJXZ


	.global ?f346@_QIThunk@ATL@@UEAAJXZ
	.proc	?f346@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f346@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=346*8,r14	// r14 = &m_pUnk->vtbl[346] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[346]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[346].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[346].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f346@_QIThunk@ATL@@UEAAJXZ


	.global ?f347@_QIThunk@ATL@@UEAAJXZ
	.proc	?f347@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f347@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=347*8,r14	// r14 = &m_pUnk->vtbl[347] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[347]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[347].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[347].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f347@_QIThunk@ATL@@UEAAJXZ


	.global ?f348@_QIThunk@ATL@@UEAAJXZ
	.proc	?f348@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f348@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=348*8,r14	// r14 = &m_pUnk->vtbl[348] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[348]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[348].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[348].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f348@_QIThunk@ATL@@UEAAJXZ


	.global ?f349@_QIThunk@ATL@@UEAAJXZ
	.proc	?f349@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f349@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=349*8,r14	// r14 = &m_pUnk->vtbl[349] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[349]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[349].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[349].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f349@_QIThunk@ATL@@UEAAJXZ


	.global ?f350@_QIThunk@ATL@@UEAAJXZ
	.proc	?f350@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f350@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=350*8,r14	// r14 = &m_pUnk->vtbl[350] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[350]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[350].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[350].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f350@_QIThunk@ATL@@UEAAJXZ


	.global ?f351@_QIThunk@ATL@@UEAAJXZ
	.proc	?f351@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f351@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=351*8,r14	// r14 = &m_pUnk->vtbl[351] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[351]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[351].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[351].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f351@_QIThunk@ATL@@UEAAJXZ


	.global ?f352@_QIThunk@ATL@@UEAAJXZ
	.proc	?f352@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f352@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=352*8,r14	// r14 = &m_pUnk->vtbl[352] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[352]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[352].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[352].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f352@_QIThunk@ATL@@UEAAJXZ


	.global ?f353@_QIThunk@ATL@@UEAAJXZ
	.proc	?f353@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f353@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=353*8,r14	// r14 = &m_pUnk->vtbl[353] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[353]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[353].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[353].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f353@_QIThunk@ATL@@UEAAJXZ


	.global ?f354@_QIThunk@ATL@@UEAAJXZ
	.proc	?f354@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f354@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=354*8,r14	// r14 = &m_pUnk->vtbl[354] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[354]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[354].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[354].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f354@_QIThunk@ATL@@UEAAJXZ


	.global ?f355@_QIThunk@ATL@@UEAAJXZ
	.proc	?f355@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f355@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=355*8,r14	// r14 = &m_pUnk->vtbl[355] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[355]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[355].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[355].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f355@_QIThunk@ATL@@UEAAJXZ


	.global ?f356@_QIThunk@ATL@@UEAAJXZ
	.proc	?f356@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f356@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=356*8,r14	// r14 = &m_pUnk->vtbl[356] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[356]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[356].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[356].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f356@_QIThunk@ATL@@UEAAJXZ


	.global ?f357@_QIThunk@ATL@@UEAAJXZ
	.proc	?f357@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f357@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=357*8,r14	// r14 = &m_pUnk->vtbl[357] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[357]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[357].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[357].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f357@_QIThunk@ATL@@UEAAJXZ


	.global ?f358@_QIThunk@ATL@@UEAAJXZ
	.proc	?f358@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f358@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=358*8,r14	// r14 = &m_pUnk->vtbl[358] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[358]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[358].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[358].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f358@_QIThunk@ATL@@UEAAJXZ


	.global ?f359@_QIThunk@ATL@@UEAAJXZ
	.proc	?f359@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f359@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=359*8,r14	// r14 = &m_pUnk->vtbl[359] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[359]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[359].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[359].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f359@_QIThunk@ATL@@UEAAJXZ


	.global ?f360@_QIThunk@ATL@@UEAAJXZ
	.proc	?f360@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f360@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=360*8,r14	// r14 = &m_pUnk->vtbl[360] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[360]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[360].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[360].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f360@_QIThunk@ATL@@UEAAJXZ


	.global ?f361@_QIThunk@ATL@@UEAAJXZ
	.proc	?f361@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f361@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=361*8,r14	// r14 = &m_pUnk->vtbl[361] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[361]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[361].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[361].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f361@_QIThunk@ATL@@UEAAJXZ


	.global ?f362@_QIThunk@ATL@@UEAAJXZ
	.proc	?f362@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f362@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=362*8,r14	// r14 = &m_pUnk->vtbl[362] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[362]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[362].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[362].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f362@_QIThunk@ATL@@UEAAJXZ


	.global ?f363@_QIThunk@ATL@@UEAAJXZ
	.proc	?f363@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f363@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=363*8,r14	// r14 = &m_pUnk->vtbl[363] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[363]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[363].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[363].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f363@_QIThunk@ATL@@UEAAJXZ


	.global ?f364@_QIThunk@ATL@@UEAAJXZ
	.proc	?f364@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f364@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=364*8,r14	// r14 = &m_pUnk->vtbl[364] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[364]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[364].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[364].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f364@_QIThunk@ATL@@UEAAJXZ


	.global ?f365@_QIThunk@ATL@@UEAAJXZ
	.proc	?f365@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f365@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=365*8,r14	// r14 = &m_pUnk->vtbl[365] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[365]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[365].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[365].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f365@_QIThunk@ATL@@UEAAJXZ


	.global ?f366@_QIThunk@ATL@@UEAAJXZ
	.proc	?f366@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f366@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=366*8,r14	// r14 = &m_pUnk->vtbl[366] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[366]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[366].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[366].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f366@_QIThunk@ATL@@UEAAJXZ


	.global ?f367@_QIThunk@ATL@@UEAAJXZ
	.proc	?f367@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f367@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=367*8,r14	// r14 = &m_pUnk->vtbl[367] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[367]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[367].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[367].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f367@_QIThunk@ATL@@UEAAJXZ


	.global ?f368@_QIThunk@ATL@@UEAAJXZ
	.proc	?f368@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f368@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=368*8,r14	// r14 = &m_pUnk->vtbl[368] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[368]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[368].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[368].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f368@_QIThunk@ATL@@UEAAJXZ


	.global ?f369@_QIThunk@ATL@@UEAAJXZ
	.proc	?f369@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f369@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=369*8,r14	// r14 = &m_pUnk->vtbl[369] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[369]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[369].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[369].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f369@_QIThunk@ATL@@UEAAJXZ


	.global ?f370@_QIThunk@ATL@@UEAAJXZ
	.proc	?f370@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f370@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=370*8,r14	// r14 = &m_pUnk->vtbl[370] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[370]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[370].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[370].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f370@_QIThunk@ATL@@UEAAJXZ


	.global ?f371@_QIThunk@ATL@@UEAAJXZ
	.proc	?f371@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f371@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=371*8,r14	// r14 = &m_pUnk->vtbl[371] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[371]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[371].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[371].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f371@_QIThunk@ATL@@UEAAJXZ


	.global ?f372@_QIThunk@ATL@@UEAAJXZ
	.proc	?f372@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f372@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=372*8,r14	// r14 = &m_pUnk->vtbl[372] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[372]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[372].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[372].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f372@_QIThunk@ATL@@UEAAJXZ


	.global ?f373@_QIThunk@ATL@@UEAAJXZ
	.proc	?f373@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f373@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=373*8,r14	// r14 = &m_pUnk->vtbl[373] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[373]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[373].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[373].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f373@_QIThunk@ATL@@UEAAJXZ


	.global ?f374@_QIThunk@ATL@@UEAAJXZ
	.proc	?f374@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f374@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=374*8,r14	// r14 = &m_pUnk->vtbl[374] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[374]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[374].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[374].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f374@_QIThunk@ATL@@UEAAJXZ


	.global ?f375@_QIThunk@ATL@@UEAAJXZ
	.proc	?f375@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f375@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=375*8,r14	// r14 = &m_pUnk->vtbl[375] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[375]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[375].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[375].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f375@_QIThunk@ATL@@UEAAJXZ


	.global ?f376@_QIThunk@ATL@@UEAAJXZ
	.proc	?f376@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f376@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=376*8,r14	// r14 = &m_pUnk->vtbl[376] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[376]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[376].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[376].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f376@_QIThunk@ATL@@UEAAJXZ


	.global ?f377@_QIThunk@ATL@@UEAAJXZ
	.proc	?f377@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f377@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=377*8,r14	// r14 = &m_pUnk->vtbl[377] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[377]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[377].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[377].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f377@_QIThunk@ATL@@UEAAJXZ


	.global ?f378@_QIThunk@ATL@@UEAAJXZ
	.proc	?f378@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f378@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=378*8,r14	// r14 = &m_pUnk->vtbl[378] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[378]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[378].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[378].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f378@_QIThunk@ATL@@UEAAJXZ


	.global ?f379@_QIThunk@ATL@@UEAAJXZ
	.proc	?f379@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f379@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=379*8,r14	// r14 = &m_pUnk->vtbl[379] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[379]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[379].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[379].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f379@_QIThunk@ATL@@UEAAJXZ


	.global ?f380@_QIThunk@ATL@@UEAAJXZ
	.proc	?f380@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f380@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=380*8,r14	// r14 = &m_pUnk->vtbl[380] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[380]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[380].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[380].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f380@_QIThunk@ATL@@UEAAJXZ


	.global ?f381@_QIThunk@ATL@@UEAAJXZ
	.proc	?f381@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f381@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=381*8,r14	// r14 = &m_pUnk->vtbl[381] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[381]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[381].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[381].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f381@_QIThunk@ATL@@UEAAJXZ


	.global ?f382@_QIThunk@ATL@@UEAAJXZ
	.proc	?f382@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f382@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=382*8,r14	// r14 = &m_pUnk->vtbl[382] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[382]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[382].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[382].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f382@_QIThunk@ATL@@UEAAJXZ


	.global ?f383@_QIThunk@ATL@@UEAAJXZ
	.proc	?f383@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f383@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=383*8,r14	// r14 = &m_pUnk->vtbl[383] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[383]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[383].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[383].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f383@_QIThunk@ATL@@UEAAJXZ


	.global ?f384@_QIThunk@ATL@@UEAAJXZ
	.proc	?f384@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f384@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=384*8,r14	// r14 = &m_pUnk->vtbl[384] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[384]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[384].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[384].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f384@_QIThunk@ATL@@UEAAJXZ


	.global ?f385@_QIThunk@ATL@@UEAAJXZ
	.proc	?f385@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f385@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=385*8,r14	// r14 = &m_pUnk->vtbl[385] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[385]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[385].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[385].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f385@_QIThunk@ATL@@UEAAJXZ


	.global ?f386@_QIThunk@ATL@@UEAAJXZ
	.proc	?f386@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f386@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=386*8,r14	// r14 = &m_pUnk->vtbl[386] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[386]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[386].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[386].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f386@_QIThunk@ATL@@UEAAJXZ


	.global ?f387@_QIThunk@ATL@@UEAAJXZ
	.proc	?f387@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f387@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=387*8,r14	// r14 = &m_pUnk->vtbl[387] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[387]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[387].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[387].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f387@_QIThunk@ATL@@UEAAJXZ


	.global ?f388@_QIThunk@ATL@@UEAAJXZ
	.proc	?f388@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f388@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=388*8,r14	// r14 = &m_pUnk->vtbl[388] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[388]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[388].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[388].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f388@_QIThunk@ATL@@UEAAJXZ


	.global ?f389@_QIThunk@ATL@@UEAAJXZ
	.proc	?f389@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f389@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=389*8,r14	// r14 = &m_pUnk->vtbl[389] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[389]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[389].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[389].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f389@_QIThunk@ATL@@UEAAJXZ


	.global ?f390@_QIThunk@ATL@@UEAAJXZ
	.proc	?f390@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f390@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=390*8,r14	// r14 = &m_pUnk->vtbl[390] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[390]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[390].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[390].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f390@_QIThunk@ATL@@UEAAJXZ


	.global ?f391@_QIThunk@ATL@@UEAAJXZ
	.proc	?f391@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f391@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=391*8,r14	// r14 = &m_pUnk->vtbl[391] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[391]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[391].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[391].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f391@_QIThunk@ATL@@UEAAJXZ


	.global ?f392@_QIThunk@ATL@@UEAAJXZ
	.proc	?f392@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f392@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=392*8,r14	// r14 = &m_pUnk->vtbl[392] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[392]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[392].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[392].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f392@_QIThunk@ATL@@UEAAJXZ


	.global ?f393@_QIThunk@ATL@@UEAAJXZ
	.proc	?f393@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f393@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=393*8,r14	// r14 = &m_pUnk->vtbl[393] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[393]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[393].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[393].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f393@_QIThunk@ATL@@UEAAJXZ


	.global ?f394@_QIThunk@ATL@@UEAAJXZ
	.proc	?f394@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f394@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=394*8,r14	// r14 = &m_pUnk->vtbl[394] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[394]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[394].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[394].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f394@_QIThunk@ATL@@UEAAJXZ


	.global ?f395@_QIThunk@ATL@@UEAAJXZ
	.proc	?f395@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f395@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=395*8,r14	// r14 = &m_pUnk->vtbl[395] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[395]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[395].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[395].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f395@_QIThunk@ATL@@UEAAJXZ


	.global ?f396@_QIThunk@ATL@@UEAAJXZ
	.proc	?f396@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f396@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=396*8,r14	// r14 = &m_pUnk->vtbl[396] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[396]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[396].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[396].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f396@_QIThunk@ATL@@UEAAJXZ


	.global ?f397@_QIThunk@ATL@@UEAAJXZ
	.proc	?f397@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f397@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=397*8,r14	// r14 = &m_pUnk->vtbl[397] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[397]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[397].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[397].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f397@_QIThunk@ATL@@UEAAJXZ


	.global ?f398@_QIThunk@ATL@@UEAAJXZ
	.proc	?f398@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f398@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=398*8,r14	// r14 = &m_pUnk->vtbl[398] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[398]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[398].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[398].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f398@_QIThunk@ATL@@UEAAJXZ


	.global ?f399@_QIThunk@ATL@@UEAAJXZ
	.proc	?f399@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f399@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=399*8,r14	// r14 = &m_pUnk->vtbl[399] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[399]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[399].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[399].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f399@_QIThunk@ATL@@UEAAJXZ


	.global ?f400@_QIThunk@ATL@@UEAAJXZ
	.proc	?f400@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f400@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=400*8,r14	// r14 = &m_pUnk->vtbl[400] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[400]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[400].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[400].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f400@_QIThunk@ATL@@UEAAJXZ


	.global ?f401@_QIThunk@ATL@@UEAAJXZ
	.proc	?f401@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f401@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=401*8,r14	// r14 = &m_pUnk->vtbl[401] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[401]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[401].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[401].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f401@_QIThunk@ATL@@UEAAJXZ


	.global ?f402@_QIThunk@ATL@@UEAAJXZ
	.proc	?f402@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f402@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=402*8,r14	// r14 = &m_pUnk->vtbl[402] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[402]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[402].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[402].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f402@_QIThunk@ATL@@UEAAJXZ


	.global ?f403@_QIThunk@ATL@@UEAAJXZ
	.proc	?f403@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f403@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=403*8,r14	// r14 = &m_pUnk->vtbl[403] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[403]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[403].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[403].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f403@_QIThunk@ATL@@UEAAJXZ


	.global ?f404@_QIThunk@ATL@@UEAAJXZ
	.proc	?f404@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f404@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=404*8,r14	// r14 = &m_pUnk->vtbl[404] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[404]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[404].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[404].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f404@_QIThunk@ATL@@UEAAJXZ


	.global ?f405@_QIThunk@ATL@@UEAAJXZ
	.proc	?f405@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f405@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=405*8,r14	// r14 = &m_pUnk->vtbl[405] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[405]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[405].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[405].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f405@_QIThunk@ATL@@UEAAJXZ


	.global ?f406@_QIThunk@ATL@@UEAAJXZ
	.proc	?f406@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f406@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=406*8,r14	// r14 = &m_pUnk->vtbl[406] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[406]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[406].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[406].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f406@_QIThunk@ATL@@UEAAJXZ


	.global ?f407@_QIThunk@ATL@@UEAAJXZ
	.proc	?f407@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f407@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=407*8,r14	// r14 = &m_pUnk->vtbl[407] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[407]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[407].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[407].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f407@_QIThunk@ATL@@UEAAJXZ


	.global ?f408@_QIThunk@ATL@@UEAAJXZ
	.proc	?f408@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f408@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=408*8,r14	// r14 = &m_pUnk->vtbl[408] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[408]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[408].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[408].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f408@_QIThunk@ATL@@UEAAJXZ


	.global ?f409@_QIThunk@ATL@@UEAAJXZ
	.proc	?f409@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f409@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=409*8,r14	// r14 = &m_pUnk->vtbl[409] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[409]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[409].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[409].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f409@_QIThunk@ATL@@UEAAJXZ


	.global ?f410@_QIThunk@ATL@@UEAAJXZ
	.proc	?f410@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f410@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=410*8,r14	// r14 = &m_pUnk->vtbl[410] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[410]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[410].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[410].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f410@_QIThunk@ATL@@UEAAJXZ


	.global ?f411@_QIThunk@ATL@@UEAAJXZ
	.proc	?f411@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f411@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=411*8,r14	// r14 = &m_pUnk->vtbl[411] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[411]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[411].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[411].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f411@_QIThunk@ATL@@UEAAJXZ


	.global ?f412@_QIThunk@ATL@@UEAAJXZ
	.proc	?f412@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f412@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=412*8,r14	// r14 = &m_pUnk->vtbl[412] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[412]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[412].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[412].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f412@_QIThunk@ATL@@UEAAJXZ


	.global ?f413@_QIThunk@ATL@@UEAAJXZ
	.proc	?f413@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f413@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=413*8,r14	// r14 = &m_pUnk->vtbl[413] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[413]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[413].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[413].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f413@_QIThunk@ATL@@UEAAJXZ


	.global ?f414@_QIThunk@ATL@@UEAAJXZ
	.proc	?f414@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f414@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=414*8,r14	// r14 = &m_pUnk->vtbl[414] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[414]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[414].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[414].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f414@_QIThunk@ATL@@UEAAJXZ


	.global ?f415@_QIThunk@ATL@@UEAAJXZ
	.proc	?f415@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f415@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=415*8,r14	// r14 = &m_pUnk->vtbl[415] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[415]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[415].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[415].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f415@_QIThunk@ATL@@UEAAJXZ


	.global ?f416@_QIThunk@ATL@@UEAAJXZ
	.proc	?f416@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f416@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=416*8,r14	// r14 = &m_pUnk->vtbl[416] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[416]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[416].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[416].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f416@_QIThunk@ATL@@UEAAJXZ


	.global ?f417@_QIThunk@ATL@@UEAAJXZ
	.proc	?f417@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f417@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=417*8,r14	// r14 = &m_pUnk->vtbl[417] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[417]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[417].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[417].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f417@_QIThunk@ATL@@UEAAJXZ


	.global ?f418@_QIThunk@ATL@@UEAAJXZ
	.proc	?f418@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f418@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=418*8,r14	// r14 = &m_pUnk->vtbl[418] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[418]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[418].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[418].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f418@_QIThunk@ATL@@UEAAJXZ


	.global ?f419@_QIThunk@ATL@@UEAAJXZ
	.proc	?f419@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f419@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=419*8,r14	// r14 = &m_pUnk->vtbl[419] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[419]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[419].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[419].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f419@_QIThunk@ATL@@UEAAJXZ


	.global ?f420@_QIThunk@ATL@@UEAAJXZ
	.proc	?f420@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f420@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=420*8,r14	// r14 = &m_pUnk->vtbl[420] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[420]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[420].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[420].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f420@_QIThunk@ATL@@UEAAJXZ


	.global ?f421@_QIThunk@ATL@@UEAAJXZ
	.proc	?f421@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f421@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=421*8,r14	// r14 = &m_pUnk->vtbl[421] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[421]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[421].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[421].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f421@_QIThunk@ATL@@UEAAJXZ


	.global ?f422@_QIThunk@ATL@@UEAAJXZ
	.proc	?f422@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f422@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=422*8,r14	// r14 = &m_pUnk->vtbl[422] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[422]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[422].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[422].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f422@_QIThunk@ATL@@UEAAJXZ


	.global ?f423@_QIThunk@ATL@@UEAAJXZ
	.proc	?f423@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f423@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=423*8,r14	// r14 = &m_pUnk->vtbl[423] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[423]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[423].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[423].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f423@_QIThunk@ATL@@UEAAJXZ


	.global ?f424@_QIThunk@ATL@@UEAAJXZ
	.proc	?f424@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f424@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=424*8,r14	// r14 = &m_pUnk->vtbl[424] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[424]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[424].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[424].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f424@_QIThunk@ATL@@UEAAJXZ


	.global ?f425@_QIThunk@ATL@@UEAAJXZ
	.proc	?f425@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f425@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=425*8,r14	// r14 = &m_pUnk->vtbl[425] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[425]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[425].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[425].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f425@_QIThunk@ATL@@UEAAJXZ


	.global ?f426@_QIThunk@ATL@@UEAAJXZ
	.proc	?f426@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f426@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=426*8,r14	// r14 = &m_pUnk->vtbl[426] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[426]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[426].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[426].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f426@_QIThunk@ATL@@UEAAJXZ


	.global ?f427@_QIThunk@ATL@@UEAAJXZ
	.proc	?f427@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f427@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=427*8,r14	// r14 = &m_pUnk->vtbl[427] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[427]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[427].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[427].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f427@_QIThunk@ATL@@UEAAJXZ


	.global ?f428@_QIThunk@ATL@@UEAAJXZ
	.proc	?f428@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f428@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=428*8,r14	// r14 = &m_pUnk->vtbl[428] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[428]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[428].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[428].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f428@_QIThunk@ATL@@UEAAJXZ


	.global ?f429@_QIThunk@ATL@@UEAAJXZ
	.proc	?f429@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f429@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=429*8,r14	// r14 = &m_pUnk->vtbl[429] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[429]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[429].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[429].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f429@_QIThunk@ATL@@UEAAJXZ


	.global ?f430@_QIThunk@ATL@@UEAAJXZ
	.proc	?f430@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f430@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=430*8,r14	// r14 = &m_pUnk->vtbl[430] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[430]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[430].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[430].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f430@_QIThunk@ATL@@UEAAJXZ


	.global ?f431@_QIThunk@ATL@@UEAAJXZ
	.proc	?f431@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f431@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=431*8,r14	// r14 = &m_pUnk->vtbl[431] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[431]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[431].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[431].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f431@_QIThunk@ATL@@UEAAJXZ


	.global ?f432@_QIThunk@ATL@@UEAAJXZ
	.proc	?f432@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f432@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=432*8,r14	// r14 = &m_pUnk->vtbl[432] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[432]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[432].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[432].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f432@_QIThunk@ATL@@UEAAJXZ


	.global ?f433@_QIThunk@ATL@@UEAAJXZ
	.proc	?f433@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f433@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=433*8,r14	// r14 = &m_pUnk->vtbl[433] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[433]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[433].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[433].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f433@_QIThunk@ATL@@UEAAJXZ


	.global ?f434@_QIThunk@ATL@@UEAAJXZ
	.proc	?f434@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f434@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=434*8,r14	// r14 = &m_pUnk->vtbl[434] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[434]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[434].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[434].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f434@_QIThunk@ATL@@UEAAJXZ


	.global ?f435@_QIThunk@ATL@@UEAAJXZ
	.proc	?f435@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f435@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=435*8,r14	// r14 = &m_pUnk->vtbl[435] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[435]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[435].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[435].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f435@_QIThunk@ATL@@UEAAJXZ


	.global ?f436@_QIThunk@ATL@@UEAAJXZ
	.proc	?f436@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f436@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=436*8,r14	// r14 = &m_pUnk->vtbl[436] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[436]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[436].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[436].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f436@_QIThunk@ATL@@UEAAJXZ


	.global ?f437@_QIThunk@ATL@@UEAAJXZ
	.proc	?f437@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f437@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=437*8,r14	// r14 = &m_pUnk->vtbl[437] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[437]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[437].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[437].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f437@_QIThunk@ATL@@UEAAJXZ


	.global ?f438@_QIThunk@ATL@@UEAAJXZ
	.proc	?f438@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f438@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=438*8,r14	// r14 = &m_pUnk->vtbl[438] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[438]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[438].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[438].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f438@_QIThunk@ATL@@UEAAJXZ


	.global ?f439@_QIThunk@ATL@@UEAAJXZ
	.proc	?f439@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f439@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=439*8,r14	// r14 = &m_pUnk->vtbl[439] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[439]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[439].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[439].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f439@_QIThunk@ATL@@UEAAJXZ


	.global ?f440@_QIThunk@ATL@@UEAAJXZ
	.proc	?f440@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f440@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=440*8,r14	// r14 = &m_pUnk->vtbl[440] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[440]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[440].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[440].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f440@_QIThunk@ATL@@UEAAJXZ


	.global ?f441@_QIThunk@ATL@@UEAAJXZ
	.proc	?f441@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f441@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=441*8,r14	// r14 = &m_pUnk->vtbl[441] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[441]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[441].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[441].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f441@_QIThunk@ATL@@UEAAJXZ


	.global ?f442@_QIThunk@ATL@@UEAAJXZ
	.proc	?f442@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f442@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=442*8,r14	// r14 = &m_pUnk->vtbl[442] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[442]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[442].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[442].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f442@_QIThunk@ATL@@UEAAJXZ


	.global ?f443@_QIThunk@ATL@@UEAAJXZ
	.proc	?f443@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f443@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=443*8,r14	// r14 = &m_pUnk->vtbl[443] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[443]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[443].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[443].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f443@_QIThunk@ATL@@UEAAJXZ


	.global ?f444@_QIThunk@ATL@@UEAAJXZ
	.proc	?f444@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f444@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=444*8,r14	// r14 = &m_pUnk->vtbl[444] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[444]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[444].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[444].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f444@_QIThunk@ATL@@UEAAJXZ


	.global ?f445@_QIThunk@ATL@@UEAAJXZ
	.proc	?f445@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f445@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=445*8,r14	// r14 = &m_pUnk->vtbl[445] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[445]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[445].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[445].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f445@_QIThunk@ATL@@UEAAJXZ


	.global ?f446@_QIThunk@ATL@@UEAAJXZ
	.proc	?f446@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f446@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=446*8,r14	// r14 = &m_pUnk->vtbl[446] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[446]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[446].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[446].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f446@_QIThunk@ATL@@UEAAJXZ


	.global ?f447@_QIThunk@ATL@@UEAAJXZ
	.proc	?f447@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f447@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=447*8,r14	// r14 = &m_pUnk->vtbl[447] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[447]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[447].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[447].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f447@_QIThunk@ATL@@UEAAJXZ


	.global ?f448@_QIThunk@ATL@@UEAAJXZ
	.proc	?f448@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f448@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=448*8,r14	// r14 = &m_pUnk->vtbl[448] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[448]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[448].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[448].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f448@_QIThunk@ATL@@UEAAJXZ


	.global ?f449@_QIThunk@ATL@@UEAAJXZ
	.proc	?f449@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f449@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=449*8,r14	// r14 = &m_pUnk->vtbl[449] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[449]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[449].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[449].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f449@_QIThunk@ATL@@UEAAJXZ


	.global ?f450@_QIThunk@ATL@@UEAAJXZ
	.proc	?f450@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f450@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=450*8,r14	// r14 = &m_pUnk->vtbl[450] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[450]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[450].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[450].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f450@_QIThunk@ATL@@UEAAJXZ


	.global ?f451@_QIThunk@ATL@@UEAAJXZ
	.proc	?f451@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f451@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=451*8,r14	// r14 = &m_pUnk->vtbl[451] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[451]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[451].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[451].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f451@_QIThunk@ATL@@UEAAJXZ


	.global ?f452@_QIThunk@ATL@@UEAAJXZ
	.proc	?f452@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f452@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=452*8,r14	// r14 = &m_pUnk->vtbl[452] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[452]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[452].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[452].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f452@_QIThunk@ATL@@UEAAJXZ


	.global ?f453@_QIThunk@ATL@@UEAAJXZ
	.proc	?f453@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f453@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=453*8,r14	// r14 = &m_pUnk->vtbl[453] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[453]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[453].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[453].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f453@_QIThunk@ATL@@UEAAJXZ


	.global ?f454@_QIThunk@ATL@@UEAAJXZ
	.proc	?f454@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f454@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=454*8,r14	// r14 = &m_pUnk->vtbl[454] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[454]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[454].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[454].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f454@_QIThunk@ATL@@UEAAJXZ


	.global ?f455@_QIThunk@ATL@@UEAAJXZ
	.proc	?f455@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f455@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=455*8,r14	// r14 = &m_pUnk->vtbl[455] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[455]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[455].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[455].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f455@_QIThunk@ATL@@UEAAJXZ


	.global ?f456@_QIThunk@ATL@@UEAAJXZ
	.proc	?f456@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f456@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=456*8,r14	// r14 = &m_pUnk->vtbl[456] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[456]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[456].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[456].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f456@_QIThunk@ATL@@UEAAJXZ


	.global ?f457@_QIThunk@ATL@@UEAAJXZ
	.proc	?f457@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f457@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=457*8,r14	// r14 = &m_pUnk->vtbl[457] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[457]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[457].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[457].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f457@_QIThunk@ATL@@UEAAJXZ


	.global ?f458@_QIThunk@ATL@@UEAAJXZ
	.proc	?f458@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f458@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=458*8,r14	// r14 = &m_pUnk->vtbl[458] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[458]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[458].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[458].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f458@_QIThunk@ATL@@UEAAJXZ


	.global ?f459@_QIThunk@ATL@@UEAAJXZ
	.proc	?f459@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f459@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=459*8,r14	// r14 = &m_pUnk->vtbl[459] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[459]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[459].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[459].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f459@_QIThunk@ATL@@UEAAJXZ


	.global ?f460@_QIThunk@ATL@@UEAAJXZ
	.proc	?f460@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f460@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=460*8,r14	// r14 = &m_pUnk->vtbl[460] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[460]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[460].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[460].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f460@_QIThunk@ATL@@UEAAJXZ


	.global ?f461@_QIThunk@ATL@@UEAAJXZ
	.proc	?f461@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f461@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=461*8,r14	// r14 = &m_pUnk->vtbl[461] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[461]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[461].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[461].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f461@_QIThunk@ATL@@UEAAJXZ


	.global ?f462@_QIThunk@ATL@@UEAAJXZ
	.proc	?f462@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f462@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=462*8,r14	// r14 = &m_pUnk->vtbl[462] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[462]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[462].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[462].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f462@_QIThunk@ATL@@UEAAJXZ


	.global ?f463@_QIThunk@ATL@@UEAAJXZ
	.proc	?f463@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f463@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=463*8,r14	// r14 = &m_pUnk->vtbl[463] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[463]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[463].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[463].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f463@_QIThunk@ATL@@UEAAJXZ


	.global ?f464@_QIThunk@ATL@@UEAAJXZ
	.proc	?f464@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f464@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=464*8,r14	// r14 = &m_pUnk->vtbl[464] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[464]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[464].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[464].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f464@_QIThunk@ATL@@UEAAJXZ


	.global ?f465@_QIThunk@ATL@@UEAAJXZ
	.proc	?f465@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f465@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=465*8,r14	// r14 = &m_pUnk->vtbl[465] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[465]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[465].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[465].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f465@_QIThunk@ATL@@UEAAJXZ


	.global ?f466@_QIThunk@ATL@@UEAAJXZ
	.proc	?f466@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f466@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=466*8,r14	// r14 = &m_pUnk->vtbl[466] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[466]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[466].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[466].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f466@_QIThunk@ATL@@UEAAJXZ


	.global ?f467@_QIThunk@ATL@@UEAAJXZ
	.proc	?f467@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f467@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=467*8,r14	// r14 = &m_pUnk->vtbl[467] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[467]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[467].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[467].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f467@_QIThunk@ATL@@UEAAJXZ


	.global ?f468@_QIThunk@ATL@@UEAAJXZ
	.proc	?f468@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f468@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=468*8,r14	// r14 = &m_pUnk->vtbl[468] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[468]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[468].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[468].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f468@_QIThunk@ATL@@UEAAJXZ


	.global ?f469@_QIThunk@ATL@@UEAAJXZ
	.proc	?f469@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f469@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=469*8,r14	// r14 = &m_pUnk->vtbl[469] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[469]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[469].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[469].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f469@_QIThunk@ATL@@UEAAJXZ


	.global ?f470@_QIThunk@ATL@@UEAAJXZ
	.proc	?f470@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f470@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=470*8,r14	// r14 = &m_pUnk->vtbl[470] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[470]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[470].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[470].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f470@_QIThunk@ATL@@UEAAJXZ


	.global ?f471@_QIThunk@ATL@@UEAAJXZ
	.proc	?f471@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f471@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=471*8,r14	// r14 = &m_pUnk->vtbl[471] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[471]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[471].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[471].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f471@_QIThunk@ATL@@UEAAJXZ


	.global ?f472@_QIThunk@ATL@@UEAAJXZ
	.proc	?f472@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f472@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=472*8,r14	// r14 = &m_pUnk->vtbl[472] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[472]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[472].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[472].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f472@_QIThunk@ATL@@UEAAJXZ


	.global ?f473@_QIThunk@ATL@@UEAAJXZ
	.proc	?f473@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f473@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=473*8,r14	// r14 = &m_pUnk->vtbl[473] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[473]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[473].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[473].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f473@_QIThunk@ATL@@UEAAJXZ


	.global ?f474@_QIThunk@ATL@@UEAAJXZ
	.proc	?f474@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f474@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=474*8,r14	// r14 = &m_pUnk->vtbl[474] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[474]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[474].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[474].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f474@_QIThunk@ATL@@UEAAJXZ


	.global ?f475@_QIThunk@ATL@@UEAAJXZ
	.proc	?f475@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f475@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=475*8,r14	// r14 = &m_pUnk->vtbl[475] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[475]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[475].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[475].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f475@_QIThunk@ATL@@UEAAJXZ


	.global ?f476@_QIThunk@ATL@@UEAAJXZ
	.proc	?f476@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f476@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=476*8,r14	// r14 = &m_pUnk->vtbl[476] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[476]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[476].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[476].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f476@_QIThunk@ATL@@UEAAJXZ


	.global ?f477@_QIThunk@ATL@@UEAAJXZ
	.proc	?f477@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f477@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=477*8,r14	// r14 = &m_pUnk->vtbl[477] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[477]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[477].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[477].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f477@_QIThunk@ATL@@UEAAJXZ


	.global ?f478@_QIThunk@ATL@@UEAAJXZ
	.proc	?f478@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f478@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=478*8,r14	// r14 = &m_pUnk->vtbl[478] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[478]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[478].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[478].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f478@_QIThunk@ATL@@UEAAJXZ


	.global ?f479@_QIThunk@ATL@@UEAAJXZ
	.proc	?f479@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f479@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=479*8,r14	// r14 = &m_pUnk->vtbl[479] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[479]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[479].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[479].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f479@_QIThunk@ATL@@UEAAJXZ


	.global ?f480@_QIThunk@ATL@@UEAAJXZ
	.proc	?f480@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f480@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=480*8,r14	// r14 = &m_pUnk->vtbl[480] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[480]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[480].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[480].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f480@_QIThunk@ATL@@UEAAJXZ


	.global ?f481@_QIThunk@ATL@@UEAAJXZ
	.proc	?f481@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f481@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=481*8,r14	// r14 = &m_pUnk->vtbl[481] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[481]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[481].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[481].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f481@_QIThunk@ATL@@UEAAJXZ


	.global ?f482@_QIThunk@ATL@@UEAAJXZ
	.proc	?f482@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f482@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=482*8,r14	// r14 = &m_pUnk->vtbl[482] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[482]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[482].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[482].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f482@_QIThunk@ATL@@UEAAJXZ


	.global ?f483@_QIThunk@ATL@@UEAAJXZ
	.proc	?f483@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f483@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=483*8,r14	// r14 = &m_pUnk->vtbl[483] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[483]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[483].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[483].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f483@_QIThunk@ATL@@UEAAJXZ


	.global ?f484@_QIThunk@ATL@@UEAAJXZ
	.proc	?f484@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f484@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=484*8,r14	// r14 = &m_pUnk->vtbl[484] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[484]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[484].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[484].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f484@_QIThunk@ATL@@UEAAJXZ


	.global ?f485@_QIThunk@ATL@@UEAAJXZ
	.proc	?f485@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f485@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=485*8,r14	// r14 = &m_pUnk->vtbl[485] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[485]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[485].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[485].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f485@_QIThunk@ATL@@UEAAJXZ


	.global ?f486@_QIThunk@ATL@@UEAAJXZ
	.proc	?f486@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f486@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=486*8,r14	// r14 = &m_pUnk->vtbl[486] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[486]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[486].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[486].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f486@_QIThunk@ATL@@UEAAJXZ


	.global ?f487@_QIThunk@ATL@@UEAAJXZ
	.proc	?f487@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f487@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=487*8,r14	// r14 = &m_pUnk->vtbl[487] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[487]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[487].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[487].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f487@_QIThunk@ATL@@UEAAJXZ


	.global ?f488@_QIThunk@ATL@@UEAAJXZ
	.proc	?f488@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f488@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=488*8,r14	// r14 = &m_pUnk->vtbl[488] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[488]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[488].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[488].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f488@_QIThunk@ATL@@UEAAJXZ


	.global ?f489@_QIThunk@ATL@@UEAAJXZ
	.proc	?f489@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f489@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=489*8,r14	// r14 = &m_pUnk->vtbl[489] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[489]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[489].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[489].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f489@_QIThunk@ATL@@UEAAJXZ


	.global ?f490@_QIThunk@ATL@@UEAAJXZ
	.proc	?f490@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f490@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=490*8,r14	// r14 = &m_pUnk->vtbl[490] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[490]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[490].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[490].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f490@_QIThunk@ATL@@UEAAJXZ


	.global ?f491@_QIThunk@ATL@@UEAAJXZ
	.proc	?f491@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f491@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=491*8,r14	// r14 = &m_pUnk->vtbl[491] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[491]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[491].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[491].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f491@_QIThunk@ATL@@UEAAJXZ


	.global ?f492@_QIThunk@ATL@@UEAAJXZ
	.proc	?f492@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f492@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=492*8,r14	// r14 = &m_pUnk->vtbl[492] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[492]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[492].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[492].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f492@_QIThunk@ATL@@UEAAJXZ


	.global ?f493@_QIThunk@ATL@@UEAAJXZ
	.proc	?f493@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f493@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=493*8,r14	// r14 = &m_pUnk->vtbl[493] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[493]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[493].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[493].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f493@_QIThunk@ATL@@UEAAJXZ


	.global ?f494@_QIThunk@ATL@@UEAAJXZ
	.proc	?f494@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f494@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=494*8,r14	// r14 = &m_pUnk->vtbl[494] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[494]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[494].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[494].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f494@_QIThunk@ATL@@UEAAJXZ


	.global ?f495@_QIThunk@ATL@@UEAAJXZ
	.proc	?f495@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f495@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=495*8,r14	// r14 = &m_pUnk->vtbl[495] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[495]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[495].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[495].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f495@_QIThunk@ATL@@UEAAJXZ


	.global ?f496@_QIThunk@ATL@@UEAAJXZ
	.proc	?f496@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f496@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=496*8,r14	// r14 = &m_pUnk->vtbl[496] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[496]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[496].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[496].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f496@_QIThunk@ATL@@UEAAJXZ


	.global ?f497@_QIThunk@ATL@@UEAAJXZ
	.proc	?f497@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f497@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=497*8,r14	// r14 = &m_pUnk->vtbl[497] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[497]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[497].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[497].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f497@_QIThunk@ATL@@UEAAJXZ


	.global ?f498@_QIThunk@ATL@@UEAAJXZ
	.proc	?f498@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f498@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=498*8,r14	// r14 = &m_pUnk->vtbl[498] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[498]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[498].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[498].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f498@_QIThunk@ATL@@UEAAJXZ


	.global ?f499@_QIThunk@ATL@@UEAAJXZ
	.proc	?f499@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f499@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=499*8,r14	// r14 = &m_pUnk->vtbl[499] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[499]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[499].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[499].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f499@_QIThunk@ATL@@UEAAJXZ


	.global ?f500@_QIThunk@ATL@@UEAAJXZ
	.proc	?f500@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f500@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=500*8,r14	// r14 = &m_pUnk->vtbl[500] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[500]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[500].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[500].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f500@_QIThunk@ATL@@UEAAJXZ


	.global ?f501@_QIThunk@ATL@@UEAAJXZ
	.proc	?f501@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f501@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=501*8,r14	// r14 = &m_pUnk->vtbl[501] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[501]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[501].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[501].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f501@_QIThunk@ATL@@UEAAJXZ


	.global ?f502@_QIThunk@ATL@@UEAAJXZ
	.proc	?f502@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f502@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=502*8,r14	// r14 = &m_pUnk->vtbl[502] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[502]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[502].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[502].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f502@_QIThunk@ATL@@UEAAJXZ


	.global ?f503@_QIThunk@ATL@@UEAAJXZ
	.proc	?f503@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f503@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=503*8,r14	// r14 = &m_pUnk->vtbl[503] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[503]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[503].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[503].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f503@_QIThunk@ATL@@UEAAJXZ


	.global ?f504@_QIThunk@ATL@@UEAAJXZ
	.proc	?f504@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f504@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=504*8,r14	// r14 = &m_pUnk->vtbl[504] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[504]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[504].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[504].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f504@_QIThunk@ATL@@UEAAJXZ


	.global ?f505@_QIThunk@ATL@@UEAAJXZ
	.proc	?f505@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f505@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=505*8,r14	// r14 = &m_pUnk->vtbl[505] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[505]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[505].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[505].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f505@_QIThunk@ATL@@UEAAJXZ


	.global ?f506@_QIThunk@ATL@@UEAAJXZ
	.proc	?f506@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f506@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=506*8,r14	// r14 = &m_pUnk->vtbl[506] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[506]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[506].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[506].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f506@_QIThunk@ATL@@UEAAJXZ


	.global ?f507@_QIThunk@ATL@@UEAAJXZ
	.proc	?f507@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f507@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=507*8,r14	// r14 = &m_pUnk->vtbl[507] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[507]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[507].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[507].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f507@_QIThunk@ATL@@UEAAJXZ


	.global ?f508@_QIThunk@ATL@@UEAAJXZ
	.proc	?f508@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f508@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=508*8,r14	// r14 = &m_pUnk->vtbl[508] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[508]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[508].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[508].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f508@_QIThunk@ATL@@UEAAJXZ


	.global ?f509@_QIThunk@ATL@@UEAAJXZ
	.proc	?f509@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f509@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=509*8,r14	// r14 = &m_pUnk->vtbl[509] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[509]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[509].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[509].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f509@_QIThunk@ATL@@UEAAJXZ


	.global ?f510@_QIThunk@ATL@@UEAAJXZ
	.proc	?f510@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f510@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=510*8,r14	// r14 = &m_pUnk->vtbl[510] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[510]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[510].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[510].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f510@_QIThunk@ATL@@UEAAJXZ


	.global ?f511@_QIThunk@ATL@@UEAAJXZ
	.proc	?f511@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f511@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=511*8,r14	// r14 = &m_pUnk->vtbl[511] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[511]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[511].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[511].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f511@_QIThunk@ATL@@UEAAJXZ


	.global ?f512@_QIThunk@ATL@@UEAAJXZ
	.proc	?f512@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f512@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=512*8,r14	// r14 = &m_pUnk->vtbl[512] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[512]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[512].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[512].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f512@_QIThunk@ATL@@UEAAJXZ


	.global ?f513@_QIThunk@ATL@@UEAAJXZ
	.proc	?f513@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f513@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=513*8,r14	// r14 = &m_pUnk->vtbl[513] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[513]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[513].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[513].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f513@_QIThunk@ATL@@UEAAJXZ


	.global ?f514@_QIThunk@ATL@@UEAAJXZ
	.proc	?f514@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f514@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=514*8,r14	// r14 = &m_pUnk->vtbl[514] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[514]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[514].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[514].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f514@_QIThunk@ATL@@UEAAJXZ


	.global ?f515@_QIThunk@ATL@@UEAAJXZ
	.proc	?f515@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f515@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=515*8,r14	// r14 = &m_pUnk->vtbl[515] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[515]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[515].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[515].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f515@_QIThunk@ATL@@UEAAJXZ


	.global ?f516@_QIThunk@ATL@@UEAAJXZ
	.proc	?f516@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f516@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=516*8,r14	// r14 = &m_pUnk->vtbl[516] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[516]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[516].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[516].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f516@_QIThunk@ATL@@UEAAJXZ


	.global ?f517@_QIThunk@ATL@@UEAAJXZ
	.proc	?f517@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f517@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=517*8,r14	// r14 = &m_pUnk->vtbl[517] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[517]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[517].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[517].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f517@_QIThunk@ATL@@UEAAJXZ


	.global ?f518@_QIThunk@ATL@@UEAAJXZ
	.proc	?f518@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f518@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=518*8,r14	// r14 = &m_pUnk->vtbl[518] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[518]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[518].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[518].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f518@_QIThunk@ATL@@UEAAJXZ


	.global ?f519@_QIThunk@ATL@@UEAAJXZ
	.proc	?f519@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f519@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=519*8,r14	// r14 = &m_pUnk->vtbl[519] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[519]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[519].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[519].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f519@_QIThunk@ATL@@UEAAJXZ


	.global ?f520@_QIThunk@ATL@@UEAAJXZ
	.proc	?f520@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f520@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=520*8,r14	// r14 = &m_pUnk->vtbl[520] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[520]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[520].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[520].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f520@_QIThunk@ATL@@UEAAJXZ


	.global ?f521@_QIThunk@ATL@@UEAAJXZ
	.proc	?f521@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f521@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=521*8,r14	// r14 = &m_pUnk->vtbl[521] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[521]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[521].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[521].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f521@_QIThunk@ATL@@UEAAJXZ


	.global ?f522@_QIThunk@ATL@@UEAAJXZ
	.proc	?f522@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f522@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=522*8,r14	// r14 = &m_pUnk->vtbl[522] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[522]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[522].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[522].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f522@_QIThunk@ATL@@UEAAJXZ


	.global ?f523@_QIThunk@ATL@@UEAAJXZ
	.proc	?f523@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f523@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=523*8,r14	// r14 = &m_pUnk->vtbl[523] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[523]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[523].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[523].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f523@_QIThunk@ATL@@UEAAJXZ


	.global ?f524@_QIThunk@ATL@@UEAAJXZ
	.proc	?f524@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f524@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=524*8,r14	// r14 = &m_pUnk->vtbl[524] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[524]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[524].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[524].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f524@_QIThunk@ATL@@UEAAJXZ


	.global ?f525@_QIThunk@ATL@@UEAAJXZ
	.proc	?f525@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f525@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=525*8,r14	// r14 = &m_pUnk->vtbl[525] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[525]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[525].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[525].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f525@_QIThunk@ATL@@UEAAJXZ


	.global ?f526@_QIThunk@ATL@@UEAAJXZ
	.proc	?f526@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f526@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=526*8,r14	// r14 = &m_pUnk->vtbl[526] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[526]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[526].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[526].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f526@_QIThunk@ATL@@UEAAJXZ


	.global ?f527@_QIThunk@ATL@@UEAAJXZ
	.proc	?f527@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f527@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=527*8,r14	// r14 = &m_pUnk->vtbl[527] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[527]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[527].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[527].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f527@_QIThunk@ATL@@UEAAJXZ


	.global ?f528@_QIThunk@ATL@@UEAAJXZ
	.proc	?f528@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f528@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=528*8,r14	// r14 = &m_pUnk->vtbl[528] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[528]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[528].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[528].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f528@_QIThunk@ATL@@UEAAJXZ


	.global ?f529@_QIThunk@ATL@@UEAAJXZ
	.proc	?f529@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f529@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=529*8,r14	// r14 = &m_pUnk->vtbl[529] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[529]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[529].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[529].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f529@_QIThunk@ATL@@UEAAJXZ


	.global ?f530@_QIThunk@ATL@@UEAAJXZ
	.proc	?f530@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f530@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=530*8,r14	// r14 = &m_pUnk->vtbl[530] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[530]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[530].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[530].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f530@_QIThunk@ATL@@UEAAJXZ


	.global ?f531@_QIThunk@ATL@@UEAAJXZ
	.proc	?f531@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f531@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=531*8,r14	// r14 = &m_pUnk->vtbl[531] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[531]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[531].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[531].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f531@_QIThunk@ATL@@UEAAJXZ


	.global ?f532@_QIThunk@ATL@@UEAAJXZ
	.proc	?f532@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f532@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=532*8,r14	// r14 = &m_pUnk->vtbl[532] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[532]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[532].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[532].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f532@_QIThunk@ATL@@UEAAJXZ


	.global ?f533@_QIThunk@ATL@@UEAAJXZ
	.proc	?f533@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f533@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=533*8,r14	// r14 = &m_pUnk->vtbl[533] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[533]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[533].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[533].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f533@_QIThunk@ATL@@UEAAJXZ


	.global ?f534@_QIThunk@ATL@@UEAAJXZ
	.proc	?f534@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f534@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=534*8,r14	// r14 = &m_pUnk->vtbl[534] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[534]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[534].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[534].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f534@_QIThunk@ATL@@UEAAJXZ


	.global ?f535@_QIThunk@ATL@@UEAAJXZ
	.proc	?f535@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f535@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=535*8,r14	// r14 = &m_pUnk->vtbl[535] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[535]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[535].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[535].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f535@_QIThunk@ATL@@UEAAJXZ


	.global ?f536@_QIThunk@ATL@@UEAAJXZ
	.proc	?f536@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f536@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=536*8,r14	// r14 = &m_pUnk->vtbl[536] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[536]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[536].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[536].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f536@_QIThunk@ATL@@UEAAJXZ


	.global ?f537@_QIThunk@ATL@@UEAAJXZ
	.proc	?f537@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f537@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=537*8,r14	// r14 = &m_pUnk->vtbl[537] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[537]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[537].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[537].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f537@_QIThunk@ATL@@UEAAJXZ


	.global ?f538@_QIThunk@ATL@@UEAAJXZ
	.proc	?f538@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f538@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=538*8,r14	// r14 = &m_pUnk->vtbl[538] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[538]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[538].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[538].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f538@_QIThunk@ATL@@UEAAJXZ


	.global ?f539@_QIThunk@ATL@@UEAAJXZ
	.proc	?f539@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f539@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=539*8,r14	// r14 = &m_pUnk->vtbl[539] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[539]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[539].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[539].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f539@_QIThunk@ATL@@UEAAJXZ


	.global ?f540@_QIThunk@ATL@@UEAAJXZ
	.proc	?f540@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f540@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=540*8,r14	// r14 = &m_pUnk->vtbl[540] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[540]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[540].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[540].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f540@_QIThunk@ATL@@UEAAJXZ


	.global ?f541@_QIThunk@ATL@@UEAAJXZ
	.proc	?f541@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f541@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=541*8,r14	// r14 = &m_pUnk->vtbl[541] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[541]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[541].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[541].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f541@_QIThunk@ATL@@UEAAJXZ


	.global ?f542@_QIThunk@ATL@@UEAAJXZ
	.proc	?f542@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f542@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=542*8,r14	// r14 = &m_pUnk->vtbl[542] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[542]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[542].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[542].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f542@_QIThunk@ATL@@UEAAJXZ


	.global ?f543@_QIThunk@ATL@@UEAAJXZ
	.proc	?f543@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f543@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=543*8,r14	// r14 = &m_pUnk->vtbl[543] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[543]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[543].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[543].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f543@_QIThunk@ATL@@UEAAJXZ


	.global ?f544@_QIThunk@ATL@@UEAAJXZ
	.proc	?f544@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f544@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=544*8,r14	// r14 = &m_pUnk->vtbl[544] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[544]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[544].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[544].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f544@_QIThunk@ATL@@UEAAJXZ


	.global ?f545@_QIThunk@ATL@@UEAAJXZ
	.proc	?f545@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f545@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=545*8,r14	// r14 = &m_pUnk->vtbl[545] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[545]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[545].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[545].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f545@_QIThunk@ATL@@UEAAJXZ


	.global ?f546@_QIThunk@ATL@@UEAAJXZ
	.proc	?f546@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f546@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=546*8,r14	// r14 = &m_pUnk->vtbl[546] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[546]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[546].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[546].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f546@_QIThunk@ATL@@UEAAJXZ


	.global ?f547@_QIThunk@ATL@@UEAAJXZ
	.proc	?f547@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f547@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=547*8,r14	// r14 = &m_pUnk->vtbl[547] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[547]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[547].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[547].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f547@_QIThunk@ATL@@UEAAJXZ


	.global ?f548@_QIThunk@ATL@@UEAAJXZ
	.proc	?f548@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f548@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=548*8,r14	// r14 = &m_pUnk->vtbl[548] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[548]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[548].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[548].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f548@_QIThunk@ATL@@UEAAJXZ


	.global ?f549@_QIThunk@ATL@@UEAAJXZ
	.proc	?f549@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f549@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=549*8,r14	// r14 = &m_pUnk->vtbl[549] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[549]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[549].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[549].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f549@_QIThunk@ATL@@UEAAJXZ


	.global ?f550@_QIThunk@ATL@@UEAAJXZ
	.proc	?f550@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f550@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=550*8,r14	// r14 = &m_pUnk->vtbl[550] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[550]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[550].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[550].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f550@_QIThunk@ATL@@UEAAJXZ


	.global ?f551@_QIThunk@ATL@@UEAAJXZ
	.proc	?f551@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f551@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=551*8,r14	// r14 = &m_pUnk->vtbl[551] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[551]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[551].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[551].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f551@_QIThunk@ATL@@UEAAJXZ


	.global ?f552@_QIThunk@ATL@@UEAAJXZ
	.proc	?f552@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f552@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=552*8,r14	// r14 = &m_pUnk->vtbl[552] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[552]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[552].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[552].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f552@_QIThunk@ATL@@UEAAJXZ


	.global ?f553@_QIThunk@ATL@@UEAAJXZ
	.proc	?f553@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f553@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=553*8,r14	// r14 = &m_pUnk->vtbl[553] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[553]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[553].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[553].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f553@_QIThunk@ATL@@UEAAJXZ


	.global ?f554@_QIThunk@ATL@@UEAAJXZ
	.proc	?f554@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f554@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=554*8,r14	// r14 = &m_pUnk->vtbl[554] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[554]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[554].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[554].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f554@_QIThunk@ATL@@UEAAJXZ


	.global ?f555@_QIThunk@ATL@@UEAAJXZ
	.proc	?f555@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f555@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=555*8,r14	// r14 = &m_pUnk->vtbl[555] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[555]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[555].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[555].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f555@_QIThunk@ATL@@UEAAJXZ


	.global ?f556@_QIThunk@ATL@@UEAAJXZ
	.proc	?f556@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f556@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=556*8,r14	// r14 = &m_pUnk->vtbl[556] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[556]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[556].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[556].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f556@_QIThunk@ATL@@UEAAJXZ


	.global ?f557@_QIThunk@ATL@@UEAAJXZ
	.proc	?f557@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f557@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=557*8,r14	// r14 = &m_pUnk->vtbl[557] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[557]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[557].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[557].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f557@_QIThunk@ATL@@UEAAJXZ


	.global ?f558@_QIThunk@ATL@@UEAAJXZ
	.proc	?f558@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f558@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=558*8,r14	// r14 = &m_pUnk->vtbl[558] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[558]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[558].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[558].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f558@_QIThunk@ATL@@UEAAJXZ


	.global ?f559@_QIThunk@ATL@@UEAAJXZ
	.proc	?f559@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f559@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=559*8,r14	// r14 = &m_pUnk->vtbl[559] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[559]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[559].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[559].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f559@_QIThunk@ATL@@UEAAJXZ


	.global ?f560@_QIThunk@ATL@@UEAAJXZ
	.proc	?f560@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f560@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=560*8,r14	// r14 = &m_pUnk->vtbl[560] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[560]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[560].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[560].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f560@_QIThunk@ATL@@UEAAJXZ


	.global ?f561@_QIThunk@ATL@@UEAAJXZ
	.proc	?f561@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f561@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=561*8,r14	// r14 = &m_pUnk->vtbl[561] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[561]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[561].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[561].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f561@_QIThunk@ATL@@UEAAJXZ


	.global ?f562@_QIThunk@ATL@@UEAAJXZ
	.proc	?f562@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f562@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=562*8,r14	// r14 = &m_pUnk->vtbl[562] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[562]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[562].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[562].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f562@_QIThunk@ATL@@UEAAJXZ


	.global ?f563@_QIThunk@ATL@@UEAAJXZ
	.proc	?f563@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f563@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=563*8,r14	// r14 = &m_pUnk->vtbl[563] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[563]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[563].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[563].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f563@_QIThunk@ATL@@UEAAJXZ


	.global ?f564@_QIThunk@ATL@@UEAAJXZ
	.proc	?f564@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f564@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=564*8,r14	// r14 = &m_pUnk->vtbl[564] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[564]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[564].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[564].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f564@_QIThunk@ATL@@UEAAJXZ


	.global ?f565@_QIThunk@ATL@@UEAAJXZ
	.proc	?f565@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f565@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=565*8,r14	// r14 = &m_pUnk->vtbl[565] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[565]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[565].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[565].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f565@_QIThunk@ATL@@UEAAJXZ


	.global ?f566@_QIThunk@ATL@@UEAAJXZ
	.proc	?f566@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f566@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=566*8,r14	// r14 = &m_pUnk->vtbl[566] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[566]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[566].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[566].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f566@_QIThunk@ATL@@UEAAJXZ


	.global ?f567@_QIThunk@ATL@@UEAAJXZ
	.proc	?f567@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f567@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=567*8,r14	// r14 = &m_pUnk->vtbl[567] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[567]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[567].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[567].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f567@_QIThunk@ATL@@UEAAJXZ


	.global ?f568@_QIThunk@ATL@@UEAAJXZ
	.proc	?f568@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f568@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=568*8,r14	// r14 = &m_pUnk->vtbl[568] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[568]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[568].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[568].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f568@_QIThunk@ATL@@UEAAJXZ


	.global ?f569@_QIThunk@ATL@@UEAAJXZ
	.proc	?f569@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f569@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=569*8,r14	// r14 = &m_pUnk->vtbl[569] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[569]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[569].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[569].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f569@_QIThunk@ATL@@UEAAJXZ


	.global ?f570@_QIThunk@ATL@@UEAAJXZ
	.proc	?f570@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f570@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=570*8,r14	// r14 = &m_pUnk->vtbl[570] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[570]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[570].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[570].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f570@_QIThunk@ATL@@UEAAJXZ


	.global ?f571@_QIThunk@ATL@@UEAAJXZ
	.proc	?f571@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f571@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=571*8,r14	// r14 = &m_pUnk->vtbl[571] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[571]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[571].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[571].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f571@_QIThunk@ATL@@UEAAJXZ


	.global ?f572@_QIThunk@ATL@@UEAAJXZ
	.proc	?f572@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f572@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=572*8,r14	// r14 = &m_pUnk->vtbl[572] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[572]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[572].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[572].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f572@_QIThunk@ATL@@UEAAJXZ


	.global ?f573@_QIThunk@ATL@@UEAAJXZ
	.proc	?f573@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f573@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=573*8,r14	// r14 = &m_pUnk->vtbl[573] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[573]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[573].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[573].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f573@_QIThunk@ATL@@UEAAJXZ


	.global ?f574@_QIThunk@ATL@@UEAAJXZ
	.proc	?f574@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f574@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=574*8,r14	// r14 = &m_pUnk->vtbl[574] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[574]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[574].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[574].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f574@_QIThunk@ATL@@UEAAJXZ


	.global ?f575@_QIThunk@ATL@@UEAAJXZ
	.proc	?f575@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f575@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=575*8,r14	// r14 = &m_pUnk->vtbl[575] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[575]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[575].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[575].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f575@_QIThunk@ATL@@UEAAJXZ


	.global ?f576@_QIThunk@ATL@@UEAAJXZ
	.proc	?f576@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f576@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=576*8,r14	// r14 = &m_pUnk->vtbl[576] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[576]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[576].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[576].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f576@_QIThunk@ATL@@UEAAJXZ


	.global ?f577@_QIThunk@ATL@@UEAAJXZ
	.proc	?f577@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f577@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=577*8,r14	// r14 = &m_pUnk->vtbl[577] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[577]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[577].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[577].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f577@_QIThunk@ATL@@UEAAJXZ


	.global ?f578@_QIThunk@ATL@@UEAAJXZ
	.proc	?f578@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f578@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=578*8,r14	// r14 = &m_pUnk->vtbl[578] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[578]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[578].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[578].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f578@_QIThunk@ATL@@UEAAJXZ


	.global ?f579@_QIThunk@ATL@@UEAAJXZ
	.proc	?f579@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f579@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=579*8,r14	// r14 = &m_pUnk->vtbl[579] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[579]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[579].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[579].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f579@_QIThunk@ATL@@UEAAJXZ


	.global ?f580@_QIThunk@ATL@@UEAAJXZ
	.proc	?f580@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f580@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=580*8,r14	// r14 = &m_pUnk->vtbl[580] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[580]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[580].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[580].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f580@_QIThunk@ATL@@UEAAJXZ


	.global ?f581@_QIThunk@ATL@@UEAAJXZ
	.proc	?f581@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f581@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=581*8,r14	// r14 = &m_pUnk->vtbl[581] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[581]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[581].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[581].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f581@_QIThunk@ATL@@UEAAJXZ


	.global ?f582@_QIThunk@ATL@@UEAAJXZ
	.proc	?f582@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f582@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=582*8,r14	// r14 = &m_pUnk->vtbl[582] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[582]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[582].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[582].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f582@_QIThunk@ATL@@UEAAJXZ


	.global ?f583@_QIThunk@ATL@@UEAAJXZ
	.proc	?f583@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f583@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=583*8,r14	// r14 = &m_pUnk->vtbl[583] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[583]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[583].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[583].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f583@_QIThunk@ATL@@UEAAJXZ


	.global ?f584@_QIThunk@ATL@@UEAAJXZ
	.proc	?f584@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f584@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=584*8,r14	// r14 = &m_pUnk->vtbl[584] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[584]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[584].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[584].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f584@_QIThunk@ATL@@UEAAJXZ


	.global ?f585@_QIThunk@ATL@@UEAAJXZ
	.proc	?f585@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f585@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=585*8,r14	// r14 = &m_pUnk->vtbl[585] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[585]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[585].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[585].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f585@_QIThunk@ATL@@UEAAJXZ


	.global ?f586@_QIThunk@ATL@@UEAAJXZ
	.proc	?f586@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f586@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=586*8,r14	// r14 = &m_pUnk->vtbl[586] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[586]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[586].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[586].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f586@_QIThunk@ATL@@UEAAJXZ


	.global ?f587@_QIThunk@ATL@@UEAAJXZ
	.proc	?f587@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f587@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=587*8,r14	// r14 = &m_pUnk->vtbl[587] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[587]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[587].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[587].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f587@_QIThunk@ATL@@UEAAJXZ


	.global ?f588@_QIThunk@ATL@@UEAAJXZ
	.proc	?f588@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f588@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=588*8,r14	// r14 = &m_pUnk->vtbl[588] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[588]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[588].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[588].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f588@_QIThunk@ATL@@UEAAJXZ


	.global ?f589@_QIThunk@ATL@@UEAAJXZ
	.proc	?f589@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f589@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=589*8,r14	// r14 = &m_pUnk->vtbl[589] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[589]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[589].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[589].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f589@_QIThunk@ATL@@UEAAJXZ


	.global ?f590@_QIThunk@ATL@@UEAAJXZ
	.proc	?f590@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f590@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=590*8,r14	// r14 = &m_pUnk->vtbl[590] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[590]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[590].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[590].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f590@_QIThunk@ATL@@UEAAJXZ


	.global ?f591@_QIThunk@ATL@@UEAAJXZ
	.proc	?f591@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f591@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=591*8,r14	// r14 = &m_pUnk->vtbl[591] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[591]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[591].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[591].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f591@_QIThunk@ATL@@UEAAJXZ


	.global ?f592@_QIThunk@ATL@@UEAAJXZ
	.proc	?f592@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f592@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=592*8,r14	// r14 = &m_pUnk->vtbl[592] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[592]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[592].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[592].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f592@_QIThunk@ATL@@UEAAJXZ


	.global ?f593@_QIThunk@ATL@@UEAAJXZ
	.proc	?f593@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f593@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=593*8,r14	// r14 = &m_pUnk->vtbl[593] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[593]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[593].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[593].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f593@_QIThunk@ATL@@UEAAJXZ


	.global ?f594@_QIThunk@ATL@@UEAAJXZ
	.proc	?f594@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f594@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=594*8,r14	// r14 = &m_pUnk->vtbl[594] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[594]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[594].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[594].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f594@_QIThunk@ATL@@UEAAJXZ


	.global ?f595@_QIThunk@ATL@@UEAAJXZ
	.proc	?f595@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f595@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=595*8,r14	// r14 = &m_pUnk->vtbl[595] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[595]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[595].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[595].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f595@_QIThunk@ATL@@UEAAJXZ


	.global ?f596@_QIThunk@ATL@@UEAAJXZ
	.proc	?f596@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f596@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=596*8,r14	// r14 = &m_pUnk->vtbl[596] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[596]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[596].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[596].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f596@_QIThunk@ATL@@UEAAJXZ


	.global ?f597@_QIThunk@ATL@@UEAAJXZ
	.proc	?f597@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f597@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=597*8,r14	// r14 = &m_pUnk->vtbl[597] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[597]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[597].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[597].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f597@_QIThunk@ATL@@UEAAJXZ


	.global ?f598@_QIThunk@ATL@@UEAAJXZ
	.proc	?f598@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f598@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=598*8,r14	// r14 = &m_pUnk->vtbl[598] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[598]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[598].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[598].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f598@_QIThunk@ATL@@UEAAJXZ


	.global ?f599@_QIThunk@ATL@@UEAAJXZ
	.proc	?f599@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f599@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=599*8,r14	// r14 = &m_pUnk->vtbl[599] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[599]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[599].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[599].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f599@_QIThunk@ATL@@UEAAJXZ


	.global ?f600@_QIThunk@ATL@@UEAAJXZ
	.proc	?f600@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f600@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=600*8,r14	// r14 = &m_pUnk->vtbl[600] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[600]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[600].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[600].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f600@_QIThunk@ATL@@UEAAJXZ


	.global ?f601@_QIThunk@ATL@@UEAAJXZ
	.proc	?f601@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f601@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=601*8,r14	// r14 = &m_pUnk->vtbl[601] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[601]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[601].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[601].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f601@_QIThunk@ATL@@UEAAJXZ


	.global ?f602@_QIThunk@ATL@@UEAAJXZ
	.proc	?f602@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f602@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=602*8,r14	// r14 = &m_pUnk->vtbl[602] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[602]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[602].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[602].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f602@_QIThunk@ATL@@UEAAJXZ


	.global ?f603@_QIThunk@ATL@@UEAAJXZ
	.proc	?f603@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f603@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=603*8,r14	// r14 = &m_pUnk->vtbl[603] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[603]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[603].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[603].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f603@_QIThunk@ATL@@UEAAJXZ


	.global ?f604@_QIThunk@ATL@@UEAAJXZ
	.proc	?f604@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f604@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=604*8,r14	// r14 = &m_pUnk->vtbl[604] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[604]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[604].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[604].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f604@_QIThunk@ATL@@UEAAJXZ


	.global ?f605@_QIThunk@ATL@@UEAAJXZ
	.proc	?f605@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f605@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=605*8,r14	// r14 = &m_pUnk->vtbl[605] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[605]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[605].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[605].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f605@_QIThunk@ATL@@UEAAJXZ


	.global ?f606@_QIThunk@ATL@@UEAAJXZ
	.proc	?f606@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f606@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=606*8,r14	// r14 = &m_pUnk->vtbl[606] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[606]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[606].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[606].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f606@_QIThunk@ATL@@UEAAJXZ


	.global ?f607@_QIThunk@ATL@@UEAAJXZ
	.proc	?f607@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f607@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=607*8,r14	// r14 = &m_pUnk->vtbl[607] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[607]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[607].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[607].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f607@_QIThunk@ATL@@UEAAJXZ


	.global ?f608@_QIThunk@ATL@@UEAAJXZ
	.proc	?f608@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f608@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=608*8,r14	// r14 = &m_pUnk->vtbl[608] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[608]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[608].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[608].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f608@_QIThunk@ATL@@UEAAJXZ


	.global ?f609@_QIThunk@ATL@@UEAAJXZ
	.proc	?f609@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f609@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=609*8,r14	// r14 = &m_pUnk->vtbl[609] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[609]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[609].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[609].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f609@_QIThunk@ATL@@UEAAJXZ


	.global ?f610@_QIThunk@ATL@@UEAAJXZ
	.proc	?f610@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f610@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=610*8,r14	// r14 = &m_pUnk->vtbl[610] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[610]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[610].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[610].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f610@_QIThunk@ATL@@UEAAJXZ


	.global ?f611@_QIThunk@ATL@@UEAAJXZ
	.proc	?f611@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f611@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=611*8,r14	// r14 = &m_pUnk->vtbl[611] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[611]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[611].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[611].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f611@_QIThunk@ATL@@UEAAJXZ


	.global ?f612@_QIThunk@ATL@@UEAAJXZ
	.proc	?f612@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f612@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=612*8,r14	// r14 = &m_pUnk->vtbl[612] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[612]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[612].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[612].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f612@_QIThunk@ATL@@UEAAJXZ


	.global ?f613@_QIThunk@ATL@@UEAAJXZ
	.proc	?f613@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f613@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=613*8,r14	// r14 = &m_pUnk->vtbl[613] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[613]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[613].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[613].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f613@_QIThunk@ATL@@UEAAJXZ


	.global ?f614@_QIThunk@ATL@@UEAAJXZ
	.proc	?f614@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f614@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=614*8,r14	// r14 = &m_pUnk->vtbl[614] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[614]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[614].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[614].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f614@_QIThunk@ATL@@UEAAJXZ


	.global ?f615@_QIThunk@ATL@@UEAAJXZ
	.proc	?f615@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f615@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=615*8,r14	// r14 = &m_pUnk->vtbl[615] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[615]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[615].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[615].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f615@_QIThunk@ATL@@UEAAJXZ


	.global ?f616@_QIThunk@ATL@@UEAAJXZ
	.proc	?f616@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f616@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=616*8,r14	// r14 = &m_pUnk->vtbl[616] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[616]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[616].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[616].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f616@_QIThunk@ATL@@UEAAJXZ


	.global ?f617@_QIThunk@ATL@@UEAAJXZ
	.proc	?f617@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f617@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=617*8,r14	// r14 = &m_pUnk->vtbl[617] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[617]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[617].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[617].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f617@_QIThunk@ATL@@UEAAJXZ


	.global ?f618@_QIThunk@ATL@@UEAAJXZ
	.proc	?f618@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f618@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=618*8,r14	// r14 = &m_pUnk->vtbl[618] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[618]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[618].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[618].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f618@_QIThunk@ATL@@UEAAJXZ


	.global ?f619@_QIThunk@ATL@@UEAAJXZ
	.proc	?f619@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f619@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=619*8,r14	// r14 = &m_pUnk->vtbl[619] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[619]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[619].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[619].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f619@_QIThunk@ATL@@UEAAJXZ


	.global ?f620@_QIThunk@ATL@@UEAAJXZ
	.proc	?f620@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f620@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=620*8,r14	// r14 = &m_pUnk->vtbl[620] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[620]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[620].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[620].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f620@_QIThunk@ATL@@UEAAJXZ


	.global ?f621@_QIThunk@ATL@@UEAAJXZ
	.proc	?f621@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f621@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=621*8,r14	// r14 = &m_pUnk->vtbl[621] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[621]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[621].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[621].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f621@_QIThunk@ATL@@UEAAJXZ


	.global ?f622@_QIThunk@ATL@@UEAAJXZ
	.proc	?f622@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f622@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=622*8,r14	// r14 = &m_pUnk->vtbl[622] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[622]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[622].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[622].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f622@_QIThunk@ATL@@UEAAJXZ


	.global ?f623@_QIThunk@ATL@@UEAAJXZ
	.proc	?f623@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f623@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=623*8,r14	// r14 = &m_pUnk->vtbl[623] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[623]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[623].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[623].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f623@_QIThunk@ATL@@UEAAJXZ


	.global ?f624@_QIThunk@ATL@@UEAAJXZ
	.proc	?f624@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f624@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=624*8,r14	// r14 = &m_pUnk->vtbl[624] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[624]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[624].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[624].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f624@_QIThunk@ATL@@UEAAJXZ


	.global ?f625@_QIThunk@ATL@@UEAAJXZ
	.proc	?f625@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f625@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=625*8,r14	// r14 = &m_pUnk->vtbl[625] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[625]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[625].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[625].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f625@_QIThunk@ATL@@UEAAJXZ


	.global ?f626@_QIThunk@ATL@@UEAAJXZ
	.proc	?f626@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f626@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=626*8,r14	// r14 = &m_pUnk->vtbl[626] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[626]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[626].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[626].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f626@_QIThunk@ATL@@UEAAJXZ


	.global ?f627@_QIThunk@ATL@@UEAAJXZ
	.proc	?f627@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f627@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=627*8,r14	// r14 = &m_pUnk->vtbl[627] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[627]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[627].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[627].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f627@_QIThunk@ATL@@UEAAJXZ


	.global ?f628@_QIThunk@ATL@@UEAAJXZ
	.proc	?f628@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f628@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=628*8,r14	// r14 = &m_pUnk->vtbl[628] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[628]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[628].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[628].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f628@_QIThunk@ATL@@UEAAJXZ


	.global ?f629@_QIThunk@ATL@@UEAAJXZ
	.proc	?f629@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f629@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=629*8,r14	// r14 = &m_pUnk->vtbl[629] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[629]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[629].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[629].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f629@_QIThunk@ATL@@UEAAJXZ


	.global ?f630@_QIThunk@ATL@@UEAAJXZ
	.proc	?f630@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f630@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=630*8,r14	// r14 = &m_pUnk->vtbl[630] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[630]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[630].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[630].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f630@_QIThunk@ATL@@UEAAJXZ


	.global ?f631@_QIThunk@ATL@@UEAAJXZ
	.proc	?f631@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f631@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=631*8,r14	// r14 = &m_pUnk->vtbl[631] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[631]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[631].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[631].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f631@_QIThunk@ATL@@UEAAJXZ


	.global ?f632@_QIThunk@ATL@@UEAAJXZ
	.proc	?f632@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f632@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=632*8,r14	// r14 = &m_pUnk->vtbl[632] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[632]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[632].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[632].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f632@_QIThunk@ATL@@UEAAJXZ


	.global ?f633@_QIThunk@ATL@@UEAAJXZ
	.proc	?f633@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f633@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=633*8,r14	// r14 = &m_pUnk->vtbl[633] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[633]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[633].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[633].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f633@_QIThunk@ATL@@UEAAJXZ


	.global ?f634@_QIThunk@ATL@@UEAAJXZ
	.proc	?f634@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f634@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=634*8,r14	// r14 = &m_pUnk->vtbl[634] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[634]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[634].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[634].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f634@_QIThunk@ATL@@UEAAJXZ


	.global ?f635@_QIThunk@ATL@@UEAAJXZ
	.proc	?f635@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f635@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=635*8,r14	// r14 = &m_pUnk->vtbl[635] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[635]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[635].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[635].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f635@_QIThunk@ATL@@UEAAJXZ


	.global ?f636@_QIThunk@ATL@@UEAAJXZ
	.proc	?f636@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f636@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=636*8,r14	// r14 = &m_pUnk->vtbl[636] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[636]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[636].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[636].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f636@_QIThunk@ATL@@UEAAJXZ


	.global ?f637@_QIThunk@ATL@@UEAAJXZ
	.proc	?f637@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f637@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=637*8,r14	// r14 = &m_pUnk->vtbl[637] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[637]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[637].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[637].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f637@_QIThunk@ATL@@UEAAJXZ


	.global ?f638@_QIThunk@ATL@@UEAAJXZ
	.proc	?f638@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f638@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=638*8,r14	// r14 = &m_pUnk->vtbl[638] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[638]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[638].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[638].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f638@_QIThunk@ATL@@UEAAJXZ


	.global ?f639@_QIThunk@ATL@@UEAAJXZ
	.proc	?f639@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f639@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=639*8,r14	// r14 = &m_pUnk->vtbl[639] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[639]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[639].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[639].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f639@_QIThunk@ATL@@UEAAJXZ


	.global ?f640@_QIThunk@ATL@@UEAAJXZ
	.proc	?f640@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f640@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=640*8,r14	// r14 = &m_pUnk->vtbl[640] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[640]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[640].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[640].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f640@_QIThunk@ATL@@UEAAJXZ


	.global ?f641@_QIThunk@ATL@@UEAAJXZ
	.proc	?f641@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f641@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=641*8,r14	// r14 = &m_pUnk->vtbl[641] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[641]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[641].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[641].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f641@_QIThunk@ATL@@UEAAJXZ


	.global ?f642@_QIThunk@ATL@@UEAAJXZ
	.proc	?f642@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f642@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=642*8,r14	// r14 = &m_pUnk->vtbl[642] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[642]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[642].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[642].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f642@_QIThunk@ATL@@UEAAJXZ


	.global ?f643@_QIThunk@ATL@@UEAAJXZ
	.proc	?f643@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f643@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=643*8,r14	// r14 = &m_pUnk->vtbl[643] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[643]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[643].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[643].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f643@_QIThunk@ATL@@UEAAJXZ


	.global ?f644@_QIThunk@ATL@@UEAAJXZ
	.proc	?f644@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f644@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=644*8,r14	// r14 = &m_pUnk->vtbl[644] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[644]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[644].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[644].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f644@_QIThunk@ATL@@UEAAJXZ


	.global ?f645@_QIThunk@ATL@@UEAAJXZ
	.proc	?f645@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f645@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=645*8,r14	// r14 = &m_pUnk->vtbl[645] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[645]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[645].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[645].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f645@_QIThunk@ATL@@UEAAJXZ


	.global ?f646@_QIThunk@ATL@@UEAAJXZ
	.proc	?f646@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f646@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=646*8,r14	// r14 = &m_pUnk->vtbl[646] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[646]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[646].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[646].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f646@_QIThunk@ATL@@UEAAJXZ


	.global ?f647@_QIThunk@ATL@@UEAAJXZ
	.proc	?f647@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f647@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=647*8,r14	// r14 = &m_pUnk->vtbl[647] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[647]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[647].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[647].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f647@_QIThunk@ATL@@UEAAJXZ


	.global ?f648@_QIThunk@ATL@@UEAAJXZ
	.proc	?f648@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f648@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=648*8,r14	// r14 = &m_pUnk->vtbl[648] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[648]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[648].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[648].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f648@_QIThunk@ATL@@UEAAJXZ


	.global ?f649@_QIThunk@ATL@@UEAAJXZ
	.proc	?f649@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f649@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=649*8,r14	// r14 = &m_pUnk->vtbl[649] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[649]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[649].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[649].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f649@_QIThunk@ATL@@UEAAJXZ


	.global ?f650@_QIThunk@ATL@@UEAAJXZ
	.proc	?f650@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f650@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=650*8,r14	// r14 = &m_pUnk->vtbl[650] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[650]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[650].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[650].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f650@_QIThunk@ATL@@UEAAJXZ


	.global ?f651@_QIThunk@ATL@@UEAAJXZ
	.proc	?f651@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f651@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=651*8,r14	// r14 = &m_pUnk->vtbl[651] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[651]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[651].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[651].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f651@_QIThunk@ATL@@UEAAJXZ


	.global ?f652@_QIThunk@ATL@@UEAAJXZ
	.proc	?f652@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f652@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=652*8,r14	// r14 = &m_pUnk->vtbl[652] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[652]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[652].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[652].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f652@_QIThunk@ATL@@UEAAJXZ


	.global ?f653@_QIThunk@ATL@@UEAAJXZ
	.proc	?f653@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f653@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=653*8,r14	// r14 = &m_pUnk->vtbl[653] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[653]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[653].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[653].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f653@_QIThunk@ATL@@UEAAJXZ


	.global ?f654@_QIThunk@ATL@@UEAAJXZ
	.proc	?f654@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f654@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=654*8,r14	// r14 = &m_pUnk->vtbl[654] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[654]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[654].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[654].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f654@_QIThunk@ATL@@UEAAJXZ


	.global ?f655@_QIThunk@ATL@@UEAAJXZ
	.proc	?f655@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f655@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=655*8,r14	// r14 = &m_pUnk->vtbl[655] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[655]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[655].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[655].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f655@_QIThunk@ATL@@UEAAJXZ


	.global ?f656@_QIThunk@ATL@@UEAAJXZ
	.proc	?f656@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f656@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=656*8,r14	// r14 = &m_pUnk->vtbl[656] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[656]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[656].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[656].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f656@_QIThunk@ATL@@UEAAJXZ


	.global ?f657@_QIThunk@ATL@@UEAAJXZ
	.proc	?f657@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f657@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=657*8,r14	// r14 = &m_pUnk->vtbl[657] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[657]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[657].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[657].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f657@_QIThunk@ATL@@UEAAJXZ


	.global ?f658@_QIThunk@ATL@@UEAAJXZ
	.proc	?f658@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f658@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=658*8,r14	// r14 = &m_pUnk->vtbl[658] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[658]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[658].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[658].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f658@_QIThunk@ATL@@UEAAJXZ


	.global ?f659@_QIThunk@ATL@@UEAAJXZ
	.proc	?f659@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f659@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=659*8,r14	// r14 = &m_pUnk->vtbl[659] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[659]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[659].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[659].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f659@_QIThunk@ATL@@UEAAJXZ


	.global ?f660@_QIThunk@ATL@@UEAAJXZ
	.proc	?f660@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f660@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=660*8,r14	// r14 = &m_pUnk->vtbl[660] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[660]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[660].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[660].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f660@_QIThunk@ATL@@UEAAJXZ


	.global ?f661@_QIThunk@ATL@@UEAAJXZ
	.proc	?f661@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f661@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=661*8,r14	// r14 = &m_pUnk->vtbl[661] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[661]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[661].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[661].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f661@_QIThunk@ATL@@UEAAJXZ


	.global ?f662@_QIThunk@ATL@@UEAAJXZ
	.proc	?f662@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f662@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=662*8,r14	// r14 = &m_pUnk->vtbl[662] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[662]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[662].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[662].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f662@_QIThunk@ATL@@UEAAJXZ


	.global ?f663@_QIThunk@ATL@@UEAAJXZ
	.proc	?f663@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f663@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=663*8,r14	// r14 = &m_pUnk->vtbl[663] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[663]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[663].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[663].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f663@_QIThunk@ATL@@UEAAJXZ


	.global ?f664@_QIThunk@ATL@@UEAAJXZ
	.proc	?f664@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f664@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=664*8,r14	// r14 = &m_pUnk->vtbl[664] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[664]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[664].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[664].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f664@_QIThunk@ATL@@UEAAJXZ


	.global ?f665@_QIThunk@ATL@@UEAAJXZ
	.proc	?f665@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f665@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=665*8,r14	// r14 = &m_pUnk->vtbl[665] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[665]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[665].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[665].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f665@_QIThunk@ATL@@UEAAJXZ


	.global ?f666@_QIThunk@ATL@@UEAAJXZ
	.proc	?f666@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f666@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=666*8,r14	// r14 = &m_pUnk->vtbl[666] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[666]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[666].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[666].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f666@_QIThunk@ATL@@UEAAJXZ


	.global ?f667@_QIThunk@ATL@@UEAAJXZ
	.proc	?f667@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f667@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=667*8,r14	// r14 = &m_pUnk->vtbl[667] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[667]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[667].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[667].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f667@_QIThunk@ATL@@UEAAJXZ


	.global ?f668@_QIThunk@ATL@@UEAAJXZ
	.proc	?f668@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f668@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=668*8,r14	// r14 = &m_pUnk->vtbl[668] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[668]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[668].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[668].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f668@_QIThunk@ATL@@UEAAJXZ


	.global ?f669@_QIThunk@ATL@@UEAAJXZ
	.proc	?f669@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f669@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=669*8,r14	// r14 = &m_pUnk->vtbl[669] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[669]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[669].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[669].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f669@_QIThunk@ATL@@UEAAJXZ


	.global ?f670@_QIThunk@ATL@@UEAAJXZ
	.proc	?f670@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f670@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=670*8,r14	// r14 = &m_pUnk->vtbl[670] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[670]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[670].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[670].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f670@_QIThunk@ATL@@UEAAJXZ


	.global ?f671@_QIThunk@ATL@@UEAAJXZ
	.proc	?f671@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f671@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=671*8,r14	// r14 = &m_pUnk->vtbl[671] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[671]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[671].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[671].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f671@_QIThunk@ATL@@UEAAJXZ


	.global ?f672@_QIThunk@ATL@@UEAAJXZ
	.proc	?f672@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f672@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=672*8,r14	// r14 = &m_pUnk->vtbl[672] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[672]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[672].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[672].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f672@_QIThunk@ATL@@UEAAJXZ


	.global ?f673@_QIThunk@ATL@@UEAAJXZ
	.proc	?f673@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f673@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=673*8,r14	// r14 = &m_pUnk->vtbl[673] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[673]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[673].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[673].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f673@_QIThunk@ATL@@UEAAJXZ


	.global ?f674@_QIThunk@ATL@@UEAAJXZ
	.proc	?f674@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f674@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=674*8,r14	// r14 = &m_pUnk->vtbl[674] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[674]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[674].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[674].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f674@_QIThunk@ATL@@UEAAJXZ


	.global ?f675@_QIThunk@ATL@@UEAAJXZ
	.proc	?f675@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f675@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=675*8,r14	// r14 = &m_pUnk->vtbl[675] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[675]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[675].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[675].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f675@_QIThunk@ATL@@UEAAJXZ


	.global ?f676@_QIThunk@ATL@@UEAAJXZ
	.proc	?f676@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f676@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=676*8,r14	// r14 = &m_pUnk->vtbl[676] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[676]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[676].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[676].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f676@_QIThunk@ATL@@UEAAJXZ


	.global ?f677@_QIThunk@ATL@@UEAAJXZ
	.proc	?f677@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f677@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=677*8,r14	// r14 = &m_pUnk->vtbl[677] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[677]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[677].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[677].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f677@_QIThunk@ATL@@UEAAJXZ


	.global ?f678@_QIThunk@ATL@@UEAAJXZ
	.proc	?f678@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f678@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=678*8,r14	// r14 = &m_pUnk->vtbl[678] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[678]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[678].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[678].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f678@_QIThunk@ATL@@UEAAJXZ


	.global ?f679@_QIThunk@ATL@@UEAAJXZ
	.proc	?f679@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f679@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=679*8,r14	// r14 = &m_pUnk->vtbl[679] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[679]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[679].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[679].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f679@_QIThunk@ATL@@UEAAJXZ


	.global ?f680@_QIThunk@ATL@@UEAAJXZ
	.proc	?f680@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f680@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=680*8,r14	// r14 = &m_pUnk->vtbl[680] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[680]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[680].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[680].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f680@_QIThunk@ATL@@UEAAJXZ


	.global ?f681@_QIThunk@ATL@@UEAAJXZ
	.proc	?f681@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f681@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=681*8,r14	// r14 = &m_pUnk->vtbl[681] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[681]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[681].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[681].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f681@_QIThunk@ATL@@UEAAJXZ


	.global ?f682@_QIThunk@ATL@@UEAAJXZ
	.proc	?f682@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f682@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=682*8,r14	// r14 = &m_pUnk->vtbl[682] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[682]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[682].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[682].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f682@_QIThunk@ATL@@UEAAJXZ


	.global ?f683@_QIThunk@ATL@@UEAAJXZ
	.proc	?f683@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f683@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=683*8,r14	// r14 = &m_pUnk->vtbl[683] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[683]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[683].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[683].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f683@_QIThunk@ATL@@UEAAJXZ


	.global ?f684@_QIThunk@ATL@@UEAAJXZ
	.proc	?f684@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f684@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=684*8,r14	// r14 = &m_pUnk->vtbl[684] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[684]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[684].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[684].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f684@_QIThunk@ATL@@UEAAJXZ


	.global ?f685@_QIThunk@ATL@@UEAAJXZ
	.proc	?f685@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f685@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=685*8,r14	// r14 = &m_pUnk->vtbl[685] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[685]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[685].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[685].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f685@_QIThunk@ATL@@UEAAJXZ


	.global ?f686@_QIThunk@ATL@@UEAAJXZ
	.proc	?f686@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f686@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=686*8,r14	// r14 = &m_pUnk->vtbl[686] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[686]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[686].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[686].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f686@_QIThunk@ATL@@UEAAJXZ


	.global ?f687@_QIThunk@ATL@@UEAAJXZ
	.proc	?f687@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f687@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=687*8,r14	// r14 = &m_pUnk->vtbl[687] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[687]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[687].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[687].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f687@_QIThunk@ATL@@UEAAJXZ


	.global ?f688@_QIThunk@ATL@@UEAAJXZ
	.proc	?f688@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f688@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=688*8,r14	// r14 = &m_pUnk->vtbl[688] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[688]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[688].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[688].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f688@_QIThunk@ATL@@UEAAJXZ


	.global ?f689@_QIThunk@ATL@@UEAAJXZ
	.proc	?f689@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f689@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=689*8,r14	// r14 = &m_pUnk->vtbl[689] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[689]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[689].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[689].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f689@_QIThunk@ATL@@UEAAJXZ


	.global ?f690@_QIThunk@ATL@@UEAAJXZ
	.proc	?f690@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f690@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=690*8,r14	// r14 = &m_pUnk->vtbl[690] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[690]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[690].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[690].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f690@_QIThunk@ATL@@UEAAJXZ


	.global ?f691@_QIThunk@ATL@@UEAAJXZ
	.proc	?f691@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f691@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=691*8,r14	// r14 = &m_pUnk->vtbl[691] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[691]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[691].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[691].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f691@_QIThunk@ATL@@UEAAJXZ


	.global ?f692@_QIThunk@ATL@@UEAAJXZ
	.proc	?f692@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f692@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=692*8,r14	// r14 = &m_pUnk->vtbl[692] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[692]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[692].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[692].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f692@_QIThunk@ATL@@UEAAJXZ


	.global ?f693@_QIThunk@ATL@@UEAAJXZ
	.proc	?f693@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f693@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=693*8,r14	// r14 = &m_pUnk->vtbl[693] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[693]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[693].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[693].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f693@_QIThunk@ATL@@UEAAJXZ


	.global ?f694@_QIThunk@ATL@@UEAAJXZ
	.proc	?f694@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f694@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=694*8,r14	// r14 = &m_pUnk->vtbl[694] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[694]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[694].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[694].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f694@_QIThunk@ATL@@UEAAJXZ


	.global ?f695@_QIThunk@ATL@@UEAAJXZ
	.proc	?f695@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f695@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=695*8,r14	// r14 = &m_pUnk->vtbl[695] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[695]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[695].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[695].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f695@_QIThunk@ATL@@UEAAJXZ


	.global ?f696@_QIThunk@ATL@@UEAAJXZ
	.proc	?f696@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f696@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=696*8,r14	// r14 = &m_pUnk->vtbl[696] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[696]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[696].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[696].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f696@_QIThunk@ATL@@UEAAJXZ


	.global ?f697@_QIThunk@ATL@@UEAAJXZ
	.proc	?f697@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f697@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=697*8,r14	// r14 = &m_pUnk->vtbl[697] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[697]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[697].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[697].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f697@_QIThunk@ATL@@UEAAJXZ


	.global ?f698@_QIThunk@ATL@@UEAAJXZ
	.proc	?f698@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f698@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=698*8,r14	// r14 = &m_pUnk->vtbl[698] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[698]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[698].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[698].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f698@_QIThunk@ATL@@UEAAJXZ


	.global ?f699@_QIThunk@ATL@@UEAAJXZ
	.proc	?f699@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f699@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=699*8,r14	// r14 = &m_pUnk->vtbl[699] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[699]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[699].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[699].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f699@_QIThunk@ATL@@UEAAJXZ


	.global ?f700@_QIThunk@ATL@@UEAAJXZ
	.proc	?f700@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f700@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=700*8,r14	// r14 = &m_pUnk->vtbl[700] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[700]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[700].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[700].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f700@_QIThunk@ATL@@UEAAJXZ


	.global ?f701@_QIThunk@ATL@@UEAAJXZ
	.proc	?f701@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f701@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=701*8,r14	// r14 = &m_pUnk->vtbl[701] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[701]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[701].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[701].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f701@_QIThunk@ATL@@UEAAJXZ


	.global ?f702@_QIThunk@ATL@@UEAAJXZ
	.proc	?f702@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f702@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=702*8,r14	// r14 = &m_pUnk->vtbl[702] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[702]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[702].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[702].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f702@_QIThunk@ATL@@UEAAJXZ


	.global ?f703@_QIThunk@ATL@@UEAAJXZ
	.proc	?f703@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f703@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=703*8,r14	// r14 = &m_pUnk->vtbl[703] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[703]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[703].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[703].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f703@_QIThunk@ATL@@UEAAJXZ


	.global ?f704@_QIThunk@ATL@@UEAAJXZ
	.proc	?f704@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f704@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=704*8,r14	// r14 = &m_pUnk->vtbl[704] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[704]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[704].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[704].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f704@_QIThunk@ATL@@UEAAJXZ


	.global ?f705@_QIThunk@ATL@@UEAAJXZ
	.proc	?f705@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f705@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=705*8,r14	// r14 = &m_pUnk->vtbl[705] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[705]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[705].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[705].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f705@_QIThunk@ATL@@UEAAJXZ


	.global ?f706@_QIThunk@ATL@@UEAAJXZ
	.proc	?f706@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f706@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=706*8,r14	// r14 = &m_pUnk->vtbl[706] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[706]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[706].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[706].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f706@_QIThunk@ATL@@UEAAJXZ


	.global ?f707@_QIThunk@ATL@@UEAAJXZ
	.proc	?f707@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f707@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=707*8,r14	// r14 = &m_pUnk->vtbl[707] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[707]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[707].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[707].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f707@_QIThunk@ATL@@UEAAJXZ


	.global ?f708@_QIThunk@ATL@@UEAAJXZ
	.proc	?f708@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f708@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=708*8,r14	// r14 = &m_pUnk->vtbl[708] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[708]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[708].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[708].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f708@_QIThunk@ATL@@UEAAJXZ


	.global ?f709@_QIThunk@ATL@@UEAAJXZ
	.proc	?f709@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f709@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=709*8,r14	// r14 = &m_pUnk->vtbl[709] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[709]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[709].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[709].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f709@_QIThunk@ATL@@UEAAJXZ


	.global ?f710@_QIThunk@ATL@@UEAAJXZ
	.proc	?f710@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f710@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=710*8,r14	// r14 = &m_pUnk->vtbl[710] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[710]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[710].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[710].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f710@_QIThunk@ATL@@UEAAJXZ


	.global ?f711@_QIThunk@ATL@@UEAAJXZ
	.proc	?f711@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f711@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=711*8,r14	// r14 = &m_pUnk->vtbl[711] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[711]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[711].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[711].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f711@_QIThunk@ATL@@UEAAJXZ


	.global ?f712@_QIThunk@ATL@@UEAAJXZ
	.proc	?f712@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f712@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=712*8,r14	// r14 = &m_pUnk->vtbl[712] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[712]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[712].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[712].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f712@_QIThunk@ATL@@UEAAJXZ


	.global ?f713@_QIThunk@ATL@@UEAAJXZ
	.proc	?f713@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f713@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=713*8,r14	// r14 = &m_pUnk->vtbl[713] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[713]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[713].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[713].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f713@_QIThunk@ATL@@UEAAJXZ


	.global ?f714@_QIThunk@ATL@@UEAAJXZ
	.proc	?f714@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f714@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=714*8,r14	// r14 = &m_pUnk->vtbl[714] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[714]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[714].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[714].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f714@_QIThunk@ATL@@UEAAJXZ


	.global ?f715@_QIThunk@ATL@@UEAAJXZ
	.proc	?f715@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f715@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=715*8,r14	// r14 = &m_pUnk->vtbl[715] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[715]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[715].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[715].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f715@_QIThunk@ATL@@UEAAJXZ


	.global ?f716@_QIThunk@ATL@@UEAAJXZ
	.proc	?f716@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f716@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=716*8,r14	// r14 = &m_pUnk->vtbl[716] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[716]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[716].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[716].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f716@_QIThunk@ATL@@UEAAJXZ


	.global ?f717@_QIThunk@ATL@@UEAAJXZ
	.proc	?f717@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f717@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=717*8,r14	// r14 = &m_pUnk->vtbl[717] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[717]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[717].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[717].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f717@_QIThunk@ATL@@UEAAJXZ


	.global ?f718@_QIThunk@ATL@@UEAAJXZ
	.proc	?f718@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f718@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=718*8,r14	// r14 = &m_pUnk->vtbl[718] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[718]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[718].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[718].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f718@_QIThunk@ATL@@UEAAJXZ


	.global ?f719@_QIThunk@ATL@@UEAAJXZ
	.proc	?f719@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f719@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=719*8,r14	// r14 = &m_pUnk->vtbl[719] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[719]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[719].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[719].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f719@_QIThunk@ATL@@UEAAJXZ


	.global ?f720@_QIThunk@ATL@@UEAAJXZ
	.proc	?f720@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f720@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=720*8,r14	// r14 = &m_pUnk->vtbl[720] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[720]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[720].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[720].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f720@_QIThunk@ATL@@UEAAJXZ


	.global ?f721@_QIThunk@ATL@@UEAAJXZ
	.proc	?f721@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f721@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=721*8,r14	// r14 = &m_pUnk->vtbl[721] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[721]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[721].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[721].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f721@_QIThunk@ATL@@UEAAJXZ


	.global ?f722@_QIThunk@ATL@@UEAAJXZ
	.proc	?f722@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f722@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=722*8,r14	// r14 = &m_pUnk->vtbl[722] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[722]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[722].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[722].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f722@_QIThunk@ATL@@UEAAJXZ


	.global ?f723@_QIThunk@ATL@@UEAAJXZ
	.proc	?f723@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f723@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=723*8,r14	// r14 = &m_pUnk->vtbl[723] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[723]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[723].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[723].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f723@_QIThunk@ATL@@UEAAJXZ


	.global ?f724@_QIThunk@ATL@@UEAAJXZ
	.proc	?f724@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f724@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=724*8,r14	// r14 = &m_pUnk->vtbl[724] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[724]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[724].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[724].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f724@_QIThunk@ATL@@UEAAJXZ


	.global ?f725@_QIThunk@ATL@@UEAAJXZ
	.proc	?f725@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f725@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=725*8,r14	// r14 = &m_pUnk->vtbl[725] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[725]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[725].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[725].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f725@_QIThunk@ATL@@UEAAJXZ


	.global ?f726@_QIThunk@ATL@@UEAAJXZ
	.proc	?f726@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f726@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=726*8,r14	// r14 = &m_pUnk->vtbl[726] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[726]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[726].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[726].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f726@_QIThunk@ATL@@UEAAJXZ


	.global ?f727@_QIThunk@ATL@@UEAAJXZ
	.proc	?f727@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f727@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=727*8,r14	// r14 = &m_pUnk->vtbl[727] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[727]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[727].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[727].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f727@_QIThunk@ATL@@UEAAJXZ


	.global ?f728@_QIThunk@ATL@@UEAAJXZ
	.proc	?f728@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f728@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=728*8,r14	// r14 = &m_pUnk->vtbl[728] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[728]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[728].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[728].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f728@_QIThunk@ATL@@UEAAJXZ


	.global ?f729@_QIThunk@ATL@@UEAAJXZ
	.proc	?f729@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f729@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=729*8,r14	// r14 = &m_pUnk->vtbl[729] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[729]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[729].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[729].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f729@_QIThunk@ATL@@UEAAJXZ


	.global ?f730@_QIThunk@ATL@@UEAAJXZ
	.proc	?f730@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f730@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=730*8,r14	// r14 = &m_pUnk->vtbl[730] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[730]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[730].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[730].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f730@_QIThunk@ATL@@UEAAJXZ


	.global ?f731@_QIThunk@ATL@@UEAAJXZ
	.proc	?f731@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f731@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=731*8,r14	// r14 = &m_pUnk->vtbl[731] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[731]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[731].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[731].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f731@_QIThunk@ATL@@UEAAJXZ


	.global ?f732@_QIThunk@ATL@@UEAAJXZ
	.proc	?f732@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f732@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=732*8,r14	// r14 = &m_pUnk->vtbl[732] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[732]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[732].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[732].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f732@_QIThunk@ATL@@UEAAJXZ


	.global ?f733@_QIThunk@ATL@@UEAAJXZ
	.proc	?f733@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f733@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=733*8,r14	// r14 = &m_pUnk->vtbl[733] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[733]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[733].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[733].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f733@_QIThunk@ATL@@UEAAJXZ


	.global ?f734@_QIThunk@ATL@@UEAAJXZ
	.proc	?f734@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f734@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=734*8,r14	// r14 = &m_pUnk->vtbl[734] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[734]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[734].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[734].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f734@_QIThunk@ATL@@UEAAJXZ


	.global ?f735@_QIThunk@ATL@@UEAAJXZ
	.proc	?f735@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f735@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=735*8,r14	// r14 = &m_pUnk->vtbl[735] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[735]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[735].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[735].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f735@_QIThunk@ATL@@UEAAJXZ


	.global ?f736@_QIThunk@ATL@@UEAAJXZ
	.proc	?f736@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f736@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=736*8,r14	// r14 = &m_pUnk->vtbl[736] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[736]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[736].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[736].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f736@_QIThunk@ATL@@UEAAJXZ


	.global ?f737@_QIThunk@ATL@@UEAAJXZ
	.proc	?f737@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f737@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=737*8,r14	// r14 = &m_pUnk->vtbl[737] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[737]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[737].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[737].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f737@_QIThunk@ATL@@UEAAJXZ


	.global ?f738@_QIThunk@ATL@@UEAAJXZ
	.proc	?f738@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f738@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=738*8,r14	// r14 = &m_pUnk->vtbl[738] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[738]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[738].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[738].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f738@_QIThunk@ATL@@UEAAJXZ


	.global ?f739@_QIThunk@ATL@@UEAAJXZ
	.proc	?f739@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f739@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=739*8,r14	// r14 = &m_pUnk->vtbl[739] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[739]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[739].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[739].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f739@_QIThunk@ATL@@UEAAJXZ


	.global ?f740@_QIThunk@ATL@@UEAAJXZ
	.proc	?f740@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f740@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=740*8,r14	// r14 = &m_pUnk->vtbl[740] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[740]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[740].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[740].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f740@_QIThunk@ATL@@UEAAJXZ


	.global ?f741@_QIThunk@ATL@@UEAAJXZ
	.proc	?f741@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f741@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=741*8,r14	// r14 = &m_pUnk->vtbl[741] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[741]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[741].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[741].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f741@_QIThunk@ATL@@UEAAJXZ


	.global ?f742@_QIThunk@ATL@@UEAAJXZ
	.proc	?f742@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f742@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=742*8,r14	// r14 = &m_pUnk->vtbl[742] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[742]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[742].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[742].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f742@_QIThunk@ATL@@UEAAJXZ


	.global ?f743@_QIThunk@ATL@@UEAAJXZ
	.proc	?f743@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f743@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=743*8,r14	// r14 = &m_pUnk->vtbl[743] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[743]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[743].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[743].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f743@_QIThunk@ATL@@UEAAJXZ


	.global ?f744@_QIThunk@ATL@@UEAAJXZ
	.proc	?f744@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f744@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=744*8,r14	// r14 = &m_pUnk->vtbl[744] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[744]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[744].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[744].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f744@_QIThunk@ATL@@UEAAJXZ


	.global ?f745@_QIThunk@ATL@@UEAAJXZ
	.proc	?f745@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f745@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=745*8,r14	// r14 = &m_pUnk->vtbl[745] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[745]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[745].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[745].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f745@_QIThunk@ATL@@UEAAJXZ


	.global ?f746@_QIThunk@ATL@@UEAAJXZ
	.proc	?f746@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f746@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=746*8,r14	// r14 = &m_pUnk->vtbl[746] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[746]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[746].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[746].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f746@_QIThunk@ATL@@UEAAJXZ


	.global ?f747@_QIThunk@ATL@@UEAAJXZ
	.proc	?f747@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f747@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=747*8,r14	// r14 = &m_pUnk->vtbl[747] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[747]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[747].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[747].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f747@_QIThunk@ATL@@UEAAJXZ


	.global ?f748@_QIThunk@ATL@@UEAAJXZ
	.proc	?f748@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f748@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=748*8,r14	// r14 = &m_pUnk->vtbl[748] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[748]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[748].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[748].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f748@_QIThunk@ATL@@UEAAJXZ


	.global ?f749@_QIThunk@ATL@@UEAAJXZ
	.proc	?f749@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f749@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=749*8,r14	// r14 = &m_pUnk->vtbl[749] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[749]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[749].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[749].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f749@_QIThunk@ATL@@UEAAJXZ


	.global ?f750@_QIThunk@ATL@@UEAAJXZ
	.proc	?f750@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f750@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=750*8,r14	// r14 = &m_pUnk->vtbl[750] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[750]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[750].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[750].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f750@_QIThunk@ATL@@UEAAJXZ


	.global ?f751@_QIThunk@ATL@@UEAAJXZ
	.proc	?f751@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f751@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=751*8,r14	// r14 = &m_pUnk->vtbl[751] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[751]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[751].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[751].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f751@_QIThunk@ATL@@UEAAJXZ


	.global ?f752@_QIThunk@ATL@@UEAAJXZ
	.proc	?f752@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f752@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=752*8,r14	// r14 = &m_pUnk->vtbl[752] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[752]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[752].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[752].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f752@_QIThunk@ATL@@UEAAJXZ


	.global ?f753@_QIThunk@ATL@@UEAAJXZ
	.proc	?f753@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f753@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=753*8,r14	// r14 = &m_pUnk->vtbl[753] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[753]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[753].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[753].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f753@_QIThunk@ATL@@UEAAJXZ


	.global ?f754@_QIThunk@ATL@@UEAAJXZ
	.proc	?f754@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f754@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=754*8,r14	// r14 = &m_pUnk->vtbl[754] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[754]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[754].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[754].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f754@_QIThunk@ATL@@UEAAJXZ


	.global ?f755@_QIThunk@ATL@@UEAAJXZ
	.proc	?f755@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f755@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=755*8,r14	// r14 = &m_pUnk->vtbl[755] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[755]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[755].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[755].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f755@_QIThunk@ATL@@UEAAJXZ


	.global ?f756@_QIThunk@ATL@@UEAAJXZ
	.proc	?f756@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f756@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=756*8,r14	// r14 = &m_pUnk->vtbl[756] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[756]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[756].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[756].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f756@_QIThunk@ATL@@UEAAJXZ


	.global ?f757@_QIThunk@ATL@@UEAAJXZ
	.proc	?f757@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f757@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=757*8,r14	// r14 = &m_pUnk->vtbl[757] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[757]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[757].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[757].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f757@_QIThunk@ATL@@UEAAJXZ


	.global ?f758@_QIThunk@ATL@@UEAAJXZ
	.proc	?f758@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f758@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=758*8,r14	// r14 = &m_pUnk->vtbl[758] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[758]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[758].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[758].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f758@_QIThunk@ATL@@UEAAJXZ


	.global ?f759@_QIThunk@ATL@@UEAAJXZ
	.proc	?f759@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f759@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=759*8,r14	// r14 = &m_pUnk->vtbl[759] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[759]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[759].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[759].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f759@_QIThunk@ATL@@UEAAJXZ


	.global ?f760@_QIThunk@ATL@@UEAAJXZ
	.proc	?f760@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f760@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=760*8,r14	// r14 = &m_pUnk->vtbl[760] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[760]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[760].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[760].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f760@_QIThunk@ATL@@UEAAJXZ


	.global ?f761@_QIThunk@ATL@@UEAAJXZ
	.proc	?f761@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f761@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=761*8,r14	// r14 = &m_pUnk->vtbl[761] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[761]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[761].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[761].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f761@_QIThunk@ATL@@UEAAJXZ


	.global ?f762@_QIThunk@ATL@@UEAAJXZ
	.proc	?f762@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f762@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=762*8,r14	// r14 = &m_pUnk->vtbl[762] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[762]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[762].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[762].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f762@_QIThunk@ATL@@UEAAJXZ


	.global ?f763@_QIThunk@ATL@@UEAAJXZ
	.proc	?f763@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f763@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=763*8,r14	// r14 = &m_pUnk->vtbl[763] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[763]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[763].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[763].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f763@_QIThunk@ATL@@UEAAJXZ


	.global ?f764@_QIThunk@ATL@@UEAAJXZ
	.proc	?f764@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f764@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=764*8,r14	// r14 = &m_pUnk->vtbl[764] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[764]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[764].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[764].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f764@_QIThunk@ATL@@UEAAJXZ


	.global ?f765@_QIThunk@ATL@@UEAAJXZ
	.proc	?f765@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f765@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=765*8,r14	// r14 = &m_pUnk->vtbl[765] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[765]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[765].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[765].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f765@_QIThunk@ATL@@UEAAJXZ


	.global ?f766@_QIThunk@ATL@@UEAAJXZ
	.proc	?f766@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f766@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=766*8,r14	// r14 = &m_pUnk->vtbl[766] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[766]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[766].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[766].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f766@_QIThunk@ATL@@UEAAJXZ


	.global ?f767@_QIThunk@ATL@@UEAAJXZ
	.proc	?f767@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f767@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=767*8,r14	// r14 = &m_pUnk->vtbl[767] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[767]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[767].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[767].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f767@_QIThunk@ATL@@UEAAJXZ


	.global ?f768@_QIThunk@ATL@@UEAAJXZ
	.proc	?f768@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f768@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=768*8,r14	// r14 = &m_pUnk->vtbl[768] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[768]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[768].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[768].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f768@_QIThunk@ATL@@UEAAJXZ


	.global ?f769@_QIThunk@ATL@@UEAAJXZ
	.proc	?f769@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f769@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=769*8,r14	// r14 = &m_pUnk->vtbl[769] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[769]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[769].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[769].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f769@_QIThunk@ATL@@UEAAJXZ


	.global ?f770@_QIThunk@ATL@@UEAAJXZ
	.proc	?f770@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f770@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=770*8,r14	// r14 = &m_pUnk->vtbl[770] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[770]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[770].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[770].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f770@_QIThunk@ATL@@UEAAJXZ


	.global ?f771@_QIThunk@ATL@@UEAAJXZ
	.proc	?f771@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f771@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=771*8,r14	// r14 = &m_pUnk->vtbl[771] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[771]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[771].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[771].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f771@_QIThunk@ATL@@UEAAJXZ


	.global ?f772@_QIThunk@ATL@@UEAAJXZ
	.proc	?f772@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f772@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=772*8,r14	// r14 = &m_pUnk->vtbl[772] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[772]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[772].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[772].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f772@_QIThunk@ATL@@UEAAJXZ


	.global ?f773@_QIThunk@ATL@@UEAAJXZ
	.proc	?f773@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f773@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=773*8,r14	// r14 = &m_pUnk->vtbl[773] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[773]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[773].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[773].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f773@_QIThunk@ATL@@UEAAJXZ


	.global ?f774@_QIThunk@ATL@@UEAAJXZ
	.proc	?f774@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f774@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=774*8,r14	// r14 = &m_pUnk->vtbl[774] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[774]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[774].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[774].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f774@_QIThunk@ATL@@UEAAJXZ


	.global ?f775@_QIThunk@ATL@@UEAAJXZ
	.proc	?f775@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f775@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=775*8,r14	// r14 = &m_pUnk->vtbl[775] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[775]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[775].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[775].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f775@_QIThunk@ATL@@UEAAJXZ


	.global ?f776@_QIThunk@ATL@@UEAAJXZ
	.proc	?f776@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f776@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=776*8,r14	// r14 = &m_pUnk->vtbl[776] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[776]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[776].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[776].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f776@_QIThunk@ATL@@UEAAJXZ


	.global ?f777@_QIThunk@ATL@@UEAAJXZ
	.proc	?f777@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f777@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=777*8,r14	// r14 = &m_pUnk->vtbl[777] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[777]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[777].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[777].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f777@_QIThunk@ATL@@UEAAJXZ


	.global ?f778@_QIThunk@ATL@@UEAAJXZ
	.proc	?f778@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f778@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=778*8,r14	// r14 = &m_pUnk->vtbl[778] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[778]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[778].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[778].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f778@_QIThunk@ATL@@UEAAJXZ


	.global ?f779@_QIThunk@ATL@@UEAAJXZ
	.proc	?f779@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f779@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=779*8,r14	// r14 = &m_pUnk->vtbl[779] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[779]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[779].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[779].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f779@_QIThunk@ATL@@UEAAJXZ


	.global ?f780@_QIThunk@ATL@@UEAAJXZ
	.proc	?f780@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f780@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=780*8,r14	// r14 = &m_pUnk->vtbl[780] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[780]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[780].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[780].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f780@_QIThunk@ATL@@UEAAJXZ


	.global ?f781@_QIThunk@ATL@@UEAAJXZ
	.proc	?f781@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f781@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=781*8,r14	// r14 = &m_pUnk->vtbl[781] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[781]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[781].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[781].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f781@_QIThunk@ATL@@UEAAJXZ


	.global ?f782@_QIThunk@ATL@@UEAAJXZ
	.proc	?f782@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f782@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=782*8,r14	// r14 = &m_pUnk->vtbl[782] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[782]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[782].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[782].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f782@_QIThunk@ATL@@UEAAJXZ


	.global ?f783@_QIThunk@ATL@@UEAAJXZ
	.proc	?f783@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f783@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=783*8,r14	// r14 = &m_pUnk->vtbl[783] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[783]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[783].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[783].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f783@_QIThunk@ATL@@UEAAJXZ


	.global ?f784@_QIThunk@ATL@@UEAAJXZ
	.proc	?f784@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f784@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=784*8,r14	// r14 = &m_pUnk->vtbl[784] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[784]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[784].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[784].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f784@_QIThunk@ATL@@UEAAJXZ


	.global ?f785@_QIThunk@ATL@@UEAAJXZ
	.proc	?f785@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f785@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=785*8,r14	// r14 = &m_pUnk->vtbl[785] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[785]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[785].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[785].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f785@_QIThunk@ATL@@UEAAJXZ


	.global ?f786@_QIThunk@ATL@@UEAAJXZ
	.proc	?f786@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f786@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=786*8,r14	// r14 = &m_pUnk->vtbl[786] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[786]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[786].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[786].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f786@_QIThunk@ATL@@UEAAJXZ


	.global ?f787@_QIThunk@ATL@@UEAAJXZ
	.proc	?f787@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f787@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=787*8,r14	// r14 = &m_pUnk->vtbl[787] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[787]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[787].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[787].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f787@_QIThunk@ATL@@UEAAJXZ


	.global ?f788@_QIThunk@ATL@@UEAAJXZ
	.proc	?f788@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f788@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=788*8,r14	// r14 = &m_pUnk->vtbl[788] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[788]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[788].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[788].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f788@_QIThunk@ATL@@UEAAJXZ


	.global ?f789@_QIThunk@ATL@@UEAAJXZ
	.proc	?f789@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f789@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=789*8,r14	// r14 = &m_pUnk->vtbl[789] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[789]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[789].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[789].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f789@_QIThunk@ATL@@UEAAJXZ


	.global ?f790@_QIThunk@ATL@@UEAAJXZ
	.proc	?f790@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f790@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=790*8,r14	// r14 = &m_pUnk->vtbl[790] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[790]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[790].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[790].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f790@_QIThunk@ATL@@UEAAJXZ


	.global ?f791@_QIThunk@ATL@@UEAAJXZ
	.proc	?f791@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f791@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=791*8,r14	// r14 = &m_pUnk->vtbl[791] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[791]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[791].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[791].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f791@_QIThunk@ATL@@UEAAJXZ


	.global ?f792@_QIThunk@ATL@@UEAAJXZ
	.proc	?f792@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f792@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=792*8,r14	// r14 = &m_pUnk->vtbl[792] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[792]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[792].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[792].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f792@_QIThunk@ATL@@UEAAJXZ


	.global ?f793@_QIThunk@ATL@@UEAAJXZ
	.proc	?f793@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f793@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=793*8,r14	// r14 = &m_pUnk->vtbl[793] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[793]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[793].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[793].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f793@_QIThunk@ATL@@UEAAJXZ


	.global ?f794@_QIThunk@ATL@@UEAAJXZ
	.proc	?f794@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f794@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=794*8,r14	// r14 = &m_pUnk->vtbl[794] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[794]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[794].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[794].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f794@_QIThunk@ATL@@UEAAJXZ


	.global ?f795@_QIThunk@ATL@@UEAAJXZ
	.proc	?f795@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f795@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=795*8,r14	// r14 = &m_pUnk->vtbl[795] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[795]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[795].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[795].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f795@_QIThunk@ATL@@UEAAJXZ


	.global ?f796@_QIThunk@ATL@@UEAAJXZ
	.proc	?f796@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f796@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=796*8,r14	// r14 = &m_pUnk->vtbl[796] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[796]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[796].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[796].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f796@_QIThunk@ATL@@UEAAJXZ


	.global ?f797@_QIThunk@ATL@@UEAAJXZ
	.proc	?f797@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f797@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=797*8,r14	// r14 = &m_pUnk->vtbl[797] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[797]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[797].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[797].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f797@_QIThunk@ATL@@UEAAJXZ


	.global ?f798@_QIThunk@ATL@@UEAAJXZ
	.proc	?f798@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f798@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=798*8,r14	// r14 = &m_pUnk->vtbl[798] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[798]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[798].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[798].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f798@_QIThunk@ATL@@UEAAJXZ


	.global ?f799@_QIThunk@ATL@@UEAAJXZ
	.proc	?f799@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f799@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=799*8,r14	// r14 = &m_pUnk->vtbl[799] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[799]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[799].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[799].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f799@_QIThunk@ATL@@UEAAJXZ


	.global ?f800@_QIThunk@ATL@@UEAAJXZ
	.proc	?f800@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f800@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=800*8,r14	// r14 = &m_pUnk->vtbl[800] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[800]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[800].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[800].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f800@_QIThunk@ATL@@UEAAJXZ


	.global ?f801@_QIThunk@ATL@@UEAAJXZ
	.proc	?f801@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f801@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=801*8,r14	// r14 = &m_pUnk->vtbl[801] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[801]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[801].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[801].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f801@_QIThunk@ATL@@UEAAJXZ


	.global ?f802@_QIThunk@ATL@@UEAAJXZ
	.proc	?f802@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f802@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=802*8,r14	// r14 = &m_pUnk->vtbl[802] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[802]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[802].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[802].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f802@_QIThunk@ATL@@UEAAJXZ


	.global ?f803@_QIThunk@ATL@@UEAAJXZ
	.proc	?f803@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f803@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=803*8,r14	// r14 = &m_pUnk->vtbl[803] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[803]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[803].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[803].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f803@_QIThunk@ATL@@UEAAJXZ


	.global ?f804@_QIThunk@ATL@@UEAAJXZ
	.proc	?f804@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f804@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=804*8,r14	// r14 = &m_pUnk->vtbl[804] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[804]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[804].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[804].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f804@_QIThunk@ATL@@UEAAJXZ


	.global ?f805@_QIThunk@ATL@@UEAAJXZ
	.proc	?f805@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f805@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=805*8,r14	// r14 = &m_pUnk->vtbl[805] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[805]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[805].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[805].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f805@_QIThunk@ATL@@UEAAJXZ


	.global ?f806@_QIThunk@ATL@@UEAAJXZ
	.proc	?f806@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f806@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=806*8,r14	// r14 = &m_pUnk->vtbl[806] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[806]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[806].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[806].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f806@_QIThunk@ATL@@UEAAJXZ


	.global ?f807@_QIThunk@ATL@@UEAAJXZ
	.proc	?f807@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f807@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=807*8,r14	// r14 = &m_pUnk->vtbl[807] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[807]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[807].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[807].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f807@_QIThunk@ATL@@UEAAJXZ


	.global ?f808@_QIThunk@ATL@@UEAAJXZ
	.proc	?f808@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f808@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=808*8,r14	// r14 = &m_pUnk->vtbl[808] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[808]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[808].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[808].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f808@_QIThunk@ATL@@UEAAJXZ


	.global ?f809@_QIThunk@ATL@@UEAAJXZ
	.proc	?f809@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f809@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=809*8,r14	// r14 = &m_pUnk->vtbl[809] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[809]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[809].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[809].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f809@_QIThunk@ATL@@UEAAJXZ


	.global ?f810@_QIThunk@ATL@@UEAAJXZ
	.proc	?f810@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f810@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=810*8,r14	// r14 = &m_pUnk->vtbl[810] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[810]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[810].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[810].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f810@_QIThunk@ATL@@UEAAJXZ


	.global ?f811@_QIThunk@ATL@@UEAAJXZ
	.proc	?f811@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f811@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=811*8,r14	// r14 = &m_pUnk->vtbl[811] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[811]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[811].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[811].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f811@_QIThunk@ATL@@UEAAJXZ


	.global ?f812@_QIThunk@ATL@@UEAAJXZ
	.proc	?f812@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f812@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=812*8,r14	// r14 = &m_pUnk->vtbl[812] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[812]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[812].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[812].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f812@_QIThunk@ATL@@UEAAJXZ


	.global ?f813@_QIThunk@ATL@@UEAAJXZ
	.proc	?f813@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f813@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=813*8,r14	// r14 = &m_pUnk->vtbl[813] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[813]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[813].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[813].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f813@_QIThunk@ATL@@UEAAJXZ


	.global ?f814@_QIThunk@ATL@@UEAAJXZ
	.proc	?f814@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f814@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=814*8,r14	// r14 = &m_pUnk->vtbl[814] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[814]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[814].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[814].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f814@_QIThunk@ATL@@UEAAJXZ


	.global ?f815@_QIThunk@ATL@@UEAAJXZ
	.proc	?f815@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f815@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=815*8,r14	// r14 = &m_pUnk->vtbl[815] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[815]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[815].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[815].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f815@_QIThunk@ATL@@UEAAJXZ


	.global ?f816@_QIThunk@ATL@@UEAAJXZ
	.proc	?f816@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f816@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=816*8,r14	// r14 = &m_pUnk->vtbl[816] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[816]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[816].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[816].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f816@_QIThunk@ATL@@UEAAJXZ


	.global ?f817@_QIThunk@ATL@@UEAAJXZ
	.proc	?f817@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f817@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=817*8,r14	// r14 = &m_pUnk->vtbl[817] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[817]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[817].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[817].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f817@_QIThunk@ATL@@UEAAJXZ


	.global ?f818@_QIThunk@ATL@@UEAAJXZ
	.proc	?f818@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f818@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=818*8,r14	// r14 = &m_pUnk->vtbl[818] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[818]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[818].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[818].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f818@_QIThunk@ATL@@UEAAJXZ


	.global ?f819@_QIThunk@ATL@@UEAAJXZ
	.proc	?f819@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f819@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=819*8,r14	// r14 = &m_pUnk->vtbl[819] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[819]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[819].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[819].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f819@_QIThunk@ATL@@UEAAJXZ


	.global ?f820@_QIThunk@ATL@@UEAAJXZ
	.proc	?f820@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f820@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=820*8,r14	// r14 = &m_pUnk->vtbl[820] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[820]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[820].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[820].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f820@_QIThunk@ATL@@UEAAJXZ


	.global ?f821@_QIThunk@ATL@@UEAAJXZ
	.proc	?f821@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f821@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=821*8,r14	// r14 = &m_pUnk->vtbl[821] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[821]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[821].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[821].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f821@_QIThunk@ATL@@UEAAJXZ


	.global ?f822@_QIThunk@ATL@@UEAAJXZ
	.proc	?f822@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f822@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=822*8,r14	// r14 = &m_pUnk->vtbl[822] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[822]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[822].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[822].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f822@_QIThunk@ATL@@UEAAJXZ


	.global ?f823@_QIThunk@ATL@@UEAAJXZ
	.proc	?f823@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f823@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=823*8,r14	// r14 = &m_pUnk->vtbl[823] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[823]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[823].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[823].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f823@_QIThunk@ATL@@UEAAJXZ


	.global ?f824@_QIThunk@ATL@@UEAAJXZ
	.proc	?f824@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f824@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=824*8,r14	// r14 = &m_pUnk->vtbl[824] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[824]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[824].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[824].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f824@_QIThunk@ATL@@UEAAJXZ


	.global ?f825@_QIThunk@ATL@@UEAAJXZ
	.proc	?f825@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f825@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=825*8,r14	// r14 = &m_pUnk->vtbl[825] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[825]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[825].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[825].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f825@_QIThunk@ATL@@UEAAJXZ


	.global ?f826@_QIThunk@ATL@@UEAAJXZ
	.proc	?f826@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f826@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=826*8,r14	// r14 = &m_pUnk->vtbl[826] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[826]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[826].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[826].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f826@_QIThunk@ATL@@UEAAJXZ


	.global ?f827@_QIThunk@ATL@@UEAAJXZ
	.proc	?f827@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f827@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=827*8,r14	// r14 = &m_pUnk->vtbl[827] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[827]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[827].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[827].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f827@_QIThunk@ATL@@UEAAJXZ


	.global ?f828@_QIThunk@ATL@@UEAAJXZ
	.proc	?f828@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f828@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=828*8,r14	// r14 = &m_pUnk->vtbl[828] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[828]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[828].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[828].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f828@_QIThunk@ATL@@UEAAJXZ


	.global ?f829@_QIThunk@ATL@@UEAAJXZ
	.proc	?f829@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f829@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=829*8,r14	// r14 = &m_pUnk->vtbl[829] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[829]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[829].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[829].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f829@_QIThunk@ATL@@UEAAJXZ


	.global ?f830@_QIThunk@ATL@@UEAAJXZ
	.proc	?f830@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f830@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=830*8,r14	// r14 = &m_pUnk->vtbl[830] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[830]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[830].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[830].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f830@_QIThunk@ATL@@UEAAJXZ


	.global ?f831@_QIThunk@ATL@@UEAAJXZ
	.proc	?f831@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f831@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=831*8,r14	// r14 = &m_pUnk->vtbl[831] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[831]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[831].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[831].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f831@_QIThunk@ATL@@UEAAJXZ


	.global ?f832@_QIThunk@ATL@@UEAAJXZ
	.proc	?f832@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f832@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=832*8,r14	// r14 = &m_pUnk->vtbl[832] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[832]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[832].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[832].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f832@_QIThunk@ATL@@UEAAJXZ


	.global ?f833@_QIThunk@ATL@@UEAAJXZ
	.proc	?f833@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f833@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=833*8,r14	// r14 = &m_pUnk->vtbl[833] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[833]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[833].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[833].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f833@_QIThunk@ATL@@UEAAJXZ


	.global ?f834@_QIThunk@ATL@@UEAAJXZ
	.proc	?f834@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f834@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=834*8,r14	// r14 = &m_pUnk->vtbl[834] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[834]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[834].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[834].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f834@_QIThunk@ATL@@UEAAJXZ


	.global ?f835@_QIThunk@ATL@@UEAAJXZ
	.proc	?f835@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f835@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=835*8,r14	// r14 = &m_pUnk->vtbl[835] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[835]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[835].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[835].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f835@_QIThunk@ATL@@UEAAJXZ


	.global ?f836@_QIThunk@ATL@@UEAAJXZ
	.proc	?f836@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f836@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=836*8,r14	// r14 = &m_pUnk->vtbl[836] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[836]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[836].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[836].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f836@_QIThunk@ATL@@UEAAJXZ


	.global ?f837@_QIThunk@ATL@@UEAAJXZ
	.proc	?f837@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f837@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=837*8,r14	// r14 = &m_pUnk->vtbl[837] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[837]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[837].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[837].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f837@_QIThunk@ATL@@UEAAJXZ


	.global ?f838@_QIThunk@ATL@@UEAAJXZ
	.proc	?f838@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f838@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=838*8,r14	// r14 = &m_pUnk->vtbl[838] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[838]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[838].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[838].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f838@_QIThunk@ATL@@UEAAJXZ


	.global ?f839@_QIThunk@ATL@@UEAAJXZ
	.proc	?f839@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f839@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=839*8,r14	// r14 = &m_pUnk->vtbl[839] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[839]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[839].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[839].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f839@_QIThunk@ATL@@UEAAJXZ


	.global ?f840@_QIThunk@ATL@@UEAAJXZ
	.proc	?f840@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f840@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=840*8,r14	// r14 = &m_pUnk->vtbl[840] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[840]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[840].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[840].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f840@_QIThunk@ATL@@UEAAJXZ


	.global ?f841@_QIThunk@ATL@@UEAAJXZ
	.proc	?f841@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f841@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=841*8,r14	// r14 = &m_pUnk->vtbl[841] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[841]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[841].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[841].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f841@_QIThunk@ATL@@UEAAJXZ


	.global ?f842@_QIThunk@ATL@@UEAAJXZ
	.proc	?f842@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f842@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=842*8,r14	// r14 = &m_pUnk->vtbl[842] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[842]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[842].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[842].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f842@_QIThunk@ATL@@UEAAJXZ


	.global ?f843@_QIThunk@ATL@@UEAAJXZ
	.proc	?f843@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f843@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=843*8,r14	// r14 = &m_pUnk->vtbl[843] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[843]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[843].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[843].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f843@_QIThunk@ATL@@UEAAJXZ


	.global ?f844@_QIThunk@ATL@@UEAAJXZ
	.proc	?f844@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f844@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=844*8,r14	// r14 = &m_pUnk->vtbl[844] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[844]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[844].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[844].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f844@_QIThunk@ATL@@UEAAJXZ


	.global ?f845@_QIThunk@ATL@@UEAAJXZ
	.proc	?f845@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f845@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=845*8,r14	// r14 = &m_pUnk->vtbl[845] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[845]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[845].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[845].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f845@_QIThunk@ATL@@UEAAJXZ


	.global ?f846@_QIThunk@ATL@@UEAAJXZ
	.proc	?f846@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f846@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=846*8,r14	// r14 = &m_pUnk->vtbl[846] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[846]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[846].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[846].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f846@_QIThunk@ATL@@UEAAJXZ


	.global ?f847@_QIThunk@ATL@@UEAAJXZ
	.proc	?f847@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f847@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=847*8,r14	// r14 = &m_pUnk->vtbl[847] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[847]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[847].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[847].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f847@_QIThunk@ATL@@UEAAJXZ


	.global ?f848@_QIThunk@ATL@@UEAAJXZ
	.proc	?f848@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f848@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=848*8,r14	// r14 = &m_pUnk->vtbl[848] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[848]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[848].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[848].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f848@_QIThunk@ATL@@UEAAJXZ


	.global ?f849@_QIThunk@ATL@@UEAAJXZ
	.proc	?f849@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f849@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=849*8,r14	// r14 = &m_pUnk->vtbl[849] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[849]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[849].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[849].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f849@_QIThunk@ATL@@UEAAJXZ


	.global ?f850@_QIThunk@ATL@@UEAAJXZ
	.proc	?f850@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f850@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=850*8,r14	// r14 = &m_pUnk->vtbl[850] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[850]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[850].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[850].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f850@_QIThunk@ATL@@UEAAJXZ


	.global ?f851@_QIThunk@ATL@@UEAAJXZ
	.proc	?f851@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f851@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=851*8,r14	// r14 = &m_pUnk->vtbl[851] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[851]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[851].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[851].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f851@_QIThunk@ATL@@UEAAJXZ


	.global ?f852@_QIThunk@ATL@@UEAAJXZ
	.proc	?f852@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f852@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=852*8,r14	// r14 = &m_pUnk->vtbl[852] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[852]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[852].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[852].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f852@_QIThunk@ATL@@UEAAJXZ


	.global ?f853@_QIThunk@ATL@@UEAAJXZ
	.proc	?f853@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f853@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=853*8,r14	// r14 = &m_pUnk->vtbl[853] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[853]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[853].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[853].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f853@_QIThunk@ATL@@UEAAJXZ


	.global ?f854@_QIThunk@ATL@@UEAAJXZ
	.proc	?f854@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f854@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=854*8,r14	// r14 = &m_pUnk->vtbl[854] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[854]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[854].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[854].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f854@_QIThunk@ATL@@UEAAJXZ


	.global ?f855@_QIThunk@ATL@@UEAAJXZ
	.proc	?f855@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f855@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=855*8,r14	// r14 = &m_pUnk->vtbl[855] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[855]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[855].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[855].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f855@_QIThunk@ATL@@UEAAJXZ


	.global ?f856@_QIThunk@ATL@@UEAAJXZ
	.proc	?f856@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f856@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=856*8,r14	// r14 = &m_pUnk->vtbl[856] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[856]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[856].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[856].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f856@_QIThunk@ATL@@UEAAJXZ


	.global ?f857@_QIThunk@ATL@@UEAAJXZ
	.proc	?f857@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f857@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=857*8,r14	// r14 = &m_pUnk->vtbl[857] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[857]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[857].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[857].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f857@_QIThunk@ATL@@UEAAJXZ


	.global ?f858@_QIThunk@ATL@@UEAAJXZ
	.proc	?f858@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f858@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=858*8,r14	// r14 = &m_pUnk->vtbl[858] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[858]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[858].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[858].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f858@_QIThunk@ATL@@UEAAJXZ


	.global ?f859@_QIThunk@ATL@@UEAAJXZ
	.proc	?f859@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f859@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=859*8,r14	// r14 = &m_pUnk->vtbl[859] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[859]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[859].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[859].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f859@_QIThunk@ATL@@UEAAJXZ


	.global ?f860@_QIThunk@ATL@@UEAAJXZ
	.proc	?f860@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f860@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=860*8,r14	// r14 = &m_pUnk->vtbl[860] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[860]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[860].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[860].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f860@_QIThunk@ATL@@UEAAJXZ


	.global ?f861@_QIThunk@ATL@@UEAAJXZ
	.proc	?f861@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f861@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=861*8,r14	// r14 = &m_pUnk->vtbl[861] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[861]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[861].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[861].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f861@_QIThunk@ATL@@UEAAJXZ


	.global ?f862@_QIThunk@ATL@@UEAAJXZ
	.proc	?f862@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f862@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=862*8,r14	// r14 = &m_pUnk->vtbl[862] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[862]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[862].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[862].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f862@_QIThunk@ATL@@UEAAJXZ


	.global ?f863@_QIThunk@ATL@@UEAAJXZ
	.proc	?f863@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f863@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=863*8,r14	// r14 = &m_pUnk->vtbl[863] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[863]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[863].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[863].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f863@_QIThunk@ATL@@UEAAJXZ


	.global ?f864@_QIThunk@ATL@@UEAAJXZ
	.proc	?f864@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f864@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=864*8,r14	// r14 = &m_pUnk->vtbl[864] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[864]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[864].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[864].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f864@_QIThunk@ATL@@UEAAJXZ


	.global ?f865@_QIThunk@ATL@@UEAAJXZ
	.proc	?f865@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f865@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=865*8,r14	// r14 = &m_pUnk->vtbl[865] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[865]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[865].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[865].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f865@_QIThunk@ATL@@UEAAJXZ


	.global ?f866@_QIThunk@ATL@@UEAAJXZ
	.proc	?f866@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f866@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=866*8,r14	// r14 = &m_pUnk->vtbl[866] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[866]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[866].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[866].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f866@_QIThunk@ATL@@UEAAJXZ


	.global ?f867@_QIThunk@ATL@@UEAAJXZ
	.proc	?f867@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f867@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=867*8,r14	// r14 = &m_pUnk->vtbl[867] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[867]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[867].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[867].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f867@_QIThunk@ATL@@UEAAJXZ


	.global ?f868@_QIThunk@ATL@@UEAAJXZ
	.proc	?f868@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f868@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=868*8,r14	// r14 = &m_pUnk->vtbl[868] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[868]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[868].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[868].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f868@_QIThunk@ATL@@UEAAJXZ


	.global ?f869@_QIThunk@ATL@@UEAAJXZ
	.proc	?f869@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f869@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=869*8,r14	// r14 = &m_pUnk->vtbl[869] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[869]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[869].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[869].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f869@_QIThunk@ATL@@UEAAJXZ


	.global ?f870@_QIThunk@ATL@@UEAAJXZ
	.proc	?f870@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f870@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=870*8,r14	// r14 = &m_pUnk->vtbl[870] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[870]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[870].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[870].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f870@_QIThunk@ATL@@UEAAJXZ


	.global ?f871@_QIThunk@ATL@@UEAAJXZ
	.proc	?f871@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f871@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=871*8,r14	// r14 = &m_pUnk->vtbl[871] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[871]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[871].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[871].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f871@_QIThunk@ATL@@UEAAJXZ


	.global ?f872@_QIThunk@ATL@@UEAAJXZ
	.proc	?f872@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f872@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=872*8,r14	// r14 = &m_pUnk->vtbl[872] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[872]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[872].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[872].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f872@_QIThunk@ATL@@UEAAJXZ


	.global ?f873@_QIThunk@ATL@@UEAAJXZ
	.proc	?f873@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f873@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=873*8,r14	// r14 = &m_pUnk->vtbl[873] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[873]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[873].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[873].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f873@_QIThunk@ATL@@UEAAJXZ


	.global ?f874@_QIThunk@ATL@@UEAAJXZ
	.proc	?f874@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f874@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=874*8,r14	// r14 = &m_pUnk->vtbl[874] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[874]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[874].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[874].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f874@_QIThunk@ATL@@UEAAJXZ


	.global ?f875@_QIThunk@ATL@@UEAAJXZ
	.proc	?f875@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f875@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=875*8,r14	// r14 = &m_pUnk->vtbl[875] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[875]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[875].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[875].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f875@_QIThunk@ATL@@UEAAJXZ


	.global ?f876@_QIThunk@ATL@@UEAAJXZ
	.proc	?f876@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f876@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=876*8,r14	// r14 = &m_pUnk->vtbl[876] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[876]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[876].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[876].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f876@_QIThunk@ATL@@UEAAJXZ


	.global ?f877@_QIThunk@ATL@@UEAAJXZ
	.proc	?f877@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f877@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=877*8,r14	// r14 = &m_pUnk->vtbl[877] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[877]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[877].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[877].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f877@_QIThunk@ATL@@UEAAJXZ


	.global ?f878@_QIThunk@ATL@@UEAAJXZ
	.proc	?f878@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f878@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=878*8,r14	// r14 = &m_pUnk->vtbl[878] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[878]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[878].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[878].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f878@_QIThunk@ATL@@UEAAJXZ


	.global ?f879@_QIThunk@ATL@@UEAAJXZ
	.proc	?f879@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f879@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=879*8,r14	// r14 = &m_pUnk->vtbl[879] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[879]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[879].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[879].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f879@_QIThunk@ATL@@UEAAJXZ


	.global ?f880@_QIThunk@ATL@@UEAAJXZ
	.proc	?f880@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f880@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=880*8,r14	// r14 = &m_pUnk->vtbl[880] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[880]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[880].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[880].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f880@_QIThunk@ATL@@UEAAJXZ


	.global ?f881@_QIThunk@ATL@@UEAAJXZ
	.proc	?f881@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f881@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=881*8,r14	// r14 = &m_pUnk->vtbl[881] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[881]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[881].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[881].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f881@_QIThunk@ATL@@UEAAJXZ


	.global ?f882@_QIThunk@ATL@@UEAAJXZ
	.proc	?f882@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f882@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=882*8,r14	// r14 = &m_pUnk->vtbl[882] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[882]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[882].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[882].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f882@_QIThunk@ATL@@UEAAJXZ


	.global ?f883@_QIThunk@ATL@@UEAAJXZ
	.proc	?f883@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f883@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=883*8,r14	// r14 = &m_pUnk->vtbl[883] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[883]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[883].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[883].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f883@_QIThunk@ATL@@UEAAJXZ


	.global ?f884@_QIThunk@ATL@@UEAAJXZ
	.proc	?f884@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f884@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=884*8,r14	// r14 = &m_pUnk->vtbl[884] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[884]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[884].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[884].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f884@_QIThunk@ATL@@UEAAJXZ


	.global ?f885@_QIThunk@ATL@@UEAAJXZ
	.proc	?f885@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f885@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=885*8,r14	// r14 = &m_pUnk->vtbl[885] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[885]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[885].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[885].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f885@_QIThunk@ATL@@UEAAJXZ


	.global ?f886@_QIThunk@ATL@@UEAAJXZ
	.proc	?f886@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f886@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=886*8,r14	// r14 = &m_pUnk->vtbl[886] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[886]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[886].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[886].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f886@_QIThunk@ATL@@UEAAJXZ


	.global ?f887@_QIThunk@ATL@@UEAAJXZ
	.proc	?f887@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f887@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=887*8,r14	// r14 = &m_pUnk->vtbl[887] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[887]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[887].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[887].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f887@_QIThunk@ATL@@UEAAJXZ


	.global ?f888@_QIThunk@ATL@@UEAAJXZ
	.proc	?f888@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f888@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=888*8,r14	// r14 = &m_pUnk->vtbl[888] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[888]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[888].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[888].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f888@_QIThunk@ATL@@UEAAJXZ


	.global ?f889@_QIThunk@ATL@@UEAAJXZ
	.proc	?f889@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f889@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=889*8,r14	// r14 = &m_pUnk->vtbl[889] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[889]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[889].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[889].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f889@_QIThunk@ATL@@UEAAJXZ


	.global ?f890@_QIThunk@ATL@@UEAAJXZ
	.proc	?f890@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f890@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=890*8,r14	// r14 = &m_pUnk->vtbl[890] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[890]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[890].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[890].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f890@_QIThunk@ATL@@UEAAJXZ


	.global ?f891@_QIThunk@ATL@@UEAAJXZ
	.proc	?f891@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f891@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=891*8,r14	// r14 = &m_pUnk->vtbl[891] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[891]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[891].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[891].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f891@_QIThunk@ATL@@UEAAJXZ


	.global ?f892@_QIThunk@ATL@@UEAAJXZ
	.proc	?f892@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f892@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=892*8,r14	// r14 = &m_pUnk->vtbl[892] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[892]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[892].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[892].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f892@_QIThunk@ATL@@UEAAJXZ


	.global ?f893@_QIThunk@ATL@@UEAAJXZ
	.proc	?f893@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f893@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=893*8,r14	// r14 = &m_pUnk->vtbl[893] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[893]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[893].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[893].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f893@_QIThunk@ATL@@UEAAJXZ


	.global ?f894@_QIThunk@ATL@@UEAAJXZ
	.proc	?f894@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f894@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=894*8,r14	// r14 = &m_pUnk->vtbl[894] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[894]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[894].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[894].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f894@_QIThunk@ATL@@UEAAJXZ


	.global ?f895@_QIThunk@ATL@@UEAAJXZ
	.proc	?f895@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f895@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=895*8,r14	// r14 = &m_pUnk->vtbl[895] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[895]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[895].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[895].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f895@_QIThunk@ATL@@UEAAJXZ


	.global ?f896@_QIThunk@ATL@@UEAAJXZ
	.proc	?f896@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f896@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=896*8,r14	// r14 = &m_pUnk->vtbl[896] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[896]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[896].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[896].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f896@_QIThunk@ATL@@UEAAJXZ


	.global ?f897@_QIThunk@ATL@@UEAAJXZ
	.proc	?f897@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f897@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=897*8,r14	// r14 = &m_pUnk->vtbl[897] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[897]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[897].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[897].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f897@_QIThunk@ATL@@UEAAJXZ


	.global ?f898@_QIThunk@ATL@@UEAAJXZ
	.proc	?f898@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f898@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=898*8,r14	// r14 = &m_pUnk->vtbl[898] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[898]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[898].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[898].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f898@_QIThunk@ATL@@UEAAJXZ


	.global ?f899@_QIThunk@ATL@@UEAAJXZ
	.proc	?f899@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f899@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=899*8,r14	// r14 = &m_pUnk->vtbl[899] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[899]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[899].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[899].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f899@_QIThunk@ATL@@UEAAJXZ


	.global ?f900@_QIThunk@ATL@@UEAAJXZ
	.proc	?f900@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f900@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=900*8,r14	// r14 = &m_pUnk->vtbl[900] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[900]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[900].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[900].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f900@_QIThunk@ATL@@UEAAJXZ


	.global ?f901@_QIThunk@ATL@@UEAAJXZ
	.proc	?f901@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f901@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=901*8,r14	// r14 = &m_pUnk->vtbl[901] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[901]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[901].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[901].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f901@_QIThunk@ATL@@UEAAJXZ


	.global ?f902@_QIThunk@ATL@@UEAAJXZ
	.proc	?f902@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f902@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=902*8,r14	// r14 = &m_pUnk->vtbl[902] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[902]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[902].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[902].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f902@_QIThunk@ATL@@UEAAJXZ


	.global ?f903@_QIThunk@ATL@@UEAAJXZ
	.proc	?f903@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f903@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=903*8,r14	// r14 = &m_pUnk->vtbl[903] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[903]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[903].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[903].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f903@_QIThunk@ATL@@UEAAJXZ


	.global ?f904@_QIThunk@ATL@@UEAAJXZ
	.proc	?f904@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f904@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=904*8,r14	// r14 = &m_pUnk->vtbl[904] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[904]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[904].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[904].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f904@_QIThunk@ATL@@UEAAJXZ


	.global ?f905@_QIThunk@ATL@@UEAAJXZ
	.proc	?f905@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f905@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=905*8,r14	// r14 = &m_pUnk->vtbl[905] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[905]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[905].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[905].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f905@_QIThunk@ATL@@UEAAJXZ


	.global ?f906@_QIThunk@ATL@@UEAAJXZ
	.proc	?f906@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f906@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=906*8,r14	// r14 = &m_pUnk->vtbl[906] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[906]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[906].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[906].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f906@_QIThunk@ATL@@UEAAJXZ


	.global ?f907@_QIThunk@ATL@@UEAAJXZ
	.proc	?f907@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f907@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=907*8,r14	// r14 = &m_pUnk->vtbl[907] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[907]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[907].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[907].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f907@_QIThunk@ATL@@UEAAJXZ


	.global ?f908@_QIThunk@ATL@@UEAAJXZ
	.proc	?f908@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f908@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=908*8,r14	// r14 = &m_pUnk->vtbl[908] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[908]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[908].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[908].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f908@_QIThunk@ATL@@UEAAJXZ


	.global ?f909@_QIThunk@ATL@@UEAAJXZ
	.proc	?f909@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f909@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=909*8,r14	// r14 = &m_pUnk->vtbl[909] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[909]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[909].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[909].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f909@_QIThunk@ATL@@UEAAJXZ


	.global ?f910@_QIThunk@ATL@@UEAAJXZ
	.proc	?f910@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f910@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=910*8,r14	// r14 = &m_pUnk->vtbl[910] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[910]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[910].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[910].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f910@_QIThunk@ATL@@UEAAJXZ


	.global ?f911@_QIThunk@ATL@@UEAAJXZ
	.proc	?f911@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f911@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=911*8,r14	// r14 = &m_pUnk->vtbl[911] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[911]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[911].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[911].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f911@_QIThunk@ATL@@UEAAJXZ


	.global ?f912@_QIThunk@ATL@@UEAAJXZ
	.proc	?f912@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f912@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=912*8,r14	// r14 = &m_pUnk->vtbl[912] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[912]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[912].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[912].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f912@_QIThunk@ATL@@UEAAJXZ


	.global ?f913@_QIThunk@ATL@@UEAAJXZ
	.proc	?f913@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f913@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=913*8,r14	// r14 = &m_pUnk->vtbl[913] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[913]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[913].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[913].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f913@_QIThunk@ATL@@UEAAJXZ


	.global ?f914@_QIThunk@ATL@@UEAAJXZ
	.proc	?f914@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f914@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=914*8,r14	// r14 = &m_pUnk->vtbl[914] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[914]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[914].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[914].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f914@_QIThunk@ATL@@UEAAJXZ


	.global ?f915@_QIThunk@ATL@@UEAAJXZ
	.proc	?f915@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f915@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=915*8,r14	// r14 = &m_pUnk->vtbl[915] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[915]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[915].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[915].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f915@_QIThunk@ATL@@UEAAJXZ


	.global ?f916@_QIThunk@ATL@@UEAAJXZ
	.proc	?f916@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f916@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=916*8,r14	// r14 = &m_pUnk->vtbl[916] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[916]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[916].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[916].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f916@_QIThunk@ATL@@UEAAJXZ


	.global ?f917@_QIThunk@ATL@@UEAAJXZ
	.proc	?f917@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f917@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=917*8,r14	// r14 = &m_pUnk->vtbl[917] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[917]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[917].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[917].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f917@_QIThunk@ATL@@UEAAJXZ


	.global ?f918@_QIThunk@ATL@@UEAAJXZ
	.proc	?f918@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f918@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=918*8,r14	// r14 = &m_pUnk->vtbl[918] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[918]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[918].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[918].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f918@_QIThunk@ATL@@UEAAJXZ


	.global ?f919@_QIThunk@ATL@@UEAAJXZ
	.proc	?f919@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f919@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=919*8,r14	// r14 = &m_pUnk->vtbl[919] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[919]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[919].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[919].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f919@_QIThunk@ATL@@UEAAJXZ


	.global ?f920@_QIThunk@ATL@@UEAAJXZ
	.proc	?f920@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f920@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=920*8,r14	// r14 = &m_pUnk->vtbl[920] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[920]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[920].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[920].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f920@_QIThunk@ATL@@UEAAJXZ


	.global ?f921@_QIThunk@ATL@@UEAAJXZ
	.proc	?f921@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f921@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=921*8,r14	// r14 = &m_pUnk->vtbl[921] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[921]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[921].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[921].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f921@_QIThunk@ATL@@UEAAJXZ


	.global ?f922@_QIThunk@ATL@@UEAAJXZ
	.proc	?f922@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f922@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=922*8,r14	// r14 = &m_pUnk->vtbl[922] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[922]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[922].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[922].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f922@_QIThunk@ATL@@UEAAJXZ


	.global ?f923@_QIThunk@ATL@@UEAAJXZ
	.proc	?f923@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f923@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=923*8,r14	// r14 = &m_pUnk->vtbl[923] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[923]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[923].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[923].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f923@_QIThunk@ATL@@UEAAJXZ


	.global ?f924@_QIThunk@ATL@@UEAAJXZ
	.proc	?f924@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f924@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=924*8,r14	// r14 = &m_pUnk->vtbl[924] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[924]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[924].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[924].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f924@_QIThunk@ATL@@UEAAJXZ


	.global ?f925@_QIThunk@ATL@@UEAAJXZ
	.proc	?f925@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f925@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=925*8,r14	// r14 = &m_pUnk->vtbl[925] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[925]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[925].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[925].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f925@_QIThunk@ATL@@UEAAJXZ


	.global ?f926@_QIThunk@ATL@@UEAAJXZ
	.proc	?f926@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f926@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=926*8,r14	// r14 = &m_pUnk->vtbl[926] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[926]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[926].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[926].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f926@_QIThunk@ATL@@UEAAJXZ


	.global ?f927@_QIThunk@ATL@@UEAAJXZ
	.proc	?f927@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f927@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=927*8,r14	// r14 = &m_pUnk->vtbl[927] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[927]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[927].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[927].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f927@_QIThunk@ATL@@UEAAJXZ


	.global ?f928@_QIThunk@ATL@@UEAAJXZ
	.proc	?f928@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f928@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=928*8,r14	// r14 = &m_pUnk->vtbl[928] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[928]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[928].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[928].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f928@_QIThunk@ATL@@UEAAJXZ


	.global ?f929@_QIThunk@ATL@@UEAAJXZ
	.proc	?f929@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f929@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=929*8,r14	// r14 = &m_pUnk->vtbl[929] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[929]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[929].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[929].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f929@_QIThunk@ATL@@UEAAJXZ


	.global ?f930@_QIThunk@ATL@@UEAAJXZ
	.proc	?f930@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f930@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=930*8,r14	// r14 = &m_pUnk->vtbl[930] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[930]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[930].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[930].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f930@_QIThunk@ATL@@UEAAJXZ


	.global ?f931@_QIThunk@ATL@@UEAAJXZ
	.proc	?f931@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f931@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=931*8,r14	// r14 = &m_pUnk->vtbl[931] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[931]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[931].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[931].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f931@_QIThunk@ATL@@UEAAJXZ


	.global ?f932@_QIThunk@ATL@@UEAAJXZ
	.proc	?f932@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f932@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=932*8,r14	// r14 = &m_pUnk->vtbl[932] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[932]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[932].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[932].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f932@_QIThunk@ATL@@UEAAJXZ


	.global ?f933@_QIThunk@ATL@@UEAAJXZ
	.proc	?f933@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f933@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=933*8,r14	// r14 = &m_pUnk->vtbl[933] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[933]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[933].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[933].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f933@_QIThunk@ATL@@UEAAJXZ


	.global ?f934@_QIThunk@ATL@@UEAAJXZ
	.proc	?f934@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f934@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=934*8,r14	// r14 = &m_pUnk->vtbl[934] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[934]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[934].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[934].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f934@_QIThunk@ATL@@UEAAJXZ


	.global ?f935@_QIThunk@ATL@@UEAAJXZ
	.proc	?f935@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f935@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=935*8,r14	// r14 = &m_pUnk->vtbl[935] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[935]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[935].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[935].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f935@_QIThunk@ATL@@UEAAJXZ


	.global ?f936@_QIThunk@ATL@@UEAAJXZ
	.proc	?f936@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f936@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=936*8,r14	// r14 = &m_pUnk->vtbl[936] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[936]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[936].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[936].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f936@_QIThunk@ATL@@UEAAJXZ


	.global ?f937@_QIThunk@ATL@@UEAAJXZ
	.proc	?f937@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f937@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=937*8,r14	// r14 = &m_pUnk->vtbl[937] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[937]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[937].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[937].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f937@_QIThunk@ATL@@UEAAJXZ


	.global ?f938@_QIThunk@ATL@@UEAAJXZ
	.proc	?f938@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f938@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=938*8,r14	// r14 = &m_pUnk->vtbl[938] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[938]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[938].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[938].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f938@_QIThunk@ATL@@UEAAJXZ


	.global ?f939@_QIThunk@ATL@@UEAAJXZ
	.proc	?f939@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f939@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=939*8,r14	// r14 = &m_pUnk->vtbl[939] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[939]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[939].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[939].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f939@_QIThunk@ATL@@UEAAJXZ


	.global ?f940@_QIThunk@ATL@@UEAAJXZ
	.proc	?f940@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f940@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=940*8,r14	// r14 = &m_pUnk->vtbl[940] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[940]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[940].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[940].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f940@_QIThunk@ATL@@UEAAJXZ


	.global ?f941@_QIThunk@ATL@@UEAAJXZ
	.proc	?f941@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f941@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=941*8,r14	// r14 = &m_pUnk->vtbl[941] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[941]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[941].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[941].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f941@_QIThunk@ATL@@UEAAJXZ


	.global ?f942@_QIThunk@ATL@@UEAAJXZ
	.proc	?f942@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f942@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=942*8,r14	// r14 = &m_pUnk->vtbl[942] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[942]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[942].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[942].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f942@_QIThunk@ATL@@UEAAJXZ


	.global ?f943@_QIThunk@ATL@@UEAAJXZ
	.proc	?f943@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f943@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=943*8,r14	// r14 = &m_pUnk->vtbl[943] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[943]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[943].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[943].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f943@_QIThunk@ATL@@UEAAJXZ


	.global ?f944@_QIThunk@ATL@@UEAAJXZ
	.proc	?f944@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f944@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=944*8,r14	// r14 = &m_pUnk->vtbl[944] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[944]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[944].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[944].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f944@_QIThunk@ATL@@UEAAJXZ


	.global ?f945@_QIThunk@ATL@@UEAAJXZ
	.proc	?f945@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f945@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=945*8,r14	// r14 = &m_pUnk->vtbl[945] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[945]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[945].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[945].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f945@_QIThunk@ATL@@UEAAJXZ


	.global ?f946@_QIThunk@ATL@@UEAAJXZ
	.proc	?f946@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f946@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=946*8,r14	// r14 = &m_pUnk->vtbl[946] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[946]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[946].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[946].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f946@_QIThunk@ATL@@UEAAJXZ


	.global ?f947@_QIThunk@ATL@@UEAAJXZ
	.proc	?f947@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f947@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=947*8,r14	// r14 = &m_pUnk->vtbl[947] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[947]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[947].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[947].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f947@_QIThunk@ATL@@UEAAJXZ


	.global ?f948@_QIThunk@ATL@@UEAAJXZ
	.proc	?f948@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f948@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=948*8,r14	// r14 = &m_pUnk->vtbl[948] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[948]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[948].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[948].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f948@_QIThunk@ATL@@UEAAJXZ


	.global ?f949@_QIThunk@ATL@@UEAAJXZ
	.proc	?f949@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f949@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=949*8,r14	// r14 = &m_pUnk->vtbl[949] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[949]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[949].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[949].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f949@_QIThunk@ATL@@UEAAJXZ


	.global ?f950@_QIThunk@ATL@@UEAAJXZ
	.proc	?f950@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f950@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=950*8,r14	// r14 = &m_pUnk->vtbl[950] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[950]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[950].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[950].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f950@_QIThunk@ATL@@UEAAJXZ


	.global ?f951@_QIThunk@ATL@@UEAAJXZ
	.proc	?f951@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f951@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=951*8,r14	// r14 = &m_pUnk->vtbl[951] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[951]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[951].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[951].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f951@_QIThunk@ATL@@UEAAJXZ


	.global ?f952@_QIThunk@ATL@@UEAAJXZ
	.proc	?f952@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f952@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=952*8,r14	// r14 = &m_pUnk->vtbl[952] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[952]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[952].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[952].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f952@_QIThunk@ATL@@UEAAJXZ


	.global ?f953@_QIThunk@ATL@@UEAAJXZ
	.proc	?f953@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f953@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=953*8,r14	// r14 = &m_pUnk->vtbl[953] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[953]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[953].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[953].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f953@_QIThunk@ATL@@UEAAJXZ


	.global ?f954@_QIThunk@ATL@@UEAAJXZ
	.proc	?f954@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f954@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=954*8,r14	// r14 = &m_pUnk->vtbl[954] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[954]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[954].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[954].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f954@_QIThunk@ATL@@UEAAJXZ


	.global ?f955@_QIThunk@ATL@@UEAAJXZ
	.proc	?f955@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f955@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=955*8,r14	// r14 = &m_pUnk->vtbl[955] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[955]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[955].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[955].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f955@_QIThunk@ATL@@UEAAJXZ


	.global ?f956@_QIThunk@ATL@@UEAAJXZ
	.proc	?f956@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f956@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=956*8,r14	// r14 = &m_pUnk->vtbl[956] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[956]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[956].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[956].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f956@_QIThunk@ATL@@UEAAJXZ


	.global ?f957@_QIThunk@ATL@@UEAAJXZ
	.proc	?f957@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f957@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=957*8,r14	// r14 = &m_pUnk->vtbl[957] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[957]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[957].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[957].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f957@_QIThunk@ATL@@UEAAJXZ


	.global ?f958@_QIThunk@ATL@@UEAAJXZ
	.proc	?f958@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f958@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=958*8,r14	// r14 = &m_pUnk->vtbl[958] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[958]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[958].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[958].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f958@_QIThunk@ATL@@UEAAJXZ


	.global ?f959@_QIThunk@ATL@@UEAAJXZ
	.proc	?f959@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f959@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=959*8,r14	// r14 = &m_pUnk->vtbl[959] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[959]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[959].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[959].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f959@_QIThunk@ATL@@UEAAJXZ


	.global ?f960@_QIThunk@ATL@@UEAAJXZ
	.proc	?f960@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f960@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=960*8,r14	// r14 = &m_pUnk->vtbl[960] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[960]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[960].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[960].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f960@_QIThunk@ATL@@UEAAJXZ


	.global ?f961@_QIThunk@ATL@@UEAAJXZ
	.proc	?f961@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f961@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=961*8,r14	// r14 = &m_pUnk->vtbl[961] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[961]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[961].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[961].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f961@_QIThunk@ATL@@UEAAJXZ


	.global ?f962@_QIThunk@ATL@@UEAAJXZ
	.proc	?f962@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f962@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=962*8,r14	// r14 = &m_pUnk->vtbl[962] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[962]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[962].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[962].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f962@_QIThunk@ATL@@UEAAJXZ


	.global ?f963@_QIThunk@ATL@@UEAAJXZ
	.proc	?f963@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f963@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=963*8,r14	// r14 = &m_pUnk->vtbl[963] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[963]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[963].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[963].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f963@_QIThunk@ATL@@UEAAJXZ


	.global ?f964@_QIThunk@ATL@@UEAAJXZ
	.proc	?f964@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f964@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=964*8,r14	// r14 = &m_pUnk->vtbl[964] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[964]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[964].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[964].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f964@_QIThunk@ATL@@UEAAJXZ


	.global ?f965@_QIThunk@ATL@@UEAAJXZ
	.proc	?f965@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f965@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=965*8,r14	// r14 = &m_pUnk->vtbl[965] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[965]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[965].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[965].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f965@_QIThunk@ATL@@UEAAJXZ


	.global ?f966@_QIThunk@ATL@@UEAAJXZ
	.proc	?f966@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f966@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=966*8,r14	// r14 = &m_pUnk->vtbl[966] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[966]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[966].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[966].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f966@_QIThunk@ATL@@UEAAJXZ


	.global ?f967@_QIThunk@ATL@@UEAAJXZ
	.proc	?f967@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f967@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=967*8,r14	// r14 = &m_pUnk->vtbl[967] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[967]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[967].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[967].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f967@_QIThunk@ATL@@UEAAJXZ


	.global ?f968@_QIThunk@ATL@@UEAAJXZ
	.proc	?f968@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f968@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=968*8,r14	// r14 = &m_pUnk->vtbl[968] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[968]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[968].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[968].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f968@_QIThunk@ATL@@UEAAJXZ


	.global ?f969@_QIThunk@ATL@@UEAAJXZ
	.proc	?f969@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f969@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=969*8,r14	// r14 = &m_pUnk->vtbl[969] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[969]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[969].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[969].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f969@_QIThunk@ATL@@UEAAJXZ


	.global ?f970@_QIThunk@ATL@@UEAAJXZ
	.proc	?f970@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f970@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=970*8,r14	// r14 = &m_pUnk->vtbl[970] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[970]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[970].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[970].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f970@_QIThunk@ATL@@UEAAJXZ


	.global ?f971@_QIThunk@ATL@@UEAAJXZ
	.proc	?f971@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f971@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=971*8,r14	// r14 = &m_pUnk->vtbl[971] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[971]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[971].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[971].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f971@_QIThunk@ATL@@UEAAJXZ


	.global ?f972@_QIThunk@ATL@@UEAAJXZ
	.proc	?f972@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f972@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=972*8,r14	// r14 = &m_pUnk->vtbl[972] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[972]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[972].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[972].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f972@_QIThunk@ATL@@UEAAJXZ


	.global ?f973@_QIThunk@ATL@@UEAAJXZ
	.proc	?f973@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f973@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=973*8,r14	// r14 = &m_pUnk->vtbl[973] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[973]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[973].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[973].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f973@_QIThunk@ATL@@UEAAJXZ


	.global ?f974@_QIThunk@ATL@@UEAAJXZ
	.proc	?f974@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f974@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=974*8,r14	// r14 = &m_pUnk->vtbl[974] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[974]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[974].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[974].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f974@_QIThunk@ATL@@UEAAJXZ


	.global ?f975@_QIThunk@ATL@@UEAAJXZ
	.proc	?f975@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f975@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=975*8,r14	// r14 = &m_pUnk->vtbl[975] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[975]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[975].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[975].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f975@_QIThunk@ATL@@UEAAJXZ


	.global ?f976@_QIThunk@ATL@@UEAAJXZ
	.proc	?f976@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f976@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=976*8,r14	// r14 = &m_pUnk->vtbl[976] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[976]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[976].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[976].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f976@_QIThunk@ATL@@UEAAJXZ


	.global ?f977@_QIThunk@ATL@@UEAAJXZ
	.proc	?f977@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f977@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=977*8,r14	// r14 = &m_pUnk->vtbl[977] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[977]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[977].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[977].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f977@_QIThunk@ATL@@UEAAJXZ


	.global ?f978@_QIThunk@ATL@@UEAAJXZ
	.proc	?f978@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f978@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=978*8,r14	// r14 = &m_pUnk->vtbl[978] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[978]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[978].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[978].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f978@_QIThunk@ATL@@UEAAJXZ


	.global ?f979@_QIThunk@ATL@@UEAAJXZ
	.proc	?f979@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f979@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=979*8,r14	// r14 = &m_pUnk->vtbl[979] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[979]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[979].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[979].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f979@_QIThunk@ATL@@UEAAJXZ


	.global ?f980@_QIThunk@ATL@@UEAAJXZ
	.proc	?f980@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f980@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=980*8,r14	// r14 = &m_pUnk->vtbl[980] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[980]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[980].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[980].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f980@_QIThunk@ATL@@UEAAJXZ


	.global ?f981@_QIThunk@ATL@@UEAAJXZ
	.proc	?f981@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f981@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=981*8,r14	// r14 = &m_pUnk->vtbl[981] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[981]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[981].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[981].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f981@_QIThunk@ATL@@UEAAJXZ


	.global ?f982@_QIThunk@ATL@@UEAAJXZ
	.proc	?f982@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f982@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=982*8,r14	// r14 = &m_pUnk->vtbl[982] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[982]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[982].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[982].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f982@_QIThunk@ATL@@UEAAJXZ


	.global ?f983@_QIThunk@ATL@@UEAAJXZ
	.proc	?f983@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f983@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=983*8,r14	// r14 = &m_pUnk->vtbl[983] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[983]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[983].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[983].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f983@_QIThunk@ATL@@UEAAJXZ


	.global ?f984@_QIThunk@ATL@@UEAAJXZ
	.proc	?f984@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f984@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=984*8,r14	// r14 = &m_pUnk->vtbl[984] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[984]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[984].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[984].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f984@_QIThunk@ATL@@UEAAJXZ


	.global ?f985@_QIThunk@ATL@@UEAAJXZ
	.proc	?f985@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f985@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=985*8,r14	// r14 = &m_pUnk->vtbl[985] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[985]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[985].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[985].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f985@_QIThunk@ATL@@UEAAJXZ


	.global ?f986@_QIThunk@ATL@@UEAAJXZ
	.proc	?f986@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f986@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=986*8,r14	// r14 = &m_pUnk->vtbl[986] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[986]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[986].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[986].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f986@_QIThunk@ATL@@UEAAJXZ


	.global ?f987@_QIThunk@ATL@@UEAAJXZ
	.proc	?f987@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f987@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=987*8,r14	// r14 = &m_pUnk->vtbl[987] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[987]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[987].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[987].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f987@_QIThunk@ATL@@UEAAJXZ


	.global ?f988@_QIThunk@ATL@@UEAAJXZ
	.proc	?f988@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f988@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=988*8,r14	// r14 = &m_pUnk->vtbl[988] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[988]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[988].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[988].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f988@_QIThunk@ATL@@UEAAJXZ


	.global ?f989@_QIThunk@ATL@@UEAAJXZ
	.proc	?f989@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f989@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=989*8,r14	// r14 = &m_pUnk->vtbl[989] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[989]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[989].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[989].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f989@_QIThunk@ATL@@UEAAJXZ


	.global ?f990@_QIThunk@ATL@@UEAAJXZ
	.proc	?f990@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f990@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=990*8,r14	// r14 = &m_pUnk->vtbl[990] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[990]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[990].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[990].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f990@_QIThunk@ATL@@UEAAJXZ


	.global ?f991@_QIThunk@ATL@@UEAAJXZ
	.proc	?f991@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f991@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=991*8,r14	// r14 = &m_pUnk->vtbl[991] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[991]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[991].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[991].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f991@_QIThunk@ATL@@UEAAJXZ


	.global ?f992@_QIThunk@ATL@@UEAAJXZ
	.proc	?f992@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f992@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=992*8,r14	// r14 = &m_pUnk->vtbl[992] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[992]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[992].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[992].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f992@_QIThunk@ATL@@UEAAJXZ


	.global ?f993@_QIThunk@ATL@@UEAAJXZ
	.proc	?f993@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f993@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=993*8,r14	// r14 = &m_pUnk->vtbl[993] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[993]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[993].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[993].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f993@_QIThunk@ATL@@UEAAJXZ


	.global ?f994@_QIThunk@ATL@@UEAAJXZ
	.proc	?f994@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f994@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=994*8,r14	// r14 = &m_pUnk->vtbl[994] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[994]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[994].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[994].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f994@_QIThunk@ATL@@UEAAJXZ


	.global ?f995@_QIThunk@ATL@@UEAAJXZ
	.proc	?f995@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f995@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=995*8,r14	// r14 = &m_pUnk->vtbl[995] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[995]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[995].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[995].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f995@_QIThunk@ATL@@UEAAJXZ


	.global ?f996@_QIThunk@ATL@@UEAAJXZ
	.proc	?f996@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f996@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=996*8,r14	// r14 = &m_pUnk->vtbl[996] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[996]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[996].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[996].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f996@_QIThunk@ATL@@UEAAJXZ


	.global ?f997@_QIThunk@ATL@@UEAAJXZ
	.proc	?f997@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f997@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=997*8,r14	// r14 = &m_pUnk->vtbl[997] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[997]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[997].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[997].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f997@_QIThunk@ATL@@UEAAJXZ


	.global ?f998@_QIThunk@ATL@@UEAAJXZ
	.proc	?f998@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f998@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=998*8,r14	// r14 = &m_pUnk->vtbl[998] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[998]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[998].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[998].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f998@_QIThunk@ATL@@UEAAJXZ


	.global ?f999@_QIThunk@ATL@@UEAAJXZ
	.proc	?f999@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f999@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=999*8,r14	// r14 = &m_pUnk->vtbl[999] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[999]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[999].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[999].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f999@_QIThunk@ATL@@UEAAJXZ


	.global ?f1000@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1000@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1000@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1000*8,r14	// r14 = &m_pUnk->vtbl[1000] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1000]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1000].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1000].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1000@_QIThunk@ATL@@UEAAJXZ


	.global ?f1001@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1001@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1001@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1001*8,r14	// r14 = &m_pUnk->vtbl[1001] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1001]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1001].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1001].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1001@_QIThunk@ATL@@UEAAJXZ


	.global ?f1002@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1002@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1002@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1002*8,r14	// r14 = &m_pUnk->vtbl[1002] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1002]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1002].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1002].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1002@_QIThunk@ATL@@UEAAJXZ


	.global ?f1003@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1003@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1003@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1003*8,r14	// r14 = &m_pUnk->vtbl[1003] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1003]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1003].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1003].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1003@_QIThunk@ATL@@UEAAJXZ


	.global ?f1004@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1004@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1004@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1004*8,r14	// r14 = &m_pUnk->vtbl[1004] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1004]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1004].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1004].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1004@_QIThunk@ATL@@UEAAJXZ


	.global ?f1005@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1005@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1005@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1005*8,r14	// r14 = &m_pUnk->vtbl[1005] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1005]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1005].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1005].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1005@_QIThunk@ATL@@UEAAJXZ


	.global ?f1006@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1006@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1006@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1006*8,r14	// r14 = &m_pUnk->vtbl[1006] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1006]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1006].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1006].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1006@_QIThunk@ATL@@UEAAJXZ


	.global ?f1007@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1007@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1007@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1007*8,r14	// r14 = &m_pUnk->vtbl[1007] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1007]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1007].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1007].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1007@_QIThunk@ATL@@UEAAJXZ


	.global ?f1008@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1008@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1008@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1008*8,r14	// r14 = &m_pUnk->vtbl[1008] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1008]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1008].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1008].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1008@_QIThunk@ATL@@UEAAJXZ


	.global ?f1009@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1009@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1009@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1009*8,r14	// r14 = &m_pUnk->vtbl[1009] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1009]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1009].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1009].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1009@_QIThunk@ATL@@UEAAJXZ


	.global ?f1010@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1010@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1010@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1010*8,r14	// r14 = &m_pUnk->vtbl[1010] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1010]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1010].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1010].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1010@_QIThunk@ATL@@UEAAJXZ


	.global ?f1011@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1011@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1011@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1011*8,r14	// r14 = &m_pUnk->vtbl[1011] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1011]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1011].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1011].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1011@_QIThunk@ATL@@UEAAJXZ


	.global ?f1012@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1012@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1012@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1012*8,r14	// r14 = &m_pUnk->vtbl[1012] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1012]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1012].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1012].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1012@_QIThunk@ATL@@UEAAJXZ


	.global ?f1013@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1013@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1013@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1013*8,r14	// r14 = &m_pUnk->vtbl[1013] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1013]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1013].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1013].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1013@_QIThunk@ATL@@UEAAJXZ


	.global ?f1014@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1014@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1014@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1014*8,r14	// r14 = &m_pUnk->vtbl[1014] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1014]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1014].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1014].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1014@_QIThunk@ATL@@UEAAJXZ


	.global ?f1015@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1015@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1015@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1015*8,r14	// r14 = &m_pUnk->vtbl[1015] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1015]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1015].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1015].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1015@_QIThunk@ATL@@UEAAJXZ


	.global ?f1016@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1016@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1016@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1016*8,r14	// r14 = &m_pUnk->vtbl[1016] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1016]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1016].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1016].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1016@_QIThunk@ATL@@UEAAJXZ


	.global ?f1017@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1017@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1017@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1017*8,r14	// r14 = &m_pUnk->vtbl[1017] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1017]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1017].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1017].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1017@_QIThunk@ATL@@UEAAJXZ


	.global ?f1018@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1018@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1018@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1018*8,r14	// r14 = &m_pUnk->vtbl[1018] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1018]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1018].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1018].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1018@_QIThunk@ATL@@UEAAJXZ


	.global ?f1019@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1019@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1019@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1019*8,r14	// r14 = &m_pUnk->vtbl[1019] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1019]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1019].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1019].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1019@_QIThunk@ATL@@UEAAJXZ


	.global ?f1020@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1020@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1020@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1020*8,r14	// r14 = &m_pUnk->vtbl[1020] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1020]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1020].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1020].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1020@_QIThunk@ATL@@UEAAJXZ


	.global ?f1021@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1021@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1021@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1021*8,r14	// r14 = &m_pUnk->vtbl[1021] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1021]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1021].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1021].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1021@_QIThunk@ATL@@UEAAJXZ


	.global ?f1022@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1022@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1022@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1022*8,r14	// r14 = &m_pUnk->vtbl[1022] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1022]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1022].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1022].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1022@_QIThunk@ATL@@UEAAJXZ


	.global ?f1023@_QIThunk@ATL@@UEAAJXZ
	.proc	?f1023@_QIThunk@ATL@@UEAAJXZ
	.align	32

?f1023@_QIThunk@ATL@@UEAAJXZ:
		add				r16=16,r32		// r16 = &m_dwRef
		ld4				r16=[r16]		// r16 = m_dwRef
		cmp.le			p6,p7=r16,r0	// p6 = m_dwRef
(p6)	break.i			0x80016			// Break if call through deleted thunk
		add				r32=8,r32		// r32 = &m_pUnk 
		ld8				r32=[r32]		// r32 = m_pUnk 
		ld8				r14=[r32]		// r14 = m_pUnk->vtbl 
		add				r14=1023*8,r14	// r14 = &m_pUnk->vtbl[1023] 
		ld8				r14=[r14]		// r14 = m_pUnk->vtbl[1023]
		ld8				r15=[r14],8		// r15 = m_pUnk->vtbl[1023].pfn,
		ld8				gp=[r14]		// gp = m_pUnk->vtbl[1023].gp 
		mov				b6=r15
		br.sptk.many	b6				// Forward to actual call site 
	.endp	?f1023@_QIThunk@ATL@@UEAAJXZ
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmdichildwndex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxmdiframewndex.h"
#include "afxmdichildwndex.h"
#include "afxpaneframewnd.h"
#include "afxpreviewviewex.h"
#include "afxmdiclientareawnd.h"
#include "afxglobalutils.h"
#include "afxdockablepane.h"
#include "afxdatarecovery.h"

#include <dwmapi.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

BOOL CMDIChildWndEx::m_bEnableFloatingBars = FALSE;
DWORD CMDIChildWndEx::m_dwExcludeStyle = WS_CAPTION | WS_BORDER | WS_THICKFRAME;
DWORD CMDIChildWndEx::m_dwDefaultTaskbarTabPropertyFlags = STPF_USEAPPTHUMBNAILWHENACTIVE | STPF_USEAPPPEEKWHENACTIVE;

typedef HRESULT (STDAPICALLTYPE *PFNSETWINDOWATTRIBUTE)(HWND, DWORD, LPCVOID, DWORD);
typedef HRESULT (STDAPICALLTYPE *PFNSETICONICTHUMBNAIL)(HWND, HBITMAP, DWORD);
typedef HRESULT (STDAPICALLTYPE *PFNSETICONICLIVEPRBMP)(HWND, HBITMAP, POINT *, DWORD);
typedef HRESULT (STDAPICALLTYPE *PFNINVALIDATEICONICBITMAPS)(HWND);

/////////////////////////////////////////////////////////////////////////////
// CMDIChildWndEx

IMPLEMENT_DYNCREATE(CMDIChildWndEx, CMDIChildWnd)

#pragma warning(disable : 4355)

CMDIChildWndEx::CMDIChildWndEx() : m_Impl(this)
{
	m_pMDIFrame = NULL;
	m_bToBeDestroyed = FALSE;
	m_bWasMaximized = FALSE;
	m_bIsMinimized = FALSE;
	m_rectOriginal.SetRectEmpty();
	m_bActivating = FALSE;
	m_bInOnCreate = FALSE;

	// ---- MDITabGroup+
	m_pRelatedTabGroup = NULL;
	// ---- MDITabGroup-

	m_pTabbedControlBar = NULL;
	m_bTabRegistered = FALSE;
	m_bEnableTaskbarThumbnailClip = TRUE;
}

#pragma warning(default : 4355)

CMDIChildWndEx::~CMDIChildWndEx()
{
}

//{{AFX_MSG_MAP(CMDIChildWndEx)
BEGIN_MESSAGE_MAP(CMDIChildWndEx, CMDIChildWnd)
	ON_WM_CREATE()
	ON_WM_MDIACTIVATE()
	ON_WM_SIZE()
	ON_WM_SIZING()
	ON_WM_DESTROY()
	ON_WM_GETMINMAXINFO()
	ON_WM_NCPAINT()
	ON_WM_NCACTIVATE()
	ON_WM_NCMOUSEMOVE()
	ON_WM_NCHITTEST()
	ON_WM_NCCALCSIZE()
	ON_WM_LBUTTONUP()
	ON_WM_NCRBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_WINDOWPOSCHANGED()
	ON_WM_ERASEBKGND()
	ON_WM_STYLECHANGED()
	ON_WM_SYSCOMMAND()
	ON_MESSAGE(WM_SETTEXT, &CMDIChildWndEx::OnSetText)
	ON_MESSAGE(WM_SETICON, &CMDIChildWndEx::OnSetIcon)
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &CMDIChildWndEx::OnIdleUpdateCmdUI)
	ON_REGISTERED_MESSAGE(AFX_WM_CHANGEVISUALMANAGER, &CMDIChildWndEx::OnChangeVisualManager)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMDIChildWndEx message handlers

BOOL CMDIChildWndEx::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST && m_pMDIFrame != NULL && m_pMDIFrame->GetActivePopup() != NULL)
	{
		// Don't process accelerators if popup window is active
		return FALSE;
	}

	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE && m_pRelatedTabGroup != NULL && GetCapture() == m_pRelatedTabGroup)
	{
		m_pRelatedTabGroup->PostMessage(WM_CANCELMODE);
		return CMDIChildWnd::PreTranslateMessage(pMsg);
	}

	return CMDIChildWnd::PreTranslateMessage(pMsg);
}

int CMDIChildWndEx::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	m_pMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetMDIFrame());
	ASSERT_VALID(m_pMDIFrame);

	m_Impl.m_bHasBorder = (lpCreateStruct->style & WS_BORDER) != NULL;
	m_bInOnCreate = TRUE;

	if ((GetStyle() & WS_SYSMENU) == 0)
	{
		GetParent()->SetRedraw(FALSE);

		m_rectOriginal = CRect(CPoint(lpCreateStruct->x, lpCreateStruct->y), CSize(lpCreateStruct->cx, lpCreateStruct->cy));

		if (m_pMDIFrame != NULL && !m_pMDIFrame->IsMDITabbedGroup())
		{
			CRect rect;
			m_pMDIFrame->m_wndClientArea.GetClientRect(rect);

			CRect rectClient;
			GetClientRect(rectClient);
			ClientToScreen(rectClient);

			CRect rectScreen;
			GetWindowRect(rectScreen);

			rect.left -= rectClient.left - rectScreen.left;
			rect.top -= rectClient.top - rectScreen.top;
			rect.right += rectScreen.right - rectClient.right;
			rect.bottom += rectScreen.bottom - rectClient.bottom;

			SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
		}

		GetParent()->SetRedraw(TRUE);
	}

	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
	{
		m_bInOnCreate = FALSE;
		return -1;
	}

	if (m_pMDIFrame->IsPrintPreview())
	{
		m_pMDIFrame->SendMessage(WM_CLOSE);
	}

	CFrameImpl::AddFrame(this);
	RegisterTaskbarTab();

	PostMessage(AFX_WM_CHANGEVISUALMANAGER);

	m_bInOnCreate = FALSE;
	return 0;
}
void CMDIChildWndEx::RegisterTaskbarTab(CMDIChildWndEx* pWndBefore)
{
	ASSERT_VALID(this);

	if (!IsTaskbarTabsSupportEnabled())
	{
		return;
	}

#if (WINVER >= 0x0601)
	if (m_tabProxyWnd.GetSafeHwnd() != NULL)
	{
		// attempt to create a proxy despite it has been already created
		return;
	}

	m_tabProxyWnd.SetRelatedMDIChildFrame(this);
	CRect rect(CPoint(-32000, -32000), CSize(10, 10));

	CString strClassName = afxGlobalData.RegisterWindowClass(_T("AFX_SUPERBAR_TAB"));
	CString strWindowText;
	GetWindowText(strWindowText);

	if (!m_tabProxyWnd.CreateEx(WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE, strClassName, strWindowText, 
		WS_POPUP | WS_BORDER | WS_SYSMENU | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX, rect, NULL, 0, NULL))
	{
		TRACE1("Creation of tab proxy window failed, error code: %d", GetLastError());
		return;
	}

	ITaskbarList3* pTaskbarList3 = afxGlobalData.GetITaskbarList3();
	if (pTaskbarList3)
	{
		CMDIFrameWndEx* pTopLevel = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
		ASSERT_VALID(pTopLevel);

		HRESULT hr = pTaskbarList3->RegisterTab(m_tabProxyWnd.GetSafeHwnd(), pTopLevel->GetSafeHwnd());
		if (FAILED(hr))
		{
			TRACE1("Registration of tab failed, error code: %x", hr);
			UnregisterTaskbarTab();
			return;
		}

		if (pWndBefore == NULL && m_pMDIFrame != NULL)
		{
			// attempt to find right place automatically
			pWndBefore = m_pMDIFrame->m_wndClientArea.FindNextRegisteredWithTaskbarMDIChild(this);
		}

		CMDITabProxyWnd* pProxyWnd = pWndBefore != NULL ? pWndBefore->GetTabProxyWnd() : NULL;

		hr = pTaskbarList3->SetTabOrder(m_tabProxyWnd.GetSafeHwnd(), pProxyWnd->GetSafeHwnd());
		if (FAILED(hr))
		{
			TRACE1("Setting of tab order failed, error code: %x", hr);
			UnregisterTaskbarTab();
			return;
		}

		if (m_pMDIFrame != NULL && m_pMDIFrame->MDIGetActive() == this)
		{
			SetTaskbarTabActive();
		}

		// Set the appropriate DWM properties on the MDI child window
		BOOL bHasIconicBitmap = TRUE;

		HMODULE hDWMAPI = GetModuleHandle(_T("DWMAPI"));
		if (hDWMAPI != NULL)
		{
			PFNSETWINDOWATTRIBUTE pfnSetWindowAttribute = (PFNSETWINDOWATTRIBUTE)GetProcAddress(hDWMAPI, "DwmSetWindowAttribute");
			if (pfnSetWindowAttribute)
			{
				pfnSetWindowAttribute(m_tabProxyWnd.GetSafeHwnd(), DWMWA_HAS_ICONIC_BITMAP, &bHasIconicBitmap, sizeof(BOOL));
				pfnSetWindowAttribute(m_tabProxyWnd.GetSafeHwnd(), DWMWA_FORCE_ICONIC_REPRESENTATION, &bHasIconicBitmap, sizeof(BOOL));
			}
		}

		SetTaskbarTabProperties(m_dwDefaultTaskbarTabPropertyFlags);
		SetTaskbarTabText(strWindowText);
	}

	m_bTabRegistered = TRUE;

	// clips view area on taskbar thumbnail after registration
	if (IsRegisteredWithTaskbarTabs())
	{
		InvalidateIconicBitmaps();
	}

#endif
}
BOOL CMDIChildWndEx::IsRegisteredWithTaskbarTabs()
{
	return m_tabProxyWnd.GetSafeHwnd() != NULL;
}
BOOL CMDIChildWndEx::IsTaskbarTabsSupportEnabled()
{
	CMDIFrameWndEx* pTopLevel = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
	if (pTopLevel == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pTopLevel);

	CWinApp* pApp = AfxGetApp();
	if(pApp == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pApp);

	if (!pApp->IsTaskbarInteractionEnabled() || !CanShowOnTaskBarTabs() || !afxGlobalData.bIsWindows7 || (GetStyle () & WS_SYSMENU) != 0)
	{
		return FALSE;
	}

	return TRUE;
}
BOOL CMDIChildWndEx::InvalidateIconicBitmaps()
{
	ASSERT_VALID(this);

	if (!IsTaskbarTabsSupportEnabled() || !IsRegisteredWithTaskbarTabs()) 
	{
		return FALSE;
	}

	CRect rectThumbnailClip(0, 0, 0, 0);
	if (m_bEnableTaskbarThumbnailClip)
	{
		rectThumbnailClip = GetTaskbarThumbnailClipRect();
	}

	SetTaskbarThumbnailClipRect(rectThumbnailClip);

#if (WINVER >= 0x0601)
	HMODULE hDWMAPI = GetModuleHandle(_T("DWMAPI"));
	if (hDWMAPI != NULL)
	{
		PFNINVALIDATEICONICBITMAPS pfnInvalidateIconicBitmaps = (PFNINVALIDATEICONICBITMAPS)GetProcAddress(hDWMAPI, "DwmInvalidateIconicBitmaps");
		if (pfnInvalidateIconicBitmaps != NULL)
		{
			pfnInvalidateIconicBitmaps(m_tabProxyWnd.GetSafeHwnd());
		}
	}
#endif

	return TRUE;
}
void CMDIChildWndEx::UpdateTaskbarTabIcon(HICON hIcon)
{
	if (m_tabProxyWnd.GetSafeHwnd() != NULL)
	{
		m_tabProxyWnd.SetIcon(hIcon, FALSE);
	}
}
void CMDIChildWndEx::SetTaskbarTabOrder(CMDIChildWndEx* pWndBefore)
{
	ASSERT_VALID(this);

	if (!IsTaskbarTabsSupportEnabled() || !IsRegisteredWithTaskbarTabs()) 
	{
		return;
	}

	if (m_tabProxyWnd.GetSafeHwnd() != NULL)
	{
#if (WINVER >= 0x0601)
		ITaskbarList3* pTaskbarList = afxGlobalData.GetITaskbarList3();
		ASSERT(pTaskbarList != NULL);

		HWND hWndBefore = pWndBefore != NULL ? pWndBefore->GetTabProxyWnd()->GetSafeHwnd() : NULL;
		if (pTaskbarList != NULL)
		{
			pTaskbarList->SetTabOrder(m_tabProxyWnd.GetSafeHwnd(), hWndBefore);
		}
#endif
	}
}
void CMDIChildWndEx::SetTaskbarTabProperties(DWORD dwFlags)
{
	ASSERT_VALID(this);

	if (!IsTaskbarTabsSupportEnabled() || !IsRegisteredWithTaskbarTabs()) 
	{
		return;
	}

#if (WINVER >= 0x0601)
	if (m_tabProxyWnd.GetSafeHwnd() != NULL)
	{
		ITaskbarList3* pTaskbarList = afxGlobalData.GetITaskbarList3();
		ASSERT(pTaskbarList != NULL);

		CComQIPtr<ITaskbarList4> spTaskbarList4 = pTaskbarList;

		if (spTaskbarList4 != NULL)
		{
			HRESULT hr = spTaskbarList4->SetTabProperties(m_tabProxyWnd.GetSafeHwnd(), (STPFLAG)dwFlags);

			if (FAILED(hr))
			{
				TRACE1("CMDIChildWndEx::SetTaskbarTabProperties failed with code %x\n", hr);
			}
		}
	}
#endif
}
BOOL CMDIChildWndEx::DockPaneLeftOf(CPane* pBar, CPane* pLeftOf)
{
	m_dockManager.DockPaneLeftOf(pBar, pLeftOf);
	return TRUE;
}
void CMDIChildWndEx::SetTaskbarTabActive()
{
	ASSERT_VALID(this);

#if (WINVER >= 0x0601)
	if (!IsTaskbarTabsSupportEnabled())
		return;

	ITaskbarList3 *pTaskbarList3 = afxGlobalData.GetITaskbarList3();
	if (pTaskbarList3)
	{
		CMDIFrameWndEx* pParentFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
		ASSERT_VALID(pParentFrame);
		pTaskbarList3->SetTabActive(m_tabProxyWnd.GetSafeHwnd(), pParentFrame->GetSafeHwnd(), 0);
	}
#endif
}
void CMDIChildWndEx::OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd)
{
	static BOOL bActivating = FALSE;

	m_dockManager.OnActivateFrame(bActivate);

	m_bActivating = bActivate;

	if (!bActivating)
	{
		bActivating = TRUE;

		CMDIChildWnd::OnMDIActivate(bActivate, pActivateWnd, pDeactivateWnd);

		if (bActivate && m_pMDIFrame != NULL)
		{
			ASSERT_VALID(m_pMDIFrame);
			m_pMDIFrame->m_wndClientArea.SetActiveTab(pActivateWnd->GetSafeHwnd());
		}

#if (WINVER >= 0x0601)
		// If in MDI Tabbed or MDI Tabbed Group, mode, and if the application wants
		// the behavior, set the MDI child as the active tab in the task bar tab list.
		if (IsTaskbarTabsSupportEnabled() && IsRegisteredWithTaskbarTabs())
		{
			CWinApp* pApp = AfxGetApp();
			if (pApp != NULL)
			{
				CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
				if ((pHandler == NULL) || (!pHandler->GetShutdownByRestartManager()))
				{
					InvalidateIconicBitmaps();
					CMDIChildWndEx* pChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, pDeactivateWnd);
					if (pChild != NULL)
					{
						pChild->InvalidateIconicBitmaps();
					}

					SetTaskbarTabActive();
				}
			}
		}
#endif

		bActivating = FALSE;

		if (bActivate && m_pMDIFrame != NULL)
		{
			CDockingManager* parentDockManager = m_pMDIFrame->GetDockingManager();
			ASSERT_VALID(parentDockManager);

			if (parentDockManager != NULL && parentDockManager->IsOLEContainerMode() || m_dockManager.IsOLEContainerMode())
			{
				//parentDockManager->AdjustDockingLayout();
				afxGlobalUtils.ForceAdjustLayout(parentDockManager, TRUE);
			}
		}
	}

#if (WINVER >= 0x0601)
	if (bActivate && !IsTaskbarTabsSupportEnabled() || !IsRegisteredWithTaskbarTabs())
	{
		SetTaskbarThumbnailClipRect(CRect(0, 0, 0, 0));
	}
#endif
}

void CMDIChildWndEx::ActivateFrame(int nCmdShow)
{
	CWnd* pWndParent = GetParent();
	ASSERT_VALID(pWndParent);

	if (CMDIFrameWndEx::m_bDisableSetRedraw || pWndParent->GetSafeHwnd() == NULL)
	{
		if ((GetStyle() & WS_SYSMENU) == 0)
		{
			nCmdShow = SW_SHOWMAXIMIZED;
		}

		if (m_pMDIFrame != 0 && m_pMDIFrame->IsMDITabbedGroup())
		{
			nCmdShow = SW_SHOWNORMAL;
		}

		CMDIChildWnd::ActivateFrame(nCmdShow);
		return;
	}

	pWndParent->SetRedraw(FALSE);

	CMDIChildWnd::ActivateFrame(nCmdShow);

	pWndParent->SetRedraw(TRUE);
	pWndParent->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
}

LRESULT CMDIChildWndEx::OnSetText(WPARAM, LPARAM lParam)
{
	LRESULT lRes = Default();

	if (m_pMDIFrame != NULL)
	{
		ASSERT_VALID(m_pMDIFrame);
		m_pMDIFrame->m_wndClientArea.UpdateTabs(TRUE);
	}

	m_Impl.OnSetText((LPCTSTR)lParam);
	SetTaskbarTabText((LPCTSTR)lParam);

	return lRes;
}

void CMDIChildWndEx::SetTaskbarTabText(LPCTSTR lpcszDefaultText)
{
	if (IsTaskbarTabsSupportEnabled() && IsRegisteredWithTaskbarTabs())
	{
		CMDIFrameWndEx* pWnd = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
		if (pWnd == NULL)
		{
			return;
		}

		DWORD dwStyle = pWnd->GetStyle();

		if ((dwStyle & FWS_ADDTOTITLE) == FWS_ADDTOTITLE)
		{
			CString strFrameTitle = pWnd->GetTitle();
			CString strWndName;
			CString strChildTitle(lpcszDefaultText);

			if ((dwStyle & FWS_PREFIXTITLE) == FWS_PREFIXTITLE)
			{
				strWndName = strChildTitle + _T(" - ") + strFrameTitle;
			}
			else
			{
				strWndName = strFrameTitle + _T(" - ") + strChildTitle;
			}
			m_tabProxyWnd.SetWindowText((LPCTSTR)strWndName);
		}
		else
		{
			m_tabProxyWnd.SetWindowText(lpcszDefaultText);
		}
	}
}

LRESULT CMDIChildWndEx::OnSetIcon(WPARAM,LPARAM)
{
	LRESULT lRes = Default();

	if (m_pMDIFrame != NULL)
	{
		ASSERT_VALID(m_pMDIFrame);
		m_pMDIFrame->m_wndClientArea.UpdateTabs();
	}

	return lRes;
}

CString CMDIChildWndEx::GetFrameText() const
{
	ASSERT_VALID(this);

	CString strText;
	GetWindowText(strText);

	return strText;
}

HICON CMDIChildWndEx::GetFrameIcon() const
{
	ASSERT_VALID(this);

	HICON hIcon = GetIcon(FALSE);
	if (hIcon == NULL)
	{
		hIcon = (HICON)(LONG_PTR) GetClassLongPtr(GetSafeHwnd(), GCLP_HICONSM);
	}

	return hIcon;
}

void CMDIChildWndEx::OnUpdateFrameTitle(BOOL bAddToTitle)
{
	BOOL bRedraw = m_Impl.IsOwnerDrawCaption() && IsWindowVisible() &&(GetStyle() & WS_MAXIMIZE) == 0;

	CString strTitle1;

	if (bRedraw)
	{
		GetWindowText(strTitle1);
	}

	CMDIChildWnd::OnUpdateFrameTitle(bAddToTitle);

	if (bRedraw)
	{
		CString strTitle2;
		GetWindowText(strTitle2);

		if (strTitle1 != strTitle2)
		{
			SendMessage(WM_NCPAINT, 0, 0);
		}
	}

	if (m_pMDIFrame != NULL)
	{
		ASSERT_VALID(m_pMDIFrame);
		m_pMDIFrame->m_wndClientArea.UpdateTabs();
	}
}

void CMDIChildWndEx::OnSize(UINT nType, int cx, int cy)
{
	if (m_bToBeDestroyed)
	{
		// prevents main menu flickering when the last document is being closed
		return;
	}

	InvalidateIconicBitmaps();

	m_bIsMinimized = (nType == SIZE_MINIMIZED);

	if (CMFCVisualManager::GetInstance()->IsOwnerDrawCaption())
	{
		if (m_pMDIFrame != NULL && !m_pMDIFrame->IsMDITabbedGroup())
		{
			CRect rectWindow;
			GetWindowRect(rectWindow);

			WINDOWPOS wndpos;
			wndpos.flags = SWP_FRAMECHANGED;
			wndpos.x     = rectWindow.left;
			wndpos.y     = rectWindow.top;
			wndpos.cx    = rectWindow.Width();
			wndpos.cy    = rectWindow.Height();

			m_Impl.OnWindowPosChanging(&wndpos);
		}
		else if (m_Impl.m_bIsWindowRgn)
		{
			m_Impl.m_bIsWindowRgn = FALSE;
			SetWindowRgn(NULL, TRUE);
		}
	}

	if (!m_bIsMinimized && nType != SIZE_MAXIMIZED && !m_bWasMaximized)
	{
		m_dockManager.m_bSizeFrame = TRUE;
		CMDIChildWnd::OnSize(nType, cx, cy);
		AdjustDockingLayout();
		m_dockManager.m_bSizeFrame = FALSE;

		m_Impl.UpdateCaption();
		return;
	}

	CMDIChildWnd::OnSize(nType, cx, cy);

	if ((nType == SIZE_MAXIMIZED ||(nType == SIZE_RESTORED && m_bWasMaximized)))
	{
		RecalcLayout();

		if (m_pNotifyHook != NULL && nType == SIZE_RESTORED)
		{
			CMDIFrameWndEx* pTopLevelFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParentFrame());
			if (pTopLevelFrame == NULL || !pTopLevelFrame->AreMDITabs())
			{
				ModifyStyle(0, WS_OVERLAPPEDWINDOW);
			}
		}
	}

	m_bWasMaximized = (nType == SIZE_MAXIMIZED);
	m_Impl.UpdateCaption();
}

BOOL CMDIChildWndEx::PreCreateWindow(CREATESTRUCT& cs)
{
	m_dockManager.Create(this);
	return CMDIChildWnd::PreCreateWindow(cs);
}

void CMDIChildWndEx::AddDockSite()
{
	ASSERT_VALID(this);
}

BOOL CMDIChildWndEx::AddPane(CBasePane* pControlBar, BOOL bTail)
{
	ASSERT_VALID(this);
	return m_dockManager.AddPane(pControlBar, bTail);
}

BOOL CMDIChildWndEx::InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter)
{
	ASSERT_VALID(this);
	return m_dockManager.InsertPane(pControlBar, pTarget, bAfter);
}

void CMDIChildWndEx::RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement)
{
	ASSERT_VALID(this);
	m_dockManager.RemovePaneFromDockManager(pControlBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
}

void CMDIChildWndEx::DockPane(CBasePane* pBar, UINT nDockBarID, LPCRECT /*lpRect*/)
{
	ASSERT_VALID(this);

	if (pBar->CanFloat() && !CMDIChildWndEx::m_bEnableFloatingBars)
	{
		// bar can't be floating
		pBar->m_dwControlBarStyle &= ~AFX_CBRS_FLOAT;
	}

	if (pBar->CanBeResized() || pBar->CanFloat())
	{
		pBar->EnableDocking(CBRS_ALIGN_ANY);
		m_dockManager.DockPane(pBar, nDockBarID);
	}
	else
	{
		AddPane(pBar, TRUE);
	}
}

void CMDIChildWndEx::OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState)
{
	ASSERT_VALID(this);

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, AfxGetMainWnd());
	if (pMainFrame != NULL)
	{
		pMainFrame->SetPrintPreviewFrame(bPreview ? this : NULL);
	}

	m_dockManager.SetPrintPreviewMode(bPreview, pState);
	DWORD dwSavedState = pState->dwStates;
	CMDIChildWnd::OnSetPreviewMode(bPreview, pState);
	pState->dwStates = dwSavedState;

	AdjustDockingLayout();
	RecalcLayout();
}

CBasePane* CMDIChildWndEx::GetPane(UINT nID)
{
	ASSERT_VALID(this);

	CBasePane* pBar = m_dockManager.FindPaneByID(nID, TRUE);
	return pBar;
}

void CMDIChildWndEx::ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	pBar->ShowPane(bShow, bDelay, bActivate);
}

CBasePane* CMDIChildWndEx::PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
}

CBasePane* CMDIChildWndEx::PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, dwAlignment, pRTCBarType);
}

BOOL CMDIChildWndEx::IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const
{
	ASSERT_VALID(this);
	return m_dockManager.IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
}

void CMDIChildWndEx::AdjustDockingLayout(HDWP hdwp)
{
	ASSERT_VALID(this);

	if (m_dockManager.IsInAdjustLayout())
	{
		return;
	}

	m_dockManager.AdjustDockingLayout(hdwp);
	AdjustClientArea();
}

void CMDIChildWndEx::AdjustClientArea()
{
	CWnd* pChildWnd = (m_pTabbedControlBar != NULL && m_pTabbedControlBar->IsMDITabbed() &&
		m_pTabbedControlBar->GetParent() == this) ? m_pTabbedControlBar : GetDlgItem(AFX_IDW_PANE_FIRST);
	if (pChildWnd != NULL)
	{
		if (!pChildWnd->IsKindOf(RUNTIME_CLASS(CSplitterWnd)) && !pChildWnd->IsKindOf(RUNTIME_CLASS(CFormView)))
		{
			pChildWnd->ModifyStyle(0, WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
		}
		else
		{
			pChildWnd->ModifyStyle(0, WS_CLIPSIBLINGS);
		}

		if (!m_bInOnCreate && !CDockingManager::m_bFullScreenMode)
		{
			CRect rectClientAreaBounds = m_dockManager.GetClientAreaBounds();

			rectClientAreaBounds.left += m_rectBorder.left;
			rectClientAreaBounds.top  += m_rectBorder.top;
			rectClientAreaBounds.right -= m_rectBorder.right;
			rectClientAreaBounds.bottom -= m_rectBorder.bottom;

			pChildWnd->SetWindowPos(&wndBottom, rectClientAreaBounds.left, rectClientAreaBounds.top,
				rectClientAreaBounds.Width(), rectClientAreaBounds.Height(), SWP_NOACTIVATE);
		}
	}
}

BOOL CMDIChildWndEx::OnMoveMiniFrame(CWnd* pFrame)
{
	ASSERT_VALID(this);
	return m_dockManager.OnMoveMiniFrame(pFrame);
}

BOOL CMDIChildWndEx::EnableDocking(DWORD dwDockStyle)
{
	return m_dockManager.EnableDocking(dwDockStyle);
}

BOOL CMDIChildWndEx::EnableAutoHidePanes(DWORD dwDockStyle)
{
	return m_dockManager.EnableAutoHidePanes(dwDockStyle);
}

void CMDIChildWndEx::RecalcLayout(BOOL bNotify)
{
	if (m_bInRecalcLayout)
		return;

	m_bInRecalcLayout = TRUE;

	if (!m_bIsMinimized)
	{
		CView* pView = GetActiveView();

		if (m_dockManager.IsPrintPreviewValid() || m_dockManager.IsOLEContainerMode())
		{
			if (pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPreviewViewEx)))
			{

				m_dockManager.RecalcLayout(bNotify);
				CRect rectClient = m_dockManager.GetClientAreaBounds();
				pView->SetWindowPos(NULL, rectClient.left, rectClient.top, rectClient.Width(), rectClient.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);
			}
			else
			{
				COleClientItem* pActiveItem = NULL;
				pView = GetActiveView();

				if (pView != NULL && GetParentFrame()->GetActiveFrame() == this && m_bActivating)
				{
					ASSERT_VALID(pView);

					COleDocument* pDoc = DYNAMIC_DOWNCAST(COleDocument, pView->GetDocument());
					if (pDoc != NULL)
					{
						ASSERT_VALID(pDoc);
						pActiveItem = pDoc->GetInPlaceActiveItem(pView);

						if (bNotify && pActiveItem != NULL && pActiveItem->m_pInPlaceFrame != NULL)
						{
							pActiveItem->m_pInPlaceFrame->OnRecalcLayout();
						}
					}
					CRect rectClient;

					CFrameWnd* pFrame = pView->GetParentFrame();
					if (pFrame != NULL)
					{
						pFrame->GetClientRect(rectClient);
						pView->SetWindowPos(NULL, 0, 0, rectClient.Width(), rectClient.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);
					}
				}
				else
				{
					AdjustClientArea();
				}
			}
		}
		else
		{
			m_dockManager.RecalcLayout(bNotify);
			AdjustClientArea();
		}
	}

	m_bInRecalcLayout = FALSE;
}

void CMDIChildWndEx::OnSizing(UINT fwSide, LPRECT pRect)
{
	CMDIChildWnd::OnSizing(fwSide, pRect);

	CRect rect;
	GetWindowRect(rect);

	if (rect.Size() != CRect(pRect).Size())
	{
		AdjustDockingLayout();
	}

}
void CMDIChildWndEx::UnregisterTaskbarTab(BOOL bCheckRegisteredMDIChildCount)
{
#if (WINVER >= 0x0601)
	// If in MDI Tabbed or MDI Tabbed Group, mode, and if the application
	// wants the behavior, remove the MDI child from the task bar tab list.
	if (m_tabProxyWnd.GetSafeHwnd() != NULL)
	{
		ITaskbarList3 *pTaskbarList3 = afxGlobalData.GetITaskbarList3();
		if (pTaskbarList3)
		{
			pTaskbarList3->UnregisterTab(m_tabProxyWnd.GetSafeHwnd());
		}
		if (m_tabProxyWnd.GetSafeHwnd() != NULL)
		{
			m_tabProxyWnd.DestroyWindow();
		}

		if (bCheckRegisteredMDIChildCount)
		{
			// if no registered children - reset clip rect to full app window
			CMDIFrameWndEx* pTopLevel = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
			if (pTopLevel != NULL && pTopLevel->GetRegisteredWithTaskBarMDIChildCount() == 0)
			{
				ITaskbarList3* pTaskbarList3 = afxGlobalData.GetITaskbarList3();
				if (pTaskbarList3 != NULL)
				{
					pTaskbarList3->SetThumbnailClip(pTopLevel->GetSafeHwnd(), NULL);
				}

			}
		}
	}
#endif
}
void CMDIChildWndEx::OnDestroy()
{
	UnregisterTaskbarTab();

	if (m_pMDIFrame != NULL && m_pMDIFrame->IsPrintPreview())
	{
		m_pMDIFrame->SendMessage(WM_CLOSE);
	}

	if (m_pTabbedControlBar != NULL && CWnd::FromHandlePermanent(m_pTabbedControlBar->GetSafeHwnd()) != NULL)
	{
		CWnd* pParent = m_pTabbedControlBar->GetParent();

		if (pParent == this && m_pMDIFrame != NULL && !m_pMDIFrame->m_bClosing)
		{
			// tabbed MDI is being closed. We need to reassign parent of embedded control bar
			m_pTabbedControlBar->ShowWindow(SW_HIDE);
			m_pTabbedControlBar->SetParent(m_pTabbedControlBar->GetDockSiteFrameWnd());
			m_pMDIFrame->GetDockingManager()->AddHiddenMDITabbedBar(m_pTabbedControlBar);
		}
		m_pTabbedControlBar = NULL;
	}

	CFrameImpl::RemoveFrame(this);

	POSITION pos = NULL;

	for (pos = m_dockManager.m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pNextFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_dockManager.m_lstMiniFrames.GetNext(pos));
		if (pNextFrame != NULL)
		{
			pNextFrame->DestroyWindow();
		}
	}

	CList<HWND, HWND> lstChildren;
	CWnd* pNextWnd = GetTopWindow();
	while (pNextWnd != NULL)
	{
		lstChildren.AddTail(pNextWnd->m_hWnd);
		pNextWnd = pNextWnd->GetNextWindow();
	}

	for (pos = lstChildren.GetHeadPosition(); pos != NULL;)
	{
		HWND hwndNext = lstChildren.GetNext(pos);
		if (IsWindow(hwndNext) && ::GetParent(hwndNext) == m_hWnd)
		{
			::DestroyWindow(hwndNext);
		}
	}

	// CMDIClientAreaWnd::OnMDIDestroy will take care about removing from the tabs.
	m_pRelatedTabGroup = NULL;

	CMDIChildWnd::OnDestroy();
}

void CMDIChildWndEx::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
	if (m_pMDIFrame != NULL && m_pMDIFrame->IsFullScreen() && !m_pMDIFrame->AreMDITabs())
	{
		m_pMDIFrame->m_Impl.GetFullScreenMinMaxInfo(lpMMI);
	}
	else
	{
		CMDIChildWnd::OnGetMinMaxInfo(lpMMI);
	}
}

void CMDIChildWndEx::OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
	CMDIChildWnd::OnStyleChanged(nStyleType, lpStyleStruct);

	if (IsTaskbarTabsSupportEnabled())
	{
		RegisterTaskbarTab();
	}
	else
	{
		UnregisterTaskbarTab();
	}

	BOOL bWasSysMenu = (lpStyleStruct->styleOld & WS_SYSMENU);
	BOOL bIsSysMenu = (lpStyleStruct->styleNew & WS_SYSMENU);

	if (bWasSysMenu == bIsSysMenu)
	{
		return;
	}

	BOOL bIsInMDITabbedGroup = m_pMDIFrame != NULL && m_pMDIFrame->IsMDITabbedGroup();

	if (bWasSysMenu)
	{
		if ((lpStyleStruct->styleOld & WS_MAXIMIZE) == 0 && (lpStyleStruct->styleOld & WS_MINIMIZE) == 0)
		{
			CRect rectWindow;
			GetWindowRect(rectWindow);

			GetParent()->ScreenToClient(&rectWindow);
			m_rectOriginal = rectWindow;
		}

		if (m_pMDIFrame != NULL &&(m_pMDIFrame->m_wndClientArea.GetExStyle() & WS_EX_CLIENTEDGE) != 0)
		{
			m_pMDIFrame->m_wndClientArea.ModifyStyleEx(WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED);
		}

		if (!bIsInMDITabbedGroup)
		{
			if (!IsZoomed() && bIsSysMenu)
			{
				if (CMFCVisualManager::GetInstance()->IsOwnerDrawCaption())
				{
					m_Impl.m_bIsWindowRgn = CMFCVisualManager::GetInstance()->OnSetWindowRegion(this, m_rectOriginal.Size());
				}
				else
				{
					m_Impl.m_bIsWindowRgn = FALSE;
					SetWindowRgn(NULL, TRUE);
				}
			}

			CRect rect;
			m_pMDIFrame->m_wndClientArea.GetClientRect(rect);


			CRect rectClient;
			GetClientRect(rectClient);
			ClientToScreen(rectClient);

			CRect rectScreen;
			GetWindowRect(rectScreen);

			rect.left -= rectClient.left - rectScreen.left;
			rect.top -= rectClient.top - rectScreen.top;
			rect.right += rectScreen.right - rectClient.right;
			rect.bottom += rectScreen.bottom - rectClient.bottom;

			if (!rect.IsRectNull())
			{
				SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
			}
		}
	}
	else if (!bIsInMDITabbedGroup)
	{
		if (m_pMDIFrame != NULL &&(m_pMDIFrame->m_wndClientArea.GetExStyle() & WS_EX_CLIENTEDGE) == 0)
		{
			m_pMDIFrame->m_wndClientArea.ModifyStyleEx(0, WS_EX_CLIENTEDGE, SWP_FRAMECHANGED);
		}

		if (!IsZoomed() && bIsSysMenu)
		{
			if (CMFCVisualManager::GetInstance()->IsOwnerDrawCaption())
			{
				CRect rectWindow(m_rectOriginal);

				if (rectWindow.IsRectNull())
				{
					GetWindowRect(rectWindow);
					GetParent()->ScreenToClient(&rectWindow);
				}

				if (!rectWindow.IsRectNull())
				{
					m_Impl.m_bIsWindowRgn = CMFCVisualManager::GetInstance()->OnSetWindowRegion(this, rectWindow.Size());
				}
			}
			else
			{
				m_Impl.m_bIsWindowRgn = FALSE;
				SetWindowRgn(NULL, TRUE);
			}
		}

		if (!m_rectOriginal.IsRectNull())
		{
			SetWindowPos(NULL, m_rectOriginal.left, m_rectOriginal.top, m_rectOriginal.Width(), m_rectOriginal.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
		}
	}
}

void CMDIChildWndEx::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID == SC_KEYMENU) && m_pMDIFrame && m_pMDIFrame->AreMDITabs())
	{
		// If in tabbed MDI mode, ignore request for the menu for
		// the MDI child windows--otherwise we loop infinitely.
		return;
	}

	CMDIChildWnd::OnSysCommand(nID, lParam);
}

LRESULT CMDIChildWndEx::OnIdleUpdateCmdUI(WPARAM, LPARAM)
{
	m_dockManager.SendMessageToMiniFrames(WM_IDLEUPDATECMDUI);
	return 0L;
}

LPCTSTR CMDIChildWndEx::GetDocumentName(CObject** /*pObj*/)
{
	CDocument* pDoc = GetActiveDocument();
	if (pDoc != NULL)
	{
		return pDoc->GetPathName();
	}
	return NULL;
}

void CMDIChildWndEx::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)
{
	if ((lpwndpos->flags & SWP_FRAMECHANGED) == SWP_FRAMECHANGED)
	{
		if (m_pMDIFrame != NULL && !m_pMDIFrame->IsMDITabbedGroup())
		{
			m_Impl.OnWindowPosChanging(lpwndpos);
		}
		else if (m_Impl.m_bIsWindowRgn)
		{
			m_Impl.m_bIsWindowRgn = FALSE;
			SetWindowRgn(NULL, TRUE);
		}
	}

	CMDIChildWnd::OnWindowPosChanged(lpwndpos);
}

void CMDIChildWndEx::OnNcPaint()
{
	BOOL bIsInMDITabbedGroup = m_pMDIFrame != NULL && m_pMDIFrame->IsMDITabbedGroup();

	if (bIsInMDITabbedGroup || IsZoomed() || !CMFCVisualManager::GetInstance()->IsOwnerDrawCaption())
	{
		Default();
		return;
	}

	if (!m_Impl.OnNcPaint())
	{
		Default();
	}
}

BOOL CMDIChildWndEx::OnNcActivate(BOOL bActive)
{
	BOOL bIsOwnerDraw = m_Impl.OnNcActivate(bActive);

	if (bIsOwnerDraw)
	{
		SetRedraw(FALSE);
	}

	BOOL bRes = CMDIChildWnd::OnNcActivate(bActive);

	if (bIsOwnerDraw)
	{
		SetRedraw(TRUE);
		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
	}

	CWinApp* pApp = AfxGetApp();
	if (pApp != NULL)
	{
		CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
		if ((pHandler == NULL) || (!pHandler->GetShutdownByRestartManager()))
		{
			InvalidateIconicBitmaps();
		}
	}

	return bRes;
}

void CMDIChildWndEx::OnNcMouseMove(UINT nHitTest, CPoint point)
{
	m_Impl.OnNcMouseMove(nHitTest, point);
	CMDIChildWnd::OnNcMouseMove(nHitTest, point);
}

LRESULT CMDIChildWndEx::OnNcHitTest(CPoint point)
{
	UINT nHit = m_Impl.OnNcHitTest(point);
	if (nHit != HTNOWHERE)
	{
		return nHit;
	}

	return CMDIChildWnd::OnNcHitTest(point);
}

LRESULT CMDIChildWndEx::OnChangeVisualManager(WPARAM, LPARAM)
{
	if (m_pMDIFrame != NULL && !m_pMDIFrame->IsMDITabbedGroup())
	{
		m_Impl.OnChangeVisualManager();
	}

	return 0;
}

#if (WINVER >= 0x0601)
void CMDIChildWndEx::OnSendIconicThumbnail(WPARAM, LPARAM)
{
	CDC dcThumbnail;
	PrintClient(&dcThumbnail, PRF_CLIENT);

	HBITMAP hBitmap = (HBITMAP)(dcThumbnail.GetCurrentBitmap()->m_hObject);
	HMODULE hDWMAPI = GetModuleHandleW(L"DWMAPI");
	if (hDWMAPI != NULL)
	{
		PFNSETICONICTHUMBNAIL pfnSetIconicThumbnail = (PFNSETICONICTHUMBNAIL)GetProcAddress(hDWMAPI, "DwmSetIconicThumbnail");
		if (pfnSetIconicThumbnail)
		{
			pfnSetIconicThumbnail(GetSafeHwnd(), hBitmap, DWM_SIT_DISPLAYFRAME);
		}
	}
}

void CMDIChildWndEx::OnSendIconicLivePreviewBitmap(WPARAM, LPARAM)
{
	CDC dcThumbnail;
	PrintClient(&dcThumbnail, PRF_CLIENT);

	CRect rectClient;
	GetClientRect(rectClient);
	CPoint ptClient;
	ptClient.x = rectClient.left;
	ptClient.y = rectClient.top;

	HBITMAP hBitmap = (HBITMAP)(dcThumbnail.GetCurrentBitmap()->m_hObject);
	HMODULE hDWMAPI = GetModuleHandleW(L"DWMAPI");
	if (hDWMAPI != NULL)
	{
		PFNSETICONICLIVEPRBMP pfnSetIconicLivePreviewBitmap = (PFNSETICONICLIVEPRBMP)GetProcAddress(hDWMAPI, "DwmSetIconicLivePreviewBitmap");
		if (pfnSetIconicLivePreviewBitmap)
		{
			pfnSetIconicLivePreviewBitmap(GetSafeHwnd(), hBitmap, &ptClient, DWM_SIT_DISPLAYFRAME);
		}
	}
}
#endif

BOOL CMDIChildWndEx::OnTaskbarTabThumbnailStretch(HBITMAP hBmpDst, const CRect& rectDst, HBITMAP hBmpSrc, const CRect& rectSrc)
{
	UNREFERENCED_PARAMETER(rectSrc);

	if (hBmpSrc == NULL || hBmpDst == NULL)
	{
		return FALSE;
	}

	CImage image;
	image.Attach(hBmpSrc);

	CClientDC dcClient(this);

	CDC dc;
	dc.CreateCompatibleDC(&dcClient);

	HBITMAP hOldBmp = (HBITMAP)dc.SelectObject(hBmpDst);

	BOOL bResult = image.Draw(dc.GetSafeHdc(), rectDst, Gdiplus::InterpolationModeHighQualityBicubic);

	dc.SelectObject(hOldBmp);

	return bResult;
}

void CMDIChildWndEx::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	BOOL bIsInMDITabbedGroup = m_pMDIFrame != NULL && m_pMDIFrame->IsMDITabbedGroup();

	if (!bIsInMDITabbedGroup && !IsZoomed() && CMFCVisualManager::GetInstance()->IsOwnerDrawCaption() && (GetStyle() & WS_BORDER) == 0)
	{
		lpncsp->rgrc[0].top += ::GetSystemMetrics(SM_CYCAPTION);
	}

	CMDIChildWnd::OnNcCalcSize(bCalcValidRects, lpncsp);
}

void CMDIChildWndEx::OnLButtonUp(UINT nFlags, CPoint point)
{
	m_Impl.OnLButtonUp(point);
	CMDIChildWnd::OnLButtonUp(nFlags, point);
}

void CMDIChildWndEx::OnMouseMove(UINT nFlags, CPoint point)
{
	m_Impl.OnMouseMove(point);
	CMDIChildWnd::OnMouseMove(nFlags, point);
}

void CMDIChildWndEx::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_Impl.OnLButtonDown(point);
	CMDIChildWnd::OnLButtonDown(nFlags, point);
}

void CMDIChildWndEx::AddTabbedPane(CDockablePane* pControlBar)
{
	ASSERT_VALID(pControlBar);
	m_pTabbedControlBar = pControlBar;

	m_pTabbedControlBar->OnBeforeChangeParent(this);
	m_pTabbedControlBar->EnableGripper(FALSE);
	m_pTabbedControlBar->SetParent(this);
	m_pTabbedControlBar->ShowWindow(SW_SHOW);
	m_pTabbedControlBar->SetMDITabbed(TRUE);

	m_pMDIFrame->GetDockingManager()->RemoveHiddenMDITabbedBar(m_pTabbedControlBar);

	AdjustClientArea();
}

BOOL CMDIChildWndEx::OnEraseBkgnd(CDC* /*pDC*/)
{
	return TRUE;
}

void CMDIChildWndEx::OnNcRButtonUp(UINT nHitTest, CPoint point)
{
	if (m_pTabbedControlBar != NULL && nHitTest == HTCAPTION && !IsZoomed())	
	{
		ASSERT_VALID(m_pTabbedControlBar);
		m_pTabbedControlBar->OnShowControlBarMenu(point);
		return;
	}

	CMDIChildWnd::OnNcRButtonUp(nHitTest, point);
}

CWnd* CMDIChildWndEx::GetTaskbarPreviewWnd()
{
	ASSERT_VALID(this);
	CWnd* pWnd = GetDescendantWindow(AFX_IDW_PANE_FIRST);

	if (pWnd->GetSafeHwnd() != NULL)
	{
		ASSERT_VALID(pWnd);

		CWnd* pParent = pWnd->GetParent();

		if (pParent != this && pParent->GetSafeHwnd() != NULL && pParent->IsKindOf(RUNTIME_CLASS(CSplitterWnd)))
		{
			pWnd = pParent;
		}
	}
	else
	{
		pWnd = GetWindow(GW_CHILD);
	}

	return pWnd;
}

void CMDIChildWndEx::OnTaskbarTabThumbnailActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	UNREFERENCED_PARAMETER(pWndOther);
	UNREFERENCED_PARAMETER(bMinimized);

	CMDIFrameWndEx* pTopLevelFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
	ASSERT_VALID(pTopLevelFrame);

	if (nState != WA_CLICKACTIVE)
	{
		ActivateTopLevelFrame();
	}
}

int CMDIChildWndEx::OnTaskbarTabThumbnailMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	UNREFERENCED_PARAMETER(pDesktopWnd);
	UNREFERENCED_PARAMETER(nHitTest);

	CMDIFrameWndEx* pTopLevelFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
	ASSERT_VALID(pTopLevelFrame);

	if (message == WM_LBUTTONUP)
	{
		ActivateTopLevelFrame();
	}
	return 1;
}

void CMDIChildWndEx::OnPressTaskbarThmbnailCloseButton()
{
	CMDIFrameWndEx* pTopLevelFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
	ASSERT_VALID(pTopLevelFrame);

	if (pTopLevelFrame == NULL || !pTopLevelFrame->IsWindowEnabled())
	{
		return;
	}

	CDocument* pDoc = GetActiveDocument();
	if (pDoc != NULL && pDoc->IsModified())
	{
		ActivateTopLevelFrame();
	}

	PostMessage(WM_CLOSE);
}

void CMDIChildWndEx::EnableTaskbarThumbnailClipRect(BOOL bEnable)
{
	m_bEnableTaskbarThumbnailClip = bEnable;

	if (GetSafeHwnd() == NULL)
	{
		return;
	}

	CRect rect(0, 0, 0, 0); 
	if (bEnable) 
	{
		rect = GetTaskbarThumbnailClipRect();
	}

	SetTaskbarThumbnailClipRect(rect);	
}

CRect CMDIChildWndEx::GetTaskbarThumbnailClipRect() const
{
	ASSERT_VALID(this);

	CRect rect(0, 0, 0, 0);
	GetWindowRect(rect);
	
	return rect;
}

BOOL CMDIChildWndEx::SetTaskbarThumbnailClipRect(CRect rect)
{
	if (!afxGlobalData.bIsWindows7)
	{
		return FALSE;
	}
	
	CMDIFrameWndEx* pTopLevel = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
	if (pTopLevel == NULL || pTopLevel->MDIGetActive() != this)
	{
		return FALSE;
	}

	if (!rect.IsRectNull())
	{
		pTopLevel->ScreenToClient(rect);
	}
	
	ITaskbarList3* pTaskbarList3 = afxGlobalData.GetITaskbarList3();
	if (pTaskbarList3 == NULL)
	{
		TRACE0("Warning: ITaskbarList3 is NULL.");
		return FALSE;
	}

	HRESULT hr = pTaskbarList3->SetThumbnailClip(pTopLevel->GetSafeHwnd(), rect.IsRectNull() || rect.IsRectEmpty() ? NULL : &rect);

	if (!SUCCEEDED(hr))
	{
		TRACE1("SetTaskbarThumbnailClipRect failed with code %x.", hr);
		return FALSE;
	}

	return TRUE;
}

void CMDIChildWndEx::ActivateTopLevelFrame()
{
	CMDIFrameWndEx* pTopLevel = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetTopLevelFrame());
	if (pTopLevel == NULL)
	{
		return;
	}

	ActivateFrame();
	pTopLevel->SetForegroundWindow();
	if (pTopLevel->IsIconic())
	{
		pTopLevel->ShowWindow(SW_RESTORE);
	}
	else
	{
		pTopLevel->ShowWindow(SW_SHOW);
	}
}
//////////////////////////////////////////////////
/// CMDITabProxyWnd

#if (WINVER >= 0x0601)
IMPLEMENT_DYNCREATE(CMDITabProxyWnd, CWnd)

BEGIN_MESSAGE_MAP(CMDITabProxyWnd, CWnd)
	ON_MESSAGE(WM_DWMSENDICONICTHUMBNAIL, &CMDITabProxyWnd::OnSendIconicThumbnail)
	ON_MESSAGE(WM_DWMSENDICONICLIVEPREVIEWBITMAP, &CMDITabProxyWnd::OnSendIconicLivePreviewBitmap)
	ON_WM_ACTIVATE()
	ON_WM_MOUSEACTIVATE()
	ON_WM_SYSCOMMAND()
	ON_WM_CLOSE()
END_MESSAGE_MAP()

CMDITabProxyWnd::CMDITabProxyWnd() : m_pRelatedMDIChildFrame(NULL)
{
}

CMDITabProxyWnd::~CMDITabProxyWnd()
{
}

void CMDITabProxyWnd::SetRelatedMDIChildFrame(CMDIChildWndEx* pRelatedMDIFrame)
{
	ASSERT_KINDOF(CMDIChildWndEx, pRelatedMDIFrame);
	m_pRelatedMDIChildFrame = pRelatedMDIFrame;
}

BOOL CMDITabProxyWnd::IsMDIChildActive()
{
	ASSERT_VALID(m_pRelatedMDIChildFrame);

	CMDIFrameWndEx* pTopLevel = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pRelatedMDIChildFrame->GetTopLevelFrame());
	ASSERT_VALID(pTopLevel);

	if (pTopLevel->IsIconic())
	{
		return FALSE;
	}

	return pTopLevel->MDIGetActive() == m_pRelatedMDIChildFrame;
}

static double CorrectZoomSize(const CSize& sizeSrc, CSize& sizeDst)
{
	double Zoom = min((double)sizeDst.cx / (double)sizeSrc.cx, (double)sizeDst.cy / (double)sizeSrc.cy);

	sizeDst.cx = (long)(sizeSrc.cx * Zoom);
	sizeDst.cy = (long)(sizeSrc.cy * Zoom);

	return Zoom;
}

HBITMAP CMDITabProxyWnd::GetClientBitmap (int nWidth, int nHeight, BOOL bIsThumbnail)
{
	if (m_pRelatedMDIChildFrame == NULL || nWidth <= 0 || nHeight <= 0)
	{
		return NULL;
	}

	CRect rectWnd;
	CWnd* pPreviewWnd = m_pRelatedMDIChildFrame->GetTaskbarPreviewWnd();

	ASSERT_VALID(pPreviewWnd);
	pPreviewWnd->GetWindowRect(rectWnd);

	rectWnd.OffsetRect(-rectWnd.left, -rectWnd.top);

	if (rectWnd.Width() <= 0 || rectWnd.Height() <= 0)
	{
		return NULL;
	}

	CImage bmpSrc;
	bmpSrc.CreateEx(rectWnd.Width(), rectWnd.Height(), 32, BI_RGB, NULL, CImage::createAlphaChannel);

	CClientDC dcPreview(pPreviewWnd);

	CDC dcThumbnail;
	dcThumbnail.CreateCompatibleDC(&dcPreview);
	HBITMAP pOldSrc = (HBITMAP)dcThumbnail.SelectObject(HBITMAP(bmpSrc));
	BOOL bAlphaChannelSet = FALSE;

	pPreviewWnd->OnDrawIconicThumbnailOrLivePreview(dcThumbnail, rectWnd, CSize (nWidth, nHeight), bIsThumbnail, bAlphaChannelSet);
	dcThumbnail.SelectObject(pOldSrc);

	if (!bAlphaChannelSet)
	{
		LPBYTE pBits = (LPBYTE)bmpSrc.GetBits();
		if (bmpSrc.GetPitch() < 0)
		{
			pBits = pBits + ((bmpSrc.GetHeight() - 1) * bmpSrc.GetPitch());
		}
		for (int i = 0; i < rectWnd.Width() * rectWnd.Height(); i++)
		{
			pBits[3] = 255;
			pBits += 4;
		}
	}

	CSize szDst(nWidth, nHeight);
	CorrectZoomSize(rectWnd.Size(), szDst);
	CRect rectDst (CPoint(0, 0), szDst);

	CImage bmpDst;
	bmpDst.CreateEx(szDst.cx, -szDst.cy, 32, BI_RGB, NULL, CImage::createAlphaChannel);

	{
		BOOL bHandled = FALSE;
		if (bIsThumbnail)
		{
			bHandled = m_pRelatedMDIChildFrame->OnTaskbarTabThumbnailStretch(HBITMAP(bmpDst), rectDst, HBITMAP(bmpSrc), rectWnd);
		}
		
		if (!bHandled)
		{
			CDC dc;
			dc.CreateCompatibleDC(&dcPreview);
			HBITMAP pOldDstBitmap = (HBITMAP)dc.SelectObject(HBITMAP(bmpDst));

			bmpSrc.AlphaBlend(dc.GetSafeHdc(), rectDst, rectWnd);
			dc.SelectObject(pOldDstBitmap);
		}
	}

	return bmpDst.Detach();
}

LRESULT CMDITabProxyWnd::OnSendIconicThumbnail(WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(wParam);

	if (m_pRelatedMDIChildFrame == NULL)
	{
		return Default();
	}

	// Probably _xSize will be swapped with _ySize in Win7 Release, because usually width resides in LOWORD.
	int nWidth = HIWORD(lParam); 
	int nHeight = LOWORD(lParam);

	HMODULE hDWMAPI = GetModuleHandle(_T("DWMAPI"));
	if (hDWMAPI != NULL)
	{
		PFNSETICONICTHUMBNAIL pfnSetIconicThumbnail = (PFNSETICONICTHUMBNAIL)GetProcAddress(hDWMAPI, "DwmSetIconicThumbnail");
		if (pfnSetIconicThumbnail)
		{
			HBITMAP hBitmap = m_pRelatedMDIChildFrame->OnGetIconicThumbnail(nWidth, nHeight); 
			if (hBitmap == NULL)
			{
				hBitmap = GetClientBitmap(nWidth, nHeight, TRUE);
			}
			
			HRESULT hr = pfnSetIconicThumbnail(GetSafeHwnd(), hBitmap, 0);
			if (FAILED(hr))
			{
				// trace error code
				TRACE1("pfnSetIconicThumbnail failed with code %x", hr);
			}
			DeleteObject(hBitmap);
		}
	}

	return Default();
}

LRESULT CMDITabProxyWnd::OnSendIconicLivePreviewBitmap(WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);

	if (m_pRelatedMDIChildFrame == NULL)
	{
		return 0;
	}

	ASSERT_VALID(m_pRelatedMDIChildFrame);

	BOOL bActive = IsMDIChildActive();
	CPoint ptClient(0,0);
	HBITMAP hBitmap = m_pRelatedMDIChildFrame->OnGetIconicLivePreviewBitmap(bActive, ptClient);

	if (hBitmap == NULL)
	{
		CMDIFrameWndEx* pTopLevelFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pRelatedMDIChildFrame->GetTopLevelFrame());
		ASSERT_VALID(pTopLevelFrame);

		CRect rectWnd;
		
		CWnd* pPrintWnd = m_pRelatedMDIChildFrame->GetTaskbarPreviewWnd();
		pPrintWnd->GetWindowRect(rectWnd);
		pTopLevelFrame->ScreenToClient(rectWnd);

		ptClient.x = rectWnd.left;
		ptClient.y = rectWnd.top;

		hBitmap = GetClientBitmap(rectWnd.Width(), rectWnd.Height(), FALSE);
	}

	HMODULE hDWMAPI = GetModuleHandle(_T("DWMAPI"));
	if (hDWMAPI != NULL)
	{
		PFNSETICONICLIVEPRBMP pfnSetIconicLivePreviewBitmap = (PFNSETICONICLIVEPRBMP)GetProcAddress(hDWMAPI, "DwmSetIconicLivePreviewBitmap");
		if (pfnSetIconicLivePreviewBitmap)
		{
			pfnSetIconicLivePreviewBitmap(GetSafeHwnd(), hBitmap, &ptClient, 0);
		}
	}
	DeleteObject(hBitmap);
	return 0;
}

void CMDITabProxyWnd::OnSysCommand(UINT nID, LPARAM lParam)
{
	if (m_pRelatedMDIChildFrame == NULL)
	{
		return;
	}

	ASSERT_VALID(m_pRelatedMDIChildFrame);

	CMDIFrameWndEx* pTopLevelFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pRelatedMDIChildFrame->GetTopLevelFrame());
	ASSERT_VALID(pTopLevelFrame);

	if (nID != SC_CLOSE)
	{
		if (nID != SC_MINIMIZE)
		{
			m_pRelatedMDIChildFrame->ActivateTopLevelFrame();
		}

		pTopLevelFrame->SendMessage(WM_SYSCOMMAND, nID, lParam);	
		return;
	}

	Default();
}

void CMDITabProxyWnd::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	if (m_pRelatedMDIChildFrame == NULL)
	{
		return;
	}

	m_pRelatedMDIChildFrame->OnTaskbarTabThumbnailActivate(nState, pWndOther, bMinimized);
}

int CMDITabProxyWnd::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	if (m_pRelatedMDIChildFrame == NULL)
	{
		return 0;
	}

	return m_pRelatedMDIChildFrame->OnTaskbarTabThumbnailMouseActivate(pDesktopWnd, nHitTest, message);
}

void CMDITabProxyWnd::OnClose()
{
	if (m_pRelatedMDIChildFrame == NULL)
	{
		return;
	}

	m_pRelatedMDIChildFrame->OnPressTaskbarThmbnailCloseButton();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmem.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"



/////////////////////////////////////////////////////////////////////////////
// Debug memory globals and implementation helpers

#ifdef _DEBUG       // most of this file is for debugging

void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine);
void* __cdecl operator new[](size_t nSize, int nType, LPCSTR lpszFileName, int nLine);

/////////////////////////////////////////////////////////////////////////////
// test allocation routines

void* PASCAL CObject::operator new(size_t nSize)
{
#ifdef _AFX_NO_DEBUG_CRT
	return ::operator new(nSize);
#else
	return ::operator new(nSize, _AFX_CLIENT_BLOCK, NULL, 0);
#endif // _AFX_NO_DEBUG_CRT
}

void PASCAL CObject::operator delete(void* p)
{
#ifdef _AFX_NO_DEBUG_CRT
	free(p);
#else
	_free_dbg(p, _AFX_CLIENT_BLOCK);
#endif
}

void PASCAL CObject::operator delete(void* p, void*)
{
#ifdef _AFX_NO_DEBUG_CRT
	free(p);
#else
	_free_dbg(p, _AFX_CLIENT_BLOCK);
#endif
}

#ifndef _AFX_NO_DEBUG_CRT

void* __cdecl operator new(size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

void* __cdecl operator new[](size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return ::operator new[](nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

void __cdecl operator delete(void* pData, LPCSTR /* lpszFileName */,
	int /* nLine */)
{
	::operator delete(pData);
}

void __cdecl operator delete[](void* pData, LPCSTR /* lpszFileName */,
	int /* nLine */)
{
	::operator delete(pData);
}

void* PASCAL
CObject::operator new(size_t nSize, LPCSTR lpszFileName, int nLine)
{
	return ::operator new(nSize, _AFX_CLIENT_BLOCK, lpszFileName, nLine);
}

void PASCAL
CObject::operator delete(void *pObject, LPCSTR /* lpszFileName */,
	int /* nLine */)
{
#ifdef _AFX_NO_DEBUG_CRT
	free(pObject);
#else
	_free_dbg(pObject, _AFX_CLIENT_BLOCK);
#endif
}

void* AFXAPI AfxAllocMemoryDebug(size_t nSize, BOOL bIsObject,  LPCSTR lpszFileName, int nLine)
{
	return _malloc_dbg(nSize, bIsObject ? _AFX_CLIENT_BLOCK : _NORMAL_BLOCK,
		lpszFileName, nLine);
}

void AFXAPI AfxFreeMemoryDebug(void* pbData, BOOL bIsObject)
{
	_free_dbg(pbData, bIsObject ? _AFX_CLIENT_BLOCK : _NORMAL_BLOCK);
}

/////////////////////////////////////////////////////////////////////////////
// allocation failure hook, tracking turn on

BOOL AFXAPI _AfxDefaultAllocHook(size_t, BOOL, LONG)
	{ return TRUE; }

AFX_STATIC_DATA AFX_ALLOC_HOOK pfnAllocHook = _AfxDefaultAllocHook;

AFX_STATIC_DATA _CRT_ALLOC_HOOK pfnCrtAllocHook = NULL;
int __cdecl _AfxAllocHookProxy(int nAllocType, void * pvData, size_t nSize,
	int nBlockUse, long lRequest, const unsigned char * szFilename, int nLine)
{
	if (nAllocType != _HOOK_ALLOC)
		return (pfnCrtAllocHook)(nAllocType, pvData, nSize,
			nBlockUse, lRequest, (const unsigned char*) szFilename, nLine);
	if ((pfnAllocHook)(nSize, _BLOCK_TYPE(nBlockUse) == _AFX_CLIENT_BLOCK, lRequest))
		return (pfnCrtAllocHook)(nAllocType, pvData, nSize,
			nBlockUse, lRequest, (const unsigned char*) szFilename, nLine);
	return FALSE;
}

AFX_ALLOC_HOOK AFXAPI AfxSetAllocHook(AFX_ALLOC_HOOK pfnNewHook)
{
	if (pfnCrtAllocHook == NULL)
		pfnCrtAllocHook = _CrtSetAllocHook(_AfxAllocHookProxy);

	AFX_ALLOC_HOOK pfnOldHook = pfnAllocHook;
	pfnAllocHook = pfnNewHook;
	return pfnOldHook;
}

// This can be set to TRUE to override all AfxEnableMemoryTracking calls,
// allowing all allocations, even MFC internal allocations to be tracked.
BOOL _afxMemoryLeakOverride = FALSE;

BOOL AFXAPI AfxEnableMemoryLeakOverride(BOOL bEnable)
{
	BOOL bOldState = _afxMemoryLeakOverride;
	_afxMemoryLeakOverride = bEnable;

	return bOldState;
}

BOOL AFXAPI AfxEnableMemoryTracking(BOOL bTrack)
{
	if (_afxMemoryLeakOverride)
		return TRUE;

	int nOldState = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
	if (bTrack)
		_CrtSetDbgFlag(nOldState | _CRTDBG_ALLOC_MEM_DF);
	else
		_CrtSetDbgFlag(nOldState & ~_CRTDBG_ALLOC_MEM_DF);
	return nOldState & _CRTDBG_ALLOC_MEM_DF;
}

/////////////////////////////////////////////////////////////////////////////
// stop on a specific memory request

// Obsolete API
void AFXAPI AfxSetAllocStop(LONG lRequestNumber)
{
	_CrtSetBreakAlloc(lRequestNumber);
}

BOOL AFXAPI AfxCheckMemory()
  // check all of memory (look for memory tromps)
{
	return _CrtCheckMemory();
}

// -- true if block of exact size, allocated on the heap
// -- set *plRequestNumber to request number (or 0)
BOOL AFXAPI AfxIsMemoryBlock(const void* pData, UINT nBytes,
		LONG* plRequestNumber)
{
	return _CrtIsMemoryBlock(pData, nBytes, plRequestNumber, NULL, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// CMemoryState

CMemoryState::CMemoryState()
{
	memset(this, 0, sizeof(*this));
}

void CMemoryState::UpdateData()
{
	for(int i = 0; i < nBlockUseMax; i++)
	{
		m_lCounts[i] = m_memState.lCounts[i];
		m_lSizes[i] = m_memState.lSizes[i];
	}
	m_lHighWaterCount = m_memState.lHighWaterCount;
	m_lTotalCount = m_memState.lTotalCount;
}

// fills 'this' with the difference, returns TRUE if significant
BOOL CMemoryState::Difference(const CMemoryState& oldState,
		const CMemoryState& newState)
{
	int nResult = _CrtMemDifference(&m_memState, &oldState.m_memState, &newState.m_memState);
	UpdateData();
	return nResult != 0;
}

void CMemoryState::DumpStatistics() const
{
	_CrtMemDumpStatistics(&m_memState);
}

// -- fill with current memory state
void CMemoryState::Checkpoint()
{
	_CrtMemCheckpoint(&m_memState);
	UpdateData();
}

// Dump objects created after this memory state was checkpointed
// Will dump all objects if this memory state wasn't checkpointed
// Dump all objects, report about non-objects also
// List request number in {}
void CMemoryState::DumpAllObjectsSince() const
{
	_CrtMemDumpAllObjectsSince(&m_memState);
}

/////////////////////////////////////////////////////////////////////////////
// Enumerate all objects allocated in the diagnostic memory heap

struct _AFX_ENUM_CONTEXT
{
	void (*m_pfn)(CObject*,void*);
	void* m_pContext;
};

AFX_STATIC void _AfxDoForAllObjectsProxy(void* pObject, void* pContext)
{
	_AFX_ENUM_CONTEXT* p = (_AFX_ENUM_CONTEXT*)pContext;
	(*p->m_pfn)((CObject*)pObject, p->m_pContext);
}

void AFXAPI
AfxDoForAllObjects(void (AFX_CDECL *pfn)(CObject*, void*), void* pContext)
{
	if (pfn == NULL)
	{
		AfxThrowInvalidArgException();
	}
	_AFX_ENUM_CONTEXT context;
	context.m_pfn = pfn;
	context.m_pContext = pContext;
	_CrtDoForAllClientObjects(_AfxDoForAllObjectsProxy, &context);
}

/////////////////////////////////////////////////////////////////////////////
// Automatic debug memory diagnostics

BOOL AFXAPI AfxDumpMemoryLeaks()
{
	return _CrtDumpMemoryLeaks();
}

#endif // _AFX_NO_DEBUG_CRT
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Non-diagnostic memory routines

int AFX_CDECL AfxNewHandler(size_t /* nSize */)
{
	AfxThrowMemoryException();
}

#pragma warning(disable: 4273)

#ifndef _AFXDLL
_PNH _afxNewHandler = &AfxNewHandler;
#endif

_PNH AFXAPI AfxGetNewHandler(void)
{
#ifdef _AFXDLL
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	return pState->m_pfnNewHandler;
#else
	return _afxNewHandler;
#endif
}

_PNH AFXAPI AfxSetNewHandler(_PNH pfnNewHandler)
{
#ifdef _AFXDLL
	AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
	_PNH pfnOldHandler = pState->m_pfnNewHandler;
	pState->m_pfnNewHandler = pfnNewHandler;
	return pfnOldHandler;
#else
	_PNH pfnOldHandler = _afxNewHandler;
	_afxNewHandler = pfnNewHandler;
	return pfnOldHandler;
#endif
}

AFX_STATIC_DATA const _PNH _pfnUninitialized = (_PNH)-1;

void* __cdecl operator new(size_t nSize)
{
	void* pResult;
#ifdef _AFXDLL
	_PNH pfnNewHandler = _pfnUninitialized;
#endif
	for (;;)
	{
#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		pResult = _malloc_dbg(nSize, _NORMAL_BLOCK, NULL, 0);
#else
		pResult = malloc(nSize);
#endif
		if (pResult != NULL)
			return pResult;

#ifdef _AFXDLL
		if (pfnNewHandler == _pfnUninitialized)
		{
			AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
			pfnNewHandler = pState->m_pfnNewHandler;
		}
		if (pfnNewHandler == NULL || (*pfnNewHandler)(nSize) == 0)
			break;
#else
		if (_afxNewHandler == NULL || (*_afxNewHandler)(nSize) == 0)
			break;
#endif
	}
	return pResult;
}

void __cdecl operator delete(void* p)
{
#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		_free_dbg(p, _NORMAL_BLOCK);
#else
		free(p);
#endif
}

void* __cdecl operator new[](size_t nSize)
{
	return ::operator new(nSize);
}

void __cdecl operator delete[](void* p)
{
	::operator delete(p);
}

#ifdef _DEBUG

void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine)
{
#ifdef _AFX_NO_DEBUG_CRT
	UNUSED_ALWAYS(nType);
	UNUSED_ALWAYS(lpszFileName);
	UNUSED_ALWAYS(nLine);
	return ::operator new(nSize);
#else
	void* pResult;
#ifdef _AFXDLL
	_PNH pfnNewHandler = _pfnUninitialized;
#endif
	for (;;)
	{
		pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);
		if (pResult != NULL)
			return pResult;

#ifdef _AFXDLL
		if (pfnNewHandler == _pfnUninitialized)
		{
			AFX_MODULE_THREAD_STATE* pState = AfxGetModuleThreadState();
			pfnNewHandler = pState->m_pfnNewHandler;
		}
		if (pfnNewHandler == NULL || (*pfnNewHandler)(nSize) == 0)
			break;
#else
		if (_afxNewHandler == NULL || (*_afxNewHandler)(nSize) == 0)
			break;
#endif
	}
	return pResult;
#endif
}

void __cdecl operator delete(void* p, int nType, LPCSTR /* lpszFileName */, int /* nLine */)
{
#if !defined(_AFX_NO_DEBUG_CRT) && defined(_DEBUG)
		_free_dbg(p, nType);
#else
		free(p);
#endif
}

void* __cdecl operator new[](size_t nSize, int nType, LPCSTR lpszFileName, int nLine)
{
	return ::operator new(nSize, nType, lpszFileName, nLine);
}

void __cdecl operator delete[](void* p, int nType, LPCSTR lpszFileName, int nLine)
{
	::operator delete(p, nType, lpszFileName, nLine);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmdiclientareawnd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxmdiclientareawnd.h"
#include "afxmdiframewndex.h"
#include "afxmdichildwndex.h"
#include "afxmenubar.h"
#include "afxdockablepane.h"
#include "afxbasetabbedpane.h"
#include "afxvisualmanager.h"
#include "afxregpath.h"
#include "afxsettingsstore.h"
#include "afxribbonres.h"
#include "afxribbonbar.h"
#include "afxglobalutils.h"
#include "afxdatarecovery.h"

#define AFX_REG_SECTION_FMT _T("%sMDIClientArea-%d")
#define AFX_REG_ENTRY_MDITABS_STATE _T("MDITabsState")

static const CString strMDIClientAreaProfile = _T("MDIClientArea");

UINT AFX_WM_ON_MOVETOTABGROUP = ::RegisterWindowMessage(_T("AFX_WM_ON_MOVETOTABGROUP"));

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CMDIClientAreaWnd, CWnd)

#define AFX_UM_UPDATE_TABS (WM_USER + 101)
#define AFX_RESIZE_MARGIN 40
#define AFX_NEW_GROUP_MARGIN 40

/////////////////////////////////////////////////////////////////////////////
// CMDITabInfo

CMDITabInfo::CMDITabInfo()
{
	m_tabLocation = CMFCTabCtrl::LOCATION_TOP;
	m_style = CMFCTabCtrl::STYLE_3D_SCROLLED;
	m_bTabCloseButton = TRUE;
	m_bTabCustomTooltips = FALSE;
	m_bTabIcons = FALSE;
	m_bAutoColor = FALSE;
	m_bDocumentMenu = FALSE;
	m_bEnableTabSwap = TRUE;
	m_nTabBorderSize = CMFCVisualManager::GetInstance()->GetMDITabsBordersSize();
	m_bFlatFrame = TRUE;
	m_bActiveTabCloseButton = FALSE;
}
void CMDITabInfo::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		ar << m_tabLocation;
		ar << m_style;
		ar << m_bTabCloseButton;
		ar << m_bTabIcons;
		ar << m_bAutoColor;
		ar << m_bDocumentMenu;
		ar << m_bEnableTabSwap;
		ar << m_nTabBorderSize;
	}
	else
	{
		int nValue;
		ar >> nValue;
		m_tabLocation = (CMFCTabCtrl::Location) nValue;

		ar >> nValue;
		m_style = (CMFCTabCtrl::Style) nValue;

		ar >> m_bTabCloseButton;
		ar >> m_bTabIcons;
		ar >> m_bAutoColor;
		ar >> m_bDocumentMenu;
		ar >> m_bEnableTabSwap;
		ar >> m_nTabBorderSize;
	}
}
/////////////////////////////////////////////////////////////////////////////
// CMDIClientAreaWnd

CMDIClientAreaWnd::CMDIClientAreaWnd()
{
	m_bTabIsVisible = FALSE;
	m_bTabIsEnabled = FALSE;

	m_bIsMDITabbedGroup = FALSE;
	m_groupAlignment = GROUP_NO_ALIGN;
	m_nResizeMargin = AFX_RESIZE_MARGIN;
	m_nNewGroupMargin = AFX_NEW_GROUP_MARGIN;

	m_bDisableUpdateTabs = FALSE;

	m_rectNewTabGroup.SetRectEmpty();
	m_nTotalResizeRest = 0;
}

CMDIClientAreaWnd::~CMDIClientAreaWnd()
{
	while (!m_lstTabbedGroups.IsEmpty())
	{
		delete m_lstTabbedGroups.RemoveTail();
	}

	while (!m_lstRemovedTabbedGroups.IsEmpty())
	{
		CMFCTabCtrl* pWnd= DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstRemovedTabbedGroups.RemoveTail());
		if (pWnd != NULL)
		{
			delete pWnd;
		}
	}

	if (!m_mapTabIcons.IsEmpty())
	{
		for (POSITION pos = m_mapTabIcons.GetStartPosition(); pos != NULL;)
		{
			CWnd* pWnd = NULL;
			CImageList* pImageList = NULL;

			m_mapTabIcons.GetNextAssoc(pos, pWnd, pImageList);
			if (pImageList != NULL)
			{
				delete pImageList;
			}
		}

		m_mapTabIcons.RemoveAll();
	}
}

void CMDIClientAreaWnd::EnableMDITabs(BOOL bEnable, const CMDITabInfo& params)
{
	if (m_bIsMDITabbedGroup)
	{
		EnableMDITabbedGroups(FALSE, params);
	}

	m_bTabIsEnabled = bEnable;
	m_bTabIsVisible = bEnable;

	m_mdiTabParams = params;
	ApplyParams(&m_wndTab);

	if (bEnable)
	{
		UpdateTabs();
		if (!IsKeepClientEdge())
		{
			ModifyStyleEx(WS_EX_CLIENTEDGE, 0);
		}
	}
	else
	{
		if (!IsKeepClientEdge())
		{
			ModifyStyleEx(0, WS_EX_CLIENTEDGE);
		}
	}

	if (m_wndTab.GetSafeHwnd() != NULL)
	{
		m_wndTab.ShowWindow(SW_SHOW);
	}

	BringWindowToTop();

	if (GetSafeHwnd() != NULL && GetParentFrame() != NULL)
	{
		GetParentFrame()->RecalcLayout();

		UINT uiRedrawFlags = RDW_ALLCHILDREN | RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE;

		if (m_wndTab.GetSafeHwnd() != NULL)
		{
			m_wndTab.RedrawWindow(NULL, NULL, uiRedrawFlags);
		}

		RedrawWindow(NULL, NULL, uiRedrawFlags);
	}
}

void CMDIClientAreaWnd::EnableMDITabbedGroups(BOOL bEnable, const CMDITabInfo& mdiTabParams)
{
	if (m_bTabIsEnabled)
	{
		EnableMDITabs(FALSE, mdiTabParams);
	}

	m_wndTab.ShowWindow(SW_HIDE);

	HWND hwndActive = (HWND) SendMessage(WM_MDIGETACTIVE, 0, 0);

	if (m_bIsMDITabbedGroup != bEnable)
	{
		m_bIsMDITabbedGroup = bEnable;

		if (!bEnable)
		{
			for (POSITION pos = m_lstTabbedGroups.GetHeadPosition(); pos != 0;)
			{
				CMFCTabCtrl* pNextWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
				ASSERT_VALID(pNextWnd);

				pNextWnd->ShowWindow(SW_HIDE);

				for (int i = 0; i < pNextWnd->GetTabsNum(); i++)
				{
					CWnd* pNextChildWnd = pNextWnd->GetTabWnd(i);
					ASSERT_VALID(pNextChildWnd);
					pNextChildWnd->ModifyStyle(0, CMDIChildWndEx::m_dwExcludeStyle | WS_SYSMENU, SWP_NOZORDER | SWP_FRAMECHANGED);
				}
			}
		}
	}

	m_bTabIsVisible = bEnable;

	if (!m_bIsMDITabbedGroup)
	{
		if (!IsKeepClientEdge())
		{
			ModifyStyleEx(0, WS_EX_CLIENTEDGE);
		}

		if (afxGlobalData.bIsWindowsVista)
		{
			CWnd* pWndChild = GetWindow(GW_CHILD);
			CList<CMDIChildWndEx*, CMDIChildWndEx*> lst;

			while (pWndChild != NULL)
			{
				ASSERT_VALID(pWndChild);

				CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, pWndChild);
				if (pMDIChild != NULL && pMDIChild->CanShowOnMDITabs())
				{
					lst.AddTail(pMDIChild);
				}

				pWndChild = pWndChild->GetNextWindow();
			}

			m_bDisableUpdateTabs = TRUE;

			for (POSITION pos = lst.GetTailPosition(); pos != NULL;)
			{
				CMDIChildWndEx* pMDIChild = lst.GetPrev(pos);
				pMDIChild->SetWindowPos(NULL, -1, -1, -1, -1, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_FRAMECHANGED);
			}

			m_bDisableUpdateTabs = FALSE;

			UpdateTabs();
		}

		return;
	}

	m_mdiTabParams = mdiTabParams;

	if (!IsKeepClientEdge())
	{
		ModifyStyleEx(WS_EX_CLIENTEDGE, 0);
	}

	POSITION pos = NULL;

	for (pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTabCtrl* pNextWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
		ASSERT_VALID(pNextWnd);
		pNextWnd->ShowWindow(SW_SHOWNA);
		ApplyParams(pNextWnd);
	}

	UpdateMDITabbedGroups(TRUE);

	for (pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTabCtrl* pNextWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
		ASSERT_VALID(pNextWnd);
		pNextWnd->RecalcLayout();
	}

	if (m_bIsMDITabbedGroup)
	{
		SetActiveTab(hwndActive);
	}
}

void CMDIClientAreaWnd::ApplyParams(CMFCTabCtrl* pTabWnd)
{
	ASSERT_VALID(pTabWnd);

	pTabWnd->ModifyTabStyle(m_mdiTabParams.m_style);
	pTabWnd->SetLocation(m_mdiTabParams.m_tabLocation);
	pTabWnd->m_bCloseBtn = m_mdiTabParams.m_bTabCloseButton;
	pTabWnd->m_bActiveTabCloseButton = m_mdiTabParams.m_bActiveTabCloseButton;
	pTabWnd->EnableTabDocumentsMenu(m_mdiTabParams.m_bDocumentMenu);
	pTabWnd->EnableAutoColor(m_mdiTabParams.m_bAutoColor);
	pTabWnd->EnableTabSwap(m_mdiTabParams.m_bEnableTabSwap);
	pTabWnd->SetTabBorderSize(m_mdiTabParams.m_nTabBorderSize);
	pTabWnd->EnableCustomToolTips(m_mdiTabParams.m_bTabCustomTooltips);

	pTabWnd->HideInactiveWindow(FALSE);
	pTabWnd->HideNoTabs();
	pTabWnd->AutoSizeWindow(FALSE);
	pTabWnd->AutoDestroyWindow(FALSE);
	pTabWnd->SetFlatFrame(m_mdiTabParams.m_bFlatFrame);
	pTabWnd->m_bTransparent = TRUE;
	pTabWnd->m_bTopEdge = TRUE;
	pTabWnd->SetDrawNoPrefix(TRUE, FALSE);
	pTabWnd->SetActiveTabBoldFont();
	pTabWnd->m_bActivateLastVisibleTab = TRUE;
	pTabWnd->m_bActivateTabOnRightClick = TRUE;

	pTabWnd->m_bIsMDITab = TRUE;
}

//{{AFX_MSG_MAP(CMDIClientAreaWnd)
BEGIN_MESSAGE_MAP(CMDIClientAreaWnd, CWnd)
	ON_WM_ERASEBKGND()
	ON_WM_STYLECHANGING()
	ON_MESSAGE(WM_MDISETMENU, &CMDIClientAreaWnd::OnSetMenu)
	ON_MESSAGE(WM_MDIREFRESHMENU, &CMDIClientAreaWnd::OnMDIRefreshMenu)
	ON_MESSAGE(WM_MDIDESTROY, &CMDIClientAreaWnd::OnMDIDestroy)
	ON_MESSAGE(WM_MDINEXT, &CMDIClientAreaWnd::OnMDINext)
	ON_MESSAGE(AFX_UM_UPDATE_TABS, &CMDIClientAreaWnd::OnUpdateTabs)
	ON_REGISTERED_MESSAGE(AFX_WM_GETDRAGBOUNDS, &CMDIClientAreaWnd::OnGetDragBounds)
	ON_REGISTERED_MESSAGE(AFX_WM_ON_DRAGCOMPLETE, &CMDIClientAreaWnd::OnDragComplete)
	ON_REGISTERED_MESSAGE(AFX_WM_ON_TABGROUPMOUSEMOVE, &CMDIClientAreaWnd::OnTabGroupMouseMove)
	ON_REGISTERED_MESSAGE(AFX_WM_ON_CANCELTABMOVE, &CMDIClientAreaWnd::OnCancelTabMove)
	ON_REGISTERED_MESSAGE(AFX_WM_ON_MOVETABCOMPLETE, &CMDIClientAreaWnd::OnMoveTabComplete)
	ON_REGISTERED_MESSAGE(AFX_WM_CHANGE_ACTIVE_TAB, &CMDIClientAreaWnd::OnActiveTabChanged)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMDIClientAreaWnd message handlers

afx_msg LRESULT CMDIClientAreaWnd::OnSetMenu(WPARAM wp, LPARAM lp)
{
	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParentFrame());
	if (pMainFrame != NULL && ::IsWindow(pMainFrame->GetSafeHwnd()))
	{
		if (pMainFrame->OnSetMenu((HMENU) wp))
		{
			wp = NULL;
		}
	}
	else
	{
		wp = NULL;
	}

	return DefWindowProc(WM_MDISETMENU, wp, lp);
}

LRESULT CMDIClientAreaWnd::OnMDIRefreshMenu(WPARAM /*wp*/, LPARAM /*lp*/)
{
	LRESULT lRes = Default();

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParentFrame());
	if (pMainFrame != NULL)
	{
		if (pMainFrame->GetMenuBar() != NULL)
		{
			pMainFrame->m_hmenuWindow = pMainFrame->GetWindowMenuPopup(pMainFrame->GetMenuBar()->GetHMenu());
		}

		if (pMainFrame->m_Impl.m_pRibbonBar != NULL)
		{
			pMainFrame->m_Impl.m_pRibbonBar->SetActiveMDIChild(pMainFrame->MDIGetActive());
		}
	}

	return lRes;
}

BOOL CMDIClientAreaWnd::OnEraseBkgnd(CDC* pDC)
{
	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParentFrame());
	if (pMainFrame != NULL && pMainFrame->OnEraseMDIClientBackground(pDC))
	{
		return TRUE;
	}

	CRect rectClient;
	GetClientRect(rectClient);

	if (CMFCVisualManager::GetInstance()->OnEraseMDIClientArea(pDC, rectClient))
	{
		return TRUE;
	}

	return CWnd::OnEraseBkgnd(pDC);
}

LRESULT CMDIClientAreaWnd::OnMDIDestroy(WPARAM wParam, LPARAM)
{
	LRESULT lRes = 0;
	CMDIFrameWndEx* pParentFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParentFrame());

	CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, CWnd::FromHandle((HWND)wParam));
	BOOL bTabHeightChanged = FALSE;

	if (!pParentFrame->m_bClosing && !CMDIFrameWndEx::m_bDisableSetRedraw)
	{
		SetRedraw(FALSE);
	}

	HWND hwndActive = NULL;
	if (pMDIChild != NULL)
	{
		CMFCTabCtrl* pTabWnd = pMDIChild->GetRelatedTabGroup();
		pMDIChild->SetRelatedTabGroup(NULL);
		if (pTabWnd != NULL)
		{
			int nTabsHeight = pTabWnd->GetTabsHeight();

			int iTab = pTabWnd->GetTabFromHwnd((HWND)wParam);
			if (iTab >= 0)
			{
				pMDIChild->m_bToBeDestroyed = TRUE;
			}

			CWinApp* pApp = AfxGetApp();
			CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
			BOOL bRecalcLayout = (pHandler == NULL || !pHandler->GetShutdownByRestartManager());

			// no need to activate another tab or re-layout the remaining tabs
			// if the application is being shut down by the restart manager.
			pTabWnd->RemoveTab(iTab, bRecalcLayout);

			if (pTabWnd->GetTabsNum() == 0)
			{
				POSITION pos = m_lstTabbedGroups.Find(pTabWnd);

				if (pos != NULL)
				{
					// find window to activate next group after the current group has been destroyed
					// we should find the window to activate only if the active group is being destroyed
					if (m_lstTabbedGroups.GetCount() > 1 && pTabWnd->IsActiveInMDITabGroup())
					{
						m_lstTabbedGroups.GetNext(pos);
						if (pos == NULL)
						{
							pos = m_lstTabbedGroups.GetHeadPosition();
						}

						if (pos != NULL)
						{
							CMFCTabCtrl* pNextTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetAt(pos));
							if (pNextTabWnd != NULL)
							{
								int iActiveTab = pNextTabWnd->GetActiveTab();
								if (iActiveTab == -1)
								{
									iActiveTab = 0;
								}
								CWnd* pActiveWnd = pNextTabWnd->GetTabWnd(iActiveTab);
								if (pActiveWnd != NULL)
								{
									ASSERT_VALID(pActiveWnd);
									hwndActive = pActiveWnd->GetSafeHwnd();
								}
							}
						}
					}
					RemoveTabGroup(pTabWnd);
				}
			}
			else
			{
				bTabHeightChanged = (nTabsHeight != pTabWnd->GetTabsHeight());
			}
		}
	}

	if (m_wndTab.GetSafeHwnd() != NULL)
	{
		int nTabsHeight = m_wndTab.GetTabsHeight();
		int iTab = m_wndTab.GetTabFromHwnd((HWND)wParam);
		if (iTab >= 0)
		{
			CMDIChildWndEx* pMDIChildTab = DYNAMIC_DOWNCAST(CMDIChildWndEx, m_wndTab.GetTabWnd(iTab));
			if (pMDIChildTab != NULL)
			{
				pMDIChildTab->m_bToBeDestroyed = TRUE;
			}

			m_wndTab.RemoveTab(iTab);
		}
		bTabHeightChanged = (nTabsHeight != m_wndTab.GetTabsHeight());
	}

	lRes = Default();
	if (bTabHeightChanged && pParentFrame != NULL)
	{
		pParentFrame->RecalcLayout();
	}

	if (!pParentFrame->m_bClosing)
	{
		if (IsWindow(hwndActive))
		{
			SetActiveTab(hwndActive);
		}
	}
	if (!pParentFrame->m_bClosing && !CMDIFrameWndEx::m_bDisableSetRedraw)
	{
		SetRedraw(TRUE);
		GetParent()->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_ALLCHILDREN);
	}

	return lRes;
}

void CMDIClientAreaWnd::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
	if (m_bDisableUpdateTabs)
	{
		return;
	}
	if (m_bIsMDITabbedGroup)
	{
		CalcWindowRectForMDITabbedGroups(lpClientRect, nAdjustType);
		CWnd::CalcWindowRect(lpClientRect, nAdjustType);
		return;
	}

	if (m_wndTab.GetSafeHwnd() != NULL)
	{
		BOOL bRedraw = FALSE;

		if (m_bTabIsVisible)
		{
			CRect rectOld;
			m_wndTab.GetWindowRect(rectOld);

			m_wndTab.SetWindowPos(NULL, lpClientRect->left, lpClientRect->top, lpClientRect->right - lpClientRect->left, lpClientRect->bottom - lpClientRect->top, SWP_NOZORDER | SWP_NOACTIVATE);

			CRect rectTabClient;
			m_wndTab.GetClientRect(rectTabClient);

			CRect rectTabWnd;
			m_wndTab.GetWndArea(rectTabWnd);

			lpClientRect->top += (rectTabWnd.top - rectTabClient.top);
			lpClientRect->bottom += (rectTabWnd.bottom - rectTabClient.bottom);
			lpClientRect->left += (rectTabWnd.left - rectTabClient.left);
			lpClientRect->right += (rectTabWnd.right - rectTabClient.right);

			m_wndTab.ShowWindow(SW_SHOWNA);

			CRect rectNew;
			m_wndTab.GetWindowRect(rectNew);

			bRedraw = (rectOld != rectNew);
		}
		else
		{
			m_wndTab.ShowWindow(SW_HIDE);
		}

		CRect rectOld;
		GetWindowRect(rectOld);
		int nHeightDelta = lpClientRect->bottom - lpClientRect->top - rectOld.Height();

		SetWindowPos(NULL, lpClientRect->left, lpClientRect->top, lpClientRect->right - lpClientRect->left, lpClientRect->bottom - lpClientRect->top, SWP_NOZORDER | SWP_NOACTIVATE);

		CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParentFrame());
		if (pMainFrame != NULL)
		{
			pMainFrame->OnSizeMDIClient(rectOld, lpClientRect);
		}

		if (!m_bTabIsVisible)
		{
			CRect rectClient;
			GetClientRect(&rectClient);
			CMDIFrameWndEx* pFrame = (CMDIFrameWndEx*) GetParentFrame();
			ASSERT_VALID(pFrame);
			HWND hwndT = ::GetWindow(pFrame->m_hWndMDIClient, GW_CHILD);

			while (hwndT != NULL)
			{
				DWORD dwStyle = ::GetWindowLong(hwndT, GWL_STYLE);
				if (dwStyle & WS_MAXIMIZE)
				{
					break; // nothing to move;
				}
				if (dwStyle & WS_MINIMIZE)
				{
					CRect rectWnd;
					::GetWindowRect(hwndT, rectWnd);
					ScreenToClient(&rectWnd);

					rectWnd.OffsetRect(0, nHeightDelta);

					if (rectWnd.top < rectClient.top)
					{
						rectWnd.top = rectClient.top;
					}

					::SetWindowPos(hwndT, NULL, rectWnd.left, rectWnd.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
				}

				hwndT=::GetWindow(hwndT,GW_HWNDNEXT);
			}
		}
	}

	CWnd::CalcWindowRect(lpClientRect, nAdjustType);

	int nActiveTab = m_wndTab.GetActiveTab();
	for (int i = 0; i < m_wndTab.GetTabsNum(); i++)
	{
		CWnd* pWnd = m_wndTab.GetTabWnd(i);
		if (pWnd->GetSafeHwnd() == 0)
		{
			continue;
		}

		// only applies to MDI children in "always maximize" mode
		if ((pWnd->GetStyle() & WS_MINIMIZE) != 0 &&
			((pWnd->GetStyle() & WS_SYSMENU) == 0))
		{
			pWnd->ShowWindow(SW_RESTORE);
		}

		DWORD dwFlags = SWP_NOACTIVATE;
		if (i != nActiveTab)
		{
			dwFlags |= SWP_NOZORDER | SWP_NOREDRAW;
		}

		CRect rect(0, 0, lpClientRect->right - lpClientRect->left, lpClientRect->bottom - lpClientRect->top);

		CRect rectClient;
		pWnd->GetClientRect(rectClient);
		pWnd->ClientToScreen(rectClient);

		CRect rectScreen;
		pWnd->GetWindowRect(rectScreen);

		rect.left -= rectClient.left - rectScreen.left;
		rect.top -= rectClient.top - rectScreen.top;
		rect.right += rectScreen.right - rectClient.right;
		rect.bottom += rectScreen.bottom - rectClient.bottom;

		if (rectClient == rect)
		{
			break;
		}

		if (pWnd != NULL &&((pWnd->GetStyle() & WS_SYSMENU) == 0))
		{
			pWnd->SetWindowPos(&wndTop, rect.left, rect.top, rect.Width(), rect.Height(), dwFlags);
		}
	}
}

void CMDIClientAreaWnd::CalcWindowRectForMDITabbedGroups(LPRECT lpClientRect, UINT /*nAdjustType*/)
{
	SetWindowPos(&wndBottom, lpClientRect->left, lpClientRect->top, lpClientRect->right - lpClientRect->left, lpClientRect->bottom - lpClientRect->top, SWP_NOACTIVATE);

	if (m_lstTabbedGroups.IsEmpty())
	{
		return;
	}
	// special processing for single tab

	if (m_lstTabbedGroups.GetCount() == 1)
	{
		CMFCTabCtrl* pNextTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetHead());
		ASSERT_VALID(pNextTab);
		pNextTab->ShowWindow(SW_SHOWNA);
		pNextTab->SetWindowPos(NULL, 0, 0, lpClientRect->right - lpClientRect->left, lpClientRect->bottom - lpClientRect->top, SWP_NOZORDER | SWP_NOACTIVATE);

		AdjustMDIChildren(pNextTab);
		return;
	}

	ASSERT(m_groupAlignment != GROUP_NO_ALIGN);

	int nTotalSize = 0;
	POSITION pos = NULL;

	for (pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTabCtrl* pNextTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
		ASSERT_VALID(pNextTab);

		CRect rect;
		pNextTab->GetWindowRect(rect);

		nTotalSize += (m_groupAlignment == GROUP_VERT_ALIGN) ? rect.Width() : rect.Height();
	}

	int nClientAreaWndSize = (m_groupAlignment == GROUP_VERT_ALIGN) ? lpClientRect->right - lpClientRect->left : lpClientRect->bottom - lpClientRect->top;

	int nDelta = (nClientAreaWndSize - nTotalSize) /(int) m_lstTabbedGroups.GetCount();
	int nRest  = (nClientAreaWndSize - nTotalSize) %(int) m_lstTabbedGroups.GetCount();

	m_nTotalResizeRest += nRest;
	if (abs(m_nTotalResizeRest) >= m_lstTabbedGroups.GetCount())
	{
		m_nTotalResizeRest > 0 ? nDelta ++ : nDelta --;
		m_nTotalResizeRest = 0;
	}

	int nOffset = 0;
	for (pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTabCtrl* pNextTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
		ASSERT_VALID(pNextTab);

		if (pNextTab->GetSafeHwnd() != NULL)
		{
			CRect rect;
			pNextTab->GetWindowRect(rect);
			ScreenToClient(rect);

			if (m_groupAlignment == GROUP_VERT_ALIGN)
			{
				int nFinalWidth = rect.Width() + nDelta;
				if (pos == NULL && nClientAreaWndSize - nOffset + nFinalWidth != 0)
				{
					nFinalWidth = nClientAreaWndSize - nOffset;
				}
				pNextTab->SetWindowPos(NULL, nOffset, 0, nFinalWidth, lpClientRect->bottom - lpClientRect->top, SWP_NOZORDER | SWP_NOACTIVATE);
				nOffset += rect.Width() + nDelta;
			}
			else
			{
				int nFinalHeight = rect.Height() + nDelta;
				if (pos == NULL && nClientAreaWndSize - nOffset + nFinalHeight != 0)
				{
					nFinalHeight = nClientAreaWndSize - nOffset;
				}
				pNextTab->SetWindowPos(NULL, 0, nOffset, lpClientRect->right - lpClientRect->left, nFinalHeight, SWP_NOZORDER | SWP_NOACTIVATE);
				nOffset += rect.Height() + nDelta;
			}

			AdjustMDIChildren(pNextTab);
		}
	}
}

void CMDIClientAreaWnd::AdjustMDIChildren(CMFCTabCtrl* pTabWnd)
{
	if (!pTabWnd->IsWindowVisible() && CMDIFrameWndEx::m_bDisableSetRedraw)
	{
		return;
	}

	CRect rectTabWnd;
	pTabWnd->GetWndArea(rectTabWnd);
	pTabWnd->MapWindowPoints(this, rectTabWnd);

	int nActiveTab = pTabWnd->GetActiveTab();

	for (int i = 0; i < pTabWnd->GetTabsNum(); i++)
	{
		CWnd* pWnd = pTabWnd->GetTabWnd(i);
		if (pWnd->GetSafeHwnd() == 0)
		{
			continue;
		}

		DWORD dwStyle = ::GetWindowLong(pWnd->GetSafeHwnd(), GWL_STYLE);
		if ((dwStyle & WS_MINIMIZE) != 0)
		{
			pWnd->ShowWindow(SW_RESTORE);
		}

		DWORD dwFlags = SWP_NOACTIVATE;
		if (i != nActiveTab)
		{
			dwFlags |= SWP_NOZORDER | SWP_NOREDRAW;
		}

		if (pWnd != NULL)
		{
			pWnd->SetWindowPos(&wndTop, rectTabWnd.left, rectTabWnd.top, rectTabWnd.Width(), rectTabWnd.Height(), dwFlags);

			CMDIChildWndEx* pChildWnd = DYNAMIC_DOWNCAST(CMDIChildWndEx, pWnd);
			if (pChildWnd != NULL && pChildWnd->IsTaskbarTabsSupportEnabled() && pChildWnd->IsRegisteredWithTaskbarTabs())
			{
				CWinApp* pApp = AfxGetApp();
				if (pApp != NULL)
				{
					CDataRecoveryHandler *pHandler = pApp->GetDataRecoveryHandler();
					if ((pHandler == NULL) || (!pHandler->GetShutdownByRestartManager()))
					{
						pChildWnd->InvalidateIconicBitmaps();
						pChildWnd->SetTaskbarTabOrder(NULL);
					}
				}
			}
		}
	}
}

void CMDIClientAreaWnd::SetTaskbarTabOrder()
{
	for (POSITION pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTabCtrl* pNextTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
		ASSERT_VALID(pNextTab);
		
		for (int i = 0; i < pNextTab->GetTabsNum(); i++)
		{
			CMDIChildWndEx* pChildWnd = DYNAMIC_DOWNCAST(CMDIChildWndEx, pNextTab->GetTabWnd(i));
			ASSERT_VALID(pChildWnd);

			if (pChildWnd->GetSafeHwnd() == NULL)
			{
				continue;
			}
			if (pChildWnd->IsTaskbarTabsSupportEnabled() && pChildWnd->IsRegisteredWithTaskbarTabs())
			{
				pChildWnd->SetTaskbarTabOrder(NULL);
			}
		}
	}
}

LRESULT CMDIClientAreaWnd::OnActiveTabChanged(WPARAM wp, LPARAM lp)
{
	CWinApp* pApp = AfxGetApp();
	if(pApp == NULL)
	{
		return 0;
	}

	ASSERT_VALID(pApp);
	if (!afxGlobalData.bIsWindows7 || !m_bIsMDITabbedGroup || !pApp->IsTaskbarInteractionEnabled())
	{
		return 0;
	}

	CMFCTabCtrl* pTabWnd = (CMFCTabCtrl*)lp;
	if (pTabWnd == NULL)
	{
		return 0;
	}

	ASSERT_VALID(pTabWnd);
	int iTab = (int) wp;
	CMDIChildWndEx* pActiveMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, pTabWnd->GetTabWnd(iTab));
	if (pActiveMDIChild == NULL)
	{
		return 0;
	}

	ASSERT_VALID(pActiveMDIChild);
	if (!pActiveMDIChild->IsRegisteredWithTaskbarTabs())
	{
		return 0;
	}

	CMDIChildWndEx* pNextMDIChild = FindNextRegisteredWithTaskbarMDIChild(pActiveMDIChild);
	// if pNextMDIChild is NULL we insert at the end, because GetSafeHwnd() will return NULL
	pActiveMDIChild->SetTaskbarTabOrder(pNextMDIChild);

	return 1;
}

CMDIChildWndEx* CMDIClientAreaWnd::FindNextRegisteredWithTaskbarMDIChild(CMDIChildWndEx* pOrgWnd)
{
	ASSERT_VALID(pOrgWnd);

	int iIndex = -1;
	CMFCTabCtrl* pTabCtrl = FindTabWndByChild(pOrgWnd->GetSafeHwnd(), iIndex);

	if (pTabCtrl == NULL)
		return NULL;

	ASSERT_VALID(pTabCtrl);

	// find next registered child within this tabbed group
	CMDIChildWndEx* pNextMDIChild = FindNextRegisteredWithTaskbarMDIChild(pTabCtrl, iIndex + 1);
	if (pNextMDIChild == NULL)
	{
		// maybe in next tabbed group
		while ((pTabCtrl = GetNextTabWnd(pTabCtrl, TRUE)) != NULL && pNextMDIChild == NULL)
		{
			ASSERT_VALID(pTabCtrl);
			pNextMDIChild = FindNextRegisteredWithTaskbarMDIChild(pTabCtrl, 0);
		}
	}

	return pNextMDIChild;
}

CMDIChildWndEx* CMDIClientAreaWnd::FindNextRegisteredWithTaskbarMDIChild(CMFCTabCtrl* pTabCtrl, int iStartFrom)
{
	ASSERT_VALID(pTabCtrl);

	if (pTabCtrl == NULL)
	{
		return NULL;
	}

	if (iStartFrom < 0)
		iStartFrom = 0;

	for (int i = iStartFrom; i < pTabCtrl->GetTabsNum(); i++)
	{
		CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, pTabCtrl->GetTabWnd(i));
		if (pMDIChild == NULL || pMDIChild->GetSafeHwnd() == NULL)
		{
			continue;
		}

		ASSERT_VALID(pMDIChild);
		if (pMDIChild->IsRegisteredWithTaskbarTabs())
		{
			return pMDIChild;
		}
	}

	return NULL;
}

void CMDIClientAreaWnd::SetActiveTab(HWND hwnd)
{
	if (m_bDisableUpdateTabs)
	{
		return;
	}
	if (m_bIsMDITabbedGroup)
	{
		CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, CWnd::FromHandle(hwnd));
		if (pMDIChild != NULL)
		{
			ASSERT_VALID(pMDIChild);
			CMFCTabCtrl* pTabWnd = pMDIChild->GetRelatedTabGroup();
			if (pTabWnd != NULL)
			{
				ASSERT_VALID(pTabWnd);

				int iTab = pTabWnd->GetTabFromHwnd(hwnd);
				if (iTab >= 0)
				{

					CRect rectTabWnd;
					pTabWnd->GetClientRect(rectTabWnd);

					if (rectTabWnd.IsRectEmpty())
					{
						CFrameWnd* pMainFrame = pMDIChild->GetTopLevelFrame();

						if (pMainFrame != NULL)
						{
							ASSERT_VALID(pMainFrame);
							pMainFrame->RecalcLayout();
						}
					}

					CMFCTabCtrl* pPrevActiveWnd = FindActiveTabWnd();
					if (pPrevActiveWnd != NULL)
					{
						pPrevActiveWnd->SetActiveInMDITabGroup(FALSE);
						pPrevActiveWnd->InvalidateTab(pPrevActiveWnd->GetActiveTab());
					}

					pTabWnd->SetActiveInMDITabGroup(TRUE);
					pTabWnd->SetActiveTab(iTab);
					pTabWnd->InvalidateTab(pTabWnd->GetActiveTab());
				}
			}
		}
	}
	else
	{
		if (m_bTabIsVisible)
		{
			int iTab = m_wndTab.GetTabFromHwnd(hwnd);
			if (iTab >= 0)
			{
				m_wndTab.SetActiveTab(iTab);
			}
		}
	}
}

LRESULT CMDIClientAreaWnd::OnUpdateTabs(WPARAM, LPARAM)
{
	UpdateTabs();
	return 0;
}

void CMDIClientAreaWnd::PreSubclassWindow()
{
	CWnd::PreSubclassWindow();
	CreateTabGroup(&m_wndTab);
}

CMFCTabCtrl* CMDIClientAreaWnd::CreateTabGroup(CMFCTabCtrl* pWndTab)
{
	if (pWndTab == NULL)
	{
		pWndTab = new CMFCTabCtrl;
	}

	if (m_mdiTabParams.m_bTabCustomTooltips)
	{
		pWndTab->EnableCustomToolTips();
	}

	CWnd* pParent = m_bIsMDITabbedGroup ? this :(CWnd*) GetParentFrame();

	// Create MDI tabs control:
	if (!pWndTab->Create(m_mdiTabParams.m_style, CRect(0, 0, 0, 0), pParent, (UINT)-1, m_mdiTabParams.m_tabLocation, m_mdiTabParams.m_bTabCloseButton))
	{
		TRACE(_T("CMDIClientAreaWnd::OnCreate: can't create tabs window\n"));
		delete pWndTab;
		return NULL;
	}

	ApplyParams(pWndTab);

	if (!m_bTabIsVisible)
	{
		pWndTab->ShowWindow(SW_HIDE);
	}

	// Create tab icons:

	if (!m_bIsMDITabbedGroup)
	{
		m_TabIcons.Create(afxGlobalData.m_sizeSmallIcon.cx, afxGlobalData.m_sizeSmallIcon.cy, ILC_COLOR32 | ILC_MASK, 0, 1);
	}
	else
	{
		CImageList* pImageList = NULL;
		if (m_mapTabIcons.Lookup(pWndTab, pImageList) && pImageList != NULL)
		{
			pImageList->DeleteImageList();
		}
		else
		{
			pImageList = new CImageList;
			m_mapTabIcons.SetAt(pWndTab, pImageList);
		}

		pImageList->Create(afxGlobalData.m_sizeSmallIcon.cx, afxGlobalData.m_sizeSmallIcon.cy, ILC_COLOR32 | ILC_MASK, 0, 1);
	}

	return pWndTab;
}

void CMDIClientAreaWnd::UpdateTabs(BOOL bSetActiveTabVisible/* = FALSE*/)
{
	if (m_bDisableUpdateTabs)
	{
		return;
	}

	if (m_bIsMDITabbedGroup)
	{
		UpdateMDITabbedGroups(bSetActiveTabVisible);
		return;
	}

	if (m_wndTab.GetSafeHwnd() == NULL || !m_bTabIsVisible)
	{
		return;
	}

	BOOL bRecalcLayout = FALSE;
	BOOL bTabWndEmpty = m_wndTab.GetTabsNum() == 0;

	CWnd* pWndChild = GetWindow(GW_CHILD);
	while (pWndChild != NULL)
	{
		ASSERT_VALID(pWndChild);

		CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, pWndChild);

		BOOL bIsShowTab = TRUE;
		if (pMDIChild != NULL)
		{
			bIsShowTab = pMDIChild->CanShowOnMDITabs();
		}
		else if (pWndChild->IsKindOf(RUNTIME_CLASS(CMFCTabCtrl)))
		{
			pWndChild = pWndChild->GetNextWindow();
			continue;
		}

		// Get tab icon:
		int iIcon = -1;
		if (m_mdiTabParams.m_bTabIcons)
		{
			HICON hIcon = NULL;
			if (pMDIChild != NULL)
			{
				hIcon = pMDIChild->GetFrameIcon();
			}
			else
			{
				if ((hIcon = pWndChild->GetIcon(FALSE)) == NULL)
				{
					hIcon = (HICON)(LONG_PTR) GetClassLongPtr(*pWndChild, GCLP_HICONSM);
				}
			}

			if (hIcon != NULL)
			{
				if (!m_mapIcons.Lookup(hIcon, iIcon))
				{
					iIcon = m_TabIcons.Add(hIcon);
					m_mapIcons.SetAt(hIcon, iIcon);

					if (m_TabIcons.GetImageCount() == 1)
					{
						m_wndTab.SetImageList(m_TabIcons.GetSafeHandle());
					}
				}

				pMDIChild->UpdateTaskbarTabIcon(hIcon);
			}
		}
		else
		{
			m_wndTab.ClearImageList();
			m_mapIcons.RemoveAll();

			while (m_TabIcons.GetImageCount() > 0)
			{
				m_TabIcons.Remove(0);
			}

			// set tab icons for taskbar tabs
			if (pMDIChild != NULL && pMDIChild->IsTaskbarTabsSupportEnabled() && pMDIChild->IsRegisteredWithTaskbarTabs())
			{
				HICON hIcon = pMDIChild->GetFrameIcon();
				if (hIcon == NULL)
				{
					CWnd* pTopLevel = GetTopLevelFrame();

					if (pTopLevel != NULL)
					{
						hIcon = afxGlobalUtils.GetWndIcon(pTopLevel);
					}
				}

				if (hIcon != NULL)
				{
					pMDIChild->UpdateTaskbarTabIcon(hIcon);
				}
			}
		}

		// Get tab label(window caption):
		CString strTabLabel;
		if (pMDIChild != NULL)
		{
			strTabLabel = pMDIChild->GetFrameText();
		}
		else
		{
			pWndChild->GetWindowText(strTabLabel);
		}

		int iTabIndex = m_wndTab.GetTabFromHwnd(pWndChild->GetSafeHwnd());
		if (iTabIndex >= 0)
		{
			// Tab is already exist, update it:
			if (pWndChild->GetStyle() & WS_VISIBLE)
			{
				CString strCurTabLabel;
				m_wndTab.GetTabLabel(iTabIndex, strCurTabLabel);

				if (strCurTabLabel != strTabLabel)
				{
					// Text was changed, update it:
					m_wndTab.SetTabLabel(iTabIndex, strTabLabel);
					bRecalcLayout = TRUE;
				}

				if (m_wndTab.GetTabIcon(iTabIndex) != (UINT) iIcon)
				{
					// Icon was changed, update it:
					m_wndTab.SetTabIcon(iTabIndex, iIcon);
					bRecalcLayout = TRUE;
				}
			}
			else
			{
				// Window is hidden now, remove tab:
				m_wndTab.RemoveTab(iTabIndex);
				bRecalcLayout = TRUE;
			}
		}
		else if ((pMDIChild == NULL || !pMDIChild->m_bToBeDestroyed) && bIsShowTab)
		{
			// New item, add it now:
			m_wndTab.AddTab(pWndChild, strTabLabel, iIcon);
			m_wndTab.SetActiveTab(m_wndTab.GetTabsNum() - 1);

			bRecalcLayout = TRUE;
		}

		pWndChild = pWndChild->GetNextWindow();
	}

	if (bRecalcLayout && GetParentFrame() != NULL)
	{
		GetParentFrame()->RecalcLayout();
	}

	if (bSetActiveTabVisible)
	{
		m_wndTab.EnsureVisible(m_wndTab.GetActiveTab());
	}

	if (bTabWndEmpty && m_wndTab.GetTabsNum() > 0 || m_wndTab.GetTabsNum() == 0)
	{
		GetParentFrame()->RecalcLayout();
		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT);
	}
}

void CMDIClientAreaWnd::UpdateMDITabbedGroups(BOOL bSetActiveTabVisible)
{
	if (m_bDisableUpdateTabs)
	{
		return;
	}

	BOOL bRecalcLayout = FALSE;
	CWnd* pWndChild = GetWindow(GW_CHILD);
	HWND hwndActive = NULL;

	while (pWndChild != NULL)
	{
		ASSERT_VALID(pWndChild);

		CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, pWndChild);

		if (pMDIChild == NULL)
		{
			pWndChild = pWndChild->GetNextWindow();
			continue;
		}

		// always modify style
		pMDIChild->ModifyStyle(CMDIChildWndEx::m_dwExcludeStyle | WS_MAXIMIZE | WS_SYSMENU, 0, SWP_NOZORDER);

		BOOL bIsShowTab = pMDIChild->CanShowOnMDITabs();
		CString strTabLabel = pMDIChild->GetFrameText();

		CMFCTabCtrl* pRelatedTabWnd = pMDIChild->GetRelatedTabGroup();

		BOOL bRemoved = FALSE;
		if (pRelatedTabWnd == NULL && !pMDIChild->m_bToBeDestroyed && bIsShowTab)
		{
			if (m_lstTabbedGroups.IsEmpty())
			{
				pRelatedTabWnd = CreateTabGroup(NULL);
				m_lstTabbedGroups.AddTail(pRelatedTabWnd);
			}
			else
			{
				// new window to be added
				pRelatedTabWnd = FindActiveTabWnd();

				if (pRelatedTabWnd == NULL)
				{
					pRelatedTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetHead());
				}
			}

			ENSURE(pRelatedTabWnd != NULL);
			ASSERT_VALID(pRelatedTabWnd);

			pMDIChild->SetRelatedTabGroup(pRelatedTabWnd);
			pRelatedTabWnd->AddTab(pWndChild, strTabLabel);

			if (!pRelatedTabWnd->IsWindowVisible())
			{
				pRelatedTabWnd->ShowWindow(SW_SHOWNA);
			}

			hwndActive = pWndChild->GetSafeHwnd();

		}
		else if (pRelatedTabWnd != NULL)
		{
			int iTabIndex = pRelatedTabWnd->GetTabFromHwnd(pWndChild->GetSafeHwnd());
			if (iTabIndex >= 0)
			{
				// Tab is already exist, update it:
				if (pWndChild->GetStyle() & WS_VISIBLE)
				{
					CString strCurTabLabel;
					pRelatedTabWnd->GetTabLabel(iTabIndex, strCurTabLabel);

					if (strCurTabLabel != strTabLabel)
					{
						// Text was changed, update it:
						pRelatedTabWnd->SetTabLabel(iTabIndex, strTabLabel);
						bRecalcLayout = TRUE;
					}
				}
				else
				{
					// Window is hidden now, remove tab:
					pRelatedTabWnd->RemoveTab(iTabIndex);
					if (pRelatedTabWnd->GetTabsNum() == 0)
					{
						RemoveTabGroup(pRelatedTabWnd, FALSE);
					}
					bRecalcLayout = TRUE;
					bRemoved = TRUE;
				}
			}
		}

		CImageList* pImageList = NULL;
		m_mapTabIcons.Lookup(pRelatedTabWnd, pImageList);

		if (pImageList != NULL)
		{
			ASSERT_VALID(pImageList);

			int iIcon = -1;
			if (m_mdiTabParams.m_bTabIcons)
			{
				HICON hIcon = NULL;
				if (pMDIChild != NULL)
				{
					hIcon = pMDIChild->GetFrameIcon();
				}

				if (hIcon != NULL)
				{
					if (!pRelatedTabWnd->IsIconAdded(hIcon, iIcon))
					{
						iIcon = pImageList->Add(hIcon);
						pRelatedTabWnd->AddIcon(hIcon, iIcon);
					}

					if (pRelatedTabWnd->GetImageList() != pImageList)
					{
						pRelatedTabWnd->SetImageList(pImageList->GetSafeHandle());
					}
				}

				if (!bRemoved)
				{
					int iTabIndex = pRelatedTabWnd->GetTabFromHwnd(pMDIChild->GetSafeHwnd());
					if (pRelatedTabWnd->GetTabIcon(iTabIndex) != (UINT) iIcon)
					{
						// Icon was changed, update it:
						pRelatedTabWnd->SetTabIcon(iTabIndex, iIcon);
					}

					if (pMDIChild->IsTaskbarTabsSupportEnabled() && pMDIChild->IsRegisteredWithTaskbarTabs())
					{
						pMDIChild->UpdateTaskbarTabIcon(hIcon);
					}
				}
			}
			else
			{
				ENSURE(pRelatedTabWnd != NULL);

				pRelatedTabWnd->ResetImageList();
				m_mapIcons.RemoveAll();

				while (pImageList->GetImageCount() > 0)
				{
					pImageList->Remove(0);
				}

				// set tab icons for taskbar tabs
				if (pMDIChild != NULL && pMDIChild->IsTaskbarTabsSupportEnabled() && pMDIChild->IsRegisteredWithTaskbarTabs())
				{
					HICON hIcon = pMDIChild->GetFrameIcon();
					if (hIcon == NULL)
					{
						CWnd* pTopLevel = GetTopLevelFrame();

						if (pTopLevel != NULL)
						{
							hIcon = afxGlobalUtils.GetWndIcon(pTopLevel);
						}
					}

					if (hIcon != NULL)
					{
						pMDIChild->UpdateTaskbarTabIcon(hIcon);
					}
				}

				bRecalcLayout = TRUE;
			}
		}

		pWndChild = pWndChild->GetNextWindow();
	}

	for (POSITION pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTabCtrl* pNextTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
		ASSERT_VALID(pNextTab);
		AdjustMDIChildren(pNextTab);
	}

	if (bRecalcLayout && GetParentFrame() != NULL)
	{
		GetParentFrame()->RecalcLayout();
	}

	if (hwndActive != NULL)
	{
		SetActiveTab(hwndActive);
	}

	if (bSetActiveTabVisible)
	{
		CMFCTabCtrl* pActiveWnd = FindActiveTabWnd();
		if (pActiveWnd != NULL)
		{
			ASSERT_VALID(pActiveWnd);
			pActiveWnd->EnsureVisible(pActiveWnd->GetActiveTab());
		}
	}
}

void CMDIClientAreaWnd::OnStyleChanging(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
	if (nStyleType == GWL_EXSTYLE && !IsKeepClientEdge())
	{
		lpStyleStruct->styleNew = lpStyleStruct->styleOld & ~WS_EX_CLIENTEDGE;
	}

	CWnd::OnStyleChanging(nStyleType, lpStyleStruct);
}

BOOL CMDIClientAreaWnd::IsKeepClientEdge()
{
	BOOL bKeepEdge = FALSE;
	HWND hwndActive = (HWND) SendMessage(WM_MDIGETACTIVE, 0, 0);
	if (hwndActive != NULL)
	{
		CWnd* pWnd = CWnd::FromHandle(hwndActive);
		if (pWnd != NULL && ::IsWindow(pWnd->GetSafeHwnd()))
		{
			bKeepEdge = (pWnd->GetStyle() & WS_SYSMENU) != 0;
		}
	}

	return !m_bIsMDITabbedGroup && bKeepEdge;
}

LRESULT CMDIClientAreaWnd::OnGetDragBounds(WPARAM wp, LPARAM lp)
{
	if (!m_bIsMDITabbedGroup || m_lstTabbedGroups.IsEmpty())
	{
		return 0;
	}

	CMFCTabCtrl* pTabWndToResize = (CMFCTabCtrl*)(wp);
	LPRECT lpRectBounds = (LPRECT)(lp);

	if (pTabWndToResize == NULL)
	{
		return 0;
	}

	ASSERT_VALID(pTabWndToResize);
	CMFCTabCtrl* pNextTabWnd = GetNextTabWnd(pTabWndToResize);

	if (pNextTabWnd == NULL)
	{
		return 0;
	}

	ASSERT(m_groupAlignment != GROUP_NO_ALIGN);

	CRect rectTabWndToResize;
	CRect rectNextTabWnd;

	pTabWndToResize->GetWindowRect(rectTabWndToResize);
	pNextTabWnd->GetWindowRect(rectNextTabWnd);

	rectTabWndToResize.UnionRect(rectTabWndToResize, rectNextTabWnd);

	if (m_groupAlignment == GROUP_VERT_ALIGN)
	{
		rectTabWndToResize.left += m_nResizeMargin;
		rectTabWndToResize.right -= m_nResizeMargin;
	}
	else
	{
		rectTabWndToResize.top += m_nResizeMargin;
		rectTabWndToResize.bottom -= m_nResizeMargin;
	}

	CopyRect(lpRectBounds, &rectTabWndToResize);
	return TRUE;
}

LRESULT CMDIClientAreaWnd::OnDragComplete(WPARAM wp, LPARAM lp)
{
	if (!m_bIsMDITabbedGroup || m_lstTabbedGroups.IsEmpty())
	{
		return 0;
	}

	CMFCTabCtrl* pTabWndToResize = (CMFCTabCtrl*)(wp);
	LPRECT lpRectResized = (LPRECT)(lp);

	ASSERT_VALID(pTabWndToResize);
	CMFCTabCtrl* pNextTabWnd = GetNextTabWnd(pTabWndToResize);

	if (pNextTabWnd == NULL)
	{
		return 0;
	}

	ASSERT(m_groupAlignment != GROUP_NO_ALIGN);

	ScreenToClient(lpRectResized);
	pTabWndToResize->SetWindowPos(NULL, -1, -1, lpRectResized->right - lpRectResized->left, lpRectResized->bottom - lpRectResized->top, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);

	CRect rectNextWnd;
	pNextTabWnd->GetWindowRect(rectNextWnd);
	ScreenToClient(rectNextWnd);

	m_groupAlignment == GROUP_VERT_ALIGN ?  rectNextWnd.left = lpRectResized->right : rectNextWnd.top = lpRectResized->bottom;

	pNextTabWnd->SetWindowPos(NULL, rectNextWnd.left, rectNextWnd.top, rectNextWnd.Width(), rectNextWnd.Height(), SWP_NOZORDER | SWP_NOACTIVATE);

	AdjustMDIChildren(pTabWndToResize);
	AdjustMDIChildren(pNextTabWnd);

	return TRUE;
}

LRESULT CMDIClientAreaWnd::OnTabGroupMouseMove(WPARAM /*wp*/, LPARAM lp)
{
	CMFCTabCtrl* pTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, GetCapture());
	if (pTabWnd == NULL)
	{
		return 0;
	}

	if (m_lstTabbedGroups.GetCount() == 1 && pTabWnd->GetTabsNum() == 1)
	{
		return 0;
	}

	POINTS pt = MAKEPOINTS(lp);
	CPoint point(pt.x, pt.y);

	if (pTabWnd->IsPtInTabArea(point))
	{
		::SetCursor(AfxGetApp()->LoadStandardCursor(IDC_ARROW));
		DrawNewGroupRect(NULL, m_rectNewTabGroup);
		m_rectNewTabGroup.SetRectEmpty();
		return 0;
	}

	CPoint pointScreen = point;
	pTabWnd->ClientToScreen(&pointScreen);

	CRect rectWnd;
	GetClientRect(rectWnd);

	ClientToScreen(rectWnd);

	if (afxGlobalData.m_hcurMoveTab == NULL)
	{
		afxGlobalData.m_hcurMoveTab = AfxGetApp()->LoadCursor(IDC_AFXBARRES_MOVE_TAB);
		afxGlobalData.m_hcurNoMoveTab = AfxGetApp()->LoadCursor(IDC_AFXBARRES_NO_MOVE_TAB);
	}

	if (!rectWnd.PtInRect(pointScreen))
	{
		::SetCursor(afxGlobalData.m_hcurNoMoveTab);

		DrawNewGroupRect(NULL, m_rectNewTabGroup);
		m_rectNewTabGroup.SetRectEmpty();
		return TRUE;
	}

	::SetCursor(afxGlobalData.m_hcurMoveTab);

	CMFCTabCtrl* pHoveredTabWnd = TabWndFromPoint(pointScreen);

	if (pHoveredTabWnd == NULL)
	{
		DrawNewGroupRect(NULL, m_rectNewTabGroup);
		m_rectNewTabGroup.SetRectEmpty();
		return 0;
	}

	CRect rectScreenHoveredWnd;
	pHoveredTabWnd->GetWindowRect(rectScreenHoveredWnd);

	CRect rectMargin = rectScreenHoveredWnd;

	BOOL bCalcVertRect = TRUE;

	if (m_groupAlignment == GROUP_NO_ALIGN)
	{
		bCalcVertRect = rectScreenHoveredWnd.right - pointScreen.x < rectScreenHoveredWnd.bottom - pointScreen.y;
	}
	else
	{
		bCalcVertRect = m_groupAlignment == GROUP_VERT_ALIGN;
	}

	if (m_groupAlignment == GROUP_VERT_ALIGN || bCalcVertRect)
	{
		rectMargin.left = rectScreenHoveredWnd.right - m_nNewGroupMargin;
		bCalcVertRect = TRUE;
	}
	else if (m_groupAlignment == GROUP_HORZ_ALIGN || !bCalcVertRect)
	{
		rectMargin.top  = rectScreenHoveredWnd.bottom - m_nNewGroupMargin;
		bCalcVertRect = FALSE;
	}

	CRect rectNew = rectScreenHoveredWnd;

	bCalcVertRect ? rectNew.left = rectScreenHoveredWnd.right - rectScreenHoveredWnd.Width() / 2: rectNew.top = rectScreenHoveredWnd.bottom - rectScreenHoveredWnd.Height() / 2;

	if (!rectMargin.PtInRect(pointScreen))
	{
		if (pHoveredTabWnd == pTabWnd)
		{
			rectNew.SetRectEmpty();
		}
		else
		{
			CPoint pointClient = pointScreen;
			pHoveredTabWnd->ScreenToClient(&pointClient);
			if (pHoveredTabWnd->IsPtInTabArea(pointClient))
			{
				pHoveredTabWnd->GetWndArea(rectNew);
				pHoveredTabWnd->ClientToScreen(rectNew);
			}
			else
			{
				rectNew.SetRectEmpty();
			}
		}
	}
	else if (pHoveredTabWnd == pTabWnd && pTabWnd->GetTabsNum() == 1)
	{
		rectNew.SetRectEmpty();
	}

	DrawNewGroupRect(rectNew, m_rectNewTabGroup);
	m_rectNewTabGroup = rectNew;
	m_bNewVericalGroup = bCalcVertRect;

	return TRUE;
}

LRESULT CMDIClientAreaWnd::OnMoveTabComplete(WPARAM wp, LPARAM lp)
{
	CMFCTabCtrl* pTabWnd = (CMFCTabCtrl*) wp;

	CRect rectNewTabGroup = m_rectNewTabGroup;
	DrawNewGroupRect(NULL, m_rectNewTabGroup);
	m_rectNewTabGroup.SetRectEmpty();

	if (pTabWnd == NULL)
	{
		return 0;
	}

	ASSERT_VALID(pTabWnd);

	POINTS pt = MAKEPOINTS(lp);
	CPoint point(pt.x, pt.y);

	CPoint pointScreen = point;
	pTabWnd->ClientToScreen(&pointScreen);

	CMFCTabCtrl* pHoveredTabWnd = TabWndFromPoint(pointScreen);

	if (pHoveredTabWnd == NULL)
	{
		return 0;
	}

	ASSERT_VALID(pHoveredTabWnd);

	BOOL bMenuResult = TRUE;
	if (rectNewTabGroup.IsRectEmpty())
	{
		CMDIFrameWndEx* pMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParent());
		ASSERT_VALID(pMDIFrame);

		CPoint pointCur;
		GetCursorPos(&pointCur);

		DWORD dwAllowedItems = GetMDITabsContextMenuAllowedItems();

		if (dwAllowedItems != 0)
		{
			bMenuResult = pMDIFrame->OnShowMDITabContextMenu(pointCur, dwAllowedItems, TRUE);
		}
	}

	CRect rectHoveredWnd;
	pHoveredTabWnd->GetWndArea(rectHoveredWnd);
	pHoveredTabWnd->ClientToScreen(rectHoveredWnd);

	if (!bMenuResult)
	{
		if (pTabWnd != pHoveredTabWnd)
		{
			MoveWindowToTabGroup(pTabWnd, pHoveredTabWnd);
		}
		else if (pTabWnd->GetTabsNum() > 1)
		{
			BOOL bVertGroup = FALSE;
			if (m_groupAlignment == GROUP_HORZ_ALIGN)
			{
				rectHoveredWnd.top = rectHoveredWnd.bottom - rectHoveredWnd.Height() / 2;
			}
			else
			{
				rectHoveredWnd.left = rectHoveredWnd.right - rectHoveredWnd.Width() / 2;
				bVertGroup = TRUE;
			}

			CMFCTabCtrl* pNewTabWnd = CreateNewTabGroup(pHoveredTabWnd, rectHoveredWnd, bVertGroup);
			MoveWindowToTabGroup(pTabWnd, pNewTabWnd);
		}
	}
	else if (!rectNewTabGroup.IsRectEmpty())
	{
		if (rectNewTabGroup == rectHoveredWnd)
		{
			MoveWindowToTabGroup(pTabWnd, pHoveredTabWnd);
		}
		else
		{
			CMFCTabCtrl* pNewTabWnd = CreateNewTabGroup(pHoveredTabWnd, rectNewTabGroup, m_bNewVericalGroup);
			MoveWindowToTabGroup(pTabWnd, pNewTabWnd);
		}
	}

	return 0;
}

BOOL CMDIClientAreaWnd::MoveWindowToTabGroup(CMFCTabCtrl* pTabWndFrom, CMFCTabCtrl* pTabWndTo, int nIdxFrom)
{
	ASSERT_VALID(pTabWndFrom);
	ASSERT_VALID(pTabWndTo);

	HWND hwndFrom = pTabWndFrom->GetSafeHwnd();
	HWND hwndTo	  = pTabWndTo->GetSafeHwnd();

	int nIdx = nIdxFrom;
	if (nIdx == -1)
	{
		nIdx = pTabWndFrom->GetActiveTab();
	}

	if (nIdx == -1)
	{
		return FALSE;
	}

	CMDIChildWndEx* pWnd = DYNAMIC_DOWNCAST(CMDIChildWndEx, pTabWndFrom->GetTabWnd(nIdx));

	if (pWnd == NULL)
	{
		return FALSE;
	}

	ASSERT_VALID(pWnd);

	CString strTabLabel = pWnd->GetFrameText();

	pTabWndFrom->RemoveTab(nIdx, TRUE);
	pWnd->SetRelatedTabGroup(pTabWndTo);
	pTabWndTo->AddTab(pWnd, strTabLabel);

	if (pTabWndFrom->GetTabsNum() == 0)
	{
		RemoveTabGroup(pTabWndFrom);
		UpdateMDITabbedGroups(TRUE);
		pTabWndTo->RecalcLayout();
	}
	else
	{
		AdjustMDIChildren(pTabWndFrom);
	}

	AdjustMDIChildren(pTabWndTo);
	SetActiveTab(pWnd->GetSafeHwnd());

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParentFrame());
	ASSERT_VALID(pMainFrame);

	if (pMainFrame != NULL)
	{
		pMainFrame->SendMessage(AFX_WM_ON_MOVETOTABGROUP, (WPARAM) hwndFrom, (LPARAM) hwndTo);
	}

	return TRUE;
}

CMFCTabCtrl* CMDIClientAreaWnd::CreateNewTabGroup(CMFCTabCtrl* pTabWndAfter, CRect rectGroup, BOOL bVertical)
{
	ASSERT_VALID(pTabWndAfter);
	POSITION pos = m_lstTabbedGroups.Find(pTabWndAfter);

	if (pos == NULL)
	{
		return NULL;
	}

	CMFCTabCtrl* pNewTabWnd = CreateTabGroup(NULL);
	pTabWndAfter->SetResizeMode(bVertical ? CMFCTabCtrl::RESIZE_VERT : CMFCTabCtrl::RESIZE_HORIZ);

	m_lstTabbedGroups.InsertAfter(pos, pNewTabWnd);
	if (pNewTabWnd != m_lstTabbedGroups.GetTail())
	{
		pNewTabWnd->SetResizeMode(bVertical ? CMFCTabCtrl::RESIZE_VERT : CMFCTabCtrl::RESIZE_HORIZ);
	}

	m_groupAlignment = bVertical ? GROUP_VERT_ALIGN : GROUP_HORZ_ALIGN;

	CRect rectWndAfter;
	pTabWndAfter->GetWindowRect(rectWndAfter);

	ScreenToClient(rectGroup);
	ScreenToClient(rectWndAfter);

	if (bVertical)
	{
		rectWndAfter.right -= rectGroup.Width();
		rectGroup.top = rectWndAfter.top;
		rectGroup.bottom = rectWndAfter.bottom;
	}
	else
	{
		rectWndAfter.bottom -= rectGroup.Height();
		rectGroup.left = rectWndAfter.left;
		rectGroup.right = rectWndAfter.right;
	}

	pTabWndAfter->SetWindowPos(NULL, -1, -1, rectWndAfter.Width(), rectWndAfter.Height(), SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
	pNewTabWnd->SetWindowPos(NULL, rectGroup.left, rectGroup.top, rectGroup.Width(), rectGroup.Height(), SWP_NOZORDER |  SWP_NOACTIVATE);

	AdjustMDIChildren(pTabWndAfter);

	return pNewTabWnd;
}

void CMDIClientAreaWnd::RemoveTabGroup(CMFCTabCtrl* pTabWnd, BOOL /*bRecalcLayout*/)
{
	ASSERT_VALID(pTabWnd);
	ASSERT(pTabWnd->GetTabsNum() == 0);

	POSITION pos = m_lstTabbedGroups.Find(pTabWnd);
	if (pos == NULL)
	{
		TRACE0("Attempt to remove non-existing tab group");
		return;
	}

	CMFCTabCtrl* pSiblingTabWndToResize = NULL;
	POSITION posNextPrev = pos;
	BOOL bNext = FALSE;

	if (m_lstTabbedGroups.GetHeadPosition() == pos)
	{
		m_lstTabbedGroups.GetNext(posNextPrev);
		bNext = TRUE;
	}
	else
	{
		m_lstTabbedGroups.GetPrev(posNextPrev);
	}

	if (posNextPrev != NULL)
	{
		pSiblingTabWndToResize = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetAt(posNextPrev));
	}

	m_lstTabbedGroups.RemoveAt(pos);
	pTabWnd->ShowWindow(SW_HIDE);

	if (m_lstTabbedGroups.GetCount() > 0)
	{
		CMFCTabCtrl* pLastTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetTail());
		ASSERT_VALID(pLastTabWnd);
		pLastTabWnd->SetResizeMode(CMFCTabCtrl::RESIZE_NO);
	}

	if (m_lstTabbedGroups.GetCount() <= 1)
	{
		m_groupAlignment = GROUP_NO_ALIGN;
	}

	if (pSiblingTabWndToResize != NULL)
	{
		CRect rectTabWndToRemove;
		pTabWnd->GetWindowRect(rectTabWndToRemove);
		CRect rectSiblingWnd;
		pSiblingTabWndToResize->GetWindowRect(rectSiblingWnd);

		rectSiblingWnd.UnionRect(rectSiblingWnd, rectTabWndToRemove);
		ScreenToClient(rectSiblingWnd);
		pSiblingTabWndToResize->SetWindowPos(NULL, rectSiblingWnd.left, rectSiblingWnd.top, rectSiblingWnd.Width(), rectSiblingWnd.Height(), SWP_NOZORDER);

		AdjustMDIChildren(pSiblingTabWndToResize);
	}

	CImageList* pImageList = NULL;
	if (m_mapTabIcons.Lookup(pTabWnd, pImageList) && pImageList != NULL)
	{
		delete pImageList;
		m_mapTabIcons.RemoveKey(pTabWnd);
	}

	m_lstRemovedTabbedGroups.AddTail(pTabWnd);
	pTabWnd->ShowWindow(SW_HIDE);

	return;
}

LRESULT CMDIClientAreaWnd::OnCancelTabMove(WPARAM, LPARAM)
{
	DrawNewGroupRect(NULL, m_rectNewTabGroup);
	m_rectNewTabGroup.SetRectEmpty();
	return 0;
}

DWORD CMDIClientAreaWnd::GetMDITabsContextMenuAllowedItems()
{
	CMFCTabCtrl* pActiveTabWnd = FindActiveTabWndByActiveChild();
	if (pActiveTabWnd == NULL)
	{
		return 0;
	}

	DWORD dwAllowedItems = 0;
	int nTabCount = pActiveTabWnd->GetTabsNum();

	if (nTabCount > 1)
	{
		if (m_lstTabbedGroups.GetCount() > 1)
		{
			dwAllowedItems = (m_groupAlignment == GROUP_VERT_ALIGN) ? AFX_MDI_CREATE_VERT_GROUP : AFX_MDI_CREATE_HORZ_GROUP;
		}
		else
		{
			dwAllowedItems = AFX_MDI_CREATE_VERT_GROUP | AFX_MDI_CREATE_HORZ_GROUP;
		}
	}

	if (pActiveTabWnd != m_lstTabbedGroups.GetHead())
	{
		dwAllowedItems |= AFX_MDI_CAN_MOVE_PREV;
	}

	if (pActiveTabWnd != m_lstTabbedGroups.GetTail())
	{
		dwAllowedItems |= AFX_MDI_CAN_MOVE_NEXT;
	}

	CMDIChildWndEx* pMDIChildFrame = DYNAMIC_DOWNCAST(CMDIChildWndEx, pActiveTabWnd->GetActiveWnd());

	CMDIFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParentFrame());
	if (pMDIChildFrame != NULL && pMDIChildFrame->IsTabbedPane() && pMainFrame != NULL && !pMainFrame->IsFullScreen())
	{
		dwAllowedItems |= AFX_MDI_CAN_BE_DOCKED;
	}

	return dwAllowedItems;
}
CMFCTabCtrl* CMDIClientAreaWnd::FindTabWndByChild(HWND hWndChild, int& iIndex)
{
	if (hWndChild == NULL)
		return NULL;

	for (POSITION pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTabCtrl* pNextTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
		ASSERT_VALID(pNextTabWnd);
		iIndex = pNextTabWnd->GetTabFromHwnd(hWndChild);
		if (iIndex >= 0)
		{
			return pNextTabWnd;
		}
	}
	return NULL;
}
CMFCTabCtrl* CMDIClientAreaWnd::FindActiveTabWndByActiveChild()
{
	HWND hwndActive = (HWND) SendMessage(WM_MDIGETACTIVE, 0, 0);
	int iIndex = -1;
	return FindTabWndByChild(hwndActive, iIndex);
}

CMFCTabCtrl* CMDIClientAreaWnd::FindActiveTabWnd()
{
	for (POSITION pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTabCtrl* pNextTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
		ASSERT_VALID(pNextTabWnd);
		if (pNextTabWnd->IsActiveInMDITabGroup())
		{
			return pNextTabWnd;
		}
	}
	return NULL;
}

CMFCTabCtrl* CMDIClientAreaWnd::GetFirstTabWnd()
{
	if (m_lstTabbedGroups.IsEmpty())
	{
		return NULL;
	}
	return DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetHead());
}

BOOL CMDIClientAreaWnd::IsMemberOfMDITabGroup(CWnd* pWnd)
{
	if (!IsMDITabbedGroup())
	{
		return FALSE;
	}

	return(m_lstTabbedGroups.Find(pWnd) != NULL);
}

CMFCTabCtrl* CMDIClientAreaWnd::GetNextTabWnd(CMFCTabCtrl* pOrgTabWnd, BOOL bWithoutAsserts)
{
	POSITION pos = m_lstTabbedGroups.Find(pOrgTabWnd);

	if (pos == NULL)
	{
		if (!bWithoutAsserts)
		{
			ASSERT(FALSE);
			TRACE0("Trying to resize a member of tabbed group which is not in the list of groups.\n");
		}
		return NULL;
	}

	m_lstTabbedGroups.GetNext(pos);
	if (pos == NULL)
	{
		if (!bWithoutAsserts)
		{
			ASSERT(FALSE);
			TRACE0("Trying to resize a last member of tabbed group, which should not be resizable.\n");
		}
		return NULL;
	}

	CMFCTabCtrl* pNextTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetAt(pos));

	if (pNextTabWnd == NULL)
	{
		if (!bWithoutAsserts)
		{
			ASSERT(FALSE);
			TRACE0("Next member of tabbed group is NULL, or not a tab window.\n");
		}
		return NULL;
	}

	return pNextTabWnd;
}

CMFCTabCtrl* CMDIClientAreaWnd::TabWndFromPoint(CPoint ptScreen)
{
	for (POSITION pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
	{
		CMFCTabCtrl* pNextTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
		ASSERT_VALID(pNextTab);
		CRect rectWnd;
		pNextTab->GetWindowRect(rectWnd);
		if (rectWnd.PtInRect(ptScreen))
		{
			return pNextTab;
		}
	}
	return NULL;
}

void CMDIClientAreaWnd::DrawNewGroupRect(LPCRECT lpRectNew, LPCRECT lpRectOld)
{
	CWindowDC dc(GetDesktopWindow());
	CSize size(4, 4);
	CRect rectNew; rectNew.SetRectEmpty();
	CRect rectOld; rectOld.SetRectEmpty();
	if (lpRectNew != NULL)
	{
		rectNew = lpRectNew;
	}
	if (lpRectOld != NULL)
	{
		rectOld = lpRectOld;
	}
	dc.DrawDragRect(rectNew, size, rectOld, size);
}

void CMDIClientAreaWnd::MDITabMoveToNextGroup(BOOL bNext)
{
	CMFCTabCtrl* pActiveWnd = FindActiveTabWndByActiveChild();
	if (pActiveWnd == NULL)
	{
		return;
	}
	ASSERT_VALID(pActiveWnd);

	POSITION pos = m_lstTabbedGroups.Find(pActiveWnd);
	bNext ? m_lstTabbedGroups.GetNext(pos) : m_lstTabbedGroups.GetPrev(pos);

	if (pos == NULL)
	{
		return;
	}

	CMFCTabCtrl* pNextTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetAt(pos));
	ASSERT_VALID(pNextTabWnd);

	MoveWindowToTabGroup(pActiveWnd, pNextTabWnd);
}

void CMDIClientAreaWnd::MDITabNewGroup(BOOL bVert)
{
	// if m_groupAlignment has already been set (e.g. it's not GROUP_NO_ALIGN) the bVert parameter should be ignored and
	// the new group should be created according to the existing alignment (because we do not support nested tabbed groups)
	if (m_groupAlignment == GROUP_VERT_ALIGN)
	{
		bVert = TRUE;
	}
	else if (m_groupAlignment == GROUP_HORZ_ALIGN)
	{
		bVert = FALSE;
	}

	CMFCTabCtrl* pActiveWnd = FindActiveTabWndByActiveChild();
	if (pActiveWnd == NULL)
	{
		return;
	}
	ASSERT_VALID(pActiveWnd);

	CRect rect;
	pActiveWnd->GetWindowRect(rect);

	if (bVert)
	{
		rect.left += rect.Width() / 2;
	}
	else
	{
		rect.top += rect.Height() / 2;
	}

	CMFCTabCtrl* pNewTabWnd = CreateNewTabGroup(pActiveWnd, rect, bVert);
	MoveWindowToTabGroup(pActiveWnd, pNewTabWnd);
}

void CMDIClientAreaWnd::CloseAllWindows(CMFCTabCtrl* pTabWnd)
{
	if (pTabWnd != NULL)
	{
		ASSERT_VALID(pTabWnd);

		for (int i = pTabWnd->GetTabsNum() - 1; i >= 0; i--)
		{
			CMDIChildWndEx* pNextWnd = DYNAMIC_DOWNCAST(CMDIChildWndEx, pTabWnd->GetTabWnd(i));
			if (pNextWnd != NULL)
			{
				ASSERT_VALID(pNextWnd);
				pNextWnd->SendMessage(WM_CLOSE, (WPARAM) 0, (LPARAM) 0);
			}
		}
	}
	else
	{
		CObList lstWindows;
		CWnd* pWndChild = GetWindow(GW_CHILD);

		while (pWndChild != NULL)
		{
			ASSERT_VALID(pWndChild);

			CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, pWndChild);
			if (pMDIChild != NULL)
			{
				ASSERT_VALID(pMDIChild);
				lstWindows.AddTail(pMDIChild);
			}

			pWndChild = pWndChild->GetNextWindow();
		}

		for (POSITION pos = lstWindows.GetHeadPosition(); pos != NULL;)
		{
			CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, lstWindows.GetNext(pos));
			ASSERT_VALID(pMDIChild);
			pMDIChild->SendMessage(WM_CLOSE, (WPARAM) 0, (LPARAM) 0);
		}

	}
}

void CMDIClientAreaWnd::SerializeTabGroup(CArchive& ar, CMFCTabCtrl* pTabWnd, BOOL bSetRelation)
{
	ASSERT_VALID(pTabWnd);
	if (ar.IsStoring())
	{
		int nTabsNum = pTabWnd->GetTabsNum();
		ar << nTabsNum;

		int nActiveTab = pTabWnd->GetActiveTab();
		ar << nActiveTab;
		ar << pTabWnd->IsActiveInMDITabGroup();

		int i = 0;

		for (i = 0; i < nTabsNum; i++)
		{
			CMDIChildWndEx* pNextWnd = DYNAMIC_DOWNCAST(CMDIChildWndEx, pTabWnd->GetTabWnd(i));
			ASSERT_VALID(pNextWnd);

			CObject* pObject = NULL;
			CString strDocumentName = pNextWnd->GetDocumentName(&pObject);
			ar << strDocumentName;

			BOOL bObjPresent = (pObject != NULL);
			ar << bObjPresent;
			if (bObjPresent)
			{
				ar << pObject;
				delete pObject;
			}

			CString strLabel;
			pTabWnd->GetTabLabel(i, strLabel);
			ar << strLabel;

			ar << pTabWnd->GetResizeMode();
			ar << pTabWnd->GetTabBkColor(i);

			int nBarID = -1;

			if (pNextWnd->IsTabbedPane())
			{
				CDockablePane* pBar = pNextWnd->GetTabbedPane();
				if (pBar != NULL && pBar->GetSafeHwnd() != NULL)
				{
					nBarID = pBar->GetDlgCtrlID();
				}
			}

			ar << nBarID;
		}

		ar << pTabWnd->IsAutoColor();

		const CArray<COLORREF, COLORREF>& arColors = pTabWnd->GetAutoColors();
		ar <<(int) arColors.GetSize();

		for (i = 0; i < arColors.GetSize(); i++)
		{
			ar << arColors [i];
		}

		ar << pTabWnd->IsTabDocumentsMenu();
		ar << pTabWnd->IsTabSwapEnabled();
		ar << pTabWnd->GetTabBorderSize();

		CRect rectWindow;
		pTabWnd->GetWindowRect(rectWindow);
		ar << rectWindow;
	}
	else
	{
		int nTabsNum = 0;
		ar >> nTabsNum;

		int nActiveTab = -1;
		ar >> nActiveTab;

		BOOL bIsActiveInMDITabGroup = FALSE;
		ar >> bIsActiveInMDITabGroup;

		if (bIsActiveInMDITabGroup)
		{
			CMFCTabCtrl* pPrevActiveWnd = FindActiveTabWnd();
			if (pPrevActiveWnd != NULL)
			{
				pPrevActiveWnd->SetActiveInMDITabGroup(FALSE);
				pPrevActiveWnd->InvalidateTab(pPrevActiveWnd->GetActiveTab());
			}
		}
		pTabWnd->SetActiveInMDITabGroup(bIsActiveInMDITabGroup);

		CMDIFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParent());
		ASSERT_VALID(pFrame);

		int i = 0;

		for (i = 0; i < nTabsNum; i++)
		{
			CString strDocumentName;
			ar >> strDocumentName;

			BOOL bObjectPresent = FALSE;
			CObject* pObj = NULL;

			ar >> bObjectPresent;
			if (bObjectPresent)
			{
				ar >> pObj;
			}

			CString strLabel;
			ar >> strLabel;

			int nValue;
			ar >> nValue;
			pTabWnd->SetResizeMode((CMFCTabCtrl::ResizeMode) nValue);

			COLORREF clrTab = (COLORREF) -1;
			ar >> clrTab;

			int nBarID = -1;
			ar >> nBarID;

			CMDIChildWndEx* pNextWnd = NULL;

			if (!strDocumentName.IsEmpty())
			{
				if (m_lstLoadedTabDocuments.Find(strDocumentName) == NULL)
				{
					pNextWnd = pFrame->CreateDocumentWindow(strDocumentName, pObj);
					if (pNextWnd)
					{
						m_lstLoadedTabDocuments.AddTail(strDocumentName);
					}
				}
				else
				{
					pNextWnd = pFrame->CreateNewWindow(strDocumentName, pObj);
				}
			}
			else if (nBarID != -1)
			{
				CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, pFrame->GetPane(nBarID));
				if (pBar != NULL)
				{
					CBaseTabbedPane* pTabbedBar = pBar->GetParentTabbedPane();
					if (pTabbedBar != NULL)
					{
						pBar->StoreRecentTabRelatedInfo();
					}
					pNextWnd = pFrame->ControlBarToTabbedDocument(pBar);
					if (pTabbedBar != NULL)
					{
						pTabbedBar->RemovePane(pBar);
					}
				}
			}

			if (pNextWnd != NULL)
			{
				ASSERT_VALID(pNextWnd);
				pTabWnd->AddTab(pNextWnd, strLabel);
				pTabWnd->SetTabBkColor(i, clrTab);
				if (bSetRelation)
				{
					pNextWnd->SetRelatedTabGroup(pTabWnd);
				}
			}

			if (pObj != NULL)
			{
				delete pObj;
			}
		}

		BOOL bIsAutoColor = FALSE;
		ar >> bIsAutoColor;

		int nAutoColorSize = 0;
		ar >> nAutoColorSize;

		CArray<COLORREF, COLORREF> arColors;

		for (i = 0; i < nAutoColorSize; i++)
		{
			COLORREF clr = (COLORREF) -1;
			ar >> clr;
			arColors.SetAtGrow(i, clr);
		}

		pTabWnd->EnableAutoColor(bIsAutoColor);
		pTabWnd->SetAutoColors(arColors);
		m_mdiTabParams.m_bAutoColor = bIsAutoColor;

		BOOL bValue = FALSE;

		ar >> bValue;
		pTabWnd->EnableTabDocumentsMenu(bValue);
		m_mdiTabParams.m_bDocumentMenu = bValue;

		ar >> bValue;
		pTabWnd->EnableTabSwap(bValue);
		m_mdiTabParams.m_bEnableTabSwap = bValue;

		int nTabBorderSize = 1;
		ar >> nTabBorderSize;
		pTabWnd->SetTabBorderSize(nTabBorderSize);
		m_mdiTabParams.m_nTabBorderSize = nTabBorderSize;

		CRect rectWindow;
		ar >> rectWindow;

		pTabWnd->GetParent()->ScreenToClient(rectWindow);

		pTabWnd->SetWindowPos(NULL, rectWindow.left, rectWindow.right, rectWindow.Width(), rectWindow.Height(), SWP_NOZORDER | SWP_NOACTIVATE);

		if (pTabWnd->GetTabsNum() > 0)
		{
			if (nActiveTab > pTabWnd->GetTabsNum() - 1)
			{
				nActiveTab = pTabWnd->GetTabsNum() - 1;
			}

			pTabWnd->SetActiveTab(nActiveTab);
		}
	}
}

void CMDIClientAreaWnd::SerializeOpenChildren(CArchive& ar)
{
	if (ar.IsStoring())
	{
		CObList lstWindows;

		CWnd* pWndChild = GetWindow(GW_CHILD);
		while (pWndChild != NULL)
		{
			ASSERT_VALID(pWndChild);

			CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, pWndChild);
			if (pMDIChild != NULL)
			{
				ASSERT_VALID(pWndChild);

				CObject* pObj = NULL;
				CString str = pMDIChild->GetDocumentName(&pObj);
				if (pObj != NULL)
				{
					delete pObj;
				}
				if (!str.IsEmpty())
				{
					lstWindows.AddHead(pMDIChild);
				}
			}

			pWndChild = pWndChild->GetNextWindow();
		}

		HWND hwndActive = (HWND) SendMessage(WM_MDIGETACTIVE);

		ar <<(int) lstWindows.GetCount();

		for (POSITION pos = lstWindows.GetHeadPosition(); pos != NULL;)
		{
			CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, lstWindows.GetNext(pos));

			ASSERT_VALID(pMDIChild);

			CObject* pObj = NULL;
			CString str = pMDIChild->GetDocumentName(&pObj);
			ar << str;

			BOOL bObjPresent = (pObj != NULL);
			ar << bObjPresent;
			if (bObjPresent)
			{
				ar << pObj;
				delete pObj;
			}

			WINDOWPLACEMENT wp;
			pMDIChild->GetWindowPlacement(&wp);

			ar << wp.flags;
			ar << wp.length;
			ar << wp.ptMaxPosition;
			ar << wp.ptMinPosition;
			ar << wp.rcNormalPosition;
			ar << wp.showCmd;

			BOOL bActive = (pMDIChild->GetSafeHwnd() == hwndActive);
			ar << bActive;

			int nBarID = -1;

			if (pMDIChild->IsTabbedPane())
			{
				CDockablePane* pBar = pMDIChild->GetTabbedPane();
				if (pBar != NULL && pBar->GetSafeHwnd() != NULL)
				{
					nBarID = pBar->GetDlgCtrlID();
				}
			}

			ar << nBarID;
		}

	}
	else
	{
		CMDIFrameWndEx* pFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, GetParent());
		ASSERT_VALID(pFrame);

		int nCount = 0;
		ar >> nCount;

		HWND hwndActive = NULL;
		BOOL bMaximize = FALSE;
		for (int i = 0; i < nCount; i++)
		{
			CString strDocName;
			ar >> strDocName;

			BOOL bObjPresent = FALSE;
			CObject* pObj = NULL;

			ar >> bObjPresent;
			if (bObjPresent)
			{
				ar >> pObj;
			}

			WINDOWPLACEMENT wp;
			ar >> wp.flags;
			ar >> wp.length;
			ar >> wp.ptMaxPosition;
			ar >> wp.ptMinPosition;
			ar >> wp.rcNormalPosition;
			ar >> wp.showCmd;

			BOOL bActive = FALSE;
			ar >> bActive;

			int nBarID = -1;
			ar >> nBarID;

			if (bMaximize)
			{
				wp.showCmd = SW_SHOWMAXIMIZED;
			}

			CMDIChildWndEx* pNextWnd = NULL;

			if (!strDocName.IsEmpty() && nBarID == -1)
			{
				pNextWnd = pFrame->CreateNewWindow(strDocName, pObj);
			}
			else if (nBarID != -1)
			{

				CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, pFrame->GetPane(nBarID));
				if (pBar != NULL)
				{
					CBaseTabbedPane* pTabbedBar = pBar->GetParentTabbedPane();
					if (pTabbedBar != NULL)
					{
						pBar->StoreRecentTabRelatedInfo();
					}
					pNextWnd = pFrame->ControlBarToTabbedDocument(pBar);
					if (pTabbedBar != NULL)
					{
						pTabbedBar->RemovePane(pBar);
					}
				}
			}

			if (pObj != NULL)
			{
				delete pObj;
			}
			if (pNextWnd != NULL)
			{
				ASSERT_VALID(pNextWnd);

				pNextWnd->SetWindowPlacement(&wp);
				if (wp.showCmd == SW_SHOWMAXIMIZED)
				{
					ShowWindow(wp.showCmd);
					bMaximize = TRUE;
				}

				if (bActive)
				{
					hwndActive = pNextWnd->GetSafeHwnd();
				}
			}
		}

		if (hwndActive != NULL)
		{
			SendMessage(WM_MDIACTIVATE, (WPARAM) hwndActive);
		}
	}
}

BOOL CMDIClientAreaWnd::SaveState(LPCTSTR lpszProfileName, UINT nFrameID)
{
	BOOL bResult = FALSE;
	CString strProfileName = ::AFXGetRegPath(strMDIClientAreaProfile, lpszProfileName);

	CString strSection;
	strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nFrameID);

	try
	{
		CMemFile file;
		{
			CArchive ar(&file, CArchive::store);

			Serialize(ar);
			ar.Flush();
		}

		UINT uiDataSize = (UINT) file.GetLength();
		LPBYTE lpbData = file.Detach();

		if (lpbData != NULL)
		{
			CSettingsStoreSP regSP;
			CSettingsStore& reg = regSP.Create(FALSE, FALSE);

			if (reg.CreateKey(strSection))
			{
				bResult = reg.Write(AFX_REG_ENTRY_MDITABS_STATE, lpbData, uiDataSize);
			}

			free(lpbData);
		}
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMDIClientAreaWnd::SaveState()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CMDIClientAreaWnd::SaveState()!\n"));
	}
	catch(...)
	{
		TRACE(_T("Unknown exception in CMDIClientAreaWnd::SaveState()!\n"));
	}

	return bResult;
}

BOOL CMDIClientAreaWnd::LoadState(LPCTSTR lpszProfileName, UINT nFrameID)
{
	BOOL bResult = FALSE;

	CString strProfileName = ::AFXGetRegPath(strMDIClientAreaProfile, lpszProfileName);

	CString strSection;
	strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nFrameID);

	LPBYTE lpbData = NULL;
	UINT uiDataSize;

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	if (!reg.Read(AFX_REG_ENTRY_MDITABS_STATE, &lpbData, &uiDataSize))
	{
		return FALSE;
	}

	try
	{
		CMemFile file(lpbData, uiDataSize);
		CArchive ar(&file, CArchive::load);

		Serialize(ar);
		bResult = TRUE;
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMDIClientAreaWnd::LoadState!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CMDIClientAreaWnd::LoadState()!\n"));
	}
	catch(...)
	{
		TRACE(_T("Unknown exception in CMDIClientAreaWnd::LoadState()!\n"));
	}

	if (lpbData != NULL)
	{
		delete [] lpbData;
	}

	if (!bResult)
	{
		m_bDisableUpdateTabs = FALSE;
		CloseAllWindows(NULL);
	}

	return bResult;
}

void CMDIClientAreaWnd::Serialize(CArchive& ar)
{
	m_mdiTabParams.Serialize(ar);

	if (ar.IsStoring())
	{
		ar << m_bTabIsEnabled;
		ar << m_bIsMDITabbedGroup;

		ar << m_bTabIsVisible;
		ar << m_groupAlignment;
		ar << m_nResizeMargin;
		ar << m_nNewGroupMargin;

		if (m_bTabIsEnabled)
		{
			SerializeTabGroup(ar, &m_wndTab);
		}
		else if (m_bIsMDITabbedGroup)
		{
			int nCountTabbedGroups = (int) m_lstTabbedGroups.GetCount();
			ar << nCountTabbedGroups;

			if (nCountTabbedGroups > 0)
			{
				for (POSITION pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
				{
					CMFCTabCtrl* pNextWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
					SerializeTabGroup(ar, pNextWnd);
				}
			}
		}
		else
		{
			SerializeOpenChildren(ar);
		}
	}
	else if (ar.IsLoading())
	{
		CloseAllWindows(NULL);
		m_lstLoadedTabDocuments.RemoveAll();

		m_bDisableUpdateTabs = TRUE;

		ar >> m_bTabIsEnabled;
		ar >> m_bIsMDITabbedGroup;
		ar >> m_bTabIsVisible;

		int nValue;
		ar >> nValue;
		m_groupAlignment = (GROUP_ALIGNMENT) nValue;

		ar >> m_nResizeMargin;
		ar >> m_nNewGroupMargin;

		if (m_bTabIsEnabled)
		{
			SerializeTabGroup(ar, &m_wndTab);
			EnableMDITabs(TRUE, m_mdiTabParams);
		}
		else if (m_bIsMDITabbedGroup)
		{

			int nCountTabbedGroups = 0;
			ar >> nCountTabbedGroups;

			for (int i = 0; i < nCountTabbedGroups; i++)
			{
				CMFCTabCtrl* pNewTabWnd = CreateTabGroup(NULL);
				ASSERT_VALID(pNewTabWnd);
				SerializeTabGroup(ar, pNewTabWnd, TRUE);

				if (pNewTabWnd->GetTabsNum() == 0)
				{
					pNewTabWnd->DestroyWindow();
					delete pNewTabWnd;
				}
				else
				{
					m_lstTabbedGroups.AddTail(pNewTabWnd);
				}
			}

			// sanity check for resize mode - the last group might have been removed
			// because the document could not be opened
			if (m_lstTabbedGroups.GetCount() > 0)
			{
				CMFCTabCtrl* pLastTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetTail());
				ASSERT_VALID(pLastTabWnd);
				pLastTabWnd->SetResizeMode(CMFCTabCtrl::RESIZE_NO);
			}

			EnableMDITabbedGroups(TRUE, m_mdiTabParams);
		}
		else
		{
			SerializeOpenChildren(ar);
		}

		m_bDisableUpdateTabs = FALSE;

		if (m_bIsMDITabbedGroup)
		{
			UpdateMDITabbedGroups(TRUE);
			for (POSITION pos = m_lstTabbedGroups.GetHeadPosition(); pos != NULL;)
			{
				CMFCTabCtrl* pNextWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(pos));
				ASSERT_VALID(pNextWnd);
				pNextWnd->RecalcLayout();

				if (pNextWnd->IsActiveInMDITabGroup())
				{
					CWnd* pWnd = pNextWnd->GetTabWnd(pNextWnd->GetActiveTab());
					PostMessage(WM_MDIACTIVATE, (WPARAM) pWnd->GetSafeHwnd());
				}
			}
		}
		else if (m_bTabIsEnabled)
		{
			UpdateTabs(TRUE);
			m_wndTab.RecalcLayout();
		}

		((CFrameWnd*) GetParent())->RecalcLayout();
	}
}

LRESULT CMDIClientAreaWnd::OnMDINext(WPARAM wp, LPARAM lp)
{
	if (!m_bIsMDITabbedGroup && !m_bTabIsEnabled)
	{
		return Default();
	}

	BOOL bNext = (lp == 0);

	CMFCTabCtrl* pActiveTabWnd = NULL;
	int nActiveTab = -1;

	if (m_bIsMDITabbedGroup)
	{
		pActiveTabWnd = FindActiveTabWnd();
	}
	else
	{
		pActiveTabWnd = &m_wndTab;
	}

	ASSERT_VALID(pActiveTabWnd);

	POSITION posActive = m_bIsMDITabbedGroup ? m_lstTabbedGroups.Find(pActiveTabWnd) : NULL;
	int nGroupCount = m_bIsMDITabbedGroup ?(int) m_lstTabbedGroups.GetCount() : 0;

	if (m_bIsMDITabbedGroup)
	{
		ENSURE(posActive != NULL);
	}

	nActiveTab = pActiveTabWnd->GetActiveTab();

	bNext ? nActiveTab++ : nActiveTab--;

	if (nActiveTab < 0)
	{
		if (nGroupCount > 0)
		{
			m_lstTabbedGroups.GetPrev(posActive);
			if (posActive != NULL)
			{
				pActiveTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetAt(posActive));
			}
			else
			{
				pActiveTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetTail());
			}
		}

		ENSURE(pActiveTabWnd != NULL);

		nActiveTab = pActiveTabWnd->GetTabsNum() - 1;
	}

	if (nActiveTab >= pActiveTabWnd->GetTabsNum())
	{
		if (nGroupCount > 0)
		{
			pActiveTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetNext(posActive));
			if (posActive != NULL)
			{
				pActiveTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetAt(posActive));
			}
			else
			{
				pActiveTabWnd = DYNAMIC_DOWNCAST(CMFCTabCtrl, m_lstTabbedGroups.GetHead());
			}
		}

		ENSURE(pActiveTabWnd != NULL);

		nActiveTab = 0;
	}

	CWnd* pWnd = pActiveTabWnd->GetTabWnd(nActiveTab);
	ASSERT_VALID(pWnd);

	if (pWnd->GetSafeHwnd() != (HWND) wp)
	{
		SetActiveTab(pWnd->GetSafeHwnd());
	}
	return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmdiframewndex.cpp ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "afxmdiframewndex.h"
#include "afxmdichildwndex.h"
#include "afxtoolbar.h"
#include "afxmenubar.h"
#include "afxpopupmenu.h"
#include "afxtoolbarmenubutton.h"
#include "afxpaneframewnd.h"
#include "afxribbonres.h"
#include "afxwindowsmanagerdialog.h"
#include "afxusertoolsmanager.h"
#include "afxcontextmenumanager.h"
#include "afxpanedivider.h"

#include "afxdockablepane.h"
#include "afxtabbedpane.h"
#include "afxpreviewviewex.h"
#include "afxribbonbar.h"
#include "afxribbonstatusbar.h"

#pragma comment(lib,"imm32") // ImmXxx

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#pragma comment(lib, "imm32.lib")

typedef BOOL (STDAPICALLTYPE *PFNCHANGEWINDOWMESSAGEFILTER)(UINT, DWORD);

/////////////////////////////////////////////////////////////////////////////
// CMDIFrameWndEx

IMPLEMENT_DYNCREATE(CMDIFrameWndEx, CMDIFrameWnd)

BOOL CMDIFrameWndEx::m_bDisableSetRedraw = TRUE;

#pragma warning(disable : 4355)

CMDIFrameWndEx::CMDIFrameWndEx() :
	m_Impl(this), m_hmenuWindow(NULL), m_bContextHelp(FALSE), m_bDoSubclass(TRUE), m_uiWindowsDlgMenuId(0),
	m_bShowWindowsDlgAlways(FALSE), m_bShowWindowsDlgHelpButton(FALSE), m_bWasMaximized(FALSE), m_bIsMinimized(FALSE),
	m_bClosing(FALSE), m_nFrameID(0), m_pPrintPreviewFrame(NULL), m_bCanConvertControlBarToMDIChild(FALSE)
{
	// Allow WM_DWMSENDICONICTHUMBNAIL and WM_DWMSENDICONICLIVEPREVIEWBITMAP through the UIPI filter, so
	// an MFC application running as administrator can show thumbnails correctly in the Windows7 taskbar.
	if (afxGlobalData.bIsWindows7)
	{
		HMODULE hUser = AfxCtxLoadLibraryW(L"USER32.DLL");
		if (hUser != NULL)
		{
			PFNCHANGEWINDOWMESSAGEFILTER pfnChangeWindowMessageFilter = (PFNCHANGEWINDOWMESSAGEFILTER)GetProcAddress(hUser, "ChangeWindowMessageFilter");
			if (pfnChangeWindowMessageFilter != NULL)
			{
				BOOL bFilter;
				bFilter = pfnChangeWindowMessageFilter(WM_DWMSENDICONICTHUMBNAIL, MSGFLT_ADD);
				bFilter = pfnChangeWindowMessageFilter(WM_DWMSENDICONICLIVEPREVIEWBITMAP, MSGFLT_ADD);
			}
		}
	}
}

#pragma warning(default : 4355)

CMDIFrameWndEx::~CMDIFrameWndEx()
{
}

//{{AFX_MSG_MAP(CMDIFrameWndEx)
BEGIN_MESSAGE_MAP(CMDIFrameWndEx, CMDIFrameWnd)
	ON_WM_MENUCHAR()
	ON_WM_WINDOWPOSCHANGED()
	ON_WM_ACTIVATE()
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_GETMINMAXINFO()
	ON_WM_CONTEXTMENU()
	ON_WM_NCPAINT()
	ON_WM_NCACTIVATE()
	ON_WM_NCMOUSEMOVE()
	ON_WM_NCHITTEST()
	ON_WM_NCCALCSIZE()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_ACTIVATEAPP()
	ON_WM_SYSCOLORCHANGE()
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &CMDIFrameWndEx::OnIdleUpdateCmdUI)
	ON_MESSAGE(WM_SETTEXT, &CMDIFrameWndEx::OnSetText)
	ON_MESSAGE(WM_DWMCOMPOSITIONCHANGED, &CMDIFrameWndEx::OnDWMCompositionChanged)
	ON_MESSAGE(WM_EXITSIZEMOVE, &CMDIFrameWndEx::OnExitSizeMove)
	ON_COMMAND(ID_CONTEXT_HELP, &CMDIFrameWndEx::OnContextHelp)
	ON_UPDATE_COMMAND_UI(ID_VIEW_STATUS_BAR, &CMDIFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_STATUS_BAR, &CMDIFrameWndEx::OnPaneCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, &CMDIFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, &CMDIFrameWndEx::OnPaneCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_REBAR, &CMDIFrameWndEx::OnUpdatePaneMenu)
	ON_COMMAND_EX(ID_VIEW_REBAR, &CMDIFrameWndEx::OnPaneCheck)
	ON_COMMAND(ID_WINDOW_NEW, &CMDIFrameWndEx::OnWindowNew)
	ON_REGISTERED_MESSAGE(AFX_WM_TOOLBARMENU, &CMDIFrameWndEx::OnToolbarContextMenu)
	ON_REGISTERED_MESSAGE(AFX_WM_CHANGEVISUALMANAGER, &CMDIFrameWndEx::OnChangeVisualManager)
	ON_REGISTERED_MESSAGE(AFX_WM_POSTSETPREVIEWFRAME, &CMDIFrameWndEx::OnPostPreviewFrame)
	ON_REGISTERED_MESSAGE(AFX_WM_CREATETOOLBAR, &CMDIFrameWndEx::OnToolbarCreateNew)
	ON_REGISTERED_MESSAGE(AFX_WM_DELETETOOLBAR, &CMDIFrameWndEx::OnToolbarDelete)
	ON_MESSAGE(WM_POWERBROADCAST, &OnPowerBroadcast)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMDIFrameWndEx message handlers

BOOL CMDIFrameWndEx::OnSetMenu(HMENU hmenu)
{
	COleClientItem* pActiveItem = GetInPlaceActiveItem();
	if (pActiveItem != NULL && pActiveItem->GetInPlaceWindow() != NULL)
	{
		return FALSE;
	}

	if (m_Impl.m_pRibbonBar != NULL && (m_Impl.m_pRibbonBar->GetStyle() & WS_VISIBLE))
	{
		SetMenu(NULL);
		m_Impl.m_pRibbonBar->SetActiveMDIChild(MDIGetActive());
		return TRUE;
	}

	if (m_Impl.m_pMenuBar != NULL)
	{
		SetMenu(NULL);
		m_Impl.m_pMenuBar->CreateFromMenu(hmenu == NULL ? m_Impl.m_hDefaultMenu : hmenu);
		return TRUE;
	}

	return FALSE;
}

BOOL CMDIFrameWndEx::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext)
{
	if (!CMDIFrameWnd::OnCreateClient(lpcs, pContext))
	{
		return FALSE;
	}

	if (m_bDoSubclass)
	{
		m_wndClientArea.SubclassWindow(m_hWndMDIClient);
	}

	return TRUE;
}

LRESULT CMDIFrameWndEx::OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu)
{
	if (m_Impl.OnMenuChar(nChar))
	{
		return MAKELPARAM(MNC_EXECUTE, -1);
	}

	return CMDIFrameWnd::OnMenuChar(nChar, nFlags, pMenu);
}

void CMDIFrameWndEx::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)
{
	if ((lpwndpos->flags & SWP_FRAMECHANGED) == SWP_FRAMECHANGED)
	{
		m_Impl.OnWindowPosChanging(lpwndpos);
	}

	CMDIFrameWnd::OnWindowPosChanged(lpwndpos);

	if (m_Impl.m_pMenuBar != NULL)
	{
		BOOL bMaximized;
		CMDIChildWnd* pChild = MDIGetActive(&bMaximized);

		if (pChild == NULL || !bMaximized)
		{
			m_Impl.m_pMenuBar->SetMaximizeMode(FALSE);
		}
		else
		{
			m_Impl.m_pMenuBar->SetMaximizeMode(TRUE, pChild);
		}
	}

	if (m_Impl.m_pRibbonBar != NULL)
	{
		ASSERT_VALID(m_Impl.m_pRibbonBar);

		BOOL bMaximized;
		CMDIChildWnd* pChild = MDIGetActive(&bMaximized);

		if (pChild == NULL || !bMaximized)
		{
			m_Impl.m_pRibbonBar->SetMaximizeMode(FALSE);
		}
		else
		{
			m_Impl.m_pRibbonBar->SetMaximizeMode(TRUE, pChild);
		}
	}
}

BOOL CMDIFrameWndEx::PreTranslateMessage(MSG* pMsg)
{
	BOOL bProcessAccel = TRUE;

	switch(pMsg->message)
	{
	case WM_SYSKEYDOWN:
		if (m_Impl.m_pRibbonBar != NULL && m_Impl.m_pRibbonBar->OnSysKeyDown(this, pMsg->wParam, pMsg->lParam))
		{
			return TRUE;
		}

	case WM_CONTEXTMENU:
		if (!afxGlobalData.m_bSysUnderlineKeyboardShortcuts && !afxGlobalData.m_bUnderlineKeyboardShortcuts)
		{
			afxGlobalData.m_bUnderlineKeyboardShortcuts = TRUE;
			CMFCToolBar::RedrawUnderlines ();
		}

		if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd) &&
			pMsg->wParam == VK_MENU)
		{
			CMFCPopupMenu::m_pActivePopupMenu->SendMessage(WM_CLOSE);
			return TRUE;
		}
		else if (m_Impl.ProcessKeyboard((int) pMsg->wParam))
		{
			return TRUE;
		}
		break;

	case WM_SYSKEYUP:
		{
			if (m_Impl.m_pRibbonBar != NULL && m_Impl.m_pRibbonBar->OnSysKeyUp(this, pMsg->wParam, pMsg->lParam))
			{
				return TRUE;
			}
			BOOL  isCtrlPressed = (0x8000 & GetKeyState(VK_CONTROL)) != 0;
			BOOL  isShiftPressed = (0x8000 & GetKeyState(VK_SHIFT)) != 0;

			HIMC hContext = ImmGetContext(m_hWnd);
			BOOL bIMEActive = ((hContext != NULL) && ImmGetOpenStatus(hContext));
			if (hContext != NULL)
			{
				ImmReleaseContext(m_hWnd, hContext);
			}

			if (m_Impl.m_pMenuBar != NULL && (pMsg->wParam == VK_MENU || (pMsg->wParam == VK_F10 && !isCtrlPressed && !isShiftPressed && !bIMEActive)))
			{
				if (m_Impl.m_pMenuBar == GetFocus())
				{
					SetFocus();
				}
				else
				{
					if ((pMsg->lParam &(1 << 29)) == 0)
					{
						m_Impl.m_pMenuBar->SetFocus();
					}
				}
				return TRUE;
			}

			if (CMFCPopupMenu::m_pActivePopupMenu != NULL && ::IsWindow(CMFCPopupMenu::m_pActivePopupMenu->m_hWnd))
			{
				return TRUE; // To prevent system menu opening
			}
		}
		break;

	case WM_KEYDOWN:
		//-----------------------------------------
		// Pass keyboard action to the active menu:
		//-----------------------------------------
		if (!CFrameImpl::IsHelpKey(pMsg) && m_Impl.ProcessKeyboard((int) pMsg->wParam))
		{
			return TRUE;
		}

		if (pMsg->wParam == VK_ESCAPE)
		{
			if (IsFullScreen())
			{
				m_Impl.m_FullScreenMgr.RestoreState(this);
			}

			CSmartDockingManager* pSDManager = NULL;
			if ((pSDManager = m_dockManager.GetSmartDockingManagerPermanent()) != NULL && pSDManager->IsStarted())
			{
				pSDManager->CauseCancelMode();
			}

			CPaneDivider* pSlider = DYNAMIC_DOWNCAST(CPaneDivider, GetCapture());
			if (pSlider != NULL)
			{
				pSlider->SendMessage(WM_CANCELMODE);
				return TRUE;
			}
		}

		if (!bProcessAccel)
		{

			return FALSE;
		}
		break;

	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);

			if (pWnd != NULL && ::IsWindow(pMsg->hwnd))
			{
				pWnd->ClientToScreen(&pt);
			}

			if (m_Impl.ProcessMouseClick(pMsg->message, pt, pMsg->hwnd))
			{
				return TRUE;
			}

			if (!::IsWindow(pMsg->hwnd))
			{
				return TRUE;
			}
		}
		break;

	case WM_NCLBUTTONDOWN:
	case WM_NCLBUTTONUP:
	case WM_NCRBUTTONDOWN:
	case WM_NCRBUTTONUP:
	case WM_NCMBUTTONDOWN:
	case WM_NCMBUTTONUP:
		if (m_Impl.ProcessMouseClick(pMsg->message, CPoint(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam)), pMsg->hwnd))
		{
			return TRUE;
		}
		break;

	case WM_MOUSEWHEEL:
		if (m_Impl.ProcessMouseWheel(pMsg->wParam, pMsg->lParam))
		{
			return TRUE;
		}
		break;

	case WM_MOUSEMOVE:
		{
			CPoint pt(AFX_GET_X_LPARAM(pMsg->lParam), AFX_GET_Y_LPARAM(pMsg->lParam));
			CWnd* pWnd = CWnd::FromHandle(pMsg->hwnd);
			if (pWnd != NULL)
			{
				pWnd->ClientToScreen(&pt);
			}

			if (m_Impl.ProcessMouseMove(pt))
			{
				return TRUE;
			}
		}
	}

	return CMDIFrameWnd::PreTranslateMessage(pMsg);
}

BOOL CMDIFrameWndEx::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (HIWORD(wParam) == 1)
	{
		UINT uiCmd = LOWORD(wParam);
		CMFCToolBar::AddCommandUsage(uiCmd);

		//---------------------------
		// Simmulate ESC keystroke...
		//---------------------------
		if (m_Impl.ProcessKeyboard(VK_ESCAPE))
		{
			return TRUE;
		}

		if (afxUserToolsManager != NULL && afxUserToolsManager->InvokeTool(uiCmd))
		{
			return TRUE;
		}
	}

	if (!CMFCToolBar::IsCustomizeMode())
	{
		return CMDIFrameWnd::OnCommand(wParam, lParam);
	}

	return FALSE;
}

HMENU CMDIFrameWndEx::GetWindowMenuPopup(HMENU hMenuBar)
{
	if (m_bClosing)
	{
		return NULL;
	}

	m_hmenuWindow = CMDIFrameWnd::GetWindowMenuPopup(hMenuBar);
	return m_hmenuWindow;
}

BOOL CMDIFrameWndEx::LoadFrame(UINT nIDResource, DWORD dwDefaultStyle, CWnd* pParentWnd, CCreateContext* pContext)
{
	m_Impl.m_nIDDefaultResource = nIDResource;
	m_Impl.LoadLargeIconsState();

	if (!CMDIFrameWnd::LoadFrame(nIDResource, dwDefaultStyle, pParentWnd, pContext))
	{
		return FALSE;
	}

	m_Impl.OnLoadFrame();

	if (GetMenuBar() != NULL)
	{
		m_hMenuDefault = m_Impl.m_hDefaultMenu;
	}

	return TRUE;
}

void CMDIFrameWndEx::OnClose()
{
	if (m_pPrintPreviewFrame != NULL)
	{
		m_pPrintPreviewFrame->SendMessage(WM_CLOSE);
		m_pPrintPreviewFrame = NULL;
		return;
	}

	if (!m_Impl.IsPrintPreview())
	{
		m_bClosing = TRUE;

		// Deactivate OLE container first:
		COleClientItem* pActiveItem = GetInPlaceActiveItem();
		if (pActiveItem != NULL)
		{
			pActiveItem->Deactivate();
		}

		m_Impl.OnCloseFrame();
	}

	CMDIFrameWnd::OnClose();
}

BOOL CMDIFrameWndEx::PreCreateWindow(CREATESTRUCT& cs)
{
	m_Impl.SetDockingManager(&m_dockManager);
	m_Impl.RestorePosition(cs);
	return CMDIFrameWnd::PreCreateWindow(cs);
}

BOOL CMDIFrameWndEx::ShowPopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (!m_Impl.OnShowPopupMenu(pMenuPopup, this))
	{
		return FALSE;
	}


	if (!CMFCToolBar::IsCustomizeMode() && m_hmenuWindow != NULL && pMenuPopup != NULL && pMenuPopup->GetHMenu() != NULL)
	{
		//-----------------------------------------------------------
		// Check the popup menu for the "Windows..." menu maching...:
		//-----------------------------------------------------------
		HMENU hMenuPop = pMenuPopup->GetHMenu();
		BOOL bIsWindowMenu = FALSE;

		int iItemMax = ::GetMenuItemCount(hMenuPop);
		for (int iItemPop = 0; !bIsWindowMenu && iItemPop < iItemMax; iItemPop ++)
		{
			UINT nID = ::GetMenuItemID( hMenuPop, iItemPop);
			bIsWindowMenu = (nID >= AFX_IDM_WINDOW_FIRST && nID <= AFX_IDM_WINDOW_LAST);
		}

		if (bIsWindowMenu)
		{
			CMenu* pMenu = CMenu::FromHandle(m_hmenuWindow);
			if (pMenu != NULL)
			{
				int iCount = pMenu->GetMenuItemCount();
				BOOL bIsFirstWindowItem = TRUE;
				BOOL bIsStandradWindowsDlg = FALSE;

				for (int i = 0; i < iCount; i ++)
				{
					UINT uiCmd = pMenu->GetMenuItemID(i);
					if (uiCmd < AFX_IDM_FIRST_MDICHILD || uiCmd == (UINT) -1)
					{
						continue;
					}

					if (m_uiWindowsDlgMenuId != 0 && uiCmd == AFX_IDM_FIRST_MDICHILD + 9)
					{
						// Don't add standrd "Windows..." command
						bIsStandradWindowsDlg = TRUE;
						continue;
					}

					if (bIsFirstWindowItem)
					{
						pMenuPopup->InsertSeparator();
						bIsFirstWindowItem = FALSE;

						::SendMessage(m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
					}

					CString strText;
					pMenu->GetMenuString(i, strText, MF_BYPOSITION);

					CMFCToolBarMenuButton button(uiCmd, NULL, -1, strText);

					UINT uiState = pMenu->GetMenuState(i, MF_BYPOSITION);
					if (uiState & MF_CHECKED)
					{
						button.m_nStyle |= TBBS_CHECKED;
					}

					pMenuPopup->InsertItem(button);
				}

				if (m_uiWindowsDlgMenuId != 0 && (bIsStandradWindowsDlg || m_bShowWindowsDlgAlways))
				{
					if (!CMFCToolBar::GetBasicCommands().IsEmpty())
					{
						CMFCToolBar::AddBasicCommand(m_uiWindowsDlgMenuId);
					}

					//-----------------------------
					// Add our "Windows..." dialog:
					//-----------------------------
					pMenuPopup->InsertItem(CMFCToolBarMenuButton(m_uiWindowsDlgMenuId, NULL, -1, m_strWindowsDlgMenuText));
				}
			}
		}
	}

	if (pMenuPopup != NULL && pMenuPopup->m_bShown)
	{
		return TRUE;
	}

	return OnShowPopupMenu(pMenuPopup);
}

void CMDIFrameWndEx::OnClosePopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (afxGlobalData.IsAccessibilitySupport() && pMenuPopup != NULL)
	{
		CMFCPopupMenu* pPopupParent = pMenuPopup->GetParentPopupMenu();
		CMFCToolBarMenuButton* pParentButton  = pMenuPopup->GetParentButton();

		if (pMenuPopup->IsEscClose() || pPopupParent != NULL || pParentButton == NULL)
		{
			::NotifyWinEvent(EVENT_SYSTEM_MENUPOPUPEND, pMenuPopup->GetSafeHwnd(), OBJID_WINDOW, CHILDID_SELF);
		}
		else
		{
			::NotifyWinEvent(EVENT_SYSTEM_MENUEND, pMenuPopup->GetSafeHwnd(), OBJID_WINDOW, CHILDID_SELF);
		}
	}

	if (CMFCPopupMenu::m_pActivePopupMenu == pMenuPopup)
	{
		CMFCPopupMenu::m_pActivePopupMenu = NULL;
	}

	m_dockManager.OnClosePopupMenu();
}

BOOL CMDIFrameWndEx::OnDrawMenuImage(CDC* pDC, const CMFCToolBarMenuButton* pMenuButton, const CRect& rectImage)
{
	ASSERT_VALID(this);

	if (m_Impl.m_pRibbonBar != NULL)
	{
		ASSERT_VALID(m_Impl.m_pRibbonBar);
		return m_Impl.m_pRibbonBar->DrawMenuImage(pDC, pMenuButton, rectImage);
	}

	return FALSE;
}

LRESULT CMDIFrameWndEx::OnToolbarCreateNew(WPARAM,LPARAM lp)
{
	ENSURE(lp != NULL);
	return(LRESULT) m_Impl.CreateNewToolBar((LPCTSTR) lp);
}

LRESULT CMDIFrameWndEx::OnToolbarDelete(WPARAM,LPARAM lp)
{
	CMFCToolBar* pToolbar = (CMFCToolBar*) lp;
	ASSERT_VALID(pToolbar);

	return(LRESULT) m_Impl.DeleteToolBar(pToolbar);
}

void CMDIFrameWndEx::HtmlHelp(DWORD_PTR dwData, UINT nCmd)
{
	if (dwData > 0 || !m_bContextHelp)
	{
		CFrameWnd::HtmlHelp(dwData, nCmd);
	}
	else
	{
		OnContextHelp();
	}
}

void CMDIFrameWndEx::WinHelp(DWORD dwData, UINT nCmd)
{
	if (dwData > 0 || !m_bContextHelp)
	{
		CMDIFrameWnd::WinHelp(dwData, nCmd);
	}
	else
	{
		OnContextHelp();
	}
}

void CMDIFrameWndEx::OnContextHelp()
{
	m_bContextHelp = TRUE;

	if (!m_bHelpMode && CanEnterHelpMode())
	{
		CMFCToolBar::SetHelpMode();
	}

	CMDIFrameWnd::OnContextHelp();

	if (!m_bHelpMode)
	{
		CMFCToolBar::SetHelpMode(FALSE);
	}

	m_bContextHelp = FALSE;
}

BOOL CMDIFrameWndEx::DockPaneLeftOf(CPane* pBar, CPane* pLeftOf)
{
	return m_dockManager.DockPaneLeftOf(pBar, pLeftOf);
}

void CMDIFrameWndEx::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	CMDIFrameWnd::OnActivate(nState, pWndOther, bMinimized);
	switch(nState)
	{
	case WA_CLICKACTIVE:
		UpdateWindow();
		break;

	case WA_INACTIVE:
		if (!CMFCToolBar::IsCustomizeMode())
		{
			m_Impl.DeactivateMenu();
		}
		break;
	}
}

void CMDIFrameWndEx::OnActivateApp(BOOL bActive, DWORD /*dwThreadID*/)
{
	m_dockManager.OnActivateFrame(bActive);
	m_Impl.OnActivateApp(bActive);
}

void CMDIFrameWndEx::EnableWindowsDialog(UINT uiMenuId, LPCTSTR lpszMenuText, BOOL bShowAlways, BOOL bShowHelpButton)
{
	ENSURE(lpszMenuText != NULL);
	ENSURE(uiMenuId != 0);

	m_uiWindowsDlgMenuId = uiMenuId;
	m_strWindowsDlgMenuText = lpszMenuText;
	m_bShowWindowsDlgAlways = bShowAlways;
	m_bShowWindowsDlgHelpButton = bShowHelpButton;
}

void CMDIFrameWndEx::EnableWindowsDialog(UINT uiMenuId, UINT uiMenuTextResId, BOOL bShowAlways, BOOL bShowHelpButton)
{
	CString strMenuText;
	ENSURE(strMenuText.LoadString(uiMenuTextResId));

	EnableWindowsDialog(uiMenuId, strMenuText, bShowAlways, bShowHelpButton);
}

void CMDIFrameWndEx::ShowWindowsDialog()
{
	CMFCWindowsManagerDialog dlg(this, m_bShowWindowsDlgHelpButton);
	dlg.DoModal();
}

COleClientItem* CMDIFrameWndEx::GetInPlaceActiveItem()
{
	CFrameWnd* pActiveFrame = GetActiveFrame();
	if (pActiveFrame == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pActiveFrame);

	CView* pView = pActiveFrame->GetActiveView();
	if (pView == NULL || pView->IsKindOf (RUNTIME_CLASS (CPreviewViewEx)))
	{
		return NULL;
	}

	ASSERT_VALID(pView);

	COleDocument* pDoc = DYNAMIC_DOWNCAST(COleDocument, pView->GetDocument());
	if (pDoc == NULL)
	{
		return NULL;
	}

	ASSERT_VALID(pDoc);
	return pDoc->GetInPlaceActiveItem(pView);
}

void CMDIFrameWndEx::OnUpdateFrameMenu(HMENU hMenuAlt)
{
	CMDIFrameWnd::OnUpdateFrameMenu(hMenuAlt);

	BOOL bIsMenuBar = m_Impl.m_pMenuBar != NULL && (m_Impl.m_pMenuBar->GetStyle() & WS_VISIBLE);

	BOOL bIsRibbon = FALSE;

	if (m_Impl.m_pRibbonBar != NULL && (m_Impl.m_pRibbonBar->GetStyle() & WS_VISIBLE))
	{
		bIsRibbon = TRUE;
	}

	if (bIsMenuBar || bIsRibbon)
	{
		COleClientItem* pActiveItem = GetInPlaceActiveItem();
		if (pActiveItem == NULL || pActiveItem->GetInPlaceWindow() == NULL)
		{
			SetMenu(NULL);
		}
		else
		{
			SetMenu(CMenu::FromHandle(hMenuAlt));
		}
	}
}

void CMDIFrameWndEx::OnDestroy()
{
	if (m_hAccelTable != NULL)
	{
		::DestroyAcceleratorTable(m_hAccelTable);
		m_hAccelTable = NULL;
	}

	m_dockManager.m_bEnableAdjustLayout = FALSE;

	CList<HWND, HWND> lstChildren;

	for (int i = 0; i < 2; i++)
	{
		CWnd* pNextWnd = GetTopWindow();
		while (pNextWnd != NULL)
		{
			if (m_wndClientArea.m_hWnd != pNextWnd->m_hWnd)
			{
				const BOOL bIsPaneDivider = pNextWnd->IsKindOf(RUNTIME_CLASS(CPaneDivider));

				if ((i == 0 && !bIsPaneDivider) || (i == 1 && bIsPaneDivider))
				{
					lstChildren.AddTail(pNextWnd->m_hWnd);
				}
			}

			pNextWnd = pNextWnd->GetNextWindow();
		}
	}

	for (POSITION pos = lstChildren.GetHeadPosition(); pos != NULL;)
	{
		HWND hwndNext = lstChildren.GetNext(pos);
		if (IsWindow(hwndNext) && ::GetParent(hwndNext) == m_hWnd)
		{
			::DestroyWindow(hwndNext);
		}
	}

	CFrameImpl::RemoveFrame(this);
	CMDIFrameWnd::OnDestroy();
}

void CMDIFrameWndEx::EnableMDITabbedGroups(BOOL bEnable, const CMDITabInfo& params)
{
	m_wndClientArea.EnableMDITabbedGroups(bEnable, params);
}

void CMDIFrameWndEx::EnableMDITabs(BOOL bEnable/* = TRUE*/, BOOL bIcons/* = TRUE*/, CMFCTabCtrl::Location tabLocation /* = CMFCTabCtrl::LOCATION_BOTTOM*/,
	BOOL bTabCloseButton/* = FALSE*/, CMFCTabCtrl::Style style/* = CMFCTabCtrl::STYLE_3D_SCROLLED*/, BOOL bTabCustomTooltips/* = FALSE*/, BOOL bActiveTabCloseButton/* = FALSE*/)
{
	ASSERT(style == CMFCTabCtrl::STYLE_3D_SCROLLED || style == CMFCTabCtrl::STYLE_3D_ONENOTE || style == CMFCTabCtrl::STYLE_3D_VS2005 ||
		style == CMFCTabCtrl::STYLE_3D_ROUNDED || style == CMFCTabCtrl::STYLE_3D_ROUNDED_SCROLL);

	CMDITabInfo params;
	params.m_style = style;
	params.m_tabLocation = tabLocation;
	params.m_bTabIcons = bIcons;
	params.m_bTabCloseButton = bTabCloseButton;
	params.m_bTabCustomTooltips = bTabCustomTooltips;
	params.m_bActiveTabCloseButton = bActiveTabCloseButton;

	m_wndClientArea.EnableMDITabs(bEnable, params);
}

void CMDIFrameWndEx::OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState)
{
	ASSERT_VALID(this);

	if (m_wndClientArea.DoesMDITabExist())
	{
		m_wndClientArea.m_bTabIsVisible = !bPreview;
		((CWnd&)m_wndClientArea.GetMDITabs()).ShowWindow(bPreview ? SW_HIDE : SW_SHOWNOACTIVATE);
	}

	m_dockManager.SetPrintPreviewMode(bPreview, pState);

	DWORD dwSavedState = pState->dwStates;
	CMDIFrameWnd::OnSetPreviewMode(bPreview, pState);
	pState->dwStates = dwSavedState;

	AdjustDockingLayout();
	RecalcLayout();

	if (m_Impl.m_pRibbonBar != NULL && m_Impl.m_pRibbonBar->IsReplaceFrameCaption())
	{
		PostMessage(AFX_WM_POSTSETPREVIEWFRAME, bPreview);
	}
}

BOOL CMDIFrameWndEx::OnShowPanes(BOOL bShow)
{
	ASSERT_VALID(this);

	BOOL bResult = m_dockManager.ShowPanes(bShow);
	AdjustDockingLayout();

	return bResult;
}

void CMDIFrameWndEx::AddDockSite()
{
	ASSERT_VALID(this);
}

BOOL CMDIFrameWndEx::AddPane(CBasePane* pControlBar, BOOL bTail)
{
	ASSERT_VALID(this);

	CMFCRibbonBar* pRibbonBar = DYNAMIC_DOWNCAST(CMFCRibbonBar, pControlBar);
	if (pRibbonBar != NULL)
	{
		ASSERT_VALID(pRibbonBar);

		if (pRibbonBar->IsMainRibbonBar())
		{
			m_Impl.m_pRibbonBar = pRibbonBar;
		}
	}

	CMFCRibbonStatusBar* pRibbonStatusBar = DYNAMIC_DOWNCAST(CMFCRibbonStatusBar, pControlBar);
	if (pRibbonStatusBar != NULL)
	{
		ASSERT_VALID(pRibbonStatusBar);
		m_Impl.m_pRibbonStatusBar = pRibbonStatusBar;
	}

	return m_dockManager.AddPane(pControlBar, bTail);
}

BOOL CMDIFrameWndEx::InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter)
{
	ASSERT_VALID(this);
	return m_dockManager.InsertPane(pControlBar, pTarget, bAfter);
}

void CMDIFrameWndEx::RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement)
{
	ASSERT_VALID(this);
	m_dockManager.RemovePaneFromDockManager(pControlBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
}

void CMDIFrameWndEx::DockPane(CBasePane* pBar, UINT nDockBarID, LPCRECT lpRect)
{
	ASSERT_VALID(this);
	m_dockManager.DockPane(pBar, nDockBarID, lpRect);
}

CBasePane* CMDIFrameWndEx::GetPane(UINT nID)
{
	ASSERT_VALID(this);

	CBasePane* pBar = m_dockManager.FindPaneByID(nID, TRUE);
	return pBar;
}

void CMDIFrameWndEx::ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	pBar->ShowPane(bShow, bDelay, bActivate);
}

CBasePane* CMDIFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
}

CBasePane* CMDIFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, dwAlignment, pRTCBarType);
}

BOOL CMDIFrameWndEx::IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const
{
	ASSERT_VALID(this);
	return m_dockManager.IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
}

void CMDIFrameWndEx::AdjustDockingLayout(HDWP hdwp)
{
	ASSERT_VALID(this);

	if (m_dockManager.IsInAdjustLayout())
	{
		return;
	}

	m_dockManager.AdjustDockingLayout(hdwp);
	AdjustClientArea();

	if (m_dockManager.IsOLEContainerMode())
	{
		RecalcLayout();
	}
}

void CMDIFrameWndEx::AdjustClientArea()
{
	CRect rectClientAreaBounds = m_dockManager.GetClientAreaBounds();

	rectClientAreaBounds.left += m_rectBorder.left;
	rectClientAreaBounds.top  += m_rectBorder.top;
	rectClientAreaBounds.right -= m_rectBorder.right;
	rectClientAreaBounds.bottom -= m_rectBorder.bottom;

	if (m_wndClientArea.GetSafeHwnd() != NULL)
	{
		m_wndClientArea.CalcWindowRect(rectClientAreaBounds, 0);
	}
}

BOOL CMDIFrameWndEx::OnMoveMiniFrame(CWnd* pFrame)
{
	ASSERT_VALID(this);
	return m_dockManager.OnMoveMiniFrame(pFrame);
}

BOOL CMDIFrameWndEx::EnableDocking(DWORD dwDockStyle)
{
	return m_dockManager.EnableDocking(dwDockStyle);
}

BOOL CMDIFrameWndEx::EnableAutoHidePanes(DWORD dwDockStyle)
{
	return m_dockManager.EnableAutoHidePanes(dwDockStyle);
}

void CMDIFrameWndEx::RecalcLayout(BOOL bNotify)
{
	if (m_bInRecalcLayout)
		return;

	m_bInRecalcLayout = TRUE;

	BOOL bWasOleInPlaceActive = m_Impl.m_bIsOleInPlaceActive;
	m_Impl.m_bIsOleInPlaceActive = FALSE;

	COleClientItem* pActiveItem = GetInPlaceActiveItem();

	if (pActiveItem != NULL && pActiveItem->m_pInPlaceFrame != NULL && pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		m_Impl.m_bIsOleInPlaceActive = TRUE;
		m_Impl.m_bHadCaption = (GetStyle() & WS_CAPTION) != 0;
	}

	if (!m_bIsMinimized)
	{
		CView* pView = GetActiveView();

		if (m_dockManager.IsPrintPreviewValid() || m_dockManager.IsOLEContainerMode())
		{
			if (pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPreviewViewEx)))
			{

				m_dockManager.RecalcLayout(bNotify);
				CRect rectClient = m_dockManager.GetClientAreaBounds();
				pView->SetWindowPos(NULL, rectClient.left, rectClient.top, rectClient.Width(), rectClient.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);
			}
			else
			{
				if (bNotify && m_dockManager.IsOLEContainerMode())
				{
					ActiveItemRecalcLayout();
				}
				else
				{
					m_bInRecalcLayout = FALSE;
					CMDIFrameWnd::RecalcLayout(bNotify);

					AdjustClientArea();
				}
			}
		}
		else
		{
			m_dockManager.RecalcLayout(bNotify);
			AdjustClientArea();
		}
	}

	m_bInRecalcLayout = FALSE;

	if (bWasOleInPlaceActive != m_Impl.m_bIsOleInPlaceActive)
	{
		if (!m_Impl.m_bHadCaption)
		{
			if (m_Impl.m_bIsOleInPlaceActive)
			{
				ModifyStyle(0, WS_CAPTION);
			}
			else
			{
				ModifyStyle(WS_CAPTION, 0);
			}
		}

		m_Impl.OnChangeVisualManager();
		SetWindowPos(NULL, -1, -1, -1, -1, SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
	}
}

void CMDIFrameWndEx::ActiveItemRecalcLayout()
{
	COleClientItem* pActiveItem = GetInPlaceActiveItem();
	if (pActiveItem != NULL)
	{
		if (pActiveItem->m_pInPlaceFrame != NULL)
		{
			CRect rectBounds = m_dockManager.GetClientAreaBounds();
			pActiveItem->m_pInPlaceFrame->OnRecalcLayout();
		}

		CView* pActiveView = pActiveItem->GetActiveView();
		if (pActiveView != NULL)
		{
			CMDIChildWndEx* pFrame = (CMDIChildWndEx*) pActiveView->GetParentFrame();

			if (pFrame != NULL && pFrame->m_bActivating)
			{
				pActiveItem->m_pInPlaceFrame->OnRecalcLayout();
			}
		}
	}
	AdjustClientArea();
}

BOOL CMDIFrameWndEx::NegotiateBorderSpace( UINT nBorderCmd, LPRECT lpRectBorder )
{
	CRect border, request;

	switch(nBorderCmd)
	{
	case borderGet:
		{
			CFrameWnd::NegotiateBorderSpace(nBorderCmd, lpRectBorder);
			m_dockManager.AdjustDockingLayout();
			CRect rectBounds = m_dockManager.GetClientAreaBounds();
			ENSURE(lpRectBorder != NULL);

			*lpRectBorder = rectBounds;
			break;
		}
	case borderRequest:
		return TRUE;

	case borderSet:
		return CFrameWnd::NegotiateBorderSpace(nBorderCmd, lpRectBorder);

	default:
		ASSERT(FALSE);  // invalid CFrameWnd::BorderCmd
	}

	return TRUE;
}

int CMDIFrameWndEx::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_dockManager.Create(this);

	m_Impl.m_bHasBorder = (lpCreateStruct->style & WS_BORDER) != NULL;

	CFrameImpl::AddFrame(this);
	OnChangeVisualManager(0, 0);

	return 0;
}

LRESULT CMDIFrameWndEx::OnExitSizeMove(WPARAM, LPARAM)
{
	RecalcLayout ();
	m_dockManager.FixupVirtualRects();
	return 0;
}

void CMDIFrameWndEx::OnUpdatePaneMenu(CCmdUI* pCmdUI)
{
	CBasePane* pBar = GetPane(pCmdUI->m_nID);
	if (pBar != NULL)
	{
		pCmdUI->SetCheck(pBar->IsWindowVisible());
		return;
	}

	pCmdUI->ContinueRouting();
}

BOOL CMDIFrameWndEx::OnPaneCheck(UINT nID)
{
	ASSERT_VALID(this);

	CBasePane* pBar = GetPane(nID);
	if (pBar != NULL)
	{
		ShowPane(pBar, !pBar->IsWindowVisible(), FALSE, FALSE);
		return TRUE;
	}

	return FALSE;
}


LRESULT CMDIFrameWndEx::OnIdleUpdateCmdUI(WPARAM, LPARAM)
{
	m_dockManager.SendMessageToMiniFrames(WM_IDLEUPDATECMDUI);
	return 0L;
}

void CMDIFrameWndEx::OnSize(UINT nType, int cx, int cy)
{
	if (m_bClosing)
	{
		CMDIFrameWnd::OnSize(nType, cx, cy);
		return;
	}

	m_bIsMinimized = (nType == SIZE_MINIMIZED);

	if (m_Impl.m_pRibbonBar || m_Impl.IsOwnerDrawCaption())
	{
		CRect rectWindow;
		GetWindowRect(rectWindow);

		WINDOWPOS wndpos;
		wndpos.flags = SWP_FRAMECHANGED;
		wndpos.x     = rectWindow.left;
		wndpos.y     = rectWindow.top;
		wndpos.cx    = rectWindow.Width();
		wndpos.cy    = rectWindow.Height();

		m_Impl.OnWindowPosChanging(&wndpos);
	}

	m_dockManager.OnActivateFrame(!m_bIsMinimized);

	if (!m_bIsMinimized && nType != SIZE_MAXIMIZED && !m_bWasMaximized)
	{
		m_dockManager.m_bSizeFrame = TRUE;
		AdjustDockingLayout();
		CMDIFrameWnd::OnSize(nType, cx, cy);
		m_dockManager.m_bSizeFrame = FALSE;
		BOOL bParam = FALSE;
		SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &bParam, 0);
		if (!bParam)
		{
			RecalcLayout();
		}

		m_Impl.UpdateCaption();
		return;
	}

	CMDIFrameWnd::OnSize(nType, cx, cy);

	if (nType == SIZE_MAXIMIZED ||(nType == SIZE_RESTORED && m_bWasMaximized))
	{
		RecalcLayout();
	}

	m_bWasMaximized = (nType == SIZE_MAXIMIZED);
	m_Impl.UpdateCaption();
}

void CMDIFrameWndEx::OnWindowNew()
{
	CMDIChildWnd* pActiveChild = MDIGetActive();
	if (pActiveChild == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	ASSERT_VALID(pActiveChild);

	BOOL bIsZoomed = FALSE;

	if (pActiveChild->IsZoomed())
	{
		pActiveChild->ShowWindow(SW_RESTORE);
		bIsZoomed = TRUE;
	}

	CMDIFrameWnd::OnWindowNew();

	pActiveChild->RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE);

	if (bIsZoomed)
	{
		pActiveChild = MDIGetActive();
		if (pActiveChild != NULL)
		{
			pActiveChild->ShowWindow(SW_MAXIMIZE);
		}
	}
}

void CMDIFrameWndEx::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
	if (IsFullScreen())
	{
		m_Impl.m_FullScreenMgr.OnGetMinMaxInfo(lpMMI);
	}
	else
	{
		m_Impl.OnGetMinMaxInfo(lpMMI);
		CFrameWnd::OnGetMinMaxInfo(lpMMI);
	}
}

CMDIChildWndEx* CMDIFrameWndEx::CreateDocumentWindow(LPCTSTR /*lpcszDocName*/, CObject* /*pObj*/)
{
	ASSERT(FALSE);
	TRACE0("If you use save/load state for MDI tabs, you must override this method in a derived class!\n");
	return NULL;
}

CMDIChildWndEx* CMDIFrameWndEx::CreateNewWindow(LPCTSTR lpcszDocName, CObject* /*pObj*/)
{
	TRACE0("If you use save/load state for MDI tabs, you should override this method in a derived class!\n");

	if (AreMDITabs())
	{
		OnWindowNew();
		return DYNAMIC_DOWNCAST(CMDIChildWndEx, MDIGetActive());
	}

	CDocument* pDoc = AfxGetApp()->OpenDocumentFile(lpcszDocName);
	if (pDoc == NULL)
	{
		return NULL;
	}

	POSITION pos = pDoc->GetFirstViewPosition();
	if (pos == NULL)
	{
		ASSERT(FALSE);
		return NULL;
	}

	CView* pView = pDoc->GetNextView(pos);
	ASSERT_VALID(pView);

	return DYNAMIC_DOWNCAST(CMDIChildWndEx, pView->GetParentFrame());
}

BOOL CMDIFrameWndEx::LoadMDIState(LPCTSTR lpszProfileName)
{
	return m_wndClientArea.LoadState(lpszProfileName, m_nFrameID);
}

BOOL CMDIFrameWndEx::SaveMDIState(LPCTSTR lpszProfileName)
{
	return m_wndClientArea.SaveState(lpszProfileName, m_nFrameID);
}

void CMDIFrameWndEx::OnContextMenu(CWnd* pWnd, CPoint point)
{
	if (m_wndClientArea.GetMDITabs().GetSafeHwnd() == NULL)
	{
		Default();
		return;
	}

	if (CMFCPopupMenu::GetActiveMenu() != NULL)
	{
		return;
	}

	if ((GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0) // Left mouse button is pressed
	{
		return;
	}

	if (pWnd->GetSafeHwnd() == m_wndClientArea.GetSafeHwnd())
	{
		CWnd* pWndCur = WindowFromPoint(point);

		if (IsMemberOfMDITabGroup(pWndCur))
		{
			CMFCTabCtrl* pWndTab = DYNAMIC_DOWNCAST(CMFCTabCtrl, pWndCur);
			if (pWndTab != NULL)
			{
				CPoint ptTab = point;
				pWndTab->ScreenToClient(&ptTab);

				const int nTab = pWndTab->GetTabFromPoint(ptTab);

				if (nTab >= 0)
				{
					pWndTab->SetActiveTab(nTab);
					OnShowMDITabContextMenu(point, GetMDITabsContextMenuAllowedItems(), FALSE);
				}
			}
		}
		else if ((CMFCPopupMenu::GetActiveMenu() == NULL) && (pWndCur == pWnd))
		{
			if (SendMessage(AFX_WM_TOOLBARMENU, (WPARAM) GetSafeHwnd(), MAKELPARAM(point.x, point.y)))
			{
				m_dockManager.OnPaneContextMenu(point);
			}
		}
	}
	else if (pWnd->GetSafeHwnd() == m_wndClientArea.GetMDITabs().GetSafeHwnd())
	{
		CMFCTabCtrl& wndTab = (CMFCTabCtrl&)(*pWnd);

		CRect rectTabs;
		wndTab.GetTabsRect(rectTabs);

		CPoint ptTab = point;
		wndTab.ScreenToClient(&ptTab);

		const int nTab = wndTab.GetTabFromPoint(ptTab);

		if (nTab >= 0)
		{
			wndTab.SetActiveTab(nTab);
			OnShowMDITabContextMenu(point, GetMDITabsContextMenuAllowedItems(), FALSE);
		}
	}
	else
	{
		Default();
	}
}

BOOL CMDIFrameWndEx::OnShowPopupMenu(CMFCPopupMenu* pMenuPopup)
{
	if (afxGlobalData.IsAccessibilitySupport() && pMenuPopup != NULL)
	{
		::NotifyWinEvent(EVENT_SYSTEM_MENUPOPUPSTART, pMenuPopup->GetSafeHwnd(), OBJID_WINDOW , CHILDID_SELF);
	}

	return TRUE;
}

LRESULT CMDIFrameWndEx::OnToolbarContextMenu(WPARAM,LPARAM)
{
	return 1l;
}

BOOL CMDIFrameWndEx::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (CMDIFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
	{
		return TRUE;
	}

	return m_dockManager.ProcessPaneContextMenuCommand(nID, nCode, pExtra, pHandlerInfo);
}

void CMDIFrameWndEx::OnNcPaint()
{
	if (!m_Impl.OnNcPaint())
	{
		Default();
	}
}

LRESULT CMDIFrameWndEx::OnSetText(WPARAM, LPARAM lParam)
{
	LRESULT lRes = Default();

	m_Impl.OnSetText((LPCTSTR)lParam);
	return lRes;
}

BOOL CMDIFrameWndEx::OnNcActivate(BOOL bActive)
{
	if (m_Impl.OnNcActivate(bActive))
	{
		return TRUE;
	}

	return CMDIFrameWnd::OnNcActivate(bActive);
}

void CMDIFrameWndEx::OnNcMouseMove(UINT nHitTest, CPoint point)
{
	m_Impl.OnNcMouseMove(nHitTest, point);
	CMDIFrameWnd::OnNcMouseMove(nHitTest, point);
}

LRESULT CMDIFrameWndEx::OnNcHitTest(CPoint point)
{
	UINT nHit = m_Impl.OnNcHitTest(point);
	if (nHit != HTNOWHERE)
	{
		return nHit;
	}

	return CMDIFrameWnd::OnNcHitTest(point);
}

LRESULT CMDIFrameWndEx::OnChangeVisualManager(WPARAM, LPARAM)
{
	m_Impl.OnChangeVisualManager();
	return 0;
}

void CMDIFrameWndEx::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp)
{
	if (!m_Impl.OnNcCalcSize(bCalcValidRects, lpncsp))
	{
		CMDIFrameWnd::OnNcCalcSize(bCalcValidRects, lpncsp);
	}
}

void CMDIFrameWndEx::OnLButtonUp(UINT nFlags, CPoint point)
{
	m_Impl.OnLButtonUp(point);
	CMDIFrameWnd::OnLButtonUp(nFlags, point);
}

void CMDIFrameWndEx::OnMouseMove(UINT nFlags, CPoint point)
{
	m_Impl.OnMouseMove(point);
	CMDIFrameWnd::OnMouseMove(nFlags, point);
}

void CMDIFrameWndEx::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_Impl.OnLButtonDown(point);
	CMDIFrameWnd::OnLButtonDown(nFlags, point);
}

LRESULT CMDIFrameWndEx::OnPostPreviewFrame(WPARAM, LPARAM)
{
	return 0;
}

CMDIChildWndEx* CMDIFrameWndEx::ControlBarToTabbedDocument(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	CMDIChildWndEx* pFrame = new CMDIChildWndEx;
	ASSERT_VALID(pFrame);

	pBar->m_bWasFloatingBeforeTabbed = pBar->IsFloating();

	CString strName;
	pBar->GetWindowText(strName);

	if (!pFrame->Create(
		AfxRegisterWndClass(CS_DBLCLKS, 0, (HBRUSH)(COLOR_BTNFACE + 1), pBar->GetIcon(FALSE)),
		strName, WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE, rectDefault, this))
	{
		return NULL;
	}

	pFrame->SetTitle(strName);
	pFrame->SetWindowText(strName);
	pFrame->AddTabbedPane(pBar);

	return pFrame;
}

BOOL CMDIFrameWndEx::TabbedDocumentToControlBar(CMDIChildWndEx* pMDIChildWnd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pMDIChildWnd);

	if (!pMDIChildWnd->IsTabbedPane())
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, pMDIChildWnd->GetTabbedPane());
	if (pBar != NULL)
	{
		if (pBar->m_bWasFloatingBeforeTabbed)
		{
			pBar->SetParent(this);
			pBar->SetMDITabbed(FALSE);
			pBar->FloatPane(pBar->m_recentDockInfo.m_rectRecentFloatingRect, DM_DBL_CLICK);
		}
		else
		{
			pBar->ShowWindow(SW_HIDE);
			pBar->SetParent(this);
			pBar->SetMDITabbed(FALSE);
			pBar->DockToRecentPos();
		}
	}

	pMDIChildWnd->SendMessage(WM_CLOSE);
	return TRUE;
}

void CMDIFrameWndEx::UpdateMDITabbedBarsIcons()
{
	ASSERT_VALID(this);

	//-----------------------------------
	// Set MDI tabbed control bars icons:
	//-----------------------------------
	HWND hwndMDIChild = ::GetWindow(m_hWndMDIClient, GW_CHILD);

	while (hwndMDIChild != NULL)
	{
		CMDIChildWndEx* pMDIChildFrame = DYNAMIC_DOWNCAST(CMDIChildWndEx, CWnd::FromHandle(hwndMDIChild));

		if (pMDIChildFrame != NULL && pMDIChildFrame->IsTabbedPane())
		{
			CDockablePane* pBar = pMDIChildFrame->GetTabbedPane();
			ASSERT_VALID(pBar);

#pragma warning(disable : 4311)
			SetClassLongPtr(hwndMDIChild, GCLP_HICONSM, (long) pBar->GetIcon(FALSE));
#pragma warning(default : 4311)
		}

		hwndMDIChild = ::GetWindow(hwndMDIChild, GW_HWNDNEXT);
	}
}

void CMDIFrameWndEx::RegisterAllMDIChildrenWithTaskbar(BOOL bRegister)
{
	ASSERT_VALID(this);

	HWND hwndMDIChild = ::GetWindow(m_hWndMDIClient, GW_CHILD);

	while (hwndMDIChild != NULL)
	{
		CMDIChildWndEx* pMDIChildFrame = DYNAMIC_DOWNCAST(CMDIChildWndEx, CWnd::FromHandle(hwndMDIChild));

		if (pMDIChildFrame != NULL)
		{
			if (bRegister)
			{
				// add at the end
				pMDIChildFrame->RegisterTaskbarTab(NULL);
			}
			else
			{
				pMDIChildFrame->UnregisterTaskbarTab(FALSE);
			}
		}

		hwndMDIChild = ::GetWindow(hwndMDIChild, GW_HWNDNEXT);
	}

	if (bRegister)
	{
		// if we are registering we need to set clip for the active child, which is done internally in InvalidateIconicBitmaps
		BOOL bMax = FALSE;
		CMDIChildWndEx* pMDIChildFrame = DYNAMIC_DOWNCAST(CMDIChildWndEx, MDIGetActive(&bMax));
		if (pMDIChildFrame != NULL)
		{
			pMDIChildFrame->InvalidateIconicBitmaps();
		}
	}
	else
	{
		// if we're unregistering we need to reset clip rect on the main frame
		ITaskbarList3* pTaskbarList3 = afxGlobalData.GetITaskbarList3();
		if (pTaskbarList3 != NULL)
		{
			pTaskbarList3->SetThumbnailClip(GetSafeHwnd(), NULL);
		}
	}
}

int CMDIFrameWndEx::GetRegisteredWithTaskBarMDIChildCount()
{
	ASSERT_VALID(this);

	int nCount = 0;
	HWND hwndMDIChild = ::GetWindow(m_hWndMDIClient, GW_CHILD);

	while (hwndMDIChild != NULL)
	{
		CMDIChildWndEx* pMDIChildFrame = DYNAMIC_DOWNCAST(CMDIChildWndEx, CWnd::FromHandle(hwndMDIChild));

		if (pMDIChildFrame != NULL && pMDIChildFrame->IsRegisteredWithTaskbarTabs())
		{
			nCount++;	
		}

		hwndMDIChild = ::GetWindow(hwndMDIChild, GW_HWNDNEXT);
	}

	return nCount;
}

BOOL CMDIFrameWndEx::OnShowMDITabContextMenu(CPoint point, DWORD dwAllowedItems, BOOL /*bTabDrop*/)
{
	if ((dwAllowedItems & AFX_MDI_CAN_BE_DOCKED) == 0)
	{
		return FALSE;
	}

	if (afxContextMenuManager == NULL)
	{
		return FALSE;
	}

	const UINT idTabbed = (UINT) -106;

	CMenu menu;
	menu.CreatePopupMenu();

	CString strItem;
	ENSURE(strItem.LoadString(IDS_AFXBARRES_TABBED));

	menu.AppendMenu(MF_STRING, idTabbed, strItem);
	menu.CheckMenuItem(idTabbed, MF_CHECKED);

	HWND hwndThis = GetSafeHwnd();

	int nMenuResult = afxContextMenuManager->TrackPopupMenu(menu, point.x, point.y, this);

	if (::IsWindow(hwndThis))
	{
		switch(nMenuResult)
		{
		case idTabbed:
			{
				CMDIChildWndEx* pMDIChild = DYNAMIC_DOWNCAST(CMDIChildWndEx, MDIGetActive());
				if (pMDIChild != NULL)
				{
					TabbedDocumentToControlBar(pMDIChild);
				}
			}
		}
	}

	return TRUE;
}

LRESULT CMDIFrameWndEx::OnDWMCompositionChanged(WPARAM,LPARAM)
{
	m_Impl.OnDWMCompositionChanged();
	return 0;
}

LRESULT CMDIFrameWndEx::OnPowerBroadcast(WPARAM wp, LPARAM)
{
	LRESULT lres = Default();

	if (wp == PBT_APMRESUMESUSPEND)
	{
		afxGlobalData.Resume();
	}

	return lres;
}

void CMDIFrameWndEx::OnSysColorChange()
{
	CMDIFrameWnd::OnSysColorChange();
	m_Impl.OnChangeVisualManager();
	SetWindowRgn(NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmenuhash.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxtoolbar.h"
#include "afxmenuhash.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CMenuHash afxMenuHash;

// Construction/Destruction
CMenuHash::CMenuHash()
{
	m_bIsActive = FALSE;
}

CMenuHash::~CMenuHash()
{
}

BOOL CMenuHash::SaveMenuBar(HMENU hMenu, CMFCToolBar* pBar)
{
	ASSERT_VALID(pBar);

	if (pBar->GetCount() == 0)
	{
		return FALSE;
	}

	HANDLE hFileOld = NULL;
	if (m_StoredMenues.Lookup(hMenu, hFileOld))
	{
		// Free unused handle:
		::CloseHandle(hFileOld);
	}

	// Get the temp path...
	CString strTempPath;
	GetTempPath(MAX_PATH, strTempPath.GetBuffer(MAX_PATH));
	strTempPath.ReleaseBuffer();

	// Create a temporary file for the output....
	CString strTempName;
	GetTempFileName(strTempPath, _T("AFX"), 0, strTempName.GetBuffer(MAX_PATH));
	strTempName.ReleaseBuffer();

	HANDLE hFile = ::CreateFile(strTempName, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("Can't create temporary file!\n"));
		return FALSE;
	}

	try
	{
		// Write a menubar context to file:
		CFile file(hFile);
		CArchive ar(&file, CArchive::store);

		m_bIsActive = TRUE;

		pBar->Serialize(ar);
		ar.Flush();

		m_bIsActive = FALSE;
	}
	catch(CArchiveException* pEx)
	{
		TRACE(_T("Archive exception in CMenuHash::SaveMenuBar()!\n"));
		pEx->Delete();
		::CloseHandle(hFile);

		m_bIsActive = FALSE;
		return FALSE;
	}
	catch(CMemoryException* pEx)
	{
		TRACE(_T("Memory exception in CMenuHash::SaveMenuBar()!\n"));
		pEx->Delete();
		::CloseHandle(hFile);

		m_bIsActive = FALSE;
		return FALSE;
	}
	catch(CFileException* pEx)
	{
		TRACE(_T("File exception in CMenuHash::SaveMenuBar()!\n"));
		pEx->Delete();
		::CloseHandle(hFile);

		m_bIsActive = FALSE;
		return FALSE;
	}

	m_StoredMenues.SetAt(hMenu, hFile);
	return TRUE;
}

BOOL CMenuHash::LoadMenuBar(HMENU hMenu, CMFCToolBar* pBar)
{
	ASSERT_VALID(pBar);
	ENSURE(hMenu != NULL);

	// Find a file handler associated with the menu:
	HANDLE hFile;
	if (!m_StoredMenues.Lookup(hMenu, hFile))
	{
		return FALSE;
	}

	// Rewind the file:
	if (::SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
	{
		TRACE(_T("CMenuHash::LoadMenuBar(). Invalid file handle\n"));
		return FALSE;
	}

	try
	{
		CFile file(hFile);
		CArchive ar(&file, CArchive::load);

		m_bIsActive = TRUE;

		pBar->Serialize(ar);

		m_bIsActive = FALSE;
	}
	catch(CArchiveException* pEx)
	{
		TRACE(_T("Archive exception in CMenuHash::LoadMenuBar()!\n"));
		pEx->Delete();

		m_bIsActive = FALSE;
		return FALSE;
	}
	catch(CMemoryException* pEx)
	{
		TRACE(_T("Memory exception in CMenuHash::LoadMenuBar()!\n"));
		pEx->Delete();

		m_bIsActive = FALSE;
		return FALSE;
	}
	catch(CFileException* pEx)
	{
		TRACE(_T("File exception in CMenuHash::LoadMenuBar()!\n"));
		pEx->Delete();

		m_bIsActive = FALSE;
		return FALSE;
	}

	return TRUE;
}

BOOL CMenuHash::RemoveMenu(HMENU hMenu)
{
	HANDLE hFile = NULL;
	if (m_StoredMenues.Lookup(hMenu, hFile))
	{
		// Free unused handle:
		::CloseHandle(hFile);
		m_StoredMenues.RemoveKey(hMenu);
		return TRUE;
	}

	return FALSE;
}

void CMenuHash::CleanUp()
{
	for (POSITION pos = m_StoredMenues.GetStartPosition(); pos != NULL;)
	{
		HMENU hMenu;
		HANDLE hFile;

		m_StoredMenues.GetNextAssoc(pos, hMenu, hFile);
		::CloseHandle(hFile);
	}

	m_StoredMenues.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmenubar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxglobals.h"
#include "afxmenubar.h"
#include "afxtoolbarbutton.h"
#include "afxtoolbarmenubutton.h"
#include "afxtoolbarsystemmenubutton.h"
#include "afxtoolbarmenubuttonsbutton.h"
#include "afxtoolbarcomboboxbutton.h"
#include "afxpopupmenu.h"
#include "afxmenutearoffmanager.h"
#include "afxmenuhash.h"
#include "afxribbonres.h"
#include "afxmdiframewndex.h"
#include "afxframewndex.h"
#include "afxoleipframewndex.h"
#include "afxmultidoctemplateex.h"
#include "afxregpath.h"
#include "afxtoolbarsmenupropertypage.h"
#include "afxwinappex.h"
#include "afxdocksite.h"
#include "afxdockingpanesrow.h"
#include "afxpaneframewnd.h"
#include "afxcustomizebutton.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

class CHelpComboBoxButton : public CMFCToolBarComboBoxButton
{
	DECLARE_SERIAL(CHelpComboBoxButton)

public:
	CHelpComboBoxButton(UINT uiId = 0, int iWidth = 0, LPCTSTR lpszPromt = NULL) : CMFCToolBarComboBoxButton(uiId, -1, CBS_DROPDOWN, iWidth)
	{
		m_strPrompt = lpszPromt == NULL ? _T("") : lpszPromt;
	}

	virtual BOOL IsEditable() const
	{
		return FALSE;
	}

	virtual CString GetPrompt() const
	{
		return m_strPrompt;
	}

	virtual void CopyFrom(const CMFCToolBarButton& s)
	{
		CMFCToolBarComboBoxButton::CopyFrom(s);
		const CHelpComboBoxButton& src = (const CHelpComboBoxButton&) s;

		m_strPrompt = src.m_strPrompt;
	}

	virtual void Serialize(CArchive& ar)
	{
		CMFCToolBarComboBoxButton::Serialize(ar);

		if (ar.IsLoading())
		{
			ar >> m_strPrompt;
		}
		else
		{
			ar << m_strPrompt;
		}
	}

protected:
	CString m_strPrompt;
};

IMPLEMENT_SERIAL(CHelpComboBoxButton, CMFCToolBarComboBoxButton, VERSIONABLE_SCHEMA | 1)

IMPLEMENT_SERIAL(CMFCMenuBar, CMFCToolBar, VERSIONABLE_SCHEMA | 1)

BOOL CMFCMenuBar::m_bShowAllCommands = FALSE;
BOOL CMFCMenuBar::m_bRecentlyUsedMenus = TRUE;
BOOL CMFCMenuBar::m_bShowAllMenusDelay = TRUE;
BOOL CMFCMenuBar::m_bMenuShadows = TRUE;
BOOL CMFCMenuBar::m_bHighlightDisabledItems = FALSE;

static const UINT uiShowAllItemsTimerId = 1;
static const int nShowAllItemsTimerFreq = 5000; // 5 sec

static const CString strMenuProfile = _T("MenuBar");

static const int nAccSystemMenuId = -10;

/////////////////////////////////////////////////////////////////////////////
// CMFCMenuBar

CMFCMenuBar::CMFCMenuBar()
{
	m_bMaximizeMode = FALSE;
	m_hMenu = NULL;
	m_hDefaultMenu = NULL;
	m_hSysMenu = NULL;
	m_hSysIcon = NULL;
	m_uiDefMenuResId = 0;
	m_nSystemButtonsNum = 0;
	m_nSystemButtonsNumSaved = 0;
	m_bHaveButtons = FALSE;
	m_szSystemButton = CSize(0, 0);
	m_bAutoDocMenus = TRUE;
	m_pMenuPage = NULL;
	m_bForceDownArrows = FALSE;
	m_bExclusiveRow = TRUE;
	m_nHelpComboID = 0;
	m_nHelpComboWidth = 0;
	m_pMenuButtonRTC = RUNTIME_CLASS(CMFCToolBarMenuButton);
	m_bClearHashOnClose = FALSE;
}

CMFCMenuBar::~CMFCMenuBar()
{
	if (m_bClearHashOnClose)
	{
		afxMenuHash.RemoveMenu(m_hMenu);
	}

	::DestroyMenu(m_hMenu);
}

//{{AFX_MSG_MAP(CMFCMenuBar)
BEGIN_MESSAGE_MAP(CMFCMenuBar, CMFCToolBar)
	ON_WM_CREATE()
	ON_WM_LBUTTONDOWN()
	ON_WM_SETFOCUS()
	ON_WM_TIMER()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SETTINGCHANGE()
	ON_WM_KILLFOCUS()
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMFCMenuBar message handlers

void CMFCMenuBar::CreateFromMenu(HMENU hMenu, BOOL bDefaultMenu, BOOL bForceUpdate)
{
	ASSERT_VALID(this);
	ENSURE(m_pMenuButtonRTC != NULL);

	if (GetFocus() == this)
	{
		GetParentFrame()->SetFocus();
	}

	if (m_hMenu != hMenu || IsCustomizeMode() || bForceUpdate)
	{
		if (g_pTearOffMenuManager != NULL && m_hMenu != NULL)
		{
			g_pTearOffMenuManager->Reset(m_hMenu);
		}

		afxMenuHash.SaveMenuBar(m_hMenu, this);

		BOOL bMaximizeMode = m_bMaximizeMode;
		m_bMaximizeMode = FALSE;

		m_hMenu = hMenu;
		if (bDefaultMenu)
		{
			m_hDefaultMenu = hMenu;
		}

		DWORD dwOldAlignment = GetCurrentAlignment();

		if (!afxMenuHash.LoadMenuBar(hMenu, this) || bForceUpdate)
		{
			CMenu* pMenu = CMenu::FromHandle(hMenu);
			if (pMenu == NULL)
			{
				return;
			}

			if (g_pTearOffMenuManager != NULL)
			{
				g_pTearOffMenuManager->SetupTearOffMenus(hMenu);
			}

			RemoveAllButtons();

			int iCount = pMenu->GetMenuItemCount();
			for (int i = 0; i < iCount; i ++)
			{
				UINT uiID = pMenu->GetMenuItemID(i);

				CString strText;
				pMenu->GetMenuString(i, strText, MF_BYPOSITION);

				switch (uiID)
				{
				case -1: // Pop-up menu
					{
						CMenu* pPopupMenu = pMenu->GetSubMenu(i);
						ENSURE(pPopupMenu != NULL);

						UINT uiTearOffId = 0;
						if (g_pTearOffMenuManager != NULL)
						{
							uiTearOffId = g_pTearOffMenuManager->Parse(strText);
						}

						CMFCToolBarMenuButton* pButton = (CMFCToolBarMenuButton*) m_pMenuButtonRTC->CreateObject();
						ASSERT_VALID(pButton);

						pButton->Initialize(0, pPopupMenu->GetSafeHmenu(), -1, strText);

						pButton->m_bText = TRUE;
						pButton->m_bImage = FALSE;
						pButton->SetTearOff(uiTearOffId);

						InsertButton(*pButton);

						delete pButton;
					}
					break;

				case 0: // Separator
					InsertSeparator();
					break;

				default: // Regular command
					{
						CMFCToolBarButton button(uiID, -1, strText);
						button.m_bText = TRUE;
						button.m_bImage = FALSE;

						InsertButton(button);
					}
					break;
				}
			}

			if (m_nHelpComboID != 0 && CommandToIndex(m_nHelpComboID) < 0)
			{
				CHelpComboBoxButton combobox(m_nHelpComboID, m_nHelpComboWidth, m_strHelpComboPrompt);
				InsertButton(combobox);
			}
		}
		else
		{
			SetPaneAlignment(dwOldAlignment);
		}

		if (bMaximizeMode)
		{
			CMDIFrameWnd* pParentFrame = DYNAMIC_DOWNCAST(CMDIFrameWnd, m_pParentWnd);
			if (pParentFrame != NULL)
			{
				SetMaximizeMode(TRUE, pParentFrame->MDIGetActive());
			}
		}

		if (GetSafeHwnd() != NULL)
		{
			AdjustLayout();
		}

		RebuildAccelerationKeys();
	}
	else if (m_bMaximizeMode && !IsCustomizeMode())
	{
		// System menu should be re-checked:
		SetMaximizeMode(FALSE, NULL, FALSE /* Don't recalculate layout */);
		SetMaximizeMode(TRUE, NULL, FALSE /* Don't recalculate layout */);

		// Repaint system buttons:
		InvalidateButton(0);
		for (int i = 0; i < m_nSystemButtonsNum; i++)
		{
			InvalidateButton(GetCount() - 1 - i);
		}
	}

	if (!m_bExclusiveRow)
	{
		AdjustSizeImmediate();
	}
}

CSize CMFCMenuBar::CalcLayout(DWORD dwMode, int nLength)
{
	OnChangeHot(-1);

	// Is menu bar have the buttons with images?
	m_bHaveButtons = FALSE;

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (!pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarMenuButtonsButton)) &&
			!pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarSystemMenuButton)) && pButton->m_bImage && pButton->IsDrawImage())
		{
			m_bHaveButtons = TRUE;
			break;
		}
	}
	BOOL bVert = (dwMode & LM_VERTDOCK) ||((dwMode & LM_HORZ) == 0);

	if (IsFloating() || !m_bExclusiveRow)
	{
		return CMFCToolBar::CalcLayout(dwMode, nLength);
	}

	CRect rect; rect.SetRectEmpty();

	if (m_pDockBarRow != NULL)
	{
		m_pDockBarRow->GetClientRect(rect);
	}

	if (rect.IsRectEmpty())
	{
		CWnd* pFrame = GetOwner();
		pFrame->GetClientRect(&rect);
	}

	CSize size;

	CRect rectClient;
	rectClient.SetRectEmpty();
	CalcInsideRect(rectClient, (dwMode & LM_HORZ));

	if (!bVert)
	{
		WrapToolBar(rect.Width() + rectClient.Width() - 1);

		// Calculate size again after wrapping:
		size = CalcSize(FALSE);
		size.cx = rect.Width() - rectClient.Width() / 2;
		size.cy -= rectClient.Height();
	}
	else
	{
		// Calculate size again after wrapping:
		size = CalcSize(TRUE);

		size.cy = rect.Height() - rectClient.Height() / 2;
		size.cx -= rectClient.Width();
	}

	// Something may have changed, rebuild acceleration keys:
	RebuildAccelerationKeys();

	return size;
}

void CMFCMenuBar::SetMaximizeMode(BOOL bMax, CWnd* pWnd, BOOL bRecalcLayout)
{
	if (m_bMaximizeMode == bMax)
	{
		return;
	}

	if (bMax)
	{
		if (pWnd == NULL)
		{
			bMax = FALSE;
		}
		else
		{
			ASSERT_VALID(pWnd);

			CFrameWnd* pFrameWnd = DYNAMIC_DOWNCAST(CFrameWnd, pWnd);
			BOOL bIsOleContainer = pFrameWnd != NULL && pFrameWnd->m_pNotifyHook != NULL;

			m_hSysMenu = NULL;

			CMenu* pMenu = pWnd->GetSystemMenu(FALSE);
			if (pMenu != NULL && ::IsMenu(pMenu->m_hMenu))
			{
				m_hSysMenu = pMenu->GetSafeHmenu();
				if (!::IsMenu(m_hSysMenu) || (pWnd->GetStyle() & WS_SYSMENU) == 0 && !bIsOleContainer)
				{
					m_hSysMenu = NULL;
				}
			}

			// If we have a system menu, then add a system menu button.
			if (m_hSysMenu != NULL)
			{
				m_hSysIcon = pWnd->GetIcon(FALSE);
				if (m_hSysIcon == NULL)
				{
					m_hSysIcon = (HICON)(LONG_PTR) GetClassLongPtr(*pWnd, GCLP_HICONSM);
				}

				InsertButton(CMFCToolBarSystemMenuButton(m_hSysMenu, m_hSysIcon), 0);
			}

			LONG style = ::GetWindowLong(*pWnd, GWL_STYLE);

			// Assume no buttons.
			m_nSystemButtonsNum = 0;

			if (m_hSysMenu != NULL)
			{
				// Add a minimize box if required.
				if (style & WS_MINIMIZEBOX)
				{
					InsertButton(CMFCToolBarMenuButtonsButton(SC_MINIMIZE));
					m_nSystemButtonsNum++;
				}

				// Add a restore box if required.
				if (style & WS_MAXIMIZEBOX)
				{
					InsertButton(CMFCToolBarMenuButtonsButton(SC_RESTORE));
					m_nSystemButtonsNum++;
				}

				// Add a close box if required.
				CMFCToolBarMenuButtonsButton closeButton(SC_CLOSE);
				if (m_hSysMenu != NULL)
				{
					// Jan Vasina: check if the maximized window has its system menu
					// with the close button enabled:
					MENUITEMINFO menuInfo;
					ZeroMemory(&menuInfo,sizeof(MENUITEMINFO));
					menuInfo.cbSize = sizeof(MENUITEMINFO);
					menuInfo.fMask = MIIM_STATE;

					if (!::GetMenuItemInfo(m_hSysMenu, SC_CLOSE, FALSE, &menuInfo) || (menuInfo.fState & MFS_GRAYED) || (menuInfo.fState & MFS_DISABLED))
					{
						closeButton.m_nStyle |= TBBS_DISABLED;
					}
				}

				InsertButton(closeButton);
				m_nSystemButtonsNum++;
			}
		}
	}
	else
	{
		m_nSystemButtonsNumSaved = m_nSystemButtonsNum;

		// Remove first button if a system menu was added.
		if (m_hSysMenu != NULL)
		{
			RemoveButton(0);
		}

		int iSysIndex = (int) m_Buttons.GetCount() - 1;
		if (m_pCustomizeBtn != NULL)
		{
			iSysIndex--;
		}

		for (int i = 0; i < m_nSystemButtonsNum; i ++)
		{
			ASSERT_KINDOF(CMFCToolBarMenuButtonsButton, GetButton(iSysIndex - i));
			RemoveButton(iSysIndex - i);
		}

		// Now we have no system buttons on the menu.
		m_nSystemButtonsNum = 0;
	}

	m_bMaximizeMode = bMax;

	if (bRecalcLayout)
	{
		AdjustLayout();
	}

	if (!m_bExclusiveRow && bRecalcLayout)
	{
		AdjustSizeImmediate(bRecalcLayout);
	}
}

void CMFCMenuBar::RestoreMaximizeMode(BOOL bRecalcLayout)
{
	if (m_bMaximizeMode)
	{
		return;
	}

	int nSystemButtonsNum = 0;

	if (m_hSysMenu != NULL)
	{
		CMDIFrameWnd* pParentFrame = DYNAMIC_DOWNCAST(CMDIFrameWnd, m_pParentWnd);
		if (pParentFrame != NULL && pParentFrame->MDIGetActive() != NULL)
		{
			LONG style = ::GetWindowLong(*pParentFrame->MDIGetActive(), GWL_STYLE);

			CMFCToolBarSystemMenuButton button(m_hSysMenu, m_hSysIcon);
			InsertButton(button, 0);

			if (style & WS_MINIMIZEBOX)
			{
				InsertButton(CMFCToolBarMenuButtonsButton(SC_MINIMIZE));
				nSystemButtonsNum++;
			}

			if (style & WS_MAXIMIZEBOX)
			{
				InsertButton(CMFCToolBarMenuButtonsButton(SC_RESTORE));
				nSystemButtonsNum++;
			}

			CMFCToolBarMenuButtonsButton closeButton(SC_CLOSE);

			MENUITEMINFO menuInfo;
			ZeroMemory(&menuInfo,sizeof(MENUITEMINFO));
			menuInfo.cbSize = sizeof(MENUITEMINFO);
			menuInfo.fMask = MIIM_STATE;

			if (!::GetMenuItemInfo(m_hSysMenu, SC_CLOSE, FALSE, &menuInfo) || (menuInfo.fState & MFS_GRAYED) || (menuInfo.fState & MFS_DISABLED))
			{
				closeButton.m_nStyle |= TBBS_DISABLED;
			}

			InsertButton(closeButton);
			nSystemButtonsNum++;
		}
	}

	m_bMaximizeMode = TRUE;
	m_nSystemButtonsNum = m_nSystemButtonsNumSaved;

	ASSERT(m_nSystemButtonsNum == nSystemButtonsNum);

	if (bRecalcLayout)
	{
		GetParentFrame()->RecalcLayout();

		Invalidate();
		UpdateWindow();
	}
}

void CMFCMenuBar::AdjustLocations()
{
	CMFCToolBarComboBoxButton* pHelpCombobox = GetHelpCombobox();
	if (pHelpCombobox != NULL)
	{
		pHelpCombobox->Show(FALSE);
	}

	CMFCToolBar::AdjustLocations();

	CRect rectClient;
	GetClientRect(&rectClient);

	int xRight = rectClient.right;
	BOOL bHorz = GetCurrentAlignment() & CBRS_ORIENT_HORZ ? TRUE : FALSE;

	if (m_bMaximizeMode)
	{
		int iButtonWidth = m_szSystemButton.cx;
		int iButtonHeight = m_szSystemButton.cy;

		POSITION pos = m_Buttons.GetTailPosition();
		CRect rect = rectClient;

		rectClient.SetRectEmpty();
		CalcInsideRect(rectClient, bHorz);

		if (!bHorz)
		{
			rect.bottom += rectClient.Height();
		}

		rect.left = rect.right - iButtonWidth;
		rect.top = rect.bottom - iButtonHeight;

		if (m_pCustomizeBtn != NULL)
		{
			m_Buttons.GetPrev(pos);
		}

		for (int i = 0; i < m_nSystemButtonsNum; i ++)
		{
			ENSURE(pos != NULL);

			CMFCToolBarMenuButtonsButton* pButton = (CMFCToolBarMenuButtonsButton*) m_Buttons.GetPrev(pos);
			ASSERT_KINDOF(CMFCToolBarMenuButtonsButton, pButton);

			pButton->SetRect(rect);

			xRight = rect.left;

			if (bHorz)
			{
				rect.OffsetRect(-iButtonWidth - 1, 0);
			}
			else
			{
				rect.OffsetRect(0, -iButtonHeight - 1);
			}
		}
	}

	// Adjust help combo location:
	if (pHelpCombobox != NULL)
	{
		pHelpCombobox->Show(TRUE);

		CRect rectCombo = pHelpCombobox->Rect();

		if (bHorz)
		{
			rectCombo.right = xRight;
			rectCombo.left = rectCombo.right - m_nHelpComboWidth;
		}
		else
		{
			rectCombo.SetRectEmpty();
		}

		pHelpCombobox->SetRect(rectCombo);
	}
}

BOOL CMFCMenuBar::OnSendCommand(const CMFCToolBarButton* pButton)
{
	CMFCToolBarMenuButtonsButton* pSysButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButtonsButton, pButton);
	if (pSysButton == NULL)
	{
		return FALSE;
	}

	if (pSysButton->m_uiSystemCommand != SC_CLOSE && pSysButton->m_uiSystemCommand != SC_MINIMIZE && pSysButton->m_uiSystemCommand != SC_RESTORE)
	{
		ASSERT(FALSE);
		return TRUE;
	}

	CMDIFrameWnd* pParentFrame = DYNAMIC_DOWNCAST(CMDIFrameWnd, m_pParentWnd);

	if (pParentFrame == NULL)
	{
		MessageBeep((UINT) -1);
		return TRUE;
	}

	CMDIChildWnd* pChild = pParentFrame->MDIGetActive();
	ASSERT_VALID(pChild);

	pChild->SendMessage(WM_SYSCOMMAND, pSysButton->m_uiSystemCommand);
	return TRUE;
}

INT_PTR CMFCMenuBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);

	int nHit = ((CMFCMenuBar*)this)->HitTest(point);
	if (nHit != -1)
	{
		CMFCToolBarButton* pButton = GetButton(nHit);
		if (pButton == NULL || pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarMenuButton)))
		{
			// Don't show tooltips on menu items!
			return -1;
		}
	}

	return CMFCToolBar::OnToolHitTest(point, pTI);
}

int CMFCMenuBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMFCToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Attach menubar to the parent frame:

	// First, try MDI frame:
	CMDIFrameWndEx* pWndParentMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pParentWnd);
	if (pWndParentMDIFrame != NULL)
	{
		pWndParentMDIFrame->m_Impl.SetMenuBar(this);
	}
	else
	{
		CFrameWndEx* pWndParentFrame = DYNAMIC_DOWNCAST(CFrameWndEx, m_pParentWnd);
		if (pWndParentFrame != NULL)
		{
			pWndParentFrame->m_Impl.SetMenuBar(this);
		}
		else
		{
			COleIPFrameWndEx* pOleFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, GetParentFrame());
			if (pOleFrame != NULL)
			{
				pOleFrame->m_Impl.SetMenuBar(this);
			}
		}
	}

	// Set default menu bar title:
	CString strTitle;
	ENSURE(strTitle.LoadString(IDS_AFXBARRES_MENU_BAR_TITLE));

	SetWindowText(strTitle);

	// Force the menu bar to be hiden whren the in-place editing is
	// is activated(server application shows its own menu):
	SetPaneStyle(GetPaneStyle() | CBRS_HIDE_INPLACE);

	// Calculate system button size:
	CalcSysButtonSize();
	return 0;
}

BOOL CMFCMenuBar::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT /*uiID*/)
{
	ENSURE(m_hDefaultMenu != NULL);

	CString strProfileName = ::AFXGetRegPath(strMenuProfile, lpszProfileName);

	// Save current maximize mode(system buttons are not saved!):
	BOOL bMaximizeMode = m_bMaximizeMode;
	SetMaximizeMode(FALSE, NULL, FALSE);

	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (m_bAutoDocMenus && pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interested in CMultiDocTemplate objects with the shared menu only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hMenuShared == NULL)
			{
				continue;
			}

			UINT uiMenuResId = pTemplate->GetResId();
			ASSERT(uiMenuResId != 0);

			// Load menubar from registry and associate it with the template shared menu:
			BuildOrigItems(uiMenuResId);
			if (CMFCToolBar::LoadState(strProfileName, nIndex, uiMenuResId) && !m_bResourceWasChanged)
			{
				afxMenuHash.SaveMenuBar(pTemplate->m_hMenuShared, this);
			}
			else if (GetOwner()->GetSafeHwnd() != NULL)
			{
				// The following code was added to ensure that a
				// AFX_WM_RESETMENU message will be sent to the frame the
				// first time the application is loaded
				m_hMenu = NULL;
				CreateFromMenu(pTemplate->m_hMenuShared, FALSE);
				GetOwner()->SendMessage(AFX_WM_RESETMENU, uiMenuResId);
				afxMenuHash.SaveMenuBar(pTemplate->m_hMenuShared, this);
				m_hMenu = pTemplate->m_hMenuShared;
			}
		}
	}

	// Load defualt menubar:
	BuildOrigItems(m_uiDefMenuResId);

	if (CMFCToolBar::LoadState(strProfileName, nIndex, 0) && !m_bResourceWasChanged)
	{
		afxMenuHash.SaveMenuBar(m_hDefaultMenu, this);
	}
	else if (GetOwner()->GetSafeHwnd() != NULL)
	{
		// The following code was added to ensure that a AFX_WM_RESETMENU
		// message will be sent to the frame the first time the application
		// is loaded

		m_hMenu = NULL;
		CreateFromMenu(m_hDefaultMenu, TRUE);

		UINT uiResID = m_uiDefMenuResId;
		if (uiResID == 0)
		{
			// Obtain main window resource ID:
			uiResID = (UINT) GetOwner()->SendMessage(WM_HELPHITTEST);
		}

		GetOwner()->SendMessage(AFX_WM_RESETMENU, uiResID);
		afxMenuHash.SaveMenuBar(m_hDefaultMenu, this);
		m_hMenu = m_hDefaultMenu;
	}

	// Restore current menu:
	BOOL bLoaded = (m_hMenu != NULL && afxMenuHash.LoadMenuBar(m_hMenu, this));

	if (bMaximizeMode)
	{
		RestoreMaximizeMode(!bLoaded); // do not recalc layout if the menu was loaded
	}

	if (bLoaded)
	{
		GetParentFrame()->RecalcLayout();
		Invalidate();
		UpdateWindow();
	}

	AdjustLayout();
	RebuildAccelerationKeys();

	return TRUE;
}

BOOL CMFCMenuBar::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT /*uiID*/)
{
	ENSURE(m_hDefaultMenu != NULL);

	CString strProfileName = ::AFXGetRegPath(strMenuProfile, lpszProfileName);

	afxMenuHash.SaveMenuBar(m_hMenu, this);

	// Save current maximize mode(system buttons are not saved!):
	BOOL bMaximizeMode = m_bMaximizeMode;
	SetMaximizeMode(FALSE, NULL, FALSE);

	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (m_bAutoDocMenus && pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interessing CMultiDocTemplate objects with
			// the sahred menu only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hMenuShared == NULL)
			{
				continue;
			}

			UINT uiMenuResId = pTemplate->GetResId();
			ASSERT(uiMenuResId != 0);

			// Load menubar associated with the template shared menu and
			// save it in the registry:
			if (afxMenuHash.LoadMenuBar(pTemplate->m_hMenuShared, this))
			{
				BuildOrigItems(uiMenuResId);
				CMFCToolBar::SaveState(strProfileName, nIndex, uiMenuResId);
			}
		}
	}

	// Save default menu:
	if (afxMenuHash.LoadMenuBar(m_hDefaultMenu, this))
	{
		BuildOrigItems(m_uiDefMenuResId);
		CMFCToolBar::SaveState(strProfileName, nIndex, 0);
	}

	// Restore current menu:
	BOOL bRestored = (m_hMenu != NULL && afxMenuHash.LoadMenuBar(m_hMenu, this));

	if (bMaximizeMode)
	{
		RestoreMaximizeMode(!bRestored);
	}

	AdjustSizeImmediate();

	if (bRestored)
	{
		GetParentFrame()->RecalcLayout();
		Invalidate();
		UpdateWindow();
	}

	AdjustLayout();

	return TRUE;
}

void CMFCMenuBar::ResetImages()
{
	ENSURE(m_hDefaultMenu != NULL);

	afxMenuHash.SaveMenuBar(m_hMenu, this);

	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (pDocManager != NULL)
	{
		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interested in CMultiDocTemplate objects with the shared menu only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hMenuShared == NULL)
			{
				continue;
			}

			if (afxMenuHash.LoadMenuBar(pTemplate->m_hMenuShared, this))
			{
				CMFCToolBar::ResetImages();
				afxMenuHash.SaveMenuBar(pTemplate->m_hMenuShared, this);
			}
		}
	}

	// Reset default menu:
	if (afxMenuHash.LoadMenuBar(m_hDefaultMenu, this))
	{
		CMFCToolBar::ResetImages();
		afxMenuHash.SaveMenuBar(m_hDefaultMenu, this);
	}

	// Restore current menu:
	if (m_hMenu != NULL && afxMenuHash.LoadMenuBar(m_hMenu, this))
	{
		GetParentFrame()->RecalcLayout();
		Invalidate();
		UpdateWindow();
	}
}

void CMFCMenuBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	int iHit = HitTest(point);

	// Disable control bar dragging if any menues are dropped!
	if (iHit < 0 && // Click outside of buttons
		GetDroppedDownMenu() != NULL)
	{
		// Do nothing
		CMFCToolBar::OnLButtonDown(nFlags, point);
	}
	else
	{
		CMFCToolBar::OnLButtonDown(nFlags, point);
	}
}

BOOL CMFCMenuBar::RestoreOriginalstate()
{
	HMENU hMenuCurr = m_hMenu;

	if (m_hMenu != NULL)
	{
		afxMenuHash.SaveMenuBar(m_hMenu, this);
	}

	// Save customize button:
	CMFCCustomizeButton* pCustomizeBtn = NULL;
	if (m_pCustomizeBtn != NULL)
	{
		ASSERT_VALID(m_pCustomizeBtn);
		ASSERT(m_pCustomizeBtn == m_Buttons.GetTail()); // Should be last

		CRuntimeClass* pRTC = m_pCustomizeBtn->GetRuntimeClass();
		pCustomizeBtn = DYNAMIC_DOWNCAST(CMFCCustomizeButton, pRTC->CreateObject());

		ASSERT_VALID(pCustomizeBtn);
		pCustomizeBtn->CopyFrom(*m_pCustomizeBtn);

	}

	CMDIFrameWndEx* pWndParentMDIFrame = DYNAMIC_DOWNCAST(CMDIFrameWndEx, m_pParentWnd);

	if (g_pTearOffMenuManager != NULL)
	{
		g_pTearOffMenuManager->Reset(NULL);
	}

	BOOL bCurrMenuIsRestored = FALSE;
	CDocTemplate* pActiveTemplate = NULL;

	// Save current maximize mode(system buttons are not saved!):
	BOOL bMaximizeMode = m_bMaximizeMode;
	SetMaximizeMode(FALSE);

	CDocManager* pDocManager = AfxGetApp()->m_pDocManager;
	if (pDocManager != NULL)
	{
		// Find an active document's template:
		CMDIFrameWnd* pParentFrame = DYNAMIC_DOWNCAST(CMDIFrameWnd, m_pParentWnd);
		if (pParentFrame != NULL && pParentFrame->MDIGetActive() != NULL)
		{
			CDocument* pActiveDoc = pParentFrame->MDIGetActive()->GetActiveDocument();
			if (pActiveDoc != NULL)
			{
				pActiveTemplate = pActiveDoc->GetDocTemplate();
			}
		}

		// Walk all templates in the application:
		for (POSITION pos = pDocManager->GetFirstDocTemplatePosition(); pos != NULL;)
		{
			CMultiDocTemplateEx* pTemplate = (CMultiDocTemplateEx*) pDocManager->GetNextDocTemplate(pos);
			ASSERT_VALID(pTemplate);
			ASSERT_KINDOF(CDocTemplate, pTemplate);

			// We are interested in CMultiDocTemplate objects with the shared menu only....
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CMultiDocTemplate)) || pTemplate->m_hMenuShared == NULL)
			{
				continue;
			}

			UINT uiMenuResId = pTemplate->GetResId();
			ENSURE(uiMenuResId != 0);

			// Restore original menu from resource:
			HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(uiMenuResId), RT_MENU);

			BOOL bCurr = (pActiveTemplate == pTemplate);

			HMENU hmenuSharedOld = pTemplate->m_hMenuShared;
			pTemplate->m_hMenuShared = ::LoadMenuW(hInst, MAKEINTRESOURCEW(uiMenuResId));

			CreateFromMenu(pTemplate->m_hMenuShared, FALSE);
			afxMenuHash.SaveMenuBar(pTemplate->m_hMenuShared, this);

			if (bCurr)
			{
				hMenuCurr = pTemplate->m_hMenuShared;
				bCurrMenuIsRestored = TRUE;
			}

			// Update shared menus in all MDI child windows:
			UpdateMDIChildrenMenus(pTemplate);

			if (hmenuSharedOld != NULL)
			{
				ENSURE(::IsMenu(hmenuSharedOld));
				afxMenuHash.RemoveMenu(hmenuSharedOld);
				::DestroyMenu(hmenuSharedOld);
			}
		}
	}

	// Load defualt menubar:
	if (m_uiDefMenuResId != 0)
	{
		HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(m_uiDefMenuResId), RT_MENU);

		HMENU hOldDefaultMenu = m_hDefaultMenu;

		m_hDefaultMenu = ::LoadMenuW(hInst, MAKEINTRESOURCEW(m_uiDefMenuResId));

		OnDefaultMenuLoaded(m_hDefaultMenu);

		CreateFromMenu(m_hDefaultMenu, TRUE);
		afxMenuHash.SaveMenuBar(m_hDefaultMenu, this);

		if (!bCurrMenuIsRestored)
		{
			hMenuCurr = m_hDefaultMenu;
		}

		if (pWndParentMDIFrame != NULL)
		{
			pWndParentMDIFrame->m_hMenuDefault = m_hDefaultMenu;
			pWndParentMDIFrame->m_Impl.m_hDefaultMenu = m_hDefaultMenu;
		}

		CFrameWnd* pWndParentFrame = DYNAMIC_DOWNCAST(CFrameWnd, m_pParentWnd);
		if (pWndParentFrame != NULL)
		{
			pWndParentFrame->m_hMenuDefault = m_hDefaultMenu;
		}

		if (hOldDefaultMenu != NULL)
		{
			ENSURE(::IsMenu(hOldDefaultMenu));

			afxMenuHash.RemoveMenu(hOldDefaultMenu);
			::DestroyMenu(hOldDefaultMenu);
		}
	}

	// Restore current menu:
	if (afxMenuHash.LoadMenuBar(hMenuCurr, this))
	{
		m_hMenu = hMenuCurr;

		if (!bMaximizeMode)
		{
			GetParentFrame()->RecalcLayout();
			Invalidate();
			UpdateWindow();
		}
	}

	if (pWndParentMDIFrame != NULL)
	{
		pWndParentMDIFrame->OnUpdateFrameMenu(m_hMenu);
	}

	if (bMaximizeMode)
	{
		RestoreMaximizeMode();
	}

	if (m_pMenuPage != NULL)
	{
		ASSERT_VALID(m_pMenuPage);
		m_pMenuPage->SelectMenu(pActiveTemplate, FALSE /* Don't save cur. menu */);
	}

	// Restore customize button:
	if (pCustomizeBtn != NULL)
	{
		InsertButton(pCustomizeBtn);
		m_pCustomizeBtn = pCustomizeBtn;
		AdjustLayout();
		AdjustSizeImmediate();
	}

	return TRUE;
}

void CMFCMenuBar::SetDefaultMenuResId(UINT uiResId)
{
	m_uiDefMenuResId = uiResId;
}

BOOL CMFCMenuBar::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN)
	{
		// Fisrt, try to move keyboard control to the drop-down menu:
		CMFCToolBarMenuButton* pMenuButon = GetDroppedDownMenu();
		if (pMenuButon != NULL)
		{
			return CBasePane::PreTranslateMessage(pMsg);
		}

		int iTotalItems = GetCount();
		if (m_bMaximizeMode)
		{
			iTotalItems -= m_nSystemButtonsNum;
		}

		if (m_iHighlighted >= 0 && m_iHighlighted < iTotalItems)
		{
			int iButton = m_iHighlighted;
			int nChar = (int) pMsg->wParam;

			if (nChar == VK_TAB)
			{
				if (::GetKeyState(VK_SHIFT) & 0x80)
				{
					nChar = VK_LEFT;
				}
				else
				{
					nChar = VK_RIGHT;
				}
			}

			BOOL bIsRTL = GetExStyle() & WS_EX_LAYOUTRTL;

			if (bIsRTL)
			{
				if (nChar == VK_LEFT)
				{
					nChar = VK_RIGHT;
				}
				else if (nChar == VK_RIGHT)
				{
					nChar = VK_LEFT;
				}
			}

			switch (nChar)
			{
			case VK_ESCAPE:
				{
					Deactivate();
					RestoreFocus();
					m_bShowAllCommands = FALSE;
				}
				break;

			case VK_RIGHT:
				if (++ m_iHighlighted >= iTotalItems)
				{
					m_iHighlighted = 0;
				}

				InvalidateButton(iButton);
				InvalidateButton(m_iHighlighted);
				UpdateWindow();

				AccNotifyObjectFocusEvent(m_iHighlighted);
				break;

			case VK_LEFT:
				if (-- m_iHighlighted < 0)
				{
					m_iHighlighted = iTotalItems - 1;
				}

				InvalidateButton(iButton);
				InvalidateButton(m_iHighlighted);
				UpdateWindow();

				AccNotifyObjectFocusEvent(m_iHighlighted);
				break;

			case VK_DOWN:
				DropDownMenu(GetButton(m_iHighlighted));
				return TRUE;

			case VK_RETURN:
				if (!DropDownMenu(GetButton(m_iHighlighted)))
				{
					ProcessCommand(GetButton(m_iHighlighted));
				}
				return TRUE;

			default:
				if (TranslateChar((int) pMsg->wParam))
				{
					return TRUE;
				}
			}
		}
	}

	return CMFCToolBar::PreTranslateMessage(pMsg);
}

void CMFCMenuBar::OnSetFocus(CWnd* pOldWnd)
{
	if (afxGlobalData.IsAccessibilitySupport())
	{
		::NotifyWinEvent(EVENT_SYSTEM_MENUSTART, GetSafeHwnd (), OBJID_WINDOW, CHILDID_SELF);

		if (m_iHot >= 0)
		{
			AccNotifyObjectFocusEvent (m_iHot);
		}
	}

	CMFCToolBar::OnSetFocus(pOldWnd);

	if (GetDroppedDownMenu() == NULL)
	{
		GetOwner()->SendMessage(WM_SETMESSAGESTRING, AFX_IDS_IDLEMESSAGE);

		int iFirstItem = GetSystemMenu() != NULL ? 1 : 0;
		if (m_iHighlighted < 0 && iFirstItem < GetCount())
		{
			m_iHighlighted = iFirstItem;
			InvalidateButton(iFirstItem);
		}
	}
}

BOOL CMFCMenuBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
	m_pParentWnd = pParentWnd;
	return CMFCToolBar::Create(pParentWnd, dwStyle, nID);
}

BOOL CMFCMenuBar::CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle, DWORD dwStyle, CRect rcBorders, UINT nID)
{
	m_pParentWnd = pParentWnd;
	return CMFCToolBar::CreateEx(pParentWnd, dwCtrlStyle, dwStyle, rcBorders, nID);
}

CSize CMFCMenuBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	if (m_Buttons.IsEmpty())
	{
		return GetButtonSize();
	}

	DWORD dwMode = bStretch ? LM_STRETCH : 0;
	dwMode |= bHorz ? LM_HORZ : 0;

	return CalcLayout(dwMode);
}

BOOL CMFCMenuBar::OnSetDefaultButtonText(CMFCToolBarButton* pButton)
{
	ASSERT_VALID(pButton);

	CString strText;
	if (FindMenuItemText(m_hMenu, pButton->m_nID, strText))
	{
		pButton->m_strText = strText;
		return TRUE;
	}

	return CMFCToolBar::OnSetDefaultButtonText(pButton);
}

BOOL __stdcall CMFCMenuBar::FindMenuItemText(HMENU hMenu, const UINT nItemID, CString& strOutText)
{
	if (hMenu == NULL || nItemID == 0 || nItemID == (UINT) -1)
	{
		return FALSE;
	}

	CMenu* pMenu = CMenu::FromHandle(hMenu);
	if (pMenu == NULL)
	{
		return FALSE;
	}

	int iCount = pMenu->GetMenuItemCount();
	for (int i = 0; i < iCount; i ++)
	{
		UINT uiID = pMenu->GetMenuItemID(i);
		if (uiID == nItemID) // Found!
		{
			pMenu->GetMenuString(i, strOutText, MF_BYPOSITION);
			return TRUE;
		}
		else if (uiID == -1) // Pop-up menu
		{
			CMenu* pPopupMenu = pMenu->GetSubMenu(i);
			ENSURE(pPopupMenu != NULL);

			if (FindMenuItemText(pPopupMenu->GetSafeHmenu(), nItemID, strOutText))
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}

int CMFCMenuBar::FindDropIndex(const CPoint point, CRect& rectDrag) const
{
	int iIndex = CMFCToolBar::FindDropIndex(point, rectDrag);
	if (m_bMaximizeMode && iIndex >= 0)
	{
		// Maybe drag left from the system icon?
		if (iIndex == 0 && m_hSysMenu != NULL)
		{
			return -1;
		}

		// Maybe drag right of the system buttons?
		if (iIndex > GetCount() - m_nSystemButtonsNum)
		{
			iIndex = GetCount() - m_nSystemButtonsNum;

			if (m_nSystemButtonsNum > 0)
			{
				// Put drag rectangle right of the last "non-system" button:

				CMFCToolBarButton* pLastButton = GetButton(iIndex - 1);
				ASSERT_VALID(pLastButton);

				CRect rectBtn = pLastButton->Rect();
				CPoint ptDrag(rectBtn.right, rectBtn.top + rectBtn.Height() / 2);

				VERIFY(CMFCToolBar::FindDropIndex(ptDrag, rectDrag) == iIndex);
			}
		}
	}

	if (m_nHelpComboID != 0)
	{
		int nHelpComboIndex = CommandToIndex(m_nHelpComboID);
		if (nHelpComboIndex >= 0 && iIndex > nHelpComboIndex)
		{
			iIndex = nHelpComboIndex;
		}
	}

	return iIndex;
}

void CMFCMenuBar::OnChangeHot(int iHot)
{
	CMFCToolBar::OnChangeHot(iHot);

	KillTimer(uiShowAllItemsTimerId);

	if (GetDroppedDownMenu() == NULL)
	{
		m_bShowAllCommands = FALSE;
	}
	else
	{
		SetTimer(uiShowAllItemsTimerId, nShowAllItemsTimerFreq, NULL);
	}
}

void __stdcall CMFCMenuBar::SetShowAllCommands(BOOL bShowAllCommands)
{
	m_bShowAllCommands = bShowAllCommands;
}

void __stdcall CMFCMenuBar::SetRecentlyUsedMenus(BOOL bOn)
{
	m_bRecentlyUsedMenus = bOn;
}

CMFCToolBarButton* CMFCMenuBar::GetMenuItem(int iItem) const
{
	if (m_bMaximizeMode)
	{
		iItem --; // Ignore system-menu button
	}

	return GetButton(iItem);
}

CMFCToolBarSystemMenuButton* CMFCMenuBar::GetSystemMenu() const
{
	if (!m_bMaximizeMode)
	{
		return NULL;
	}

	if (m_Buttons.IsEmpty())
	{
		return NULL;
	}
	return DYNAMIC_DOWNCAST(CMFCToolBarSystemMenuButton, m_Buttons.GetHead());
}

CMFCToolBarMenuButtonsButton* CMFCMenuBar::GetSystemButton(UINT uiBtn, BOOL bByCommand) const
{
	if (!m_bMaximizeMode)
	{
		return NULL;
	}

	if (bByCommand)
	{
		for (POSITION pos = m_Buttons.GetTailPosition(); pos != NULL;)
		{
			CMFCToolBarMenuButtonsButton* pButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButtonsButton, m_Buttons.GetPrev(pos));

			if (pButton == NULL)
			{
				break;
			}

			if (pButton->m_nID == uiBtn)
			{
				return pButton;
			}
		}

		return NULL;
	}
	// else - by index:
	if ((int) uiBtn < 0 ||(int) uiBtn >= m_nSystemButtonsNum)
	{
		ASSERT(FALSE);
		return NULL;
	}

	int iIndex = (int) m_Buttons.GetCount() - m_nSystemButtonsNum + uiBtn;

	CMFCToolBarMenuButtonsButton* pButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButtonsButton, GetButton(iIndex));
	ASSERT_VALID(pButton);

	return pButton;
}

BOOL __stdcall CMFCMenuBar::SetMenuFont(LPLOGFONT lpLogFont, BOOL bHorz)
{
	if (!afxGlobalData.SetMenuFont(lpLogFont, bHorz))
	{
		return FALSE;
	}

	// Recalculate all toolbars and menus layout:
	extern CObList afxAllToolBars;

	for (POSITION pos = afxAllToolBars.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(pos);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) != NULL)
		{
			ASSERT_VALID(pToolBar);
			pToolBar->AdjustLayout();
		}
	}

	return TRUE;
}

const CFont& __stdcall CMFCMenuBar::GetMenuFont(BOOL bHorz)
{
	return bHorz ? afxGlobalData.fontRegular : afxGlobalData.fontVert;
}

void CMFCMenuBar::OnTimer(UINT_PTR nIDEvent)
{
	if (nIDEvent == uiShowAllItemsTimerId)
	{
		CPoint ptCursor;

		::GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);

		// Check that the popup-menu is still exist and mouse cursor is
		// within the menu button:
		CMFCToolBarMenuButton* pMenuButon = GetDroppedDownMenu();
		if (pMenuButon != NULL && pMenuButon->m_pPopupMenu != NULL && pMenuButon->m_rect.PtInRect(ptCursor) && !pMenuButon->m_pPopupMenu->AreAllCommandsShown())
		{
			pMenuButon->m_pPopupMenu->ShowAllCommands();
		}

		KillTimer(uiShowAllItemsTimerId);
	}

	CMFCToolBar::OnTimer(nIDEvent);
}

void CMFCMenuBar::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	int iButton = HitTest(point);
	BOOL bSysMenu = FALSE;

	if (iButton >= 0)
	{
		bSysMenu = DYNAMIC_DOWNCAST(CMFCToolBarSystemMenuButton, GetButton(iButton)) != NULL;
	}

	CMFCToolBar::OnLButtonDblClk(nFlags, point);

	if (bSysMenu || IsShowAllCommands() || IsCustomizeMode())
	{
		return;
	}

	if ((iButton = HitTest(point)) < 0)
	{
		return;
	}

	CMFCToolBarMenuButton* pMenuButton = DYNAMIC_DOWNCAST(CMFCToolBarMenuButton, GetButton(iButton));
	if (pMenuButton == NULL)
	{
		return;
	}

	// Special deal to system menu button
	if (pMenuButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarSystemMenuButton)))
	{
		return;
	}

	m_bShowAllCommands = TRUE;
	pMenuButton->OnCancelMode();

	if (!(pMenuButton->m_nStyle & TBBS_DISABLED) && pMenuButton->OnClick(this, FALSE))
	{
		OnChangeHot(iButton);

		InvalidateButton(iButton);
		UpdateWindow(); // immediate feedback
	}
}

void CMFCMenuBar::CalcSysButtonSize()
{
	CWindowDC dc(NULL);

	CDC dcMem;
	dcMem.CreateCompatibleDC(NULL); // Assume display!

	int iButtonWidth = ::GetSystemMetrics(SM_CXMENUSIZE);
	int iButtonHeight = ::GetSystemMetrics(SM_CXMENUSIZE);

	CBitmap bmpMem;
	bmpMem.CreateCompatibleBitmap(&dc, iButtonWidth, iButtonHeight);

	CBitmap* pBmpOriginal = dcMem.SelectObject(&bmpMem);

	CRect rectBtn(0, 0, iButtonWidth, iButtonHeight);
	dcMem.DrawFrameControl(rectBtn, DFC_CAPTION, DFCS_ADJUSTRECT);

	m_szSystemButton = rectBtn.Size();
	dcMem.SelectObject(pBmpOriginal);
}

void CMFCMenuBar::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	CMFCToolBar::OnSettingChange(uFlags, lpszSection);

	CalcSysButtonSize();
	Invalidate();
	UpdateWindow();
}

int CMFCMenuBar::CalcMaxButtonHeight()
{
	m_bHaveButtons = FALSE;

	for (POSITION pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (!pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarMenuButtonsButton)) &&
			!pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarSystemMenuButton)) && pButton->m_bImage && pButton->IsDrawImage())
		{
			m_bHaveButtons = TRUE;
			break;
		}
	}

	return GetRowHeight();
}

BOOL CMFCMenuBar::BuildOrigItems(UINT uiMenuResID)
{
	while (!m_OrigButtons.IsEmpty())
	{
		delete m_OrigButtons.RemoveHead();
	}

	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());
	if (pApp == NULL || !pApp->IsResourceSmartUpdate())
	{
		return FALSE;
	}

	CMenu menu;
	if (!menu.LoadMenu(uiMenuResID))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	int iCount = menu.GetMenuItemCount();
	for (int i = 0; i < iCount; i ++)
	{
		UINT uiID = menu.GetMenuItemID(i);

		CString strText;

#ifdef _DEBUG
		menu.GetMenuString(i, strText, MF_BYPOSITION);
#endif

		switch (uiID)
		{
		case -1: // Pop-up menu
			{
				CMenu* pPopupMenu = menu.GetSubMenu(i);
				ENSURE(pPopupMenu != NULL);

				CMFCToolBarMenuButton* pButton = (CMFCToolBarMenuButton*) m_pMenuButtonRTC->CreateObject();
				ASSERT_VALID(pButton);

				pButton->Initialize(0, pPopupMenu->GetSafeHmenu(), -1, strText);
				m_OrigButtons.AddTail(pButton);
			}
			break;

		case 0: // Separator
			{
				CMFCToolBarButton* pButton = new CMFCToolBarButton;
				ENSURE(pButton != NULL);

				pButton->m_nStyle = TBBS_SEPARATOR;
				m_OrigButtons.AddTail(pButton);
			}
			break;

		default: // Regular command

			m_OrigButtons.AddTail(new CMFCToolBarButton(uiID, -1, strText));
			break;
		}
	}

	return TRUE;
}

void __stdcall CMFCMenuBar::UpdateMDIChildrenMenus(CMultiDocTemplate* pTemplate)
{
	ASSERT_VALID(pTemplate);

	for (POSITION pos = pTemplate->GetFirstDocPosition(); pos != NULL;)
	{
		CDocument* pDoc = pTemplate->GetNextDoc(pos);
		ASSERT_VALID(pDoc);

		// assumes 1 doc per frame
		for (POSITION posView = pDoc->GetFirstViewPosition(); posView != NULL;)
		{
			CView* pView = pDoc->GetNextView(posView);
			ASSERT_VALID(pView);

			CMDIChildWnd* pFrame = DYNAMIC_DOWNCAST(CMDIChildWnd, pView->GetParentFrame());
			if (pFrame != NULL)
			{
				pFrame->SetHandles(pTemplate->m_hMenuShared, pTemplate->m_hAccelTable);
			}
		}
	}
}

BOOL CMFCMenuBar::IsPureMenuButton(CMFCToolBarButton* pButton) const
{
	ASSERT_VALID(pButton);
	return m_bMenuMode || pButton->IsKindOf(RUNTIME_CLASS(CMFCToolBarMenuButton));
}

void CMFCMenuBar::EnableHelpCombobox(UINT uiID /* 0 - disable */, LPCTSTR lpszPrompt /* = NULL */, int nComboBoxWidth/* = 150*/)
{
	ASSERT_VALID(this);

	m_nHelpComboID = uiID;
	m_nHelpComboWidth = nComboBoxWidth;
	m_strHelpComboPrompt = lpszPrompt == NULL ? _T("") : lpszPrompt;

	if (GetSafeHwnd() != NULL)
	{
		AdjustLayout();
		RedrawWindow();
	}
}

CMFCToolBarComboBoxButton* CMFCMenuBar::GetHelpCombobox()
{
	if (m_nHelpComboID == 0)
	{
		return NULL;
	}

	int nHelpComboIndex = CommandToIndex(m_nHelpComboID);
	if (nHelpComboIndex <= 0)
	{
		return NULL;
	}

	CMFCToolBarComboBoxButton* pCombobox = DYNAMIC_DOWNCAST(CMFCToolBarComboBoxButton, GetButton(nHelpComboIndex));
	return pCombobox;
}

void CMFCMenuBar::SetMenuButtonRTC(CRuntimeClass* pMenuButtonRTC)
{
	if (pMenuButtonRTC == NULL)
	{
		// Use default class:
		m_pMenuButtonRTC = RUNTIME_CLASS(CMFCToolBarMenuButton);
	}
	else
	{
		ASSERT_POINTER(pMenuButtonRTC, CRuntimeClass);
		ASSERT(pMenuButtonRTC->IsDerivedFrom(RUNTIME_CLASS(CMFCToolBarMenuButton)));

		m_pMenuButtonRTC = pMenuButtonRTC;
	}
}

int CMFCMenuBar::GetFloatPopupDirection(CMFCToolBarMenuButton* pMenuButton)
{
	ASSERT_VALID(pMenuButton);

	if (m_Buttons.Find(pMenuButton) == NULL)
	{
		ASSERT(FALSE);
		return -1;
	}

	if (!IsFloating())
	{
		ASSERT(FALSE);
		return -1;
	}

	BOOL bIsMenuWrapped = FALSE;
	POSITION pos = NULL;

	for (pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (pButton->m_bWrap)
		{
			bIsMenuWrapped = TRUE;
			break;
		}
	}

	if (!bIsMenuWrapped)
	{
		// menu bar has 1 row only, nothing to optimize
		return -1;
	}

	int nRow = 0;
	int nColumn = 0;

	for (pos = m_Buttons.GetHeadPosition(); pos != NULL;)
	{
		CMFCToolBarButton* pButton = (CMFCToolBarButton*) m_Buttons.GetNext(pos);
		ASSERT_VALID(pButton);

		if (pMenuButton == pButton)
		{
			if (pButton->m_bWrap)
			{
				// Last in row, show popup menu on right
				return(int) CMFCPopupMenu::DROP_DIRECTION_RIGHT;
			}

			if (nColumn == 0)
			{
				// First in row, show popup menu on left
				return(int) CMFCPopupMenu::DROP_DIRECTION_LEFT;
			}

			if (nRow == 0)
			{
				// First row, show popup menu on top
				return(int) CMFCPopupMenu::DROP_DIRECTION_TOP;
			}

			// Default direction
			return(int) CMFCPopupMenu::DROP_DIRECTION_BOTTOM;
		}

		nColumn++;

		if (pButton->m_bWrap)
		{
			nRow ++;
			nColumn = 0;
		}
	}

	ASSERT(FALSE);
	return -1;
}

void CMFCMenuBar::OnKillFocus(CWnd* pNewWnd)
{
	if (afxGlobalData.IsAccessibilitySupport())
	{
		::NotifyWinEvent(EVENT_SYSTEM_MENUEND, GetSafeHwnd (), OBJID_WINDOW, CHILDID_SELF);
	}

	CMFCToolBar::OnKillFocus(pNewWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmenuimages.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxmenuimages.h"
#include "afxribbonres.h"
#include "afxglobals.h"

static const COLORREF clrTransparent = RGB(255, 0, 255);
static const int nImageWidth = 9;
static const int nImageHeight = 9;

CMFCToolBarImages CMenuImages::m_ImagesBlack;
CMFCToolBarImages CMenuImages::m_ImagesDkGray;
CMFCToolBarImages CMenuImages::m_ImagesGray;
CMFCToolBarImages CMenuImages::m_ImagesLtGray;
CMFCToolBarImages CMenuImages::m_ImagesWhite;
CMFCToolBarImages CMenuImages::m_ImagesBlack2;

BOOL CMenuImages::m_bInitializing = FALSE;

BOOL __stdcall CMenuImages::Initialize()
{
	if (m_bInitializing)
	{
		return FALSE;
	}

	if (m_ImagesBlack.IsValid())
	{
		return TRUE;
	}

	m_bInitializing = TRUE;

	m_ImagesBlack.SetImageSize(CSize(nImageWidth, nImageHeight));
	if (!m_ImagesBlack.Load(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_MENU_IMAGES24 : IDB_AFXBARRES_MENU_IMAGES))
	{
		TRACE(_T("CMenuImages. Can't load menu images %x\n"), IDB_AFXBARRES_MENU_IMAGES);
		m_bInitializing = FALSE;
		return FALSE;
	}

	if (m_ImagesBlack.IsRTL())
	{
		m_ImagesBlack.Mirror();
	}

	m_ImagesBlack.SetTransparentColor(clrTransparent);

	CreateCopy(m_ImagesGray, RGB(128, 128, 128));
	CreateCopy(m_ImagesDkGray, RGB(72, 72, 72));
	CreateCopy(m_ImagesLtGray, RGB(192, 192, 192));
	CreateCopy(m_ImagesWhite, RGB(255, 255, 255));
	CreateCopy(m_ImagesBlack2, RGB(0, 0, 0));

	if (m_ImagesBlack.IsValid())
	{
		double dblScale = afxGlobalData.GetRibbonImageScale();
		if (dblScale != 1.0)
		{
			m_ImagesBlack.SmoothResize(dblScale);
			m_ImagesGray.SmoothResize(dblScale);
			m_ImagesDkGray.SmoothResize(dblScale);
			m_ImagesLtGray.SmoothResize(dblScale);
			m_ImagesWhite.SmoothResize(dblScale);
			m_ImagesBlack2.SmoothResize(dblScale);
		}
	}

	m_bInitializing = FALSE;
	return TRUE;
}

CSize __stdcall CMenuImages::Size()
{
	if (m_bInitializing)
	{
		CSize size(nImageWidth, nImageHeight);

		double dblScale = afxGlobalData.GetRibbonImageScale();
		if (dblScale != 1.0)
		{
			size.cx = (int)(.5 + size.cx * dblScale);
			size.cy = (int)(.5 + size.cy * dblScale);
		}

		return size;
	}

	Initialize ();
	return m_ImagesBlack.GetImageSize();
}

void __stdcall CMenuImages::Draw(CDC* pDC, IMAGES_IDS id, const CPoint& ptImage, CMenuImages::IMAGE_STATE state, const CSize& sizeImage/* = CSize(0, 0)*/)
{
	if (!Initialize())
	{
		return;
	}

	CAfxDrawState ds;

	CMFCToolBarImages& images = (state == ImageBlack) ? m_ImagesBlack : (state == ImageGray) ? m_ImagesGray :
		(state == ImageDkGray) ? m_ImagesDkGray : (state == ImageLtGray) ? m_ImagesLtGray : (state == ImageWhite) ? m_ImagesWhite : m_ImagesBlack2;

	images.PrepareDrawImage(ds, sizeImage);
	images.Draw(pDC, ptImage.x, ptImage.y, id);
	images.EndDrawImage(ds);
}

void __stdcall CMenuImages::Draw(CDC* pDC, IMAGES_IDS id, const CRect& rectImage, CMenuImages::IMAGE_STATE state, const CSize& sizeImageDest/* = CSize(0, 0)*/)
{
	const CSize sizeImage = (sizeImageDest == CSize(0, 0)) ? Size() : sizeImageDest;

	CPoint ptImage(rectImage.left +(rectImage.Width() - sizeImage.cx) / 2 +((rectImage.Width() - sizeImage.cx) % 2),
		rectImage.top +(rectImage.Height() - sizeImage.cy) / 2 +((rectImage.Height() - sizeImage.cy) % 2));

	Draw(pDC, id, ptImage, state, sizeImageDest);
}

void __stdcall CMenuImages::CleanUp()
{
	if (m_bInitializing)
	{
		return;
	}

	if (m_ImagesBlack.GetCount() > 0)
	{
		m_ImagesBlack.Clear();
		m_ImagesGray.Clear();
		m_ImagesDkGray.Clear();
		m_ImagesLtGray.Clear();
		m_ImagesWhite.Clear();
		m_ImagesBlack2.Clear();
	}
}

void __stdcall CMenuImages::CreateCopy(CMFCToolBarImages& images, COLORREF clr)
{
	m_ImagesBlack.CopyTo(images);
	images.MapTo3dColors(TRUE, RGB(0, 0, 0), clr);
}

void __stdcall CMenuImages::SetColor(CMenuImages::IMAGE_STATE state, COLORREF color)
{
	Initialize();

	CMFCToolBarImages imagesTmp;

	imagesTmp.SetImageSize (CSize (nImageWidth, nImageHeight));
	imagesTmp.Load(afxGlobalData.Is32BitIcons() ? IDB_AFXBARRES_MENU_IMAGES24 : IDB_AFXBARRES_MENU_IMAGES);
	imagesTmp.SetTransparentColor(clrTransparent);

	if (imagesTmp.IsRTL())
	{
		CMFCToolBarImages::MirrorBitmap(imagesTmp.m_hbmImageWell, imagesTmp.GetImageSize().cx);
	}

	CMFCToolBarImages& images = (state == ImageBlack) ? m_ImagesBlack : (state == ImageGray) ? m_ImagesGray :
		(state == ImageDkGray) ? m_ImagesDkGray : (state == ImageLtGray) ? m_ImagesLtGray : (state == ImageWhite) ? m_ImagesWhite : m_ImagesBlack2;

	if (color != (COLORREF)-1)
	{
		imagesTmp.MapTo3dColors(TRUE, RGB(0, 0, 0), color);
	}

	if (!m_bInitializing)
	{
		imagesTmp.SmoothResize(afxGlobalData.GetRibbonImageScale());
	}

	images.Clear();
	imagesTmp.CopyTo(images);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmenutearoffmanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxmenutearoffmanager.h"
#include "afxwinappex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

CMenuTearOffManager* g_pTearOffMenuManager = NULL;

static const TCHAR cIDChar = 1;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMenuTearOffManager::CMenuTearOffManager() : m_uiTearOffMenuFirst(0), m_uiTearOffMenuLast(0)
{
}

CMenuTearOffManager::~CMenuTearOffManager()
{
	g_pTearOffMenuManager = NULL;
}

BOOL CMenuTearOffManager::Initialize( LPCTSTR lpszRegEntry, UINT uiTearOffMenuFirst, UINT uiTearOffMenuLast)
{
	ENSURE(g_pTearOffMenuManager != NULL);
	ASSERT(uiTearOffMenuLast >= uiTearOffMenuFirst);

	if (uiTearOffMenuFirst == 0 || uiTearOffMenuLast == 0)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	g_pTearOffMenuManager = this;

	m_uiTearOffMenuFirst = uiTearOffMenuFirst;
	m_uiTearOffMenuLast = uiTearOffMenuLast;

	CWinAppEx* pApp = DYNAMIC_DOWNCAST(CWinAppEx, AfxGetApp());

	m_strTearOffBarRegEntry = (lpszRegEntry == NULL) ? ( pApp ? pApp->GetRegSectionPath() : _T("")) : lpszRegEntry;

	int nCount = uiTearOffMenuLast - uiTearOffMenuFirst + 1;
	m_arTearOffIDsUsage.SetSize(nCount);

	for (int i = 0; i < nCount; i ++)
	{
		m_arTearOffIDsUsage [i] = 0;
	}

	return TRUE;
}

void CMenuTearOffManager::Reset(HMENU hMenu)
{
	int nCount = m_uiTearOffMenuLast - m_uiTearOffMenuFirst + 1;

	if (hMenu == NULL) // Reset all
	{
		for (int i = 0; i < nCount; i ++)
		{
			m_arTearOffIDsUsage [i] = 0;
		}

		return;
	}

	CMenu* pMenu = CMenu::FromHandle(hMenu);
	if (pMenu == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	int iCount = pMenu->GetMenuItemCount();
	for (int i = 0; i < iCount; i ++)
	{
		CString str;
		pMenu->GetMenuString(i, str, MF_BYPOSITION);

		UINT uiTearOffID = Parse(str);
		if (uiTearOffID >= m_uiTearOffMenuFirst && uiTearOffID <= m_uiTearOffMenuLast)
		{
			m_arTearOffIDsUsage [uiTearOffID - m_uiTearOffMenuFirst] = 0;
		}

		if (pMenu->GetMenuItemID(i) == (UINT)-1)
		{
			CMenu* pPopupMenu = pMenu->GetSubMenu(i);
			ENSURE(pPopupMenu != NULL);

			Reset(pPopupMenu->GetSafeHmenu());
		}
	}
}

UINT CMenuTearOffManager::GetFreeTearOffID()
{
	if (m_uiTearOffMenuFirst == 0 || m_uiTearOffMenuLast == 0)
	{
		ASSERT(FALSE);
		return 0;
	}

	int nCount = m_uiTearOffMenuLast - m_uiTearOffMenuFirst + 1;
	for (int i = 0; i < nCount; i ++)
	{
		if (m_arTearOffIDsUsage [i] == 0)
		{
			m_arTearOffIDsUsage [i] = 1;
			return m_uiTearOffMenuFirst + i;
		}
	}

	return 0;
}

void CMenuTearOffManager::SetupTearOffMenus(HMENU hMenu)
{
	ENSURE(hMenu != NULL);

	CMenu* pMenu = CMenu::FromHandle(hMenu);
	if (pMenu == NULL)
	{
		return;
	}

	int iCount = pMenu->GetMenuItemCount();
	for (int i = 0; i < iCount; i ++)
	{
		UINT uiID = pMenu->GetMenuItemID(i);
		if (uiID != (UINT) -1)
		{
			continue;
		}

		UINT uiState = pMenu->GetMenuState(i, MF_BYPOSITION);
		if (uiState & MF_MENUBARBREAK)
		{
			CString str;
			pMenu->GetMenuString(i, str, MF_BYPOSITION);

			if (str [0] != cIDChar)
			{
				UINT uiCtrlBarId = GetFreeTearOffID();
				if (uiCtrlBarId == 0) // No more free IDs!
				{ // Reserve more IDs in Initialize!!!
					ASSERT(FALSE);
					return;
				}

				Build(uiCtrlBarId, str);
				pMenu->ModifyMenu(i, MF_BYPOSITION, i, str);
			}
		}

		CMenu* pPopupMenu = pMenu->GetSubMenu(i);
		if (pPopupMenu != NULL)
		{
			SetupTearOffMenus(pPopupMenu->GetSafeHmenu());
		}
	}
}

void CMenuTearOffManager::SetInUse(UINT uiCmdId, BOOL bUse/* = TRUE*/)
{
	if (uiCmdId < m_uiTearOffMenuFirst || uiCmdId > m_uiTearOffMenuLast)
	{
		return;
	}

	int nDelta = bUse ? 1 : -1;
	int iIndex = uiCmdId - m_uiTearOffMenuFirst;

	m_arTearOffIDsUsage [iIndex] += nDelta;

	if (m_arTearOffIDsUsage [iIndex] < 0)
	{
		m_arTearOffIDsUsage [iIndex] = 0;
	}
}

UINT CMenuTearOffManager::Parse(CString& str)
{
	if (str.IsEmpty() || str [0] != cIDChar)
	{
		return 0;
	}

	UINT uiID = _ttol(str.Mid(1));
	ASSERT(uiID != 0);

	int iOffset = str.ReverseFind(cIDChar);
	if (iOffset == -1)
	{
		ASSERT(FALSE);
		return 0;
	}

	str = str.Mid(iOffset + 1);
	return uiID;
}

void CMenuTearOffManager::Build(UINT uiTearOffBarID, CString& strText)
{
	ASSERT(uiTearOffBarID != 0);

	CString strNew;
	strNew.Format(_T("%c%d%c%s"), cIDChar, uiTearOffBarID, cIDChar, (LPCTSTR)strText);
	strText = strNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmenubutton.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxmenuimages.h"
#include "afxcontrolbarutil.h"
#include "afxmenubutton.h"
#include "afxcontextmenumanager.h"
#include "afxpopupmenu.h"
#include "afxtagmanager.h"
#include "afxctrlcontainer.h"
#include "afxdialogex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const int nImageHorzMargin = 10;

/////////////////////////////////////////////////////////////////////////////
// CMFCMenuButton

IMPLEMENT_DYNAMIC(CMFCMenuButton, CMFCButton)

CMFCMenuButton::CMFCMenuButton()
{
	m_bRightArrow = FALSE;
	m_hMenu = NULL;
	m_nMenuResult = 0;
	m_bMenuIsActive = FALSE;
	m_bStayPressed = FALSE;
	m_bOSMenu = TRUE;
	m_bDefaultClick = FALSE;
	m_bClickOnMenu = FALSE;
}

CMFCMenuButton::~CMFCMenuButton()
{
}

BEGIN_MESSAGE_MAP(CMFCMenuButton, CMFCButton)
	//{{AFX_MSG_MAP(CMFCMenuButton)
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONDOWN()
	ON_WM_GETDLGCODE()
	ON_WM_LBUTTONUP()
	ON_WM_KILLFOCUS()
	ON_WM_LBUTTONDBLCLK()
	ON_MESSAGE(WM_MFC_INITCTRL, &CMFCMenuButton::OnInitControl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCMenuButton message handlers

CSize CMFCMenuButton::SizeToContent(BOOL bCalcOnly)
{
	CSize size = CMFCButton::SizeToContent(FALSE);
	size.cx += CMenuImages::Size().cx;

	if (!bCalcOnly)
	{
		SetWindowPos(NULL, -1, -1, size.cx, size.cy, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
	}

	return size;
}

void CMFCMenuButton::OnDraw(CDC* pDC, const CRect& rect, UINT uiState)
{
	ASSERT_VALID(pDC);

	CSize sizeArrow = CMenuImages::Size();

	CRect rectParent = rect;
	rectParent.right -= sizeArrow.cx + nImageHorzMargin;

	CMFCButton::OnDraw(pDC, rectParent, uiState);

	CRect rectArrow = rect;
	rectArrow.left = rectParent.right;

	CMenuImages::Draw(pDC, m_bRightArrow ? CMenuImages::IdArrowRightLarge : CMenuImages::IdArrowDownLarge,
		rectArrow, (uiState & ODS_DISABLED) ? CMenuImages::ImageGray : CMenuImages::ImageBlack);

	if (m_bDefaultClick)
	{
		//----------------
		// Draw separator:
		//----------------
		CRect rectSeparator = rectArrow;
		rectSeparator.right = rectSeparator.left + 2;
		rectSeparator.DeflateRect(0, 2);

		if (!m_bWinXPTheme || m_bDontUseWinXPTheme)
		{
			rectSeparator.left += m_sizePushOffset.cx;
			rectSeparator.top += m_sizePushOffset.cy;
		}

		pDC->Draw3dRect(rectSeparator, afxGlobalData.clrBtnDkShadow, afxGlobalData.clrBtnHilite);
	}
}

void CMFCMenuButton::OnShowMenu()
{
	if (m_hMenu == NULL || m_bMenuIsActive)
	{
		return;
	}

	CRect rectWindow;
	GetWindowRect(rectWindow);

	int x, y;

	if (m_bRightArrow)
	{
		x = rectWindow.right;
		y = rectWindow.top;
	}
	else
	{
		x = rectWindow.left;
		y = rectWindow.bottom;
	}

	if (m_bStayPressed)
	{
		m_bPushed = TRUE;
		m_bHighlighted = TRUE;
	}

	m_bMenuIsActive = TRUE;
	Invalidate();

	if (!m_bOSMenu && afxContextMenuManager != NULL)
	{
		m_nMenuResult = afxContextMenuManager->TrackPopupMenu(m_hMenu, x, y, this);
		SetFocus();
	}
	else
	{
		m_nMenuResult = ::TrackPopupMenu(m_hMenu, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, x, y, 0, GetSafeHwnd(), NULL);
	}

	CWnd* pParent = GetParent();

#ifdef _DEBUG
	if ((pParent->IsKindOf(RUNTIME_CLASS(CDialog))) && (!pParent->IsKindOf(RUNTIME_CLASS(CDialogEx))))
	{
		TRACE(_T("CMFCMenuButton parent is CDialog, should be CDialogEx for popup menu handling to work correctly.\n"));
	}
#endif

	if (m_nMenuResult != 0)
	{
		//-------------------------------------------------------
		// Trigger mouse up event(to button click notification):
		//-------------------------------------------------------
		if (pParent != NULL)
		{
			pParent->SendMessage( WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM) m_hWnd);
		}
	}

	m_bPushed = FALSE;
	m_bHighlighted = FALSE;
	m_bMenuIsActive = FALSE;

	Invalidate();
	UpdateWindow();

	if (m_bCaptured)
	{
		ReleaseCapture();
		m_bCaptured = FALSE;
	}
}

void CMFCMenuButton::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_SPACE || nChar == VK_DOWN)
	{
		m_bClickOnMenu = TRUE;
		OnShowMenu();
		return;
	}

	CButton::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CMFCMenuButton::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (m_bMenuIsActive)
	{
		Default();
		return;
	}

	m_bClickOnMenu = TRUE;

	if (m_bDefaultClick)
	{
		CRect rectClient;
		GetClientRect(rectClient);

		CRect rectArrow = rectClient;
		rectArrow.left = rectArrow.right - CMenuImages::Size().cx - nImageHorzMargin;

		if (!rectArrow.PtInRect(point))
		{
			m_bClickOnMenu = FALSE;
			m_nMenuResult = 0;
			CMFCButton::OnLButtonDown(nFlags, point);
			return;
		}
	}

	SetFocus();
	OnShowMenu();
}

UINT CMFCMenuButton::OnGetDlgCode()
{
	return DLGC_WANTARROWS;
}

void CMFCMenuButton::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bStayPressed && m_bMenuIsActive && m_bPushed)
	{
		m_bClickiedInside = FALSE;

		CButton::OnLButtonUp(nFlags, point);

		if (m_bCaptured)
		{
			ReleaseCapture();
			m_bCaptured = FALSE;
		}
	}
	else if (!m_bClickOnMenu)
	{
		CMFCButton::OnLButtonUp(nFlags, point);
	}
}

void CMFCMenuButton::OnKillFocus(CWnd* pNewWnd)
{
	if (m_bStayPressed && m_bMenuIsActive && m_bPushed)
	{
		CButton::OnKillFocus(pNewWnd);

		if (m_bCaptured)
		{
			ReleaseCapture();
			m_bCaptured = FALSE;
		}

		m_bClickiedInside = FALSE;
		m_bHover = FALSE;
	}
	else
	{
		CMFCButton::OnKillFocus(pNewWnd);
	}
}

BOOL CMFCMenuButton::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN &&
		pMsg->wParam == VK_RETURN &&
		CMFCPopupMenu::GetActiveMenu() == NULL)
	{
		m_bClickOnMenu = TRUE;
		OnShowMenu();
		return TRUE;
	}

	return CMFCButton::PreTranslateMessage(pMsg);
}

void CMFCMenuButton::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	if (!m_bMenuIsActive)
	{
		CMFCButton::OnLButtonDblClk(nFlags, point);
		m_bClickOnMenu = FALSE;
	}
	if (m_bCaptured)
	{
		ReleaseCapture ();
		m_bCaptured = FALSE;
	}
}

LRESULT CMFCMenuButton::OnInitControl(WPARAM wParam, LPARAM lParam)
{
	DWORD dwSize = (DWORD)wParam;
	BYTE* pbInitData = (BYTE*)lParam;

	CString strDst;
	CMFCControlContainer::UTF8ToString((LPSTR)pbInitData, strDst, dwSize);

	CTagManager tagManager(strDst);

	BOOL bOSMenu = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCMenuButton_OSMenu, bOSMenu))
	{
		m_bOSMenu = bOSMenu;
	}

	BOOL bRightArrow = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCMenuButton_RightArrow, bRightArrow))
	{
		m_bRightArrow = bRightArrow;
	}

	BOOL bStayPressed = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCMenuButton_StayPressed, bStayPressed))
	{
		m_bStayPressed = bStayPressed;
	}

	BOOL bDefaultClick = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCMenuButton_DefaultClick, bDefaultClick))
	{
		m_bDefaultClick = bDefaultClick;
	}

	BOOL bAutosize = FALSE;
	if (CMFCControlContainer::ReadBoolProp(tagManager, PS_MFCMenuButton_Autosize, bAutosize))
	{
		if (bAutosize)
		{
			SizeToContent();
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmousemanager.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxmousemanager.h"
#include "afxsettingsstore.h"
#include "afxregpath.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const CString strRegEntryName = _T("Mouse");
static const CString strMouseProfile = _T("MouseManager");

CMouseManager* afxMouseManager = NULL;

IMPLEMENT_SERIAL(CMouseManager, CObject, 1)

// Construction/Destruction
CMouseManager::CMouseManager()
{
	ENSURE(afxMouseManager == NULL);
	afxMouseManager = this;
}

CMouseManager::~CMouseManager()
{
	afxMouseManager = NULL;
}

BOOL CMouseManager::AddView(int iViewId, UINT uiViewNameResId, UINT uiIconId)
{
	CString strViewName;
	ENSURE(strViewName.LoadString(uiViewNameResId));

	return AddView(iViewId, strViewName, uiIconId);
}

BOOL CMouseManager::AddView(int iViewId, LPCTSTR lpszViewName, UINT uiIconId)
{
	ENSURE(lpszViewName != NULL);

	int iId;
	if (m_ViewsNames.Lookup(lpszViewName, iId)) // Already exist
	{
		return FALSE;
	}

	m_ViewsNames.SetAt(lpszViewName, iViewId);

	if (uiIconId != 0)
	{
		m_ViewsToIcons.SetAt(iViewId, uiIconId);
	}

	return TRUE;
}

UINT CMouseManager::GetViewDblClickCommand(int iId) const
{
	UINT uiCmd;

	if (!m_ViewsToCommands.Lookup(iId, uiCmd))
	{
		return 0;
	}

	return uiCmd;
}

void CMouseManager::GetViewNames(CStringList& listOfNames) const
{
	listOfNames.RemoveAll();

	for (POSITION pos = m_ViewsNames.GetStartPosition(); pos != NULL;)
	{
		CString strName;
		int iId;

		m_ViewsNames.GetNextAssoc(pos, strName, iId);
		listOfNames.AddTail(strName);
	}
}

int CMouseManager::GetViewIdByName(LPCTSTR lpszName) const
{
	ENSURE(lpszName != NULL);

	int iId;

	if (!m_ViewsNames.Lookup(lpszName, iId))
	{
		return -1;
	}

	return iId;
}

BOOL CMouseManager::LoadState(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strMouseProfile, lpszProfileName);

	BOOL bResult = FALSE;

	LPBYTE lpbData = NULL;
	UINT uiDataSize;

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strProfileName))
	{
		TRACE(_T("CMouseManager::LoadState: Can't open registry %s!\n"), strProfileName);
		return FALSE;
	}

	if (!reg.Read(strRegEntryName, &lpbData, &uiDataSize))
	{
		TRACE(_T("CMouseManager::LoadState: Can't load registry data %s!\n"), strProfileName);
		return FALSE;
	}

	try
	{
		CMemFile file(lpbData, uiDataSize);
		CArchive ar(&file, CArchive::load);

		Serialize(ar);
		bResult = TRUE;
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMouseManager::LoadState()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CMouseManager::LoadState()!\n"));
	}

	if (lpbData != NULL)
	{
		delete [] lpbData;
	}

	return bResult;
}

BOOL CMouseManager::SaveState(LPCTSTR lpszProfileName)
{
	CString strProfileName = ::AFXGetRegPath(strMouseProfile, lpszProfileName);

	BOOL bResult = FALSE;

	try
	{
		CMemFile file;

		{
			CArchive ar(&file, CArchive::store);

			Serialize(ar);
			ar.Flush();
		}

		UINT uiDataSize = (UINT) file.GetLength();
		LPBYTE lpbData = file.Detach();

		if (lpbData != NULL)
		{
			CSettingsStoreSP regSP;
			CSettingsStore& reg = regSP.Create(FALSE, FALSE);

			if (reg.CreateKey(strProfileName))
			{
				bResult = reg.Write(strRegEntryName, lpbData, uiDataSize);
			}

			free(lpbData);
		}
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMouseManager::SaveState()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CArchiveException exception in CMouseManager::SaveState()!\n"));
	}

	return bResult;
}

void CMouseManager::Serialize(CArchive& ar)
{
	CObject::Serialize(ar);

	if (ar.IsLoading())
	{
		m_ViewsToCommands.RemoveAll();

		int iCount;
		ar >> iCount;

		for (int i = 0; i < iCount; i ++)
		{
			int iViewId;
			ar >> iViewId;

			UINT uiCmd;
			ar >> uiCmd;

			m_ViewsToCommands.SetAt(iViewId, uiCmd);
		}
	}
	else
	{
		int iCount = (int) m_ViewsToCommands.GetCount();
		ar << iCount;

		for (POSITION pos = m_ViewsToCommands.GetStartPosition(); pos != NULL;)
		{
			int iViewId;
			UINT uiCmd;

			m_ViewsToCommands.GetNextAssoc(pos, iViewId, uiCmd);

			ar << iViewId;
			ar << uiCmd;
		}
	}
}

void CMouseManager::SetCommandForDblClk(int iViewId, UINT uiCmd)
{
	if (uiCmd > 0)
	{
		m_ViewsToCommands.SetAt(iViewId, uiCmd);
	}
	else
	{
		m_ViewsToCommands.RemoveKey(iViewId);
	}
}

UINT CMouseManager::GetViewIconId(int iViewId) const
{
	UINT uiIconId;
	if (!m_ViewsToIcons.Lookup(iViewId, uiIconId))
	{
		return 0;
	}

	return uiIconId;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmousepropertypage.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "afxglobals.h"
#include "afxtoolbarscustomizedialog.h"
#include "afxmousepropertypage.h"
#include "afxmousemanager.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCMousePropertyPage property page

IMPLEMENT_DYNCREATE(CMFCMousePropertyPage, CPropertyPage)

CMFCMousePropertyPage::CMFCMousePropertyPage() : CPropertyPage(CMFCMousePropertyPage::IDD)
{
	m_strCommandDescription = _T("");
	m_iCurrViewId = -1;
}

CMFCMousePropertyPage::~CMFCMousePropertyPage()
{
}

void CMFCMousePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMFCMousePropertyPage)
	DDX_Control(pDX, IDC_AFXBARRES_LIST_VIEWS, m_wndListOfViews);
	DDX_Control(pDX, IDC_AFXBARRES_LIST_OF_COMMANDS, m_wndListOfCommands);
	DDX_Control(pDX, IDC_AFXBARRES_COMMAND_DESCRIPTION, m_wndCommandDescription);
	DDX_Text(pDX, IDC_AFXBARRES_COMMAND_DESCRIPTION, m_strCommandDescription);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMFCMousePropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMFCMousePropertyPage)
	ON_BN_CLICKED(IDC_AFXBARRES_NO_DBLCLIICK, &CMFCMousePropertyPage::OnNoDblcliick)
	ON_BN_CLICKED(IDC_AFXBARRES_USE_DBLCLIICK, &CMFCMousePropertyPage::OnUseDblcliick)
	ON_LBN_SELCHANGE(IDC_AFXBARRES_LIST_OF_COMMANDS, &CMFCMousePropertyPage::OnSelchangeListOfCommands)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_AFXBARRES_LIST_VIEWS, &CMFCMousePropertyPage::OnItemchangedListViews)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCMousePropertyPage message handlers

void CMFCMousePropertyPage::OnNoDblcliick()
{
	afxMouseManager->SetCommandForDblClk(m_iCurrViewId, 0);
	EnableDblClkControls(FALSE);
}

void CMFCMousePropertyPage::OnUseDblcliick()
{
	EnableDblClkControls();

	if (m_iCurrViewId < 0)
	{
		MessageBeep((UINT) -1);
		return;
	}

	afxMouseManager->SetCommandForDblClk(m_iCurrViewId, 0);
}

void CMFCMousePropertyPage::OnSelchangeListOfCommands()
{
	ENSURE(afxMouseManager != NULL);

	if (m_iCurrViewId < 0)
	{
		MessageBeep((UINT) -1);
		return;
	}

	int iIndex = m_wndListOfCommands.GetCurSel();
	UINT uiCmdId = (UINT) m_wndListOfCommands.GetItemData(iIndex);

	// Get command description:
	CFrameWnd* pParent = GetParentFrame();
	if (pParent != NULL && pParent->GetSafeHwnd() != NULL)
	{
		pParent->GetMessageString(uiCmdId, m_strCommandDescription);
	}
	else
	{
		m_strCommandDescription.Empty();
	}

	// Update mouse manager:
	afxMouseManager->SetCommandForDblClk(m_iCurrViewId, uiCmdId);

	UpdateData(FALSE);
}

void CMFCMousePropertyPage::OnItemchangedListViews(NMHDR* pNMHDR, LRESULT* pResult)
{
	ENSURE(afxMouseManager != NULL);

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	ENSURE(pNMListView != NULL);

	*pResult = 0;

	if (pNMListView->uChanged != LVIF_STATE)
	{
		return;
	}

	for (int i = 0; i < m_wndListOfViews.GetItemCount(); i ++)
	{
		UINT uState = m_wndListOfViews.GetItemState(i, LVIF_STATE | LVIS_SELECTED);
		if (uState & LVIS_SELECTED)
		{
			m_iCurrViewId = (int) m_wndListOfViews.GetItemData(i);
			ASSERT(m_iCurrViewId >= 0);

			UINT uiCmd = afxMouseManager->GetViewDblClickCommand(m_iCurrViewId);
			if (uiCmd == 0)
			{
				CheckDlgButton(IDC_AFXBARRES_USE_DBLCLIICK, 0);
				CheckDlgButton(IDC_AFXBARRES_NO_DBLCLIICK, 1);
				EnableDblClkControls(FALSE);
			}
			else
			{
				CheckDlgButton(IDC_AFXBARRES_USE_DBLCLIICK, 1);
				CheckDlgButton(IDC_AFXBARRES_NO_DBLCLIICK, 0);
				EnableDblClkControls();
				SelectCommand(uiCmd);
			}

			break;
		}
	}
}

BOOL CMFCMousePropertyPage::OnInitDialog()
{
	ENSURE(afxMouseManager != NULL);

	CPropertyPage::OnInitDialog();

	CStringList listOfViewNames;
	afxMouseManager->GetViewNames(listOfViewNames);

	// Create image list:
	if (!m_ViewsImages.Create( afxGlobalData.m_sizeSmallIcon.cx, afxGlobalData.m_sizeSmallIcon.cy, ILC_COLOR | ILC_MASK, (int) listOfViewNames.GetCount(), 1))
	{
		ASSERT(FALSE);
	}

	m_wndListOfViews.SetImageList(&m_ViewsImages, LVSIL_SMALL);

	POSITION pos;

	// Fill views list:
	CRect rect;
	m_wndListOfViews.GetClientRect(&rect);
	m_wndListOfViews.InsertColumn(0, _T(""), LVCFMT_LEFT, rect.Width() - 1);

	ASSERT(!listOfViewNames.IsEmpty());

	int iMaxWidth = 0;

	for (pos = listOfViewNames.GetHeadPosition(); pos != NULL;)
	{
		CString strViewName = listOfViewNames.GetNext(pos);

		int iImageIndex = -1;

		// Add view icon:
		UINT uiViewIconId = afxMouseManager->GetViewIconId(afxMouseManager->GetViewIdByName(strViewName));

		HICON hViewIcon;
		if (uiViewIconId != 0 && (hViewIcon = AfxGetApp()->LoadIcon(uiViewIconId)) != NULL)
		{
			iImageIndex = m_ViewsImages.Add(hViewIcon);
			::DestroyIcon(hViewIcon);
		}

		int iIndex = m_wndListOfViews.GetItemCount();
		for (int i = 0; i < m_wndListOfViews.GetItemCount(); i ++)
		{
			CString strText = m_wndListOfViews.GetItemText(i, 0);
			if (strText > strViewName)
			{
				iIndex = i;
				break;
			}
		}

		m_wndListOfViews.InsertItem(iIndex, strViewName, iImageIndex);
		m_wndListOfViews.SetItemData(iIndex, (DWORD) afxMouseManager->GetViewIdByName(strViewName));

		int iStrWidth = m_wndListOfViews.GetStringWidth(strViewName);
		iMaxWidth = max(iStrWidth, iMaxWidth);
	}

	// Add icon width pluse some pixels:
	IMAGEINFO info;
	m_ViewsImages.GetImageInfo(0, &info);
	CRect rectImage = info.rcImage;

	iMaxWidth += rectImage.Width() + 10;
	m_wndListOfViews.SetColumnWidth(0, iMaxWidth);

	// Fill commands list:
	CMFCToolBarsCustomizeDialog* pWndParent = DYNAMIC_DOWNCAST(CMFCToolBarsCustomizeDialog, GetParent());
	ENSURE(pWndParent != NULL);

	pWndParent->FillAllCommandsList(m_wndListOfCommands);

	// Select the first view:
	m_wndListOfViews.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
	m_wndListOfViews.EnsureVisible(0, FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CMFCMousePropertyPage::EnableDblClkControls(BOOL bEnable)
{
	m_wndListOfCommands.EnableWindow(bEnable);
	m_wndCommandDescription.EnableWindow(bEnable);

	if (!bEnable)
	{
		m_wndListOfCommands.SetCurSel(-1);

		m_strCommandDescription.Empty();
		UpdateData(FALSE);
	}
}

BOOL CMFCMousePropertyPage::SelectCommand(UINT uiCmd)
{
	// Get selected item description:
	CFrameWnd* pParent = GetParentFrame();
	if (pParent != NULL && pParent->GetSafeHwnd() != NULL)
	{
		pParent->GetMessageString(uiCmd, m_strCommandDescription);
	}
	else
	{
		m_strCommandDescription.Empty();
	}

	UpdateData(FALSE);

	// Select command in the commands listbox:
	for (int iCmdIndex = 0; iCmdIndex < m_wndListOfCommands.GetCount(); iCmdIndex ++)
	{
		if (uiCmd == (UINT) m_wndListOfCommands.GetItemData(iCmdIndex))
		{
			m_wndListOfCommands.SetCurSel(iCmdIndex);
			m_wndListOfCommands.SetTopIndex(iCmdIndex);

			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxolecntrframewndex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxpreviewviewex.h"
#include "afxpaneframewnd.h"
#include "afxolecntrframewndex.h"
#include "afxoledocipframewndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// COleCntrFrameWndEx

IMPLEMENT_DYNAMIC(COleCntrFrameWndEx, CFrameWnd)

COleCntrFrameWndEx::COleCntrFrameWndEx(COleIPFrameWnd* pInPlaceFrame) : COleCntrFrameWnd(pInPlaceFrame)
{
}

COleCntrFrameWndEx::~COleCntrFrameWndEx()
{
	POSITION pos = NULL;

	for (pos = m_dockManager.m_lstMiniFrames.GetHeadPosition(); pos != NULL;)
	{
		CPaneFrameWnd* pNextFrame = DYNAMIC_DOWNCAST(CPaneFrameWnd, m_dockManager.m_lstMiniFrames.GetNext(pos));
		if (pNextFrame != NULL)
		{
			pNextFrame->DestroyWindow();
		}
	}

	CList<HWND, HWND> lstChildren;
	CWnd* pNextWnd = GetTopWindow();
	while (pNextWnd != NULL)
	{
		lstChildren.AddTail(pNextWnd->m_hWnd);
		pNextWnd = pNextWnd->GetNextWindow();
	}

	for (pos = lstChildren.GetHeadPosition(); pos != NULL;)
	{
		HWND hwndNext = lstChildren.GetNext(pos);
		if (IsWindow(hwndNext) && ::GetParent(hwndNext) == m_hWnd)
		{
			::DestroyWindow(hwndNext);
		}
	}

	const CObList& list = CMFCToolBar::GetAllToolbars();
	CObList& afxAllToolBars = const_cast<CObList&>(list);

	for (pos = afxAllToolBars.GetHeadPosition(); pos != NULL;)
	{
		POSITION posSave = pos;

		CMFCToolBar* pToolBar = (CMFCToolBar*) afxAllToolBars.GetNext(pos);
		ENSURE(pToolBar != NULL);

		if (CWnd::FromHandlePermanent(pToolBar->m_hWnd) == NULL)
		{
			afxAllToolBars.RemoveAt(posSave);
		}
	}

}

//{{AFX_MSG_MAP(COleCntrFrameWndEx)
BEGIN_MESSAGE_MAP(COleCntrFrameWndEx, COleCntrFrameWnd)
	ON_WM_SIZE()
	ON_WM_SIZING()
	ON_MESSAGE_VOID(WM_IDLEUPDATECMDUI, COleCntrFrameWndEx::OnIdleUpdateCmdUI)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// COleCntrFrameWndEx message handlers

BOOL COleCntrFrameWndEx::DockPaneLeftOf(CPane* pBar, CPane* pLeftOf)
{
	m_dockManager.DockPaneLeftOf(pBar, pLeftOf);
	return TRUE;
}

void COleCntrFrameWndEx::OnSize(UINT nType, int cx, int cy)
{
	COleCntrFrameWnd::OnSize(nType, cx, cy);

	if (nType != SIZE_MINIMIZED)
	{
		AdjustDockingLayout();
	}
}

BOOL COleCntrFrameWndEx::PreCreateWindow(CREATESTRUCT& cs)
{
	m_dockManager.Create(this);

	return COleCntrFrameWnd::PreCreateWindow(cs);
}

void COleCntrFrameWndEx::AddDockSite()
{
	ASSERT_VALID(this);
}

BOOL COleCntrFrameWndEx::AddPane(CBasePane* pControlBar, BOOL bTail)
{
	ASSERT_VALID(this);
	return m_dockManager.AddPane(pControlBar, bTail);
}

BOOL COleCntrFrameWndEx::InsertPane(CBasePane* pControlBar, CBasePane* pTarget, BOOL bAfter)
{
	ASSERT_VALID(this);
	return m_dockManager.InsertPane(pControlBar, pTarget, bAfter);
}

void COleCntrFrameWndEx::RemovePaneFromDockManager(CBasePane* pControlBar, BOOL bDestroy, BOOL bAdjustLayout, BOOL bAutoHide, CBasePane* pBarReplacement)
{
	ASSERT_VALID(this);
	m_dockManager.RemovePaneFromDockManager(pControlBar, bDestroy, bAdjustLayout, bAutoHide, pBarReplacement);
	AdjustDockingLayout();
}

void COleCntrFrameWndEx::DockPane(CBasePane* pBar, UINT nDockBarID, LPCRECT lpRect)
{
	ASSERT_VALID(this);
	m_dockManager.DockPane(pBar, nDockBarID, lpRect);
	AdjustDockingLayout();
}

CBasePane* COleCntrFrameWndEx::GetPane(UINT nID)
{
	ASSERT_VALID(this);

	return m_dockManager.FindPaneByID(nID, TRUE);
}

void COleCntrFrameWndEx::ShowPane(CBasePane* pBar, BOOL bShow, BOOL bDelay, BOOL bActivate)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	pBar->ShowPane(bShow, bDelay, bActivate);
}

CBasePane* COleCntrFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, bool bExactBar, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, bExactBar, pRTCBarType);
}

CBasePane* COleCntrFrameWndEx::PaneFromPoint(CPoint point, int nSensitivity, DWORD& dwAlignment, CRuntimeClass* pRTCBarType) const
{
	ASSERT_VALID(this);
	return m_dockManager.PaneFromPoint(point, nSensitivity, dwAlignment, pRTCBarType);
}

BOOL COleCntrFrameWndEx::IsPointNearDockSite(CPoint point, DWORD& dwBarAlignment, BOOL& bOuterEdge) const
{
	ASSERT_VALID(this);
	return m_dockManager.IsPointNearDockSite(point, dwBarAlignment, bOuterEdge);
}

void COleCntrFrameWndEx::AdjustDockingLayout(HDWP /*hdwp*/)
{
	ASSERT_VALID(this);
	AdjustClientArea();
}

BOOL COleCntrFrameWndEx::OnMoveMiniFrame(CWnd* pFrame)
{
	ASSERT_VALID(this);
	return m_dockManager.OnMoveMiniFrame(pFrame);
}

BOOL COleCntrFrameWndEx::EnableDocking(DWORD dwDockStyle)
{
	return m_dockManager.EnableDocking(dwDockStyle);
}

BOOL COleCntrFrameWndEx::EnableAutoHidePanes(DWORD dwDockStyle)
{
	return m_dockManager.EnableAutoHidePanes(dwDockStyle);
}

void COleCntrFrameWndEx::RecalcLayout(BOOL bNotify)
{
	AdjustClientArea();
	m_dockManager.AdjustDockingLayout();
	m_dockManager.RecalcLayout(bNotify);

	CView* pView = GetActiveView();
	if (pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPreviewViewEx)) && m_dockManager.IsPrintPreviewValid())
	{
		CRect rectClient = m_dockManager.GetClientAreaBounds();
		pView->SetWindowPos(NULL, rectClient.left, rectClient.top, rectClient.Width(), rectClient.Height(), SWP_NOZORDER  | SWP_NOACTIVATE);
	}

	m_pInPlaceFrame->RecalcLayout(bNotify);
}

void COleCntrFrameWndEx::OnSizing(UINT fwSide, LPRECT pRect)
{
	COleCntrFrameWnd::OnSizing(fwSide, pRect);

	CRect rect;
	GetWindowRect(rect);

	if (rect.Size() != CRect(pRect).Size())
	{
		AdjustDockingLayout();
	}
}

void COleCntrFrameWndEx::OnIdleUpdateCmdUI()
{
	COleCntrFrameWnd::OnIdleUpdateCmdUI();

	// update control bars
	m_dockManager.SendMessageToMiniFrames(WM_IDLEUPDATECMDUI);

	POSITION pos = m_dockManager.m_lstControlBars.GetHeadPosition();
	while (pos != NULL)
	{
		CBasePane* pBar = (CBasePane*)m_dockManager.m_lstControlBars.GetNext(pos);
		ENSURE(pBar != NULL);
		ASSERT_VALID(pBar);

		pBar->SendMessageToDescendants(WM_IDLEUPDATECMDUI, (WPARAM) TRUE);
	}
}

BOOL COleCntrFrameWndEx::OnShowPanes(BOOL bShow)
{
	ASSERT_VALID(this);
	BOOL bResult = m_dockManager.ShowPanes(bShow);
	AdjustDockingLayout();

	return bResult;
}

void COleCntrFrameWndEx::AdjustClientArea()
{
	COleServerDoc* pDoc = (COleServerDoc*)m_pInPlaceFrame->GetActiveDocument();

	if (pDoc != NULL )
	{
		ASSERT_VALID(pDoc);
		ASSERT_KINDOF(COleServerDoc, pDoc);
		COleDocIPFrameWndEx* pFrame = (COleDocIPFrameWndEx*)m_pInPlaceFrame;

		pDoc->OnResizeBorder(NULL, pFrame->m_lpFrame, TRUE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxmultipaneframewnd.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxmultipaneframewnd.h"
#include "afxglobalutils.h"
#include "afxdockingmanager.h"
#include "afxdockablepane.h"
#include "afxpanedivider.h"

#include "afxbasetabbedpane.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

IMPLEMENT_SERIAL(CMultiPaneFrameWnd,CPaneFrameWnd,VERSIONABLE_SCHEMA | 2)

/////////////////////////////////////////////////////////////////////////////
// CMultiPaneFrameWnd

CMultiPaneFrameWnd::CMultiPaneFrameWnd()
{
	m_hWndLastFocused = NULL;
	m_bHostsToolbar = FALSE;
}

CMultiPaneFrameWnd::~CMultiPaneFrameWnd()
{
}

//{{AFX_MSG_MAP(CMultiPaneFrameWnd)
BEGIN_MESSAGE_MAP(CMultiPaneFrameWnd, CPaneFrameWnd)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_SIZING()
	ON_WM_GETMINMAXINFO()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SETFOCUS()
	ON_MESSAGE(WM_IDLEUPDATECMDUI, &CMultiPaneFrameWnd::OnIdleUpdateCmdUI)
	ON_REGISTERED_MESSAGE(AFX_WM_CHECKEMPTYMINIFRAME, &CMultiPaneFrameWnd::OnCheckEmptyState)
END_MESSAGE_MAP()
//}}AFX_MSG_MAP

/////////////////////////////////////////////////////////////////////////////
// CMultiPaneFrameWnd message handlers

int CMultiPaneFrameWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPaneFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_barContainerManager.Create(this, NULL);
	return 0;
}

// Should return TRUE if no docking occures!!!

BOOL CMultiPaneFrameWnd::DockFrame(CPaneFrameWnd* pDockedFrame, AFX_DOCK_METHOD dockMethod)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDockedFrame);

	CMultiPaneFrameWnd* pMultiDockedFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, pDockedFrame);

	if (pMultiDockedFrame == NULL )
	{
		// we can dock only multi mini frame windows!
		//(their dock bars have CBRS_FLOAT_MULTI style)
		return TRUE;
	}

	CBasePane* pFirstBar = DYNAMIC_DOWNCAST(CBasePane, pMultiDockedFrame->GetFirstVisiblePane());
	if (pFirstBar == NULL || pFirstBar->GetEnabledAlignment() == 0)
	{
		return TRUE;
	}

	CDockablePane* pTargetControlBar = NULL;
	BOOL bTabArea = FALSE;
	BOOL bCaption = FALSE;
	DWORD dwAlignment = CBRS_ALIGN_LEFT;

	CPoint pt;
	GetCursorPos(&pt);

	if (dockMethod == DM_MOUSE || dockMethod == DM_STANDARD)
	{
		CGlobalUtils globalUtilsLocal;
		if (!globalUtilsLocal.GetPaneAndAlignFromPoint(m_barContainerManager, pt, &pTargetControlBar, dwAlignment, bTabArea, bCaption))
		{
			return TRUE;
		}
	}

	if (pTargetControlBar == NULL || dwAlignment == 0)
	{
		return TRUE;
	}

	CPaneContainerManager& barManager = pMultiDockedFrame->GetPaneContainerManager();
	CWnd* pFirstDockedBar = barManager.GetFirstVisiblePane();

	if ((bTabArea || bCaption) && pTargetControlBar != NULL)
	{
		// if the first bar is a tabbed bar it will be destroyed when adding to tab wnd
		// we need to take one of its tabs
		CBaseTabbedPane* pTabbedBar = DYNAMIC_DOWNCAST(CBaseTabbedPane, pFirstDockedBar);

		if (pTabbedBar != NULL)
		{
			int iTabNum = -1;
			pFirstDockedBar = pTabbedBar->GetFirstVisibleTab(iTabNum);
		}

		if (!m_barContainerManager.AddPaneContainerManagerToDockablePane(pTargetControlBar, barManager))
		{
			return TRUE;
		}
	}
	else
	{
		if (!m_barContainerManager.AddPaneContainerManager(pTargetControlBar, dwAlignment, barManager, TRUE))
		{
			return TRUE;
		}
	}

	HWND hDockedFrame = pDockedFrame->m_hWnd;
	pMultiDockedFrame->SendMessage(AFX_WM_CHECKEMPTYMINIFRAME);
	if (IsWindow(hDockedFrame))
	{
		pMultiDockedFrame->MoveWindow(pMultiDockedFrame->GetRecentFloatingRect());
	}

	OnPaneRecalcLayout();

	if (dockMethod == DM_MOUSE && pFirstDockedBar != NULL)
	{
		pFirstDockedBar->ScreenToClient(&pt);
		if (pFirstDockedBar->IsKindOf(RUNTIME_CLASS(CPane)))
		{
			((CPane*) pFirstDockedBar)->EnterDragMode(TRUE);
		}
		else
		{
			pFirstDockedBar->SendMessage(WM_LBUTTONDOWN, 0, MAKELPARAM(pt.x, pt.y));
		}

	}

	OnSetRollUpTimer();

	return FALSE;
}

BOOL CMultiPaneFrameWnd::DockPane(CDockablePane* pDockedBar)
{
	CPoint pt;
	GetCursorPos(&pt);

	BOOL bTabArea = FALSE;
	BOOL bCaption = FALSE;
	CDockablePane* pTargetControlBar = NULL;
	DWORD dwAlignment = 0;

	CGlobalUtils globalUtilsLocal;
	if (!globalUtilsLocal.GetPaneAndAlignFromPoint(m_barContainerManager, pt, &pTargetControlBar, dwAlignment, bTabArea, bCaption))
	{
		return TRUE;
	}

	if (pTargetControlBar == NULL || dwAlignment == 0)
	{
		return TRUE;
	}

	pDockedBar->UndockPane(FALSE);

	pDockedBar->SetParent(this);
	BOOL bResult = m_barContainerManager.InsertPane(pDockedBar, pTargetControlBar, dwAlignment);

	if (!bResult)
	{
		ASSERT(FALSE);
	}

	if (bResult)
	{
		AddRemovePaneFromGlobalList(pDockedBar, TRUE);
		CheckGripperVisibility();
		OnPaneRecalcLayout();
		SendMessage(WM_NCPAINT);
	}

	OnSetRollUpTimer();

	if (pDockedBar->CanFocus())
	{
		pDockedBar->SetFocus();
	}

	OnPaneRecalcLayout();

	return !bResult;
}

CDockablePane* CMultiPaneFrameWnd::DockPaneStandard(BOOL& bWasDocked)
{
	if (!OnBeforeDock())
	{
		return NULL;
	}

	CObList lstBars;
	m_barContainerManager.AddPanesToList(&lstBars, NULL);
	CList<HWND, HWND> lstBarsHwnd;

	for (POSITION pos = lstBars.GetHeadPosition(); pos != NULL;)
	{
		CWnd* pWnd = DYNAMIC_DOWNCAST(CWnd, lstBars.GetNext(pos));
		if (pWnd != NULL)
		{
			lstBarsHwnd.AddTail(pWnd->GetSafeHwnd());
		}
	}

	CBasePane* pTargetControlBar = m_dragFrameImpl.m_pFinalTargetBar;
	AFX_PREDOCK_STATE state = m_dragFrameImpl.m_bDockToTab ? PDS_DOCK_TO_TAB : PDS_DOCK_REGULAR;

	CPaneFrameWnd* pParentMiniFrame = NULL;

	if (pTargetControlBar != NULL)
	{
		pParentMiniFrame = pTargetControlBar->GetParentMiniFrame();
	}

	CWnd* pFocusWnd = GetFocus();

	if (pParentMiniFrame == NULL)
	{
		bWasDocked = !SetPreDockState(state, pTargetControlBar, DM_STANDARD);
	}
	else
	{
		CMultiPaneFrameWnd* pParentMultiMiniFrame = DYNAMIC_DOWNCAST(CMultiPaneFrameWnd, pParentMiniFrame);
		if (pParentMultiMiniFrame != NULL && pParentMultiMiniFrame != this)
		{
			bWasDocked = !pParentMultiMiniFrame->DockFrame(this, DM_STANDARD);
		}
	}

	if (pFocusWnd != NULL && ::IsWindow(pFocusWnd->GetSafeHwnd()))
	{
		pFocusWnd->SetFocus();
	}

	if (bWasDocked)
	{
		for (POSITION pos = lstBarsHwnd.GetHeadPosition(); pos != NULL;)
		{
			HWND hwnd = lstBarsHwnd.GetNext(pos);
			CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, CWnd::FromHandle(hwnd));
			if (pNextBar != NULL)
			{
				pNextBar->OnAfterDockFromMiniFrame();
			}
		}
	}

	return NULL;
}

void CMultiPaneFrameWnd::OnSetRollUpTimer()
{
	CObList lstControlBars;
	m_barContainerManager.AddPanesToList(&lstControlBars, NULL);

	for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pNextBar = DYNAMIC_DOWNCAST(CBasePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		if (pNextBar != NULL && pNextBar->GetControlBarStyle() & AFX_CBRS_AUTO_ROLLUP)
		{
			SetRollUpTimer();
			break;
		}
	}
}

void CMultiPaneFrameWnd::OnKillRollUpTimer()
{
	CObList lstControlBars;
	m_barContainerManager.AddPanesToList(&lstControlBars, NULL);

	BOOL bThereIsRollupState = FALSE;
	for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CBasePane* pNextBar = DYNAMIC_DOWNCAST(CBasePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		if (pNextBar != NULL && pNextBar->GetControlBarStyle() & AFX_CBRS_AUTO_ROLLUP)
		{
			bThereIsRollupState = TRUE;
			break;
		}
	}

	if (!bThereIsRollupState)
	{
		KillRollupTimer();
	}
}

void CMultiPaneFrameWnd::AdjustPaneFrames()
{
	CObList& lstControlBars = m_barContainerManager.m_lstControlBars;
	UINT uiSWPFlags = SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_FRAMECHANGED;
	for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		pNextBar->SetWindowPos(NULL, -1, -1, -1, -1, uiSWPFlags);
	}
}

void CMultiPaneFrameWnd::AddPane(CBasePane* pWnd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pWnd);
	ASSERT_KINDOF(CDockablePane, pWnd);

	CDockablePane* pBar = DYNAMIC_DOWNCAST(CDockablePane, pWnd);

	if (m_barContainerManager.IsEmpty())
	{
		m_barContainerManager.AddPane(pBar);
		CPaneFrameWnd::AddPane(pWnd);
	}

	OnSetRollUpTimer();
}

BOOL CMultiPaneFrameWnd::AddRecentPane(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	CPaneContainer* pRecentContainer = pBar->m_recentDockInfo.GetRecentPaneContainer(FALSE);
	CPaneContainer* pRecentTabContainer = pBar->m_recentDockInfo.GetRecentTabContainer(FALSE);
	if (pRecentContainer != NULL)
	{
		pBar->SetParent(this);
		AddRemovePaneFromGlobalList(pBar, TRUE);
		CDockablePane* pAddedBar = m_barContainerManager.AddPaneToRecentPaneContainer(pBar, pRecentContainer);

		CWnd* pEmbeddedWnd = CWnd::FromHandlePermanent(m_hEmbeddedBar);

		if (pAddedBar != NULL && pEmbeddedWnd == NULL)
		{
			m_hEmbeddedBar = pAddedBar->GetSafeHwnd();
		}
		if (m_barContainerManager.GetVisiblePaneCount() == 1 && pBar == pAddedBar)
		{
			MoveWindow(m_rectRecentFloatingRect);
		}
		if (pAddedBar != NULL)
		{
			OnShowPane(pAddedBar, TRUE);
		}
	}
	else if (pRecentTabContainer != NULL)
	{
		pBar->SetParent(this);
		AddRemovePaneFromGlobalList(pBar, TRUE);
		BOOL bRecentLeftBar = pBar->m_recentDockInfo.IsRecentLeftPane(FALSE);
		CDockablePane* pTabbedBar = (CDockablePane*)(bRecentLeftBar ? pRecentTabContainer->GetLeftPane() : pRecentTabContainer->GetRightPane());
		if (pTabbedBar != NULL)
		{
			CDockablePane* pCreatedTabbedBar = NULL;
			pBar->AttachToTabWnd(pTabbedBar, DM_DBL_CLICK, TRUE, &pCreatedTabbedBar);

			pTabbedBar->ShowPane(TRUE, FALSE, TRUE);
			OnPaneRecalcLayout();
		}
		else
		{
			CDockablePane* pAddedBar = m_barContainerManager.AddPaneToRecentPaneContainer(pBar, pRecentTabContainer);
			OnShowPane(pAddedBar, TRUE);
		}
	}
	else
	{
		ASSERT(FALSE);
		return FALSE;
	}
	OnSetRollUpTimer();
	return TRUE;
}

void CMultiPaneFrameWnd::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

	OnPaneRecalcLayout();

	ArrangeCaptionButtons();
	SendMessage(WM_NCPAINT);
}

void CMultiPaneFrameWnd::OnSizing(UINT fwSide, LPRECT pRect)
{
	CWnd::OnSizing(fwSide, pRect);
}

void CMultiPaneFrameWnd::OnPaneRecalcLayout()
{
	ASSERT_VALID(this);

	CRect rectClient;
	GetClientRect(rectClient);
	HDWP hdwp = ::BeginDeferWindowPos(20);
	m_barContainerManager.ResizePaneContainers(rectClient, hdwp);
	EndDeferWindowPos(hdwp);

	if (CPane::m_bHandleMinSize)
	{
		CRect rectContainer;
		m_barContainerManager.GetWindowRect(rectContainer);

		CRect rectWnd;
		GetWindowRect(rectWnd);

		int nDeltaWidth = rectContainer.Width() - rectClient.Width();
		int nDeltaHeight = rectContainer.Height() - rectClient.Height();

		if (nDeltaWidth < 0)
		{
			nDeltaWidth = 0;
		}

		if (nDeltaHeight < 0)
		{
			nDeltaHeight = 0;
		}

		if (nDeltaWidth != 0 || nDeltaHeight != 0)
		{
			SetWindowPos(NULL, -1, -1, rectWnd.Width() + nDeltaWidth, rectWnd.Height() + nDeltaHeight, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
		}
	}
}

void CMultiPaneFrameWnd::RemovePane(CBasePane* pBar, BOOL bDestroy, BOOL /*bNoDelayedDestroy*/)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	if (pBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
	{
		m_barContainerManager.RemovePaneFromPaneContainer((CDockablePane*) pBar);
		if (!m_barContainerManager.IsEmpty())
		{
			CPaneFrameWnd::ReplacePane(pBar, m_barContainerManager.GetFirstPane());
		}
		else
		{
			// do not destroy the miniframe in the base class
			CPaneFrameWnd::RemovePane(pBar, FALSE);

			// if embedded bar has became NULL set it to the first bar in the container
			CWnd* pEmbeddedWnd = CWnd::FromHandlePermanent(m_hEmbeddedBar);
			if (pEmbeddedWnd == NULL)
			{
				m_hEmbeddedBar = m_barContainerManager.GetFirstPane()->GetSafeHwnd();
			}
		}
	}

	if (bDestroy && GetPaneCount() == 0)
	{
		PostMessage(AFX_WM_CHECKEMPTYMINIFRAME);
	}
	else
	{
		CheckGripperVisibility();
		OnPaneRecalcLayout();
		SendMessage(WM_NCPAINT);
	}

	OnKillRollUpTimer();
}

BOOL CMultiPaneFrameWnd::SetPreDockState(AFX_PREDOCK_STATE preDockState, CBasePane* pBarToDock, AFX_DOCK_METHOD dockMethod)
{
	ASSERT_VALID(this);

	if (preDockState == PDS_NOTHING || preDockState == PDS_DOCK_TO_TAB && pBarToDock != NULL && !pBarToDock->CanBeAttached())
	{
		return TRUE;
	}

	CDockablePane* pTargetDockBar = DYNAMIC_DOWNCAST(CDockablePane, pBarToDock);

	CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(GetParent());
	if (pDockManager == NULL)
	{
		ASSERT(FALSE);
		return TRUE;
	}

	CWnd* pFirstDockedBar = m_barContainerManager.GetFirstVisiblePane();

	// determine dock alignment and edge
	CPoint pt;
	GetCursorPos(&pt);

	DWORD dwAlignment = 0;

	CObList lstControlBars;
	m_barContainerManager.AddPanesToList(&lstControlBars, NULL);

	CList<HWND, HWND> lstHandles;

	POSITION pos = NULL;

	for (pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		pNextBar->StoreRecentDockSiteInfo();
		lstHandles.AddTail(pNextBar->GetSafeHwnd());
	}

	if (pTargetDockBar != NULL)
	{
		CBasePane* pHeadBar = m_barContainerManager.GetFirstPane();

		if (pHeadBar == NULL || !pTargetDockBar->CanAcceptPane(pHeadBar) || !pHeadBar->CanAcceptPane(pTargetDockBar))
		{
			return TRUE;
		}

		if (!pHeadBar->IsPaneVisible() && m_barContainerManager.GetPaneCount() == 1 && (pHeadBar->GetDockingMode() & DT_STANDARD) != 0)
		{
			// the head bar is unvisible and there is only one bar in container manager
			// means that this bar was torn off from the tab window and its parent miniframe
			// is hidden
			pHeadBar->ModifyStyle(0, WS_VISIBLE);
		}

		BOOL bOuterEdge = FALSE;
		if (preDockState == PDS_DOCK_REGULAR && !afxGlobalUtils.CheckAlignment(pt, pTargetDockBar, CDockingManager::m_nDockSensitivity, NULL, bOuterEdge, dwAlignment))
		{
			// unable for some reason to determine alignment
			return TRUE;
		}

		if (preDockState == PDS_DOCK_REGULAR)
		{
			if (!pTargetDockBar->DockPaneContainer(m_barContainerManager, dwAlignment, dockMethod))
			{
				return TRUE;
			}
		}
		else if (preDockState == PDS_DOCK_TO_TAB)
		{
			for (pos = lstControlBars.GetHeadPosition(); pos != NULL;)
			{
				CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
				ASSERT_VALID(pNextBar);

				AddRemovePaneFromGlobalList(pNextBar, FALSE);
				pNextBar->AttachToTabWnd(pTargetDockBar, dockMethod);
			}

			ShowWindow(SW_HIDE);
			MoveWindow(GetRecentFloatingRect());
			CPaneFrameWnd::OnCancelMode();
			SendMessage(AFX_WM_CHECKEMPTYMINIFRAME);
			return TRUE;
		}
		else
		{
			return TRUE;
		}
	}
	else // dock to frame window - need to create a new default slider
	{
		BOOL bOuterEdge = FALSE;
		if (!pDockManager->IsPointNearDockSite(pt, dwAlignment, bOuterEdge))
		{
			return TRUE;
		}

		CPaneDivider* pSlider = CDockablePane::CreateDefaultPaneDivider(dwAlignment, GetParent());

		if (pSlider == NULL)
		{
			return TRUE;
		}

		pSlider->SetPaneAlignment(dwAlignment);

		CRect rectContainer;
		m_barContainerManager.GetWindowRect(rectContainer);
		pDockManager->AdjustRectToClientArea(rectContainer, dwAlignment);
		HDWP hdwp = NULL;
		m_barContainerManager.ResizePaneContainers(rectContainer, hdwp);

		if (bOuterEdge)
		{
			// register slider with the dock manager
			pDockManager->AddPane(pSlider, !bOuterEdge, FALSE, bOuterEdge);
			pSlider->AddPaneContainer(m_barContainerManager, bOuterEdge);
		}
		else
		{
			pSlider->AddPaneContainer(m_barContainerManager, FALSE);
			pDockManager->AddPane(pSlider);
		}
	}

	// FINALLY destroy the frame - // all its bars should have been docked(and therefore removed)
	HWND hwndSave = m_hWnd;
	SendMessage(AFX_WM_CHECKEMPTYMINIFRAME);

	if (IsWindow(hwndSave))
	{
		MoveWindow(m_rectRecentFloatingRect);
	}
	else
	{
		return FALSE;
	}

	if (pFirstDockedBar != NULL && dockMethod == DM_MOUSE)
	{
		pFirstDockedBar->ScreenToClient(&pt);
		if (pFirstDockedBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
		{
			((CDockablePane*)pFirstDockedBar)->EnterDragMode(FALSE);
		}
		else
		{
			pFirstDockedBar->SendMessage(WM_LBUTTONDOWN, 0, MAKELPARAM(pt.x, pt.y));
		}
	}

	// adjust the docking layout
	if (pTargetDockBar != NULL)
	{
		pTargetDockBar->RecalcLayout();
	}
	else if (pFirstDockedBar != NULL)
	{
		CDockablePane* pDockingBar = DYNAMIC_DOWNCAST(CDockablePane, pFirstDockedBar);
		if (pDockingBar != NULL)
		{
			pDockingBar->AdjustDockingLayout();
		}
	}

	OnSetRollUpTimer();

	for (pos = lstHandles.GetHeadPosition(); pos != NULL;)
	{
		HWND hwndNext = lstHandles.GetNext(pos);
		if (::IsWindow(hwndNext))
		{
			CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, CWnd::FromHandle(hwndNext));
			if (pNextBar != NULL)
			{
				pNextBar->OnAfterDockFromMiniFrame();
			}
		}
	}

	return FALSE;
}

BOOL CMultiPaneFrameWnd::SaveState(LPCTSTR lpszProfileName, UINT uiID)
{
	ASSERT_VALID(this);
	CObList& lstControlBars = m_barContainerManager.m_lstControlBars;
	for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		pNextBar->SaveState(lpszProfileName, uiID);
	}
	return TRUE;
}

BOOL CMultiPaneFrameWnd::LoadState(LPCTSTR lpszProfileName, UINT uiID)
{
	ASSERT_VALID(this);
	CObList& lstControlBars = m_barContainerManager.m_lstControlBars;
	for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		pNextBar->LoadState(lpszProfileName, uiID);
	}
	return TRUE;
}

void CMultiPaneFrameWnd::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);
	CPaneFrameWnd::Serialize(ar);
	m_barContainerManager.Serialize(ar);
}

void CMultiPaneFrameWnd::SetDockState(CDockingManager* pDockManager)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDockManager);

	CObList lstBarsToRemove;
	if (!m_barContainerManager.IsEmpty())
	{
		// float each control bar, reparent it and set its window position
		CObList& lstControlBars = m_barContainerManager.m_lstControlBars;
		POSITION pos = NULL;

		for (pos = lstControlBars.GetHeadPosition(); pos != NULL;)
		{
			CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
			ASSERT_VALID(pNextBar);

			if (pNextBar->IsKindOf(RUNTIME_CLASS(CBaseTabbedPane)))
			{
				BOOL bLeftBar = FALSE;
				CPaneContainer* pContainer = m_barContainerManager.FindPaneContainer(pNextBar, bLeftBar);

				ENSURE(pContainer != NULL);

				CList<UINT, UINT>* pListBarIDs = pContainer->GetAssociatedSiblingPaneIDs(pNextBar);

				if (pListBarIDs != NULL)
				{
					for (POSITION posNext = pListBarIDs->GetHeadPosition(); posNext != NULL;)
					{
						UINT nIDNext = pListBarIDs->GetNext(posNext);
						CBasePane* pBarToAttach = pDockManager->FindPaneByID(nIDNext, TRUE);

						if (pBarToAttach == NULL)
						{
							continue;
						}

						if (pBarToAttach->IsKindOf(RUNTIME_CLASS(CDockablePane)) && ((CDockablePane*)pBarToAttach)->IsAutoHideMode())
						{
							((CDockablePane*)pBarToAttach)->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
						}

						if (pBarToAttach->IsTabbed())
						{
							CMFCBaseTabCtrl* pTabWnd = (CMFCBaseTabCtrl*) pBarToAttach->GetParent();
							CBaseTabbedPane* pTabBar = (CBaseTabbedPane*)pTabWnd->GetParent();
							ASSERT_VALID(pTabBar);

							pBarToAttach->SetParent(this);
							pTabBar->RemovePane(pBarToAttach);
						}
						else
						{
							// float this bar in case if was docked somewhere else
							pBarToAttach->FloatPane(CRect(0, 0, 10, 10), DM_SHOW, false);
						}
						CPaneFrameWnd* pParentMiniFrame = pBarToAttach->GetParentMiniFrame();

						if (pParentMiniFrame != NULL && pParentMiniFrame != this)
						{
							pParentMiniFrame->RemovePane(pBarToAttach);
						}

						((CDockablePane*) pBarToAttach)->AttachToTabWnd(pNextBar, DM_UNKNOWN, FALSE);

						if (pParentMiniFrame != NULL)
						{
							pParentMiniFrame->PostMessage(AFX_WM_CHECKEMPTYMINIFRAME);
						}
					}
				}

				if (((CBaseTabbedPane*)pNextBar)->GetTabsNum() == 0)
				{
					lstBarsToRemove.AddTail(pNextBar);
				}
				else
				{
					((CBaseTabbedPane*)pNextBar)->ApplyRestoredTabInfo();
					pNextBar->RecalcLayout();
				}
				continue;
			}

			if (pNextBar->IsTabbed())
			{
				CMFCBaseTabCtrl* pTabWnd = (CMFCBaseTabCtrl*) pNextBar->GetParent();
				CBaseTabbedPane* pTabBar = (CBaseTabbedPane*) pTabWnd->GetParent();
				ASSERT_VALID(pTabBar);
				// set belong to any parent
				pNextBar->SetParent(GetParent());
				pTabBar->RemovePane(pNextBar);
				if (pNextBar->IsKindOf(RUNTIME_CLASS(CDockablePane)))
				{
					((CDockablePane*) pNextBar)->EnableGripper(TRUE);
				}

				pNextBar->ShowWindow(SW_SHOW);
			}

			if (pNextBar->IsAutoHideMode())
			{
				pNextBar->SetAutoHideMode(FALSE, CBRS_ALIGN_ANY);
			}

			CRect rectDummy;
			pNextBar->GetWindowRect(rectDummy);
			pNextBar->FloatPane(rectDummy, DM_SHOW, false);

			CPaneFrameWnd* pParentMiniFrame = pNextBar->GetParentMiniFrame();
			if (pParentMiniFrame != NULL)
			{
				pNextBar->SetParent(this);
				pParentMiniFrame->RemovePane(pNextBar);

				CRect rect = pNextBar->m_rectSavedDockedRect;

				pNextBar->SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER | SWP_FRAMECHANGED  | SWP_NOACTIVATE);
			}
		}

		for (pos = lstBarsToRemove.GetHeadPosition(); pos != NULL;)
		{
			CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstBarsToRemove.GetNext(pos));
			RemovePane(pNextBar);
			pNextBar->DestroyWindow();
		}

		// retake the list
		CObList& lstModifiedControlBars = m_barContainerManager.m_lstControlBars;

		if (lstModifiedControlBars.IsEmpty())
		{
			SendMessage(AFX_WM_CHECKEMPTYMINIFRAME);
			return;
		}

		for (pos = lstModifiedControlBars.GetHeadPosition(); pos != NULL;)
		{
			CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstModifiedControlBars.GetNext(pos));
			ASSERT_VALID(pNextBar);

			BOOL bShow = pNextBar->GetRecentVisibleState();

			if (bShow)
			{
				SetDelayShow(TRUE);
			}
			
			// show with delay
			pNextBar->ShowPane(bShow, TRUE, FALSE);
			
			AddRemovePaneFromGlobalList(pNextBar, TRUE);
		}

		// set embedded bar to the first bar in the container
		CBasePane* pEmbeddedBar = DYNAMIC_DOWNCAST(CBasePane, lstControlBars.GetHead());
		if (pEmbeddedBar != NULL)
		{
			if (lstControlBars.GetCount() > 1)
			{
				m_hEmbeddedBar = pEmbeddedBar->GetSafeHwnd();
			}
			else
			{
				CString strText;
				pEmbeddedBar->GetWindowText(strText);
				SetWindowText(strText);

				SetIcon(pEmbeddedBar->GetIcon(FALSE), FALSE);
				SetIcon(pEmbeddedBar->GetIcon(TRUE), TRUE);
			}
		}
		OnSetRollUpTimer();
		SetCaptionButtons(m_dwCaptionButtons);
		OnPaneRecalcLayout();
		return;
	}

	// if we're here the miniframe is empty and should be destroyed
	PostMessage(AFX_WM_CHECKEMPTYMINIFRAME);
}

void CMultiPaneFrameWnd::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
	CSize sizeBase;

	m_barContainerManager.GetMinSize(sizeBase);
	CalcMinSize(sizeBase, lpMMI);

	CWnd::OnGetMinMaxInfo(lpMMI);
}

void CMultiPaneFrameWnd::OnShowPane(CDockablePane* pBar, BOOL bShow)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);

	m_barContainerManager.OnShowPane(pBar, bShow);

	if (bShow)
	{
		if (!m_bDelayShow)
		{
			ShowWindow(SW_SHOWNOACTIVATE);
		}

		OnSetRollUpTimer();
	}
	else if (!m_barContainerManager.IsRootPaneContainerVisible())
	{
		ShowWindow(SW_HIDE);
		OnKillRollUpTimer();
	}

	CheckGripperVisibility();

	OnPaneRecalcLayout();

	// redraw caption to reflect the number of visible bars and set the recent pos
	SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE);
}

void CMultiPaneFrameWnd::CloseMiniFrame()
{
	if (OnCloseMiniFrame())
	{
		ShowWindow(SW_HIDE);
		m_barContainerManager.HideAll();
	}
}

void CMultiPaneFrameWnd::CheckGripperVisibility()
{
	if (IsWindowVisible())
	{
		int nVisibleCount = m_barContainerManager.GetVisiblePaneCount();

		if (nVisibleCount == 1) // take off caption from this bar
		{
			CDockablePane* pVisibleBar = DYNAMIC_DOWNCAST(CDockablePane, m_barContainerManager.GetFirstVisiblePane());

			if (pVisibleBar != NULL)
			{
				pVisibleBar->EnableGripper(FALSE);
			}
		}
		else
		{
			m_barContainerManager.EnableGrippers(TRUE);
		}
	}
}

CString CMultiPaneFrameWnd::GetCaptionText()
{
	CString strCaptionText;
	if (m_barContainerManager.GetVisiblePaneCount() == 1)
	{
		CWnd* pVisibleBar = DYNAMIC_DOWNCAST(CWnd, m_barContainerManager.GetFirstVisiblePane());

		if (pVisibleBar != NULL)
		{
			pVisibleBar->GetWindowText(strCaptionText);
		}
	}

	return strCaptionText;
}

void CMultiPaneFrameWnd::OnLButtonDblClk(UINT /*nFlags*/, CPoint /*point*/)
{
	OnDockToRecentPos();
}

void CMultiPaneFrameWnd::OnDockToRecentPos()
{
	CDockingManager* pDockManager = m_pDockManager != NULL ? m_pDockManager : afxGlobalUtils.GetDockingManager(this);

	CObList lstControlBars;
	m_barContainerManager.AddPanesToList(&lstControlBars, NULL);

	POSITION pos = NULL;

	for (pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		pNextBar->StoreRecentDockSiteInfo();
	}

	for (pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		AddRemovePaneFromGlobalList(pNextBar, FALSE);
		pNextBar->DockPane(pNextBar, NULL, DM_DBL_CLICK);
	}

	afxGlobalUtils.ForceAdjustLayout(pDockManager);

	SendMessage(AFX_WM_CHECKEMPTYMINIFRAME);
}

void CMultiPaneFrameWnd::SaveRecentFloatingState()
{
	GetWindowRect(m_rectRecentFloatingRect);
	CObList lstControlBars;
	m_barContainerManager.AddPanesToList(&lstControlBars, NULL);
	for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		pNextBar->m_recentDockInfo.m_rectRecentFloatingRect = m_rectRecentFloatingRect;
	}
}

void CMultiPaneFrameWnd::StoreRecentDockSiteInfo(CPane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);
	ASSERT_KINDOF(CDockablePane, pBar);

	CDockablePane* pDockingBar = DYNAMIC_DOWNCAST(CDockablePane, pBar);

	if (pDockingBar == NULL)
	{
		return;
	}

	BOOL bLeftBar = TRUE;
	CPaneContainer* pRecentContainer = m_barContainerManager.FindPaneContainer(pDockingBar, bLeftBar);

	pDockingBar->m_recentDockInfo.StoreDockInfo(pRecentContainer);
}

void CMultiPaneFrameWnd::StoreRecentTabRelatedInfo(CDockablePane* pDockingBar, CDockablePane* pTabbedBar)
{
	BOOL bLeftBar = TRUE;
	CPaneContainer* pRecentContainer = m_barContainerManager.FindPaneContainer(pTabbedBar, bLeftBar);

	pDockingBar->m_recentDockInfo.StoreDockInfo(pRecentContainer, pTabbedBar);
}

void CMultiPaneFrameWnd::DockRecentPaneToMainFrame(CDockablePane* pBar)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBar);
	AddRemovePaneFromGlobalList(pBar, FALSE);
	pBar->DockPane(pBar, NULL, DM_DBL_CLICK);
}

LRESULT CMultiPaneFrameWnd::OnCheckEmptyState(WPARAM, LPARAM)
{
	if (m_barContainerManager.m_pRootContainer != NULL)
	{
		m_barContainerManager.m_pRootContainer->ReleaseEmptyPaneContainer();
	}
	if (m_barContainerManager.GetNodeCount() == 0 || m_barContainerManager.GetNodeCount() == 1 && m_barContainerManager.m_pRootContainer != NULL && m_barContainerManager.m_pRootContainer->GetRefCount() == 0 && m_barContainerManager.m_pRootContainer->IsEmpty())
	{
		CPaneFrameWnd::OnCancelMode();
		DestroyWindow();
	}
	else if (m_barContainerManager.GetVisiblePaneCount() == 0)
	{
		ShowWindow(SW_HIDE);
		CPaneFrameWnd::OnCancelMode();
	}
	return 0;
}

BOOL CMultiPaneFrameWnd::InsertPane(CBasePane* pControlBar, CBasePane* /*pTarget*/, BOOL /*bAfter*/)
{
	AddRemovePaneFromGlobalList(pControlBar, TRUE);
	return TRUE;
}

void CMultiPaneFrameWnd::CalcExpectedDockedRect(CWnd* pWndToDock, CPoint ptMouse, CRect& rectResult, BOOL& bDrawTab, CDockablePane** ppTargetBar)
{
	CGlobalUtils globalUtilsLocal;
	if (m_bRolledUp)
	{
		// can't dock on rolled up miniframe
		bDrawTab = FALSE;
		rectResult.SetRectEmpty();
		return;
	}
	globalUtilsLocal.CalcExpectedDockedRect(m_barContainerManager, pWndToDock, ptMouse, rectResult, bDrawTab, ppTargetBar);
}

CBasePane* CMultiPaneFrameWnd::PaneFromPoint(CPoint point, int nSensitivity, BOOL bCheckVisibility)
{
	if (bCheckVisibility && !IsWindowVisible())
	{
		return NULL;
	}
	BOOL bTabArea = FALSE;
	BOOL bCaption = FALSE;
	return m_barContainerManager.PaneFromPoint(point, nSensitivity, TRUE, bTabArea, bCaption);
}

BOOL CMultiPaneFrameWnd::CanBeDockedToPane(const CDockablePane* pDockingBar) const
{
	for (POSITION pos = m_barContainerManager.m_lstControlBars.GetHeadPosition();
		pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, m_barContainerManager.m_lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);

		if (pDockingBar->CanAcceptPane(pNextBar) && pNextBar->CanAcceptPane(pDockingBar))
		{
			return TRUE;
		}
	}

	return FALSE;
}

LRESULT CMultiPaneFrameWnd::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
	CPaneFrameWnd::OnIdleUpdateCmdUI(wParam, 0);
	return 0L;
}

void CMultiPaneFrameWnd::ReplacePane(CBasePane* pBarOrg, CBasePane* pBarReplaceWith)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pBarOrg);
	ASSERT_VALID(pBarReplaceWith);
	ASSERT_KINDOF(CDockablePane, pBarReplaceWith);

	m_barContainerManager.ReplacePane((CDockablePane*) pBarOrg, (CDockablePane*) pBarReplaceWith);
	OnSetRollUpTimer();
}

CWnd* CMultiPaneFrameWnd::GetPane() const
{
	CWnd* pWnd = CPaneFrameWnd::GetPane();
	if (pWnd == NULL)
	{
		pWnd = GetFirstVisiblePane();
		if (pWnd == NULL)
		{
			pWnd = m_barContainerManager.GetFirstPane();
		}
	}

	return pWnd;
}

void CMultiPaneFrameWnd::RemoveNonValidPanes()
{
	m_barContainerManager.RemoveNonValidPanes();
}

void CMultiPaneFrameWnd::OnSetFocus(CWnd* /*pOldWnd*/)
{
	CBasePane* pFirstBar = DYNAMIC_DOWNCAST(CBasePane, GetFirstVisiblePane());
	if (m_hWndLastFocused == NULL)
	{
		if (pFirstBar != NULL && ::IsWindow(pFirstBar->GetSafeHwnd()) && pFirstBar->CanFocus())
		{
			pFirstBar->SetFocus();
		}
	}
	else
	{
		CDockablePane* pWnd = DYNAMIC_DOWNCAST(CDockablePane, CWnd::FromHandlePermanent(m_hWndLastFocused));
		CPaneContainer* pContainer = NULL;
		if (pWnd != NULL)
		{
			BOOL bLeftBar;
			pContainer = m_barContainerManager.FindPaneContainer(pWnd, bLeftBar);
		}

		if (pContainer != NULL && ::IsWindow(pWnd->GetSafeHwnd()))
		{
			pWnd->SetFocus();
		}
		else if (pFirstBar != NULL && ::IsWindow(pFirstBar->GetSafeHwnd()))
		{
			pFirstBar->SetFocus();
		}
	}

	if (GetParentFrame() != NULL)
	{
		GetParentFrame()->SetWindowPos(&wndTop, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
	}
}
void CMultiPaneFrameWnd::ConvertToTabbedDocument()
{
	CObList lstControlBars;
	m_barContainerManager.AddPanesToList(&lstControlBars, NULL);
	for (POSITION pos = lstControlBars.GetHeadPosition(); pos != NULL;)
	{
		CDockablePane* pNextBar = DYNAMIC_DOWNCAST(CDockablePane, lstControlBars.GetNext(pos));
		ASSERT_VALID(pNextBar);
		pNextBar->ConvertToTabbedDocument(FALSE);
	}
	PostMessage(AFX_WM_CHECKEMPTYMINIFRAME);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxoleserverdocex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxcontrolbarutil.h"
#include "afxoleserverdocex.h"
#include "afxoledocipframewndex.h"
#include "afxoleipframewndex.h"
#include "afxolecntrframewndex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// COleServerDocEx

IMPLEMENT_DYNCREATE(COleServerDocEx, COleServerDoc)

COleServerDocEx::COleServerDocEx()
{
}

BOOL COleServerDocEx::OnNewDocument()
{
	if (!COleServerDoc::OnNewDocument())
		return FALSE;
	return TRUE;
}

COleServerDocEx::~COleServerDocEx()
{
}

COleServerItem* COleServerDocEx::OnGetEmbeddedItem()
{
	// OnGetEmbeddedItem is called by the framework to get the COleServerItem
	//  that is associated with the document.  It is only called when necessary.

	// Instead of returning NULL, return a pointer to a new COleServerItem
	//  derived class that is used in conjunction with this document, then
	//  remove the ASSERT(FALSE) below.
	//(i.e., return new CMyServerItem.)
	ASSERT(FALSE); // remove this after completing the TODO
	return NULL;
}

BEGIN_MESSAGE_MAP(COleServerDocEx, COleServerDoc)
	//{{AFX_MSG_MAP(COleServerDocEx)
	// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COleServerDocEx diagnostics

#ifdef _DEBUG
void COleServerDocEx::AssertValid() const
{
	COleServerDoc::AssertValid();
}

void COleServerDocEx::Dump(CDumpContext& dc) const
{
	COleServerDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COleServerDocEx serialization

void COleServerDocEx::Serialize(CArchive& ar)
{
	COleServerDoc::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// COleServerDocEx commands
void COleServerDocEx::OnResizeBorder( LPCRECT lpRectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL bFrame )
{
	ASSERT_VALID(this);
	ENSURE(lpUIWindow != NULL);

	if (!bFrame)
	{
		COleServerDoc::OnResizeBorder(lpRectBorder, lpUIWindow, bFrame);
		return;
	}

	COleCntrFrameWndEx* pMainFrame = NULL;

	COleDocIPFrameWndEx* p_IpDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, m_pInPlaceFrame);

	if (p_IpDocFrame != NULL)
	{
		pMainFrame =  p_IpDocFrame->GetContainerFrameWindow();
	}
	else
	{
		COleIPFrameWndEx* p_IpFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, m_pInPlaceFrame);

		if (p_IpFrame != NULL)
		{
			pMainFrame = p_IpFrame->GetContainerFrameWindow();
		}
		else
		{
			return;
		}
	}

	if (pMainFrame == NULL)
	{
		return;
	}

	CDockingManager* pDockManager = pMainFrame->GetDockingManager();
	ASSERT_VALID(pDockManager);

	CRect rcCurBorders;

	if (lpRectBorder == NULL)
	{
		if (lpUIWindow->GetBorder(&rcCurBorders) != S_OK)
		{
			lpUIWindow->SetBorderSpace(NULL);
			return;
		}
	}
	else
	{
		rcCurBorders = *lpRectBorder;
	}

	if (AfxGetThread()->m_pActiveWnd == m_pInPlaceFrame)
		OnShowControlBars(pMainFrame, TRUE);

	pDockManager->m_rectInPlace = rcCurBorders;
	pDockManager->AdjustDockingLayout();

	CRect rectClient = pDockManager->GetClientAreaBounds();

	CRect rectRequest(abs(rectClient.left - rcCurBorders.left), abs(rectClient.top - rcCurBorders.top), abs(rectClient.right - rcCurBorders.right), abs(rectClient.bottom  - rcCurBorders.bottom)); // v.8.6 removed -1 to make it work in Excel

	CRect rectTemp;
	rectTemp = rectRequest;

	if (!rectRequest.IsRectNull() || lpUIWindow->RequestBorderSpace(&rectTemp) == S_OK)
	{
		lpUIWindow->SetBorderSpace(&rectRequest);
		pDockManager->AdjustDockingLayout();
	}
	else
	{
		OnShowControlBars(pMainFrame, FALSE);
		CRect rect(0,0,0,0);
		lpUIWindow->SetBorderSpace(&rect);
	}
}

void COleServerDocEx::OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow)
{
	COleServerDoc::OnShowControlBars(pFrameWnd, bShow);
	COleCntrFrameWndEx* pMainFrame = DYNAMIC_DOWNCAST(COleCntrFrameWndEx, pFrameWnd);

	if (pMainFrame != NULL)
	{
		ASSERT_VALID(pMainFrame);
		CDockingManager* pDockManager = pMainFrame->GetDockingManager();

		if (pDockManager != NULL)
		{
			ASSERT_VALID(pDockManager);
			pDockManager->ShowPanes(bShow);
		}
	}
}

void COleServerDocEx::OnDocWindowActivate( BOOL bActivate )
{
	if (bActivate)
	{
		COleServerDoc::OnDocWindowActivate(bActivate);
		return;
	}

	COleCntrFrameWndEx* pMainFrame = NULL;

	COleDocIPFrameWndEx* p_IpDocFrame = DYNAMIC_DOWNCAST(COleDocIPFrameWndEx, m_pInPlaceFrame);

	if (p_IpDocFrame != NULL)
	{
		pMainFrame =  p_IpDocFrame->GetContainerFrameWindow();
	}
	else
	{
		COleIPFrameWndEx* p_IpFrame = DYNAMIC_DOWNCAST(COleIPFrameWndEx, m_pInPlaceFrame);

		if (p_IpFrame != NULL)
		{
			pMainFrame =  p_IpFrame->GetContainerFrameWindow();
		}
	}

	if (pMainFrame == NULL)
	{
		return;
	}

	CDockingManager* pDockManager = pMainFrame->GetDockingManager();
	ASSERT_VALID(pDockManager);

	pDockManager->ShowPanes(bActivate);
	COleServerDoc::OnDocWindowActivate(bActivate);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\src\mfc\afxoutlookbar.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
//
#include "stdafx.h"
#include "afxoutlookbar.h"
#include "afxoutlookbartabctrl.h"
#include "afxoutlookbarpaneadapter.h"
#include "afxoutlookbarpane.h"
#include "afxdockingmanager.h"
#include "afxglobalutils.h"
#include "afxregpath.h"
#include "afxsettingsstore.h"
#include "afxpaneframewnd.h"
#include "afxwinappex.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

#define AFX_REG_SECTION_FMT _T("%sMFCOutlookBar-%d")
#define AFX_REG_SECTION_FMT_EX _T("%sMFCOutlookBar-%d%x")

static const CString strOutlookBarProfile = _T("MFCOutlookBars");
static const CString strRegCustomPages = _T("MFCOutlookCustomPages");

UINT g_nMinReservedPageID = 0xF000;

#define AFX_TOTAL_RESERVED_PAGES  100

static bool g_arTakenIDs [AFX_TOTAL_RESERVED_PAGES];

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBar

IMPLEMENT_SERIAL(CMFCOutlookBar, CBaseTabbedPane, 1)

CMFCOutlookBar::CMFCOutlookBar()
{
	m_bMode2003 = FALSE;
	m_pFontButtons = NULL;
}

CMFCOutlookBar::~CMFCOutlookBar()
{
	while (!m_lstCustomPages.IsEmpty())
	{
		delete m_lstCustomPages.RemoveHead();
	}
}

BEGIN_MESSAGE_MAP(CMFCOutlookBar, CBaseTabbedPane)
	//{{AFX_MSG_MAP(CMFCOutlookBar)
	ON_WM_CREATE()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMFCOutlookBar message handlers

void CMFCOutlookBar::GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const
{
	rectTabAreaTop.SetRectEmpty();
	rectTabAreaBottom.SetRectEmpty();

	if (CanFloat())
	{
		if (m_pTabWnd != NULL)
		{
			m_pTabWnd->GetTabArea(rectTabAreaTop, rectTabAreaBottom);
		}
	}
	else
	{
		GetClientRect(rectTabAreaTop);
		ClientToScreen(rectTabAreaTop);
	}
}

int CMFCOutlookBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CBaseTabbedPane::OnCreate(lpCreateStruct) == -1)
		return -1;

	CRect rectClient(0, 0, lpCreateStruct->cx, lpCreateStruct->cy);

	ENSURE(m_pTabWnd == NULL);
	m_pTabWnd = new CMFCOutlookBarTabCtrl;

	CMFCOutlookBarTabCtrl* pTabWnd = (CMFCOutlookBarTabCtrl*) m_pTabWnd;

	// enable this before create,a s it may change inside for dialog applications
	pTabWnd->m_bEnableWrapping = TRUE;

	// Create tabs window:
	if (!pTabWnd->Create(rectClient, this, 101))
	{
		TRACE0("Failed to create tab window\n");
		delete m_pTabWnd;
		m_pTabWnd = NULL;
		return -1;      // fail to create
	}

	pTabWnd->SetDockingBarWrapperRTC(RUNTIME_CLASS(CMFCOutlookBarPaneAdapter));

	if (CanFloat())
	{
		pTabWnd->HideSingleTab();
	}

	return 0;
}

BOOL CMFCOutlookBar::Create(LPCTSTR lpszCaption, CWnd* pParentWnd, const RECT& rect, UINT nID, DWORD dwStyle, DWORD dwControlBarStyle, CCreateContext* pContext)
{
	dwControlBarStyle &= ~AFX_CBRS_FLOAT;

	BOOL bResult = CBaseTabbedPane::Create(lpszCaption, pParentWnd, rect, FALSE, nID, dwStyle, AFX_CBRS_OUTLOOK_TABS, dwControlBarStyle, pContext);
	if (!bResult)
	{
		TRACE0("Failed to create CMFCOutlookBar\n");
		return FALSE;
	}

	if (dwControlBarStyle & AFX_CBRS_RESIZE)
	{
		EnableDocking(CBRS_ALIGN_ANY);
		DockPaneUsingRTTI(FALSE);
	}
	else
	{
		CDockingManager* pManager = afxGlobalUtils.GetDockingManager(pParentWnd);
		if (pManager != NULL)
		{
			pManager->AddPane(this);
		}
	}

	if (lpszCaption != NULL)
	{
		m_strBarName = lpszCaption;
	}

	return TRUE;
}

BOOL CMFCOutlookBar::CanAcceptPane(const CBasePane* pBar) const
{
	ASSERT_VALID(this);

	if (pBar == NULL || m_bMode2003)
	{
		return FALSE;
	}

	if (CanFloat())
	{
		return CBaseTabbedPane::CanAcceptPane(pBar);
	}

	return(pBar->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPaneAdapter)) || pBar->IsKindOf(RUNTIME_CLASS(CMFCOutlookBarPane)) || pBar->IsKindOf(RUNTIME_CLASS(CMFCOutlookBar)));
}

AFX_CS_STATUS CMFCOutlookBar::GetDockingStatus(CPoint pt, int nSensitivity)
{
	ASSERT_VALID(this);

	if (m_pTabWnd == NULL)
	{
		return CS_NOTHING;
	}

	if (m_pTabWnd->GetTabsNum() == 0 || m_pTabWnd->GetVisibleTabsNum() == 0)
	{
		return CS_DELAY_DOCK_TO_TAB;
	}

	// detect caption
	UINT nHitTest = HitTest(pt, TRUE);

	CRect rectTabAreaTop;
	CRect rectTabAreaBottom;
	GetTabArea(rectTabAreaTop, rectTabAreaBottom);

	if (!rectTabAreaTop.IsRectEmpty())
	{
		rectTabAreaTop.bottom += nSensitivity;
	}

	if (!rectTabAreaBottom.IsRectEmpty())
	{
		rectTabAreaBottom.top -= nSensitivity;
	}

	if (nHitTest == HTCAPTION || rectTabAreaTop.PtInRect(pt) || rectTabAreaBottom.PtInRect(pt))
	{
		// need to display "ready to create detachable tab" status
		return CS_DELAY_DOCK_TO_TAB;
	}

	AFX_CS_STATUS status = CDockablePane::GetDockingStatus(pt, nSensitivity);

	//if the bar can't float it's a static bar and it can't accept
	// anything but dock to tabs

	if (!CanFloat() && status == CS_DELAY_DOCK)
	{
		return CS_NOTHING;
	}

	return status;
}

void CMFCOutlookBar::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	CMemDC memDC(dc, this);

	CRect rectClient;
	GetClientRect(rectClient);

	CMFCVisualManager::GetInstance()->OnFillBarBackground(&memDC.GetDC(), this, rectClient, rectClient);
}

CMFCOutlookBarPane* CMFCOutlookBar::CreateCustomPage(LPCTSTR lpszPageName, BOOL bActivatePage, DWORD dwEnabledDocking, BOOL bEnableTextLabels)
{
	ENSURE(lpszPageName != NULL);

	if (m_bMode2003)
	{
		ASSERT(FALSE);
		return NULL;
	}

	CMFCOutlookBarTabCtrl* pOutlookWnd = (CMFCOutlookBarTabCtrl*) GetUnderlyingWindow();

	ASSERT_VALID(pOutlookWnd);

	UINT uiPageID = FindAvailablePageID();

	if (uiPageID == 0xFFFF)
	{
		TRACE0("There is no page ID available!\n");
		return NULL;
	}

	CMFCOutlookBarPane* pNewPage = new CMFCOutlookBarPane;
	pNewPage->Create(this, AFX_DEFAULT_TOOLBAR_STYLE | CBRS_FLOAT_MULTI, uiPageID);
	pNewPage->SetOwner(GetOwner());
	pNewPage->EnableDocking(dwEnabledDocking);
	pNewPage->EnableTextLabels(bEnableTextLabels);
	pOutlookWnd->AddTab(pNewPage, lpszPageName);

	m_lstCustomPages.AddTail(pNewPage);
	g_arTakenIDs [uiPageID - g_nMinReservedPageID] = true;

	if (bActivatePage)
	{
		pOutlookWnd->SetActiveTab(pOutlookWnd->m_iTabsNum - 1);
	}

	return pNewPage;
}

BOOL CMFCOutlookBar::RemoveCustomPage(UINT uiPage, CMFCOutlookBarTabCtrl* pTargetWnd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pTargetWnd);

	if (m_bMode2003)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCOutlookBarTabCtrl* pOutlookBar = DYNAMIC_DOWNCAST(CMFCOutlookBarTabCtrl, GetUnderlyingWindow());
	if (pOutlookBar == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	CMFCOutlookBarPane* pPage = DYNAMIC_DOWNCAST(CMFCOutlookBarPane, pTargetWnd->GetTabWndNoWrapper(uiPage));
	if (pPage == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	POSITION pos = m_lstCustomPages.Find(pPage);
	if (pos != NULL)
	{
		UINT uID = pPage->GetDlgCtrlID();

		if (uID >= g_nMinReservedPageID && uID < g_nMinReservedPageID + AFX_TOTAL_RESERVED_PAGES)
		{
			g_arTakenIDs [uID - g_nMinReservedPageID] = false;
			m_lstCustomPages.RemoveAt(pos);

			BOOL bSave = pTargetWnd->m_bAutoDestroyWindow;

			pTargetWnd->m_bAutoDestroyWindow = TRUE;
			pTargetWnd->RemoveTab(uiPage);
			pTargetWnd->m_bAutoDestroyWindow = bSave;

			delete pPage;
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CMFCOutlookBar::LoadState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CBaseTabbedPane::LoadState(lpszProfileName, nIndex, uiID);

	CString strProfileName = ::AFXGetRegPath(strOutlookBarProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	LPBYTE lpbData = NULL;
	UINT uiDataSize;

	CSettingsStoreSP regSP;
	CSettingsStore& reg = regSP.Create(FALSE, TRUE);

	if (!reg.Open(strSection))
	{
		return FALSE;
	}

	if (!reg.Read(strRegCustomPages, &lpbData, &uiDataSize))
	{
		return FALSE;
	}

	CMFCOutlookBarTabCtrl* pOutlookBar = (CMFCOutlookBarTabCtrl*) GetUnderlyingWindow();

	try
	{
		CMemFile file(lpbData, uiDataSize);
		CArchive ar(&file, CArchive::load);

		int nCount = 0;
		ar >> nCount;

		for (int i = 0; i < nCount; i++)
		{
			int nID = 0;
			CString strName;
			ar >> nID;
			ar >> strName;

			CMFCOutlookBarPane* pPage = new CMFCOutlookBarPane();
			pPage->Create(this, AFX_DEFAULT_TOOLBAR_STYLE, nID);
			pPage->SetOwner(GetOwner());

			pPage->LoadState(lpszProfileName, nID,  nID);

			m_lstCustomPages.AddTail(pPage);
			pOutlookBar->AddTab(pPage, strName);

			g_arTakenIDs [nID - g_nMinReservedPageID] = true;
		}

		int nVisiblePages = 0;
		ar >> nVisiblePages;

		pOutlookBar->SetVisiblePageButtons(nVisiblePages);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMFCOutlookBar::SaveState()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Archive exception in CMFCOutlookBar::LoadState()!\n"));
	}

	delete [] lpbData;
	return TRUE;
}

BOOL CMFCOutlookBar::SaveState(LPCTSTR lpszProfileName, int nIndex, UINT uiID)
{
	CBaseTabbedPane::SaveState(lpszProfileName, nIndex, uiID);

	for (POSITION pos = m_lstCustomPages.GetHeadPosition(); pos != NULL;)
	{
		CMFCOutlookBarPane* pPage = (CMFCOutlookBarPane*)m_lstCustomPages.GetNext(pos);
		ASSERT_VALID(pPage);
		int nID = pPage->GetDlgCtrlID();
		pPage->SaveState(lpszProfileName, nID, nID);
	}

	CString strProfileName = ::AFXGetRegPath(strOutlookBarProfile, lpszProfileName);

	if (nIndex == -1)
	{
		nIndex = GetDlgCtrlID();
	}

	CString strSection;
	if (uiID == (UINT) -1)
	{
		strSection.Format(AFX_REG_SECTION_FMT, (LPCTSTR)strProfileName, nIndex);
	}
	else
	{
		strSection.Format(AFX_REG_SECTION_FMT_EX, (LPCTSTR)strProfileName, nIndex, uiID);
	}

	try
	{
		CMemFile file;

		{
			CArchive ar(&file, CArchive::store);

			ar <<(int) m_lstCustomPages.GetCount();
			for (POSITION pos = m_lstCustomPages.GetHeadPosition(); pos != NULL;)
			{
				CMFCOutlookBarPane* pPage = (CMFCOutlookBarPane*)m_lstCustomPages.GetNext(pos);
				ASSERT_VALID(pPage);

				ar << pPage->GetDlgCtrlID();

				CString strName;
				if (pPage->IsTabbed())
				{
					pPage->GetWindowText(strName);
				}
				else
				{
					pPage->GetParent()->GetWindowText(strName);
				}

				ar << strName;
			}

			CMFCOutlookBarTabCtrl* pOutlookBar = (CMFCOutlookBarTabCtrl*) GetUnderlyingWindow();
			if (pOutlookBar != NULL)
			{
				ar << pOutlookBar->GetVisiblePageButtons();
			}
			else
			{
				ar << -1;
			}

			ar.Flush();
		}

		UINT uiDataSize = (UINT) file.GetLength();
		LPBYTE lpbData = file.Detach();

		if (lpbData != NULL)
		{
			CSettingsStoreSP regSP;
			CSettingsStore& reg = regSP.Create(FALSE, FALSE);

			if (reg.CreateKey(strSection))
			{
				reg.Write(strRegCustomPages, lpbData, uiDataSize);
			}

			free(lpbData);
		}
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Memory exception in CMFCOutlookBar::SaveState()!\n"));
	}
	catch(CArchiveException* pEx)
	{
		pEx->Delete();
		TRACE(_T("Archive exception in CMFCOutlookBar::SaveState()!\n"));
	}

	return TRUE;
}

UINT CMFCOutlookBar::FindAvailablePageID()
{
	for (UINT ui = 0; ui < AFX_TOTAL_RESERVED_PAGES; ui++)
	{
		if (!g_arTakenIDs [ui])
		{
			return ui + g_nMinReservedPageID;
		}
	}

	return 0xFFFF;
}

void CMFCOutlookBar::SetMode2003(BOOL bMode2003/* = TRUE*/)
{
	ASSERT_VALID(this);

	if (GetSafeHwnd() != NULL)
	{
		ASSERT(FALSE);
		return;
	}

	m_bMode2003 = bMode2003;
}

void CMFCOutlookBar::SetButtonsFont(CFont* pFont, BOOL bRedraw/* = TRUE*/)
{
	ASSERT_VALID(this);
	m_pFontButtons = pFont;

	if (bRedraw && GetSafeHwnd() != NULL)
	{
		RedrawWindow(NULL, NULL, R