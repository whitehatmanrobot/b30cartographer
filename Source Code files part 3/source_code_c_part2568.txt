e
		specified MIDI input channel.

@parm   DWORD | dwInputChannel | MIDI Input channel number. Must be between 0 and 15, inclusive.

@rvalue S_OK | The operation succeeded.
@rvalue S_FALSE | No PChannel Thru is already active on that input channel
@rvalue E_UNEXPECTED | The Performance engine does not exist.
@rvalue E_FAIL | There is no DirectMusic MIDI input port.
@rvalue E_INVALIDARG | <p dwInputChannel> is greater than 15.

@xref  <i IDMUSProdConductor>, <om IDMUSProdConductor.SetPChannelThru>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::CancelPChannelThru( DWORD dwInputChannel )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( dwInputChannel > 15 )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_UNEXPECTED;

	if( m_pDMPerformance
	&&	g_pMIDIInputContainer )
	{
		hr = g_pMIDIInputContainer->CancelPChannelThru( dwInputChannel );
	}

	return hr;
}


/*======================================================================================
METHOD:  ICONDUCTOR::IsTrackCursorEnabled
========================================================================================
@method HRESULT | IDMUSProdConductor| IsTrackCursorEnabled | Queries the state of the Transport Options toolbar's Track Cursor button.

@comm	When the Track Cursor button is down, the playing transport should display an indication
	of the current play position and the display should scroll to keep the current play position
	in view.  When the Track Cursor button is up, the display should not automatically scroll. 

@rvalue S_OK | The Track Cursor button is down (Time cursor should be tracked).
@rvalue S_FALSE | The Track Cursor button is up (Time cursor should not be tracked).
@rvalue E_FAIL | An error occurred.

@xref  <i IDMUSProdConductor>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::IsTrackCursorEnabled( )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !m_pOptionsToolbarHandler )
	{
		return E_FAIL;
	}

	return m_pOptionsToolbarHandler->m_fCursorEnabled ? S_OK : S_FALSE;
}


/*======================================================================================
METHOD:  ICONDUCTOR8::RegisterAudiopath
========================================================================================
@method HRESULT | IDMUSProdConductor8| RegisterAudiopath | Registers an Audiopath node.

@xref  <i IDMUSProdConductor8>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::RegisterAudiopath( IDMUSProdNode *pAudiopathNode, BSTR bstrName )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( bstrName == NULL )
	{
		return E_INVALIDARG;
	}
	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( pAudiopathNode == NULL )
	{
		return E_POINTER;
	}

	// Find the item in our list of Audiopaths
	POSITION pos = m_lstAudiopaths.GetHeadPosition();
	while( pos )
	{
		CAudiopathListItem* pAPListItem = m_lstAudiopaths.GetNext( pos );
		if( pAPListItem->pNode == pAudiopathNode )
		{
			// Already exists!
			return E_INVALIDARG;
		}
	}

	// Create and add an item to our list of Audiopaths
	CAudiopathListItem* pAPListItem = new CAudiopathListItem( pAudiopathNode, 0, 0 );
	if( pAPListItem )
	{
		pAPListItem->strName = strName;
		m_lstAudiopaths.AddTail( pAPListItem );

		return S_OK;
	}
	return E_OUTOFMEMORY;
}


/*======================================================================================
METHOD:  ICONDUCTOR8::UnRegisterAudiopath
========================================================================================
@method HRESULT | IDMUSProdConductor8| UnRegisterAudiopath | Unregisters an Audiopath node.

@xref  <i IDMUSProdConductor8>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::UnRegisterAudiopath( IDMUSProdNode *pAudiopathNode )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pAudiopathNode == NULL )
	{
		return E_POINTER;
	}

	// Find the item in our list of Audiopaths
	POSITION pos = m_lstAudiopaths.GetHeadPosition();
	while( pos )
	{
		POSITION posCurrent = pos;
		CAudiopathListItem* pAPListItem = m_lstAudiopaths.GetNext( pos );
		if( pAPListItem->pNode == pAudiopathNode )
		{
			// Check if the audiopath is in use
			if( m_pAudiopathListItem == pAPListItem )
			{
				// Yes - need to change to 'none'

				// Display an hourglass cursor
				CWaitCursor waitCursor;

				// Broadcast the WaveUnload notification
				BroadCastWaveNotification( GUID_ConductorUnloadWaves );

				// Set the old audio path to be inactive
				// Try and get the IDMUSProdAudioPathInUse interface for the node
				IDMUSProdAudioPathInUse *pIDMUSProdAudiopathInUse;
				if( SUCCEEDED( pAudiopathNode->QueryInterface( IID_IDMUSProdAudioPathInUse, (void **)&pIDMUSProdAudiopathInUse ) ) )
				{
					// Notify the Audiopath that it is no longer in use
					//pIDMUSProdAudiopathInUse->UsingAudioPath( pOldAudiopath, FALSE );
					pIDMUSProdAudiopathInUse->UsingAudioPath( m_pDMAudiopath, FALSE );
					pIDMUSProdAudiopathInUse->Release();
				}

				m_pFrameWork->RemoveFromNotifyList( pAudiopathNode, this );

				// Initialize the ListItem pointer to NULL
				m_pAudiopathListItem = NULL;

				// Ensure that there is no default audiopath
				// This also releases our pointer to the old audio path
				ActivateAudiopath( NULL );

				// Update the transport toolbar
				if( m_pToolbarHandler )
				{
					m_pToolbarHandler->UpdateActiveFromEngine();
					m_pToolbarHandler->SetStateAuto();
				}

				// Remove all items from the combo box, then add and select the Audiopath used by the conductor
				m_pOptionsToolbarHandler->UpdateComboBoxFromConductor();

				// Notify all other components that output has been changed
				BroadCastPortChangeNotification();
			}

			m_lstAudiopaths.RemoveAt( posCurrent );
			delete pAPListItem;
			return S_OK;
		}
	}

	return E_INVALIDARG;
}


/*======================================================================================
METHOD:  ICONDUCTOR8::SetAudiopathName
========================================================================================
@method HRESULT | IDMUSProdConductor8| SetAudiopathName | Update the name of an Audiopath node.

@xref  <i IDMUSProdConductor8>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::SetAudiopathName( IDMUSProdNode *pAudiopathNode, BSTR bstrName )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( bstrName == NULL )
	{
		return E_INVALIDARG;
	}
	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( pAudiopathNode == NULL )
	{
		return E_POINTER;
	}

	if( strName.IsEmpty() )
	{
		return E_INVALIDARG;
	}

	// Find the item in our list of Audiopaths
	POSITION pos = m_lstAudiopaths.GetHeadPosition();
	while( pos )
	{
		CAudiopathListItem* pAPListItem = m_lstAudiopaths.GetNext( pos );
		if( pAPListItem->pNode == pAudiopathNode )
		{
			pAPListItem->strName = strName;

			if( m_pAudiopathListItem == pAPListItem )
			{
				m_pOptionsToolbarHandler->UpdateComboBoxFromConductor();
			}

			return S_OK;
		}
	}

	return E_INVALIDARG;
}


/*======================================================================================
METHOD:  ICONDUCTOR8::GetDownloadCustomDLSStatus
========================================================================================
@method HRESULT | IDMUSProdConductor8| GetDownloadCustomDLSStatus | Get whether or not
	custom DLS collections should be downloaded.

@xref  <i IDMUSProdConductor8>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::GetDownloadCustomDLSStatus( BOOL *pfDownloadCustomDLS )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pfDownloadCustomDLS == NULL )
	{
		return E_POINTER;
	}

	*pfDownloadCustomDLS = m_fDownloadDLS;

	return S_OK;
}


/*======================================================================================
METHOD:  ICONDUCTOR8::GetDownloadGMStatus
========================================================================================
@method HRESULT | IDMUSProdConductor8| GetDownloadGMStatus | Get whether or not the
	standard GM collection should be downloaded.

@xref  <i IDMUSProdConductor8>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::GetDownloadGMStatus( BOOL *pfDownloadGM )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pfDownloadGM == NULL )
	{
		return E_POINTER;
	}

	*pfDownloadGM = m_fDownloadGM;

	return S_OK;
}


/*======================================================================================
METHOD:  ICONDUCTOR8::SetupMIDIAndWaveSave
========================================================================================
@method HRESULT | IDMUSProdConductor8| SetupMIDIAndWaveSave | Initialize the MIDI Save
	and Wave export objects in the given segment state.

@xref  <i IDMUSProdConductor8>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::SetupMIDIAndWaveSave( IUnknown *punkSegmentState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( punkSegmentState )
	{
		IDirectMusicSegment8 *pIDirectMusicSegment8;
		IDirectMusicSegmentState8 *pIDirectMusicSegmentState8;
		if( SUCCEEDED( punkSegmentState->QueryInterface( IID_IDirectMusicSegmentState8, (void**)&pIDirectMusicSegmentState8 ) ) )
		{
			AddToolsAndSetupWaveSaveForSegState( punkSegmentState );
			pIDirectMusicSegmentState8->Release();
			return S_OK;
		}
		else if( SUCCEEDED( punkSegmentState->QueryInterface( IID_IDirectMusicSegment8, (void**)&pIDirectMusicSegment8 ) ) )
		{
			IUnknown *punkAudiopathConfig;
			if( SUCCEEDED( pIDirectMusicSegment8->GetAudioPathConfig( &punkAudiopathConfig ) ) )
			{
				IDirectMusicGraph* pGraph;
				if( SUCCEEDED( pIDirectMusicSegment8->GetGraph( &pGraph ) ) )
				{
					AddToolsToToolgraph( pGraph, m_pOutputTool, m_pMIDISaveTool );
					pGraph->Release();
				}
				else if( SUCCEEDED( ::CoCreateInstance( CLSID_DirectMusicGraph, NULL, CLSCTX_INPROC_SERVER, IID_IDirectMusicGraph, (void **)&pGraph ) ) )
				{
					if( SUCCEEDED( pIDirectMusicSegment8->SetGraph( pGraph ) ) )
					{
						AddToolsToToolgraph( pGraph, m_pOutputTool, m_pMIDISaveTool );
					}
					pGraph->Release();
				}
				punkAudiopathConfig->Release();
			}
			pIDirectMusicSegment8->Release();
			return S_OK;
		}
	}

	return E_POINTER;
}


/*======================================================================================
METHOD:  ICONDUCTOR8::GetAudioParams
========================================================================================
@method HRESULT | IDMUSProdConductor8| GetAudioParams | Fill out the <p pDMUSAudioParams>
	structure with the current performance's audio parameters.

@parm   <t DMUS_AUDIOPARAMS> | pDMUSAudioParams | Pointer to a <t DMUS_AUDIOPARAMS> structure.

@rvalue S_OK | The operation succeeded.
@rvalue E_POINTER | <p pDMUSAudioParams> is NULL.
@rvalue E_INVALIDARG | The dwSize member of <p pDMUSAudioParams> is invalid.

@xref  <i IDMUSProdConductor8>, <t DMUS_AUDIOPARAMS>

--------------------------------------------------------------------------------------*/
HRESULT STDMETHODCALLTYPE CConductor::GetAudioParams( DMUS_AUDIOPARAMS *pDMUSAudioParams )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if( pDMUSAudioParams == NULL )
	{
		return E_POINTER;
	}

	ASSERT( pDMUSAudioParams->dwSize == sizeof( DMUS_AUDIOPARAMS ) );
	if( pDMUSAudioParams->dwSize != sizeof( DMUS_AUDIOPARAMS ) )
	{
		return E_INVALIDARG;
	}

	pDMUSAudioParams->fInitNow = FALSE;
	pDMUSAudioParams->dwValidData = DMUS_AUDIOPARAMS_VOICES | DMUS_AUDIOPARAMS_SAMPLERATE | DMUS_AUDIOPARAMS_FEATURES | DMUS_AUDIOPARAMS_DEFAULTSYNTH;
	pDMUSAudioParams->dwFeatures = 0;
	pDMUSAudioParams->dwVoices = m_dwVoices;
	pDMUSAudioParams->dwSampleRate = m_dwSampleRate;
	pDMUSAudioParams->clsidDefaultSynth = m_clsidDefaultSynth;

	// The capabilities of the default synth
	DWORD dwDefaultSynthFlags = 0;

	// Initialize dwDefaultSynthFlags
	if( GUID_Synth_Default == m_clsidDefaultSynth )
	{
		dwDefaultSynthFlags = DMUS_PC_DLS | DMUS_PC_SOFTWARESYNTH | DMUS_PC_DIRECTSOUND | DMUS_PC_DLS2 | DMUS_PC_AUDIOPATH | DMUS_PC_WAVE;
	}
	else
	{
		// Try and find the portcaps for the default synth
		DMUS_PORTCAPS dmPortCaps;
		if( GetPortCaps( m_pDMusic, m_clsidDefaultSynth, &dmPortCaps ) )
		{
			dwDefaultSynthFlags = dmPortCaps.dwFlags;
		}
		else
		{
			// Port doesn't exist - fallback to the default synth
			m_clsidDefaultSynth = GUID_Synth_Default;
			dwDefaultSynthFlags = DMUS_PC_DLS | DMUS_PC_SOFTWARESYNTH | DMUS_PC_DIRECTSOUND | DMUS_PC_DLS2 | DMUS_PC_AUDIOPATH | DMUS_PC_WAVE;
		}
	}

	// If the default synth supports audiopaths
	if( dwDefaultSynthFlags & DMUS_PC_AUDIOPATH )
	{
		// If the default synth does not support waves, clear the DMUS_AUDIOF_STREAMING flag
		if( !(dwDefaultSynthFlags & DMUS_PC_WAVE) )
		{
			pDMUSAudioParams->dwFeatures = (DMUS_AUDIOF_ALL ^ DMUS_AUDIOF_STREAMING);
		}
		else
		{
			// Otherwise, request all features
			pDMUSAudioParams->dwFeatures = DMUS_AUDIOF_ALL;
		}
	}

	// If the default synth is not specified, clear the DMUS_AUDIOPARAMS_DEFAULTSYNTH flag
	if( GUID_Synth_Default == pDMUSAudioParams->clsidDefaultSynth )
	{
		pDMUSAudioParams->dwValidData &= ~DMUS_AUDIOPARAMS_DEFAULTSYNTH;
	}

	return S_OK;
}


// IDMUSProdNotifySink
HRESULT STDMETHODCALLTYPE CConductor::OnUpdate( IDMUSProdNode *pIDocRootNode, GUID guidUpdateType, void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(pData);

	if( pIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	if( AUDIOPATH_NeedToRebuildNotification != guidUpdateType )
	{
		return E_INVALIDARG;
	}

	if( pData == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	DWORD dwFlags = *((DWORD *)pData);

	// Find the item in our list of Audiopaths
	POSITION pos = m_lstAudiopaths.GetHeadPosition();
	while( pos )
	{
		CAudiopathListItem* pAPListItem = m_lstAudiopaths.GetNext( pos );
		if( pAPListItem->pNode == pIDocRootNode )
		{
			// Check if the audiopath is in use
			if( m_pAudiopathListItem == pAPListItem )
			{
				// Display an hourglass cursor
				CWaitCursor waitCursor;

				// Try and get the IDMUSProdAudioPathInUse interface for the node
				IDMUSProdAudioPathInUse *pIDMUSProdAudiopathInUse;
				if( SUCCEEDED( pIDocRootNode->QueryInterface( IID_IDMUSProdAudioPathInUse, (void **)&pIDMUSProdAudiopathInUse ) ) )
				{
					// Notify the Audiopath that the old audiopath is no longer in use
					pIDMUSProdAudiopathInUse->UsingAudioPath( m_pDMAudiopath, FALSE );
					pIDMUSProdAudiopathInUse->Release();
				}

				CTypedPtrList<CPtrList, CDownloadedInstrumentList*> lstDownloadedInstrumentList;
				while( !m_lstDownloadedInstrumentList.IsEmpty() )
				{
					lstDownloadedInstrumentList.AddTail( m_lstDownloadedInstrumentList.RemoveHead() );
				}

				// Broadcast the WaveUnload notification
				if( dwFlags & AUDIOPATH_UNLOAD_DOWNLOAD_WAVES )
				{
					BroadCastWaveNotification( GUID_ConductorUnloadWaves );
				}

				// Remove the existing audiopath - this ensures that the 'shared'
				// buffers are created properly
				ActivateAudiopath( NULL, false );

				// Create the new audiopath
				IDirectMusicAudioPath *pAudiopath = NULL;
				HRESULT hrCreate = CreateAudiopath( m_pAudiopathListItem, &pAudiopath );

				// Activate the Audio path (if creation failed, this will set the active audiopath to 'none'
				HRESULT hrActivate = ActivateAudiopath( pAudiopath, false );

				// Flag whether or not to send the port changed notification
				bool fSendPortChangedNotify = false;

				// If either activation or creation of the new audiopath failed
				if( FAILED( hrCreate )
				||	FAILED( hrActivate ) )
				{
					// Broadcast the WaveFlush notification
					BroadCastWaveNotification( GUID_ConductorFlushWaves );

					// Unload the instruments from the old audiopath
					while( !lstDownloadedInstrumentList.IsEmpty() )
					{
						delete lstDownloadedInstrumentList.RemoveHead();
					}

					// Remove from the audiopath's notification list
					m_pFrameWork->RemoveFromNotifyList( pIDocRootNode, g_pconductor );

					// Initialize the ListItem pointer to NULL
					m_pAudiopathListItem = NULL;

					// Ensure that no audiopath is set as the default
					// This will also release our pointer to the existing audio path
					ActivateAudiopath( NULL, true );

					// Need to send the port changed notification
					fSendPortChangedNotify = true;
				}
				else
				{
					// Otherwise, keep the ListItem pointer the same
					// Notify the Audiopath node that it now in use
					// Try and get the IDMUSProdAudioPathInUse interface for the node
					if( SUCCEEDED( m_pAudiopathListItem->pNode->QueryInterface( IID_IDMUSProdAudioPathInUse, (void **)&pIDMUSProdAudiopathInUse ) ) )
					{
						pIDMUSProdAudiopathInUse->UsingAudioPath( pAudiopath, TRUE );
						pIDMUSProdAudiopathInUse->Release();
					}
					
					// Check if we need to unload and download the instruments
					// Make a list of the ports in the current audiopath
					CTypedPtrList<CPtrList, IDirectMusicPort*> lstPorts;
					IDirectMusicPort *pDMPort = NULL;

					// Iterate through the default Audiopath's port
					DMUS_PORTCAPS dmPortCaps;
					DWORD dwIndex = 0;
					while( S_OK == pAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void **)&pDMPort ) )
					{
						// Verify we have a valid port pointer
						ASSERT( pDMPort );

						// Initialize the DMUS_PORTCAPS structure
						dmPortCaps.dwSize = sizeof(DMUS_PORTCAPS);

						// Try and get the capabilities of this port, and check if it supports DLS
						// and doesn't already have GS in hardware
						if( SUCCEEDED( pDMPort->GetCaps( &dmPortCaps ) )
						&&	(dmPortCaps.dwFlags & DMUS_PC_DLS)
						&&	!(dmPortCaps.dwFlags & DMUS_PC_GSINHARDWARE) )
						{
							lstPorts.AddTail( pDMPort );
							pDMPort->AddRef();
						}

						// Release the port
						pDMPort->Release();

						// Go on to the next port in the audio path
						dwIndex++;
					}

					// Iterate through the list of downloaded instrument lists
					POSITION posDL = lstDownloadedInstrumentList.GetHeadPosition();
					while( posDL )
					{
						// Save pointer to our current location
						const POSITION posCurrentDL = posDL;

						// Get a pointer to each downloaded instrument list
						CDownloadedInstrumentList *pCDownloadedInstrumentList = lstDownloadedInstrumentList.GetNext( posDL );

						// Iterate through all the ports in the new audiopath
						POSITION posPort = lstPorts.GetHeadPosition();
						while( posPort )
						{
							// Save a pointer to our current port position
							const POSITION posCurrentPort = posPort;

							// Get a poitner to each port
							pDMPort = lstPorts.GetNext( posPort );

							// Check if this is the port we're looking for
							if( pDMPort == pCDownloadedInstrumentList->m_pDMPort )
							{
								// yes - add it back to the mail downloaded instruments list
								m_lstDownloadedInstrumentList.AddTail( pCDownloadedInstrumentList );

								// Remove it from our private downloaded instruments list
								lstDownloadedInstrumentList.RemoveAt( posCurrentDL );

								// Remove the port from lstPorts
								lstPorts.RemoveAt( posCurrentPort );

								// Release our pointer to the port
								pDMPort->Release();

								break;
							}
						}
					}

					if( !lstDownloadedInstrumentList.IsEmpty()
					||	!lstPorts.IsEmpty() )
					{
						while( !lstDownloadedInstrumentList.IsEmpty() )
						{
							delete lstDownloadedInstrumentList.RemoveHead();
						}
						while( !lstPorts.IsEmpty() )
						{
							lstPorts.RemoveHead()->Release();
						}

						// Send the port removal notification
						BroadCastPortRemovalNotification();

						// Download GM
						DownOrUnLoadGM();

						// Need to send the port changed notification
						fSendPortChangedNotify = true;
					}
				}

				// Release our pointer to the new audio path
				if( pAudiopath )
				{
					pAudiopath->Release();
				}

				// Update the transport toolbar
				if( m_pToolbarHandler )
				{
					m_pToolbarHandler->UpdateActiveFromEngine();
					m_pToolbarHandler->SetStateAuto();
				}

				// Remove all items from the combo box, then add and select the Audiopath used by the conductor
				m_pOptionsToolbarHandler->UpdateComboBoxFromConductor();

				// Broadcast the WaveDownload notification
				if( dwFlags & AUDIOPATH_UNLOAD_DOWNLOAD_WAVES )
				{
					BroadCastWaveNotification( GUID_ConductorDownloadWaves );
				}

				// Notify all other components that output has been changed
				if( fSendPortChangedNotify )
				{
					BroadCastPortChangeNotification();
				}

				// If either activation or creation of the new audiopath failed
				if( FAILED( hrCreate )
				||	FAILED( hrActivate ) )
				{
					ASSERT( m_pAudiopathListItem == NULL );

					// Iterate through all registered audiopaths
					POSITION pos = m_lstAudiopaths.GetHeadPosition();
					while( pos )
					{
						CAudiopathListItem *pAPListItem = m_lstAudiopaths.GetNext( pos );

						if( pAPListItem->dwStandardID == DMUS_APATH_SHARED_STEREOPLUSREVERB
						&&	pAPListItem->pNode == NULL )
						{
							// Add the text to the combo box
							int nStringIndex = m_pOptionsToolbarHandler->m_comboAudiopath.AddString( pAPListItem->strName );

							// Create a new AudiopathListItem to store information about this Audiopath in
							// Set the combobox item to point to this AudiopathListItem
							m_pOptionsToolbarHandler->m_comboAudiopath.SetItemDataPtr( nStringIndex, pAPListItem );

							m_pOptionsToolbarHandler->m_comboAudiopath.SetCurSel( nStringIndex );
							break;
						}
					}

					BOOL bHandled = FALSE;
					m_pOptionsToolbarHandler->OnCloseUpComboAudiopath( 0, 0, 0, bHandled );
				}
			}

			return S_OK;
		}
	}

	return E_INVALIDARG;
}


// IDMUSProdComponent
HRESULT STDMETHODCALLTYPE CConductor::Initialize( IDMUSProdFramework __RPC_FAR* pFrameWork, BSTR __RPC_FAR* pbstrErrorText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( pbstrErrorText != NULL )
    {
        *pbstrErrorText = NULL;
    }
    if( pFrameWork == NULL )
    {
        return E_INVALIDARG;
    }
    if( m_pFrameWork != NULL )
    {
		return S_OK;  // only initialize once
	}

	HRESULT hr;

	// Verify we're running on the DX8 framework
	hr = pFrameWork->QueryInterface( IID_IDMUSProdFramework8, (void **)&m_pFrameWork );
	if( m_pFrameWork == NULL )
	{
		CString strError;
		strError.LoadString( IDS_ERR_NEED_DX8_FRAMEWORK );
		*pbstrErrorText = strError.AllocSysString();
		return hr;
	}

	// create an invisible window that is used to catch toolbar messages
	CRect rect( 0, 0, 0, 0 );
	CWnd* pWndParent = new CWnd;
	if( !pWndParent )
	{
		ReleaseAll();
		return E_OUTOFMEMORY;
	}
	if( !pWndParent->CreateEx(0, AfxRegisterWndClass(0), NULL, WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL) )
	{
		delete pWndParent;
		ReleaseAll();
		return E_FAIL;
	}

	m_pToolbarHandler = new CComObject<CToolbarHandler>();
	if ( !m_pToolbarHandler )
	{
		pWndParent->DestroyWindow();
		delete pWndParent;
		ReleaseAll();
		return E_OUTOFMEMORY;
	}
	if( m_pToolbarHandler->Create( pWndParent->GetSafeHwnd(), rect, NULL, WS_CHILD ) == 0 )
	{
		pWndParent->DestroyWindow();
		delete pWndParent;
		delete m_pToolbarHandler;
		m_pToolbarHandler = NULL;
		ReleaseAll();
		return E_FAIL;
	}
	hr = m_pFrameWork->AddToolBar(m_pToolbarHandler);

	//  IDMUSProdFramework::AddToolBar reassigns parent so it is ok to destroy pWndParent
	if( pWndParent->GetSafeHwnd() )
	{
		pWndParent->DestroyWindow();
	}
	delete pWndParent;
	pWndParent = NULL;

	if( FAILED( hr ) )
	{
		// clean up
		if( m_pToolbarHandler->m_hWnd )
		{
			m_pToolbarHandler->DestroyWindow();
		}
		delete m_pToolbarHandler;
		m_pToolbarHandler = NULL;
		ReleaseAll();
		return E_FAIL;
	}

	CString strError;
	hr = InitializeDirectMusic( strError );
	if( FAILED( hr ) )
	{
		if( ::IsWindow(m_pToolbarHandler->m_hWnd) )
		{
			m_pToolbarHandler->DestroyWindow();
		}
		m_pFrameWork->RemoveToolBar(m_pToolbarHandler);
		m_pToolbarHandler = NULL;

		if( !strError.IsEmpty() )
		{
			*pbstrErrorText = strError.AllocSysString();
		}
		ReleaseAll();
		return hr;
	}

	////////////////////////////////////////////////////////////////////////
	// S_OK will be returned if we make it to this point.
	// Any failures from this point forward are not considered important
	// enough to cause Initilaize() to fail.
	////////////////////////////////////////////////////////////////////////

	// Create Options toolbar
	////////////////////////////////////////////////////////////////////////
	m_pOptionsToolbarHandler = new CComObject<COptionsToolbarHandler>();
	if ( m_pOptionsToolbarHandler )
	{
		pWndParent = CreateParentWindow();
		if( !pWndParent )
		{
			// clean up
			delete m_pOptionsToolbarHandler;
			m_pOptionsToolbarHandler = NULL;
		}
		else
		{
			rect = CRect( 0, 0, 0, 0 );
			if( m_pOptionsToolbarHandler->Create( pWndParent->GetSafeHwnd(), rect, NULL, WS_CHILD ) == 0 )
			{
				// clean up
				pWndParent->DestroyWindow();
				delete m_pOptionsToolbarHandler;
				m_pOptionsToolbarHandler = NULL;
			}
			else
			{
				hr = m_pFrameWork->AddToolBar(m_pOptionsToolbarHandler);

				//  IDMUSProdFramework::AddToolBar reassigns parent so it is ok to destroy pWndParent
				if( pWndParent->GetSafeHwnd() )
				{
					pWndParent->DestroyWindow();
				}

				if( FAILED( hr ) )
				{
					// clean up
					if( m_pOptionsToolbarHandler->m_hWnd )
					{
						m_pOptionsToolbarHandler->DestroyWindow();
					}
					delete m_pOptionsToolbarHandler;
					m_pOptionsToolbarHandler = NULL;
				}
				else
				{
					// Succeeded
				}
			}
			delete pWndParent;
			pWndParent = NULL;
		}
	}

	// Create Status toolbar
	////////////////////////////////////////////////////////////////////////
	m_pStatusToolbarHandler = new CComObject<CStatusToolbarHandler>();
	if ( m_pStatusToolbarHandler )
	{
		pWndParent = CreateParentWindow();
		if( !pWndParent )
		{
			// clean up
			delete m_pStatusToolbarHandler;
			m_pStatusToolbarHandler = NULL;
		}
		else
		{
			rect = CRect( 0, 0, 0, 0 );
			if( m_pStatusToolbarHandler->Create( pWndParent->GetSafeHwnd(), rect, NULL, WS_CHILD ) == 0 )
			{
				// clean up
				pWndParent->DestroyWindow();
				delete m_pStatusToolbarHandler;
				m_pStatusToolbarHandler = NULL;
			}
			else
			{
				hr = m_pFrameWork->AddToolBar(m_pStatusToolbarHandler);

				//  IDMUSProdFramework::AddToolBar reassigns parent so it is ok to destroy pWndParent
				if( pWndParent->GetSafeHwnd() )
				{
					pWndParent->DestroyWindow();
				}

				if( FAILED( hr ) )
				{
					// clean up
					if( m_pStatusToolbarHandler->m_hWnd )
					{
						m_pStatusToolbarHandler->DestroyWindow();
					}
					delete m_pStatusToolbarHandler;
					m_pStatusToolbarHandler = NULL;
				}
				else
				{
					m_pStatusToolbarHandler->EnableTimer(TRUE);
				}
			}
			delete pWndParent;
			pWndParent = NULL;
		}
	}

	// Create Secondary Segment toolbar
	////////////////////////////////////////////////////////////////////////
	CSecondaryToolbarHandler *pToolbarHandler = new CComObject<CSecondaryToolbarHandler>();
	if ( pToolbarHandler )
	{
		pWndParent = CreateParentWindow();
		if( !pWndParent )
		{
			// clean up
			delete pToolbarHandler;
		}
		else
		{
			rect = CRect( 0, 0, 0, 0 );
			if( pToolbarHandler->Create( pWndParent->GetSafeHwnd(), rect, NULL, WS_CHILD ) == 0 )
			{
				// clean up
				pWndParent->DestroyWindow();
				delete pToolbarHandler;
			}
			else
			{
				hr = m_pFrameWork->AddToolBar(pToolbarHandler);

				//  IDMUSProdFramework::AddToolBar reassigns parent so it is ok to destroy pWndParent
				if( pWndParent->GetSafeHwnd() )
				{
					pWndParent->DestroyWindow();
				}

				if( FAILED( hr ) )
				{
					// clean up
					if( pToolbarHandler->m_hWnd )
					{
						pToolbarHandler->DestroyWindow();
					}
					delete pToolbarHandler;
				}
				else
				{
					m_lstSecondaryToolbars.AddHead( pToolbarHandler );
				}
			}
			delete pWndParent;
			pWndParent = NULL;
		}
	}

	// Create Synth Status toolbar
	////////////////////////////////////////////////////////////////////////
	m_pSynthStatusToolbar = new CComObject<CSynthStatusToolbar>();
	if ( m_pSynthStatusToolbar )
	{
		pWndParent = CreateParentWindow();
		if( !pWndParent )
		{
			// clean up
			delete m_pSynthStatusToolbar;
			m_pSynthStatusToolbar = NULL;
		}
		else
		{
			rect = CRect( 0, 0, 0, 0 );
			if( m_pSynthStatusToolbar->Create( pWndParent->GetSafeHwnd(), rect, NULL, WS_CHILD ) == 0 )
			{
				// clean up
				pWndParent->DestroyWindow();
				delete m_pSynthStatusToolbar;
				m_pSynthStatusToolbar = NULL;
			}
			else
			{
				hr = m_pFrameWork->AddToolBar(m_pSynthStatusToolbar);

				//  IDMUSProdFramework::AddToolBar reassigns parent so it is ok to destroy pWndParent
				if( pWndParent->GetSafeHwnd() )
				{
					pWndParent->DestroyWindow();
				}

				if( FAILED( hr ) )
				{
					// clean up
					if( m_pSynthStatusToolbar->m_hWnd )
					{
						m_pSynthStatusToolbar->DestroyWindow();
					}
					delete m_pSynthStatusToolbar;
					m_pSynthStatusToolbar = NULL;
				}
				else
				{
					m_pSynthStatusToolbar->EnableTimer(TRUE);
				}
			}
			delete pWndParent;
			pWndParent = NULL;
		}
	}

	// Create Wave Recording toolbar
	////////////////////////////////////////////////////////////////////////
	m_pWaveRecordToolbar = new CComObject<CWaveRecordToolbar>();
	if ( m_pWaveRecordToolbar )
	{
		pWndParent = CreateParentWindow();
		if( !pWndParent )
		{
			// clean up
			delete m_pWaveRecordToolbar;
			m_pWaveRecordToolbar = NULL;
		}
		else
		{
			rect = CRect( 0, 0, 0, 0 );
			if( m_pWaveRecordToolbar->Create( pWndParent->GetSafeHwnd(), rect, NULL, WS_CHILD ) == 0 )
			{
				// clean up
				pWndParent->DestroyWindow();
				delete m_pWaveRecordToolbar;
				m_pWaveRecordToolbar = NULL;
			}
			else
			{
				hr = m_pFrameWork->AddToolBar(m_pWaveRecordToolbar);

				//  IDMUSProdFramework::AddToolBar reassigns parent so it is ok to destroy pWndParent
				if( pWndParent->GetSafeHwnd() )
				{
					pWndParent->DestroyWindow();
				}

				if( FAILED( hr ) )
				{
					// clean up
					if( m_pWaveRecordToolbar->m_hWnd )
					{
						m_pWaveRecordToolbar->DestroyWindow();
					}
					delete m_pWaveRecordToolbar;
					m_pWaveRecordToolbar = NULL;
				}
				else
				{
					//m_pWaveRecordToolbar->EnableTimer(TRUE);
				}
			}
			delete pWndParent;
			pWndParent = NULL;
		}
	}

	// Create loopback tool
	g_pMIDIInputContainer = new CMIDIInputContainer( m_pDMusic );

	g_pMIDIInputContainer->InitializeFromRegistry();

	// Always enable and check the MIDI and Synth buttons
	if( m_pOptionsToolbarHandler )
	{
		m_pOptionsToolbarHandler->SetBtnState( ID_TRANSP_MIDI, TBSTATE_ENABLED | TBSTATE_CHECKED );
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CConductor::CleanUp()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_hNotifyEvent )
	{
		ASSERT( !m_hNotifyExitEvent );
		m_hNotifyExitEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );
	}

	m_fShutdown = TRUE;

	::EnterCriticalSection( &m_csNotifyEntry );

	CNotifyEntry* pNotifyEntry;
	while( !m_lstNotifyEntry.IsEmpty() )
	{
		pNotifyEntry = m_lstNotifyEntry.RemoveHead();
		delete pNotifyEntry;
	}

	::LeaveCriticalSection( &m_csNotifyEntry );

	// First, de-activate DirectMusic and all of the ports registered with it
	if (m_pDMusic)
	{
		m_pDMusic->Activate( FALSE );
	}

	if (m_pDMPerformance)
	{
		m_pDMPerformance->RemoveNotificationType( GUID_NOTIFICATION_SEGMENT );
		m_pDMPerformance->RemoveNotificationType( GUID_NOTIFICATION_MEASUREANDBEAT );
		m_pDMPerformance->RemoveNotificationType( GUID_NOTIFICATION_PERFORMANCE );

		// Signal the notification event handler thread and wait for it to exit
		if ( m_hNotifyEvent )
		{
			m_pDMPerformance->SetNotificationHandle( NULL, 0 );
			::SetEvent( m_hNotifyEvent );

			::WaitForSingleObject( m_hNotifyExitEvent, 5000 );
			::CloseHandle( m_hNotifyEvent );
			m_hNotifyEvent = NULL;
			::CloseHandle( m_hNotifyExitEvent );
			m_hNotifyExitEvent = NULL;
		}

		m_pDMPerformance->Stop( NULL, NULL, 0, 0 );

		m_pDMPerformance->CloseDown();
	}

	if( m_pToolbarHandler != NULL )
	{
		if( ::IsWindow(m_pToolbarHandler->m_hWnd) )
		{
			m_pToolbarHandler->DestroyWindow();
		}
		m_pFrameWork->RemoveToolBar( m_pToolbarHandler );
		m_pToolbarHandler = NULL;
	}
	if( m_pOptionsToolbarHandler != NULL )
	{
		if( ::IsWindow(m_pOptionsToolbarHandler->m_hWnd) )
		{
			m_pOptionsToolbarHandler->DestroyWindow();
		}
		m_pFrameWork->RemoveToolBar( m_pOptionsToolbarHandler );
		m_pOptionsToolbarHandler = NULL;
	}
	if( m_pStatusToolbarHandler != NULL )
	{
		if( ::IsWindow(m_pStatusToolbarHandler->m_hWnd) )
		{
			m_pStatusToolbarHandler->DestroyWindow();
		}
		m_pFrameWork->RemoveToolBar( m_pStatusToolbarHandler );
		m_pStatusToolbarHandler = NULL;
	}
	if( m_pSynthStatusToolbar != NULL )
	{
		if( ::IsWindow(m_pSynthStatusToolbar->m_hWnd) )
		{
			m_pSynthStatusToolbar->DestroyWindow();
		}
		m_pFrameWork->RemoveToolBar( m_pSynthStatusToolbar );
		m_pSynthStatusToolbar = NULL;
	}
	if( m_pWaveRecordToolbar != NULL )
	{
		if( ::IsWindow(m_pWaveRecordToolbar->m_hWnd) )
		{
			m_pWaveRecordToolbar->DestroyWindow();
		}
		m_pFrameWork->RemoveToolBar( m_pWaveRecordToolbar );
		m_pWaveRecordToolbar = NULL;
	}
	while( !m_lstSecondaryToolbars.IsEmpty() )
	{
		CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.RemoveHead();

		if( ::IsWindow(pToolbarHandler->m_hWnd) )
		{
			pToolbarHandler->DestroyWindow();
		}
		m_pFrameWork->RemoveToolBar( pToolbarHandler );
	}
	if( g_pMIDIInputContainer != NULL )
	{
		delete g_pMIDIInputContainer;
		g_pMIDIInputContainer = NULL;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CConductor::GetName( BSTR __RPC_FAR* pbstrName )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if( pbstrName == NULL )
    {
        return E_INVALIDARG;
    }

    CComBSTR bstrName( "Conductor" );

    *pbstrName = bstrName.Detach();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CConductor::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	UNREFERENCED_PARAMETER(guidRefNodeId);
	UNREFERENCED_PARAMETER(ppIRefNode);
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CConductor::OnActivateApp( BOOL fActivate )
{
	UNREFERENCED_PARAMETER(fActivate);
	// Commented out, per bug #14271
	/*
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( fActivate )
	{
		return ResumeOutput();
	}
	else
	{
		return SuspendOutput();
	}
	*/
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CConductor::PlayFromStart()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_pToolbarHandler )
	{
		BOOL bHandled;
		if( m_pToolbarHandler->m_fDisplayingPlay )
		{
			m_pToolbarHandler->OnRewPlayClicked( 0, 0, NULL, bHandled );
		}
		else
		{
			m_pToolbarHandler->OnStopImmediateClicked( 0, 0, NULL, bHandled );
		}
		return S_OK;
	}
	return E_FAIL;
}

HRESULT STDMETHODCALLTYPE CConductor::PlayFromCursor()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_pToolbarHandler )
	{
		BOOL bHandled;
		if( m_pToolbarHandler->m_fDisplayingPlay )
		{
			m_pToolbarHandler->OnPlayClicked( 0, 0, NULL, bHandled );
		}
		else
		{
			m_pToolbarHandler->OnStopClicked( 0, 0, NULL, bHandled );
		}
		return S_OK;
	}
	return E_FAIL;
}

HRESULT STDMETHODCALLTYPE CConductor::Record()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_pToolbarHandler )
	{
		BOOL bHandled;
		m_pToolbarHandler->OnRecordClicked( 0, 0, NULL, bHandled );
		return S_OK;
	}
	return E_FAIL;
}

HRESULT STDMETHODCALLTYPE CConductor::Transition()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !m_pToolbarHandler )
	{
		return E_FAIL;
	}

	// Get the index of the Transition button
	int nIndex = ::SendMessage( m_pToolbarHandler->m_hWndToolbar, TB_COMMANDTOINDEX, ID_TRANSP_TRANSITION, 0 );

	// Get the state information of the Transition button
	TBBUTTON tbbutton;
	::SendMessage( m_pToolbarHandler->m_hWndToolbar, TB_GETBUTTON, nIndex, (LPARAM)&tbbutton );

	// If it's enabled
	if( tbbutton.fsState & TBSTATE_ENABLED )
	{
		// Pretend the Transition button was pressed
		BOOL bHandled;
		m_pToolbarHandler->OnTransitionClicked( 0, 0, NULL, bHandled );
		return S_OK;
	}
	return E_FAIL;
}

HRESULT STDMETHODCALLTYPE CConductor::SpaceBarPress()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_pToolbarHandler )
	{
		BOOL bHandled;
		if( m_pToolbarHandler->m_fDisplayingPlay )
		{
			m_pToolbarHandler->OnPlayClicked( 0, 0, NULL, bHandled );
		}
		else
		{
			m_pToolbarHandler->OnStopImmediateClicked( 0, 0, NULL, bHandled );
		}
		return S_OK;
	}
	return E_FAIL;
}

HRESULT STDMETHODCALLTYPE CConductor::PlaySecondarySegment( int nSecondarySegment )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( nSecondarySegment < 0 )
	{
		return E_INVALIDARG;
	}

	POSITION pos = m_lstSecondaryToolbars.GetHeadPosition();
	while( pos )
	{
		CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos );

		if( nSecondarySegment < (signed)pToolbarHandler->m_dwNumButtons )
		{
			if( pToolbarHandler->m_arrayButtons[nSecondarySegment]->pISegmentState )
			{
				pToolbarHandler->OnStopClicked( WORD(nSecondarySegment) );
			}
			else
			{
				pToolbarHandler->OnPlayClicked( WORD(nSecondarySegment) );
			}
		}
	}
	return E_FAIL;
}


BOOL CConductor::IsActiveUsingEngine( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_rpActive != NULL )
	{
		DWORD dwFlags;
		m_rpActive->GetFlags( &dwFlags );
		if (!(dwFlags & B_NOT_USING_ENGINE))
		{
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CConductor::IsPlayingUsingEngine( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_rpPlaying != NULL )
	{
		DWORD dwFlags;
		m_rpPlaying->GetFlags( &dwFlags );
		if (!(dwFlags & B_NOT_USING_ENGINE))
		{
			return TRUE;
		}
	}
	return FALSE;
}

ITransportRegEntry *CConductor::GetDisplayedTransport( void )
{
	/*
	if ( !m_fOutputEnabled )
	{
		return NULL;
	}
	*/

	ITransportRegEntry *pRegEntry;

	if( m_rpPlaying != NULL )
	{
		// m_rpPlaying is valid
		pRegEntry = m_rpPlaying;
		/*
		if( m_rpActive != NULL )
		{
			// m_rpActive is valid
			if (m_rpActive == m_rpPlaying)
			{
				pRegEntry = m_rpActive;
			}
			else
			{
				pRegEntry = m_rpPlaying;
			}
		}
		else
		{
			// m_rpActive is invalid
			pRegEntry = m_rpPlaying;
		}
		*/
	}
	else
	{
		// m_rpPlaying is invalid
		if( m_rpActive != NULL )
		{
			// m_iActive is valid
			pRegEntry = m_rpActive;
		}
		else
		{
			// m_rpActive is invalid
			pRegEntry = NULL;
		}
	}
	return pRegEntry;
}

BOOL CConductor::IsEnginePlaying( void )
{
	ASSERT( m_pDMPerformance != NULL );
	if ( m_pDMPerformance == NULL)
	{
		return FALSE;
	}

	MUSIC_TIME mtNow;
	m_pDMPerformance->GetTime( NULL, &mtNow );
	IDirectMusicSegmentState *pSegmentState = NULL;
	if ( FAILED( m_pDMPerformance->GetSegmentState( &pSegmentState, mtNow ) ) )
	{
		return FALSE;
	}

	RELEASE( pSegmentState );

	return TRUE;
}

void AddStandardAudiopath( CTypedPtrList<CPtrList, CAudiopathListItem*> *plstAudiopaths, const DWORD dwStandardID, const DWORD dwXboxID, const int nStringID )
{
	CString strText;
	if( strText.LoadString( nStringID ) )
	{
		// Create a new CAudiopathListItem to store information about this Audiopath in
		CAudiopathListItem *pAudiopathListItem = new CAudiopathListItem(NULL, dwStandardID, dwXboxID);
		if( pAudiopathListItem )
		{
			pAudiopathListItem->strName = strText;
			plstAudiopaths->AddTail( pAudiopathListItem );
		}
	}
}

void CConductor::ReadDefaultDirectMusicAudiopath( IDirectMusicAudioPath **ppAudiopath )
{
	if( ppAudiopath == NULL )
	{
		ASSERT(FALSE);
		return;
	}

	// Add the standard audio paths
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_SHARED_STEREOPLUSREVERB, XBOX_APATH_SHARED_STEREOPLUSREVERB, IDS_APATH_MUSIC );
	// Don't enable, since you can't play any music on it
	//AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_GLOBALFX_ENV, IDS_APATH_ENV );
	//AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_ENV3D, IDS_APATH_3D );
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_MONO, XBOX_APATH_DYNAMIC_MONO, IDS_APATH_MONO );
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_STEREO, XBOX_APATH_SHARED_STEREO, IDS_APATH_STEREO  );
#ifdef DMP_XBOX
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_MONO, XBOX_APATH_MIXBIN_QUAD, IDS_APATH_MIXBIN_QUAD );
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_MONO, XBOX_APATH_MIXBIN_QUAD_ENV, IDS_APATH_MIXBIN_QUAD_ENV );
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_MONO, XBOX_APATH_MIXBIN_QUAD_MUSIC, IDS_APATH_MIXBIN_QUAD_MUSIC );
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_MONO, XBOX_APATH_MIXBIN_5DOT1, IDS_APATH_MIXBIN_5DOT1 );
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_MONO, XBOX_APATH_MIXBIN_5DOT1_ENV, IDS_APATH_MIXBIN_5DOT1_ENV );
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_MONO, XBOX_APATH_MIXBIN_5DOT1_MUSIC, IDS_APATH_MIXBIN_5DOT1_MUSIC );
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_MONO, XBOX_APATH_MIXBIN_STEREO_EFFECTS, IDS_APATH_MIXBIN_STEREO_EFFECTS );
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_3D, XBOX_APATH_DYNAMIC_3D, IDS_APATH_3D_WET );
#else
	AddStandardAudiopath( &m_lstAudiopaths, DMUS_APATH_DYNAMIC_3D, XBOX_APATH_DYNAMIC_3D, IDS_APATH_3D_DRY );
#endif
    
    POSITION pos = m_lstAudiopaths.GetHeadPosition();
	while( pos )
	{
		CAudiopathListItem *pAudiopathListItem = m_lstAudiopaths.GetNext( pos );
		if( !pAudiopathListItem->pNode
		&&	pAudiopathListItem->dwStandardID == DMUS_APATH_SHARED_STEREOPLUSREVERB )
		{
			m_pAudiopathListItem = pAudiopathListItem;
			break;
		}
	}

	ASSERT( m_pAudiopathListItem );

	// Initialize dwNumPChannelsToAskFor
	DWORD dwNumPChannelsToAskFor = DEFAULT_NUM_PCHANNELS;

	if( GUID_Synth_Default != m_clsidDefaultSynth )
	{
		// Try and find the portcaps for the default synth
		DMUS_PORTCAPS dmPortCaps;
		if( GetPortCaps( m_pDMusic, m_clsidDefaultSynth, &dmPortCaps ) )
		{
			dwNumPChannelsToAskFor = min( dwNumPChannelsToAskFor, dmPortCaps.dwMaxChannelGroups * 16 );
		}
	}

	HRESULT hr = m_pDMPerformance->CreateStandardAudioPath( DMUS_APATH_SHARED_STEREOPLUSREVERB, dwNumPChannelsToAskFor, TRUE, ppAudiopath );
#ifdef DMP_XBOX
    if( (XBDM_CANNOTCONNECT == hr)
	||	(XBDM_CANNOTACCESS == hr) )
    {
		CString strError;
        strError.LoadString( (XBDM_CANNOTCONNECT == hr) ? IDS_ERR_CANNOT_CONNECT_XBOX : IDS_ERR_WRONG_VERSION_XBOX );
    	if( IDYES == AfxMessageBox( strError, MB_ICONWARNING | MB_YESNO ) )
        {
            DWORD dwValue = 0;
            SetRegDWORD(HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\XboxAddin\\"), TEXT("EnableXboxSynth"), &dwValue, TRUE);
            dwValue = TRUE;
            SetRegDWORD(HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\XboxAddin\\"), TEXT("EnablePCSynth"), &dwValue, TRUE);
			hr = m_pDMPerformance->CreateStandardAudioPath( DMUS_APATH_SHARED_STEREOPLUSREVERB, dwNumPChannelsToAskFor, TRUE, ppAudiopath );
        }
    }
#endif
	if( FAILED(hr) )
	{
		m_pAudiopathListItem = NULL;
	}
}

// Notify all components in the framework that the output port configuration changed
void CConductor::BroadCastPortChangeNotification( void )
{
	// Reset all thru connections
	UpdateMIDIThruChannels();

	// Reset Echo MIDI in state
	if( g_pMIDIInputContainer )
	{
		g_pMIDIInputContainer->ResetLatencyOffset();
	}

	if( m_pFrameWork )
	{
		HRESULT hr;
		IDMUSProdComponent* pIComponent;
		IDMUSProdComponent* pINextComponent;

		hr = m_pFrameWork->GetFirstComponent( &pINextComponent );

		while( SUCCEEDED( hr ) && pINextComponent )
		{
			pIComponent = pINextComponent;

			IDMUSProdPortNotify *pIDMUSProdPortNotify;
			if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdPortNotify, (void**)&pIDMUSProdPortNotify ) ) )
			{
				pIDMUSProdPortNotify->OnOutputPortsChanged();
				pIDMUSProdPortNotify->Release();
			}

			hr = m_pFrameWork->GetNextComponent( pIComponent, &pINextComponent );
			pIComponent->Release();
		}
	}
}

// Notify all components in the framework that the output ports were removed
void CConductor::BroadCastPortRemovalNotification( void )
{
	// Clear all thru connections
	ClearThruConnections();

	if( m_pFrameWork )
	{
		HRESULT hr;
		IDMUSProdComponent* pIComponent;
		IDMUSProdComponent* pINextComponent;

		hr = m_pFrameWork->GetFirstComponent( &pINextComponent );

		while( SUCCEEDED( hr ) && pINextComponent )
		{
			pIComponent = pINextComponent;

			IDMUSProdPortNotify *pIDMUSProdPortNotify;
			if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdPortNotify, (void**)&pIDMUSProdPortNotify ) ) )
			{
				pIDMUSProdPortNotify->OnOutputPortsRemoved();
				pIDMUSProdPortNotify->Release();
			}

			hr = m_pFrameWork->GetNextComponent( pIComponent, &pINextComponent );
			pIComponent->Release();
		}
	}
}

void CConductor::WriteDefaultDirectMusicAudiopath( void )
{
	/*
	TCHAR szComponentPath[MAX_PATH];
	TCHAR szinport[32];

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\PortConfiguration\\") );
	_tcscpy( szinport, _T("1\\") );
	_tcscat( szComponentPath, szinport );

	WritePortListToRegistry( szComponentPath, &m_lstPortOptions1 );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\PortConfiguration\\") );
	_tcscpy( szinport, _T("2\\") );
	_tcscat( szComponentPath, szinport );

	WritePortListToRegistry( szComponentPath, &m_lstPortOptions2 );
	*/

	return;
}

/*
void CConductor::ImportPortListFromRegistry( TCHAR szBasePath[], CTypedPtrList<CPtrList, CPortOptions*> *plstPortOptions )
{
	HKEY  hKeyOpen;
	LONG  lResult;

	// Open the base key
	lResult = ::RegOpenKeyEx( HKEY_CURRENT_USER, szBasePath, 0, KEY_READ, &hKeyOpen );
	if( lResult == ERROR_SUCCESS )
	{
		// Enumerate through the subkeys - each subkey is a different port GUID
		DWORD dwIndex = 0;
		TCHAR szSubKey[MAX_PATH + 1];
		lResult = ::RegEnumKey( hKeyOpen, dwIndex, szSubKey, MAX_PATH + 1 );
		while( lResult == ERROR_SUCCESS )
		{
			// Open the subkey
			HKEY hKeyPort;
			lResult = ::RegOpenKeyEx( hKeyOpen, szSubKey, 0, KEY_READ, &hKeyPort );
			if( lResult == ERROR_SUCCESS )
			{
				// Parse port GUID
				OLECHAR *pszGuid = new OLECHAR[100];
				::MultiByteToWideChar( CP_ACP, 0, szSubKey, -1, pszGuid, 100);

				GUID guidPortGUID;
				lResult = ::CLSIDFromString(pszGuid, &guidPortGUID);
				delete pszGuid;
				if( lResult == NOERROR )
				{
					// Get the DMUS_PORTCAPS structure for this port.
					DMUS_PORTCAPS dmPortCaps;
					if( GetDMusPortCaps( guidPortGUID, &dmPortCaps ) )
					{
						CPortOptions *pPortOptions;
						pPortOptions = new CPortOptions( &dmPortCaps );

						DWORD *pdwPChannelArray;
						DWORD dwSize;
						if( GetRegData( hKeyPort, _T("PChannelBlocks"), (BYTE **)&pdwPChannelArray, &dwSize ) )
						{
							pPortOptions->m_adwBlocks.SetSize( dwSize / sizeof(DWORD) );
							// Assign them to the first 'n' blocks
							for( DWORD i=0; i <dwSize / sizeof(DWORD); i++ )
							{
								pPortOptions->m_adwBlocks[i] = pdwPChannelArray[i];
							}

							delete pdwPChannelArray;
						}

						DWORD dwEffects;
						if( GetRegDWORD( hKeyPort, NULL, _T("Effects"), &dwEffects ) )
						{
							pPortOptions->m_dwEffects = dwEffects;
						}

						BYTE *pbData;
						if( GetRegData( hKeyPort, _T("WavesReverbParams"), (BYTE **)&pbData, &dwSize ) )
						{
							ASSERT( dwSize == sizeof( DMUS_WAVES_REVERB_PARAMS ) );
							if( dwSize == sizeof( DMUS_WAVES_REVERB_PARAMS ) )
							{
								memcpy( &pPortOptions->m_ReverbParams, pbData, sizeof( DMUS_WAVES_REVERB_PARAMS ) );
							}

							delete pbData;
						}

						DWORD dwDownloadGM;
						if( GetRegDWORD( hKeyPort, NULL, _T("DownloadGM"), &dwDownloadGM ) )
						{
							pPortOptions->m_fDownloadGM = (dwDownloadGM != 0);
						}

						DWORD dwSampleRate;
						if( GetRegDWORD( hKeyPort, NULL, _T("SampleRate"), &dwSampleRate ) )
						{
							pPortOptions->m_dwSampleRate = dwSampleRate;
						}

						DWORD dwVoices;
						if( GetRegDWORD( hKeyPort, NULL, _T("Voices"), &dwVoices ) )
						{
							pPortOptions->m_dwVoices = dwVoices;
						}

						plstPortOptions->AddTail( pPortOptions );
					}
				}
				::RegCloseKey( hKeyPort );
			}

			dwIndex++;
			lResult = ::RegEnumKey( hKeyOpen, dwIndex, szSubKey, MAX_PATH + 1 );
		}
		::RegCloseKey( hKeyOpen );
	}

	return;
}

void CConductor::WritePortListToRegistry( TCHAR szBasePath[], CTypedPtrList<CPtrList, CPortOptions*> *plstPortOptions )
{
	HKEY  hKeyOpen;
	LONG  lResult;

	// Open the base key
	lResult = ::RegCreateKeyEx( HKEY_CURRENT_USER, szBasePath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyOpen, NULL );
	if( lResult == ERROR_SUCCESS )
	{
		// Enumerate through the subkeys - each subkey is a different port GUID
		TCHAR szSubKey[MAX_PATH + 1];
		lResult = ::RegEnumKey( hKeyOpen, 0, szSubKey, MAX_PATH + 1 );
		while( lResult == ERROR_SUCCESS )
		{
			// Delete the subkey
			lResult = ::RegDeleteKey( hKeyOpen, szSubKey );

			lResult = ::RegEnumKey( hKeyOpen, 0, szSubKey, MAX_PATH + 1 );
		}

		// Enumerate throught the ports - create a subkey for each port GUID
		CPortOptions *pPortOptions;
		POSITION pos = plstPortOptions->GetHeadPosition();
		while( pos )
		{
			pPortOptions = plstPortOptions->GetNext( pos );

			// Convert port GUID to string
			LPOLESTR psz;
		    if( SUCCEEDED( StringFromIID(pPortOptions->m_guidPort, &psz) ) )
			{
				WideCharToMultiByte( CP_ACP, 0, psz, -1, szSubKey, sizeof(szSubKey), NULL, NULL );
				CoTaskMemFree( psz );

				// Create the subkey
				HKEY hKeyPort;
				lResult = ::RegCreateKeyEx( hKeyOpen, szSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hKeyPort, NULL );
				if( lResult == ERROR_SUCCESS )
				{
					if( pPortOptions->m_adwBlocks.GetSize() )
					{
						DWORD *padwBlocks;
						padwBlocks = new DWORD[pPortOptions->m_adwBlocks.GetSize()];

						for( DWORD i=0; i < (unsigned)pPortOptions->m_adwBlocks.GetSize(); i++ )
						{
							padwBlocks[i] = pPortOptions->m_adwBlocks[i];
						}

						::RegSetValueEx( hKeyPort, _T("PChannelBlocks"), 0, REG_BINARY, (LPBYTE)padwBlocks, sizeof(DWORD) * pPortOptions->m_adwBlocks.GetSize() );

						delete[] padwBlocks;
					}

					::RegSetValueEx( hKeyPort, _T("Effects"), 0, REG_DWORD, (LPBYTE)&pPortOptions->m_dwEffects, sizeof(DWORD) );

					::RegSetValueEx( hKeyPort, _T("WavesReverbParams"), 0, REG_BINARY, (LPBYTE)&pPortOptions->m_ReverbParams, sizeof(DMUS_WAVES_REVERB_PARAMS) );

					::RegSetValueEx( hKeyPort, _T("DownloadGM"), 0, REG_DWORD, (LPBYTE)&pPortOptions->m_fDownloadGM, sizeof(DWORD) );

					::RegSetValueEx( hKeyPort, _T("SampleRate"), 0, REG_DWORD, (LPBYTE)&pPortOptions->m_dwSampleRate, sizeof(DWORD) );

					::RegSetValueEx( hKeyPort, _T("Voices"), 0, REG_DWORD, (LPBYTE)&pPortOptions->m_dwVoices, sizeof(DWORD) );

					::RegCloseKey( hKeyPort );
				}
			}
		}
		::RegCloseKey( hKeyOpen );
	}

	return;
}

BOOL CConductor::GetDMusPortCaps( GUID guidPortGUID, DMUS_PORTCAPS *pdmPortCaps )
{
	ASSERT( pdmPortCaps );
	if( !pdmPortCaps )
	{
		return FALSE;
	}

	// Search for guidPortGUID
	HRESULT hr;
	for(DWORD dwIndex = 0; ; dwIndex++)
	{
		// Initialize dmpc
		DMUS_PORTCAPS dmpc;
		ZeroMemory(&dmpc, sizeof(dmpc));
		dmpc.dwSize = sizeof(DMUS_PORTCAPS);

		// Get the port's capabilities
		hr = m_pDMusic->EnumPort(dwIndex, &dmpc);

		// If we succeeded and didn't hit the end of the list
		if(SUCCEEDED(hr) && (hr != S_FALSE) )
		{
			// If this is the port we want
			if ( ::IsEqualGUID( dmpc.guidPort, guidPortGUID ) )
			{
				memcpy( pdmPortCaps, &dmpc, sizeof( DMUS_PORTCAPS ) );
				return TRUE;
			}
		}
		else
		{
			break;
		}
	}
	return FALSE;
}
*/

void CConductor::SendAllNotesOff( long lTime, BOOL fSendGMReset )
{
	UNREFERENCED_PARAMETER(lTime);
	UNREFERENCED_PARAMETER(fSendGMReset);

	// Iterate through 1000 PChannels
	for( int i=0; i<1000/16; i++)
	{
		for( int j=0; j<16; j++ )
		{
			/* Commented out per Todor's request on 2/11/00
			// Send Reset All Controllers (121)
			SendMIDIMessage( i * 16 + j, lTime, MIDI_CCHANGE, 121 );

			// Send All Notes Off (123)
			SendMIDIMessage( i * 16 + j, lTime, MIDI_CCHANGE, 123 );

			// Send All Sound Off (127)
			SendMIDIMessage( i * 16 + j, lTime, MIDI_CCHANGE, 127 );

			if( fSendGMReset )
			{
				SendGMReset( i * 16 + j );
			}
			*/
			/*
			// Send note off messages
			for( BYTE bNote = 0; bNote < 127; bNote ++)
			{
				SendMIDIMessage( m_pDMPerformance, i * 16 + j, lTime, MIDI_NOTEOFF, bNote );
			}
			*/
		}
	}
}

/*
  GM Reset    F0 7E 7F 09 01 F7
  GS Reset    F0 0A 41 10 42 12 40 00 7F 00 41 F7
  XG Reset    F0 08 43 10 4C 00 00 7E 00 F7
  GS Exit     F0 0A 41 10 42 12 40 00 7F 7F 42 F7
*/
HRESULT CConductor::SendGMReset( DWORD dwPChannel )
{
	ASSERT( m_pDMPerformance );

	HRESULT hr;
	DMUS_SYSEX_PMSG *pDMSysexEvent = NULL;

	// Allocate MIDI message
	hr = m_pDMPerformance->AllocPMsg( sizeof(DMUS_PMSG) + sizeof(DWORD) + 6, (DMUS_PMSG**)&pDMSysexEvent );
	if ( FAILED(hr) )
	{
		return hr;
	}
	memset( pDMSysexEvent, 0, sizeof(DMUS_PMSG) + sizeof(DWORD) + 6 );

	pDMSysexEvent->dwLen = 6;
	pDMSysexEvent->abData[0] = 0xF0;
	pDMSysexEvent->abData[1] = 0x7E;
	pDMSysexEvent->abData[2] = 0x7F;
	pDMSysexEvent->abData[3] = 0x09;
	pDMSysexEvent->abData[4] = 0x01;
	pDMSysexEvent->abData[5] = 0xF7;
	//pDMSysexEvent->bByte2 = 0;
	//pDMSysexEvent->m_rtTime = 0;
	pDMSysexEvent->dwFlags = DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_REFTIME;
	pDMSysexEvent->dwPChannel = dwPChannel;
	//pDMSysexEvent->dwVirtualTrackID = 0;
	pDMSysexEvent->dwType = DMUS_PMSGT_SYSEX;
	pDMSysexEvent->dwSize = sizeof(DMUS_PMSG) + sizeof(DWORD) + 6;

	DMUS_PMSG *pPipelineEvent = NULL;
	pPipelineEvent = (DMUS_PMSG*) pDMSysexEvent;

	return m_pDMPerformance->SendPMsg( pPipelineEvent );
}

HRESULT CConductor::SendMIDIMessage( DWORD dwPChannel, long lTime, BYTE bStatus, BYTE bByte1 )
{
	ASSERT( m_pDMPerformance );

	HRESULT hr;
	DMUS_PMSG *pPipelineEvent = NULL;
	DMUS_MIDI_PMSG *pDMMidiEvent = NULL;

	// Allocate MIDI message
	hr = m_pDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pDMMidiEvent );
	if ( FAILED(hr) )
	{
		return hr;
	}
	memset( pDMMidiEvent, 0, sizeof(DMUS_MIDI_PMSG) );

	pDMMidiEvent->bStatus = bStatus;
	pDMMidiEvent->bByte1 = bByte1;
	//pDMMidiEvent->bByte2 = 0;
	if( lTime )
	{
		REFERENCE_TIME rtNow;
		m_pDMPerformance->GetLatencyTime( &rtNow );
		pDMMidiEvent->rtTime = lTime * 10000 + rtNow;
		pDMMidiEvent->dwFlags = DMUS_PMSGF_TOOL_QUEUE;
	}
	else
	{
		//pDMMidiEvent->m_rtTime = 0;
		pDMMidiEvent->dwFlags = DMUS_PMSGF_TOOL_IMMEDIATE;
	}
	pDMMidiEvent->dwFlags |= DMUS_PMSGF_REFTIME;
	pDMMidiEvent->dwPChannel = dwPChannel;
	//pDMMidiEvent->dwVirtualTrackID = 0;
	pDMMidiEvent->dwType = DMUS_PMSGT_MIDI;
	pDMMidiEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
	pPipelineEvent = (DMUS_PMSG*) pDMMidiEvent;

	return m_pDMPerformance->SendPMsg( pPipelineEvent );
}


HRESULT STDMETHODCALLTYPE CConductor::IsDirty(void)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CConductor::Load(
	/* [unique][in] */ IStream *pIStream)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !m_lstSecondaryToolbars.IsEmpty() )
	{
		IDMUSProdRIFFStream* pIRiffStream;
		if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			return E_FAIL;
		}

		// Try and find the toolbar list chunk
		MMCKINFO ckMain;
		ckMain.fccType = FOURCC_2NDARY_TOOLBAR_LIST;
		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) != 0 )
		{
			pIRiffStream->Release();
			return E_FAIL;
		}

		// Descend into the toolbar size chunk
		MMCKINFO ckSubChunk;
		if( pIRiffStream->Descend( &ckSubChunk, &ckMain, 0 ) != 0 )
		{
			pIRiffStream->Release();
			return E_FAIL;
		}

		// Load number of toolbars
		if( ckSubChunk.ckid != FOURCC_2NDARY_TOOLBAR_SIZE )
		{
			pIRiffStream->Release();
			return E_FAIL;
		}
		ASSERT( ckSubChunk.cksize == sizeof(DWORD) );

		// Read the number of segments to create
		DWORD cbRead;
		HRESULT hr;
		DWORD dwNumSegmentToolbars = 0;
		hr = pIStream->Read( &dwNumSegmentToolbars, sizeof(DWORD), &cbRead );
		if( FAILED(hr) || (cbRead != sizeof(DWORD)) )
		{
			pIRiffStream->Release();
			return E_FAIL;
		}

		// Ascend out of the size chunk
		pIRiffStream->Ascend( &ckSubChunk, 0 );

		// TODO: resize m_lstSecondaryToolbars to match number of requested toolbars
		POSITION pos = m_lstSecondaryToolbars.GetHeadPosition();
		while( pos && SUCCEEDED(hr) )
		{
			CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos );

			// Set number of buttons to display
			pToolbarHandler->SetNumButtons( dwNumSegmentToolbars );
			pToolbarHandler->m_spinControl.SetPos( dwNumSegmentToolbars );

			hr = pToolbarHandler->Load( pIRiffStream, &ckMain );
		}

		// Ascend out of the toolbar list chunk and clean up
		pIRiffStream->Ascend( &ckMain, 0 );
		pIRiffStream->Release();
		return hr;
	}
	else
	{
		return S_FALSE;
	}
}

HRESULT STDMETHODCALLTYPE CConductor::Save(
	/* [unique][in] */ IStream *pIStream,
	/* [in] */ BOOL fClearDirty)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(fClearDirty);

	if( !m_lstSecondaryToolbars.IsEmpty() )
	{
		IDMUSProdRIFFStream* pIRiffStream;
		if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			return E_FAIL;
		}

		// Create the toolbar list chunk
		MMCKINFO ckMain;
		ckMain.fccType = FOURCC_2NDARY_TOOLBAR_LIST;
		if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATELIST ) != 0 )
		{
			pIRiffStream->Release();
			return E_FAIL;
		}

		// Create toolbar size chunk
		MMCKINFO ckSubChunk;
		ckSubChunk.ckid = FOURCC_2NDARY_TOOLBAR_SIZE;
		if( pIRiffStream->CreateChunk( &ckSubChunk, 0 ) != 0 )
		{
			pIRiffStream->Release();
			return E_FAIL;
		}

		// write number of segments
		HRESULT hr;
		DWORD cbWritten, dwNumSegmentToolbars = 0;
		// Compute number of toolbar button states
		POSITION pos = m_lstSecondaryToolbars.GetHeadPosition();
		while( pos )
		{
			dwNumSegmentToolbars += m_lstSecondaryToolbars.GetNext( pos )->m_dwNumButtons;
		}
		hr = pIStream->Write( &dwNumSegmentToolbars, sizeof(DWORD), &cbWritten );
		if( FAILED(hr) || (cbWritten != sizeof(DWORD)) )
		{
			pIRiffStream->Release();
			return E_FAIL;
		}

		// Ascend out of the size chunk
		pIRiffStream->Ascend( &ckSubChunk, 0 );

		// Write the toolbar states
		pos = m_lstSecondaryToolbars.GetHeadPosition();
		while( pos && SUCCEEDED(hr) )
		{
			hr = m_lstSecondaryToolbars.GetNext( pos )->Save( pIRiffStream );
		}

		// Ascend out of the list chunk
		pIRiffStream->Ascend( &ckMain, 0 );
		pIRiffStream->Release();

		return hr;
	}
	else
	{
		return S_FALSE;
	}
}

HRESULT STDMETHODCALLTYPE CConductor::GetSizeMax(
	/* [out] */ ULARGE_INTEGER *pcbSize)
{
	UNREFERENCED_PARAMETER(pcbSize);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetClassID( 
	/* [out] */ CLSID *pClassID)
{
	UNREFERENCED_PARAMETER(pClassID);
	return E_NOTIMPL;
}

void CConductor::UpdateMIDIThruChannels( void )
{
	::EnterCriticalSection( &m_csAudiopath );
	IDirectMusicAudioPath *pDMAudiopath = m_pDMAudiopath;
	if( pDMAudiopath )
	{
		pDMAudiopath->AddRef();
	}
	::LeaveCriticalSection( &m_csAudiopath );

	if( g_pMIDIInputContainer )
	{
		g_pMIDIInputContainer->UpdateMIDIThruChannels( pDMAudiopath );
	}

	if( pDMAudiopath )
	{
		pDMAudiopath->Release();
	}
}	

void CConductor::ClearThruConnections( void )
{
	if( g_pMIDIInputContainer )
	{
		g_pMIDIInputContainer->ClearThruConnections();
	}
}

void CConductor::StopAllNotesAndSegments( void )
{
	// Stop all Secondary Segments
	POSITION pos = m_lstSecondaryToolbars.GetHeadPosition();
	while( pos )
	{
		CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos );
		BOOL bHandled;
		for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
		{
			pToolbarHandler->OnButtonClicked( 0, WORD(ID_TRANSP_STOP1 + i), 0, bHandled );
		}
	}

	// Stop the Count-In segment state
	if( m_pToolbarHandler->m_pCountInSegmentState )
	{
		// Stop the Count-In segment state
		// Ignore the m_pToolbarHandler->m_fStopImmediate - stop immediately.
		m_pDMPerformance->Stop( NULL, m_pToolbarHandler->m_pCountInSegmentState, 0, 0 );

		// Release the Count-In segment state
		m_pToolbarHandler->m_pCountInSegmentState->Release();
		m_pToolbarHandler->m_pCountInSegmentState = NULL;
	}

	// Stop the current transport.
	if( m_pToolbarHandler->IsValid( m_rpPlaying ) )
	{
		IDMUSProdTransport*  pITransport;
		m_rpPlaying->GetTransport( &pITransport );
		if (pITransport)
		{
			// We'll assume this succeeded.  If not, the subsequent Performance calls below should cause
			// everything to stop playing.
			pITransport->Stop( TRUE );
			m_rpPlaying = NULL;

			// Update the active flags, if they're using the engine
			m_pToolbarHandler->UpdateActiveFromEngine();

			// Switch to displaying the active buttons
			m_pToolbarHandler->m_fPlayFromStart = FALSE;
		}
	}

	// Stop the performance engine and all notes on all PChannels
	if( m_pDMPerformance )
	{
		m_pDMPerformance->Stop( NULL, NULL, 0, 0 );

		SendAllNotesOff( 250, TRUE );
	}

	::Sleep( 250 );
	m_pToolbarHandler->SetStateAuto();
}
	
void CConductor::SetMIDIExportFields( IUnknown* pIUnknown )
{
	// pIUnknown should be either IDMUSProdTransport* or IDMUSProdSecondaryTransport*
	if( m_pDMPerformance )
	{
		// Set fields needed for MIDI export
		if( m_pIUnknownMIDIExport == NULL
		&&  m_pISegStateMIDIExport == NULL )
		{
			// Set m_pIUnknownMIDIExport 
			m_pIUnknownMIDIExport = pIUnknown; 
			m_pIUnknownMIDIExport->AddRef();

			// Set m_pISegStateMIDIExport
			MUSIC_TIME mtNow;
			if( SUCCEEDED( m_pDMPerformance->GetTime( NULL, &mtNow ) ) )
			{
				m_pDMPerformance->GetSegmentState( &m_pISegStateMIDIExport, mtNow );
			}
		}
	}
}
	
BOOL CConductor::AllTransportsSetToPlay( void )
{
	// Check primary transport
	if( m_pToolbarHandler )
	{
		if( m_pToolbarHandler->m_fDisplayingPlay == FALSE )
		{
			return FALSE;
		}
	}
	
	// Check secondary toolbar
	POSITION pos = m_lstSecondaryToolbars.GetHeadPosition();
	while( pos )
	{
		CSecondaryToolbarHandler *pToolbarHandler = m_lstSecondaryToolbars.GetNext( pos );

		for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
		{
			if( pToolbarHandler->m_arrayButtons[i]->fDisplayingPlay == FALSE )
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}

/*
CPortOptions *CConductor::FindPortByGUID( CTypedPtrList<CPtrList, CPortOptions*> *plstDlgPortOptions, GUID guidPort )
{
	// Validate parameters
	ASSERT( plstDlgPortOptions );

	// Search for a CDlgPortItem that matches guidPort
	POSITION pos = plstDlgPortOptions->GetHeadPosition();
	while( pos )
	{
		CPortOptions *pPortOptions = plstDlgPortOptions->GetNext( pos );
		if( ::IsEqualGUID( pPortOptions->m_guidPort, guidPort ) )
		{
			// Found a matching one - return it
			return pPortOptions;
		}
	}

	return NULL;
}
*/

HRESULT CConductor::CreateAudiopath( CAudiopathListItem *pAudiopathListItem, IDirectMusicAudioPath **ppIDirectMusicAudioPath )
{
	ASSERT( ppIDirectMusicAudioPath );
	*ppIDirectMusicAudioPath = NULL;

	// Nothing to create
	if( pAudiopathListItem == NULL )
	{
		return S_FALSE;
	}

	HRESULT hr;

	if( pAudiopathListItem->pNode )
	{
		// Try and get an AudiopathConfig object from the node
		IUnknown *punkAudiopathConfig;
		hr = pAudiopathListItem->pNode->GetObject( CLSID_DirectMusicAudioPathConfig, IID_IUnknown, (void**)&punkAudiopathConfig );
		if( FAILED( hr ) )
		{
			AfxMessageBox( IDS_ERR_APATH_GETCONFIG, MB_ICONEXCLAMATION | MB_OK );
		}
		else
		{
			hr = m_pDMPerformance->CreateAudioPath( punkAudiopathConfig, TRUE, ppIDirectMusicAudioPath );
			if( FAILED( hr ) )
			{
				if( hr == DSERR_BADSENDBUFFERGUID )
				{
					AfxMessageBox( IDS_ERR_APATH_CREATE_USER_NOSENDDEST, MB_ICONWARNING | MB_OK );
				}
				else if( hr == E_INVALIDARG )
				{
					AfxMessageBox( IDS_ERR_APATH_CREATE_USER_INVALIDARG, MB_ICONWARNING | MB_OK );
				}
				else if( hr == DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER )
				{
					AfxMessageBox( IDS_ERR_APATH_CREATE_USER_NOENVDEST, MB_ICONWARNING | MB_OK );
				}
				else if( hr == E_NOINTERFACE )
				{
					AfxMessageBox( IDS_ERR_APATH_CREATE_USER_NOSYNTH, MB_ICONWARNING | MB_OK );
				}
				else
				{
					CString strError, strNumber;
					strNumber.Format("0x%x", hr );
					AfxFormatString1( strError, IDS_ERR_APATH_CREATE_USER, strNumber );
					AfxMessageBox( strError, MB_ICONWARNING | MB_OK );
				}
			}
			punkAudiopathConfig->Release();
		}
	}
	else
	{
		// Initialize dwNumPChannelsToAskFor
		DWORD dwNumPChannelsToAskFor = DEFAULT_NUM_PCHANNELS;

		if( GUID_Synth_Default != m_clsidDefaultSynth )
		{
			// Try and find the portcaps for the default synth
			DMUS_PORTCAPS dmPortCaps;
			if( GetPortCaps( m_pDMusic, m_clsidDefaultSynth, &dmPortCaps ) )
			{
				dwNumPChannelsToAskFor = min( dwNumPChannelsToAskFor, dmPortCaps.dwMaxChannelGroups * 16 );
			}
		}

		hr = m_pDMPerformance->CreateStandardAudioPath( pAudiopathListItem->dwStandardID, dwNumPChannelsToAskFor, TRUE, ppIDirectMusicAudioPath );
		if( FAILED( hr ) )
		{
			CString strError;
#ifdef DMP_XBOX
            if( (XBDM_CANNOTCONNECT == hr)
			||	(XBDM_CANNOTACCESS == hr) )
            {
                strError.LoadString( (XBDM_CANNOTCONNECT == hr) ? IDS_ERR_CANNOT_CONNECT_XBOX : IDS_ERR_WRONG_VERSION_XBOX );
    			if( IDYES == AfxMessageBox( strError, MB_ICONWARNING | MB_YESNO ) )
                {
                    DWORD dwValue = 0;
                    SetRegDWORD(HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\XboxAddin\\"), TEXT("EnableXboxSynth"), &dwValue, TRUE);
                    dwValue = TRUE;
                    SetRegDWORD(HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\XboxAddin\\"), TEXT("EnablePCSynth"), &dwValue, TRUE);
                    return CreateAudiopath( pAudiopathListItem, ppIDirectMusicAudioPath );
                }
            }
            else
#endif
            {
                strError.FormatMessage( IDS_ERR_APATH_CREATE_STANDARD, hr );
    			AfxMessageBox( strError, MB_ICONWARNING | MB_OK );
            }
		}
	}

	return hr;
}

void CConductor::UpdateLatency( void )
{
    g_fUsePhoneyDSound = m_fUsePhoneyDSound;
	if( m_fUsePhoneyDSound )
	{
		// Set the Phoney DSound latency
		g_dwLatency = m_dwLatency;

		// Clear the pointer to the last sampled output port
		g_rpLastSampledPort = NULL;
	}

	if( m_pSynthStatusToolbar )
	{
		BOOL bHandled = FALSE;
		m_pSynthStatusToolbar->OnResetClicked(0,0,0,bHandled);
	}

	if( m_dwDefaultLatency == LATENCY_UNSUPPORTED )
	{
		// Latency is unsupported - just return
		return;
	}

	::EnterCriticalSection( &m_csAudiopath );
	IDirectMusicAudioPath *pDMAudiopath = m_pDMAudiopath;
	if( pDMAudiopath )
	{
		pDMAudiopath->AddRef();
	}
	::LeaveCriticalSection( &m_csAudiopath );

	if( pDMAudiopath == NULL )
	{
		// No audiopath - just return
		return;
	}

	// Iterate through the default Audiopath's ports
	IDirectMusicPort *pDMPort = NULL;
	DWORD dwIndex = 0;
	while( S_OK == pDMAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void **)&pDMPort ) )
	{
		// Verify we have a valid port pointer
		ASSERT( pDMPort );

		IKsControl *pIKsControl;
		HRESULT hr = pDMPort->QueryInterface(IID_IKsControl, (void**)&pIKsControl);
		if (SUCCEEDED(hr)) 
		{
			KSPROPERTY ksp;
			ULONG cb;
			DWORD dwLatency = m_dwLatency;

			// Set the latency
			ZeroMemory(&ksp, sizeof(ksp));
			ksp.Set   = GUID_DMUS_PROP_WriteLatency;
			ksp.Id    = 0;
			ksp.Flags = KSPROPERTY_TYPE_SET;

			pIKsControl->KsProperty(&ksp,
								 sizeof(ksp),
								 (LPVOID)&dwLatency,
								 sizeof(dwLatency),
								 &cb);

			// Set the write period
			dwLatency = m_dwLatency / 2;
			dwLatency = max( 2, dwLatency );
			ZeroMemory(&ksp, sizeof(ksp));
			ksp.Set   = GUID_DMUS_PROP_WritePeriod;
			ksp.Id    = 0;
			ksp.Flags = KSPROPERTY_TYPE_SET;

			pIKsControl->KsProperty(&ksp,
								 sizeof(ksp),
								 (LPVOID)&dwLatency,
								 sizeof(dwLatency),
								 &cb);

			pIKsControl->Release();
		}

		// Release the port
		pDMPort->Release();

		// Go on to the next port in the audio path
		dwIndex++;
	}

	pDMAudiopath->Release();

	// Clear the pointer to the last sampled output port
	g_rpLastSampledPort = NULL;
}

void CConductor::UpdateAudioSettings( void )
{
	// Display an hourglass cursor
	CWaitCursor waitCursor;

	// Save an old pointer to the audio path
	EnterCriticalSection( &m_csAudiopath );
	IDirectMusicAudioPath *pOldAudiopath = m_pDMAudiopath;
	if( pOldAudiopath )
	{
		pOldAudiopath->AddRef();
	}

	// Ensure that there is no default audiopath
	// This also releases our pointer to the old audio path
	ActivateAudiopath( NULL, false );

	// Unload the GM set
	DownOrUnLoadGM();

	// Clean up the performance
	RELEASE( m_pDMAudiopath );
	LeaveCriticalSection( &m_csAudiopath );

	// Broadcast the WaveUnload notification
	if( pOldAudiopath )
	{
		BroadCastWaveNotification( GUID_ConductorUnloadWaves );
	}

	// Clear the pointer to the last sampled output port
	g_rpLastSampledPort = NULL;

	// If we were previously using an audiopath from a node, set the old audio path
	// to be inactive
	if( m_pAudiopathListItem
	&&	m_pAudiopathListItem->pNode )
	{
		// Try and get the IDMUSProdAudioPathInUse interface for the node
		IDMUSProdAudioPathInUse *pIDMUSProdAudiopathInUse;
		if( SUCCEEDED( m_pAudiopathListItem->pNode->QueryInterface( IID_IDMUSProdAudioPathInUse, (void **)&pIDMUSProdAudiopathInUse ) ) )
		{
			// Notify the Audiopath that the old audio path is no longer in use
			pIDMUSProdAudiopathInUse->UsingAudioPath( pOldAudiopath, FALSE );
			pIDMUSProdAudiopathInUse->Release();
		}

		m_pFrameWork->RemoveFromNotifyList( m_pAudiopathListItem->pNode, this );
	}

	RELEASE( pOldAudiopath );

	BroadCastPortRemovalNotification();

	m_pDMPerformance->Stop( NULL, NULL, 0, 0 );

	Sleep( 500 );

	/* Are these calls necessary ?
	m_pDMPerformance->SetDefaultAudiopath( NULL );

	m_pDMPerformance->RemoveNotificationType( GUID_NOTIFICATION_SEGMENT );
	m_pDMPerformance->RemoveNotificationType( GUID_NOTIFICATION_MEASUREANDBEAT );
	m_pDMPerformance->RemoveNotificationType( GUID_NOTIFICATION_PERFORMANCE );

	m_pDMPerformance->SetNotificationHandle( NULL, 0 );
	*/

	m_pDMPerformance->CloseDown();

	// Re-Initialize the performance
	IDirectMusic *pDMusic;
	if( FAILED( m_pDMusic->QueryInterface( IID_IDirectMusic, (void **)&pDMusic ) ) )
	{
		ASSERT(FALSE);
		return;
	}

	// Initialize the performance
	DMUS_AUDIOPARAMS dmAudioParams;
	ZeroMemory( &dmAudioParams, sizeof( DMUS_AUDIOPARAMS ) );
	dmAudioParams.dwSize = sizeof( DMUS_AUDIOPARAMS );
	GetAudioParams( &dmAudioParams );

	// Initialize default latency
	m_dwDefaultLatency = LATENCY_UNSUPPORTED;

	HRESULT hr;
    g_fUsePhoneyDSound = m_fUsePhoneyDSound;
	if( m_fUsePhoneyDSound )
	{
		if( !m_pPhoneyDSound )
		{
			m_pPhoneyDSound = new CPhoneyDSound;
		}

		if( m_pPhoneyDSound )
		{
			// Need to intercept CoCreateInstance so that we can use our own BufferConfig object
			if( DynamicTrampoline == NULL )
			{
				HRESULT (STDAPICALLTYPE *DynamicTarget)(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
								IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv) = &CoCreateInstance;
				DynamicTrampoline = (FUNCPTR_CoCreate)DetourFunction( (PBYTE)DynamicTarget, (PBYTE)DynamicDetour );
			}

			IDirectSound *pDSound;
			m_pPhoneyDSound->QueryInterface(IID_IDirectSound,(void **)&pDSound);
			hr = m_pDMPerformance->InitAudio( &pDMusic, &pDSound, m_hWndFramework, 0, 0, DMUS_AUDIOF_ALL, &dmAudioParams);
			pDSound->Release();
		}
		else
		{
			g_fUsePhoneyDSound = m_fUsePhoneyDSound = FALSE;
#ifndef DMP_XBOX 
			// First, remove the trampoline function for PC version.
			if( DynamicTrampoline )
			{
				DetourRemove((PBYTE)DynamicTrampoline, (PBYTE)DynamicDetour);
				DynamicTrampoline = NULL;
			}
#endif

			hr = m_pDMPerformance->InitAudio( &pDMusic, NULL, m_hWndFramework, 0, 0, DMUS_AUDIOF_ALL, &dmAudioParams );
		}
	}
	else
	{
#ifndef DMP_XBOX 
		// First, remove the trampoline function for PC version
		if( DynamicTrampoline )
		{
			DetourRemove((PBYTE)DynamicTrampoline, (PBYTE)DynamicDetour);
			DynamicTrampoline = NULL;
		}
#endif

		hr = m_pDMPerformance->InitAudio( &pDMusic, NULL, m_hWndFramework, 0, 0, DMUS_AUDIOF_ALL, &dmAudioParams );
	}
	
	// Release the base IDirectMusic interface
	RELEASE( pDMusic );

	// Check to see if the performance initialized correctly.
	if( FAILED(hr) )
	{
		AfxMessageBox( IDS_ERR_INIT_PERF, MB_ICONEXCLAMATION | MB_OK );
		//strError.LoadString( IDS_ERR_INIT_PERF );
		//return hr;
	}

	// Ensure AutoDownload is NOT set
	BOOL fAutoDownload;
	fAutoDownload = FALSE;
	m_pDMPerformance->SetGlobalParam( GUID_PerfAutoDownload, &fAutoDownload, sizeof(BOOL) );

	// If the ratio button is checked, update GUID_PerfMasterTempo
	if ( (m_pToolbarHandler->m_buttonRatio.GetState() & 1) )
	{
		float fModifier = float(m_nRatio) / 100.0f;
		m_pDMPerformance->SetGlobalParam( GUID_PerfMasterTempo, &fModifier, sizeof(float) );
	}

	IDirectMusicGraph *pGraph = NULL;
	if( FAILED( m_pDMPerformance->GetGraph( &pGraph ) ) )
	{
		if( SUCCEEDED( ::CoCreateInstance( CLSID_DirectMusicGraph, NULL, CLSCTX_INPROC_SERVER, IID_IDirectMusicGraph, (void **)&pGraph ) ) )
		{
			if( FAILED( m_pDMPerformance->SetGraph( pGraph ) ) )
			{
				pGraph->Release();
				pGraph = NULL;
			}
		}
	}

	if( pGraph )
	{
		pGraph->InsertTool( m_pNotifyTool, NULL, 0, 0 );
		pGraph->Release();
	}

	m_pDMPerformance->SetNotificationHandle( m_hNotifyEvent, 0 );
	m_pDMPerformance->AddNotificationType( GUID_NOTIFICATION_SEGMENT );
	m_pDMPerformance->AddNotificationType( GUID_NOTIFICATION_MEASUREANDBEAT );
	m_pDMPerformance->AddNotificationType( GUID_NOTIFICATION_PERFORMANCE );

	if( m_pAudiopathListItem )
	{
		IDirectMusicAudioPath *pAudiopath = NULL;
		hr = CreateAudiopath( m_pAudiopathListItem, &pAudiopath );
		hr = ActivateAudiopath( pAudiopath );

		// If there is a new audio path, notify the Audiopath node that it now in use
		if( pAudiopath
		&&	SUCCEEDED( hr )
		&&	m_pAudiopathListItem
		&&	m_pAudiopathListItem->pNode )
		{
			// Try and get the IDMUSProdAudioPathInUse interface for the node
			IDMUSProdAudioPathInUse *pIDMUSProdAudiopathInUse;
			if( SUCCEEDED( m_pAudiopathListItem->pNode->QueryInterface( IID_IDMUSProdAudioPathInUse, (void **)&pIDMUSProdAudiopathInUse ) ) )
			{
				pIDMUSProdAudiopathInUse->UsingAudioPath( pAudiopath, TRUE );
				pIDMUSProdAudiopathInUse->Release();
			}

			m_pFrameWork->AddToNotifyList( m_pAudiopathListItem->pNode, this );
		}

		if( !pAudiopath
		||	FAILED( hr ) )
		{
			// Initialize the ListItem pointer to NULL
			m_pAudiopathListItem = NULL;

			// Ensure that no audiopath is set as the default
			// This will also release our pointer to the existing audio path
			ActivateAudiopath( NULL, true );

			// Remove all items from the combo box, then add and select the Audiopath used by the conductor
			m_pOptionsToolbarHandler->UpdateComboBoxFromConductor();
		}
		else
		{
			// Broadcast the WaveDownload notification
			BroadCastWaveNotification( GUID_ConductorDownloadWaves );
		}

		RELEASE( pAudiopath );
	}

	// Notify all other components that output has been changed
	BroadCastPortChangeNotification();
}

HRESULT STDMETHODCALLTYPE CConductor::GetDefaultAudiopathNode( IDMUSProdNode **ppAudiopathNode )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( ppAudiopathNode == NULL )
	{
		return E_POINTER;
	}

	if( m_pAudiopathListItem == NULL )
	{
		return E_FAIL;
	}

	if( m_pAudiopathListItem->pNode == NULL )
	{
		CDMOInfoProxy *pDMOInfoProxy = new CDMOInfoProxy( m_pAudiopathListItem->dwStandardID );
		if( pDMOInfoProxy )
		{
			// QI for the IDMUSProdNode interface
			HRESULT hr = pDMOInfoProxy->QueryInterface( IID_IDMUSProdNode, (void**)ppAudiopathNode );

			// Release our reference, leaving the one added by the QI
			pDMOInfoProxy->Release();

			// Return the result of the QI
			return hr;
		}
		return E_OUTOFMEMORY;
	}

	return m_pAudiopathListItem->pNode->QueryInterface( IID_IDMUSProdNode, (void **)ppAudiopathNode );
}

HRESULT STDMETHODCALLTYPE CConductor::PleaseRedownload( void )
{
	// Broadcast the WaveUnload notification
	BroadCastWaveNotification( GUID_ConductorUnloadWaves );

	// Broadcast the WaveDownload notification
	BroadCastWaveNotification( GUID_ConductorDownloadWaves );

	if( m_fDownloadGM )
	{
		m_fDownloadGM = FALSE;
		DownOrUnLoadGM();
		m_fDownloadGM = TRUE;
		DownOrUnLoadGM();
	}

	if( m_fDownloadDLS )
	{
		m_fDownloadDLS = FALSE;
		DownOrUnLoadDLS();
		m_fDownloadDLS = TRUE;
		DownOrUnLoadDLS();
	}

	return S_OK;
}

void CConductor::DownOrUnLoadGM( void )
{
	// Unload any instruments previously downloaded
	while( !m_lstDownloadedInstrumentList.IsEmpty() )
	{
		delete m_lstDownloadedInstrumentList.RemoveHead();
	}

	IDirectMusicAudioPath *pDMAudioPath;
	EnterCriticalSection( &m_csAudiopath );
	pDMAudioPath = m_pDMAudiopath;
	if( pDMAudioPath )
	{
		pDMAudioPath->AddRef();
	}
	LeaveCriticalSection( &m_csAudiopath );


	// Now, download GM (if necessary)
	if( m_fDownloadGM && pDMAudioPath )
	{
		// Find out the list of ports to download to
		IDirectMusicPort *pDMPort = NULL;

		// Iterate through the default Audiopath's port
		DMUS_PORTCAPS dmPortCaps;
		DWORD dwIndex = 0;
		while( S_OK == pDMAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void **)&pDMPort ) )
		{
			// Verify we have a valid port pointer
			ASSERT( pDMPort );

			// Initialize the DMUS_PORTCAPS structure
			dmPortCaps.dwSize = sizeof(DMUS_PORTCAPS);

			// Try and get the capabilities of this port, and check if it supports DLS
			// and doesn't already have GS in hardware
			if( SUCCEEDED( pDMPort->GetCaps( &dmPortCaps ) )
			&&	(dmPortCaps.dwFlags & DMUS_PC_DLS)
			&&	!(dmPortCaps.dwFlags & DMUS_PC_GSINHARDWARE) )
			{
				CDownloadedInstrumentList *pDownloadedInstrumentList = new CDownloadedInstrumentList;
				if( pDownloadedInstrumentList )
				{
					pDownloadedInstrumentList->m_pDMPort = pDMPort;
					pDownloadedInstrumentList->m_pDMPort->AddRef();
					m_lstDownloadedInstrumentList.AddTail( pDownloadedInstrumentList );
				}
			}

			// Release the port
			pDMPort->Release();

			// Go on to the next port in the audio path
			dwIndex++;
		}

		// Now, download the GM set (if the port list is not empty)
		if( !m_lstDownloadedInstrumentList.IsEmpty() )
		{
			// Get the DirectMusic loader
			IDirectMusicLoader *pILoader = NULL;
			HRESULT hr = m_pFrameWork->GetSharedObject( CLSID_DirectMusicLoader, IID_IDirectMusicLoader, 
														(LPVOID*)&pILoader);
			if ( FAILED(hr) )
			{
				hr = CoCreateInstance(CLSID_DirectMusicLoader,
										  NULL,
										  CLSCTX_INPROC_SERVER,
										  IID_IDirectMusicLoader,
										  (LPVOID*)&pILoader);
			}

			/*
			if ( FAILED(hr) )
			{
				//strError.LoadString( IDS_ERR_CREATE_COLLEC );
			}
			else*/if( SUCCEEDED( hr ) )
			{
				// Download the GM collection
				IDirectMusicCollection *pDMCollection;
				DMUS_OBJECTDESC desc;
				
				desc.dwSize = sizeof(desc);
				desc.guidClass = CLSID_DirectMusicCollection;
				desc.guidObject = GUID_DefaultGMCollection;
				desc.dwValidData = (DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT);
				hr = pILoader->GetObject(&desc, IID_IDirectMusicCollection, (void**) &pDMCollection);

				RELEASE( pILoader );

				if( FAILED( hr ) )
				{
					AfxMessageBox( IDS_ERR_LOAD_GMDLS, MB_ICONEXCLAMATION | MB_OK );
					//return S_OK;
				}
				else //if( SUCCEEDED( hr ) )
				{
					IDirectMusicInstrument* pInstrument;
					IDirectMusicDownloadedInstrument *pDownloadedInstrument;

					// Initialize progress bar
					HANDLE hKeyProgressBar;
					CString strPrompt;
					strPrompt.LoadString( IDS_DOWNLOADING_GM );
					BSTR bstrPrompt = strPrompt.AllocSysString();
					m_pFrameWork->StartProgressBar( 0, 235, bstrPrompt, &hKeyProgressBar );

					int nInst = 0;
					DWORD dwPatch;
					hr = pDMCollection->EnumInstrument( nInst, &dwPatch, NULL, NULL );
					while ( hr == S_OK )
					{
						// Update Progress bar
						m_pFrameWork->SetProgressBarPos( hKeyProgressBar, nInst );

						// Get instrument
						if( SUCCEEDED( pDMCollection->GetInstrument(dwPatch, &pInstrument) ) )
						{
							POSITION pos = m_lstDownloadedInstrumentList.GetHeadPosition();
							while( pos )
							{
								CDownloadedInstrumentList *pDownloadedInstrumentList = m_lstDownloadedInstrumentList.GetNext( pos );
								// Download instrument
								if( pDownloadedInstrumentList->m_pDMPort &&
									SUCCEEDED(pDownloadedInstrumentList->m_pDMPort->DownloadInstrument( pInstrument, &pDownloadedInstrument, NULL, 0 )))
								{
									pDownloadedInstrumentList->m_lstDownloadedInstruments.AddHead( pDownloadedInstrument );
								}
							}

							// If this is a drum kit
							if( dwPatch & 0x80000000 )
							{
								IDirectMusicInstrument* pInstrumentTmp;
								// And a corresponding XG drum kit isn't in the collection
								if( FAILED( pDMCollection->GetInstrument((dwPatch | 0x007F0000) & 0x7FFFFFFF, &pInstrumentTmp) ) )
								{
									// Change the patch to be an XG drum kit
									pInstrument->SetPatch( ((dwPatch | 0x007F0000) & 0x7FFFFFFF) );

									pos = m_lstDownloadedInstrumentList.GetHeadPosition();
									while( pos )
									{
										CDownloadedInstrumentList *pDownloadedInstrumentList = m_lstDownloadedInstrumentList.GetNext( pos );
										// Download instrument
										if( pDownloadedInstrumentList->m_pDMPort &&
											SUCCEEDED(pDownloadedInstrumentList->m_pDMPort->DownloadInstrument( pInstrument, &pDownloadedInstrument, NULL, 0 )))
										{
											pDownloadedInstrumentList->m_lstDownloadedInstruments.AddHead( pDownloadedInstrument );
										}
									}
								}
								else
								{
									// A corresponding XG drum kit already exists - don't download
									pInstrumentTmp->Release();
								}
							}
							RELEASE( pInstrument );
						}
						nInst++;

						hr = pDMCollection->EnumInstrument( nInst, &dwPatch, NULL, NULL );
					}

					// End progress bar
					m_pFrameWork->EndProgressBar( hKeyProgressBar );

					hr = S_OK;

					RELEASE( pDMCollection );
				}
			}
		}
	}

	if( pDMAudioPath )
	{
		pDMAudioPath->Release();
	}

	if( m_pFrameWork )
	{
		HRESULT hr;
		IDMUSProdComponent* pIComponent;
		IDMUSProdComponent* pINextComponent;

		hr = m_pFrameWork->GetFirstComponent( &pINextComponent );

		while( SUCCEEDED( hr ) && pINextComponent )
		{
			pIComponent = pINextComponent;

			IDMUSProdDLSNotify *pIDMUSProdDLSNotify;
			if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdDLSNotify, (void**)&pIDMUSProdDLSNotify ) ) )
			{
				pIDMUSProdDLSNotify->OnDownloadGM( m_fDownloadGM );
				pIDMUSProdDLSNotify->Release();
			}

			hr = m_pFrameWork->GetNextComponent( pIComponent, &pINextComponent );
			pIComponent->Release();
		}
	}
}

void CConductor::DownOrUnLoadDLS( void )
{
	if( m_pFrameWork )
	{
		HRESULT hr;
		IDMUSProdComponent* pIComponent;
		IDMUSProdComponent* pINextComponent;

		hr = m_pFrameWork->GetFirstComponent( &pINextComponent );

		while( SUCCEEDED( hr ) && pINextComponent )
		{
			pIComponent = pINextComponent;

			IDMUSProdDLSNotify *pIDMUSProdDLSNotify;
			if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdDLSNotify, (void**)&pIDMUSProdDLSNotify ) ) )
			{
				pIDMUSProdDLSNotify->OnDownloadCustomDLS( m_fDownloadDLS );
				pIDMUSProdDLSNotify->Release();
			}

			hr = m_pFrameWork->GetNextComponent( pIComponent, &pINextComponent );
			pIComponent->Release();
		}
	}
}

// IDMUSProdNode
HRESULT STDMETHODCALLTYPE CConductor::GetNodeImageIndex( short* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetFirstChild( IDMUSProdNode** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetNextChild( IDMUSProdNode*, IDMUSProdNode** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetComponent( IDMUSProdComponent** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetDocRootNode( IDMUSProdNode** )
{
	//ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::SetDocRootNode( IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetParentNode( IDMUSProdNode** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::SetParentNode( IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetNodeId( GUID* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetNodeName( BSTR* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetNodeNameMaxLength( short* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::ValidateNodeName( BSTR )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::SetNodeName( BSTR )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetNodeListInfo( DMUSProdListInfo* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetEditorClsId( CLSID* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetEditorTitle( BSTR* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetEditorWindow( HWND* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::SetEditorWindow( HWND )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::UseOpenCloseImages( BOOL* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CConductor::GetRightClickMenuId( HINSTANCE*, UINT* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::OnRightClickMenuInit( HMENU )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::OnRightClickMenuSelect( long )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::DeleteChildNode( IDMUSProdNode*, BOOL )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::InsertChildNode( IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::DeleteNode( BOOL )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::OnNodeSelChanged( BOOL )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::CreateDataObject( IDataObject** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::CanCut()
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::CanCopy()
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::CanDelete()
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::CanDeleteChildNode( IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::CanPasteFromData( IDataObject*, BOOL* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::PasteFromData( IDataObject* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::CanChildPasteFromData( IDataObject*, IDMUSProdNode*, BOOL* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::ChildPasteFromData( IDataObject*, IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CConductor::GetObject( REFCLSID, REFIID, void** ) 
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
void CConductor::BroadCastWaveNotification( REFGUID rguidNotification )
{
	if( m_pFrameWork )
	{
		HRESULT hr;
		IDMUSProdComponent* pIComponent;
		IDMUSProdComponent* pINextComponent;

		hr = m_pFrameWork->GetFirstComponent( &pINextComponent );

		while( SUCCEEDED( hr ) && pINextComponent )
		{
			pIComponent = pINextComponent;

			IDMUSProdNotifySink *pIDMUSProdNotifySink;
			if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pIDMUSProdNotifySink ) ) )
			{
				pIDMUSProdNotifySink->OnUpdate( NULL, rguidNotification, NULL );
				pIDMUSProdNotifySink->Release();
			}

			hr = m_pFrameWork->GetNextComponent( pIComponent, &pINextComponent );
			pIComponent->Release();
		}
	}
}

void CConductor::UsePhoneyDSound( bool fUsePhoneyDSound )
{
	if( m_fUsePhoneyDSound != fUsePhoneyDSound )
	{
		// Stop exporting wave and/or MIDI files
		if( m_pWaveRecordToolbar )
		{
			m_pWaveRecordToolbar->StopAll();
		}

		m_fUsePhoneyDSound = fUsePhoneyDSound;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\cconduct.h ===
#if !defined(CCONDUCTOR_H__36F6DDF3_46CE_11D0_B9DB_00AA00C08146__INCLUDED_)
#define CCONDUCTOR_H__36F6DDF3_46CE_11D0_B9DB_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// CConductor.h : Declaration of the CConductor

#include "resource.h"
#include "DMUSProd.h"
#include "Conductor.h"
#include <dmusicc.h>
#include <dmusici.h>
#include <PrivateTransport.h>

class CConductor;
class COutputTool;
class CNotifyTool;
class MIDISaveTool;
class CStatusToolbarHandler;
class CSynthStatusToolbar;
class CPhoneyDSound;
interface ITransportRegEntry;
interface ISecondaryTransportRegEntry;

extern const IID IID_ITransportRegEntry;
extern const IID IID_ISecondaryTransportRegEntry;
extern CComModule _Module;
extern CConductor* g_pconductor;

BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPCTSTR lpszString );
BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite );
BOOL GetRegString( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPTSTR lpszString, LPDWORD lpdwSize );
BOOL GetRegDWORD( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, DWORD *pdwData );
BOOL GetRegData( HKEY hKey, LPCTSTR lpValueName, BYTE **ppbData, DWORD *pdwSize );

#define LATENCY_UNSUPPORTED 0x7fffffff

// Flag that we're transitioning to nothing
#define TRANS_TO_NOTHING 0x80000000
#define TRANS_PRIVATE_FLAGS (TRANS_TO_NOTHING)

#define RELEASE(x) { if (x) { x->Release(); x = NULL; } } 

// CAudiopathListItem
struct CAudiopathListItem
{
	CAudiopathListItem( IDMUSProdNode *pNewAudiopathNode, DWORD dwNewStandardID, DWORD dwXboxPathID )
	{
		pNode = pNewAudiopathNode;
		if( pNode )
		{
			pNode->AddRef();
		}

		dwStandardID = dwNewStandardID;
        dwXboxID = dwXboxPathID;
	}
	~CAudiopathListItem()
	{
		RELEASE( pNode );
	}

	IDMUSProdNode *pNode;
	DWORD dwStandardID;     // PC Audiopath ID.
    DWORD dwXboxID;         // Optional ID if this is playing on an Xbox.
	CString strName;
};

// SegStateAudioPath
struct SegStateAudioPath
{
	SegStateAudioPath( IDirectMusicAudioPath *pNewAudiopath, IDirectMusicSegmentState8 *pNewSegmentState )
	{
		pAudiopath = pNewAudiopath;
		if( pAudiopath )
		{
			pAudiopath->AddRef();
		}
		pSegmentState = pNewSegmentState;
		if( pSegmentState )
		{
			pSegmentState->AddRef();
		}
	}
	~SegStateAudioPath()
	{
		RELEASE( pAudiopath );
		RELEASE( pSegmentState );
	}
	IDirectMusicAudioPath *pAudiopath;
	IDirectMusicSegmentState8 *pSegmentState;
};


/////////////////////////////////////////////////////////////////////////////
// GetNewRegDWORD - Gets a DWORD from the new PortConfig registry key

inline BOOL GetNewRegDWORD( LPCTSTR lpValueName, DWORD *pdwData )
{
	return GetRegDWORD( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\PortConfiguration\\"),
		lpValueName, pdwData );
}

/////////////////////////////////////////////////////////////////////////////
// GetNewRegString - Gets a string from the new PortConfig registry key

inline BOOL GetNewRegString( LPCTSTR lpValueName, LPTSTR lpszString, LPDWORD lpdwSize )
{
	return GetRegString( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\PortConfiguration\\"),
		lpValueName, lpszString, lpdwSize );
}

/////////////////////////////////////////////////////////////////////////////
// SetNewRegDWORD - Sets a DWORD in the new PortConfig registry key

inline BOOL SetNewRegDWORD( LPCTSTR lpValueName, DWORD dwData, BOOL fOverWrite )
{
	return SetRegDWORD( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\PortConfiguration\\"),
		lpValueName, &dwData, fOverWrite );
}

/////////////////////////////////////////////////////////////////////////////
// SetNewRegString - Sets a string in the new PortConfig registry key

inline BOOL SetNewRegString( LPCTSTR lpValueName, LPTSTR lpszString )
{
	return SetRegString( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\PortConfiguration\\"),
		lpValueName, lpszString );
}

typedef enum ODevice
{
    OD_ONE,
    OD_TWO
} ODevice;

class CDownloadedInstrumentList
{
public:
	CDownloadedInstrumentList();
	~CDownloadedInstrumentList();

 	IDirectMusicPort	*m_pDMPort; // Pointer to the IDirectMusicPort object.
	CTypedPtrList<CPtrList, IDirectMusicDownloadedInstrument*> m_lstDownloadedInstruments;
};

class CNotifyEntry
{
public:
	CNotifyEntry( IDMUSProdNotifyCPt* pINotifyCPt, REFGUID guid )
	{
		memcpy( &m_guid, &guid, sizeof(GUID) );
		m_lstNotifyCPt.RemoveAll();
		m_lstNotifyCPt.AddHead( pINotifyCPt );
	}

	~CNotifyEntry()
	{
		/*
		IDMUSProdNotifyCPt* pNotifyCPt = NULL;
		do
		{
			pNotifyCPt = m_lstNotifyCPt.RemoveHead();
			if ( pNotifyCPt != NULL )
			{
				pNotifyCPt->Release();
			}
		} while ( pNotifyCPt != NULL );
		*/
		m_lstNotifyCPt.RemoveAll();
	}

	GUID		m_guid;
    CTypedPtrList<CPtrList, IDMUSProdNotifyCPt*> m_lstNotifyCPt;
};

#define B_NOT_USING_ENGINE		0x001
#define B_PLAY_ENABLED			0x002
#define B_PLAY_CHECKED			0x004
#define B_STOP_ENABLED			0x008
#define B_STOP_CHECKED			0x010
#define B_REC_ENABLED			0x020
#define B_REC_CHECKED			0x040
#define B_TRANS_ENABLED			0x080
#define B_TRANS_CHECKED			0x100
#define B_TEMPO_ENABLED			0x200
#define B_TEMPO_RATIO_ENABLED	0x400
#define B_TEMPO_RATIO_CHECKED	0x800

#define B_USER_FLAGS (B_NOT_USING_ENGINE | B_PLAY_ENABLED | B_PLAY_CHECKED | \
				B_STOP_ENABLED | B_STOP_CHECKED | B_REC_ENABLED | B_REC_CHECKED)

#define FOURCC_2NDARY_TOOLBAR_LIST		mmioFOURCC('2','t','b','l')
#define FOURCC_2NDARY_TOOLBAR_CHUNK		mmioFOURCC('2','n','t','c')
#define FOURCC_2NDARY_TOOLBAR_SIZE		mmioFOURCC('2','n','t','s')
#define FOURCC_2NDARY_TOOLBAR_FLAGS		mmioFOURCC('2','n','t','f')

/////////////////////////////////////////////////////////////////////////////
// Conductor

class CConductor :
	public IDMUSProdConductor8,
	public IDMUSProdComponent,
	public IPrivateTransport,
	public IDMUSProdConductorPrivate,
	public CComObjectRoot,
	public CComCoClass<CConductor,&CLSID_CConductor>,
	public IConnectionPointContainerImpl<CConductor>,
	public IConnectionPointImpl<CConductor,&IID_IDMUSProdMidiInCPt>,
	public IPersistStream,
	public IDMUSProdNode,
	public IDMUSProdNotifySink
	{
	friend class CSecondaryToolbarHandler;
	friend class CToolbarHandler;
	friend class COptionsToolbarHandler;
	friend class DlgMIDI;
	friend class DlgMetronome;
	friend class DlgAltTempo;
	friend class DlgTransition;
	friend class CStatusToolbarHandler;
	friend class CWaveRecordToolbar;
	friend class COutputTool;
	friend class CRatioButton;
	friend class CMyButton;
	friend class CMIDIInputContainer;
	friend class CSynthButton;
	friend UINT AFX_CDECL MIDIInThreadProc( LPVOID pParam );
	friend UINT AFX_CDECL NotifyThreadProc( LPVOID pParam );
	friend void CALLBACK EXPORT TimerProc( HWND hWnd, UINT nMsg, UINT nIDEvent, DWORD dwTime );
	friend void CALLBACK EXPORT SynthStatusTimerProc( HWND hWnd, UINT nMsg, UINT nIDEvent, DWORD dwTime );
	friend void AddToolsAndSetupWaveSaveForSegState( IUnknown *punk );
	friend bool GetPChannelName( DWORD dwPChannel, CString &strName );


public:
	CConductor();
	~CConductor();
	HRESULT InitializeDirectMusic( CString &strError );
	void AddToolsToToolgraph(IDirectMusicGraph *pGraph, COutputTool* pCOutputTool, MIDISaveTool* pMIDISaveTool );
	void AddToolsToSegState(IDirectMusicSegmentState8 *pIDirectMusicSegmentState, COutputTool* pCOutputTool, MIDISaveTool* pMIDISaveTool );
	void AddTools(IDirectMusicAudioPath *pAudiopath, COutputTool* pCOutputTool, MIDISaveTool* pMIDISaveTool );
	//void AddTools(IDirectMusicPerformance* pPerf, COutputTool* pCOutputTool, MIDISaveTool* pMIDISaveTool );
	void SetupWaveSaveDMO( IDirectMusicAudioPath *pAudiopath );
	HRESULT DownloadGMCollection();
	void SendAllNotesOff( long lTime, BOOL fSendGMReset );
	HRESULT SendGMReset( DWORD dwPChannel );
	HRESULT SendMIDIMessage( DWORD dwPChannel, long lTime, BYTE bStatus, BYTE bByte1 );
	void StopAllNotesAndSegments( void );
	HRESULT CreateAudiopath( CAudiopathListItem *pAudiopathListItem, IDirectMusicAudioPath **ppIDirectMusicAudioPath );

	BEGIN_COM_MAP(CConductor)
		COM_INTERFACE_ENTRY(IDMUSProdConductor)
		COM_INTERFACE_ENTRY(IDMUSProdConductor8)
		COM_INTERFACE_ENTRY(IDMUSProdComponent)
		COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
		COM_INTERFACE_ENTRY(IPrivateTransport)
		COM_INTERFACE_ENTRY(IDMUSProdConductorPrivate)
		COM_INTERFACE_ENTRY(IPersistStream)
		COM_INTERFACE_ENTRY(IDMUSProdNode)
		COM_INTERFACE_ENTRY(IDMUSProdNotifySink)
	END_COM_MAP()

	DECLARE_NOT_AGGREGATABLE(CConductor)
	// Remove the comment from the line above if you don't want your object to
	// support aggregation or if you want to provide support for
	// Microsoft Transaction Server. The default is to support it

	DECLARE_REGISTRY_RESOURCEID(IDR_Conductor)

	// IDMUSProdConductor
	HRESULT STDMETHODCALLTYPE GetPerformanceEngine(
			/* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppPerformance );
	HRESULT STDMETHODCALLTYPE GetPort(
			/* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppPort );
	HRESULT STDMETHODCALLTYPE RegisterTransport(
			/* [in] */ IDMUSProdTransport *pTransport,
			/* [in] */ DWORD dwFlags );
	HRESULT STDMETHODCALLTYPE UnRegisterTransport(
			/* [in] */ IDMUSProdTransport *pTransport );
	HRESULT STDMETHODCALLTYPE SetActiveTransport(
			/* [in] */ IDMUSProdTransport *pTransport,
			/* [in] */ DWORD btnFlags);
	HRESULT STDMETHODCALLTYPE IsTransportPlaying(
			/* [in] */ IDMUSProdTransport *pTransport );
	HRESULT STDMETHODCALLTYPE PlayMIDIEvent(
			/* [in] */ BYTE bStatus,
			/* [in] */ BYTE bData1,
			/* [in] */ BYTE bData2,
			/* [in] */ DWORD dwTime );
	HRESULT STDMETHODCALLTYPE SetBtnStates(
			/* [in] */ IDMUSProdTransport *pTransport,
			/* [in] */ DWORD btnFlags );
	HRESULT STDMETHODCALLTYPE SetTempo(
			/* [in] */ IDMUSProdTransport *pTransport,
			/* [in] */ double dblTempo,
			/* [in] */ BOOL fEnable );
	HRESULT STDMETHODCALLTYPE RegisterNotify(
			/* [in] */ IDMUSProdNotifyCPt *pNotifyCPt,
			/* [in] */ REFGUID guidNotify );
	HRESULT STDMETHODCALLTYPE UnregisterNotify(
			/* [in] */ IDMUSProdNotifyCPt *pNotifyCPt,
			/* [in] */ REFGUID guidNotify );
	HRESULT STDMETHODCALLTYPE SetTransportName(
			/* [in] */ IDMUSProdTransport *pTransport,
			/* [in] */ BSTR bstrName );
	HRESULT STDMETHODCALLTYPE TransportStopped(
			/* [in] */ IDMUSProdTransport *pTransport );
	HRESULT STDMETHODCALLTYPE GetTransitionOptions(
			/* [out,retval] */ ConductorTransitionOptions *pTransitionOptions );
	HRESULT STDMETHODCALLTYPE RegisterSecondaryTransport(
			/* [in] */ IDMUSProdSecondaryTransport *pSecondaryTransport );
	HRESULT STDMETHODCALLTYPE UnRegisterSecondaryTransport(
			/* [in] */ IDMUSProdSecondaryTransport *pSecondaryTransport );
	HRESULT STDMETHODCALLTYPE SetSecondaryTransportName(
			/* [in] */ IDMUSProdSecondaryTransport *pSecondaryTransport,
			/* [in] */ BSTR bstrName );
    HRESULT STDMETHODCALLTYPE IsSecondaryTransportPlaying(
			/* [in] */ IDMUSProdSecondaryTransport *pSecondaryTransport );
	HRESULT STDMETHODCALLTYPE SetPChannelThru(
			/* [in] */ DWORD dwInputChannel,
			/* [in] */ DWORD dwPChannel );
	HRESULT STDMETHODCALLTYPE CancelPChannelThru(
			/* [in] */ DWORD dwInputChannel );
	HRESULT STDMETHODCALLTYPE IsTrackCursorEnabled( );

	// IDMUSProdConductor8
	HRESULT STDMETHODCALLTYPE RegisterAudiopath(
			/* [in] */ IDMUSProdNode *pAudiopathNode,
			/* [in] */ BSTR bstrName );
	HRESULT STDMETHODCALLTYPE UnRegisterAudiopath(
			/* [in] */ IDMUSProdNode *pAudiopathNode );
	HRESULT STDMETHODCALLTYPE SetAudiopathName(
			/* [in] */ IDMUSProdNode *pAudiopathNode,
			/* [in] */ BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetDownloadCustomDLSStatus(
			/* [out,retval] */ BOOL *pfDownloadCustomDLS );
	HRESULT STDMETHODCALLTYPE GetDownloadGMStatus(
			/* [out,retval] */ BOOL *pfDownloadGM );
	HRESULT STDMETHODCALLTYPE SetupMIDIAndWaveSave(
			/* [in] */ IUnknown *punkSegmentState );
	HRESULT STDMETHODCALLTYPE GetAudioParams(
			/* [out,retval] */ DMUS_AUDIOPARAMS *pDMUSAudioParams );

	// IDMUSProdComponent
	HRESULT STDMETHODCALLTYPE Initialize(
			/* [in] */ IDMUSProdFramework __RPC_FAR *pFramework, BSTR __RPC_FAR* pbstrErrorText );
	HRESULT STDMETHODCALLTYPE CleanUp();
	HRESULT STDMETHODCALLTYPE GetName(
			/* [retval][out] */ BSTR __RPC_FAR *pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp( BOOL fActivate );

	// IPrivateTransport
    HRESULT STDMETHODCALLTYPE PlayFromStart();
	HRESULT STDMETHODCALLTYPE PlayFromCursor();
	HRESULT STDMETHODCALLTYPE Record();
	HRESULT STDMETHODCALLTYPE Transition();
	HRESULT STDMETHODCALLTYPE SpaceBarPress();
	HRESULT STDMETHODCALLTYPE PlaySecondarySegment( int nSecondarySegment );

	// IDMUSProdConductorPrivate
	HRESULT STDMETHODCALLTYPE GetDefaultAudiopathNode( IDMUSProdNode **ppAudiopathNode );
	HRESULT STDMETHODCALLTYPE PleaseRedownload( void );

	// IPersistStream
	HRESULT STDMETHODCALLTYPE IsDirty(void);
	HRESULT STDMETHODCALLTYPE Load(
		/* [unique][in] */ IStream *pIStream);
	HRESULT STDMETHODCALLTYPE Save(
		/* [unique][in] */ IStream *pIStream,
		/* [in] */ BOOL fClearDirty);
	HRESULT STDMETHODCALLTYPE GetSizeMax(
		/* [out] */ ULARGE_INTEGER *pcbSize);
	HRESULT STDMETHODCALLTYPE GetClassID( 
		/* [out] */ CLSID __RPC_FAR *pClassID);

	// IDMUSProdNotifySink
    HRESULT STDMETHODCALLTYPE OnUpdate( 
        /* [in] */ IDMUSProdNode *pIDocRootNode,
        /* [in] */ GUID guidUpdateType,
        /* [in] */ void *pData);

    // IDMUSProdNode
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

private:
	void ReleaseAll();
	BOOL IsActiveUsingEngine( void );
	BOOL IsPlayingUsingEngine( void );
	ITransportRegEntry *GetDisplayedTransport( void );
	HRESULT SuspendOutput();
	HRESULT ResumeOutput();
	void BroadCastPortChangeNotification( void );
	void BroadCastPortRemovalNotification( void );
	void BroadCastWaveNotification( REFGUID rguidNotification );
	BOOL IsEnginePlaying( void );
	void ReadDefaultDirectMusicAudiopath( IDirectMusicAudioPath **ppAudiopath );
	void WriteDefaultDirectMusicAudiopath( void );
	HRESULT ActivateAudiopath( IDirectMusicAudioPath *pAudiopath, bool fSendNotificationsAndDownloadGM = true );
    HRESULT ActivateXboxPath( DWORD dwXboxPath);
    void UpdateMIDIThruChannels( void );
	void ClearThruConnections( void );
	void StopCursor( void );
	void StartCursor( void );
	void SetMIDIExportFields( IUnknown* pIUnknown );
	BOOL AllTransportsSetToPlay( void );
	void UpdateLatency( void );
	void UpdateAudioSettings( void );
	void DownOrUnLoadGM( void );
	void DownOrUnLoadDLS( void );

public:
	IDirectMusicPerformance8*			m_pDMPerformance;
	IDirectMusic8*						m_pDMusic;
	BOOL								m_fShutdown;
	BOOL								m_fOutputEnabled;
	IUnknown*							m_pIUnknownMIDIExport;
	IDirectMusicSegmentState*			m_pISegStateMIDIExport;
	BOOL								m_fLeadInMeasureMIDIExport;
	COutputTool*						m_pOutputTool;
	MIDISaveTool*						m_pMIDISaveTool;
	CNotifyTool*						m_pNotifyTool;

	// Audiopath stuff
	IDirectMusicAudioPath*				m_pDMAudiopath;
	CAudiopathListItem*					m_pAudiopathListItem;

	// Public phoney DSound stuff
	CPhoneyDSound						*m_pPhoneyDSound;
	void UsePhoneyDSound( bool fUsePhoneyDSound );

private:
	IDMUSProdFramework8* 				m_pFrameWork;
	HWND								m_hWndFramework;

	CTypedPtrList<CPtrList, CDownloadedInstrumentList*> m_lstDownloadedInstrumentList;
	HANDLE								m_hNotifyEvent;
	HANDLE								m_hNotifyExitEvent;
	bool								m_fDownloadGM;
	bool								m_fDownloadDLS;

	CTypedPtrList<CPtrList, CSecondaryToolbarHandler*> m_lstSecondaryToolbars;
	CStatusToolbarHandler*				m_pStatusToolbarHandler;
	CSynthStatusToolbar*				m_pSynthStatusToolbar;
	CToolbarHandler*					m_pToolbarHandler;
	COptionsToolbarHandler*				m_pOptionsToolbarHandler;
	CWaveRecordToolbar*					m_pWaveRecordToolbar;
	//bool								m_fAudiopathHasDumpDMOs;
    CTypedPtrList<CPtrList, ITransportRegEntry*> m_lstITransportRegEntry;
    CTypedPtrList<CPtrList, ISecondaryTransportRegEntry*> m_lstISecondaryTransportRegEntry;
	CTypedPtrList<CPtrList, CAudiopathListItem*> m_lstAudiopaths;
	CTypedPtrList<CPtrList, SegStateAudioPath*> m_lstSegStateAudioPaths;
	ITransportRegEntry*					m_rpActive;
	ITransportRegEntry*					m_rpPlaying;
	int 								m_nRatio;
	double								m_dblTempo;
	ConductorTransitionOptions			m_TransitionOptions;
	DWORD								m_dwLatency;
	DWORD								m_dwDefaultLatency;
	bool								m_fLatencyAppliesToAllAudiopaths;
	DWORD								m_dwSampleRate;
	DWORD								m_dwVoices;
	CLSID								m_clsidDefaultSynth;

	// Private Phoney DSound stuff
	bool								m_fUsePhoneyDSound;
	CLSID								m_clsidPhoneyOutput;

	BOOL								m_fMetronomeEnabled;
	BYTE								m_bMetronomeNoteOne;
	BYTE								m_bMetronomeVelocityOne;
	BYTE								m_bMetronomeNoteOther;
	BYTE								m_bMetronomeVelocityOther;
	DWORD								m_dwMetronomePChannel;

    CTypedPtrList<CPtrList, CNotifyEntry*> m_lstNotifyEntry;
	CRITICAL_SECTION					m_csNotifyEntry;
	CRITICAL_SECTION					m_csAudiopath;
	CRITICAL_SECTION					m_csAudiopathList;

	BEGIN_MSG_MAP(CConductor)
	END_MSG_MAP()

	// connection point for MIDI input sink
	BEGIN_CONNECTION_POINT_MAP( CConductor )
		CONNECTION_POINT_ENTRY( IID_IDMUSProdMidiInCPt )
	END_CONNECTION_POINT_MAP()
};

#endif // !defined(CCONDUCTOR_H__36F6DDF3_46CE_11D0_B9DB_00AA00C08146__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\DirectKS\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6076C15F_C134_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_STDAFX_H__6076C15F_C134_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxext.h>
#include <afxtempl.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6076C15F_C134_11D0_8C10_00A0C92E1CAC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\conduct.cpp ===
// Conductor.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f Conductorps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include <mmsystem.h>
#include "dsoundp.h"
#include "audiosink.h"
#include "Conductor.h"
#include "CConduct.h"
#include <dmksctrl.h>
#include <PrivateTransport.h>
#include <afxctl.h>
#include <PChannelName.h>
#ifdef DMP_XBOX 
#include "..\shared\xguids.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

const GUID CDECL BASED_CODE _tlid =
		{ 0x36F6DDE2, 0x46CE, 0x11D0, { 0xB9, 0xDB, 0, 0xAA, 0, 0xC0, 0x81, 0x46 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

EXTERN_C const IID IID_IMediaObjectInPlace = 
		{ 0x651b9ad0, 0x0fc7, 0x4aa9, { 0x95, 0x38, 0xd8, 0x99, 0x31, 0x01, 0x07, 0x41 } };
EXTERN_C const IID IID_IMediaObject = 
		{ 0xd8ad0f58, 0x5494, 0x4102, { 0x97, 0xc5, 0xec, 0x79, 0x8e, 0x59, 0xbc, 0xf4 } };

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CConductor, CConductor)
END_OBJECT_MAP()

class CConductorApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CConductorApp theApp;

BOOL CConductorApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();
}

int CConductorApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPCTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_SET_VALUE, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString) + sizeof( TCHAR );

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPCTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = ::RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_SET_VALUE, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = ::RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szCLSID[32];
	TCHAR	 szInProcServer32[32];
	TCHAR	 szThreadingModel[32];
	TCHAR	 szApartment[32];
    TCHAR    szOCXPath[256];
    TCHAR    szOCXLongPath[256];
    TCHAR    szGuid[100];
    CString  strName;
    TCHAR    szComponentPath[256];
	TCHAR	 szSkip[32];
	DWORD    dwSkip = 0;
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, 256 ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, 256);

	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szInProcServer32, _T("InProcServer32") );
	_tcscpy( szThreadingModel, _T("ThreadingModel") );
	_tcscpy( szApartment, _T("Apartment") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szSkip, _T("Skip") );
	
// Register Style Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_CConductor, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );
		strName.LoadString( IDS_CONDUCTOR_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, szSkip, &dwSkip, FALSE)) )
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_CConductor, &psz) ) )
    {
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	//return _Module.RegisterServer(TRUE);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

//	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
//	{
//		return ResultFromScode(SELFREG_E_TYPELIB);
//	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	//_Module.UnregisterServer();
	//return S_OK;

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(LIBID_CONDUCTORLib))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\Debug.cpp ===
//
// Debug.cpp
//
// Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved
//
//

#include <stdafx.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "Debug.h"

#ifdef _DEBUG

#define MODULE "Conductor"

// Section in WIN.INI for all debug settings
const char szDebugSection[] = "Debug";

// Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// The current debug level. 
static int giDebugLevel;

// Do asserts break?
static BOOL gfAssertBreak;

// DebugInit
//
// Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);

    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// DebugTrace
//
// Send a debug trace out.
//
// Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or the 
// kernel debugger if it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        
    LPSTR pstrFormat,       
    ...)                    
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

// DebugAssert
//
// Implementation of the 'assert' macro
//
void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\Debug.h ===
//
// Debug.h
// 
// Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
//
#ifndef _DEBUG_H_
#define _DEBUG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>

#undef assert

#ifdef _DEBUG

extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

#define Trace DebugTrace

#define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

#else

#define Trace
#define assert(exp)	((void)0)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgEchoAdvanced.h ===
#if !defined(AFX_DLGECHOADVANCED_H__07803D41_034C_47FB_A772_5162A1D2E0AA__INCLUDED_)
#define AFX_DLGECHOADVANCED_H__07803D41_034C_47FB_A772_5162A1D2E0AA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgEchoAdvanced.h : header file
//

#include "resource.h"
#include "OutputTool.h"

/////////////////////////////////////////////////////////////////////////////
// DlgEchoAdvanced dialog

class DlgMIDI;

class DlgEchoAdvanced : public CDialog
{
// Construction
public:
	DlgEchoAdvanced(CWnd* pParent = NULL);   // standard constructor

	DlgMIDI *m_pDlgMIDI;
// Dialog Data
	//{{AFX_DATA(DlgEchoAdvanced)
	enum { IDD = IDD_ECHO_ADVANCED };
	CComboBox	m_acomboEchoInput[ECHO_ADVANCED_PORTS];
	CSpinButtonCtrl	m_aspinEchoPChannels[ECHO_ADVANCED_PORTS];
	CEdit	m_aeditEchoPChannels[ECHO_ADVANCED_PORTS];
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DlgEchoAdvanced)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	int	m_anCurrentBlock[ECHO_ADVANCED_PORTS];
	void UpdatePChannelEdit( DWORD dwIndex, int nBlock );
	void DisplayPortCreationError( HRESULT hr, CComboBox &comboBox );

	// Generated message map functions
	//{{AFX_MSG(DlgEchoAdvanced)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnDeltaposSpinEchoPchannels(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusEditEchoPchannels();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGECHOADVANCED_H__07803D41_034C_47FB_A772_5162A1D2E0AA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgAltTempo.h ===
#if !defined(AFX_DLGALTTEMPO_H__A89CD69A_3092_11D2_8900_00C04FBF8D15__INCLUDED_)
#define AFX_DLGALTTEMPO_H__A89CD69A_3092_11D2_8900_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

// DlgAltTempo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// DlgAltTempo dialog

class DlgAltTempo : public CDialog
{
// Construction
public:
	DlgAltTempo(CWnd* pParent = NULL);   // standard constructor

	int m_nRatio;

// Dialog Data
	//{{AFX_DATA(DlgAltTempo)
	enum { IDD = IDD_ALTERNATE_TEMPO };
	CSpinButtonCtrl	m_spinRatio;
	CEdit	m_editRatio;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DlgAltTempo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(DlgAltTempo)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusRatioEdit();
	afx_msg void OnDeltaposSpinRatio(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGALTTEMPO_H__A89CD69A_3092_11D2_8900_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgEditPChannel.cpp ===
// DlgEditPChannel.cpp : implementation file
//

#include "stdafx.h"
#include "DlgEditPChannel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// DlgEditPChannel dialog


DlgEditPChannel::DlgEditPChannel(CWnd* pParent /*=NULL*/)
	: CDialog(DlgEditPChannel::IDD, pParent)
{
	//{{AFX_DATA_INIT(DlgEditPChannel)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void DlgEditPChannel::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DlgEditPChannel)
	DDX_Control(pDX, IDC_STATIC_PCHANNEL, m_staticPChannelHelp);
	DDX_Control(pDX, IDC_EDIT_PCHANNEL_NAME, m_editPChannelname);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DlgEditPChannel, CDialog)
	//{{AFX_MSG_MAP(DlgEditPChannel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DlgEditPChannel message handlers

BOOL DlgEditPChannel::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CDialog::OnInitDialog();

	CString strFormat;
	if( strFormat.LoadString( IDS_PCHANNEL_HELP ) )
	{
		CString strText;
		strText.Format( strFormat, m_dwPChannel + 1 );
		m_staticPChannelHelp.SetWindowText( strText );
	}

	m_editPChannelname.SetWindowText( m_strName );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void DlgEditPChannel::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString strName;
	m_editPChannelname.GetWindowText( strName );
	if( !strName.IsEmpty() )
	{
		m_strName = strName;
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgAltTempo.cpp ===
// DlgAltTempo.cpp : implementation file
//

#include "stdafx.h"
#include "cconduct.h"
#include "DlgAltTempo.h"
#include "math.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// DlgAltTempo dialog


DlgAltTempo::DlgAltTempo(CWnd* pParent /*=NULL*/)
	: CDialog(DlgAltTempo::IDD, pParent)
{
	//{{AFX_DATA_INIT(DlgAltTempo)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void DlgAltTempo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DlgAltTempo)
	DDX_Control(pDX, IDC_SPIN_RATIO, m_spinRatio);
	DDX_Control(pDX, IDC_RATIO_EDIT, m_editRatio);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DlgAltTempo, CDialog)
	//{{AFX_MSG_MAP(DlgAltTempo)
	ON_EN_KILLFOCUS(IDC_RATIO_EDIT, OnKillfocusRatioEdit)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_RATIO, OnDeltaposSpinRatio)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DlgAltTempo message handlers

void DlgAltTempo::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

BOOL DlgAltTempo::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	m_nRatio = g_pconductor->m_nRatio;

	if (m_editRatio.GetSafeHwnd() != NULL)
	{
		m_editRatio.EnableWindow(TRUE);
		m_editRatio.SetLimitText( 5 );
	}
	if (m_spinRatio.GetSafeHwnd() != NULL)
	{
		m_spinRatio.EnableWindow(TRUE);
		m_spinRatio.SetRange( int(ceil(DMUS_MASTERTEMPO_MIN * 100.0f)), int(DMUS_MASTERTEMPO_MAX * 100) );
		m_spinRatio.SetPos( m_nRatio );
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void DlgAltTempo::OnKillfocusRatioEdit() 
{
	CString strNewRatio;

	m_editRatio.GetWindowText( strNewRatio );

	// Strip leading and trailing spaces
	strNewRatio.TrimRight();
	strNewRatio.TrimLeft();

	if( strNewRatio.IsEmpty() )
	{
		m_spinRatio.SetPos( m_nRatio );
	}
	else
	{
		int iNewRatio = _ttoi( strNewRatio );
		if( iNewRatio > int(DMUS_MASTERTEMPO_MAX * 100) )
		{
			iNewRatio = int(DMUS_MASTERTEMPO_MAX * 100);
			m_spinRatio.SetPos( iNewRatio );
		}
		else if( float(iNewRatio) / 100 < DMUS_MASTERTEMPO_MIN )
		{
			iNewRatio = int(ceil(DMUS_MASTERTEMPO_MIN * 100.0f));
			m_spinRatio.SetPos( iNewRatio );
		}
		if( iNewRatio != m_nRatio )
		{
			m_nRatio = iNewRatio;
		}
	}
}

void DlgAltTempo::OnDeltaposSpinRatio(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int iNewRatio = m_spinRatio.GetPos() + pNMUpDown->iDelta;
	if( iNewRatio < int(ceil(DMUS_MASTERTEMPO_MIN * 100.0f)) )
	{
		iNewRatio = int(ceil(DMUS_MASTERTEMPO_MIN * 100.0f));
	}
	else if( iNewRatio > int(DMUS_MASTERTEMPO_MAX * 100) )
	{
		iNewRatio = int(DMUS_MASTERTEMPO_MAX * 100);
	}

	if( iNewRatio != m_nRatio )
	{
		m_nRatio = iNewRatio;
	}
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgEditPChannel.h ===
#if !defined(AFX_DLGEDITPCHANNEL_H__710E795E_94BF_4A5F_A5FE_E3C870C24674__INCLUDED_)
#define AFX_DLGEDITPCHANNEL_H__710E795E_94BF_4A5F_A5FE_E3C870C24674__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgEditPChannel.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// DlgEditPChannel dialog

class DlgEditPChannel : public CDialog
{
// Construction
public:
	DlgEditPChannel(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(DlgEditPChannel)
	enum { IDD = IDD_DIALOG_EDIT_PCHANNEL };
	CStatic	m_staticPChannelHelp;
	CEdit	m_editPChannelname;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DlgEditPChannel)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	DWORD	m_dwPChannel;
	CString	m_strName;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(DlgEditPChannel)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGEDITPCHANNEL_H__710E795E_94BF_4A5F_A5FE_E3C870C24674__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgEchoAdvanced.cpp ===
// DlgEchoAdvanced.cpp : implementation file
//

#include "stdafx.h"
#include "DlgEchoAdvanced.h"
#include "OutputTool.h"
#include "cconduct.h"
#include "DlgMIDI.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CMIDIInputContainer* g_pMIDIInputContainer;

/////////////////////////////////////////////////////////////////////////////
// DlgEchoAdvanced dialog


DlgEchoAdvanced::DlgEchoAdvanced(CWnd* pParent /*=NULL*/)
	: CDialog(DlgEchoAdvanced::IDD, pParent)
{
	//{{AFX_DATA_INIT(DlgEchoAdvanced)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	ZeroMemory( m_anCurrentBlock, sizeof(int) * ECHO_ADVANCED_PORTS );
	m_pDlgMIDI = NULL;
}


void DlgEchoAdvanced::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DlgEchoAdvanced)
	DDX_Control(pDX, IDC_COMBO_ECHO_INPUT_1, m_acomboEchoInput[0]);
	DDX_Control(pDX, IDC_COMBO_ECHO_INPUT_2, m_acomboEchoInput[1]);
	DDX_Control(pDX, IDC_COMBO_ECHO_INPUT_3, m_acomboEchoInput[2]);
	DDX_Control(pDX, IDC_COMBO_ECHO_INPUT_4, m_acomboEchoInput[3]);
	DDX_Control(pDX, IDC_COMBO_ECHO_INPUT_5, m_acomboEchoInput[4]);
	DDX_Control(pDX, IDC_COMBO_ECHO_INPUT_6, m_acomboEchoInput[5]);
	DDX_Control(pDX, IDC_COMBO_ECHO_INPUT_7, m_acomboEchoInput[6]);
	DDX_Control(pDX, IDC_COMBO_ECHO_INPUT_8, m_acomboEchoInput[7]);
	DDX_Control(pDX, IDC_SPIN_ECHO_PCHANNELS_1, m_aspinEchoPChannels[0]);
	DDX_Control(pDX, IDC_SPIN_ECHO_PCHANNELS_2, m_aspinEchoPChannels[1]);
	DDX_Control(pDX, IDC_SPIN_ECHO_PCHANNELS_3, m_aspinEchoPChannels[2]);
	DDX_Control(pDX, IDC_SPIN_ECHO_PCHANNELS_4, m_aspinEchoPChannels[3]);
	DDX_Control(pDX, IDC_SPIN_ECHO_PCHANNELS_5, m_aspinEchoPChannels[4]);
	DDX_Control(pDX, IDC_SPIN_ECHO_PCHANNELS_6, m_aspinEchoPChannels[5]);
	DDX_Control(pDX, IDC_SPIN_ECHO_PCHANNELS_7, m_aspinEchoPChannels[6]);
	DDX_Control(pDX, IDC_SPIN_ECHO_PCHANNELS_8, m_aspinEchoPChannels[7]);
	DDX_Control(pDX, IDC_EDIT_ECHO_PCHANNELS_1, m_aeditEchoPChannels[0]);
	DDX_Control(pDX, IDC_EDIT_ECHO_PCHANNELS_2, m_aeditEchoPChannels[1]);
	DDX_Control(pDX, IDC_EDIT_ECHO_PCHANNELS_3, m_aeditEchoPChannels[2]);
	DDX_Control(pDX, IDC_EDIT_ECHO_PCHANNELS_4, m_aeditEchoPChannels[3]);
	DDX_Control(pDX, IDC_EDIT_ECHO_PCHANNELS_5, m_aeditEchoPChannels[4]);
	DDX_Control(pDX, IDC_EDIT_ECHO_PCHANNELS_6, m_aeditEchoPChannels[5]);
	DDX_Control(pDX, IDC_EDIT_ECHO_PCHANNELS_7, m_aeditEchoPChannels[6]);
	DDX_Control(pDX, IDC_EDIT_ECHO_PCHANNELS_8, m_aeditEchoPChannels[7]);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DlgEchoAdvanced, CDialog)
	//{{AFX_MSG_MAP(DlgEchoAdvanced)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ECHO_PCHANNELS_1, OnDeltaposSpinEchoPchannels)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ECHO_PCHANNELS_2, OnDeltaposSpinEchoPchannels)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ECHO_PCHANNELS_3, OnDeltaposSpinEchoPchannels)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ECHO_PCHANNELS_4, OnDeltaposSpinEchoPchannels)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ECHO_PCHANNELS_5, OnDeltaposSpinEchoPchannels)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ECHO_PCHANNELS_6, OnDeltaposSpinEchoPchannels)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ECHO_PCHANNELS_7, OnDeltaposSpinEchoPchannels)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ECHO_PCHANNELS_8, OnDeltaposSpinEchoPchannels)
	ON_EN_KILLFOCUS(IDC_EDIT_ECHO_PCHANNELS_1, OnKillfocusEditEchoPchannels)
	ON_EN_KILLFOCUS(IDC_EDIT_ECHO_PCHANNELS_2, OnKillfocusEditEchoPchannels)
	ON_EN_KILLFOCUS(IDC_EDIT_ECHO_PCHANNELS_3, OnKillfocusEditEchoPchannels)
	ON_EN_KILLFOCUS(IDC_EDIT_ECHO_PCHANNELS_4, OnKillfocusEditEchoPchannels)
	ON_EN_KILLFOCUS(IDC_EDIT_ECHO_PCHANNELS_5, OnKillfocusEditEchoPchannels)
	ON_EN_KILLFOCUS(IDC_EDIT_ECHO_PCHANNELS_6, OnKillfocusEditEchoPchannels)
	ON_EN_KILLFOCUS(IDC_EDIT_ECHO_PCHANNELS_7, OnKillfocusEditEchoPchannels)
	ON_EN_KILLFOCUS(IDC_EDIT_ECHO_PCHANNELS_8, OnKillfocusEditEchoPchannels)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DlgEchoAdvanced message handlers

BOOL DlgEchoAdvanced::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Ensure we have a valid window handle
	if( (m_acomboEchoInput[0].GetSafeHwnd() == NULL)
	||	(NULL == m_pDlgMIDI) )
	{
		return FALSE;
	}

	// Loop through all available DMusic ports, adding them to the combo boxes and
	// looking for existing 'Echo MIDI' input ports
	bool afFoundEchoInput[MIDI_IN_PORTS] = {false};
	HRESULT	hr;
	DMUS_PORTCAPS dmpc;
	for( DWORD dwDMIndex = 0; ; dwDMIndex++ )
	{
		// Initialize the PORTCAPS structure
		ZeroMemory(&dmpc, sizeof(dmpc));
		dmpc.dwSize = sizeof(DMUS_PORTCAPS);

		// Enumerate the next port
		hr = g_pconductor->m_pDMusic->EnumPort( dwDMIndex, &dmpc );
		if(SUCCEEDED(hr) && hr != S_FALSE)
		{
			if( dmpc.dwClass == DMUS_PC_INPUTCLASS )
			{
				// Found an input port - add it to the combo box

				// Create a GUID to save this port's GUID
				GUID *pGuid;
				pGuid = new GUID;
				ASSERT( pGuid );
				CopyMemory( pGuid, &dmpc.guidPort, sizeof(GUID) );

				//TRACE("Adding %S %x\n", dmpc.wszDescription, dmpc.guidPort.Data1 );

				// Point the combo box item's data ptr at the port's GUID
				CString strDesc = dmpc.wszDescription;
				for( int i=0; i<ECHO_ADVANCED_PORTS; i++ )
				{
					// Add the item to the Echo input combo box
					DWORD dwComboIndex = m_acomboEchoInput[i].AddString( strDesc );
					m_acomboEchoInput[i].SetItemDataPtr( dwComboIndex, (void *)pGuid );

					// If we found the currently selected port, select it
					// In the MIDIInputContainer, the Echo ports start at 1, but we're
					// iterating from zero, so add one.
					if ( ::IsEqualGUID( m_pDlgMIDI->m_aguidEchoMIDIInPort[i], dmpc.guidPort ) )
					{
						afFoundEchoInput[i] = true;
						m_acomboEchoInput[i].SetCurSel( dwComboIndex );
					}
				}
			}
		}
		else
		{
			break;
		}
	}

	// Add a 'none' option - it has the data UINT_MAX
	CString strNoMIDI;
	strNoMIDI.LoadString( IDS_NO_MIDI_INPUT );

	// Add the 'none' option to the Echo MIDI input box
	for( int i=0; i<ECHO_ADVANCED_PORTS; i++ )
	{
		DWORD dwComboIndex = m_acomboEchoInput[i].InsertString( 0, strNoMIDI );
		m_acomboEchoInput[i].SetItemData( dwComboIndex, UINT_MAX );
		m_acomboEchoInput[i].SetItemDataPtr( dwComboIndex, (void *)UINT_MAX );

		// By default, select 'None'
		if( !afFoundEchoInput[i] )
		{
			m_acomboEchoInput[i].SetCurSel(dwComboIndex);
		}

		m_aspinEchoPChannels[i].SetRange( 0, 250 );
		UpdatePChannelEdit( i, m_pDlgMIDI->m_anCurrentBlock[i] );
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void DlgEchoAdvanced::OnOK() 
{
	for( int i=0; i<ECHO_ADVANCED_PORTS; i++ )
	{
		GUID guidEchoInputPort = GUID_AllZeros;

		// Get the index of the currently selected item
		int nIndex = m_acomboEchoInput[i].GetCurSel();
		if (nIndex == CB_ERR)
		{
			// Error getting index of selected item - perhaps nothing's selected?
			ASSERT( FALSE );
		}
		else
		{
			// Get the selected port GUID
			if( m_acomboEchoInput[i].GetItemDataPtr( nIndex ) != (void *)UINT_MAX )
			{
				GUID *pGuid = (GUID *) m_acomboEchoInput[i].GetItemDataPtr( nIndex );
				memcpy( &guidEchoInputPort, pGuid, sizeof(GUID) );
			}
		}

		// Update the main MIDI option dialog
		m_pDlgMIDI->m_aguidEchoMIDIInPort[i] = guidEchoInputPort;
		m_pDlgMIDI->m_anCurrentBlock[i] = m_anCurrentBlock[i];
	}
	
	CDialog::OnOK();
}

void DlgEchoAdvanced::UpdatePChannelEdit( DWORD dwIndex, int nBlock )
{
	// Validate the block number
	if( nBlock < 0 )
	{
		return;
	}

	// Validate the index
	if( dwIndex >= ECHO_ADVANCED_PORTS )
	{
		return;
	}

	// Copy it to our local variable (since the spin control doesn't store it)
	m_anCurrentBlock[dwIndex] = nBlock;

	// Compute the text to display, and then display it
	CString strText, strFormat;
	strFormat.LoadString( IDS_PCHANNEL_GROUP_FORAMT );
	strText.Format( strFormat, nBlock * 16 + 1, nBlock * 16 + 16 );
	m_aeditEchoPChannels[dwIndex].SetWindowText( strText );
}

void DlgEchoAdvanced::OnDeltaposSpinEchoPchannels(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	DWORD dwIndex = pNMUpDown->hdr.idFrom - IDC_SPIN_ECHO_PCHANNELS_1;

	ASSERT( dwIndex < ECHO_ADVANCED_PORTS );

	if( dwIndex >= ECHO_ADVANCED_PORTS )
	{
		return;
	}

	// Calculate what the block # will change to
	int nNewBlock = m_anCurrentBlock[dwIndex] + pNMUpDown->iDelta;

	// If the block number is invalid (negative), return
	if( nNewBlock < 0 )
	{
		*pResult = 1;
		return;
	}

	// Update the text in the PChannel edit box
	UpdatePChannelEdit( dwIndex, nNewBlock );

	*pResult = 1;
}

void DlgEchoAdvanced::OnKillfocusEditEchoPchannels() 
{
	for( int i=0; i<ECHO_ADVANCED_PORTS; i++ )
	{
		CString strText;
		m_aeditEchoPChannels[i].GetWindowText( strText );
		
		// Strip leading and trailing spaces
		strText.TrimRight();
		strText.TrimLeft();

		// If empty set value to previous one
		if( strText.IsEmpty() )
		{
			UpdatePChannelEdit( i, m_anCurrentBlock[i] );
		}
		else
		{
			// Convert from text to int
			int nNewBlock;
			TCHAR *tcstrTmp;
			tcstrTmp = new TCHAR[strText.GetLength() + 1];
			tcstrTmp[0] = 0;
			if( _stscanf( strText, "%d%s", &nNewBlock, tcstrTmp ) )
			{
				// Check bounds
				if( nNewBlock < 0 )
				{
					nNewBlock = 0;
				}
				else if( nNewBlock > 999 )
				{
					nNewBlock = 999;
				}

				nNewBlock /= 16;
				UpdatePChannelEdit( i, nNewBlock );
			}
			else
			{
				// Invalid data - reset control with previous value
				UpdatePChannelEdit( i, m_anCurrentBlock[i] );
			}

			delete tcstrTmp;
		}
	}
}

void DlgEchoAdvanced::DisplayPortCreationError( HRESULT hr, CComboBox &comboBox )
{
	// Failed to set Conductor's MIDI input
	CString strError, strFormat;
	strFormat.LoadString( IDS_ERR_UNKNOWN_CREATE_PORT );

	CString strName;
	comboBox.GetLBText( comboBox.GetCurSel(), strName );
	strError.Format( strFormat, hr, strName );

	AfxMessageBox( strError, MB_ICONEXCLAMATION | MB_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgMIDIExport.cpp ===
// DlgMIDIExport.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DlgMIDIExport.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgMIDIExport dialog


CDlgMIDIExport::CDlgMIDIExport(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgMIDIExport::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgMIDIExport)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_fLeadInMeasureMIDIExport = FALSE;
}


void CDlgMIDIExport::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgMIDIExport)
	DDX_Control(pDX, IDC_LEADIN_MEASURE, m_radioLeadInMeasure);
	DDX_Control(pDX, IDC_FIRST_MEASURE, m_radioFirstMeasure);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgMIDIExport, CDialog)
	//{{AFX_MSG_MAP(CDlgMIDIExport)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgMIDIExport message handlers

BOOL CDlgMIDIExport::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CDialog::OnInitDialog();
	
	m_radioLeadInMeasure.SetCheck( m_fLeadInMeasureMIDIExport );
	m_radioFirstMeasure.SetCheck( !m_fLeadInMeasureMIDIExport );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgMIDIExport::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_fLeadInMeasureMIDIExport = m_radioLeadInMeasure.GetCheck();
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgMetronome.h ===
#if !defined(AFX_DLGMETRONOME_H__237BB477_063B_11D2_88D4_00C04FBF8D15__INCLUDED_)
#define AFX_DLGMETRONOME_H__237BB477_063B_11D2_88D4_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgMetronome.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// DlgMetronome dialog

class DlgMetronome : public CDialog
{
// Construction
public:
	DlgMetronome(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(DlgMetronome)
	enum { IDD = IDD_DIALOG_METRONOME };
	CSpinButtonCtrl	m_spinOtherVelocity;
	CEdit	m_editOtherVelocity;
	CComboBox	m_comboOtherValue;
	CSpinButtonCtrl	m_spinCountIn;
	CEdit	m_editCountIn;
	CSpinButtonCtrl	m_spinPChannel;
	CEdit	m_editPChannel;
	CEdit	m_editOneVelocity;
	CComboBox	m_comboOneValue;
	CSpinButtonCtrl	m_spinOneVelocity;
	//}}AFX_DATA

	BYTE	m_bOneVelocity;
	BYTE	m_bOneValue;
	BYTE	m_bOtherVelocity;
	BYTE	m_bOtherValue;
	DWORD	m_dwPChannel;

	long	m_lCountInBars;
	BOOL	m_fCountOnlyOnRecord;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DlgMetronome)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(DlgMetronome)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnKillfocusEditOneVelocity();
	afx_msg void OnKillfocusEditPchannel();
	afx_msg void OnKillfocusEditOtherVelocity();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGMETRONOME_H__237BB477_063B_11D2_88D4_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgMIDIExport.h ===
#if !defined(AFX_DLGMIDIEXPORT_H__DD2755D3_1843_11D3_B447_00105A2796DE__INCLUDED_)
#define AFX_DLGMIDIEXPORT_H__DD2755D3_1843_11D3_B447_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgMIDIExport.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgMIDIExport dialog

class CDlgMIDIExport : public CDialog
{
// Construction
public:
	CDlgMIDIExport(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgMIDIExport)
	enum { IDD = IDD_DIALOG_MIDI_EXPORT };
	CButton	m_radioLeadInMeasure;
	CButton	m_radioFirstMeasure;
	//}}AFX_DATA

public:
	BOOL	m_fLeadInMeasureMIDIExport;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgMIDIExport)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgMIDIExport)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGMIDIEXPORT_H__DD2755D3_1843_11D3_B447_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgMetronome.cpp ===
// DlgMetronome.cpp : implementation file
//

#include "stdafx.h"
#include "cconduct.h"
#include "DlgMetronome.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static const char *gacMidiValueToName[12] = {
"C ",
"C#",
"D ",
"D#",
"E ",
"F ",
"F#",
"G ",
"G#",
"A ",
"A#",
"B " };

const static char *gacDrums[61] = {
"High Q",
"Slap ",
"Scratch Push",
"Scratch Pull",
"Sticks",
"Square Click",
"Click Metronome",
"Bell Metronome",
"Kick Drum 2",
"Kick Drum 1",
"Side Stick",
"Snare Drum 1",
"Hand Clap",
"Snare Drum 2",
"Low Tom 2",
"Closed Hi-Hat",
"Low Tom 1",
"Pedal Hi-Hat",
"Mid Tom 2",
"Open Hi-Hat",
"Mid Tom 1",
"Hi Tom 2 ",
"Crash Cymbal 1",
"Hi Tom 1",
"Ride Cymbal 1",
"Chinese Cymbal ",
"Ride Bell",
"Tambourine",
"Splash Cymbal",
"Cowbell",
"Crash Cymbal 2",
"Vibra-slap",
"Ride Cymbal 2",
"Hi Bongo",
"Low Bongo",
"Mute Hi Conga",
"Open Hi Conga",
"Low Conga",
"Hi Timbale",
"Low Timbale",
"Hi Agogo",
"Low Agogo",
"Cabasa",
"Maracas",
"Short Whistle",
"Long Whistle",
"Short Guiro",
"Long Guiro",
"Claves",
"Hi Woodblock",
"Low Woodblock",
"Mute Cuica",
"Open Cuica",
"Mute Triangle",
"Open Triangle",
"Shaker",
"Jingle Bell",
"Belltree",
"Castanets",
"Mute Surdo",
"Open Surdo" };

/////////////////////////////////////////////////////////////////////////////
// DlgMetronome dialog


DlgMetronome::DlgMetronome(CWnd* pParent /*=NULL*/)
	: CDialog(DlgMetronome::IDD, pParent)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//{{AFX_DATA_INIT(DlgMetronome)
	//}}AFX_DATA_INIT
}


void DlgMetronome::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DlgMetronome)
	DDX_Control(pDX, IDC_SPIN_OTHER_VELOCITY, m_spinOtherVelocity);
	DDX_Control(pDX, IDC_EDIT_OTHER_VELOCITY, m_editOtherVelocity);
	DDX_Control(pDX, IDC_COMBO_OTHER_VALUE, m_comboOtherValue);
	DDX_Control(pDX, IDC_SPIN_COUNTIN, m_spinCountIn);
	DDX_Control(pDX, IDC_EDIT_COUNTIN, m_editCountIn);
	DDX_Control(pDX, IDC_SPIN_PCHANNEL, m_spinPChannel);
	DDX_Control(pDX, IDC_EDIT_PCHANNEL, m_editPChannel);
	DDX_Control(pDX, IDC_EDIT_ONE_VELOCITY, m_editOneVelocity);
	DDX_Control(pDX, IDC_COMBO_ONE_VALUE, m_comboOneValue);
	DDX_Control(pDX, IDC_SPIN_ONE_VELOCITY, m_spinOneVelocity);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DlgMetronome, CDialog)
	//{{AFX_MSG_MAP(DlgMetronome)
	ON_EN_KILLFOCUS(IDC_EDIT_ONE_VELOCITY, OnKillfocusEditOneVelocity)
	ON_EN_KILLFOCUS(IDC_EDIT_PCHANNEL, OnKillfocusEditPchannel)
	ON_EN_KILLFOCUS(IDC_EDIT_OTHER_VELOCITY, OnKillfocusEditOtherVelocity)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DlgMetronome message handlers

BOOL DlgMetronome::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CDialog::OnInitDialog();
	
	m_bOneVelocity = g_pconductor->m_bMetronomeVelocityOne;
	m_bOneValue = g_pconductor->m_bMetronomeNoteOne;
	m_bOtherVelocity = g_pconductor->m_bMetronomeVelocityOther;
	m_bOtherValue = g_pconductor->m_bMetronomeNoteOther;
	m_dwPChannel = g_pconductor->m_dwMetronomePChannel;

	if (m_editOneVelocity.GetSafeHwnd() != NULL)
	{
		m_editOneVelocity.EnableWindow(TRUE);
		m_editOneVelocity.SetLimitText( 3 );
	}
	if (m_spinOneVelocity.GetSafeHwnd() != NULL)
	{
		m_spinOneVelocity.EnableWindow(TRUE);
		m_spinOneVelocity.SetRange( 0, 127 );
		m_spinOneVelocity.SetPos( m_bOneVelocity );
	}

	if (m_editOtherVelocity.GetSafeHwnd() != NULL)
	{
		m_editOtherVelocity.EnableWindow(TRUE);
		m_editOtherVelocity.SetLimitText( 3 );
	}
	if (m_spinOtherVelocity.GetSafeHwnd() != NULL)
	{
		m_spinOtherVelocity.EnableWindow(TRUE);
		m_spinOtherVelocity.SetRange( 0, 127 );
		m_spinOtherVelocity.SetPos( m_bOtherVelocity );
	}

	if( (m_comboOneValue.GetSafeHwnd() != NULL)
	&&	(m_comboOtherValue.GetSafeHwnd() != NULL) )
	{
		m_comboOneValue.EnableWindow(TRUE);
		m_comboOtherValue.EnableWindow(TRUE);
		m_comboOneValue.ResetContent();
		m_comboOtherValue.ResetContent();

		int nIndex;
		CString cstrTxt;
		for( nIndex = 127; nIndex > 87; nIndex-- )
		{
			cstrTxt.Format( "%s %d", gacMidiValueToName[nIndex % 12] , nIndex/12 );
			m_comboOneValue.AddString( cstrTxt );
			m_comboOtherValue.AddString( cstrTxt );
		}

		for( nIndex = 87; nIndex > 26; nIndex-- )
		{
			cstrTxt.Format( "%s %d - %s", gacMidiValueToName[nIndex % 12] , nIndex/12, gacDrums[nIndex - 27] );
			m_comboOneValue.AddString( cstrTxt );
			m_comboOtherValue.AddString( cstrTxt );
		}

		for( nIndex = 26; nIndex >= 0; nIndex-- )
		{
			cstrTxt.Format( "%s %d", gacMidiValueToName[nIndex % 12] , nIndex/12 );
			m_comboOneValue.AddString( cstrTxt );
			m_comboOtherValue.AddString( cstrTxt );
		}

		m_comboOneValue.SetCurSel( 127 - m_bOneValue );
		m_comboOtherValue.SetCurSel( 127 - m_bOtherValue );
	}

	if (m_editPChannel.GetSafeHwnd() != NULL)
	{
		m_editPChannel.EnableWindow(TRUE);
		m_editPChannel.SetLimitText( 3 );
	}
	if (m_spinPChannel.GetSafeHwnd() != NULL)
	{
		m_spinPChannel.EnableWindow(TRUE);
		m_spinPChannel.SetRange( 1, 999 );
		m_spinPChannel.SetPos( m_dwPChannel + 1 );
	}

	if (m_editCountIn.GetSafeHwnd() != NULL)
	{
		m_editCountIn.EnableWindow(TRUE);
		m_editCountIn.SetLimitText( 2 );
	}
	if (m_spinCountIn.GetSafeHwnd() != NULL)
	{
		m_spinCountIn.EnableWindow(TRUE);
		m_spinCountIn.SetRange( 0, 99 );
		m_spinCountIn.SetPos( m_lCountInBars );
	}

	CheckRadioButton( IDC_RADIO_RECORD, IDC_RADIO_ALL_PLAYBACK,
					  m_fCountOnlyOnRecord ? IDC_RADIO_RECORD : IDC_RADIO_ALL_PLAYBACK );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void DlgMetronome::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_comboOneValue.GetCurSel() != CB_ERR )
	{
		m_bOneValue = BYTE(127 - m_comboOneValue.GetCurSel());
	}

	if( m_comboOtherValue.GetCurSel() != CB_ERR )
	{
		m_bOtherValue = BYTE(127 - m_comboOtherValue.GetCurSel());
	}
	
	m_bOneVelocity = BYTE(m_spinOneVelocity.GetPos());
	m_bOtherVelocity = BYTE(m_spinOtherVelocity.GetPos());

	m_dwPChannel = m_spinPChannel.GetPos() - 1;

	m_lCountInBars = m_spinCountIn.GetPos();

	m_fCountOnlyOnRecord = (GetCheckedRadioButton( IDC_RADIO_RECORD, IDC_RADIO_ALL_PLAYBACK ) == IDC_RADIO_RECORD);

	CDialog::OnOK();
}

void DlgMetronome::OnKillfocusEditOneVelocity() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString strNewVelocity;

	m_editOneVelocity.GetWindowText( strNewVelocity );

	// Strip leading and trailing spaces
	strNewVelocity.TrimRight();
	strNewVelocity.TrimLeft();

	if( strNewVelocity.IsEmpty() )
	{
		m_spinOneVelocity.SetPos( m_bOneVelocity );
	}
	else
	{
		int iNewVelocity = _ttoi( strNewVelocity );
		if( iNewVelocity > 127 )
		{
			iNewVelocity = 127;
			m_spinOneVelocity.SetPos( iNewVelocity );
		}
		// Only update m_bVelocity in OnOK()
		/*
		if( (BYTE)iNewVelocity != m_bVelocity )
		{
			m_bVelocity = (BYTE)iNewVelocity;
		}
		*/
	}
}

void DlgMetronome::OnKillfocusEditPchannel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString strNewPChannel;

	m_editPChannel.GetWindowText( strNewPChannel );

	// Strip leading and trailing spaces
	strNewPChannel.TrimRight();
	strNewPChannel.TrimLeft();

	if( strNewPChannel.IsEmpty() )
	{
		m_spinPChannel.SetPos( m_dwPChannel + 1 );
	}
	else
	{
		// Can never be greater than 999, since the user can only enter 3 digits
		// But, it can be less than 1:
		int iNewPChannel = _ttoi( strNewPChannel );
		if( iNewPChannel < 1 )
		{
			iNewPChannel = 1;
			m_spinPChannel.SetPos( iNewPChannel );
		}
		// Only update m_dwPChannel in OnOK()
		/*
		if( (iNewPChannel - 1) != m_dwPChannel )
		{
			m_dwPChannel = iNewPChannel - 1;
		}
		*/
	}
}

BOOL DlgMetronome::PreTranslateMessage(MSG* pMsg) 
{
	if( pMsg->message == WM_KEYDOWN && !(pMsg->lParam & 0x40000000) )
	{
		switch( (int) pMsg->wParam )
		{
		case VK_RETURN:
		{
			CWnd* pWnd = GetFocus();
			if( pWnd )
			{
				int id = pWnd->GetDlgCtrlID();
				if( (id != IDOK) && (id != IDCANCEL) )
				{
					CWnd* pWndNext = GetNextDlgTabItem( pWnd );
					if( pWndNext )
					{
						pWndNext->SetFocus();
						return TRUE;
					}
				}
			}
		}
		}
	}
	
	return CDialog::PreTranslateMessage(pMsg);
}


void DlgMetronome::OnKillfocusEditOtherVelocity() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString strNewVelocity;

	m_editOtherVelocity.GetWindowText( strNewVelocity );

	// Strip leading and trailing spaces
	strNewVelocity.TrimRight();
	strNewVelocity.TrimLeft();

	if( strNewVelocity.IsEmpty() )
	{
		m_spinOtherVelocity.SetPos( m_bOtherVelocity );
	}
	else
	{
		int iNewVelocity = _ttoi( strNewVelocity );
		if( iNewVelocity > 127 )
		{
			iNewVelocity = 127;
			m_spinOtherVelocity.SetPos( iNewVelocity );
		}
		// Only update m_bVelocity in OnOK()
		/*
		if( (BYTE)iNewVelocity != m_bVelocity )
		{
			m_bVelocity = (BYTE)iNewVelocity;
		}
		*/
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgSecondaryStart.cpp ===
// DlgSecondaryStart.cpp : implementation file
//

#include "stdafx.h"
#include <dmusici.h>
#include "DlgSecondaryStart.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// DlgSecondaryStart dialog


DlgSecondaryStart::DlgSecondaryStart(CWnd* pParent /*=NULL*/)
	: CDialog(DlgSecondaryStart::IDD, pParent)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//{{AFX_DATA_INIT(DlgSecondaryStart)
	//}}AFX_DATA_INIT

	m_dwSegmentFlags = 0;
}


void DlgSecondaryStart::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DlgSecondaryStart)
	DDX_Control(pDX, IDC_CHECK_BOUNDARY, m_checkBoundary);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_TIME, m_radioSwitchAnyTime);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_GRID, m_radioSwitchAnyGrid);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_BEAT, m_radioSwitchAnyBeat);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_BAR, m_radioSwitchAnyBar);
	DDX_Control(pDX, IDC_STATIC_NO_MARKERS, m_staticNoMarkers);
	DDX_Control(pDX, IDC_ALIGN_OPTIONS_PROMPT, m_staticAlignPrompt);
	DDX_Control(pDX, IDC_COMBO_BOUNDARY, m_comboBoundary);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DlgSecondaryStart, CDialog)
	//{{AFX_MSG_MAP(DlgSecondaryStart)
	ON_BN_CLICKED(IDC_CHECK_BOUNDARY, OnCheckBoundary)
	ON_CBN_SELCHANGE(IDC_COMBO_BOUNDARY, OnSelchangeComboBoundary)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DlgSecondaryStart message handlers

BOOL DlgSecondaryStart::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CDialog::OnInitDialog();
	
	// Set the 'Controlling' button state
	CheckDlgButton( IDC_CONTROL, (m_dwSegmentFlags & DMUS_SEGF_CONTROL) ? BST_CHECKED : BST_UNCHECKED );
	
	// Set the 'Don't Cutoff' radio button state
	int nRadioButton = IDC_RADIO_INVALIDATE;
	if( m_dwSegmentFlags & DMUS_SEGF_INVALIDATE_PRI )
	{
		nRadioButton = IDC_RADIO_INVALIDATEPRI;
	}
	else if( m_dwSegmentFlags & DMUS_SEGF_NOINVALIDATE )
	{
		nRadioButton = IDC_RADIO_NOINVALIDATE;
	}
	CheckRadioButton( IDC_RADIO_NOINVALIDATE, IDC_RADIO_INVALIDATE, nRadioButton );

	// Set the Quick Response/After Prepare Time radio button state
	CheckRadioButton( IDC_RADIO_TIMING_QUICK, IDC_RADIO_TIMING_AFTERPREPARETIME, (m_dwSegmentFlags & DMUS_SEGF_AFTERPREPARETIME) ? IDC_RADIO_TIMING_AFTERPREPARETIME : IDC_RADIO_TIMING_QUICK );

	// Set the Immediate/Grid/Beat/Bar/Default radio button state
	if( m_dwSegmentFlags & DMUS_SEGF_ALIGN )
	{
		m_staticAlignPrompt.EnableWindow( TRUE );
		m_radioSwitchAnyTime.EnableWindow( TRUE );
		m_radioSwitchAnyGrid.EnableWindow( TRUE );
		m_radioSwitchAnyBeat.EnableWindow( TRUE );
		m_radioSwitchAnyBar.EnableWindow( TRUE );

		if( m_dwSegmentFlags & DMUS_SEGF_BEAT )
		{
			m_comboBoundary.SetCurSel( 5 );
		}
		else if( m_dwSegmentFlags & DMUS_SEGF_MEASURE )
		{
			m_comboBoundary.SetCurSel( 6 );
		}
		else if( m_dwSegmentFlags & DMUS_SEGF_SEGMENTEND )
		{
			m_comboBoundary.SetCurSel( 7 );
		}

		if( m_dwSegmentFlags & DMUS_SEGF_VALID_START_GRID )
		{
			CheckRadioButton( IDC_RADIO_SWITCH_ANY_TIME, IDC_RADIO_SWITCH_ANY_BAR, IDC_RADIO_SWITCH_ANY_GRID );
		}
		else if( m_dwSegmentFlags & DMUS_SEGF_VALID_START_BEAT )
		{
			CheckRadioButton( IDC_RADIO_SWITCH_ANY_TIME, IDC_RADIO_SWITCH_ANY_BAR, IDC_RADIO_SWITCH_ANY_BEAT );
		}
		else if( m_dwSegmentFlags & DMUS_SEGF_VALID_START_MEASURE )
		{
			CheckRadioButton( IDC_RADIO_SWITCH_ANY_TIME, IDC_RADIO_SWITCH_ANY_BAR, IDC_RADIO_SWITCH_ANY_BAR );
		}
		else //if( m_dwSegmentFlags & DMUS_SEGF_VALID_START_TICK )
		{
			CheckRadioButton( IDC_RADIO_SWITCH_ANY_TIME, IDC_RADIO_SWITCH_ANY_BAR, IDC_RADIO_SWITCH_ANY_TIME );
		}
	}
	else
	{
		m_staticAlignPrompt.EnableWindow( FALSE );
		m_radioSwitchAnyTime.SetCheck( 0 );
		m_radioSwitchAnyTime.EnableWindow( FALSE );
		m_radioSwitchAnyGrid.SetCheck( 0 );
		m_radioSwitchAnyGrid.EnableWindow( FALSE );
		m_radioSwitchAnyBeat.SetCheck( 0 );
		m_radioSwitchAnyBeat.EnableWindow( FALSE );
		m_radioSwitchAnyBar.SetCheck( 0 );
		m_radioSwitchAnyBar.EnableWindow( FALSE );

		if( m_dwSegmentFlags & DMUS_SEGF_GRID )
		{
			m_comboBoundary.SetCurSel( 2 );
		}
		else if( m_dwSegmentFlags & DMUS_SEGF_BEAT )
		{
			m_comboBoundary.SetCurSel( 3 );
		}
		else if( m_dwSegmentFlags & DMUS_SEGF_MEASURE )
		{
			m_comboBoundary.SetCurSel( 4 );
		}
		else if( m_dwSegmentFlags & DMUS_SEGF_SEGMENTEND )
		{
			m_comboBoundary.SetCurSel( 8 );
		}
		else if( m_dwSegmentFlags & DMUS_SEGF_QUEUE )
		{
			m_comboBoundary.SetCurSel( 9 );
		}
		else if( m_dwSegmentFlags & DMUS_SEGF_DEFAULT )
		{
			m_comboBoundary.SetCurSel( 0 );
		}
		else
		{
			// Immediate
			m_comboBoundary.SetCurSel( 1 );
		}
	}
		
	if( (m_dwSegmentFlags & DMUS_SEGF_ALIGN)
	||	(m_dwSegmentFlags & DMUS_SEGF_QUEUE) )
	{
		// Set the 'marker' static text and button state
		m_checkBoundary.SetCheck( BST_UNCHECKED );
		m_staticNoMarkers.ShowWindow( SW_HIDE );
		m_checkBoundary.EnableWindow( FALSE );
		m_dwSegmentFlags &= ~DMUS_SEGF_MARKER;
	}
	else
	{
		// Set the 'marker' static text and button state
		m_checkBoundary.SetCheck( (m_dwSegmentFlags & DMUS_SEGF_MARKER) ? BST_CHECKED : BST_UNCHECKED );
		m_staticNoMarkers.ShowWindow( (m_dwSegmentFlags & DMUS_SEGF_MARKER) ? SW_SHOW : SW_HIDE );
		m_checkBoundary.EnableWindow( TRUE );
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void DlgSecondaryStart::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Get the 'Controlling' button state
	m_dwSegmentFlags = IsDlgButtonChecked( IDC_CONTROL ) ? DMUS_SEGF_CONTROL : 0;
	
	// Get the 'Don't Cutoff' radio button states
	switch( GetCheckedRadioButton( IDC_RADIO_NOINVALIDATE, IDC_RADIO_INVALIDATE ) )
	{
	case IDC_RADIO_NOINVALIDATE:
		m_dwSegmentFlags |= DMUS_SEGF_NOINVALIDATE;
		break;
	case IDC_RADIO_INVALIDATEPRI:
		m_dwSegmentFlags |= DMUS_SEGF_INVALIDATE_PRI;
		break;
	case IDC_RADIO_INVALIDATE:
		// Do nothing
		break;
	}

	// Get the Quick Response/After Prepare Time radio button state
	m_dwSegmentFlags |= IsDlgButtonChecked( IDC_RADIO_TIMING_AFTERPREPARETIME ) ? DMUS_SEGF_AFTERPREPARETIME : 0;

	// Get the 'marker' button state
	m_dwSegmentFlags |= IsDlgButtonChecked( IDC_CHECK_BOUNDARY ) ? DMUS_SEGF_MARKER : 0;

	// Get the boundary flags
	switch( m_comboBoundary.GetCurSel() )
	{
	case 0:
		m_dwSegmentFlags |= DMUS_SEGF_DEFAULT;
		break;
	case 1:
		// Do nothing
		//m_dwSegmentFlags |= 0;
		break;
	case 2:
		m_dwSegmentFlags |= DMUS_SEGF_GRID;
		break;
	case 3:
		m_dwSegmentFlags |= DMUS_SEGF_BEAT;
		break;
	case 4:
		m_dwSegmentFlags |= DMUS_SEGF_MEASURE;
		break;
	case 5:
		m_dwSegmentFlags |= DMUS_SEGF_ALIGN | DMUS_SEGF_BEAT;
		break;
	case 6:
		m_dwSegmentFlags |= DMUS_SEGF_ALIGN | DMUS_SEGF_MEASURE;
		break;
	case 7:
		m_dwSegmentFlags |= DMUS_SEGF_ALIGN | DMUS_SEGF_SEGMENTEND;
		break;
	case 8:
		m_dwSegmentFlags |= DMUS_SEGF_SEGMENTEND;
		break;
	case 9:
		m_dwSegmentFlags |= DMUS_SEGF_QUEUE;
		break;
	default:
		break;
	}

	// Get default alignment flags
	if( m_dwSegmentFlags & DMUS_SEGF_ALIGN )
	{
		// Check radio buttons for 'Switch' points
		if( m_radioSwitchAnyTime.GetCheck() )
		{
			m_dwSegmentFlags |= DMUS_SEGF_VALID_START_TICK;
		}
		else if( m_radioSwitchAnyGrid.GetCheck() )
		{
			m_dwSegmentFlags |= DMUS_SEGF_VALID_START_GRID;
		}
		else if( m_radioSwitchAnyBeat.GetCheck() )
		{
			m_dwSegmentFlags |= DMUS_SEGF_VALID_START_BEAT;
		}
		else if( m_radioSwitchAnyBar.GetCheck() )
		{
			m_dwSegmentFlags |= DMUS_SEGF_VALID_START_MEASURE;
		}
	}

	CDialog::OnOK();
}

void DlgSecondaryStart::OnCheckBoundary() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( IsDlgButtonChecked( IDC_CHECK_BOUNDARY ) )
	{
		m_dwSegmentFlags |= DMUS_SEGF_MARKER;
	}
	else
	{
		m_dwSegmentFlags &= ~DMUS_SEGF_MARKER;
	}

	m_staticNoMarkers.ShowWindow( IsDlgButtonChecked( IDC_CHECK_BOUNDARY ) ? SW_SHOW : SW_HIDE );
}

void DlgSecondaryStart::OnSelchangeComboBoundary() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Get the boundary flags
	const int nSel = m_comboBoundary.GetCurSel();
	switch( nSel )
	{
	case 5:		// "Align to Beat"
	case 6:		// "Align to Bar"
	case 7:		// "Align to Segment"
		// Enable controls that set set switch points
		m_staticAlignPrompt.EnableWindow( TRUE );
		m_radioSwitchAnyBeat.EnableWindow( TRUE );
		m_radioSwitchAnyBar.EnableWindow( TRUE );
		m_radioSwitchAnyTime.EnableWindow( TRUE );
		m_radioSwitchAnyGrid.EnableWindow( TRUE );

		// Make sure one of the buttons is checked
		if( !m_radioSwitchAnyTime.GetCheck() 
		&&  !m_radioSwitchAnyGrid.GetCheck() 
		&&  !m_radioSwitchAnyBeat.GetCheck()
		&&  !m_radioSwitchAnyBar.GetCheck() )
		{
			m_radioSwitchAnyTime.SetCheck( BST_CHECKED );
		}
		break;

	default:
		// Disable controls that set set switch points
		m_staticAlignPrompt.EnableWindow( FALSE );
		m_radioSwitchAnyTime.SetCheck( 0 );
		m_radioSwitchAnyTime.EnableWindow( FALSE );
		m_radioSwitchAnyGrid.SetCheck( 0 );
		m_radioSwitchAnyGrid.EnableWindow( FALSE );
		m_radioSwitchAnyBeat.SetCheck( 0 );
		m_radioSwitchAnyBeat.EnableWindow( FALSE );
		m_radioSwitchAnyBar.SetCheck( 0 );
		m_radioSwitchAnyBar.EnableWindow( FALSE );
		break;
	}

	if( ((nSel >= 5) && (nSel <= 7))
	||	(nSel == 9) )
	{
		// Disable the 'Start at next Marker' checkbox
		m_checkBoundary.SetCheck( BST_UNCHECKED );
		m_staticNoMarkers.ShowWindow( SW_HIDE );
		m_checkBoundary.EnableWindow( FALSE );

	}
	else
	{
		// Enable the 'Start at next Marker' checkbox
		m_checkBoundary.SetCheck( (m_dwSegmentFlags & DMUS_SEGF_MARKER) ? BST_CHECKED : BST_UNCHECKED );
		m_staticNoMarkers.ShowWindow( (m_dwSegmentFlags & DMUS_SEGF_MARKER) ? SW_SHOW : SW_HIDE );
		m_checkBoundary.EnableWindow( TRUE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgMIDI.h ===
#if !defined(AFX_DLGMIDI_H__07F96B02_35F9_11D2_8900_00C04FBF8D15__INCLUDED_)
#define AFX_DLGMIDI_H__07F96B02_35F9_11D2_8900_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// DlgMIDI.h : header file
//

#include "resource.h"
#include "OutputTool.h"

//#define USE_LATENCY_HELPTEXT 1

/////////////////////////////////////////////////////////////////////////////
// CROEdit window

/*
class CROEdit : public CEdit
{
// Construction
public:
	CROEdit();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CROEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CROEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CROEdit)
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};
*/

/////////////////////////////////////////////////////////////////////////////
// MIDI / synth options dialog

class DlgMIDI : public CDialog
{
// Construction
public:
	DlgMIDI(CWnd* pParent = NULL);	 // standard constructor

// Dialog Data
	//{{AFX_DATA(DlgMIDI)
	enum { IDD = IDD_SETUP_MIDI };
	CEdit	m_editOther;
	CComboBox	m_comboLowLatDevice;
	CComboBox	m_comboDefaultSynth;
	CEdit	m_editVoices;
	CSpinButtonCtrl	m_spinVoices;
	CEdit	m_editLatency;
	CSpinButtonCtrl	m_spinLatency;
	CButton	m_btnEchoMidi;
	CComboBox	m_comboEchoInput;
	CSpinButtonCtrl	m_spinEchoPChannels;
	CComboBox	m_comboInput;
	//}}AFX_DATA

	//CEdit	m_editEchoPChannels;
	CEdit			m_editEchoPChannels;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DlgMIDI)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(DlgMIDI)
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnDeltaposSpinEchoPchannels(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	afx_msg void OnKillfocusEditEchoPchannels();
	afx_msg void OnSelchangeComboEchoInput();
	afx_msg void OnButtonLatencyDefault();
	afx_msg void OnCheckLowLatency();
	afx_msg void OnSelchangeComboLowLatDevice();
	afx_msg void OnSelchangeDefaultSynth();
	afx_msg void On1122444896();
	afx_msg void OnOther();
	afx_msg void OnEchoAdvanced();
	//}}AFX_MSG
#ifdef USE_LATENCY_HELPTEXT
	afx_msg void OnChangeEditLatency();
#endif // USE_LATENCY_HELPTEXT
	DECLARE_MESSAGE_MAP()

protected:
	void UpdatePChannelEdit( int nBlock );
	void DisplayPortCreationError( HRESULT hr, CComboBox &comboBox );
	void EnableDlgItem( int nID, bool fEnable );
	bool IsDlgItemEnabled( int nID );
	void RestrictFrequencyRange( const DWORD dwLowFreq, const DWORD dwHighFreq );

#ifdef USE_LATENCY_HELPTEXT
	void UpdateLatencyText( void );

	DWORD	m_dwBaseLatency;
	bool	m_fOrigUsePhoneyDSound;
#endif // USE_LATENCY_HELPTEXT

	int		m_nInitialMIDIInIndex;
	int		m_nInitialEchoMIDIInIndex;

public:
	DWORD	m_dwLatency;
	bool	m_fLatencyAppliesToAllAudioPaths;

	DWORD	m_dwSampleRate;
	DWORD	m_dwOtherSampleRate;
	DWORD	m_dwVoices;
	CLSID	m_clsidDefaultSynth;

	bool	m_fUsePhoneyDSound;
	TCHAR	m_strPhoneyFilterName[MAX_PATH];

	bool	m_fDownloadGM;
	bool	m_fDownloadDLS;

	int		m_anCurrentBlock[ECHO_ADVANCED_PORTS];
	GUID	m_aguidEchoMIDIInPort[ECHO_ADVANCED_PORTS];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGMIDI_H__07F96B02_35F9_11D2_8900_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\dlgmidi.cpp ===
// DlgMIDI.cpp : implementation file
//

#include "stdafx.h"
#include "directks.h"

#include "DlgMIDI.h"
#include "cconduct.h"
#include <mmsystem.h>
#include "Toolbar.h"
#include "OutputTool.h"
#include "dslink.h"
#include "audiosink.h"
#include "DlgEchoAdvanced.h"
#ifdef USE_LATENCY_HELPTEXT
#include <dmksctrl.h>
#endif // USE_LATENCY_HELPTEXT
#include <initguid.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CMIDIInputContainer* g_pMIDIInputContainer;
extern bool g_fKslInitialized;
#ifdef _DEBUG
extern LogClass g_publicLogClass;
#endif

struct LowLatencyPortItem
{
	char *szFilterName;
	DWORD dwMinimumSampleFrequency;
	DWORD dwMaximumSampleFrequency;
};

static s_dwLastRealDefaultLatency = LATENCY_UNSUPPORTED;
#ifdef USE_LATENCY_HELPTEXT
static s_dwLastPhoneyBaseLatency = LATENCY_UNSUPPORTED;
static s_dwLastRealBaseLatency = LATENCY_UNSUPPORTED;

REFERENCE_TIME SampleLatency( IDirectMusicPort *pIDMOutputPort, IDirectMusicPerformance *pDMPerformance );

DWORD DialogSampleLatency( bool fUsePhoneyDSound )
{
	IDirectMusicAudioPath *pDMAudiopath = g_pconductor->m_pDMAudiopath;
	IDirectMusicPerformance *pDMPerformance = g_pconductor->m_pDMPerformance;

	if( !pDMPerformance
	||	!pDMAudiopath )
	{
		return 0;
	}

	DWORD dwSampledLatency = 0;

	IDirectMusicPort *pDMPort = NULL;
	DWORD dwIndex = 0;
	while( S_OK == pDMAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void **)&pDMPort ) )
	{
		// Verify we have a valid port pointer
		ASSERT( pDMPort );

		IKsControl *pIKsControl;
		HRESULT hr = pDMPort->QueryInterface(IID_IKsControl, (void**)&pIKsControl);
		if (SUCCEEDED(hr)) 
		{
			KSPROPERTY ksp;
			ULONG cb;
			DWORD dwLatency;

			// Get the latency
			ZeroMemory(&ksp, sizeof(ksp));
			ksp.Set   = GUID_DMUS_PROP_WriteLatency;
			ksp.Id    = 0;
			ksp.Flags = KSPROPERTY_TYPE_GET;

			if( SUCCEEDED( pIKsControl->KsProperty(&ksp,
								 sizeof(ksp),
								 (LPVOID)&dwLatency,
								 sizeof(dwLatency),
								 &cb) ) )
			{
				DWORD dwLatency = DWORD((5000 + SampleLatency( pDMPort, pDMPerformance)) / 10000);
				dwSampledLatency = max( dwSampledLatency, dwLatency );
			}

			pIKsControl->Release();
		}

		// Release the port
		pDMPort->Release();

		// Go on to the next port in the audio path
		dwIndex++;
	}

	if( fUsePhoneyDSound )
	{
		if( S_OK == pDMAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, CLSID_DirectMusicSynth, 0, IID_IDirectMusicPort, (void **)&pDMPort ) )
		{
			DWORD dwLatency = DWORD((5000 + SampleLatency( pDMPort, pDMPerformance)) / 10000);
			dwSampledLatency = max( dwSampledLatency, dwLatency );

			// Release the port
			pDMPort->Release();
		}
	}
	return dwSampledLatency;
}
#endif // USE_LATENCY_HELPTEXT

/////////////////////////////////////////////////////////////////////////////
// CROEdit

/*
CROEdit::CROEdit()
{
}

CROEdit::~CROEdit()
{
}


BEGIN_MESSAGE_MAP(CROEdit, CEdit)
	//{{AFX_MSG_MAP(CROEdit)
	ON_WM_CTLCOLOR_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define MY_BACKGROUND_COLOR ::GetSysColor( COLOR_WINDOW )
/////////////////////////////////////////////////////////////////////////////
// CROEdit message handlers

HBRUSH CROEdit::CtlColor(CDC* pDC, UINT nCtlColor) 
{
	UNREFERENCED_PARAMETER(nCtlColor);
	if( ::IsWindowEnabled( this->m_hWnd ) )
	{
		// TODO: Change any attributes of the DC here
		pDC->SetBkColor( MY_BACKGROUND_COLOR );

		// TODO: Return a non-NULL brush if the parent's handler should not be called
		LOGBRUSH lb;
		lb.lbColor = MY_BACKGROUND_COLOR;
		lb.lbHatch = 0;
		lb.lbStyle = BS_SOLID;
		return ::CreateBrushIndirect( &lb );
	}
	else
	{
		return NULL;
	}
}
*/

/////////////////////////////////////////////////////////////////////////////
// DlgMIDI dialog


DlgMIDI::DlgMIDI(CWnd* pParent /*=NULL*/)
	: CDialog(DlgMIDI::IDD, pParent)
{
	//{{AFX_DATA_INIT(DlgMIDI)
	//}}AFX_DATA_INIT

	m_nInitialMIDIInIndex = -1;
	m_nInitialEchoMIDIInIndex = -1;

	if( g_pMIDIInputContainer )
	{
		for( int i=0; i<ECHO_ADVANCED_PORTS; i++ )
		{
			m_anCurrentBlock[i] = g_pMIDIInputContainer->m_aMIDIInputContainer[i+1].m_dwPChannelBase / 16;
			m_aguidEchoMIDIInPort[i] = g_pMIDIInputContainer->m_aMIDIInputContainer[i+1].m_guidPort;
		}
	}
	else
	{
		ZeroMemory( m_anCurrentBlock, sizeof(int) * ECHO_ADVANCED_PORTS );
		ZeroMemory( m_aguidEchoMIDIInPort, sizeof(GUID) * ECHO_ADVANCED_PORTS );
	}

	m_dwLatency = 0;
#ifdef USE_LATENCY_HELPTEXT
	m_dwBaseLatency = 0;
#endif // USE_LATENCY_HELPTEXT
	m_fLatencyAppliesToAllAudioPaths = FALSE;

#ifndef DMP_XBOX
	m_dwSampleRate = 22050;
#else
	m_dwSampleRate = 48000;
#endif
	m_dwOtherSampleRate = 22050;
	m_dwVoices = 64;
	m_clsidDefaultSynth = GUID_Synth_Default;

#ifndef DMP_XBOX
	m_fDownloadGM = true;
#else
	m_fDownloadGM = false;
#endif
	m_fDownloadDLS = true;

	m_fUsePhoneyDSound = false;
#ifdef USE_LATENCY_HELPTEXT
	m_fOrigUsePhoneyDSound = false;
#endif // USE_LATENCY_HELPTEXT
	ZeroMemory( m_strPhoneyFilterName, sizeof( TCHAR ) * MAX_PATH );
}


void DlgMIDI::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DlgMIDI)
	DDX_Control(pDX, IDC_EDIT_OTHER, m_editOther);
	DDX_Control(pDX, IDC_COMBO_LOW_LAT_DEVICE, m_comboLowLatDevice);
	DDX_Control(pDX, IDC_DEFAULT_SYNTH, m_comboDefaultSynth);
	DDX_Control(pDX, IDC_EDIT_VOICES, m_editVoices);
	DDX_Control(pDX, IDC_SPIN_VOICES, m_spinVoices);
	DDX_Control(pDX, IDC_EDIT_LATENCY, m_editLatency);
	DDX_Control(pDX, IDC_SPIN_LATENCY, m_spinLatency);
	DDX_Control(pDX, IDC_CHECK_ECHO_MIDI, m_btnEchoMidi);
	DDX_Control(pDX, IDC_COMBO_ECHO_INPUT, m_comboEchoInput);
	DDX_Control(pDX, IDC_SPIN_ECHO_PCHANNELS, m_spinEchoPChannels);
	DDX_Control(pDX, IDC_MIDI_INPUT, m_comboInput);
	DDX_Control(pDX, IDC_EDIT_ECHO_PCHANNELS, m_editEchoPChannels);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DlgMIDI, CDialog)
	//{{AFX_MSG_MAP(DlgMIDI)
	ON_WM_DESTROY()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_ECHO_PCHANNELS, OnDeltaposSpinEchoPchannels)
	ON_EN_KILLFOCUS(IDC_EDIT_ECHO_PCHANNELS, OnKillfocusEditEchoPchannels)
	ON_CBN_SELCHANGE(IDC_COMBO_ECHO_INPUT, OnSelchangeComboEchoInput)
	ON_BN_CLICKED(IDC_BUTTON_LATENCY_DEFAULT, OnButtonLatencyDefault)
	ON_BN_CLICKED(IDC_CHECK_LOW_LATENCY, OnCheckLowLatency)
	ON_CBN_SELCHANGE(IDC_COMBO_LOW_LAT_DEVICE, OnSelchangeComboLowLatDevice)
	ON_CBN_SELCHANGE(IDC_DEFAULT_SYNTH, OnSelchangeDefaultSynth)
	ON_BN_CLICKED(IDC_11, On1122444896)
	ON_BN_CLICKED(IDC_OTHER, OnOther)
	ON_BN_CLICKED(IDC_22, On1122444896)
	ON_BN_CLICKED(IDC_44, On1122444896)
	ON_BN_CLICKED(IDC_48, On1122444896)
	ON_BN_CLICKED(IDC_96, On1122444896)
	ON_BN_CLICKED(IDC_ECHO_ADVANCED, OnEchoAdvanced)
	//}}AFX_MSG_MAP
#ifdef USE_LATENCY_HELPTEXT
	ON_EN_CHANGE(IDC_EDIT_LATENCY, OnChangeEditLatency)
#endif // USE_LATENCY_HELPTEXT
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DlgMIDI message handlers

BOOL DlgMIDI::OnInitDialog() 
{
	CDialog::OnInitDialog();

	if ( m_comboInput.GetSafeHwnd() != NULL )
	{
		bool fFoundMIDIInput = false;
		bool fFoundEchoInput = false;
		bool fFoundDefaultOutput = false;
#ifdef USE_LATENCY_HELPTEXT
		m_fOrigUsePhoneyDSound = m_fUsePhoneyDSound;
#endif // USE_LATENCY_HELPTEXT

		// Initialize the port structures
		GUID guidInputPortGUID;
		ZeroMemory( &guidInputPortGUID, sizeof(GUID) );

		// If there is a DirectMusic MIDI In port, get its GUID
		if( g_pMIDIInputContainer
		&&	g_pMIDIInputContainer->m_aMIDIInputContainer[0].m_pPortContainer
		&&	g_pMIDIInputContainer->m_aMIDIInputContainer[0].m_pPortContainer->m_pPort )
		{
			guidInputPortGUID = g_pMIDIInputContainer->m_aMIDIInputContainer[0].m_guidPort;
		}

		// Loop through all available DMusic ports
		HRESULT	hr;
		DWORD dwDMIndex;
		DMUS_PORTCAPS dmpc;
		for( dwDMIndex = 0; ; dwDMIndex++ )
		{
			// Initialize the PORTCAPS structure
			ZeroMemory(&dmpc, sizeof(dmpc));
			dmpc.dwSize = sizeof(DMUS_PORTCAPS);

			// Enumerate the next port
			hr = g_pconductor->m_pDMusic->EnumPort( dwDMIndex, &dmpc );
			if(SUCCEEDED(hr) && hr != S_FALSE)
			{
				if( dmpc.dwClass == DMUS_PC_INPUTCLASS )
				{
					// Found an input port - add it to the combo box

					// Create a GUID to save this port's GUID
					GUID *pGuid;
					pGuid = new GUID;
					ASSERT( pGuid );
					CopyMemory( pGuid, &dmpc.guidPort, sizeof(GUID) );

					//TRACE("Adding %S %x\n", dmpc.wszDescription, dmpc.guidPort.Data1 );

					// Point the combo box item's data ptr at the port's GUID
					CString strDesc = dmpc.wszDescription;
					DWORD dwComboIndex = m_comboInput.AddString( strDesc );
					m_comboInput.SetItemDataPtr( dwComboIndex, (void *)pGuid );

					// If we found the currently selected port, select it
					if ( ::IsEqualGUID( guidInputPortGUID, dmpc.guidPort ) )
					{
						fFoundMIDIInput = true;
						m_comboInput.SetCurSel( dwComboIndex );
					}

					// Add the item to the Echo input combo box
					dwComboIndex = m_comboEchoInput.AddString( strDesc );
					m_comboEchoInput.SetItemDataPtr( dwComboIndex, (void *)pGuid );

					// If we found the currently selected port, select it
					if ( ::IsEqualGUID( g_pMIDIInputContainer->m_aMIDIInputContainer[1].m_guidPort, dmpc.guidPort ) )
					{
						fFoundEchoInput = true;
						m_comboEchoInput.SetCurSel( dwComboIndex );
					}
				}
				else if( dmpc.dwClass == DMUS_PC_OUTPUTCLASS )
				{
					// Found an output port - add it to the combo box

					// Create a GUID to save this port's GUID
					GUID *pGuid;
					pGuid = new GUID;
					ASSERT( pGuid );
					CopyMemory( pGuid, &dmpc.guidPort, sizeof(GUID) );

					//TRACE("Adding %S %x\n", dmpc.wszDescription, dmpc.guidPort.Data1 );

					// Point the combo box item's data ptr at the port's GUID
					CString strDesc = dmpc.wszDescription;
					DWORD dwComboIndex = m_comboDefaultSynth.AddString( strDesc );
					m_comboDefaultSynth.SetItemDataPtr( dwComboIndex, (void *)pGuid );

					// If we found the currently selected port, select it
					if ( ::IsEqualGUID( m_clsidDefaultSynth, dmpc.guidPort ) )
					{
						fFoundDefaultOutput = true;
						m_comboDefaultSynth.SetCurSel( dwComboIndex );
					}
				}
			}
			else
			{
				break;
			}
		}

		// Add a 'none' option - it has the data UINT_MAX
		CString strNoMIDI;
		strNoMIDI.LoadString( IDS_NO_MIDI_INPUT );

		// Add the 'none' option to the MIDI input box
		DWORD	dwComboIndex;
		dwComboIndex = m_comboInput.InsertString( 0, strNoMIDI );
		m_comboInput.SetItemData( dwComboIndex, UINT_MAX );
		m_comboInput.SetItemDataPtr( dwComboIndex, (void *)UINT_MAX );

		// By default, select 'None'
		if( !fFoundMIDIInput )
		{
			m_comboInput.SetCurSel(dwComboIndex);
		}

		// Add the 'none' option to the Echo MIDI input box
		dwComboIndex = m_comboEchoInput.InsertString( 0, strNoMIDI );
		m_comboEchoInput.SetItemData( dwComboIndex, UINT_MAX );
		m_comboEchoInput.SetItemDataPtr( dwComboIndex, (void *)UINT_MAX );

		// By default, select 'None'
		if( !fFoundEchoInput )
		{
			m_comboEchoInput.SetCurSel(dwComboIndex);
		}


		// Add the 'none' option to the Default Synth box
		strNoMIDI.LoadString( IDS_NO_DEFAULT_SYNTH );
		dwComboIndex = m_comboDefaultSynth.InsertString( 0, strNoMIDI );
		m_comboDefaultSynth.SetItemData( dwComboIndex, UINT_MAX );
		m_comboDefaultSynth.SetItemDataPtr( dwComboIndex, (void *)UINT_MAX );

		// By default, select 'None'
		if( !fFoundDefaultOutput )
		{
			m_comboDefaultSynth.SetCurSel(dwComboIndex);
		}


		// Save the initial MIDI input settings
		m_nInitialMIDIInIndex = m_comboInput.GetCurSel();
		m_nInitialEchoMIDIInIndex = m_comboEchoInput.GetCurSel();


		// Set the Enable/Disable checkbox correctly
		/*
		int iCurSel = m_comboEchoInput.GetCurSel();
		if( (iCurSel == -1)
		||	(m_comboEchoInput.GetItemDataPtr( iCurSel ) == (void *)UINT_MAX) )
		{
			m_btnEchoMidi.EnableWindow( FALSE );
			m_btnEchoMidi.SetCheck( 0 );
		}
		else
		*/
		{
			m_btnEchoMidi.EnableWindow( TRUE );
			m_btnEchoMidi.PostMessage( BM_SETCHECK, g_pMIDIInputContainer->m_fWantToEcho ? 1 : 0, 0 );
		}

		m_spinEchoPChannels.SetRange( 0, 250 );
		UpdatePChannelEdit( g_pMIDIInputContainer->m_aMIDIInputContainer[1].m_dwPChannelBase / 16 );

		// Set the latency settings
		if( m_fUsePhoneyDSound
		||	(g_pconductor->m_dwDefaultLatency != LATENCY_UNSUPPORTED) )
		{
			m_spinLatency.SetRange( 0, 9999 );
			m_editLatency.SetLimitText( 4 );
			m_spinLatency.SetPos( m_dwLatency );
			SetDlgItemInt( IDC_EDIT_LATENCY, m_dwLatency, FALSE );
			CheckDlgButton( IDC_CHECK_LATENCY_PERSIST, m_fLatencyAppliesToAllAudioPaths ? BST_CHECKED : BST_UNCHECKED );

			if( !m_fUsePhoneyDSound )
			{
				s_dwLastRealDefaultLatency = g_pconductor->m_dwDefaultLatency;
			}

#ifdef USE_LATENCY_HELPTEXT
			m_dwBaseLatency = DialogSampleLatency( m_fOrigUsePhoneyDSound ) - m_dwLatency;

			if( m_fOrigUsePhoneyDSound )
			{
				s_dwLastPhoneyBaseLatency = m_dwBaseLatency;
			}
			else
			{
				s_dwLastRealBaseLatency = m_dwBaseLatency;
			}

			UpdateLatencyText();
#endif // USE_LATENCY_HELPTEXT
		}
		else
		{
			// Latency is unsupported - disable the controls
			m_spinLatency.EnableWindow( FALSE );
			m_editLatency.EnableWindow( FALSE );
			EnableDlgItem( IDC_CHECK_LATENCY_PERSIST, false );
			EnableDlgItem( IDC_BUTTON_LATENCY_DEFAULT, false );
		}

		// Set the voices settings
		m_spinVoices.SetRange( 1, 999 );
		m_editVoices.SetLimitText( 3 );
		m_spinVoices.SetPos( m_dwVoices );
		SetDlgItemInt( IDC_EDIT_VOICES, m_dwVoices, FALSE );

		// Set the sample rate setting
		int nRadioButton = IDC_OTHER;
		switch( m_dwSampleRate )
		{
		case 11025:
			nRadioButton = IDC_11;
			break;
		case 22050:
			nRadioButton = IDC_22;
			break;
		case 44100:
			nRadioButton = IDC_44;
			break;
		case 48000:
			nRadioButton = IDC_48;
			break;
		case 96000:
			nRadioButton = IDC_96;
			break;
		default:
			m_dwOtherSampleRate = m_dwSampleRate;
			break;
		}
		CheckRadioButton( IDC_11, IDC_OTHER, nRadioButton );
		m_editOther.EnableWindow( nRadioButton == IDC_OTHER );

		m_editOther.SetLimitText( 5 );
		SetDlgItemInt( IDC_EDIT_OTHER, m_dwOtherSampleRate, FALSE );

		CheckRadioButton( IDC_RADIO_GM_DOWNLOAD, IDC_RADIO_GM_UNLOAD, m_fDownloadGM ? IDC_RADIO_GM_DOWNLOAD : IDC_RADIO_GM_UNLOAD );
		CheckRadioButton( IDC_RADIO_DLS_DOWNLOAD, IDC_RADIO_DLS_UNLOAD, m_fDownloadDLS ? IDC_RADIO_DLS_DOWNLOAD : IDC_RADIO_DLS_UNLOAD );

		// Get list of devices that support WDM audio
		if( !g_fKslInitialized  )
		{
#ifdef _DEBUG
			KslRegisterLog( &g_publicLogClass );
#endif
			KslInitKsLib();
			g_fKslInitialized = true;
		}

		WAVEFORMATEX wFormatEx;
		wFormatEx.wFormatTag = WAVE_FORMAT_PCM;
		wFormatEx.nChannels = (USHORT)2;
		wFormatEx.nSamplesPerSec = 22050;
		wFormatEx.nAvgBytesPerSec = 22050*2*16/8;
		wFormatEx.wBitsPerSample = (USHORT)16;
		wFormatEx.nBlockAlign = (USHORT)(2*16/8);
		wFormatEx.cbSize = 0;

		m_comboLowLatDevice.SetCurSel( -1 );

		bool fFoundFilter = false;

		CList<CKsFilter> lstFilters;
		GUID *pGuid = new GUID;
		*pGuid = KSCATEGORY_AUDIO_DEVICE;
		KslEnumFilters( &lstFilters, ePCMAudio, &pGuid, 1, TRUE, TRUE, FALSE );
		CNode<CKsFilter> *pNode = lstFilters.GetHead();
		while( pNode )
		{
			CKsFilter *pCKsFilter = (CKsFilter *)pNode->pData;

			CPCMAudioFilter PCMAudioFilter( pCKsFilter->m_szFilterName, pCKsFilter->m_szFriendlyName, pCKsFilter->m_szCLSID, pCKsFilter->m_szService, pCKsFilter->m_szBinary );
			CPCMAudioPin *pCPCMAudioPin = PCMAudioFilter.FindViablePin( &(pCKsFilter->m_listRenderSinkPins), &wFormatEx );
			if( pCPCMAudioPin )
			{
				pCPCMAudioPin->SetFormat( &wFormatEx );
				if( pCPCMAudioPin->Instantiate( TRUE ) )
				{
					pCPCMAudioPin->ClosePin();
					int nIndex = m_comboLowLatDevice.AddString( pCKsFilter->m_szFriendlyName );

					LowLatencyPortItem *pLowLatencyPortItem = new LowLatencyPortItem;
					if( pLowLatencyPortItem )
					{
						pLowLatencyPortItem->szFilterName = _strdup( pCKsFilter->m_szFilterName );
						pLowLatencyPortItem->dwMinimumSampleFrequency = pCPCMAudioPin->m_dwMinSampleFreq;
						pLowLatencyPortItem->dwMaximumSampleFrequency = pCPCMAudioPin->m_dwMaxSampleFreq;

						m_comboLowLatDevice.SetItemDataPtr( nIndex, pLowLatencyPortItem );

						if( strcmp( m_strPhoneyFilterName, pCKsFilter->m_szFilterName ) == 0 )
						{
							m_comboLowLatDevice.SetCurSel( nIndex );
						}
						else if( !fFoundFilter && m_strPhoneyFilterName[0] == 0 )
						{
							fFoundFilter = true;
							m_comboLowLatDevice.SetCurSel( nIndex );
						}
					}
				}
			}

			pNode = lstFilters.GetNext( pNode );
		}

		pNode = lstFilters.GetHead();
		while(pNode)
		{
			if (pNode->pData)
			{
				delete pNode->pData;
			}
			pNode = lstFilters.GetNext(pNode);
		}
		lstFilters.Empty();

		delete pGuid;

		if( m_comboLowLatDevice.GetCurSel() == CB_ERR )
		{
			m_comboLowLatDevice.SetCurSel( 0 );
		}

		if( m_comboLowLatDevice.GetCount() == 0 )
		{
			EnableDlgItem( IDC_CHECK_LOW_LATENCY, false );
			m_comboLowLatDevice.EnableWindow( FALSE );
			m_fUsePhoneyDSound = FALSE;
		}
		else
		{
			CheckDlgButton( IDC_CHECK_LOW_LATENCY, m_fUsePhoneyDSound ? BST_CHECKED : BST_UNCHECKED );
			m_comboLowLatDevice.EnableWindow( m_fUsePhoneyDSound );
		}

#ifdef DMP_XBOX
		CString strPCAudioSettings;
		strPCAudioSettings.LoadString( IDS_PC_AUDIO_INIT_SETTINGS );
		SetDlgItemText( IDC_STATIC_AUDIO_SETTINGS, strPCAudioSettings );
#endif

		// Restrict the Sample rate buttons, if necessary
		OnSelchangeComboLowLatDevice(); // From Low-latency device
	}


	return TRUE;  // return TRUE unless you set the focus to a control
				  // EXCEPTION: OCX Property Pages should return FALSE
}

void DlgMIDI::OnDestroy() 
{
	CDialog::OnDestroy();
	
	if( m_comboDefaultSynth.GetSafeHwnd() != NULL )
	{
		GUID *pGuid;
		while( m_comboDefaultSynth.GetCount() > 0 )
		{
			pGuid = (GUID *) m_comboDefaultSynth.GetItemDataPtr( 0 );
			if( pGuid != (GUID *)UINT_MAX)
			{
				delete pGuid;
			}
			m_comboDefaultSynth.DeleteString( 0 );
		}
	}

	if ( m_comboInput.GetSafeHwnd() != NULL )
	{
		GUID *pGuid;
		while( m_comboInput.GetCount() > 0 )
		{
			pGuid = (GUID *) m_comboInput.GetItemDataPtr( 0 );
			if( pGuid != (GUID *)UINT_MAX)
			{
				delete pGuid;
			}
			m_comboInput.DeleteString( 0 );
		}
	}
	// Already deleted these GUIDs above (both comboboxes contain the same
	// strings and pointers to the same GUIDs).
	/*
	if ( m_comboEchoInput.GetSafeHwnd() != NULL )
	{
		while( m_comboEchoInput.GetCount() > 0 )
		{
			GUID *pGuid = (GUID *) m_comboEchoInput.GetItemDataPtr( 0 );
			if( pGuid != (GUID *)UINT_MAX)
			{
				delete pGuid;
			}
			m_comboEchoInput.DeleteString( 0 );
		}
	}
	*/

	if ( m_comboLowLatDevice.GetSafeHwnd() != NULL )
	{
		while( m_comboLowLatDevice.GetCount() > 0 )
		{
			LowLatencyPortItem *pLowLatencyPortItem = static_cast<LowLatencyPortItem *>(m_comboLowLatDevice.GetItemDataPtr( 0 ));
			if( pLowLatencyPortItem )
			{
				delete []pLowLatencyPortItem->szFilterName;
			}
			delete pLowLatencyPortItem;
			m_comboLowLatDevice.DeleteString( 0 );
		}
	}
}

void DlgMIDI::OnDeltaposSpinEchoPchannels(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	// Calculate what the block # will change to
	int nNewBlock = m_anCurrentBlock[0] + pNMUpDown->iDelta;

	// If the block number is invalid (negative), return
	if( nNewBlock < 0 )
	{
		*pResult = 1;
		return;
	}

	// Update the text in the PChannel edit box
	UpdatePChannelEdit( nNewBlock );

	*pResult = 1;
}

void DlgMIDI::OnOK() 
{
	if (m_comboInput.GetSafeHwnd() == NULL)
	{
		CDialog::OnOK();
	}

	// Get the index of the currently selected item
	BOOL fContinue = TRUE;
	int index = m_comboInput.GetCurSel();
	if (index == CB_ERR)
	{
		// Error getting index of selected item - perhaps nothing's selected?
		ASSERT( FALSE );
		// Unexpected error, might as well close the dialog box
		//fContinue = FALSE;
		DisplayPortCreationError( 0, m_comboInput );
	}
	else if( index != m_nInitialMIDIInIndex )
	{
		// Change to the hourglass cursor
		CWaitCursor cWait;
		
		GUID *pGuid;
		if( m_comboInput.GetItemDataPtr( index ) == (void *)UINT_MAX )
		{
			g_pMIDIInputContainer->SetDMusicEchoMIDIIn( 0, 0, GUID_AllZeros );
		}
		else
		{
			pGuid = (GUID *) m_comboInput.GetItemDataPtr( index );
			HRESULT hrError = E_FAIL;
			if( pGuid )
			{
				hrError = g_pMIDIInputContainer->SetDMusicEchoMIDIIn( 0, 0, *pGuid );
			}
			else
			{
				hrError = g_pMIDIInputContainer->SetDMusicEchoMIDIIn( 0, 0, GUID_AllZeros );
			}
			if( FAILED( hrError ) )
			{
				TRACE("Failed to set MIDI In.\n");
				fContinue = FALSE;
				DisplayPortCreationError( hrError, m_comboInput );
			}
			else
			{
				m_nInitialMIDIInIndex = index;
			}
		}
	}

	if( fContinue )
	{
		// Change to the hourglass cursor
		CWaitCursor cWait;

		// Get the index of the currently selected item
		index = m_comboEchoInput.GetCurSel();
		if (index == CB_ERR)
		{
			// Error getting index of selected item - perhaps nothing's selected?
			// DisplayPortCreationError( 0, m_comboEchoInput );
			// Unexpected error, might as well close the dialog box
			//fContinue = FALSE;
			ASSERT( FALSE );
		}
		else
		{
			// Get the selected port GUID
			if( m_comboEchoInput.GetItemDataPtr( index ) == (void *)UINT_MAX )
			{
				ZeroMemory( &m_aguidEchoMIDIInPort[0], sizeof(GUID) );
			}
			else
			{
				GUID *pGuid = (GUID *) m_comboEchoInput.GetItemDataPtr( index );
				memcpy( &m_aguidEchoMIDIInPort[0], pGuid, sizeof(GUID) );
			}

			// Update the echo tool
			HRESULT hrError = g_pMIDIInputContainer->EnableEchoMIDI( m_btnEchoMidi.GetCheck() );

			if( SUCCEEDED( hrError ) )
			{
				for( int i=0; i<ECHO_ADVANCED_PORTS; i++ )
				{
					// Only do the update (pass true) for the last port
					hrError = g_pMIDIInputContainer->SetDMusicEchoMIDIIn( i + 1, (unsigned)m_anCurrentBlock[i], m_aguidEchoMIDIInPort[i], (ECHO_ADVANCED_PORTS - 1) == i );
				}
			}

			if( SUCCEEDED( hrError )
			&&	g_pMIDIInputContainer->m_fWantToEcho )
			{
				g_pMIDIInputContainer->EnableEchoMIDI( FALSE );
				hrError = g_pMIDIInputContainer->EnableEchoMIDI( TRUE );
			}

			if( FAILED( hrError ) )
			{
				TRACE("Failed to set Echo MIDI Input.\n");
				fContinue = FALSE;
				DisplayPortCreationError( hrError, m_comboEchoInput );
			}
		}
	}

	if( fContinue )
	{
		if( m_fUsePhoneyDSound
		||	g_pconductor->m_dwDefaultLatency != LATENCY_UNSUPPORTED )
		{
			BOOL fTrans;
			DWORD dwLatency = GetDlgItemInt( IDC_EDIT_LATENCY, &fTrans, FALSE );
			if( !fTrans )
			{
				fContinue = FALSE;
			}
			else
			{
				m_dwLatency = dwLatency;

				m_fLatencyAppliesToAllAudioPaths = IsDlgButtonChecked( IDC_CHECK_LATENCY_PERSIST ) ? true : false;
			}
		}
	}

	if( fContinue )
	{
		BOOL fTrans;
		DWORD dwVoices = GetDlgItemInt( IDC_EDIT_VOICES, &fTrans, FALSE );
		if( !fTrans
		||	(dwVoices < 1) )
		{
			fContinue = FALSE;
			AfxMessageBox( IDS_ERR_INVALID_VOICES );
		}
		else
		{
			m_dwVoices = dwVoices;
		}
	}

	if( fContinue )
	{
		// Get the index of the currently selected item
		index = m_comboDefaultSynth.GetCurSel();
		if (index == CB_ERR)
		{
			// Error getting index of selected item - perhaps nothing's selected?
			// DisplayPortCreationError( 0, m_comboEchoInput );
			// Unexpected error, might as well close the dialog box
			//fContinue = FALSE;
			ASSERT( FALSE );
		}
		else
		{
			// Get the selected default port GUID
			if( m_comboDefaultSynth.GetItemDataPtr( index ) == (void *)UINT_MAX )
			{
				m_clsidDefaultSynth = GUID_Synth_Default;
			}
			else
			{
				GUID *pGuid = (GUID *) m_comboDefaultSynth.GetItemDataPtr( index );
				memcpy( &m_clsidDefaultSynth, pGuid, sizeof(GUID) );
			}
		}

		switch( GetCheckedRadioButton( IDC_11, IDC_OTHER ) )
		{
		case IDC_11:
			m_dwSampleRate = 11025;
			break;
		default:
		case IDC_22:
			m_dwSampleRate = 22050;
			break;
		case IDC_44:
			m_dwSampleRate = 44100;
			break;
		case IDC_48:
			m_dwSampleRate = 48000;
			break;
		case IDC_96:
			m_dwSampleRate = 96000;
			break;
		case IDC_OTHER:
			{
				BOOL fTrans;
				DWORD dwOtherSampleRate = GetDlgItemInt( IDC_EDIT_OTHER, &fTrans, FALSE );

				DWORD dwLowSampleRate = 11025;
				DWORD dwHighSampleRate = 96000;
				if( m_fUsePhoneyDSound )
				{
					int nIndex = m_comboLowLatDevice.GetCurSel();
					ASSERT( nIndex != CB_ERR );

					LowLatencyPortItem *pLowLatencyPortItem = static_cast<LowLatencyPortItem *>(m_comboLowLatDevice.GetItemDataPtr( nIndex ));
					if( pLowLatencyPortItem )
					{
						dwLowSampleRate = max( dwLowSampleRate, pLowLatencyPortItem->dwMinimumSampleFrequency );
						dwHighSampleRate = min( dwHighSampleRate, pLowLatencyPortItem->dwMaximumSampleFrequency );
					}
				}

				if( !fTrans || dwOtherSampleRate < dwLowSampleRate || dwOtherSampleRate > dwHighSampleRate )
				{
					CString strInvalidSampleRate;
					strInvalidSampleRate.FormatMessage( IDS_ERR_INVALID_SAMPLERATE, dwLowSampleRate, dwHighSampleRate );
					AfxMessageBox( strInvalidSampleRate );
					return;
				}
				m_dwSampleRate = dwOtherSampleRate;
			}
			break;
		}

		m_fDownloadGM = (GetCheckedRadioButton( IDC_RADIO_GM_DOWNLOAD, IDC_RADIO_GM_UNLOAD ) == IDC_RADIO_GM_DOWNLOAD);
		m_fDownloadDLS = (GetCheckedRadioButton( IDC_RADIO_DLS_DOWNLOAD, IDC_RADIO_DLS_UNLOAD ) == IDC_RADIO_DLS_DOWNLOAD);

		m_fUsePhoneyDSound = IsDlgButtonChecked( IDC_CHECK_LOW_LATENCY ) ? true : false;

		if( m_fUsePhoneyDSound )
		{
			int nIndex = m_comboLowLatDevice.GetCurSel();
			ASSERT( nIndex != CB_ERR );
			LowLatencyPortItem *pLowLatencyPortItem = static_cast<LowLatencyPortItem *>(m_comboLowLatDevice.GetItemDataPtr( nIndex ));
			if( pLowLatencyPortItem
			&&	pLowLatencyPortItem->szFilterName )
			{
				strcpy( m_strPhoneyFilterName, pLowLatencyPortItem->szFilterName );
			}
		}

		CDialog::OnOK();
	}
}

void DlgMIDI::OnKillfocusEditEchoPchannels() 
{
	CString strText;
	m_editEchoPChannels.GetWindowText( strText );
	
	// Strip leading and trailing spaces
	strText.TrimRight();
	strText.TrimLeft();

	// If empty set value to previous one
	if( strText.IsEmpty() )
	{
		UpdatePChannelEdit( m_anCurrentBlock[0] );
	}
	else
	{
		// Convert from text to int
		int nNewBlock;
		TCHAR *tcstrTmp;
		tcstrTmp = new TCHAR[strText.GetLength() + 1];
		tcstrTmp[0] = 0;
		if( _stscanf( strText, "%d%s", &nNewBlock, tcstrTmp ) )
		{
			// Check bounds
			if( nNewBlock < 0 )
			{
				nNewBlock = 0;
			}
			else if( nNewBlock > 999 )
			{
				nNewBlock = 999;
			}

			nNewBlock /= 16;
			UpdatePChannelEdit( nNewBlock );
		}
		else
		{
			// Invalid data - reset control with previous value
			UpdatePChannelEdit( m_anCurrentBlock[0] );
		}

		delete tcstrTmp;
	}
}

void DlgMIDI::UpdatePChannelEdit( int nBlock )
{
	// Validate the block number
	if( nBlock < 0 )
	{
		return;
	}

	// Copy it to our local variable (since the spin control doesn't store it)
	m_anCurrentBlock[0] = nBlock;

	// Compute the text to display, and then display it
	CString strText, strFormat;
	strFormat.LoadString( IDS_PCHANNEL_GROUP_FORAMT );
	strText.Format( strFormat, nBlock * 16 + 1, nBlock * 16 + 16 );
	m_editEchoPChannels.SetWindowText( strText );
}

void DlgMIDI::DisplayPortCreationError( HRESULT hr, CComboBox &comboBox )
{
	// Failed to set Conductor's MIDI input
	CString strError, strFormat;
	strFormat.LoadString( IDS_ERR_UNKNOWN_CREATE_PORT );

	CString strName;
	comboBox.GetLBText( comboBox.GetCurSel(), strName );
	strError.Format( strFormat, hr, strName );

	AfxMessageBox( strError, MB_ICONEXCLAMATION | MB_OK );
}

void DlgMIDI::OnSelchangeComboEchoInput() 
{
	/*
	// Set the Enable/Disable checkbox correctly
	int iCurSel = m_comboEchoInput.GetCurSel();
	if( (iCurSel == -1)
	||	(m_comboEchoInput.GetItemDataPtr( iCurSel ) == (void *)UINT_MAX) )
	{
		m_btnEchoMidi.EnableWindow( FALSE );
		m_btnEchoMidi.SetCheck( 0 );
	}
	else
	{
		m_btnEchoMidi.EnableWindow( TRUE );
		m_btnEchoMidi.SetCheck( g_pMIDIInputContainer->m_fWantToEcho ? 1 : 0 );
	}
	*/
}

void DlgMIDI::OnButtonLatencyDefault() 
{
	DWORD dwDefaultLatency;
	if( m_fUsePhoneyDSound )
	{
		// If we're using Phoney DSound, get the default latency directly
		dwDefaultLatency = DEFAULT_PHONEY_DS_LATENCY;
	}
	else
	{
		// Otherwise, we're not using Phoney DSound, so get the last default
		// latency value we've seen.  If we started out using real DSound, then
		// this value is the current default latency

		dwDefaultLatency = s_dwLastRealDefaultLatency;
	}

	// Only update the values if we have a valid default latency value
	if( dwDefaultLatency != LATENCY_UNSUPPORTED )
	{
		m_spinLatency.SetPos( dwDefaultLatency );
		SetDlgItemInt( IDC_EDIT_LATENCY, dwDefaultLatency, FALSE );
	}
}

void DlgMIDI::OnCheckLowLatency() 
{
	// Set m_fUsePhoneyDSound if the button is checked
	m_fUsePhoneyDSound = IsDlgButtonChecked( IDC_CHECK_LOW_LATENCY ) ? true : false;

	// Enable the combobox if m_fUsePhoneyDSound is set 
	m_comboLowLatDevice.EnableWindow( m_fUsePhoneyDSound );

	// Update the latency value
	OnButtonLatencyDefault();

	// Update the sample rate buttons
	OnSelchangeComboLowLatDevice();

#ifdef USE_LATENCY_HELPTEXT
	// Update the helper text displayed next to the latency value
	UpdateLatencyText();
#endif // USE_LATENCY_HELPTEXT
}

#ifdef USE_LATENCY_HELPTEXT
void DlgMIDI::UpdateLatencyText( void )
{
	if( m_fUsePhoneyDSound
	||	g_pconductor->m_dwDefaultLatency != LATENCY_UNSUPPORTED )
	{
		// If we're using Phoney DSound, or if we're using normal DSound
		// and the default latency is not 'Unsupported'

		CString strText1, strText2;
		BOOL fTrans;
		DWORD dwLatency = GetDlgItemInt( IDC_EDIT_LATENCY, &fTrans, FALSE );
		if( !fTrans )
		{
			dwLatency = LATENCY_UNSUPPORTED;
		}

		DWORD dwBaseLatency = LATENCY_UNSUPPORTED;
		strText2.LoadString(IDS_UNKNOWN_LATENCY);

		if( m_fOrigUsePhoneyDSound == m_fUsePhoneyDSound )
		{
			dwBaseLatency = m_dwBaseLatency;
		}
		else if( m_fUsePhoneyDSound && s_dwLastPhoneyBaseLatency )
		{
			dwBaseLatency = s_dwLastPhoneyBaseLatency;
		}
		else if( !m_fUsePhoneyDSound && s_dwLastRealBaseLatency )
		{
			dwBaseLatency = s_dwLastRealBaseLatency;
		}
		if( dwBaseLatency == LATENCY_UNSUPPORTED )
		{
			strText1.LoadString(IDS_UNKNOWN_LATENCY);
		}
		else
		{
			strText1.Format( "%d", dwBaseLatency );
		}
		if( dwLatency == LATENCY_UNSUPPORTED )
		{
			strText2.LoadString(IDS_UNKNOWN_LATENCY);
		}
		else
		{
			strText2.Format( "%d", dwBaseLatency + dwLatency );
		}

		CString strDialog;
		AfxFormatString2( strDialog, IDS_LATENCY_TEXT, strText1, strText2 );
		SetDlgItemText( IDC_STATIC_MS_CAPTION, strDialog );
	}
	else
	{
		CString strDialog;
		if( strDialog.LoadString( IDS_MS_TEXT ) )
		{
			SetDlgItemText( IDC_STATIC_MS_CAPTION, strDialog );
		}
	}
}

void DlgMIDI::OnChangeEditLatency() 
{
	UpdateLatencyText();
}
#endif // USE_LATENCY_HELPTEXT

void DlgMIDI::RestrictFrequencyRange( const DWORD dwLowFreq, const DWORD dwHighFreq )
{
	EnableDlgItem( IDC_11, dwLowFreq <= 11025 && dwHighFreq >= 11025 );
	EnableDlgItem( IDC_22, dwLowFreq <= 22050 && dwHighFreq >= 22050 );
	EnableDlgItem( IDC_44, dwLowFreq <= 44100 && dwHighFreq >= 44100 );
	EnableDlgItem( IDC_48, dwLowFreq <= 48000 && dwHighFreq >= 48000 );
	EnableDlgItem( IDC_96, dwLowFreq <= 96000 && dwHighFreq >= 96000 );

	// Ensure that an enabled radio button is checked
	int nID = GetCheckedRadioButton( IDC_11, IDC_OTHER );

	// First, try and lower the frequency
	while( !IsDlgItemEnabled( nID ) && (nID > IDC_11) )
	{
		nID--;
	}

	// Then try and raise the frequency
	while( !IsDlgItemEnabled( nID ) && (nID < IDC_96) )
	{
		nID++;
	}

	CheckRadioButton( IDC_11, IDC_OTHER, nID );
}

void DlgMIDI::OnSelchangeComboLowLatDevice() 
{
	// Restrict range based on synth
	OnSelchangeDefaultSynth();

	if( m_fUsePhoneyDSound )
	{
		int nIndex = m_comboLowLatDevice.GetCurSel();
		if( nIndex != CB_ERR )
		{
			LowLatencyPortItem *pLowLatencyPortItem = static_cast<LowLatencyPortItem *>(m_comboLowLatDevice.GetItemDataPtr( nIndex ));
			if( pLowLatencyPortItem )
			{
				RestrictFrequencyRange( pLowLatencyPortItem->dwMinimumSampleFrequency, pLowLatencyPortItem->dwMaximumSampleFrequency );
			}
		}
	}
}

void DlgMIDI::EnableDlgItem( int nID, bool fEnable )
{
	CWnd *pWnd = GetDlgItem( nID );
	if( pWnd )
	{
		pWnd->EnableWindow( fEnable );
	}
}

bool DlgMIDI::IsDlgItemEnabled( int nID )
{
	CWnd *pWnd = GetDlgItem( nID );
	if( pWnd )
	{
		if( pWnd->IsWindowEnabled() )
		{
			return true;
		}
	}
	return false;
}

void DlgMIDI::OnSelchangeDefaultSynth() 
{
	RestrictFrequencyRange( 0, UINT_MAX );

	EnableDlgItem( IDC_OTHER, TRUE );
	m_editOther.EnableWindow( GetCheckedRadioButton( IDC_11, IDC_OTHER ) == IDC_OTHER );

	// Get the index of the currently selected item
	int index = m_comboDefaultSynth.GetCurSel();
	if (index != CB_ERR)
	{
		// Get the selected default port GUID
		if( m_comboDefaultSynth.GetItemDataPtr( index ) != (void *)UINT_MAX )
		{
			GUID *pGuid = (GUID *) m_comboDefaultSynth.GetItemDataPtr( index );
			if( *pGuid == CLSID_XboxSynth )
			{
				// DMusic's DSound sink only supports 11025, 22050, and 44100
				RestrictFrequencyRange( 11025, 44100 );

				if( GetCheckedRadioButton( IDC_11, IDC_OTHER ) == IDC_OTHER )
				{
					BOOL fTrans;
					DWORD dwOtherSampleRate = GetDlgItemInt( IDC_EDIT_OTHER, &fTrans, FALSE );

					if( !fTrans )
					{
						// If invalid value, check 22 kHz
						CheckRadioButton( IDC_11, IDC_OTHER, IDC_22 );
					}
					else if( dwOtherSampleRate < (11025+22050)/2 )
					{
						// If less than halfway to 22kHz, check 11kHz
						CheckRadioButton( IDC_11, IDC_OTHER, IDC_11 );
					}
					else if( dwOtherSampleRate < (22050+44100)/2 )
					{
						// If less than halfway to 44kHz, check 22kHz
						CheckRadioButton( IDC_11, IDC_OTHER, IDC_22 );
					}
					else
					{
						// Otherwise, check 44kHz
						CheckRadioButton( IDC_11, IDC_OTHER, IDC_44 );
					}
				}

				EnableDlgItem( IDC_OTHER, FALSE );
				m_editOther.EnableWindow( FALSE );
			}
		}
	}
}

void DlgMIDI::On1122444896() 
{
	m_editOther.EnableWindow( FALSE );
}

void DlgMIDI::OnOther() 
{
	m_editOther.EnableWindow( TRUE );
}

void DlgMIDI::OnEchoAdvanced() 
{
	DlgEchoAdvanced dlgEchoAdvanced;
	dlgEchoAdvanced.m_pDlgMIDI = this;
	int nRes = dlgEchoAdvanced.DoModal();
	if( nRes == IDOK )
	{
		// Update our Echo MIDI input options

		// Update the MIDI input port
		for( int i=0; i<m_comboEchoInput.GetCount(); i++ )
		{
			GUID guid = GUID_AllZeros;
			if( m_comboEchoInput.GetItemDataPtr( i ) != (void *)UINT_MAX )
			{
				GUID *pGuid = (GUID *) m_comboEchoInput.GetItemDataPtr( i );
				if( pGuid )
				{
					guid = *pGuid;
				}
			}

			if( m_aguidEchoMIDIInPort[0] == guid )
			{
				m_comboEchoInput.SetCurSel( i );
				break;
			}
		}

		// Update the output PChannels
		UpdatePChannelEdit( m_anCurrentBlock[0] );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgTransition.cpp ===
// DlgTransition.cpp : implementation file
//

#include "stdafx.h"
#include "cconduct.h"
#include "DlgTransition.h"
#include "Toolbar.h"
#include "TREntry.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MIN_EMB_CUSTOM_ID	100
#define MAX_EMB_CUSTOM_ID	199

/////////////////////////////////////////////////////////////////////////////
// DlgTransition dialog


DlgTransition::DlgTransition(CWnd* pParent /*=NULL*/)
	: CDialog(DlgTransition::IDD, pParent)
{
	//{{AFX_DATA_INIT(DlgTransition)
	//}}AFX_DATA_INIT
}


void DlgTransition::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DlgTransition)
	DDX_Control(pDX, IDC_CHECK_TRANS_NOTHING, m_buttonTransNothing);
	DDX_Control(pDX, IDC_RADIO_AFTER_PREPARE, m_radioAfterPrepare);
	DDX_Control(pDX, IDC_RADIO_QUICK_RESPONSE, m_radioQuickResponse);
	DDX_Control(pDX, IDC_CHECK_SEG_DEFAULT, m_buttonSegDefault);
	DDX_Control(pDX, IDC_COMBO_TRANS_SEGMENT, m_comboSegment);
	DDX_Control(pDX, IDC_STATIC_NO_MARKERS, m_staticNoMarkers);
	DDX_Control(pDX, IDC_CHECK_BOUNDARY, m_buttonBoundary);
	DDX_Control(pDX, IDC_ALIGN_OPTIONS_PROMPT, m_staticAlignPrompt);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_TIME, m_radioSwitchAnyTime);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_GRID, m_radioSwitchAnyGrid);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_BEAT, m_radioSwitchAnyBeat);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_BAR, m_radioSwitchAnyBar);
	DDX_Control(pDX, IDC_CUSTOM_PROMPT, m_staticCustomIdPrompt);
	DDX_Control(pDX, IDC_RADIO_ENTIRE_PATTERN, m_radioEntirePattern);
	DDX_Control(pDX, IDC_RADIO_ENTIRE_ADDITIONAL, m_radioEntireAdditional);
	DDX_Control(pDX, IDC_RADIO_ONE_BAR_PATTERN, m_radio1BarPattern);
	DDX_Control(pDX, IDC_RADIO_ONE_BAR_ADDITIONAL, m_radio1BarAdditional);
	DDX_Control(pDX, IDC_CUSTOM_ID_SPIN, m_spinCustomId);
	DDX_Control(pDX, IDC_CUSTOM_ID, m_editCustomId);
	DDX_Control(pDX, IDC_COMBO_PATTERN, m_comboPattern);
	DDX_Control(pDX, IDC_COMBO_BOUNDARY, m_comboBoundary);
	DDX_Control(pDX, IDC_CHECK_MODULATE, m_buttonModulate);
	DDX_Control(pDX, IDC_CHECK_LONG, m_buttonLong);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(DlgTransition, CDialog)
	//{{AFX_MSG_MAP(DlgTransition)
	ON_BN_CLICKED(IDC_CHECK_LONG, OnCheckLong)
	ON_CBN_SELCHANGE(IDC_COMBO_PATTERN, OnSelChangeComboPattern)
	ON_EN_KILLFOCUS(IDC_CUSTOM_ID, OnKillFocusCustomId)
	ON_NOTIFY(UDN_DELTAPOS, IDC_CUSTOM_ID_SPIN, OnDeltaPosCustomIdSpin)
	ON_CBN_SELCHANGE(IDC_COMBO_BOUNDARY, OnSelChangeComboBoundary)
	ON_BN_CLICKED(IDC_CHECK_BOUNDARY, OnCheckBoundary)
	ON_CBN_SELCHANGE(IDC_COMBO_TRANS_SEGMENT, OnSelchangeComboTransSegment)
	ON_BN_CLICKED(IDC_RADIO_ENTIRE_ADDITIONAL, OnRadioEntireAdditional)
	ON_BN_CLICKED(IDC_RADIO_ENTIRE_PATTERN, OnRadioEntirePattern)
	ON_BN_CLICKED(IDC_RADIO_ONE_BAR_ADDITIONAL, OnRadioOneBarAdditional)
	ON_BN_CLICKED(IDC_RADIO_ONE_BAR_PATTERN, OnRadioOneBarPattern)
	ON_BN_CLICKED(IDC_CHECK_MODULATE, OnCheckModulate)
	ON_BN_CLICKED(IDC_CHECK_SEG_DEFAULT, OnCheckSegDefault)
	ON_BN_CLICKED(IDC_CHECK_TRANS_NOTHING, OnCheckTransNothing)
	ON_BN_CLICKED(IDC_RADIO_NOINVALIDATE, OnRadioInvalidateBtn)
	ON_BN_CLICKED(IDC_RADIO_INVALIDATEPRI, OnRadioInvalidateBtn)
	ON_BN_CLICKED(IDC_RADIO_INVALIDATE, OnRadioInvalidateBtn)
	ON_BN_CLICKED(IDC_RADIO_AFTER_PREPARE, OnRadioPrepareBtn)
	ON_BN_CLICKED(IDC_RADIO_QUICK_RESPONSE, OnRadioPrepareBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// DlgTransition message handlers

void DlgTransition::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_TransitionOptions.dwBoundaryFlags = 0;
	m_TransitionOptions.wPatternType = 0;
	m_TransitionOptions.dwFlags = 0;

	if( m_buttonSegDefault.GetCheck() )
	{
		m_TransitionOptions.dwBoundaryFlags = DMUS_COMPOSEF_DEFAULT;
	}
	else
	{
		switch( m_comboBoundary.GetCurSel() )
		{
		case 0:
			m_TransitionOptions.dwBoundaryFlags = DMUS_COMPOSEF_IMMEDIATE;
			break;
		case 1:
			m_TransitionOptions.dwBoundaryFlags = DMUS_COMPOSEF_GRID;
			break;
		case 2:
			m_TransitionOptions.dwBoundaryFlags = DMUS_COMPOSEF_BEAT;
			break;
		case 3:
			m_TransitionOptions.dwBoundaryFlags = DMUS_COMPOSEF_MEASURE;
			break;
		case 4:
			m_TransitionOptions.dwBoundaryFlags = (DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_BEAT);
			break;
		case 5:
			m_TransitionOptions.dwBoundaryFlags = (DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_MEASURE);
			break;
		case 6:
			m_TransitionOptions.dwBoundaryFlags = (DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_SEGMENTEND);
			break;
		case 7:
			m_TransitionOptions.dwBoundaryFlags = DMUS_COMPOSEF_SEGMENTEND;
			break;
		case 8:
			m_TransitionOptions.dwFlags = TRANS_END_OF_SEGMENT; // End of Segment Queue
			break;
		default:
			break;
		}

		switch( GetCheckedRadioButton( IDC_RADIO_NOINVALIDATE, IDC_RADIO_INVALIDATE ) )
		{
		case IDC_RADIO_NOINVALIDATE:
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_NOINVALIDATE;
			break;
		case IDC_RADIO_INVALIDATEPRI:
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_INVALIDATE_PRI;
			break;
		case IDC_RADIO_INVALIDATE:
			// Do nothing
			break;
		}

		if( m_radioAfterPrepare.GetCheck() )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_AFTERPREPARETIME;
		}
	}

	if( !(m_TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT) )
	{
		switch( m_comboPattern.GetCurSel() )
		{
		int nCustomId;

		case 0:
			m_TransitionOptions.wPatternType = DMUS_COMMANDT_INTRO;
			break;
		case 1:
			m_TransitionOptions.wPatternType = DMUS_COMMANDT_BREAK;
			break;
		case 2:
			m_TransitionOptions.wPatternType = DMUS_COMMANDT_FILL;
			break;
		case 3:
			m_TransitionOptions.wPatternType = DMUS_COMMANDT_END;
			break;
		case 4:
			nCustomId = m_spinCustomId.GetPos();
			// If ASSERT fires, validation in control handlers is broken
			ASSERT( (nCustomId >= MIN_EMB_CUSTOM_ID)  &&  (nCustomId <= MAX_EMB_CUSTOM_ID) );
			m_TransitionOptions.wPatternType = (WORD)nCustomId;
			break;
		case 5:
			m_TransitionOptions.wPatternType = DMUS_COMMANDT_ENDANDINTRO;
			break;
		case 6:
			m_TransitionOptions.dwFlags |= TRANS_REGULAR_PATTERN;
			break;
		case 7:
			m_TransitionOptions.dwFlags |= TRANS_NO_TRANSITION;
			break;
		default:
			break;
		}
	}
	else
	{
		m_TransitionOptions.dwFlags |= TRANS_NO_TRANSITION;
	}

	// If doing a pattern transition, always set DMUS_COMPOSEF_USE_AUDIOPATH
	if( 0 == (m_TransitionOptions.dwFlags & TRANS_NO_TRANSITION) )
	{
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_USE_AUDIOPATH;
	}

	// Default to no transition segment
	m_TransitionOptions.pDMUSProdNodeSegmentTransition = NULL;

	if( !(m_TransitionOptions.dwFlags & TRANS_NO_TRANSITION) )
	{
		// Check radio buttons for 'Transition' pattern
		if( m_radioEntirePattern.GetCheck() )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_ENTIRE_TRANSITION;
		}
		else if( m_radio1BarPattern.GetCheck() )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_1BAR_TRANSITION;
		}

		if( m_buttonLong.GetCheck() )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_LONG;

			// Check radio buttons for 'Additional' pattern
			if( m_radioEntireAdditional.GetCheck() )
			{
				m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_ENTIRE_ADDITION;
			}
			else if( m_radio1BarAdditional.GetCheck() )
			{
				m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_1BAR_ADDITION;
			}
		}

		if( m_buttonModulate.GetCheck() )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_MODULATE;
		}

		if( m_buttonTransNothing.GetCheck() )
		{
			m_TransitionOptions.dwFlags |= TRANS_TO_NOTHING;
		}
	}
	else
	{
		// Check for a transition segment
		int nCurSel = m_comboSegment.GetCurSel();
		if( nCurSel != CB_ERR )
		{
			ITransportRegEntry *pDisplayedRegEntry = static_cast<ITransportRegEntry *>(m_comboSegment.GetItemDataPtr( nCurSel ));
			if( pDisplayedRegEntry != NULL )
			{
				IDMUSProdTransport*  pTmpTransport;
				IDMUSProdNode* pTmpDMUSProdNode;
				pDisplayedRegEntry->GetTransport( &pTmpTransport );
				if( SUCCEEDED( pTmpTransport->QueryInterface( IID_IDMUSProdNode, (void **)&pTmpDMUSProdNode ) ) )
				{
					IDirectMusicSegment *pTmpDirectMusicSegment;
					if( SUCCEEDED( pTmpDMUSProdNode->GetObject( CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pTmpDirectMusicSegment ) ) )
					{
						m_TransitionOptions.pDMUSProdNodeSegmentTransition = pTmpDMUSProdNode;

						pTmpDirectMusicSegment->Release();
					}

					pTmpDMUSProdNode->Release();
				}
			}
		}
	}

	if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN )
	{
		// Check radio buttons for 'Switch' points
		if( m_radioSwitchAnyTime.GetCheck() )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_VALID_START_TICK;
		}
		else if( m_radioSwitchAnyGrid.GetCheck() )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_VALID_START_GRID;
		}
		else if( m_radioSwitchAnyBeat.GetCheck() )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_VALID_START_BEAT;
		}
		else if( m_radioSwitchAnyBar.GetCheck() )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_VALID_START_MEASURE;
		}
	}

	if( m_buttonBoundary.GetCheck() )
	{
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_MARKER;
	}

	CDialog::OnOK();
}

BOOL DlgTransition::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CDialog::OnInitDialog();

	m_editCustomId.LimitText( 3 );
	m_spinCustomId.SetRange( MIN_EMB_CUSTOM_ID, MAX_EMB_CUSTOM_ID );
	
	m_TransitionOptions = g_pconductor->m_TransitionOptions;
	{
		if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_IMMEDIATE )
		{
			m_comboBoundary.SetCurSel( 0 );
		}
		else if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_GRID )
		{
			m_comboBoundary.SetCurSel( 1 );
		}
		else if( (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_BEAT)
			 && !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN) )
		{
			m_comboBoundary.SetCurSel( 2 );
		}
		else if( (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MEASURE)
			 && !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN) )
		{
			m_comboBoundary.SetCurSel( 3 );
		}
		else if( (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_BEAT)
			 &&  (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN) )
		{
			m_comboBoundary.SetCurSel( 4 );
		}
		else if( (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MEASURE)
			 &&  (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN) )
		{
			m_comboBoundary.SetCurSel( 5 );
		}
		else if( (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_SEGMENTEND)
			 &&  (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN) )
		{
			m_comboBoundary.SetCurSel( 6 );
		}
		else if( (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_SEGMENTEND)
			 && !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN) )
		{
			m_comboBoundary.SetCurSel( 7 );
		}
		else if( m_TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT )
		{
			m_comboBoundary.SetCurSel( 8 );
		}
		else if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT )
		{
			m_comboBoundary.SetCurSel( 3 );
		}
		else
		{
			// This shouldn't happen!
			ASSERT(0);
			m_comboBoundary.SetCurSel( 3 );
		}

		// Update the state of the pattern transition controls
		UpdateSegmentAndPatternTransitionControls();

		// Add the 'None' text to the Transition Segment combobox
		CString strText;
		if( strText.LoadString( IDS_NO_TRANS_SEGMENT ) )
		{
			int nIndex = m_comboSegment.AddString( strText );
			m_comboSegment.SetItemDataPtr( nIndex, NULL );

			// Default to having 'none' selected (if the segment can't be found in the loop below)
			m_comboSegment.SetCurSel( nIndex );
		}

		// Add the text for the other segments to the Transition Segment combobox
		if ( g_pconductor->m_pToolbarHandler )
		{
			IDMUSProdTransport*  pTmpTransport;
			IDMUSProdNode* pTmpDMUSProdNode;
			IDirectMusicSegment *pTmpDirectMusicSegment;
			POSITION pos = g_pconductor->m_lstITransportRegEntry.GetHeadPosition();
			while( pos )
			{
				ITransportRegEntry *pITransportRegEntry = g_pconductor->m_lstITransportRegEntry.GetNext( pos );
				pITransportRegEntry->GetTransport( &pTmpTransport );
				if( SUCCEEDED( pTmpTransport->QueryInterface( IID_IDMUSProdNode, (void **)&pTmpDMUSProdNode ) ) )
				{
					if( SUCCEEDED( pTmpDMUSProdNode->GetObject( CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pTmpDirectMusicSegment ) ) )
					{
						BSTR  bstrName;
						CString strName;
						// If the transport doens't have a name, use a default name
						if ( SUCCEEDED(	pTmpTransport->GetName( &bstrName ) ) )
						{
							strName = bstrName;
							SysFreeString( bstrName );
						}
						else
						{
							strName.LoadString( IDS_DEFAULT_TRANSPORT_NAME );
						}
						int nIndex = m_comboSegment.AddString( strName );
						m_comboSegment.SetItemDataPtr( nIndex, pITransportRegEntry );

						if( m_TransitionOptions.pDMUSProdNodeSegmentTransition == pTmpDMUSProdNode )
						{
							m_comboSegment.SetCurSel( nIndex );
						}

						pTmpDirectMusicSegment->Release();
					}

					pTmpDMUSProdNode->Release();
				}
			}
		}

		if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN )
		{
			m_staticAlignPrompt.EnableWindow( TRUE );
			m_radioSwitchAnyTime.EnableWindow( TRUE );
			m_radioSwitchAnyGrid.EnableWindow( TRUE );
			m_radioSwitchAnyBar.EnableWindow( TRUE );
			m_radioSwitchAnyBeat.EnableWindow( TRUE );

			if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_GRID )
			{
				CheckRadioButton( IDC_RADIO_SWITCH_ANY_TIME, IDC_RADIO_SWITCH_ANY_BAR, IDC_RADIO_SWITCH_ANY_GRID );
			}
			else if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_BEAT )
			{
				CheckRadioButton( IDC_RADIO_SWITCH_ANY_TIME, IDC_RADIO_SWITCH_ANY_BAR, IDC_RADIO_SWITCH_ANY_BEAT );
			}
			else if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_MEASURE )
			{
				CheckRadioButton( IDC_RADIO_SWITCH_ANY_TIME, IDC_RADIO_SWITCH_ANY_BAR, IDC_RADIO_SWITCH_ANY_BAR );
			}
			else //if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_TICK )
			{
				CheckRadioButton( IDC_RADIO_SWITCH_ANY_TIME, IDC_RADIO_SWITCH_ANY_BAR, IDC_RADIO_SWITCH_ANY_TIME );
			}
		}
		else
		{
			m_staticAlignPrompt.EnableWindow( FALSE );
			m_radioSwitchAnyTime.SetCheck( 0 );
			m_radioSwitchAnyTime.EnableWindow( FALSE );
			m_radioSwitchAnyGrid.SetCheck( 0 );
			m_radioSwitchAnyGrid.EnableWindow( FALSE );
			m_radioSwitchAnyBeat.SetCheck( 0 );
			m_radioSwitchAnyBeat.EnableWindow( FALSE );
			m_radioSwitchAnyBar.SetCheck( 0 );
			m_radioSwitchAnyBar.EnableWindow( FALSE );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void DlgTransition::OnCheckLong() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_buttonLong.GetCheck() )
	{
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_LONG | DMUS_COMPOSEF_ENTIRE_ADDITION;
		m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_1BAR_ADDITION;

		// Enable radio buttons for the 'Additional' pattern
		m_radioEntireAdditional.EnableWindow( TRUE );
		m_radioEntireAdditional.SetCheck( 1 );
		m_radio1BarAdditional.EnableWindow( TRUE );
		m_radio1BarAdditional.SetCheck( 0 );
	}
	else
	{
		m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_LONG;

		// Disable radio buttons for the 'Additional' pattern
		m_radioEntireAdditional.SetCheck( 0 );
		m_radioEntireAdditional.EnableWindow( FALSE );
		m_radio1BarAdditional.SetCheck( 0 );
		m_radio1BarAdditional.EnableWindow( FALSE );
	}
}

void DlgTransition::OnSelChangeComboPattern() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_TransitionOptions.dwFlags &= ~(TRANS_REGULAR_PATTERN | TRANS_NO_TRANSITION);
	m_TransitionOptions.wPatternType = 0;

	switch( m_comboPattern.GetCurSel() )
	{
	case 0:
		m_TransitionOptions.wPatternType = DMUS_COMMANDT_INTRO;
		break;
	case 1:
		m_TransitionOptions.wPatternType = DMUS_COMMANDT_BREAK;
		break;
	case 2:
		m_TransitionOptions.wPatternType = DMUS_COMMANDT_FILL;
		break;
	case 3:
		m_TransitionOptions.wPatternType = DMUS_COMMANDT_END;
		break;
	case 4:
		m_TransitionOptions.wPatternType = MIN_EMB_CUSTOM_ID;
		break;
	case 5:
		m_TransitionOptions.wPatternType = DMUS_COMMANDT_ENDANDINTRO;
		break;
	case 6:
		m_TransitionOptions.dwFlags |= TRANS_REGULAR_PATTERN;
		break;
	case 7:
		m_TransitionOptions.dwFlags |= TRANS_NO_TRANSITION;
		break;
	default:
		break;
	}

	// Enable/Disable the controls appropriately
	UpdateSegmentAndPatternTransitionControls();
}

void DlgTransition::OnKillFocusCustomId() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString strNewCustomId;

	m_editCustomId.GetWindowText( strNewCustomId );

	// Strip leading and trailing spaces
	strNewCustomId.TrimRight();
	strNewCustomId.TrimLeft();

	if( strNewCustomId.IsEmpty() )
	{
		m_spinCustomId.SetPos( MIN_EMB_CUSTOM_ID );
		m_TransitionOptions.wPatternType = MIN_EMB_CUSTOM_ID;
	}
	else
	{
		int nNewCustomId = _ttoi( strNewCustomId );
	
		if( nNewCustomId < MIN_EMB_CUSTOM_ID)
		{
			nNewCustomId = MIN_EMB_CUSTOM_ID;
		}
	
		if( nNewCustomId > MAX_EMB_CUSTOM_ID)
		{
			nNewCustomId = MAX_EMB_CUSTOM_ID;
		}

		m_spinCustomId.SetPos( nNewCustomId );
		m_TransitionOptions.wPatternType = WORD(nNewCustomId);
	}
}

void DlgTransition::OnDeltaPosCustomIdSpin( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nCustomId = m_spinCustomId.GetPos();

	if( HIWORD(nCustomId) == 0 )
	{
		int nNewCustomId = LOWORD(nCustomId) + pNMUpDown->iDelta;

		if( nNewCustomId < MIN_EMB_CUSTOM_ID)
		{
			nNewCustomId = MIN_EMB_CUSTOM_ID;
		}

		if( nNewCustomId > MAX_EMB_CUSTOM_ID)
		{
			nNewCustomId = MAX_EMB_CUSTOM_ID;
		}

		m_spinCustomId.SetPos( nNewCustomId );
	}
	
	*pResult = 1;
}

void DlgTransition::OnSelChangeComboBoundary() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_TransitionOptions.dwBoundaryFlags &= ~(DMUS_COMPOSEF_IMMEDIATE|DMUS_COMPOSEF_GRID|DMUS_COMPOSEF_BEAT|DMUS_COMPOSEF_MEASURE|DMUS_COMPOSEF_SEGMENTEND|DMUS_COMPOSEF_ALIGN);
	m_TransitionOptions.dwFlags &= ~TRANS_END_OF_SEGMENT;

	switch( m_comboBoundary.GetCurSel() )
	{
	case 0:
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_IMMEDIATE;
		break;
	case 1:
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_GRID;
		break;
	case 2:
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_BEAT;
		break;
	case 3:
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_MEASURE;
		break;
	case 4:
		m_TransitionOptions.dwBoundaryFlags |= (DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_BEAT);
		break;
	case 5:
		m_TransitionOptions.dwBoundaryFlags |= (DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_MEASURE);
		break;
	case 6:
		m_TransitionOptions.dwBoundaryFlags |= (DMUS_COMPOSEF_ALIGN | DMUS_COMPOSEF_SEGMENTEND);
		break;
	case 7:
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_SEGMENTEND;
		break;
	case 8:
		m_TransitionOptions.dwFlags |= TRANS_END_OF_SEGMENT | TRANS_NO_TRANSITION;
		m_TransitionOptions.dwFlags &= ~TRANS_REGULAR_PATTERN;
		m_TransitionOptions.wPatternType = 0;
		break;
	}

	// Update pattern controls
	UpdateSegmentAndPatternTransitionControls();
}

void DlgTransition::OnCheckBoundary() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_buttonBoundary.GetCheck() )
	{
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_MARKER;
	}
	else
	{
		m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_MARKER;
	}

	m_staticNoMarkers.ShowWindow( (m_buttonBoundary.GetCheck()) ? SW_SHOW : SW_HIDE );
}

void DlgTransition::OnSelchangeComboTransSegment() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	int nCurSel = m_comboSegment.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		ITransportRegEntry *pDisplayedRegEntry = static_cast<ITransportRegEntry *>(m_comboSegment.GetItemDataPtr( nCurSel ));

		if( pDisplayedRegEntry == NULL )
		{
			m_TransitionOptions.pDMUSProdNodeSegmentTransition = NULL;
		}
		else
		{
			IDMUSProdTransport*  pTmpTransport;
			IDMUSProdNode* pTmpDMUSProdNode;
			pDisplayedRegEntry->GetTransport( &pTmpTransport );
			if( SUCCEEDED( pTmpTransport->QueryInterface( IID_IDMUSProdNode, (void **)&pTmpDMUSProdNode ) ) )
			{
				IDirectMusicSegment *pTmpDirectMusicSegment;
				if( SUCCEEDED( pTmpDMUSProdNode->GetObject( CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pTmpDirectMusicSegment ) ) )
				{
					m_TransitionOptions.pDMUSProdNodeSegmentTransition = pTmpDMUSProdNode;

					pTmpDirectMusicSegment->Release();
				}

				pTmpDMUSProdNode->Release();
			}
		}

		// Enable/Disable the controls appropriately
		UpdateSegmentAndPatternTransitionControls();
	}
}

void DlgTransition::UpdateSegmentAndPatternTransitionControls( void )
{
	BOOL fEnablePatternTransition = FALSE;

	if( !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT)
	&&	(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN)
	&&	(m_TransitionOptions.dwBoundaryFlags & (DMUS_COMPOSEF_BEAT | DMUS_COMPOSEF_MEASURE)) )
	{
		m_comboSegment.EnableWindow( FALSE );

		for( int i=m_comboSegment.GetCount() - 1; i >=0; i-- )
		{
			if( m_comboSegment.GetItemDataPtr( i ) == NULL )
			{
				m_comboSegment.SetCurSel( i );
				break;
			}
		}

		m_TransitionOptions.pDMUSProdNodeSegmentTransition = NULL;
		m_TransitionOptions.wPatternType = 0;
		m_TransitionOptions.dwFlags |= TRANS_NO_TRANSITION;
		m_TransitionOptions.dwFlags &= ~TRANS_REGULAR_PATTERN;
	}
	else
	{
		m_comboSegment.EnableWindow( (m_TransitionOptions.dwFlags & (TRANS_END_OF_SEGMENT | TRANS_NO_TRANSITION)) ? TRUE : FALSE );

		if( !m_TransitionOptions.pDMUSProdNodeSegmentTransition
		&&	!(m_TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT) )
		{
			// Not using a transition segment or transition on queue boundary - enable all available settings
			fEnablePatternTransition = TRUE;
		}
	}

	//
	// Enable/Disable the custom embellishment controls and pattern combobox
	//
	if( fEnablePatternTransition
	&&	m_TransitionOptions.wPatternType >= MIN_EMB_CUSTOM_ID
	&&  m_TransitionOptions.wPatternType <= MAX_EMB_CUSTOM_ID )
	{
		// Transition uses a custom embellishment pattern
		m_staticCustomIdPrompt.EnableWindow( TRUE );
		m_editCustomId.EnableWindow( TRUE );
		m_spinCustomId.EnableWindow( TRUE );
		m_spinCustomId.SetPos( m_TransitionOptions.wPatternType );

		// Set 'Transition Pattern' combo box selection to "Custom" 
		m_comboPattern.EnableWindow( TRUE );
		m_comboPattern.SetCurSel( 4 );
	}
	else
	{		
		// Transition does not use a custom embellishment pattern
		m_spinCustomId.SetPos( MIN_EMB_CUSTOM_ID );
		m_staticCustomIdPrompt.EnableWindow( FALSE );
		m_editCustomId.EnableWindow( FALSE );
		m_spinCustomId.EnableWindow( FALSE );

		// Set 'Transition Pattern' combo box selection
		switch( m_TransitionOptions.wPatternType )
		{
		case DMUS_COMMANDT_INTRO:
			m_comboPattern.SetCurSel( 0 );
			break;
		case DMUS_COMMANDT_BREAK:
			m_comboPattern.SetCurSel( 1 );
			break;
		case DMUS_COMMANDT_FILL:
			m_comboPattern.SetCurSel( 2 );
			break;
		case DMUS_COMMANDT_END:
			m_comboPattern.SetCurSel( 3 );
			break;
		case DMUS_COMMANDT_ENDANDINTRO:
			m_comboPattern.SetCurSel( 5 );
			break;
		case DMUS_COMMANDT_GROOVE:
		default:
			if( m_TransitionOptions.dwFlags & TRANS_REGULAR_PATTERN )
			{
				m_comboPattern.SetCurSel( 6 );
			}
			else if( m_TransitionOptions.dwFlags & TRANS_NO_TRANSITION )
			{
				m_comboPattern.SetCurSel( 7 );
			}
			break;
		}

		m_comboPattern.EnableWindow( fEnablePatternTransition );
	}

	// Enable 'Segment's Default' checkbox
	m_buttonSegDefault.EnableWindow( TRUE );
	m_buttonSegDefault.SetCheck( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT ? TRUE : FALSE );

	// Enable/Disable the boundary combobox correctly
	m_comboBoundary.EnableWindow( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT ? FALSE : TRUE );

	if( !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT)
	&&	(m_TransitionOptions.dwBoundaryFlags  & DMUS_COMPOSEF_ALIGN) )
	{
		// Enable controls that set set switch points
		m_staticAlignPrompt.EnableWindow( TRUE );
		m_radioSwitchAnyTime.EnableWindow( TRUE );
		m_radioSwitchAnyGrid.EnableWindow( TRUE );
		m_radioSwitchAnyBeat.EnableWindow( TRUE );
		m_radioSwitchAnyBar.EnableWindow( TRUE );
		// Make sure one of the buttons is checked
		if( !m_radioSwitchAnyTime.GetCheck() 
		&&  !m_radioSwitchAnyGrid.GetCheck() 
		&&  !m_radioSwitchAnyBeat.GetCheck()
		&&	!m_radioSwitchAnyBar.GetCheck() )
		{
			m_radioSwitchAnyTime.SetCheck( 1 );
		}
	}
	else
	{
		// Disable controls that set set switch points
		m_staticAlignPrompt.EnableWindow( FALSE );
		m_radioSwitchAnyTime.SetCheck( 0 );
		m_radioSwitchAnyTime.EnableWindow( FALSE );
		m_radioSwitchAnyGrid.SetCheck( 0 );
		m_radioSwitchAnyGrid.EnableWindow( FALSE );
		m_radioSwitchAnyBeat.SetCheck( 0 );
		m_radioSwitchAnyBeat.EnableWindow( FALSE );
		m_radioSwitchAnyBar.SetCheck( 0 );
		m_radioSwitchAnyBar.EnableWindow( FALSE );
	}

	// Enable 'Trans at next marker' checkbox
	BOOL fEnableBoundaryCheckbox = ((m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT)
								||	(!(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN) &&
									 !(m_TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT))) ? TRUE : FALSE;
	m_buttonBoundary.EnableWindow( fEnableBoundaryCheckbox );
	m_buttonBoundary.SetCheck( (fEnableBoundaryCheckbox && (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MARKER)) ? 1 : 0 );
	m_staticNoMarkers.ShowWindow( (fEnableBoundaryCheckbox && (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MARKER)) ? SW_SHOW : SW_HIDE );

	//
	// Enable/Disable the pattern transition options
	// Enable/Disable the segment transition options
	//
	if( !fEnablePatternTransition
	||	(m_TransitionOptions.dwFlags & TRANS_NO_TRANSITION) )
	{
		// Disable radio buttons for the 'Transition' pattern
		m_radioEntirePattern.SetCheck( 0 );
		m_radioEntirePattern.EnableWindow( FALSE );
		m_radio1BarPattern.SetCheck( 0 );
		m_radio1BarPattern.EnableWindow( FALSE );

		// 'Long' is not checked
		m_buttonLong.SetCheck( 0 );
		m_buttonLong.EnableWindow( FALSE );

		// Disable radio buttons for the 'Additional' pattern
		m_radioEntireAdditional.SetCheck( 0 );
		m_radioEntireAdditional.EnableWindow( FALSE );
		m_radio1BarAdditional.SetCheck( 0 );
		m_radio1BarAdditional.EnableWindow( FALSE );

		// Disable Modulate button
		m_buttonModulate.EnableWindow( FALSE );
		m_buttonModulate.SetCheck( 0 );

		// Diable 'to nothing' button
		m_buttonTransNothing.EnableWindow( FALSE );
		m_buttonTransNothing.SetCheck( 0 );
	}
	else
	{
		// Make sure one of the 'Transition' pattern radio buttons will be checked
		if( !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ENTIRE_TRANSITION)
		&&  !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_1BAR_TRANSITION) )
		{
			m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_ENTIRE_TRANSITION;
		}

		// Enable radio buttons for the 'Transition' pattern
		m_radioEntirePattern.EnableWindow( TRUE );
		m_radioEntirePattern.SetCheck( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ENTIRE_TRANSITION );
		m_radio1BarPattern.EnableWindow( TRUE );
		m_radio1BarPattern.SetCheck( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_1BAR_TRANSITION );

		// Enable the 'Long' checkbox
		m_buttonLong.EnableWindow( TRUE );

		if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_LONG )
		{
			// 'Long' is checked
			m_buttonLong.SetCheck( 1 );

			// Make sure one of the 'Additional' pattern radio buttons will be checked
			if( !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ENTIRE_ADDITION)
			&&  !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_1BAR_ADDITION) )
			{
				m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_ENTIRE_ADDITION;
			}

			// Enable radio buttons for the 'Additional' pattern
			m_radioEntireAdditional.EnableWindow( TRUE );
			m_radioEntireAdditional.SetCheck( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ENTIRE_ADDITION );
			m_radio1BarAdditional.EnableWindow( TRUE );
			m_radio1BarAdditional.SetCheck( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_1BAR_ADDITION );
		}
		else
		{
			// 'Long' is not checked
			m_buttonLong.SetCheck( 0 );

			// Disable radio buttons for the 'Additional' pattern
			m_radioEntireAdditional.SetCheck( 0 );
			m_radioEntireAdditional.EnableWindow( FALSE );
			m_radio1BarAdditional.SetCheck( 0 );
			m_radio1BarAdditional.EnableWindow( FALSE );
		}

		// Enable the 'Modulate' checkbox
		m_buttonModulate.SetCheck( (m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_MODULATE) ? 1 : 0 );
		m_buttonModulate.EnableWindow( TRUE );

		if( m_TransitionOptions.wPatternType == DMUS_COMMANDT_END )
		{
			// Enable the 'to nothing' checkbox
			m_buttonTransNothing.SetCheck( (m_TransitionOptions.dwFlags & TRANS_TO_NOTHING) ? 1: 0 );
			m_buttonTransNothing.EnableWindow( TRUE );
		}
		else
		{
			// Diable 'to nothing' button
			m_buttonTransNothing.EnableWindow( FALSE );
			m_buttonTransNothing.SetCheck( 0 );
		}
	}

	// If "Use segment's default" is not checked (Added to fix bug 52362)
	if( !(m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_DEFAULT) )
	{
		// Enable the "response" and "cut off" radio buttons
		m_radioQuickResponse.EnableWindow( TRUE );
		m_radioAfterPrepare.EnableWindow( TRUE );
		m_radioAfterPrepare.SetCheck( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_AFTERPREPARETIME ? 1 : 0 );
		m_radioQuickResponse.SetCheck( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_AFTERPREPARETIME ? 0 : 1 );


		// Initialize 'Don't Cut Off' radio buttons
		::EnableWindow( ::GetDlgItem( GetSafeHwnd(), IDC_RADIO_NOINVALIDATE ), TRUE );
		::EnableWindow( ::GetDlgItem( GetSafeHwnd(), IDC_RADIO_INVALIDATEPRI ), TRUE );
		::EnableWindow( ::GetDlgItem( GetSafeHwnd(), IDC_RADIO_INVALIDATE ), TRUE );
		int nRadioButton = IDC_RADIO_INVALIDATE;
		if( m_TransitionOptions.dwBoundaryFlags  & DMUS_COMPOSEF_INVALIDATE_PRI )
		{
			nRadioButton = IDC_RADIO_INVALIDATEPRI;
		}
		else if( m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_NOINVALIDATE )
		{
			nRadioButton = IDC_RADIO_NOINVALIDATE;
		}
		CheckRadioButton( IDC_RADIO_NOINVALIDATE, IDC_RADIO_INVALIDATE, nRadioButton );
	}
	else
	{
		// Disable the "response" and "cut off" radio buttons
		m_radioQuickResponse.EnableWindow( FALSE );
		m_radioQuickResponse.SetCheck( 0 );
		m_radioAfterPrepare.EnableWindow( FALSE );
		m_radioAfterPrepare.SetCheck( 0 );
		::EnableWindow( ::GetDlgItem( GetSafeHwnd(), IDC_RADIO_NOINVALIDATE ), FALSE );
		::EnableWindow( ::GetDlgItem( GetSafeHwnd(), IDC_RADIO_INVALIDATEPRI ), FALSE );
		::EnableWindow( ::GetDlgItem( GetSafeHwnd(), IDC_RADIO_INVALIDATE ), FALSE );
		::SendMessage( ::GetDlgItem( GetSafeHwnd(), IDC_RADIO_NOINVALIDATE ), BM_SETCHECK, 0, 0 );
		::SendMessage( ::GetDlgItem( GetSafeHwnd(), IDC_RADIO_INVALIDATEPRI ), BM_SETCHECK, 0, 0 );
		::SendMessage( ::GetDlgItem( GetSafeHwnd(), IDC_RADIO_INVALIDATE ), BM_SETCHECK, 0, 0 );
	}
}

void DlgTransition::OnRadioEntireAdditional() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_ENTIRE_ADDITION;
	m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_1BAR_ADDITION;
}

void DlgTransition::OnRadioOneBarAdditional() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_ENTIRE_ADDITION;
	m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_1BAR_ADDITION;
}

void DlgTransition::OnRadioEntirePattern() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_ENTIRE_TRANSITION;
	m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_1BAR_TRANSITION;
}

void DlgTransition::OnRadioOneBarPattern() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_ENTIRE_TRANSITION;
	m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_1BAR_TRANSITION;
}

void DlgTransition::OnCheckModulate() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_buttonModulate.GetCheck() )
	{
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_MODULATE;
	}
	else
	{
		m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_MODULATE;
	}
}

void DlgTransition::OnCheckSegDefault() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_buttonSegDefault.GetCheck() )
	{
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_DEFAULT;
	}
	else
	{
		m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_DEFAULT;
	}

	UpdateSegmentAndPatternTransitionControls();
}

void DlgTransition::OnCheckTransNothing() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_buttonTransNothing.GetCheck() )
	{
		m_TransitionOptions.dwFlags |= TRANS_TO_NOTHING;
	}
	else
	{
		m_TransitionOptions.dwFlags &= ~TRANS_TO_NOTHING;
	}
}

void DlgTransition::OnRadioPrepareBtn() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( m_radioAfterPrepare.GetCheck() )
	{
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_AFTERPREPARETIME;
	}
	else
	{
		m_TransitionOptions.dwBoundaryFlags &= ~DMUS_COMPOSEF_AFTERPREPARETIME;
	}
}

void DlgTransition::OnRadioInvalidateBtn() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Clear the invalidate flags
	m_TransitionOptions.dwBoundaryFlags &= ~(DMUS_COMPOSEF_NOINVALIDATE|DMUS_COMPOSEF_INVALIDATE_PRI);

	// Set the appropriate invalidate flags
	switch( GetCheckedRadioButton( IDC_RADIO_NOINVALIDATE, IDC_RADIO_INVALIDATE ) )
	{
	case IDC_RADIO_NOINVALIDATE:
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_NOINVALIDATE;
		break;
	case IDC_RADIO_INVALIDATEPRI:
		m_TransitionOptions.dwBoundaryFlags |= DMUS_COMPOSEF_INVALIDATE_PRI;
		break;
	case IDC_RADIO_INVALIDATE:
		// Do nothing
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\dmusics.h ===
/************************************************************************
*                                                                       *
*   dmusics.h -- Definitions for created a DirectMusic software synth   *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICS_
#define _DMUSICS_

#include "dmusicc.h"

/* Software synths are enumerated from under this registry key.
 */
#define REGSTR_PATH_SOFTWARESYNTHS  "Software\\Microsoft\\DirectMusic\\SoftwareSynths"

interface IDirectMusicSynth;
interface IDirectMusicSynthSink;

#ifndef __cplusplus 
typedef interface IDirectMusicSynth IDirectMusicSynth;
typedef interface IDirectMusicSynthSink IDirectMusicSynthSink;
#endif

/* IDirectMusicSynth::Refresh
 *
 * This is the last buffer of the stream. It may be a partial block.
 */
#define REFRESH_F_LASTBUFFER        0x00000001

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth
DECLARE_INTERFACE_(IDirectMusicSynth, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
};

#undef  INTERFACE

#define INTERFACE  IDirectMusicSynth8
DECLARE_INTERFACE_(IDirectMusicSynth8, IDirectMusicSynth)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;

	/* IDirectMusicSynth8 */
    STDMETHOD(PlayVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId, 
										   DWORD dwChannelGroup, 
										   DWORD dwChannel, 
										   DWORD dwDLId, 
										   long	 prPitch,			//PREL not defined here
										   long  vrVolume,          //VREL not defined here 
                                           SAMPLE_TIME stVoiceStart,
                                           SAMPLE_TIME stLoopStart,
                                           SAMPLE_TIME stLoopEnd) PURE;

    STDMETHOD(StopVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId ) PURE;

    STDMETHOD(GetVoicePosition)     (THIS_ DWORD dwVoice[], 
										   DWORD cbVoice,
										   SAMPLE_POSITION dwVoicePos[] ) PURE;
    STDMETHOD(Refresh)              (THIS_ DWORD dwDownloadID,
                                           DWORD dwFlags) PURE;
    STDMETHOD(AssignChannelToBuses) (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwBuses,
                                           DWORD cBuses) PURE;                                           
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ IDirectMusicSynth *pSynth) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;                                           
    STDMETHOD(GetDesiredBufferSize) (THIS_ LPDWORD pdwBufferSizeInSamples) PURE;                                           
};

DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

DEFINE_GUID(IID_IDirectMusicSynth, 0x9823661,  0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSynth8,0x53cab625, 0x2711, 0x4c9f, 0x9d, 0xe7, 0x1b, 0x7f, 0x92, 0x5f, 0x6f, 0xc8);
DEFINE_GUID(IID_IDirectMusicSynthSink,0x9823663, 0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_SetSynthSink
 *
 * Item 0: An IUnknown on which the port can QueryInterface for a user-mode synth sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SetSynthSink,0x0a3a5ba5, 0x37b6, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_SinkUsesDSound
 *
 * Item 0: A DWORD boolean indicating whether or not the sink requires an IDirectSound interface. The
 * default is FALSE if this property item is not implemented by the sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SinkUsesDSound, 0xbe208857, 0x8952, 0x11d2, 0xba, 0x1c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DMOInfoProxy.cpp ===
// Implementation of CDMOInfoProxy

#include "stdafx.h"
#include "DMOInfoProxy.h"
#include "dmusici.h"
#include <initguid.h>
#define _SYS_GUID_OPERATORS_
#include "dmoreg.h"
#include "uuids.h"


// Constructor/Desctructor
CDMOInfoProxy::CDMOInfoProxy( DWORD dwStandardID )
{
	m_cRef = 0;
	AddRef();

	m_dwType = dwStandardID;
}

CDMOInfoProxy::~CDMOInfoProxy()
{
}

// IUnknown
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::QueryInterface( const IID &iid, void **ppv )
{
    if( ::IsEqualIID( iid, IID_IDMUSProdDMOInfo )  ||
		::IsEqualIID( iid, IID_IUnknown ) )
	{
		*ppv = static_cast<IDMUSProdDMOInfo *>(this);
	}
    else if( ::IsEqualIID( iid, IID_IDMUSProdNode ) )
	{
		*ppv = static_cast<IDMUSProdNode *>(this);
	}
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	static_cast<IUnknown *>(*ppv)->AddRef();
	return S_OK;
}

ULONG STDMETHODCALLTYPE CDMOInfoProxy::AddRef()
{
	return InterlockedIncrement( &m_cRef );
}

ULONG STDMETHODCALLTYPE CDMOInfoProxy::Release()
{
	if( InterlockedDecrement( &m_cRef ) == 0 )
	{
		delete this;
		return 0;
	}
	return m_cRef;
}

void GetDMOName( CLSID clsidDMO, WCHAR *wcstrName )
{
	IEnumDMO *pEnumDMO;

	DMO_PARTIAL_MEDIATYPE dmoPMT;
	dmoPMT.type = MEDIATYPE_Audio;
	dmoPMT.subtype = MEDIASUBTYPE_PCM;

	if( SUCCEEDED( DMOEnum( DMOCATEGORY_AUDIO_EFFECT, 0, 1, &dmoPMT, 1, &dmoPMT, &pEnumDMO ) ) )
	{
		pEnumDMO->Reset();
		CLSID clsidItem;
		WCHAR *pwcName;
		DWORD dwItemsFetched;
		while( S_OK == pEnumDMO->Next( 1, &clsidItem, &pwcName, &dwItemsFetched ) )
		{
			if( clsidItem == clsidDMO )
			{
				wcsncpy( wcstrName, pwcName, 64 );
				::CoTaskMemFree( pwcName );
				break;
			}

			::CoTaskMemFree( pwcName );
		}
		pEnumDMO->Release();
	}
}

// IDMUSProdDMOInfo method
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::EnumDMOInfo(
	DWORD dwIndex, DMUSProdDMOInfo *pDMOInfo ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Validate arguments
	if( pDMOInfo == NULL
	||	pDMOInfo->dwSize != sizeof( DMUSProdDMOInfo ) )
	{
		return E_POINTER;
	}

	ZeroMemory( pDMOInfo->awchPChannelText, sizeof(WCHAR) * 65 );
	ZeroMemory( pDMOInfo->awchMixGroupName, sizeof(WCHAR) * 65 );
	ZeroMemory( pDMOInfo->awchBufferText, sizeof(WCHAR) * 65 );
	ZeroMemory( pDMOInfo->awchDMOName, sizeof(WCHAR) * 65 );

	switch( m_dwType )
	{
	case DMUS_APATH_SHARED_STEREOPLUSREVERB:
		switch( dwIndex )
		{
		case 0:
			pDMOInfo->clsidDMO = GUID_DSFX_WAVES_REVERB;
			pDMOInfo->dwStage = DMUS_PATH_BUFFER_DMO;
			pDMOInfo->dwPChannel = 0;
			pDMOInfo->dwBufferIndex = 1;
			pDMOInfo->dwEffectIndex = 0;
			//pDMOInfo->awchPChannelText = ;
			//pDMOInfo->awchMixGroupName = ;
			//pDMOInfo->awchBufferText = ;
			GetDMOName( GUID_DSFX_WAVES_REVERB, pDMOInfo->awchDMOName );
			pDMOInfo->guidDesignGUID = GUID_DSFX_WAVES_REVERB;
			return S_OK;
			break;
		}
		break;
		/*
	case DMUS_APATH_DYNAMIC_ENV3D:
		switch( dwIndex )
		{
		case 0:
			pDMOInfo->clsidDMO = GUID_DSFX_STANDARD_I3DL2SOURCE;
			pDMOInfo->dwStage = DMUS_PATH_BUFFER_DMO;
			pDMOInfo->dwPChannel = 0;
			pDMOInfo->dwBufferIndex = 0;
			pDMOInfo->dwEffectIndex = 0;
			//pDMOInfo->awchPChannelText = ;
			//pDMOInfo->awchMixGroupName = ;
			//pDMOInfo->awchBufferText = ;
			GetDMOName( GUID_DSFX_STANDARD_I3DL2SOURCE, pDMOInfo->awchDMOName );
			pDMOInfo->guidDesignGUID = GUID_DSFX_STANDARD_I3DL2SOURCE;
			return S_OK;
		case 1:
			pDMOInfo->clsidDMO = GUID_DSFX_STANDARD_I3DL2REVERB;
			pDMOInfo->dwStage = DMUS_PATH_MIXIN_BUFFER_DMO;
			pDMOInfo->dwPChannel = 0;
			pDMOInfo->dwBufferIndex = 0;
			pDMOInfo->dwEffectIndex = 0;
			//pDMOInfo->awchPChannelText = ;
			//pDMOInfo->awchMixGroupName = ;
			//pDMOInfo->awchBufferText = ;
			GetDMOName( GUID_DSFX_STANDARD_I3DL2REVERB, pDMOInfo->awchDMOName );
			pDMOInfo->guidDesignGUID = GUID_DSFX_STANDARD_I3DL2REVERB;
			return S_OK;
		}
		break;
		*/
	}

	return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetNodeImageIndex( short* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetFirstChild( IDMUSProdNode** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetNextChild( IDMUSProdNode*, IDMUSProdNode** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetComponent( IDMUSProdComponent** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetDocRootNode( IDMUSProdNode** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::SetDocRootNode( IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetParentNode( IDMUSProdNode** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::SetParentNode( IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetNodeId( GUID* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetNodeName( BSTR* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetNodeNameMaxLength( short* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::ValidateNodeName( BSTR )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::SetNodeName( BSTR )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetNodeListInfo( DMUSProdListInfo* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetEditorClsId( CLSID* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetEditorTitle( BSTR* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetEditorWindow( HWND* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::SetEditorWindow( HWND )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::UseOpenCloseImages( BOOL* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetRightClickMenuId( HINSTANCE*, UINT* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::OnRightClickMenuInit( HMENU )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::OnRightClickMenuSelect( long )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::DeleteChildNode( IDMUSProdNode*, BOOL )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::InsertChildNode( IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::DeleteNode( BOOL )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::OnNodeSelChanged( BOOL )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::CreateDataObject( IDataObject** )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::CanCut()
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::CanCopy()
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::CanDelete()
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::CanDeleteChildNode( IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::CanPasteFromData( IDataObject*, BOOL* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::PasteFromData( IDataObject* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::CanChildPasteFromData( IDataObject*, IDMUSProdNode*, BOOL* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::ChildPasteFromData( IDataObject*, IDMUSProdNode* )
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
HRESULT STDMETHODCALLTYPE CDMOInfoProxy::GetObject( REFCLSID, REFIID, void** ) 
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DMOInfoProxy.h ===
#if !defined(AFX_DMOINFOPROXY_H__DD2654D3_1843_11D3_B447_00105A2796DE__INCLUDED_)
#define AFX_DMOINFOPROXY_H__DD2654D3_1843_11D3_B447_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DMOInfoProxy.h : header file
//

#include "AudioPathDesigner.h"
#include "DMUSProd.h"


/////////////////////////////////////////////////////////////////////////////
// CDMOInfoProxy class

class CDMOInfoProxy : public IDMUSProdDMOInfo, public IDMUSProdNode
{
public:
	CDMOInfoProxy( DWORD dwStandardID );
	~CDMOInfoProxy();

	// IUnknown methods
	virtual STDMETHODIMP QueryInterface( const IID &iid, void **ppv );
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// IDMUSProdDMOInfo method
	HRESULT STDMETHODCALLTYPE EnumDMOInfo( DWORD dwIndex, DMUSProdDMOInfo *pDMOInfo );

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

public:
	DWORD	m_dwType;

protected:
	LONG	m_cRef;
};

#endif // !defined(AFX_DMOINFOPROXY_H__DD2654D3_1843_11D3_B447_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgSecondaryStart.h ===
#if !defined(AFX_DLGSECONDARYSTART_H__6CB4201E_259F_11D2_88F7_00C04FBF8D15__INCLUDED_)
#define AFX_DLGSECONDARYSTART_H__6CB4201E_259F_11D2_88F7_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgSecondaryStart.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// DlgSecondaryStart dialog

class DlgSecondaryStart : public CDialog
{
// Construction
public:
	DlgSecondaryStart(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(DlgSecondaryStart)
	enum { IDD = IDD_SECONDARY };
	CButton	m_checkBoundary;
	CButton	m_radioSwitchAnyTime;
	CButton	m_radioSwitchAnyGrid;
	CButton	m_radioSwitchAnyBeat;
	CButton	m_radioSwitchAnyBar;
	CButton	m_radioSwitchOnBoundary;
	CStatic	m_staticNoMarkers;
	CStatic	m_staticAlignPrompt;
	CComboBox	m_comboBoundary;
	//}}AFX_DATA

	DWORD	m_dwSegmentFlags;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DlgSecondaryStart)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(DlgSecondaryStart)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnCheckBoundary();
	afx_msg void OnSelchangeComboBoundary();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGSECONDARYSTART_H__6CB4201E_259F_11D2_88F7_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\MIDISave.cpp ===
#include "stdafx.h"
#include "MIDISave.h"
#include "resource.h"


static writevarlen( FILE *file, LONG value )

{
    long buffer ;
    char out ;

    buffer = value & 0x7F ;

    while( (value >>= 7) > 0 ) {
        buffer <<= 8 ;
        buffer |= 0x80 ;
        buffer += (value & 0x7F) ;
    }

    for( ; ; ) {
        out = (char)buffer ;
        if( fwrite(&out,1,1,file) < 1 )
            return( 1 ) ;
        if( buffer & 0x80 )
            buffer >>= 8 ;
        else
            break ;
    }

    return( 0 ) ;

} 


static long calcvarlen( long value )

{
    long lLen = 1 ;

    while( (value >>= 7) > 0 )
    {
        lLen++ ;
    }

    return( lLen ) ;

}   

static writebyte( FILE *file, unsigned char c )

{
    return( fwrite(&c,1,1,file) < 1 ) ;
}   

static writeword( FILE *file, unsigned short w )

{
    writebyte( file, (unsigned char) ((unsigned short)(w >> 8)));
    return( writebyte( file, (unsigned char) w )) ;
}   

static writelong( FILE *file, long l )

{
    writeword( file, (unsigned short) ((long)(l >> 16)));
    return( writeword( file, (unsigned short) l)) ;
}

DWORD MIDIList::CalcTrack( MUSIC_TIME mtEnd )

{
    MIDIEvent *     pEvent;
    unsigned char   bLaststatus = 0;
    DWORD           dwTotal = 0;
    MUSIC_TIME      mtLasttime = 0;

    if (m_pName)
    {
        dwTotal = calcvarlen( strlen(m_pName) );
        dwTotal += strlen(m_pName);
        dwTotal += 3;
    }

    for(pEvent = GetHead();pEvent;pEvent=pEvent->GetNext() )
    {
        if( pEvent->m_mtTime < 0 ) pEvent->m_mtTime = 0;
        dwTotal   += calcvarlen( pEvent->m_mtTime - mtLasttime );
        mtLasttime = pEvent->m_mtTime;
        {
            if( pEvent->m_bStatus != bLaststatus )
            {
                dwTotal++;
                bLaststatus = pEvent->m_bStatus;
            }
            if ((bLaststatus & 0xF0) == 0xF0) 
            {
                bLaststatus = 0;
            }
			// If a SysEx event
			if( pEvent->m_bStatus == MIDI_SYSX )
			{
				// Add the bytes used for storing the SysEx event length
				ASSERT( pEvent->m_bLength < 128 );
				dwTotal++;
			}
            dwTotal += pEvent->m_bLength;
        }
    }

    if( mtEnd < mtLasttime )
        dwTotal++;
    else
        dwTotal += calcvarlen( mtEnd - mtLasttime );

    return( dwTotal + 3L );

}   

#define ID_MTHD     0x4D546864
#define ID_MTRK     0x4D54726B

HRESULT MIDIList::SaveTrack( FILE *file, MUSIC_TIME mtEnd )
{
    MIDIEvent *     pEvent;
    MUSIC_TIME      mtLasttime = 0;
    DWORD           dwId       = ID_MTRK;  
    unsigned char   bLaststatus = 0;

    writelong( file, dwId );    // Track header
    dwId = CalcTrack( mtEnd );  
    writelong( file, dwId );    // Length of track chunk
    if (m_pName)
    {
        writebyte( file, 0 );   // 0 time until track name 
        writebyte( file, 0xFF );
        writebyte( file, 3 );
        writevarlen( file, strlen(m_pName) );
        fwrite( m_pName, strlen(m_pName), 1, file );
    }
    for(pEvent = GetHead();pEvent;pEvent=pEvent->GetNext() )
    {
        if( writevarlen(file,pEvent->m_mtTime - mtLasttime) )
        {
            return( E_FAIL );
        }
        mtLasttime = pEvent->m_mtTime;
        {
            if (pEvent->m_bStatus != bLaststatus)
            {
                bLaststatus = pEvent->m_bStatus;
                fwrite( &pEvent->m_bStatus, 1, 1, file );
            }
            if ((bLaststatus & 0xF0) == 0xF0) 
            {
                bLaststatus = 0;
            }
			if( pEvent->m_bStatus == MIDI_SYSX )
			{
				// Need to write length of SysEx data chunk
				if( writevarlen(file,pEvent->m_bLength) )
				{
					return( E_FAIL );
				}
			}
			fwrite( &pEvent->m_bData[0], pEvent->m_bLength, 1, file );
        }
    }

    if( mtEnd < mtLasttime )
        writevarlen( file, 0 );
    else
        writevarlen( file, mtEnd - mtLasttime );

    writebyte( file, 0xFF );
    writebyte( file, 0x2F );
    writebyte( file, 0x0 );

    return( 0 );
}   

static MIDIEvent * sortevents( MIDIEvent * pEvents, long lLen )

{
    MIDIEvent * pLeft;
    MIDIEvent * pRight ;
    long        lCut ;
    MIDIEvent * pTop ;

    if( lLen < 3 )
    {
        if( !pEvents )
            return( 0 ) ;
        if( lLen == 1 )
            return( pEvents ) ;
        pLeft  = pEvents ;
        pRight = pEvents->GetNext() ;
        if( !pRight )
            return( pLeft ) ;
        if( (pLeft->m_mtTime > pRight->m_mtTime)
		|| ((pLeft->m_mtTime == pRight->m_mtTime) && ((pRight->m_bStatus & 0xF0) != MIDI_NOTEON)) )
        {
            pLeft->SetNext(NULL) ;
            pRight->SetNext(pLeft) ;
            return( pRight ) ;
        }
        return( pLeft ) ;
    }

    lCut    = lLen >> 1 ;
    pLeft   = pEvents ;
    pEvents = pEvents->GetItem( lCut-1 ) ;
    pRight  = sortevents( pEvents->GetNext(), lLen-lCut ) ;
    pEvents->SetNext(NULL) ;
    pLeft   = sortevents( pLeft, lCut ) ;
    pTop    = NULL ;

    for( ;  pLeft && pRight ;  )
    {
        if( (pLeft->m_mtTime < pRight->m_mtTime)
		|| ((pLeft->m_mtTime == pRight->m_mtTime) && ((pLeft->m_bStatus & 0xF0) != MIDI_NOTEON)) )
        {
            if( !pTop )
                pTop = pLeft ;
            else
                pEvents->SetNext(pLeft) ;
            pEvents = pLeft ;
            pLeft   = pEvents->GetNext() ;
        }
        else
        {
            if( !pTop )
                pTop = pRight ;
            else
                pEvents->SetNext(pRight) ;
            pEvents = pRight ;
            pRight  = pEvents->GetNext() ;
        }
    }

    if( pLeft )
        pEvents->SetNext(pLeft) ;
    else
        pEvents->SetNext(pRight) ;

    return( pTop ) ;

}   

void MIDIList::Sort() 

{
    m_pHead = sortevents(GetHead(), GetCount()) ;
}   

void MIDIList::Clear()

{
    MIDIEvent *pEvent = RemoveHead();
    while (pEvent)
    {
        delete pEvent;
		pEvent = RemoveHead();
    }
    m_nTranspose = 0;
}

MIDIList::MIDIList()

{
    m_nTranspose = 0;
    m_pName = NULL;
}

MIDIList::~MIDIList()

{
    if (m_pName) delete m_pName;
    Clear();
}

void MIDIList::SetName(char *pName)

{
    if (pName)
    {
        if (m_pName) delete m_pName;
        m_pName = new char[strlen(pName)+1];
        if (m_pName) strcpy(m_pName,pName);
    }
}

DWORD MIDIList::PrepToSave(MUSIC_TIME mtStartOffset, MUSIC_TIME *pmtLength)

{
    MIDIEvent *pEvent = GetHead();
    if (!pEvent) return 0;
    for (;pEvent;pEvent = pEvent->GetNext())
    {
        pEvent->m_mtTime -= mtStartOffset;
        if (pEvent->m_mtTime > *pmtLength)
        {
            *pmtLength = pEvent->m_mtTime;
        }
    }
    Sort();
    return 1;
}

HRESULT MIDISaveTool::SaveMIDISong( FILE *file, MUSIC_TIME mtLength, DWORD dwTracks)
{
    long    dwID = ID_MTHD ;

    if( writelong(file,dwID) )
        return( E_FAIL ) ;

    dwID = 6;
    writelong( file, dwID ) ;   // Length of header  
    writeword( file, 1 ) ;      // MIDI format 1 
    writeword( file, (unsigned short)(1 + dwTracks) ) ; // Number of tracks
    writeword( file, 768 ) ;    // PPQ

    if(FAILED( m_ControlTrack.SaveTrack(file,mtLength) ))
        return( E_FAIL ) ;
    DWORD dwTrack;
    if (m_ppChannelTracks)
    {
        for (dwTrack = 0; dwTrack < m_dwChannels; dwTrack++)
        {
            if (m_ppChannelTracks[dwTrack] && 
                m_ppChannelTracks[dwTrack]->GetCount())
            {
                if (FAILED(m_ppChannelTracks[dwTrack]->SaveTrack(file,mtLength) ))
                    return( E_FAIL ) ;
            }
        }
    }
    return S_OK;
}   

HRESULT MIDISaveTool::SaveMIDIFile(LPCTSTR pFileName, 
                                   IDirectMusicSegmentState *pState, 
                                   BOOL fExtraMeasure,
                                   BOOL fRMID)

{
    FILE *pFile;
    MUSIC_TIME mtLength = 0;
    DWORD dwIndex;
    DWORD dwTrackCount = 0;
    MUSIC_TIME mtStartOffset;
	HRESULT hr = S_OK;

    if (!pState)
    {
        return E_FAIL;
    }
    EnterCriticalSection(&m_CrSec);
    StopRecording();
    pState->GetStartTime(&mtStartOffset);
    if (fExtraMeasure) // Insert a measure at start and give it the time signature.
    {
        mtStartOffset -= ( DMUS_PPQ * 4 );
        MIDIEvent *pEvent = new MIDIEvent;
        if (pEvent)
        {
            pEvent->m_bStatus = 0xFF;   // Meta event marker.
            pEvent->m_bData[0] = 0x58;  // Time Signature
            pEvent->m_bData[1] = 0x4;   // 4 bytes to follow.
            pEvent->m_bData[2] = 4;     // 4 beats per measure.
            pEvent->m_bData[3] = 2;     // Quarter note.
            pEvent->m_bData[4] = 24;
            pEvent->m_bData[5] = 8;
            pEvent->m_mtTime = mtStartOffset;
            pEvent->m_bLength = 6;
            m_ControlTrack.AddHead(pEvent);
        }
    }
    if (m_ppChannelTracks)
    {
        for (dwIndex = 0;dwIndex < m_dwChannels; dwIndex++)
        {
            if (m_ppChannelTracks[dwIndex])
            {
                dwTrackCount += m_ppChannelTracks[dwIndex]->PrepToSave(mtStartOffset,&mtLength);
            }
        }
    }
    m_ControlTrack.PrepToSave(mtStartOffset,&mtLength);   
    pFile = fopen( pFileName, "wb" ) ;
    if( pFile > 0 )
    {
        if (fRMID)
        {
            fwrite("RIFF    RMIDdata    ",20,1,pFile);
        }
        SaveMIDISong( pFile, mtLength, dwTrackCount);
        if (fRMID)
        {
            long lEndPos = ftell( pFile );
            lEndPos = (lEndPos+1) & 0xFFFFFFFE;
            fseek(pFile,4,SEEK_SET);
            lEndPos -= 8;
            fwrite(&lEndPos,4,1,pFile);
            fseek(pFile,16,SEEK_SET);
            lEndPos -= 12;
            fwrite(&lEndPos,4,1,pFile);
        }
        fclose( pFile ) ;
    }
    LeaveCriticalSection(&m_CrSec);

	if( pFile <= 0 )
	{
		CString strMsg;
		LPVOID lpMessageBuffer;
		
		FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
					   NULL, GetLastError(),
					   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
					   (LPTSTR)&lpMessageBuffer, 0, NULL );

		HINSTANCE hInstanceOld = AfxGetResourceHandle();
		AfxSetResourceHandle( _Module.GetResourceInstance() );

		AfxFormatString1( strMsg, IDS_SYSERR_SAVE, pFileName );
		strMsg = strMsg + (LPTSTR)lpMessageBuffer;
		AfxMessageBox( strMsg );

		AfxSetResourceHandle( hInstanceOld );

		LocalFree( lpMessageBuffer );
		hr = E_FAIL;
	}

    return hr;
}

HRESULT MIDISaveTool::SetChannelName(DWORD dwTrack, char *pName)

{
    if (dwTrack < m_dwChannels)
    {
        if (m_ppChannelTracks && m_ppChannelTracks[dwTrack])
        {
            m_ppChannelTracks[dwTrack]->SetName( pName );
            return S_OK;
        }
    }
    return E_FAIL;
}


HRESULT MIDISaveTool::SetChannels(DWORD dwChannels)

{
    DWORD dwTrack;
    EnterCriticalSection(&m_CrSec);
    if (m_dwChannels != dwChannels)
    {
        MIDIList ** ppChannelTracks = new MIDIList *[dwChannels];
		if (ppChannelTracks)
		{
			for (dwTrack = 0; dwTrack < dwChannels; dwTrack++)
			{
				ppChannelTracks[dwTrack] = NULL;
			}
			if (m_dwChannels < dwChannels)
			{
				for (dwTrack = 0; dwTrack < m_dwChannels; dwTrack++)
				{
					ppChannelTracks[dwTrack] = m_ppChannelTracks[dwTrack];
				}
				for (;dwTrack < dwChannels; dwTrack++)
				{
				    ppChannelTracks[dwTrack] = new MIDIList;
					if (ppChannelTracks[dwTrack])
					{
                        char strName[20];
                        wsprintf( strName, "Track %ld",dwTrack+1);
                        ppChannelTracks[dwTrack]->SetName(strName);
                    }
				}
			}
			else
			{
				for (dwTrack = 0; dwTrack < dwChannels; dwTrack++)
				{
					ppChannelTracks[dwTrack] = m_ppChannelTracks[dwTrack];
				}
				for (; dwTrack < m_dwChannels; dwTrack++)
				{
					if (m_ppChannelTracks[dwTrack])
					{
						delete m_ppChannelTracks[dwTrack];
					}
				}
			}
			if (m_ppChannelTracks)
			{
				delete m_ppChannelTracks;
			}
		}
        else 
        {
            dwChannels = 0;
        }
	    m_ppChannelTracks = ppChannelTracks;
	    m_dwChannels = dwChannels;    
    }
    LeaveCriticalSection(&m_CrSec);
    return S_OK;
}

HRESULT MIDISaveTool::StartRecording()

{
    DWORD dwTrack;
    EnterCriticalSection(&m_CrSec);
    if (m_ppChannelTracks)
    {
        for (dwTrack = 0; dwTrack < m_dwChannels; dwTrack++)
        {
            if (m_ppChannelTracks[dwTrack])
            {
                m_ppChannelTracks[dwTrack]->Clear();
            }
        }
    }
    m_ControlTrack.Clear();
    m_fRecordEnabled = TRUE;
    LeaveCriticalSection(&m_CrSec);
    return S_OK;
}

HRESULT MIDISaveTool::StopRecording()

{
    m_fRecordEnabled = FALSE;
    return S_OK;
}

MIDISaveTool::MIDISaveTool()
{
    m_fRecordEnabled = FALSE;
    m_cRef = 1; // set to 1 so one call to Release() will free this
    InitializeCriticalSection(&m_CrSec);
    m_ControlTrack.SetName("Control Track");
    m_dwChannels = 0;
    m_ppChannelTracks = NULL;
}

MIDISaveTool::~MIDISaveTool()
{
    DWORD dwTrack;
    if (m_ppChannelTracks)
    {
        for (dwTrack = 0; dwTrack < m_dwChannels; dwTrack++)
        {
            if (m_ppChannelTracks[dwTrack])
            {
                delete m_ppChannelTracks[dwTrack];
            }
        }
        delete m_ppChannelTracks;
    }
    DeleteCriticalSection(&m_CrSec);
}


STDMETHODIMP MIDISaveTool::QueryInterface(const IID &iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDirectMusicTool)
    {
        *ppv = static_cast<IDirectMusicTool*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    static_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) MIDISaveTool::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) MIDISaveTool::Release()
{
    if( 0 == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////
// IDirectMusicTool

HRESULT STDMETHODCALLTYPE MIDISaveTool::Init( IDirectMusicGraph* pGraph )
{
 	UNREFERENCED_PARAMETER(pGraph);

   // This tool has no need to do any type of initialization.
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE MIDISaveTool::GetMsgDeliveryType( DWORD* pdwDeliveryType )
{
    // This tool wants messages immediately.
    // This is the default, so returning E_NOTIMPL
    // would work. The other method is to specifically
    // set *pdwDeliveryType to the delivery type, DMUS_PMSGF_TOOL_IMMEDIATE,
    // DMUS_PMSGF_TOOL_QUEUE, or DMUS_PMSGF_TOOL_ATTIME.
    
    *pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE MIDISaveTool::GetMediaTypeArraySize( DWORD* pdwNumElements )
{
    *pdwNumElements = 8;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE MIDISaveTool::GetMediaTypes( DWORD** padwMediaTypes, 
                                                    DWORD dwNumElements )
{
    if( dwNumElements == 8 )
    {
        (*padwMediaTypes)[0] = DMUS_PMSGT_NOTE;
        (*padwMediaTypes)[1] = DMUS_PMSGT_MIDI;
        (*padwMediaTypes)[2] = DMUS_PMSGT_TEMPO;
        (*padwMediaTypes)[3] = DMUS_PMSGT_CURVE;
        (*padwMediaTypes)[4] = DMUS_PMSGT_TIMESIG;
        (*padwMediaTypes)[5] = DMUS_PMSGT_PATCH;
        (*padwMediaTypes)[6] = DMUS_PMSGT_TRANSPOSE;
        (*padwMediaTypes)[7] = DMUS_PMSGT_SYSEX;

        return S_OK;
    }
    else
    {
        // this should never happen
        return E_FAIL;
    }
}

// curve.h

#define CT_MAX  192 // curve table maximum
#define CT_FACTOR	100	// curve table multiplication factor
#define CT_DIVFACTOR	( ( CT_MAX ) * CT_FACTOR ) // curve division factor

// linear curves
static short ganCT_Linear[CT_MAX + 1] = {
	0,100,200,300,400,500,600,700,
	800,900,1000,1100,1200,1300,1400,1500,
	1600,1700,1800,1900,2000,2100,2200,2300,
	2400,2500,2600,2700,2800,2900,3000,3100,
	3200,3300,3400,3500,3600,3700,3800,3900,
	4000,4100,4200,4300,4400,4500,4600,4700,
	4800,4900,5000,5100,5200,5300,5400,5500,
	5600,5700,5800,5900,6000,6100,6200,6300,
	6400,6500,6600,6700,6800,6900,7000,7100,
	7200,7300,7400,7500,7600,7700,7800,7900,
	8000,8100,8200,8300,8400,8500,8600,8700,
	8800,8900,9000,9100,9200,9300,9400,9500,
	9600,9700,9800,9900,10000,10100,10200,10300,
	10400,10500,10600,10700,10800,10900,11000,11100,
	11200,11300,11400,11500,11600,11700,11800,11900,
	12000,12100,12200,12300,12400,12500,12600,12700,
	12800,12900,13000,13100,13200,13300,13400,13500,
	13600,13700,13800,13900,14000,14100,14200,14300,
	14400,14500,14600,14700,14800,14900,15000,15100,
	15200,15300,15400,15500,15600,15700,15800,15900,
	16000,16100,16200,16300,16400,16500,16600,16700,
	16800,16900,17000,17100,17200,17300,17400,17500,
	17600,17700,17800,17900,18000,18100,18200,18300,
	18400,18500,18600,18700,18800,18900,19000,19100,19200 
};

// sine curves
static short ganCT_Sine[CT_MAX + 1] = {
	0,1,5,11,20,32,46,62,
	82,103,128,155,184,216,250,287,
	327,369,413,460,509,561,615,671,
	730,792,855,921,990,1060,1133,1208,
	1286,1365,1447,1531,1617,1706,1796,1889,
	1983,2080,2179,2279,2382,2486,2593,2701,
	2811,2923,3037,3153,3270,3389,3509,3632,
	3755,3881,4008,4136,4266,4397,4530,4664,
	4799,4936,5074,5213,5354,5495,5638,5781,
	5926,6071,6218,6365,6514,6663,6813,6963,
	7115,7267,7420,7573,7727,7881,8036,8191,
	8346,8502,8659,8815,8972,9128,9285,9442,
	9600,9757,9914,10071,10227,10384,10540,10697,
	10853,11008,11163,11318,11472,11626,11779,11932,
	12084,12236,12386,12536,12685,12834,12981,13128,
	13273,13418,13561,13704,13845,13986,14125,14263,
	14399,14535,14669,14802,14933,15063,15191,15318,
	15444,15567,15690,15810,15929,16046,16162,16276,
	16388,16498,16606,16713,16817,16920,17020,17119,
	17216,17310,17403,17493,17582,17668,17752,17834,
	17913,17991,18066,18139,18209,18278,18344,18407,
	18469,18528,18584,18638,18690,18739,18786,18830,
	18872,18912,18949,18983,19015,19044,19071,19096,
	19117,19137,19153,19167,19179,19188,19194,19198,19200 
};

// log curve
static short ganCT_Log[CT_MAX + 1] = {
	0,381,747,1097,1432,1755,2066,2366,
	2655,2934,3205,3467,3721,3967,4207,4439,
	4666,4886,5101,5310,5515,5714,5909,6099,
	6285,6467,6645,6819,6990,7157,7321,7482,
	7640,7795,7947,8096,8243,8387,8529,8668,
	8805,8940,9073,9204,9332,9459,9584,9707,
	9828,9947,10065,10181,10295,10408,10520,10630,
	10738,10845,10951,11056,11159,11261,11361,11461,
	11559,11656,11752,11847,11941,12034,12126,12216,
	12306,12395,12483,12570,12656,12741,12826,12909,
	12992,13074,13155,13235,13315,13394,13472,13549,
	13626,13702,13777,13851,13925,13998,14071,14143,
	14214,14285,14355,14425,14494,14562,14630,14698,
	14764,14831,14896,14962,15026,15091,15154,15218,
	15280,15343,15405,15466,15527,15587,15647,15707,
	15766,15825,15883,15941,15999,16056,16113,16169,
	16225,16281,16336,16391,16446,16500,16554,16607,
	16661,16713,16766,16818,16870,16921,16973,17024,
	17074,17124,17174,17224,17273,17323,17371,17420,
	17468,17516,17564,17611,17658,17705,17752,17798,
	17844,17890,17936,17981,18026,18071,18116,18160,
	18204,18248,18292,18335,18379,18422,18464,18507,
	18549,18592,18634,18675,18717,18758,18799,18840,
	18881,18921,18962,19002,19042,19081,19121,19160,19200 
};

// exponential curve
static short ganCT_Exp[CT_MAX + 1] = {
	0,40,79,119,158,198,238,279,
	319,360,401,442,483,525,566,608,
	651,693,736,778,821,865,908,952,
	996,1040,1084,1129,1174,1219,1264,1310,
	1356,1402,1448,1495,1542,1589,1636,1684,
	1732,1780,1829,1877,1927,1976,2026,2076,
	2126,2176,2227,2279,2330,2382,2434,2487,
	2539,2593,2646,2700,2754,2809,2864,2919,
	2975,3031,3087,3144,3201,3259,3317,3375,
	3434,3493,3553,3613,3673,3734,3795,3857,
	3920,3982,4046,4109,4174,4238,4304,4369,
	4436,4502,4570,4638,4706,4775,4845,4915,
	4986,5057,5129,5202,5275,5349,5423,5498,
	5574,5651,5728,5806,5885,5965,6045,6126,
	6208,6291,6374,6459,6544,6630,6717,6805,
	6894,6984,7074,7166,7259,7353,7448,7544,
	7641,7739,7839,7939,8041,8144,8249,8355,
	8462,8570,8680,8792,8905,9019,9135,9253,
	9372,9493,9616,9741,9868,9996,10127,10260,
	10395,10532,10671,10813,10957,11104,11253,11405,
	11560,11718,11879,12043,12210,12381,12555,12733,
	12915,13101,13291,13486,13685,13890,14099,14314,
	14534,14761,14993,15233,15479,15733,15995,16266,
	16545,16834,17134,17445,17768,18103,18453,18819,19200 
};

static long ComputeCurveTimeSlice(DMUS_CURVE_PMSG* pCurve)
{
    long lTimeIncrement;
    DWORD dwTotalDistance;
    DWORD dwResolution;
    if ((pCurve->bType == DMUS_CURVET_PBCURVE) ||
        (pCurve->bType == DMUS_CURVET_RPNCURVE) ||
        (pCurve->bType == DMUS_CURVET_NRPNCURVE))
    {
        dwResolution = 100;
    }
    else
    {
        dwResolution = 3;
    }
    if (pCurve->nEndValue > pCurve->nStartValue)
        dwTotalDistance = pCurve->nEndValue - pCurve->nStartValue;
    else 
        dwTotalDistance = pCurve->nStartValue - pCurve->nEndValue;
    if (dwTotalDistance == 0) dwTotalDistance = 1;
    lTimeIncrement = (pCurve->mtDuration * dwResolution) / dwTotalDistance;
    // Force to no smaller than 192nd note (10ms at 120 bpm.)
    if( lTimeIncrement < (DMUS_PPQ/48) ) lTimeIncrement = DMUS_PPQ/48;
    return lTimeIncrement;
}

static BOOL ComputeCurve( DMUS_CURVE_PMSG* pCurve, MUSIC_TIME *pmtTime, DWORD *pdwReturnVal  )
{
	short *panTable;
	MUSIC_TIME mtCurrent;
	short nIndex;

	switch( pCurve->bCurveShape )
	{
	case DMUS_CURVES_INSTANT:
	default:
        *pdwReturnVal = (DWORD) pCurve->nEndValue;
		return FALSE;
		break;
	case DMUS_CURVES_LINEAR:
		panTable = &ganCT_Linear[ 0 ];
		break;
	case DMUS_CURVES_EXP:
		panTable = &ganCT_Exp[ 0 ];
		break;
	case DMUS_CURVES_LOG:
		panTable = &ganCT_Log[ 0 ];
		break;
	case DMUS_CURVES_SINE:
		panTable = &ganCT_Sine[ 0 ];
		break;
	}

	// compute index into table
	// there are CT_MAX + 1 elements in the table.
	mtCurrent = *pmtTime - pCurve->mtOriginalStart;
    if( (pCurve->mtDuration == 0) ||
		(*pmtTime - pCurve->mtOriginalStart >= pCurve->mtDuration ))
	{
		*pdwReturnVal = pCurve->nEndValue;
		return FALSE;
	}
	else
	{
		//dblRes = (double)pCurve->mtDuration / (CT_MAX + 1);
		nIndex = short((mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration);

        // find an amount of time to add to the curve event such that there is at
        // least a change by CT_FACTOR. This will be used as the time stamp
        // for the next iteration of the curve.

		// clamp nIndex
		if( nIndex < 0 )
		{
			nIndex = 0;
		}
		if( nIndex >= CT_MAX )
		{
			nIndex = CT_MAX;
			*pdwReturnVal = pCurve->nEndValue;
			return FALSE;
		}
		else
		{
            // Okay, in the curve, so calculate the return value.
            *pdwReturnVal = ((panTable[nIndex] * (pCurve->nEndValue - pCurve->nStartValue)) / 
                CT_DIVFACTOR) + pCurve->nStartValue;
		}
		*pmtTime += ComputeCurveTimeSlice( pCurve );
		if( *pmtTime > pCurve->mtDuration + pCurve->mtOriginalStart )
		{
			*pmtTime = pCurve->mtDuration + pCurve->mtOriginalStart;
		}
	}

	return TRUE;
}

HRESULT STDMETHODCALLTYPE MIDISaveTool::ProcessPMsg( IDirectMusicPerformance* pPerf, 
                                                  DMUS_PMSG* pPMsg )
{
	UNREFERENCED_PARAMETER(pPerf);

    if( pPMsg->pGraph == NULL )
    {
        return DMUS_S_FREE;
    }

    EnterCriticalSection(&m_CrSec);
    if (m_fRecordEnabled && (pPMsg->dwPChannel < m_dwChannels) 
        && m_ppChannelTracks && m_ppChannelTracks[pPMsg->dwPChannel])
    {
        if( pPMsg->dwType == DMUS_PMSGT_MIDI )
        {
            DMUS_MIDI_PMSG * pMIDI;
            pMIDI = (DMUS_MIDI_PMSG*)pPMsg;
            MIDIEvent *pEvent = new MIDIEvent;
            if (pEvent)
            {
                pEvent->m_bStatus = (BYTE) 
                    ((pMIDI->bStatus & 0xF0) | (pMIDI->dwPChannel & 0xF));
                switch( pMIDI->bStatus & 0xF0 )
                {
                    case MIDI_NOTEON:
                    case MIDI_NOTEOFF:
                    case MIDI_PTOUCH:
                    case MIDI_CCHANGE:
                    case MIDI_PBEND:
                        pEvent->m_bLength = 2;
                        break;
                    default :
                        pEvent->m_bLength = 1;
                }
                pEvent->m_bData[0] = pMIDI->bByte1;
                pEvent->m_bData[1] = pMIDI->bByte2;
                pEvent->m_mtTime = pMIDI->mtTime;
                m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
            }
        }
        else if( pPMsg->dwType == DMUS_PMSGT_NOTE )
        {
	        DMUS_NOTE_PMSG* pNote;
            pNote = (DMUS_NOTE_PMSG*)pPMsg;
            MIDIEvent *pEvent = new MIDIEvent;
            if (pEvent)
            {
                pEvent->m_bStatus = (BYTE) 
                    (MIDI_NOTEON | (pNote->dwPChannel & 0xF));
                pEvent->m_bData[0] = (BYTE)(pNote->bMidiValue +
                    m_ppChannelTracks[pPMsg->dwPChannel]->m_nTranspose);
                pEvent->m_bData[1] = pNote->bVelocity;
                pEvent->m_mtTime = pNote->mtTime;
                pEvent->m_bLength = 2;
                m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
            }
            pEvent = new MIDIEvent;
            if (pEvent)
            {
                pEvent->m_bStatus = (BYTE) 
                    (MIDI_NOTEOFF | (pNote->dwPChannel & 0xF));
                pEvent->m_bData[0] = (BYTE)(pNote->bMidiValue +
                    m_ppChannelTracks[pPMsg->dwPChannel]->m_nTranspose);
                pEvent->m_bData[1] = 0;
                pEvent->m_mtTime = pNote->mtTime + pNote->mtDuration;
                pEvent->m_bLength = 2;
                m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
            }
        }
        else if( pPMsg->dwType == DMUS_PMSGT_TRANSPOSE )
        {
            DMUS_TRANSPOSE_PMSG* pTranspose;
            pTranspose = (DMUS_TRANSPOSE_PMSG*)pPMsg;
            m_ppChannelTracks[pPMsg->dwPChannel]->m_nTranspose = 
                pTranspose->nTranspose;
        }
        else if( pPMsg->dwType == DMUS_PMSGT_PATCH )
        {
	        DMUS_PATCH_PMSG* pPatch;
            pPatch = (DMUS_PATCH_PMSG*)pPMsg;
            MIDIEvent *pEvent = new MIDIEvent;
            if (pEvent)
            {
                pEvent->m_bStatus = (BYTE)
                    (MIDI_CCHANGE | (pPatch->dwPChannel & 0xF));
                pEvent->m_bData[0] = MIDI_CC_BS_LSB;
                pEvent->m_bData[1] = pPatch->byLSB;
                pEvent->m_mtTime = pPatch->mtTime - 2;
                pEvent->m_bLength = 2;
                m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
            }
            pEvent = new MIDIEvent;
            if (pEvent)
            {
                pEvent->m_bStatus = (BYTE)
                    (MIDI_CCHANGE | (pPatch->dwPChannel & 0xF));
                pEvent->m_bData[0] = MIDI_CC_BS_MSB;
                pEvent->m_bData[1] = pPatch->byMSB;
                pEvent->m_mtTime = pPatch->mtTime - 1;
                pEvent->m_bLength = 2;
                m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
            }
            pEvent = new MIDIEvent;
            if (pEvent)
            {
                pEvent->m_bStatus = (BYTE)
                    (MIDI_PCHANGE | (pPatch->dwPChannel & 0xF));
                pEvent->m_bData[0] = pPatch->byInstrument;
                pEvent->m_mtTime = pPatch->mtTime;
                pEvent->m_bLength = 1;
                m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
            }
        }
        else if( pPMsg->dwType == DMUS_PMSGT_CURVE )
        {
            DMUS_CURVE_PMSG* pCurve;
            pCurve = (DMUS_CURVE_PMSG*) pPMsg;
            MUSIC_TIME mtTime = pCurve->mtTime;
            pCurve->mtOriginalStart = pCurve->mtTime;
            BOOL fKeepGoing = TRUE;
			DWORD dwLastValue = LONG_MAX;
            for (;fKeepGoing;)
            {
				// Save the current time
				MUSIC_TIME mtOldTime = mtTime;

				// Compute the new value, new time, and whether to keep going or not
                DWORD dwValue;
                fKeepGoing = ComputeCurve( pCurve, &mtTime, &dwValue);

				// Ensure we don't repeat the same value
				if( dwValue == dwLastValue )
				{
					continue;
				}
				dwLastValue = dwValue;

				// Create a new event
                MIDIEvent *pEvent = new MIDIEvent;
                if (pEvent)
                {
	                pEvent->m_mtTime = mtOldTime;
                    m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
                    switch( pCurve->bType )
        	        {
	                case DMUS_CURVET_PBCURVE:
                        pEvent->m_bStatus = (BYTE) 
                            (MIDI_PBEND | (pPMsg->dwPChannel & 0xF));
                        pEvent->m_bData[0] = (BYTE) (dwValue & 0x7F);
                        dwValue >>= 7;
                        pEvent->m_bData[1] = (BYTE) (dwValue & 0x7F);
                        pEvent->m_bLength = 2;
		                break;
	                case DMUS_CURVET_CCCURVE:
                        pEvent->m_bStatus = (BYTE) 
                            (MIDI_CCHANGE | (pPMsg->dwPChannel & 0xF));
                        pEvent->m_bData[0] = pCurve->bCCData;
                        pEvent->m_bData[1] = (BYTE) (dwValue & 0x7F);
                        pEvent->m_bLength = 2;
		                break;
	                case DMUS_CURVET_MATCURVE:
                        pEvent->m_bStatus = (BYTE) 
                            (MIDI_MTOUCH | (pPMsg->dwPChannel & 0xF));
                        pEvent->m_bData[0] = (BYTE) (dwValue & 0x7F);
                        pEvent->m_bLength = 1;
		                break;
	                case DMUS_CURVET_PATCURVE:
		                pEvent->m_bStatus = (BYTE) 
                            (MIDI_PTOUCH | (pPMsg->dwPChannel & 0xF));
                        pEvent->m_bData[0] = pCurve->bCCData;
                        pEvent->m_bData[1] = (BYTE) (dwValue & 0x7F);
                        pEvent->m_bLength = 2;
		                break;
					case DMUS_CURVET_RPNCURVE:
						pEvent->m_mtTime = mtOldTime - 3;
		                pEvent->m_bStatus = (BYTE) 
                            (MIDI_CCHANGE | (pPMsg->dwPChannel & 0xF));
                        pEvent->m_bData[0] = MIDI_CC_RPN_LSB;
                        pEvent->m_bData[1] = (BYTE) (pCurve->wParamType & 0x7F);
                        pEvent->m_bLength = 2;
						pEvent = new MIDIEvent;
						if (pEvent)
						{
							pEvent->m_mtTime = mtOldTime - 2;
							m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
							pEvent->m_bStatus = (BYTE) 
								(MIDI_CCHANGE | (pPMsg->dwPChannel & 0xF));
							pEvent->m_bData[0] = MIDI_CC_RPN_MSB;
							pEvent->m_bData[1] = (BYTE) ((pCurve->wParamType >> 7) & 0x7F);
							pEvent->m_bLength = 2;
							pEvent = new MIDIEvent;
							if (pEvent)
							{
								pEvent->m_mtTime = mtOldTime - 1;
								m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
								pEvent->m_bStatus = (BYTE) 
									(MIDI_CCHANGE | (pPMsg->dwPChannel & 0xF));
								pEvent->m_bData[0] = MIDI_CC_DATA_MSB;
								pEvent->m_bData[1] = (BYTE) ((dwValue >> 7) & 0x7F);
								pEvent->m_bLength = 2;
								pEvent = new MIDIEvent;
								if (pEvent)
								{
									pEvent->m_mtTime = mtOldTime;
									m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
									pEvent->m_bStatus = (BYTE) 
										(MIDI_CCHANGE | (pPMsg->dwPChannel & 0xF));
									pEvent->m_bData[0] = MIDI_CC_DATA_LSB;
									pEvent->m_bData[1] = (BYTE) (dwValue & 0x7F);
									pEvent->m_bLength = 2;
								}
							}
						}
						break;
					case DMUS_CURVET_NRPNCURVE:
						pEvent->m_mtTime = mtOldTime - 3;
		                pEvent->m_bStatus = (BYTE) 
                            (MIDI_CCHANGE | (pPMsg->dwPChannel & 0xF));
                        pEvent->m_bData[0] = MIDI_CC_NRPN_LSB;
                        pEvent->m_bData[1] = (BYTE) (pCurve->wParamType & 0x7F);
                        pEvent->m_bLength = 2;
						pEvent = new MIDIEvent;
						if (pEvent)
						{
							pEvent->m_mtTime = mtOldTime - 2;
							m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
							pEvent->m_bStatus = (BYTE) 
								(MIDI_CCHANGE | (pPMsg->dwPChannel & 0xF));
							pEvent->m_bData[0] = MIDI_CC_NRPN_MSB;
							pEvent->m_bData[1] = (BYTE) ((pCurve->wParamType >> 7) & 0x7F);
							pEvent->m_bLength = 2;
							pEvent = new MIDIEvent;
							if (pEvent)
							{
								pEvent->m_mtTime = mtOldTime - 1;
								m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
								pEvent->m_bStatus = (BYTE) 
									(MIDI_CCHANGE | (pPMsg->dwPChannel & 0xF));
								pEvent->m_bData[0] = MIDI_CC_DATA_MSB;
								pEvent->m_bData[1] = (BYTE) ((dwValue >> 7) & 0x7F);
								pEvent->m_bLength = 2;
								pEvent = new MIDIEvent;
								if (pEvent)
								{
									pEvent->m_mtTime = mtOldTime;
									m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
									pEvent->m_bStatus = (BYTE) 
										(MIDI_CCHANGE | (pPMsg->dwPChannel & 0xF));
									pEvent->m_bData[0] = MIDI_CC_DATA_LSB;
									pEvent->m_bData[1] = (BYTE) (dwValue & 0x7F);
									pEvent->m_bLength = 2;
								}
							}
						}
						break;
					default:
						// Unknown curve type - delete the event
	                    delete m_ppChannelTracks[pPMsg->dwPChannel]->RemoveHead();
						ASSERT(FALSE);
						break;
	                }
                }
                else
                {
                    fKeepGoing = FALSE;
                }
            }
            pCurve->mtOriginalStart = 0;
        }
        else if( pPMsg->dwType == DMUS_PMSGT_TEMPO )
        {
	        DMUS_TEMPO_PMSG* pTempo;
            pTempo = (DMUS_TEMPO_PMSG*)pPMsg;
            MIDIEvent *pEvent = new MIDIEvent;
            if (pEvent)
            {
                double dblTempo = 60000000.0 / pTempo->dblTempo;
                DWORD dwTempo = (DWORD) dblTempo;
                pEvent->m_bStatus = 0xFF;   // Meta event marker.
                pEvent->m_bData[0] = 0x51;  // Tempo
                pEvent->m_bData[1] = 0x3;   // 3 bytes to follow.
                pEvent->m_bData[2] = (unsigned char)(dwTempo >> 16L);
                pEvent->m_bData[3] = (unsigned char)(0xFF & (dwTempo >> 8L));
                pEvent->m_bData[4] = (unsigned char)(0xFF & dwTempo);
                pEvent->m_mtTime = pTempo->mtTime;
                pEvent->m_bLength = 5;
                m_ControlTrack.AddHead(pEvent);
            }
        }
        else if( pPMsg->dwType == DMUS_PMSGT_TIMESIG )
        {
	        DMUS_TIMESIG_PMSG* pTimeSig;
            pTimeSig = (DMUS_TIMESIG_PMSG*)pPMsg;
            MIDIEvent *pEvent = new MIDIEvent;
            if (pEvent)
            {
                pEvent->m_bStatus = 0xFF;   // Meta event marker.
                pEvent->m_bData[0] = 0x58;  // Time Signature
                pEvent->m_bData[1] = 0x4;   // 4 bytes to follow.
                pEvent->m_bData[2] = (unsigned char)pTimeSig->bBeatsPerMeasure;
                DWORD dwShift = 0 ;
                DWORD dwMask  = 1 ;
                for( ;  (!(dwMask & pTimeSig->bBeat)) ; dwShift++ )
                {
                    dwMask <<= 1 ;
                }
                pEvent->m_bData[3] = (unsigned char) dwShift;
                dwMask = 768 / pTimeSig->bBeat ;
                pEvent->m_bData[4] = (unsigned char)(dwMask >> 3);
                pEvent->m_bData[5] = 8;
                pEvent->m_mtTime = pTimeSig->mtTime;
                pEvent->m_bLength = 6;
                m_ControlTrack.AddHead(pEvent);
            }
        }
        else if( pPMsg->dwType == DMUS_PMSGT_SYSEX )
        {
			DMUS_SYSEX_PMSG* pSysEx;
			pSysEx = (DMUS_SYSEX_PMSG*)pPMsg;
			if( (pSysEx->dwLen > 1) // Must have at least 0xF0 and 0xF7
			&&	(pSysEx->dwLen <= 13) )
			{
				MIDIEvent *pEvent = new MIDIEvent;
				if (pEvent)
				{
					pEvent->m_bStatus = MIDI_SYSX;
					// Skip the first 0xF0
					ASSERT( pSysEx->abData[0] == 0xF0 );
					memcpy( pEvent->m_bData, &(pSysEx->abData[1]), pSysEx->dwLen - 1 );
					pEvent->m_bLength = (BYTE)(pSysEx->dwLen - 1);
					pEvent->m_mtTime = pSysEx->mtTime;
					m_ppChannelTracks[pPMsg->dwPChannel]->AddHead(pEvent);
				}
			}
       }
    }
    LeaveCriticalSection(&m_CrSec);

	if( FAILED( pPMsg->pGraph->StampPMsg(pPMsg) ) )
    {
        return DMUS_S_FREE;
    }
    return DMUS_S_REQUEUE;
}

HRESULT STDMETHODCALLTYPE MIDISaveTool::Flush( IDirectMusicPerformance* pPerf, 
                                            DMUS_PMSG* pDMUS_PMSG,
                                            REFERENCE_TIME rt)
{
	UNREFERENCED_PARAMETER(pPerf);
	UNREFERENCED_PARAMETER(pDMUS_PMSG);
	UNREFERENCED_PARAMETER(rt);

    // this tool does not need to flush.
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\DlgTransition.h ===
#if !defined(AFX_DLGTRANSITION_H__6E01F2D4_00B0_11D2_88D2_00C04FBF8D15__INCLUDED_)
#define AFX_DLGTRANSITION_H__6E01F2D4_00B0_11D2_88D2_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgTransition.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// DlgTransition dialog

class DlgTransition : public CDialog
{
	friend class CToolbarHandler;
// Construction
public:
	DlgTransition(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(DlgTransition)
	enum { IDD = IDD_DIALOG_TRANSITION };
	CButton	m_buttonTransNothing;
	CButton	m_radioAfterPrepare;
	CButton	m_radioQuickResponse;
	CButton	m_buttonSegDefault;
	CComboBox	m_comboSegment;
	CStatic	m_staticNoMarkers;
	CButton	m_buttonBoundary;
	CStatic	m_staticAlignPrompt;
	CButton	m_radioSwitchAnyTime;
	CButton	m_radioSwitchAnyGrid;
	CButton	m_radioSwitchAnyBeat;
	CButton	m_radioSwitchAnyBar;
	CStatic	m_staticCustomIdPrompt;
	CButton	m_radioEntirePattern;
	CButton	m_radioEntireAdditional;
	CButton	m_radio1BarPattern;
	CButton	m_radio1BarAdditional;
	CSpinButtonCtrl	m_spinCustomId;
	CEdit	m_editCustomId;
	CComboBox	m_comboPattern;
	CComboBox	m_comboBoundary;
	CButton	m_buttonModulate;
	CButton	m_buttonLong;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(DlgTransition)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void UpdateSegmentAndPatternTransitionControls( void );

	ConductorTransitionOptions		m_TransitionOptions; // Transition options.

	// Generated message map functions
	//{{AFX_MSG(DlgTransition)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckLong();
	afx_msg void OnSelChangeComboPattern();
	afx_msg void OnKillFocusCustomId();
	afx_msg void OnDeltaPosCustomIdSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelChangeComboBoundary();
	afx_msg void OnCheckBoundary();
	afx_msg void OnSelchangeComboTransSegment();
	afx_msg void OnRadioEntireAdditional();
	afx_msg void OnRadioEntirePattern();
	afx_msg void OnRadioOneBarAdditional();
	afx_msg void OnRadioOneBarPattern();
	afx_msg void OnCheckModulate();
	afx_msg void OnCheckSegDefault();
	afx_msg void OnCheckTransNothing();
	afx_msg void OnRadioPrepareBtn();
	afx_msg void OnRadioInvalidateBtn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGTRANSITION_H__6E01F2D4_00B0_11D2_88D2_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\EchoMIDIInThru.cpp ===
#include "stdafx.h"
#include "OutputTool.h"
#include "cconduct.h"

extern CMIDIInputContainer* g_pMIDIInputContainer;

void UpdateLatency( DWORD dwEchoMIDIID, IDirectMusicPort **pIBasePort, DWORD *pdwBaseOutputGroup, REFERENCE_TIME rtTimeBuffer )
{
	static int nLatencyRecomputeCounter = 0;

	// Initialize the variables to return
	*pIBasePort = NULL;
	*pdwBaseOutputGroup = 0;

	IDirectMusicPort *pOutputPort;
	DWORD dwRealPChannel, dwBaseOutputGroup;
	for( DWORD dwPChannel = g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_dwPChannelBase; dwPChannel < g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_dwPChannelBase + 16; dwPChannel++ )
	{
		pOutputPort = NULL;
		if( SUCCEEDED( g_pconductor->m_pDMAudiopath->ConvertPChannel( dwPChannel, &dwRealPChannel ) )
		&&	SUCCEEDED( g_pconductor->m_pDMPerformance->PChannelInfo( dwRealPChannel,
				&pOutputPort, &dwBaseOutputGroup, NULL ) )
		&&	pOutputPort )
		{
			// If this is the information for PChannel 0, save it
			if( dwPChannel == 0 )
			{
				*pdwBaseOutputGroup = dwBaseOutputGroup;
				*pIBasePort = pOutputPort;
				pOutputPort->AddRef();
			}

			// If the latency is not set, or if it is time to check the latency
			if( (g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_rtLatencyOffset <= 0) ||
				(nLatencyRecomputeCounter <= 0) )
			{
				// Get the latency clock
				IReferenceClock *pRefClock;
				if( SUCCEEDED( pOutputPort->GetLatencyClock( &pRefClock ) ) )
				{
					// Get the latency time
					REFERENCE_TIME rtLatencyTime;
					if( SUCCEEDED( pRefClock->GetTime( &rtLatencyTime ) ) )
					{
						// Set the offset to 9/8 (112.5%) of the latency, with a minimum of the existing offset
						REFERENCE_TIME rtNewOffset = ((rtLatencyTime - rtTimeBuffer) * 9) >> 3;
						if( rtNewOffset > g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_rtLatencyOffset )
						{
							// Why is this check here?
							if( g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_rtLatencyOffset <= 10000 )
							{
								g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_rtLatencyOffset = rtNewOffset;
							}
							else
							{
								// Only allow jumps of up to 50%.
								g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_rtLatencyOffset = min( rtNewOffset, (g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_rtLatencyOffset * 3) >> 1 );
							}
							TRACE("Echo MIDI In Latency is: %I64d\n", g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_rtLatencyOffset);
						}
					}
					pRefClock->Release();
				}
			}

			// Release our pointer to the port
			pOutputPort->Release();
		}
	}

	nLatencyRecomputeCounter--;
	if( nLatencyRecomputeCounter <= 0 )
	{
		nLatencyRecomputeCounter = 10;
	}

}

void EchoBuffer( DWORD dwEchoMIDIID, IDirectMusicBuffer *pDMBuffer )
{
	ASSERT( pDMBuffer && g_pMIDIInputContainer);
	if( !pDMBuffer || !g_pMIDIInputContainer )
	{
		return;
	}

	REFERENCE_TIME rtTimeBuffer;
	pDMBuffer->GetStartTime( &rtTimeBuffer );
#ifdef VERBOSE_MIDI_INPUT_SPEW
	TRACE("Echo MIDI In Buffer start: %I64x\n", rtTimeBuffer);
#endif

	if( g_pconductor->m_pDMPerformance
	&&	g_pconductor->m_pDMAudiopath )
	{
		IDirectMusicPort *pIBasePort;
		DWORD dwBaseOutputGroup;
		UpdateLatency( dwEchoMIDIID, &pIBasePort, &dwBaseOutputGroup, rtTimeBuffer );

		// Reset the start time of the buffer to account for the worst latency
		pDMBuffer->SetStartTime( rtTimeBuffer + g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_rtLatencyOffset );

		// Reset the read pointer to the start of the buffer
		pDMBuffer->ResetReadPtr();

		DMUS_BUFFERDESC bufDesc;
		bufDesc.dwSize = sizeof(DMUS_BUFFERDESC);
		bufDesc.dwFlags = 0;
		bufDesc.guidBufferFormat = GUID_AllZeros;

		if( FAILED( pDMBuffer->GetUsedBytes( &bufDesc.cbBuffer ) ) )
		{
			bufDesc.cbBuffer = 256;
		}

		// Need to repack the buffer to play on the correct group and port
		IDirectMusicBuffer *pDMOutputBuffer = NULL;
		if( SUCCEEDED( g_pconductor->m_pDMusic->CreateMusicBuffer( &bufDesc, &pDMOutputBuffer, NULL ) ) )
		{
			DWORD dwAvailableBufferSize = bufDesc.cbBuffer;
			BYTE *pbMsg;
			REFERENCE_TIME rtTime;
			DWORD dwLength;
			DWORD dwRealPChannel;

			// The port that the current buffer is destined for
			IDirectMusicPort *pIBufferPort = NULL;

			// Reset the read pointer again (TODO: is this really necesary?)
			pDMBuffer->ResetReadPtr();

			while(  pDMOutputBuffer
				&& (pDMBuffer->GetNextEvent( &rtTime, NULL, &dwLength, &pbMsg ) == S_OK) )
			{
				// Skip empty messages
				if( dwLength == 0 )
				{
					continue;
				}

				// Initialize the group and output port
				DWORD dwOutputGroup = dwBaseOutputGroup;
				IDirectMusicPort *pIOutputPort = pIBasePort;
				if( pIOutputPort )
				{
					pIOutputPort->AddRef();
				}

				const BYTE bStatus = pbMsg[0];
				if( (dwLength < 4)
				&&	(bStatus & 0x80)
				&&	(bStatus & 0xF0) != 0xF0 )
				{
					DWORD dwMChannel;
					if( SUCCEEDED( g_pconductor->m_pDMAudiopath->ConvertPChannel( g_pMIDIInputContainer->m_aMIDIInputContainer[dwEchoMIDIID].m_dwPChannelBase + (bStatus & 0x0F), &dwRealPChannel ) )
					&&	SUCCEEDED( g_pconductor->m_pDMPerformance->PChannelInfo( dwRealPChannel,
							&pIOutputPort, &dwOutputGroup, &dwMChannel ) )
					&&	pIOutputPort )
					{
						pbMsg[0] = BYTE((bStatus & 0xF0) | BYTE(dwMChannel & 0xF));

						// If there is a base port, release it
						if( pIBasePort )
						{
							// Release the reference to the base port we added above
							pIBasePort->Release();
						}
					}
				}

				// If the current output port is NULL
				if( !pIOutputPort )
				{
					// Skip this event, since we have nowhere to send it
					continue;
				}

				// If no buffer port is assigned yet
				if( !pIBufferPort )
				{
					// Assign the current output port to the buffer port
					pIBufferPort = pIOutputPort;
				}

				// If this event needs to go to a port other than the one the buffer is
				// set up to use, send this buffer, create another one, and reset pIBufferPort
				if( pIBufferPort != pIOutputPort )
				{
					// Play pDMOutputBuffer and create a new buffer
					pIBufferPort->PlayBuffer( pDMOutputBuffer );
					pDMOutputBuffer->Release();

					// Try and create a new, empty pDMOutputBuffer
					if( FAILED( g_pconductor->m_pDMusic->CreateMusicBuffer( &bufDesc, &pDMOutputBuffer, NULL ) ) )
					{
						// Creation failed - set pDMOutputBuffer to NULL and break out of the loop
						pDMOutputBuffer = NULL;

						// Set the buffer port to NULL
						pIBufferPort = NULL;

						// Release the output port
						pIOutputPort->Release();
						break;
					}
					else
					{
						// Reset dwAvailableBufferSize
						dwAvailableBufferSize = bufDesc.cbBuffer;
					}

					pIBufferPort = pIOutputPort;
				}

				// Check if there's enough space left in pDMOutputBuffer
				if( dwAvailableBufferSize >= DMUS_EVENT_SIZE(dwLength) )
				{
					// Yes - Pack it into the output buffer
					pDMOutputBuffer->PackUnstructured( rtTime, dwOutputGroup, dwLength, pbMsg );

					// Update dwAvailableBufferSize
					dwAvailableBufferSize -= DMUS_EVENT_SIZE(dwLength);
				}
				// No - check if the message will fit in an empty buffer
				else if( DMUS_EVENT_SIZE(dwLength) <= bufDesc.cbBuffer )
				{
					// Yes - play pDMOutputBuffer and create a new buffer
					pIBufferPort->PlayBuffer( pDMOutputBuffer );
					pDMOutputBuffer->Release();

					// Try and create a new, empty pDMOutputBuffer
					if( FAILED( g_pconductor->m_pDMusic->CreateMusicBuffer( &bufDesc, &pDMOutputBuffer, NULL ) ) )
					{
						// Creation failed - set pDMOutputBuffer to NULL and break out of the loop
						pDMOutputBuffer = NULL;

						// Set the buffer port to NULL
						pIBufferPort = NULL;

						// Release the output port
						pIOutputPort->Release();
						break;
					}
					else
					{
												// Creation succeeded - pack the event into the output buffer
						pDMOutputBuffer->PackUnstructured( rtTime, dwOutputGroup, dwLength, pbMsg );

						// Reset dwAvailableBufferSize
						dwAvailableBufferSize = bufDesc.cbBuffer - DMUS_EVENT_SIZE(dwLength);
					}
				}
				else
				{
					// Message won't fit - drop it
					TRACE("EchoMIDIInThreadProc: Dropping message that is too big to fit in buffer!\n");
				}

				// Release the output port
				pIOutputPort->Release();
			}

			if( pDMOutputBuffer )
			{
				// If there is a buffer port
				if( pIBufferPort )
				{
					pIBufferPort->PlayBuffer( pDMOutputBuffer );
				}

				pDMOutputBuffer->Release();
			}
		}

		pDMBuffer->SetStartTime( rtTimeBuffer );

		if( pIBasePort )
		{
			pIBasePort->Release();
		}
	}
}

UINT AFX_CDECL EchoMIDIInThreadProc( LPVOID pParam )
{
	UNREFERENCED_PARAMETER(pParam);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if ( !g_pconductor || !g_pMIDIInputContainer )
	{
		ASSERT(FALSE);
		return UINT_MAX;    // illegal parameter
	}

	ASSERT( g_pconductor->m_pDMusic != NULL );
	//try {
	while (1)
	{
		DWORD dwRes;
		dwRes = WaitForMultipleObjects( g_pMIDIInputContainer->m_dwValidInputHandles, g_pMIDIInputContainer->m_ahMIDIInputHandles, FALSE, INFINITE );

		// If our conductor, MIDI input container, or DirectMusic pointers are invalid
		// or if the Conductor is shutting down
		// or if the MIDI input container is waiting for us to exit
		if( !g_pconductor
		||	!g_pMIDIInputContainer
		||	!g_pconductor->m_pDMusic
		||	g_pconductor->m_fShutdown
		||	g_pMIDIInputContainer->m_hEchoMIDIInputExitEvent )
		{
			// Exit the thread
			break;
		}

		// If we woke up because we were signaled
		if( (dwRes >= WAIT_OBJECT_0)
		&&	(dwRes <= WAIT_OBJECT_0 + MIDI_IN_PORTS - 1) )
		{
			// Create a music buffer
			DMUS_BUFFERDESC bufDesc;
			bufDesc.dwSize = sizeof(DMUS_BUFFERDESC);
			bufDesc.dwFlags = 0;
			bufDesc.guidBufferFormat = GUID_AllZeros;
			bufDesc.cbBuffer = 256;

			IDirectMusicBuffer *pDMBuffer = NULL;
			if( SUCCEEDED( g_pconductor->m_pDMusic->CreateMusicBuffer( &bufDesc, &pDMBuffer, NULL ) ) )
			{
				HRESULT hr = E_FAIL;

				// Enter the MIDI input critical section
				::EnterCriticalSection( &g_pMIDIInputContainer->m_csEchoMIDI );

				// Iterate through all MIDI input ports
				POSITION pos = g_pMIDIInputContainer->m_lstMIDIInPorts.GetHeadPosition();
				while( pos )
				{
					// Get the next port
					PortContainer *pPortContainer = g_pMIDIInputContainer->m_lstMIDIInPorts.GetNext( pos );

					// If there is a valid port pointer
					if( pPortContainer->m_pPort )
					{
						// Try and read from the port
						hr = pPortContainer->m_pPort->Read( pDMBuffer );

						// If there is data
						if ( hr == S_OK )
						{
							// Find which "echo" containers use this port
							for( int i=1; i < MIDI_IN_PORTS; i++)
							{
								if( (pPortContainer == g_pMIDIInputContainer->m_aMIDIInputContainer[i].m_pPortContainer)
								&&	(g_pMIDIInputContainer->m_aMIDIInputContainer[i].m_fEchoMIDI) )
								{
									// Echo the MIDI data
									EchoBuffer( i, pDMBuffer );
								}
							}

							// If this port is used for MIDI input also
							if( pPortContainer == g_pMIDIInputContainer->m_aMIDIInputContainer[0].m_pPortContainer )
							{
								// Broadcast the MIDI data
								BYTE *pbMsg;
								REFERENCE_TIME rtTime;
								DWORD dwLength;
								pDMBuffer->ResetReadPtr();
								while ( pDMBuffer->GetNextEvent( &rtTime, NULL, &dwLength, &pbMsg ) == S_OK )
								{
									// process it
									IUnknown **pp;
									BYTE bStatus = pbMsg[0];
									BYTE bData1 = pbMsg[1];
									BYTE bData2 = pbMsg[2];

									if( bStatus & 0x80 && (bStatus & 0xF0) != 0xF0 )
									{
										if( (bStatus & 0xF0) == 0x90 && bData2 == 0 )
										{
											bStatus -= 0x10;
										}
										for( pp = g_pconductor->m_vec.begin();
										pp < g_pconductor->m_vec.end(); pp++ )
										{
											if( *pp )
											{
												((IDMUSProdMidiInCPt*)(*pp))->OnMidiMsg( rtTime, bStatus, bData1, bData2 );
											}
										}
									}
								}
							}
						}
					}
				}

				// Leave the MIDI input critical section
				::LeaveCriticalSection( &g_pMIDIInputContainer->m_csEchoMIDI );

				pDMBuffer->Release();

				if ( FAILED(hr) )
				{
					TRACE("EchoMIDIInThreadProc: Read failed with %x\n", hr);
					break;
				}
			}
		}
		else if ( dwRes != WAIT_TIMEOUT )
		{
			break;
		}
	}
	/*}
	catch( ... )
	{
		TRACE("Caught exception in EchoMIDIInThreadProc. Exiting.\n");
	}*/

	if( g_pMIDIInputContainer && g_pMIDIInputContainer->m_hEchoMIDIInputExitEvent )
	{
		//TRACE("EchoMIDIInThreadProc setting event.\n");
		::SetEvent( g_pMIDIInputContainer->m_hEchoMIDIInputExitEvent );
	}

	//TRACE("EchoMIDIInThreadProc exiting.\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\MIDISave.h ===
#ifndef _MIDISAVE_H_
#define _MIDISAVE_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <dmusicc.h>
#include <dmusici.h>
#include "alist.h"

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

#define MIDI_CC_BS_MSB	0x00
#define MIDI_CC_BS_LSB	0x20

#define MIDI_CC_DATA_MSB	0x06
#define MIDI_CC_DATA_LSB	0x26
#define MIDI_CC_NRPN_LSB	0x62
#define MIDI_CC_NRPN_MSB	0x63
#define MIDI_CC_RPN_LSB	0x64
#define MIDI_CC_RPN_MSB	0x65

class MIDIEvent : public AListItem
{
public:
	MIDIEvent* GetNext()
	{
		return (MIDIEvent*)AListItem::GetNext();
	};
    MIDIEvent* GetItem(LONG lIndex) 
	{
		return (MIDIEvent*) AListItem::GetItem(lIndex);
	};
    MUSIC_TIME  m_mtTime;   // Music time this event occurs.
    BYTE        m_bStatus;  // MIDI status. FF for Meta Event.
    BYTE        m_bLength;  // How many bytes follow.
    BYTE        m_bData[12];  // Event data 
};

class MIDIList : public AList
{
public:
    MIDIList();
    ~MIDIList();
    MIDIEvent* GetHead() 
	{
		return (MIDIEvent*)AList::GetHead();
	};
    MIDIEvent* RemoveHead() 
	{
		return (MIDIEvent*)AList::RemoveHead();
	};
    MIDIEvent* GetItem(LONG lIndex) 
	{
		return (MIDIEvent*) AList::GetItem(lIndex);
	};
    void    Sort();
    void    Clear();
    DWORD   PrepToSave(MUSIC_TIME mtStartOffset, MUSIC_TIME *pmtLength);
    void    SetName(char *pName);
    HRESULT SaveTrack( FILE *file, MUSIC_TIME mtEnd );
    DWORD   CalcTrack( MUSIC_TIME mtEnd );
    short   m_nTranspose;
private:
    char * m_pName;
};

class MIDISaveTool : public IDirectMusicTool
{
public:
	MIDISaveTool();
    ~MIDISaveTool();
    HRESULT StartRecording();
    HRESULT StopRecording();
    HRESULT SetChannels(DWORD dwChannels);
    HRESULT SetChannelName(DWORD dwTrack, char *pName);
    HRESULT SaveMIDIFile(LPCTSTR pFileName, IDirectMusicSegmentState *pState, 
        BOOL fExtraMeasure, BOOL fRMID);
public:
// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicTool
	HRESULT STDMETHODCALLTYPE Init(IDirectMusicGraph* pGraph) ;
	HRESULT STDMETHODCALLTYPE GetMsgDeliveryType(DWORD* pdwDeliveryType ) ;
	HRESULT STDMETHODCALLTYPE GetMediaTypeArraySize(DWORD* pdwNumElements ) ;
	HRESULT STDMETHODCALLTYPE GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements) ;
	HRESULT STDMETHODCALLTYPE ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG) ;
	HRESULT STDMETHODCALLTYPE Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pDMUS_PMSG, REFERENCE_TIME rt) ;
private:
    HRESULT SaveMIDISong( FILE *file, MUSIC_TIME mtLength, DWORD dwTracks);
    CRITICAL_SECTION    m_CrSec;	        
	long	            m_cRef;			    // reference counter
    MIDIList **         m_ppChannelTracks;  // Array of lists, one for each PChannel
    MIDIList            m_ControlTrack;     // Control commands
    BOOL                m_fRecordEnabled;   // Must be active to allow recording.
    DWORD               m_dwChannels;       // Number of PChannels being recorded.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\OptionsToolbar.cpp ===
// OptionsToolbar.cpp : implementation file
//

#include "stdafx.h"
#include "OptionsToolbar.h"
#include "OutputTool.h"
#include "CConduct.h"
#include "DlgMIDI.h"
#include "DlgMetronome.h"
#include "Toolbar.h"
#include "TREntry.h"
#include <initguid.h>
#include "AudioPathDesigner.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern CMIDIInputContainer* g_pMIDIInputContainer;
extern TCHAR g_szPhoneyDSoundFilterName[MAX_PATH];

COptionsToolbarHandler::COptionsToolbarHandler()
{
	m_fCursorEnabled = TRUE;
	m_lCountInBars = 0;
	m_fCountOnlyOnRecord = TRUE;

	// Read the cursor state from the registry
	DWORD dwID;
	if( GetNewRegDWORD( _T("TimeCursorEnabled"), &dwID ) )
	{
		if( dwID == 0 )
		{
			m_fCursorEnabled = FALSE;
		}
	}

	// Read the number of Count-In bars from the registry
	if( GetNewRegDWORD( _T("CountInBars"), &dwID ) )
	{
		m_lCountInBars = min( dwID, 99 );
	}

	// Read whether we should only Count-In on Record from the registry
	if( GetNewRegDWORD( _T("CountInOnlyOnRecord"), &dwID ) )
	{
		if( dwID == 0 )
		{
			m_fCountOnlyOnRecord = FALSE;
		}
	}
}

COptionsToolbarHandler::~COptionsToolbarHandler()
{
	m_font.DeleteObject();
}

BOOL COptionsToolbarHandler::SetBtnState( int nID, UINT nState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( ::IsWindow( m_hWndToolbar ) )
	{
		return ::SendMessage( m_hWndToolbar, TB_SETSTATE, nID, MAKELONG(nState, 0) );
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// COptionsToolbarHandler IDMUSProdToolBar::GetInfo

HRESULT COptionsToolbarHandler::GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( (phWndOwner == NULL)
	||	(phInstance == NULL)
	||	(pnResourceId == NULL)
	||	(pbstrTitle == NULL) )
	{
		return E_POINTER;
	}

	*phWndOwner = m_hWnd;
	*phInstance = _Module.GetResourceInstance();
	*pnResourceId = (UINT)-1;  // we are going to build the toolbar from scratch

	CString strTitle;
	strTitle.LoadString(IDS_OPTIONSTOOLBAR_TITLE);
	*pbstrTitle = strTitle.AllocSysString();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// COptionsToolbarHandler IDMUSProdToolBar::GetMenuText

HRESULT COptionsToolbarHandler::GetMenuText( BSTR* pbstrText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrText == NULL )
	{
		return E_POINTER;
	}

	CString strText;
	strText.LoadString(IDS_OPTIONSTOOLBAR_MENUTEXT);
	*pbstrText = strText.AllocSysString();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// COptionsToolbarHandler IDMUSProdToolBar::GetMenuHelpText

HRESULT COptionsToolbarHandler::GetMenuHelpText( BSTR* pbstrMenuHelpText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrMenuHelpText == NULL )
	{
		return E_POINTER;
	}

	CString strMenuHelpText;
	strMenuHelpText.LoadString(IDS_OPTIONSTOOLBAR_HELP);
	*pbstrMenuHelpText = strMenuHelpText.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// COptionsToolbarHandler IDMUSProdToolBar::Initialize

HRESULT COptionsToolbarHandler::Initialize( HWND hWndToolBar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( hWndToolBar == NULL )
	{
		return E_INVALIDARG;
	}
	m_hWndToolbar = hWndToolBar;
 
	CToolBarCtrl* pToolBarCtrl = new CToolBarCtrl;
	if( pToolBarCtrl == NULL )
	{
		return E_OUTOFMEMORY;
	}

	pToolBarCtrl->Attach( hWndToolBar );
	pToolBarCtrl->AddBitmap( 10, IDB_Transport );

	// Create font for Audiopath combo box
	CClientDC* pDC = new CClientDC( pToolBarCtrl );

	int nHeight = -( (pDC->GetDeviceCaps(LOGPIXELSY) * 8) / 72 );

	CString strFontName;
	if( strFontName.LoadString( IDS_TOOLBAR_FONT ) == 0)
	{
		strFontName = _T("MS Sans Serif");
	}
	m_font.CreateFont( nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,
		DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
		DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, strFontName );
	
	CFont* pOldFont = pDC->SelectObject( &m_font );
	
	TEXTMETRIC tm;
	pDC->GetTextMetrics( &tm );
	int cxChar = tm.tmAveCharWidth;
	int cyChar = tm.tmHeight + tm.tmExternalLeading;

	pDC->SelectObject( pOldFont );
	delete pDC;

	TBBUTTON button;
	button.dwData = 0;
	button.iString = NULL;

	// 4 - Options
	button.iBitmap = 4;
	button.idCommand = ID_TRANSP_OPT;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton( 0, &button );

	// 3 - MIDI
	button.iBitmap = 3;
	button.idCommand = ID_TRANSP_MIDI;
	button.fsState = TBSTATE_INDETERMINATE;
	button.fsStyle = TBSTYLE_CHECK;
	pToolBarCtrl->InsertButton( 0, &button );

	// 2 - Cursor
	button.iBitmap = 7;
	button.idCommand = ID_TRANSP_CURSOR;
	button.fsState = BYTE(m_fCursorEnabled ? TBSTATE_ENABLED | TBSTATE_CHECKED : TBSTATE_ENABLED);
	button.fsStyle = TBSTYLE_CHECK;
	pToolBarCtrl->InsertButton( 0, &button );

	// 1 - Metronome
	button.iBitmap = 6;
	button.idCommand = ID_TRANSP_METRONOME;
	button.fsState = BYTE(g_pconductor->m_fMetronomeEnabled ? TBSTATE_ENABLED | TBSTATE_CHECKED : TBSTATE_ENABLED);
	button.fsStyle = TBSTYLE_CHECK;
	pToolBarCtrl->InsertButton( 0, &button );

	// 0 - Separator for Audiopath combobox
	button.iBitmap = cxChar * 30;
	button.idCommand = ID_TRANSP_AUDIOPATH;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	pToolBarCtrl->InsertButton( 0, &button );

	// Attach the Audiopath combobox
	CRect rect;
	pToolBarCtrl->GetItemRect( 0, &rect );
	rect.bottom = rect.top + (cyChar * 21);
	if( !m_comboAudiopath.Create(WS_CHILD | WS_VISIBLE | WS_VSCROLL |
		CBS_DROPDOWNLIST | CBS_SORT,
		rect, pToolBarCtrl, ID_TRANSP_AUDIOPATH) )
	{
		return -1;
	}
	m_comboAudiopath.SetFont( &m_font );
	m_comboAudiopath.EnableWindow(TRUE);

	UpdateComboBoxFromConductor();

	if( pToolBarCtrl )
	{
		pToolBarCtrl->Detach();
		delete pToolBarCtrl;
	}

	return S_OK;
}

void COptionsToolbarHandler::UpdateComboBoxFromConductor( void )
{
	while( m_comboAudiopath.GetCount() > 0 )
	{
		m_comboAudiopath.DeleteString( 0 );
	}

	if( g_pconductor->m_pAudiopathListItem
	&&	!g_pconductor->m_pAudiopathListItem->strName.IsEmpty() )
	{
		// Add the text to the combo box
		int nStringIndex = m_comboAudiopath.AddString( g_pconductor->m_pAudiopathListItem->strName );

		// Set the combobox item to point to nothing
		m_comboAudiopath.SetItemDataPtr( nStringIndex, NULL );

		// Set the current selection to this item
		m_comboAudiopath.SetCurSel( nStringIndex );
	}
	else
	{
		// Load the 'No default audiopath' string
		CString strNone;
		if( strNone.LoadString( IDS_NO_AUDIOPATH ) )
		{
			// Add the text to the combo box
			int nStringIndex = m_comboAudiopath.AddString( strNone );

			// Set the combobox item to point to nothing
			m_comboAudiopath.SetItemDataPtr( nStringIndex, NULL );

			// Set the current selection to this item
			m_comboAudiopath.SetCurSel( nStringIndex );
		}
	}
}

LRESULT COptionsToolbarHandler::OnMidiClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( g_pconductor->m_fOutputEnabled )
	{
		g_pconductor->SuspendOutput();
		SetBtnState( ID_TRANSP_MIDI, TBSTATE_ENABLED );
	}
	else {
		g_pconductor->ResumeOutput();
		SetBtnState( ID_TRANSP_MIDI, TBSTATE_ENABLED | TBSTATE_CHECKED );
	}

	if( g_pconductor->m_pToolbarHandler )
	{
		g_pconductor->m_pToolbarHandler->SetStateAuto();
	}

	return TRUE;
}

LRESULT COptionsToolbarHandler::OnOptionsClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	DlgMIDI dlg;
	dlg.m_dwLatency = g_pconductor->m_dwLatency;
	dlg.m_fLatencyAppliesToAllAudioPaths = g_pconductor->m_fLatencyAppliesToAllAudiopaths;

	dlg.m_dwSampleRate = g_pconductor->m_dwSampleRate;
	dlg.m_dwVoices = g_pconductor->m_dwVoices;
	dlg.m_clsidDefaultSynth = g_pconductor->m_clsidDefaultSynth;

	dlg.m_fDownloadGM = g_pconductor->m_fDownloadGM;
	dlg.m_fDownloadDLS = g_pconductor->m_fDownloadDLS;

	dlg.m_fUsePhoneyDSound = g_pconductor->m_fUsePhoneyDSound;
	strcpy( dlg.m_strPhoneyFilterName, g_szPhoneyDSoundFilterName );

	if( IDCANCEL == dlg.DoModal() )
	{
		return TRUE;
	}


	if( g_pMIDIInputContainer )
	{
		g_pMIDIInputContainer->UpdateRegistry();

		g_pMIDIInputContainer->RestartMIDIInThreadIfNecessary();
	}

	// Set 'Echo MIDI In' Output PChannel group
	if( dlg.m_dwLatency != g_pconductor->m_dwLatency
	||	dlg.m_fLatencyAppliesToAllAudioPaths != g_pconductor->m_fLatencyAppliesToAllAudiopaths )
	{
		// Set 'Latency' value
		g_pconductor->m_dwLatency = dlg.m_dwLatency;
		SetNewRegDWORD(_T("Latency"), g_pconductor->m_dwLatency, TRUE);

		// Set 'Update Latency' state
		g_pconductor->m_fLatencyAppliesToAllAudiopaths = dlg.m_fLatencyAppliesToAllAudioPaths;
		SetNewRegDWORD(_T("ApplyLatencyToAllAudioPaths"), g_pconductor->m_fLatencyAppliesToAllAudiopaths, TRUE);

		g_pconductor->UpdateLatency();
	}

	if( g_pconductor->m_fDownloadGM != dlg.m_fDownloadGM )
	{
		// Set download GM flag
		g_pconductor->m_fDownloadGM = dlg.m_fDownloadGM;
		SetNewRegDWORD(_T("DownloadGM"), g_pconductor->m_fDownloadGM, TRUE);

		g_pconductor->DownOrUnLoadGM();
	}


	if( g_pconductor->m_fDownloadDLS != dlg.m_fDownloadDLS )
	{
		// Set download DLS flag
		g_pconductor->m_fDownloadDLS = dlg.m_fDownloadDLS;
		SetNewRegDWORD(_T("DownloadDLS"), g_pconductor->m_fDownloadDLS, TRUE);

		g_pconductor->DownOrUnLoadDLS();
	}

	if( dlg.m_dwSampleRate != g_pconductor->m_dwSampleRate
	||	dlg.m_clsidDefaultSynth != g_pconductor->m_clsidDefaultSynth
	||	dlg.m_dwVoices != g_pconductor->m_dwVoices
	||	dlg.m_fUsePhoneyDSound != g_pconductor->m_fUsePhoneyDSound
	||	strcmp( dlg.m_strPhoneyFilterName, g_szPhoneyDSoundFilterName) != 0 )
	{
		// Set 'Sample Rate' value
		g_pconductor->m_dwSampleRate = dlg.m_dwSampleRate;
		SetNewRegDWORD(_T("SampleRate"), g_pconductor->m_dwSampleRate, TRUE);

		// Set 'Voices' value
		g_pconductor->m_dwVoices = dlg.m_dwVoices;
		SetNewRegDWORD(_T("Voices"), g_pconductor->m_dwVoices, TRUE);

		// Set 'Default Synth' value
		LPOLESTR psz;
		g_pconductor->m_clsidDefaultSynth = dlg.m_clsidDefaultSynth;
		if( SUCCEEDED( StringFromIID(g_pconductor->m_clsidDefaultSynth, &psz) ) )
		{
			TCHAR szGuid[MAX_PATH];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );
			SetNewRegString( _T("DMDefaultPort"), szGuid );
		}

		// Set 'Use Phoney DSound' value
		bool fChangedPhoneyDSound = (g_pconductor->m_fUsePhoneyDSound != dlg.m_fUsePhoneyDSound);
		g_pconductor->UsePhoneyDSound( dlg.m_fUsePhoneyDSound );
		SetNewRegDWORD(_T("UsePhoneyDSound"), g_pconductor->m_fUsePhoneyDSound ? 1 : 0, TRUE);

		// Set 'Default Synth' value
		strcpy( g_szPhoneyDSoundFilterName, dlg.m_strPhoneyFilterName );
		SetNewRegString( _T("PhoneyDSoundDefaultPort"), g_szPhoneyDSoundFilterName );

		// If we changed to use Phoney DSound, ensure that the latency value the user
		// set is actually used
		bool fOrigLatencyAppliesToAllAudiopaths = g_pconductor->m_fLatencyAppliesToAllAudiopaths;
		if( fChangedPhoneyDSound
		&&	dlg.m_fUsePhoneyDSound )
		{
			g_pconductor->m_fLatencyAppliesToAllAudiopaths = true;
		}

		// Now, re-initialize the performance
		g_pconductor->UpdateAudioSettings();

		// Reset m_fLatencyAppliesToAllAudiopaths to its initial value
		if( fChangedPhoneyDSound
		&&	dlg.m_fUsePhoneyDSound )
		{
			g_pconductor->m_fLatencyAppliesToAllAudiopaths = fOrigLatencyAppliesToAllAudiopaths;
		}
	}

	return TRUE;
}

CWndClassInfo& COptionsToolbarHandler::GetWndClassInfo()
{
	static CWndClassInfo wc =
	{
		{ sizeof(WNDCLASSEX), CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, StartWindowProc,
		  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, NULL, 0 },
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
	};
	return wc;
}


LRESULT COptionsToolbarHandler::OnRightClick(WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	//TRACE("%x %x %x %x\n",wNotifyCode, pNMHDR->hwndFrom,pNMHDR->idFrom,pNMHDR->code);

	// Get the cursor position (To put the menu there)
	POINT ptScreen, ptClient;
	BOOL  bResult;
	bResult = ::GetCursorPos( &ptScreen );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	ptClient = ptScreen;
	bResult = ::ScreenToClient( pNMHDR->hwndFrom, &ptClient );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	if( ::IsWindow( m_hWndToolbar ) )
	{
		CRect rect;
		// Metronome is 1st item.
		::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 1, (LPARAM) &rect );

		if( rect.PtInRect( ptClient ) )
		{
			DlgMetronome dlg;
			dlg.m_lCountInBars = m_lCountInBars;
			dlg.m_fCountOnlyOnRecord = m_fCountOnlyOnRecord;
			if( IDOK == dlg.DoModal() )
			{
				g_pconductor->m_bMetronomeVelocityOne = dlg.m_bOneVelocity;
				g_pconductor->m_bMetronomeNoteOne = dlg.m_bOneValue;
				g_pconductor->m_bMetronomeVelocityOther = dlg.m_bOtherVelocity;
				g_pconductor->m_bMetronomeNoteOther = dlg.m_bOtherValue;
				g_pconductor->m_dwMetronomePChannel = dlg.m_dwPChannel;
				
				SetNewRegDWORD( _T("MetronomeVelocity"), g_pconductor->m_bMetronomeVelocityOther, TRUE );
				SetNewRegDWORD( _T("MetronomeNote"), g_pconductor->m_bMetronomeNoteOther, TRUE );
				SetNewRegDWORD( _T("MetronomeOneVelocity"), g_pconductor->m_bMetronomeVelocityOne, TRUE );
				SetNewRegDWORD( _T("MetronomeOneNote"), g_pconductor->m_bMetronomeNoteOne, TRUE );
				SetNewRegDWORD( _T("MetronomePChannel"), g_pconductor->m_dwMetronomePChannel, TRUE );

				m_lCountInBars = dlg.m_lCountInBars;
				m_fCountOnlyOnRecord = dlg.m_fCountOnlyOnRecord;

				SetNewRegDWORD( _T("CountInBars"), m_lCountInBars, TRUE );
				SetNewRegDWORD( _T("CountInOnlyOnRecord"), m_fCountOnlyOnRecord, TRUE );
			}
		}
		else
		{
			// MIDI Options is 4th Item
			::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 4, (LPARAM) &rect );

			if( rect.PtInRect( ptClient ) )
			{
				OnOptionsClicked( wNotifyCode, ID_TRANSP_OPT, pNMHDR->hwndFrom, bHandled );
			}
		}
	}

	return TRUE;
}

LRESULT COptionsToolbarHandler::OnMetronomeClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( g_pconductor->m_fMetronomeEnabled )
	{
		g_pconductor->m_fMetronomeEnabled = FALSE;
		SetBtnState( ID_TRANSP_METRONOME, TBSTATE_ENABLED );
	}
	else {
		g_pconductor->m_fMetronomeEnabled = TRUE;
		SetBtnState( ID_TRANSP_METRONOME, TBSTATE_ENABLED | TBSTATE_CHECKED );
	}

	// Save the state in the registry
	SetNewRegDWORD( _T("MetronomeEnabled"), g_pconductor->m_fMetronomeEnabled, TRUE );

	return TRUE;
}

LRESULT COptionsToolbarHandler::OnCursorClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ITransportRegEntry *pDisplayedRegEntry = g_pconductor->GetDisplayedTransport();

	if( g_pconductor->m_pToolbarHandler == NULL )
	{
		return FALSE;
	}

	if ( !g_pconductor->m_pToolbarHandler->IsValid( pDisplayedRegEntry ) )
	{
		return FALSE;
	}

	IDMUSProdTransport*  pITransport = NULL;
	pDisplayedRegEntry->GetTransport( &pITransport );
	if( !pITransport )
	{
		return FALSE;
	}

	if( m_fCursorEnabled )
	{
		m_fCursorEnabled = FALSE;
		SetBtnState( ID_TRANSP_CURSOR, TBSTATE_ENABLED );
	}
	else
	{
		m_fCursorEnabled = TRUE;
		SetBtnState( ID_TRANSP_CURSOR, TBSTATE_ENABLED | TBSTATE_CHECKED );
	}

	pITransport->TrackCursor( m_fCursorEnabled );

	// Write the state to the registry
	SetNewRegDWORD(_T("TimeCursorEnabled"), m_fCursorEnabled, TRUE);

	return TRUE;
}

// Structure for validating an interface pointer. 
//
struct _V_GENERIC_INTERFACE
{
    FARPROC *(__vptr[1]);
};

LRESULT COptionsToolbarHandler::OnCloseUpComboAudiopath( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	int nIndex = m_comboAudiopath.GetCurSel();
	if( nIndex >= 0 )
	{
		CAudiopathListItem *pAudiopathListItem = static_cast<CAudiopathListItem *>(m_comboAudiopath.GetItemDataPtr( nIndex ));
		if( pAudiopathListItem != g_pconductor->m_pAudiopathListItem)
		{
			// Stop everything to get rid of stuck notes
			g_pconductor->StopAllNotesAndSegments();
			Sleep( 100 );	// Necessary so unload of waves will not fail

			// Display an hourglass cursor
			CWaitCursor waitCursor;

			// Save a pointer to the old Audiopath
			CAudiopathListItem *pOldAudiopathListItem = g_pconductor->m_pAudiopathListItem;

			// Broadcast the WaveUnload notification
			if( g_pconductor->m_pDMAudiopath )
			{
				g_pconductor->BroadCastWaveNotification( GUID_ConductorUnloadWaves );

				// Send the port removal notification
				g_pconductor->BroadCastPortRemovalNotification();

				// If we were previously using an audiopath from a node, set the old audio path
				// to be inactive
		 		if( g_pconductor->m_pAudiopathListItem
				&&	g_pconductor->m_pAudiopathListItem->pNode )
				{
					// Try and get the IDMUSProdAudioPathInUse interface for the node
					IDMUSProdAudioPathInUse *pIDMUSProdAudiopathInUse;
					if( SUCCEEDED( g_pconductor->m_pAudiopathListItem->pNode->QueryInterface( IID_IDMUSProdAudioPathInUse, (void **)&pIDMUSProdAudiopathInUse ) ) )
					{
						// Notify the Audiopath that it is no longer in use
						pIDMUSProdAudiopathInUse->UsingAudioPath( g_pconductor->m_pDMAudiopath, FALSE );
						pIDMUSProdAudiopathInUse->Release();
					}

					// Remove from the audiopath's notification list
					g_pconductor->m_pFrameWork->RemoveFromNotifyList( g_pconductor->m_pAudiopathListItem->pNode, g_pconductor );
				}
			}

			// Remove the existing audiopath - this ensures that the 'shared'
			// buffers are created properly
			g_pconductor->ActivateAudiopath( NULL );

			// Initialize the ListItem pointer to NULL
			g_pconductor->m_pAudiopathListItem = NULL;

			IDirectMusicAudioPath *pAudiopath;
			HRESULT hr = g_pconductor->CreateAudiopath( pAudiopathListItem, &pAudiopath );
			if( SUCCEEDED( hr )
			&&	pAudiopath )
			{
				// Activate the Audio path
				hr = g_pconductor->ActivateAudiopath( pAudiopath );

				// If we succeeded
				if( SUCCEEDED( hr ) )
				{
#ifdef DMP_XBOX
                    g_pconductor->ActivateXboxPath( pAudiopathListItem->dwXboxID );
#endif
					// If we created an Audiopath from the node, set the new audiopath as active
					if( pAudiopathListItem
					&&	pAudiopathListItem->pNode )
					{
						// Try and get the IDMUSProdAudioPathInUse interface for the node
						IDMUSProdAudioPathInUse *pIDMUSProdAudiopathInUse;
						if( SUCCEEDED( pAudiopathListItem->pNode->QueryInterface( IID_IDMUSProdAudioPathInUse, (void **)&pIDMUSProdAudiopathInUse ) ) )
						{
							// Notify the Audiopath that it now in use
							pIDMUSProdAudiopathInUse->UsingAudioPath( pAudiopath, TRUE );
							pIDMUSProdAudiopathInUse->Release();
						}

						// Add us to the audiopath's notification list
						g_pconductor->m_pFrameWork->AddToNotifyList( pAudiopathListItem->pNode, g_pconductor );
					}

					// Update the Concductor with information about the new audio path
					g_pconductor->m_pAudiopathListItem = pAudiopathListItem;

					// Broadcast the WaveDownload notification
					g_pconductor->BroadCastWaveNotification( GUID_ConductorDownloadWaves );

					// Notify all other components that output has been changed
					// Need to do this even if activation failed, so that the other components
					// can reset their port lists
					g_pconductor->BroadCastPortChangeNotification();
				}

				// Release our pointer to the new audio path
				if( pAudiopath )
				{
					pAudiopath->Release();
				}
			}

			if( FAILED( hr ) )
			{
				// Try and create the old audiopath
				hr = g_pconductor->CreateAudiopath( pOldAudiopathListItem, &pAudiopath );
				if( SUCCEEDED( hr ) )
				{
					// Activate the Audio path
					hr = g_pconductor->ActivateAudiopath( pAudiopath );

					// If we succeeded
					if( SUCCEEDED( hr ) )
					{
						// If we created an Audiopath from the node, set the new audiopath as active
						if( pOldAudiopathListItem
						&&	pOldAudiopathListItem->pNode )
						{
							// Try and get the IDMUSProdAudioPathInUse interface for the node
							IDMUSProdAudioPathInUse *pIDMUSProdAudiopathInUse;
							if( SUCCEEDED( pOldAudiopathListItem->pNode->QueryInterface( IID_IDMUSProdAudioPathInUse, (void **)&pIDMUSProdAudiopathInUse ) ) )
							{
								// Notify the Audiopath that it now in use
								pIDMUSProdAudiopathInUse->UsingAudioPath( pAudiopath, TRUE );
								pIDMUSProdAudiopathInUse->Release();
							}

							// Add us to the audiopath's notification list
							g_pconductor->m_pFrameWork->AddToNotifyList( pOldAudiopathListItem->pNode, g_pconductor );
						}

						// Update the Concductor with information about the new audio path
						g_pconductor->m_pAudiopathListItem = pOldAudiopathListItem;

						// Broadcast the WaveDownload notification
						g_pconductor->BroadCastWaveNotification( GUID_ConductorDownloadWaves );

						// Notify all other components that output has been changed
						// Need to do this even if activation failed, so that the other components
						// can reset their port lists
						g_pconductor->BroadCastPortChangeNotification();
					}

					// Release our pointer to the new audio path
					if( pAudiopath )
					{
						pAudiopath->Release();
					}
				}
			}

			// Update the transport toolbar
			if( g_pconductor->m_pToolbarHandler )
			{
				g_pconductor->m_pToolbarHandler->UpdateActiveFromEngine();
				g_pconductor->m_pToolbarHandler->SetStateAuto();
			}
		}
	}

	// Remove all items from the combo box, then add and select the Audiopath used by the conductor
	UpdateComboBoxFromConductor();

	return TRUE;
}

LRESULT COptionsToolbarHandler::OnDropDownComboAudiopath( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	while( m_comboAudiopath.GetCount() > 0 )
	{
		m_comboAudiopath.DeleteString( 0 );
	}

	// Iterate through all registered audiopaths
	POSITION pos = g_pconductor->m_lstAudiopaths.GetHeadPosition();
	while( pos )
	{
		CAudiopathListItem *pAPListItem = g_pconductor->m_lstAudiopaths.GetNext( pos );

		// Add the text to the combo box
		int nStringIndex = m_comboAudiopath.AddString( pAPListItem->strName );

		// Create a new AudiopathListItem to store information about this Audiopath in
		// Set the combobox item to point to this AudiopathListItem
		m_comboAudiopath.SetItemDataPtr( nStringIndex, pAPListItem );

		// Check if this item is the current Audiopath
		if( pAPListItem == g_pconductor->m_pAudiopathListItem )
		{
			m_comboAudiopath.SetCurSel( nStringIndex );
		}
	}

	// Load the 'No default audiopath' string
	CString strNone;
	if( strNone.LoadString( IDS_NO_AUDIOPATH ) )
	{
		// Add the text to the combo box
		int nStringIndex = m_comboAudiopath.AddString( strNone );

		// Set the combobox item to point to nothing
		m_comboAudiopath.SetItemDataPtr( nStringIndex, NULL );

		// Check if this item is the current Audiopath
		if( NULL == g_pconductor->m_pAudiopathListItem )
		{
			m_comboAudiopath.SetCurSel( nStringIndex );
		}
	}

	return TRUE;
}

LRESULT COptionsToolbarHandler::OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
	UNREFERENCED_PARAMETER(nMsg);
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	while( m_comboAudiopath.GetCount() > 0 )
	{
		m_comboAudiopath.DeleteString( 0 );
	}

	lResult = FALSE;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\notify.cpp ===
// Implementation of CNotifySink

#include "stdafx.h"
#include "CConduct.h"
#include "Toolbar.h"
#include "SecondaryToolbar.h"
#include "OutputTool.h"
//#include <fstream.h>
#include "StatusToolbar.h"
#include "WaveRecordToolbar.h"
#include "..\WaveSaveDmo\testdmo.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

extern CMIDIInputContainer* g_pMIDIInputContainer;
extern void EchoBuffer( IDirectMusicBuffer *pDMBuffer );

/*
struct _V_GENERIC_INTERFACE
{
    FARPROC *(__vptr[1]);
};
*/

//extern ofstream ofsMessageOutput;

//#define VERBOSE_MIDI_INPUT_SPEW

/*
HRESULT SendMIDIOutMessage( IDirectMusicPerformance *pPerformance, DWORD dwPChannel, REFERENCE_TIME rtNow, BYTE bStatus, BYTE bByte1, BYTE bByte2 )
{
	if( g_pMIDIInputContainer && g_pMIDIInputContainer->m_fThruingMIDI )
	{
		ASSERT( pPerformance );

		HRESULT hr;
		DMUS_PMSG *pPipelineEvent = NULL;
		DMUS_MIDI_PMSG *pDMMidiEvent = NULL;

		// Allocate MIDI message
		hr = pPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pDMMidiEvent );
		if ( FAILED(hr) )
		{
			return hr;
		}
		memset( pDMMidiEvent, 0, sizeof(DMUS_MIDI_PMSG) );

		pDMMidiEvent->bStatus = bStatus;
		pDMMidiEvent->bByte1 = bByte1;
		pDMMidiEvent->bByte2 = bByte2;
		pDMMidiEvent->rtTime = rtNow;
		pDMMidiEvent->dwFlags = DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_REFTIME;
		pDMMidiEvent->dwPChannel = dwPChannel;
		//pDMMidiEvent->dwVirtualTrackID = 0;
		pDMMidiEvent->dwType = DMUS_PMSGT_MIDI;
		pDMMidiEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
		pPipelineEvent = (DMUS_PMSG*) pDMMidiEvent;

		//char cLine[200];
		//sprintf( cLine, "PMSG: %x %x %x %I64d\n", bStatus, bByte1, bByte2, rtNow);
		//ofsMessageOutput<<cLine;
		return pPerformance->SendPMsg( pPipelineEvent );
	}
	return S_OK;
}
*/


bool IsAudiopathPerformanceDefault( const IDirectMusicAudioPath *pIDirectMusicAudioPath )
{
	IDirectMusicAudioPath *pPerfIDirectMusicAudioPath;
	if( SUCCEEDED( g_pconductor->m_pDMPerformance->GetDefaultAudioPath( &pPerfIDirectMusicAudioPath ) ) )
	{
		if( pPerfIDirectMusicAudioPath )
		{
			pPerfIDirectMusicAudioPath->Release();
		}

		if( pIDirectMusicAudioPath == pPerfIDirectMusicAudioPath )
		{
			return true;
		}
	}

	return false;
}

bool AudiopathHasWaveSaveDMO( IDirectMusicAudioPath *pIDirectMusicAudioPath )
{
	if( pIDirectMusicAudioPath == NULL )
	{
		return false;
	}

	if( IsAudiopathPerformanceDefault( pIDirectMusicAudioPath ) )
	{
		return false;
	}

	bool fResult = false;
	IDirectSoundBuffer *pIDirectSoundBuffer;
	DWORD dwBufferIndex = 0;
	while( !fResult
		&&	(S_OK == pIDirectMusicAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER, dwBufferIndex,
					GUID_All_Objects, 0, IID_IDirectSoundBuffer, (void**) &pIDirectSoundBuffer )) )
	{
		IDump* pIDump = NULL;
		DWORD dwDMOIndex = 0;
		while( !fResult
			&&	(S_OK == pIDirectMusicAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER_DMO, dwBufferIndex,
						GUID_DSFX_STANDARD_DUMP, dwDMOIndex, IID_IDump, (void**) &pIDump )) )
		{
			fResult = true;
			dwDMOIndex++;
			pIDump->Release();
		}

		dwBufferIndex++;
		pIDirectSoundBuffer->Release();
	}
	dwBufferIndex = 0;
	while( !fResult
		&&	(S_OK == pIDirectMusicAudioPath->GetObjectInPath( 0, DMUS_PATH_MIXIN_BUFFER, dwBufferIndex,
					GUID_All_Objects, 0, IID_IDirectSoundBuffer, (void**) &pIDirectSoundBuffer )) )
	{
		IDump* pIDump = NULL;
		DWORD dwDMOIndex = 0;
		while( !fResult
			&&	(S_OK == pIDirectMusicAudioPath->GetObjectInPath( 0, DMUS_PATH_MIXIN_BUFFER_DMO, dwBufferIndex,
						GUID_DSFX_STANDARD_DUMP, dwDMOIndex, IID_IDump, (void**) &pIDump )) )
		{
			fResult = true;
			dwDMOIndex++;
			pIDump->Release();
		}

		dwBufferIndex++;
		pIDirectSoundBuffer->Release();
	}

	return fResult;
}

void AddToolsAndSetupWaveSaveForSegState( IUnknown *punk )
{
	IDirectMusicSegmentState8 *pIDirectMusicSegmentState8;
	if( punk
	&&	SUCCEEDED( punk->QueryInterface( IID_IDirectMusicSegmentState8, (void**)&pIDirectMusicSegmentState8 ) ) )
	{
		IDirectMusicAudioPath *pIDirectMusicAudioPath;
		if( SUCCEEDED( pIDirectMusicSegmentState8->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH, 0, GUID_All_Objects, 0, IID_IDirectMusicAudioPath, (void **)&pIDirectMusicAudioPath ) ) )
		{
			if( !IsAudiopathPerformanceDefault( pIDirectMusicAudioPath ) )
			{
				if( AudiopathHasWaveSaveDMO( pIDirectMusicAudioPath ) )
				{
					SegStateAudioPath *pSegStateAudioPath = new SegStateAudioPath( pIDirectMusicAudioPath, pIDirectMusicSegmentState8 );
					if( pSegStateAudioPath )
					{
						::EnterCriticalSection( &g_pconductor->m_csAudiopathList );
						POSITION pos = g_pconductor->m_lstSegStateAudioPaths.GetHeadPosition();
						while( pos )
						{
							if( g_pconductor->m_lstSegStateAudioPaths.GetNext( pos )->pSegmentState == pIDirectMusicSegmentState8 )
							{
								delete pSegStateAudioPath;
								pSegStateAudioPath = NULL;
								break;
							}
						}

						if( pSegStateAudioPath )
						{
							g_pconductor->SetupWaveSaveDMO( pIDirectMusicAudioPath );
							g_pconductor->m_lstSegStateAudioPaths.AddTail( pSegStateAudioPath );
						}
						::LeaveCriticalSection( &g_pconductor->m_csAudiopathList );
					}
				}
				g_pconductor->AddToolsToSegState( pIDirectMusicSegmentState8, g_pconductor->m_pOutputTool, g_pconductor->m_pMIDISaveTool );
			}
			pIDirectMusicAudioPath->Release();
		}
		pIDirectMusicSegmentState8->Release();
	}
}

long g_lMaxNotifyThreads = 10;

UINT AFX_CDECL NotifyThreadProc( LPVOID pParam )
{
	UNREFERENCED_PARAMETER(pParam);
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( g_pconductor == NULL )
	{
		ASSERT(FALSE);
		return UINT_MAX;    // illegal parameter
	}

	BOOL fInCritSeq = FALSE;

	ASSERT( g_pconductor->m_hNotifyEvent != NULL );
	ASSERT( g_pconductor->m_pDMPerformance != NULL );
	try {
	while (1)
	{
		DWORD dwRes;
		dwRes = WaitForSingleObject( g_pconductor->m_hNotifyEvent, INFINITE );
		if ( !g_pconductor || !g_pconductor->m_hNotifyEvent ||
			 !g_pconductor->m_pDMPerformance || g_pconductor->m_fShutdown )
		{
			//TRACE("NotifyThreadProc: pointer NULL!.\n");
			break;
		}
		if ( (dwRes == WAIT_OBJECT_0) || (dwRes == WAIT_TIMEOUT) )
		{
			DMUS_NOTIFICATION_PMSG *pNotificationMsg = NULL;
			HRESULT hr;
			do
			{
				// Assuming that IDirectMusicPerformance::GetNotificationEvent is thread safe.
				hr = g_pconductor->m_pDMPerformance->GetNotificationPMsg( &pNotificationMsg );
				if ( hr == S_OK )
				{
					ASSERT( pNotificationMsg != NULL );
					if ( pNotificationMsg->dwType == DMUS_PMSGT_NOTIFICATION)
					{
						// Check if this is a Segment notification, we're not in a transition, and 
						// the music stopped.
						if ( g_pconductor && g_pconductor->m_pToolbarHandler &&
							InlineIsEqualGUID( pNotificationMsg->guidNotificationType, GUID_NOTIFICATION_SEGMENT ) )
						{
							/*
							MUSIC_TIME mtNow;
							REFERENCE_TIME rtNow;
							g_pconductor->m_pDMPerformance->GetTime( &rtNow, &mtNow );
							char szDebug[512];
							sprintf( szDebug, "Segment Notification %d for %x received at %ld | %I64d for time %ld | %I64d\n",
								pNotificationMsg->dwNotificationOption, pNotificationMsg->punkUser,
								mtNow, rtNow, pNotificationMsg->mtTime, pNotificationMsg->rtTime );
							OutputDebugString(szDebug);
							*/
							if( (pNotificationMsg->dwNotificationOption == DMUS_NOTIFICATION_SEGEND) ||
								(pNotificationMsg->dwNotificationOption == DMUS_NOTIFICATION_SEGABORT) )
							{
								IDirectMusicSegmentState8 *pIDirectMusicSegmentState8;
								if( pNotificationMsg->punkUser
								&&	SUCCEEDED( pNotificationMsg->punkUser->QueryInterface( IID_IDirectMusicSegmentState8, (void **)&pIDirectMusicSegmentState8 ) ) )
								{
									::EnterCriticalSection( &g_pconductor->m_csAudiopathList );
									POSITION pos = g_pconductor->m_lstSegStateAudioPaths.GetHeadPosition();
									while( pos )
									{
										const POSITION posToDelete = pos;
										SegStateAudioPath *pSegStateAudioPath = g_pconductor->m_lstSegStateAudioPaths.GetNext( pos );
										if( pSegStateAudioPath->pSegmentState == pIDirectMusicSegmentState8 )
										{
											delete pSegStateAudioPath;
											pSegStateAudioPath = NULL;
											g_pconductor->m_lstSegStateAudioPaths.RemoveAt( posToDelete );
										}
									}
									::LeaveCriticalSection( &g_pconductor->m_csAudiopathList );
									pIDirectMusicSegmentState8->Release();
								}

								POSITION pos = g_pconductor->m_lstSecondaryToolbars.GetHeadPosition();
								while( pos )
								{
									CSecondaryToolbarHandler *pToolbarHandler = g_pconductor->m_lstSecondaryToolbars.GetNext( pos );
									pToolbarHandler->OnSegEndNotify( pNotificationMsg->punkUser );
									::PostMessage( pToolbarHandler->m_hWndToolbar, WM_COMMAND, (WPARAM) MAKELONG( 0, ID_SET_STATE_AUTO ), (LPARAM) g_pconductor->m_pToolbarHandler->m_hWndToolbar );
								}
								::PostMessage( g_pconductor->m_pToolbarHandler->m_hWndToolbar, WM_COMMAND, (WPARAM) MAKELONG( 0, ID_SET_STATE_AUTO ), (LPARAM) g_pconductor->m_pToolbarHandler->m_hWndToolbar );

								// If it exists, redraw the status toolbar
								if( g_pconductor->m_pStatusToolbarHandler )
								{
									g_pconductor->m_pStatusToolbarHandler->RefreshAllButtons();
								}

								if( g_pconductor->m_pWaveRecordToolbar )
								{
									g_pconductor->m_pWaveRecordToolbar->PostMessage( WM_USER + 3, NULL, NULL );
								}
							}
							else if( pNotificationMsg->dwNotificationOption == DMUS_NOTIFICATION_SEGSTART )
							{
								POSITION pos = g_pconductor->m_lstSecondaryToolbars.GetHeadPosition();
								while( pos )
								{
									CSecondaryToolbarHandler *pToolbarHandler = g_pconductor->m_lstSecondaryToolbars.GetNext( pos );
									pToolbarHandler->OnSegStartNotify( pNotificationMsg->punkUser );
									::PostMessage( pToolbarHandler->m_hWndToolbar, WM_COMMAND, (WPARAM) MAKELONG( 0, ID_SET_STATE_AUTO ), (LPARAM) g_pconductor->m_pToolbarHandler->m_hWndToolbar );
								}
								::PostMessage( g_pconductor->m_pToolbarHandler->m_hWndToolbar, WM_COMMAND, (WPARAM) MAKELONG( 0, ID_SET_STATE_AUTO ), (LPARAM) g_pconductor->m_pToolbarHandler->m_hWndToolbar );
							}
							else
							{
								::PostMessage( g_pconductor->m_pToolbarHandler->m_hWndToolbar, WM_COMMAND, (WPARAM) MAKELONG( 0, ID_SET_STATE_AUTO ), (LPARAM) g_pconductor->m_pToolbarHandler->m_hWndToolbar );
							}
						}
						// Removed code that automatically resets Play/Stop when we receive a
						// MusicStopped notification.  It was too unreliable.  Transports are now
						// responsible for calling IDMUSProdConductor::TransportStopped(..) when they stop
						// playing by a means other than hitting the Stop or Transition buttons.

						// do the multicast
						::EnterCriticalSection( &g_pconductor->m_csNotifyEntry );
						fInCritSeq = TRUE;

						CNotifyEntry* pNotifyEntry = NULL;
						BOOL fFound = FALSE;
						POSITION pos;
						pos = g_pconductor->m_lstNotifyEntry.GetHeadPosition();
						while ( pos != NULL && !fFound )
						{
							pNotifyEntry = g_pconductor->m_lstNotifyEntry.GetNext( pos );
							if ( InlineIsEqualGUID( pNotifyEntry->m_guid, pNotificationMsg->guidNotificationType ) )
							{
								fFound = TRUE;
								ConductorNotifyEvent cnEvent;
								cnEvent.m_cbSize = sizeof( pNotificationMsg );
								cnEvent.m_dwType = pNotificationMsg->dwType;
								cnEvent.m_pbData = (BYTE *)pNotificationMsg;

								POSITION pos2;
								IDMUSProdNotifyCPt *pINotifyCPt;
								pos2 = pNotifyEntry->m_lstNotifyCPt.GetHeadPosition();
								while ( pos2 != NULL )
								{
									pINotifyCPt = pNotifyEntry->m_lstNotifyCPt.GetAt( pos2 );
									if ( pINotifyCPt != NULL )
									/*
									if ( !IsBadReadPtr(pINotifyCPt, sizeof(_V_GENERIC_INTERFACE))
									&&	 !IsBadReadPtr(*reinterpret_cast<_V_GENERIC_INTERFACE*>(pINotifyCPt)->__vptr, sizeof(FARPROC))
									&&	 !IsBadCodePtr(*(reinterpret_cast<_V_GENERIC_INTERFACE*>(pINotifyCPt)->__vptr)[0]) )
									*/
									{
										pINotifyCPt->OnNotify( &cnEvent );
									}
									else
									{
										ASSERT( FALSE );
									}
									pNotifyEntry->m_lstNotifyCPt.GetNext( pos2 );
								}
							}
						}

						::LeaveCriticalSection( &g_pconductor->m_csNotifyEntry );
						fInCritSeq = FALSE;
					}
					g_pconductor->m_pDMPerformance->FreePMsg( (DMUS_PMSG *)pNotificationMsg );
					pNotificationMsg = NULL;
				}
			} while ( hr == S_OK );
			if ( FAILED(hr) )
			{
				TRACE("NotifyThreadProc: GetNotifyEvent failed with %x\n", hr);
				break;
			}
		}
		else
		{
			TRACE("NotifyThreadProc: break out early.\n");
			break;
		}
		// Go back and WaitForSingleObject again.
	}
	}
	catch( ... )
	{
		TRACE("Caught exception in NotifyThreadProc. Exiting.\n");
	}

	//TRACE("NotifyThreadProc setting event.\n");

	if( fInCritSeq )
	{
		::LeaveCriticalSection( &g_pconductor->m_csNotifyEntry );
	}

	if( g_pconductor && g_pconductor->m_hNotifyExitEvent )
	{
		::SetEvent( g_pconductor->m_hNotifyExitEvent );
	}

	//TRACE("NotifyThreadProc exiting.\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\OutputTool.cpp ===
// Implementation of COutputTool and CMIDIInputContainer

#include "stdafx.h"
#include "OutputTool.h"
#include "cconduct.h"
#include "StatusToolbar.h"
#include "Toolbar.h"

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0

#define LATENCY_CUTOFF_MS 60

extern UINT AFX_CDECL EchoMIDIInThreadProc( LPVOID pParam );
IDirectMusicPort *g_rpLastSampledPort;
static REFERENCE_TIME s_rtLastSampledLatency;

// Defined in notify.cpp
extern void AddToolsAndSetupWaveSaveForSegState( IUnknown *punk );

// Constructor/Desctructor
COutputTool::COutputTool()
{
	m_cRef = 0;
	AddRef();
	
	// Initially allocate for 32 channels
	m_afActivePChannels.SetSize( 32 );
	m_afMute.SetSize( 32 );
	m_alPChannelStates.SetSize( 32 );
	m_alPChannelNoteOnStates.SetSize( 32 );
	m_abPChannelNoteOn.SetSize( 32 );
//	ofsOutput.open("OutputFile.txt");
}

COutputTool::~COutputTool()
{
//	ofsOutput.close();
}

// IUnknown
HRESULT STDMETHODCALLTYPE COutputTool::QueryInterface( const IID &iid, void **ppv )
{
    if( ::IsEqualIID( iid, IID_IDirectMusicTool )  ||
		::IsEqualIID( iid, IID_IUnknown ) )
	{
		*ppv = static_cast<IDirectMusicTool *>(this);
	}
	else  {
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	static_cast<IUnknown *>(*ppv)->AddRef();
	return S_OK;
}

ULONG STDMETHODCALLTYPE COutputTool::AddRef()
{
	return InterlockedIncrement( &m_cRef );
}

ULONG STDMETHODCALLTYPE COutputTool::Release()
{
	if( InterlockedDecrement( &m_cRef ) == 0 )
	{
		delete this;
		return 0;
	}
	return m_cRef;
}

// IDirectMusicTool methods
HRESULT STDMETHODCALLTYPE COutputTool::Init(
	IDirectMusicGraph* pGraph) 
{
	UNREFERENCED_PARAMETER(pGraph);
	// This tool has no need to do any type of initialization.
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE COutputTool::GetMsgDeliveryType(
	DWORD* pdwDeliveryType )
{
	// This tool wants messages just before their time stamp occurs.
	*pdwDeliveryType = DMUS_PMSGF_TOOL_QUEUE;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE COutputTool::GetMediaTypeArraySize(
	DWORD* pdwNumElements )
{
	// This tool only wants note messages, MIDI messages, user messages, 
	// wave messages, and Notification messages; for manbugs 45192, we'll also
    // have the tool take curves. So, set *pdwNumElements to 6.
	*pdwNumElements = 6;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE COutputTool::GetMediaTypes(
	DWORD** padwMediaTypes, 
	DWORD dwNumElements)
{
	// Fill in the array padwMediaTypes with the type of
	// messages this tool wants to process. In this case,
	// dwNumElements will be 6, since that is what this
	// tool returns from GetMediaTypeArraySize().

	if( dwNumElements == 6 )
	{
		(*padwMediaTypes)[0] = DMUS_PMSGT_NOTE;
		(*padwMediaTypes)[1] = DMUS_PMSGT_MIDI;
		(*padwMediaTypes)[2] = DMUS_PMSGT_USER;
		(*padwMediaTypes)[3] = DMUS_PMSGT_NOTIFICATION;
		(*padwMediaTypes)[4] = DMUS_PMSGT_WAVE;
        (*padwMediaTypes)[5] = DMUS_PMSGT_CURVE;
		return S_OK;
	}
	else
	{
		// this should never happen
		return E_FAIL;
	}
}

HRESULT STDMETHODCALLTYPE COutputTool::ProcessPMsg(
	IDirectMusicPerformance* pPerf, 
	DMUS_PMSG* pPMsg)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// The Tool is set up to only receive messages of types
	// DMUS_PMSGT_NOTE, DMUS_PMSGT_MIDI, DMUS_PMSGT_WAVE, DMUS_PMSGT_NOTIFICATION, and DMUS_PMSGT_USER

	// Check if this is a "user" message
	if( pPMsg->dwType == DMUS_PMSGT_USER )
	{
		// Ensure this is our user message
		if( pPMsg->punkUser == this )
		{
			DMUS_MIDI_PMSG* pMidi = (DMUS_MIDI_PMSG*) pPMsg;
			if( pMidi->bStatus == MIDI_NOTEON )
			{
				//ofsOutput<<"On,  "<<pPMsg->dwPChannel<<","<<pPMsg->mtTime<<"\n";
				m_alPChannelStates[pPMsg->dwPChannel] += pMidi->bByte2;
				m_alPChannelNoteOnStates[pPMsg->dwPChannel] += pMidi->bByte2;
				m_abPChannelNoteOn[pPMsg->dwPChannel] = 1;
			}
			else if( pMidi->bStatus == MIDI_NOTEOFF )
			{
				//ofsOutput<<"Off, "<<pPMsg->dwPChannel<<","<<pPMsg->mtTime<<"\n";
				m_alPChannelStates[pPMsg->dwPChannel] -= pMidi->bByte2;
			}
			else
			{
				ASSERT(0);
			}
			return DMUS_S_FREE;
		}
		else
		{
			// returning S_FREE frees the message. If StampPMsg()
			// fails, there is no destination for this message so
			// free it.
			if(( NULL == pPMsg->pGraph ) ||
				FAILED(pPMsg->pGraph->StampPMsg(pPMsg)))
			{
				TRACE("OutputTool freeing user message - StampPMsg failed.\n");
				return DMUS_S_FREE;
			}
			return DMUS_S_REQUEUE;
		}
	}

	// Need to save the original PChannel, since StampPMsg will change it
	const DWORD dwOrigPChannel = pPMsg->dwPChannel;

	// returning S_FREE frees the message. If StampPMsg()
	// fails, there is no destination for this message so
	// free it.
	if( (NULL == pPMsg->pGraph)
	||	FAILED(pPMsg->pGraph->StampPMsg(pPMsg)))
	{
		//TRACE("OutputTool freeing message - StampPMSG failed. Type %d.\n", pPMsg->dwType);
		return DMUS_S_FREE;
	}

	// Ignore broadcast messages
	if( dwOrigPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS )
	{
		// Send the message on to the next tool
		return DMUS_S_REQUEUE;
	}

	// Handle metronome events
	if( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
	{
		DMUS_NOTIFICATION_PMSG* pNotification = (DMUS_NOTIFICATION_PMSG*) pPMsg;
		if(  g_pconductor->m_fMetronomeEnabled &&
			( pNotification->guidNotificationType == GUID_NOTIFICATION_MEASUREANDBEAT) && 
			( pNotification->dwNotificationOption == DMUS_NOTIFICATION_MEASUREBEAT ) &&
			( pPMsg->mtTime >= g_pconductor->m_pToolbarHandler->m_mtPlayTime ) )
		{
			//TRACE("Received MeasureBeat notification %d,%d at %d. punkUser=%x.\n", pNotification->dwField1, pNotification->dwField2, pPMsg->mtTime, pPMsg->punkUser );

			IDirectMusicSegmentState *pSegmentState = NULL;
			if( FAILED( g_pconductor->m_pDMPerformance->GetSegmentState( &pSegmentState, pPMsg->mtTime ) ) )
			{
				// Send the message on to the next tool
				return DMUS_S_REQUEUE;
			}
			
			RELEASE( pSegmentState );

			DMUS_MIDI_PMSG* pOnMidiMsg, *pOffMidiMsg;
			if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pOnMidiMsg )) &&
				SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pOffMidiMsg )) )
			{
				memset( pOnMidiMsg, 0, sizeof(DMUS_MIDI_PMSG) );
				memset( pOffMidiMsg, 0, sizeof(DMUS_MIDI_PMSG) );
				// MIDI_NOTEOFF = 0x80, MIDI_NOTEON = 0x90
				pOnMidiMsg->dwSize = sizeof(DMUS_MIDI_PMSG);
				pOnMidiMsg->bStatus = 0x90;
				pOnMidiMsg->mtTime = pNotification->mtTime;
				pOnMidiMsg->dwFlags = DMUS_PMSGF_MUSICTIME;
				pOnMidiMsg->dwPChannel = g_pconductor->m_dwMetronomePChannel;
				pOnMidiMsg->dwType = DMUS_PMSGT_MIDI;

				pOffMidiMsg->dwSize = sizeof(DMUS_MIDI_PMSG);
				pOffMidiMsg->bStatus = 0x80;
				pOffMidiMsg->mtTime = pNotification->mtTime + (DMUS_PPQ / 4);
				pOffMidiMsg->dwFlags = DMUS_PMSGF_MUSICTIME;
				pOffMidiMsg->dwPChannel = g_pconductor->m_dwMetronomePChannel;
				pOffMidiMsg->dwType = DMUS_PMSGT_MIDI;

				// Determine which PChannel the metronome should play on
				IDirectMusicSegmentState8 *pIDirectMusicSegmentState8;
				if( pNotification->punkUser
				&&	SUCCEEDED( pNotification->punkUser->QueryInterface( IID_IDirectMusicSegmentState8, (void **)&pIDirectMusicSegmentState8 ) ) )
				{
					IDirectMusicAudioPath *pIDirectMusicAudioPath;
					if( SUCCEEDED( pIDirectMusicSegmentState8->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH, 0, GUID_All_Objects, 0, IID_IDirectMusicAudioPath, (void **)&pIDirectMusicAudioPath ) ) )
					{
						pIDirectMusicAudioPath->ConvertPChannel( pOnMidiMsg->dwPChannel, &pOnMidiMsg->dwPChannel );
						pIDirectMusicAudioPath->ConvertPChannel( pOffMidiMsg->dwPChannel, &pOffMidiMsg->dwPChannel );
						pIDirectMusicAudioPath->Release();
					}
					pIDirectMusicSegmentState8->Release();
				}

				if( pNotification->dwField1 == 0 )
				{
					pOnMidiMsg->bByte1 = g_pconductor->m_bMetronomeNoteOne;
					pOnMidiMsg->bByte2 = g_pconductor->m_bMetronomeVelocityOne;
					pOffMidiMsg->bByte1 = g_pconductor->m_bMetronomeNoteOne;
					pOffMidiMsg->bByte2 = g_pconductor->m_bMetronomeVelocityOne;
				}
				else
				{
					pOnMidiMsg->bByte1 = g_pconductor->m_bMetronomeNoteOther;
					pOnMidiMsg->bByte2 = g_pconductor->m_bMetronomeVelocityOther;
					pOffMidiMsg->bByte1 = g_pconductor->m_bMetronomeNoteOther;
					pOffMidiMsg->bByte2 = g_pconductor->m_bMetronomeVelocityOther;
				}

				pPerf->SendPMsg( (DMUS_PMSG*)pOnMidiMsg );
				pPerf->SendPMsg( (DMUS_PMSG*)pOffMidiMsg );
			}
		}

		// Send the message on to the next tool
		return DMUS_S_REQUEUE;
	}

	// Add the buttons, if necessary
	if( ((pPMsg->dwType == DMUS_PMSGT_MIDI) && ((((DMUS_MIDI_PMSG*)pPMsg)->bStatus & 0xF0) == MIDI_NOTEON))
	||	((pPMsg->dwType == DMUS_PMSGT_NOTE) && (((DMUS_NOTE_PMSG*)pPMsg)->bFlags & DMUS_NOTEF_NOTEON))
	||	((pPMsg->dwType == DMUS_PMSGT_WAVE) && !(((DMUS_NOTE_PMSG*)pPMsg)->bFlags & DMUS_WAVEF_OFF)) )
	{
		if( (dwOrigPChannel >= (unsigned)m_afMute.GetSize())
		||	!m_afActivePChannels[ dwOrigPChannel ] )
		{
			AddNew( dwOrigPChannel );
		}
	}

	// If this channel should be muted
	if( (dwOrigPChannel < (unsigned)m_afMute.GetSize())
	&&	m_afMute[ dwOrigPChannel ] )
	{
		//Fix 19688: Eat Note on events, but let all other events flow through.
		if( pPMsg->dwType == DMUS_PMSGT_MIDI )
		{
			DMUS_MIDI_PMSG* pMidi = (DMUS_MIDI_PMSG*) pPMsg;
			if( (pMidi->bStatus & 0xF0) == MIDI_NOTEON )
			{
				return DMUS_S_FREE;
			}
		}
		else if( pPMsg->dwType == DMUS_PMSGT_NOTE )
		{
			DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*) pPMsg;
			if( pNote->bFlags & DMUS_NOTEF_NOTEON )
			{
				return DMUS_S_FREE;
			}
		}
		else if( pPMsg->dwType == DMUS_PMSGT_WAVE )
		{
			DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*) pPMsg;
			if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
			{
				return DMUS_S_FREE;
			}
		}
	}

	if( pPMsg->dwType == DMUS_PMSGT_MIDI )
	{
		DMUS_MIDI_PMSG* pMidi = (DMUS_MIDI_PMSG*) pPMsg;
		if( (pMidi->bStatus & 0xF0) == MIDI_NOTEON )
		{
			ASSERT( dwOrigPChannel < (unsigned)m_afMute.GetSize() );
			ASSERT( m_afActivePChannels[ dwOrigPChannel ] );

			m_alPChannelStates[dwOrigPChannel] += pMidi->bByte2;
			m_alPChannelNoteOnStates[dwOrigPChannel] += pMidi->bByte2;
			m_abPChannelNoteOn[dwOrigPChannel] = 1;
		}
		else if( ((pMidi->bStatus & 0xF0) == MIDI_NOTEOFF)
			 &&  (dwOrigPChannel < (unsigned)m_alPChannelStates.GetSize()) )
		{
			m_alPChannelStates[dwOrigPChannel] -= pMidi->bByte2;
		}
		else
		{
			// Let all other MIDI messages flow through
			//TRACE("MIDI - \t - \t - %2.2x %2.2x %2.2x\n", dwOrigPChannel, pMidi->bStatus, pMidi->bByte1);
		}
	}

	if( pPMsg->dwType == DMUS_PMSGT_WAVE )
	{
		DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*) pPMsg;
		if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
		{
			ASSERT( dwOrigPChannel < (unsigned)m_afMute.GetSize() );
			ASSERT( m_afActivePChannels[ dwOrigPChannel ] );

			DMUS_MIDI_PMSG* pOnMidiMsg, *pOffMidiMsg;
			if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
				(DMUS_PMSG**)&pOnMidiMsg )) &&
				SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
				(DMUS_PMSG**)&pOffMidiMsg )))
			{
				// copy the original note into this message
				memcpy( pOnMidiMsg, pPMsg, sizeof(DMUS_PMSG) );
				memcpy( pOffMidiMsg, pPMsg, sizeof(DMUS_PMSG) );
				pOnMidiMsg->dwPChannel = dwOrigPChannel;
				pOffMidiMsg->dwPChannel = dwOrigPChannel;
				pOnMidiMsg->pTool	 = (IDirectMusicTool*)this;
				pOffMidiMsg->pTool	 = (IDirectMusicTool*)this;
				pOnMidiMsg->pTool->AddRef();
				pOffMidiMsg->pTool->AddRef();
				if( pOnMidiMsg->pGraph ) pOnMidiMsg->pGraph->AddRef();
				if( pOffMidiMsg->pGraph ) pOffMidiMsg->pGraph->AddRef();
				pOnMidiMsg->punkUser = NULL;
				pOffMidiMsg->punkUser= NULL;
				pOnMidiMsg->dwSize	 = sizeof(DMUS_MIDI_PMSG);
				pOffMidiMsg->dwSize  = sizeof(DMUS_MIDI_PMSG);
				pOnMidiMsg->dwType	 = DMUS_PMSGT_USER;
				pOffMidiMsg->dwType  = DMUS_PMSGT_USER;
				pOnMidiMsg->bStatus	 = MIDI_NOTEON;
				pOffMidiMsg->bStatus = MIDI_NOTEOFF;
				pOnMidiMsg->bByte2	 = 100;
				pOffMidiMsg->bByte2  = 100;
				pOnMidiMsg->dwFlags	 = DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME;
				if( pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME )
				{
					pOffMidiMsg->rtTime += pWave->rtDuration;
					pOffMidiMsg->dwFlags = DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_REFTIME;
				}
				else
				{
					pOffMidiMsg->mtTime += long(min( LONG_MAX, pWave->rtDuration ));
					pPerf->MusicToReferenceTime( pOffMidiMsg->mtTime, &pOffMidiMsg->rtTime );
					pOffMidiMsg->dwFlags = DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME;
				}

				pOnMidiMsg->punkUser = this;
				AddRef();
				pOffMidiMsg->punkUser = this;
				AddRef();

				pPerf->SendPMsg( (DMUS_PMSG*)pOnMidiMsg );
				pPerf->SendPMsg( (DMUS_PMSG*)pOffMidiMsg );
			}
		}
	}

	if( pPMsg->dwType == DMUS_PMSGT_NOTE )
	{
		DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*) pPMsg;
		if( pNote->bFlags & DMUS_NOTEF_NOTEON )
		{
			ASSERT( dwOrigPChannel < (unsigned)m_afMute.GetSize() );
			ASSERT( m_afActivePChannels[ dwOrigPChannel ] );

			DMUS_MIDI_PMSG* pOnMidiMsg, *pOffMidiMsg;
			if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
				(DMUS_PMSG**)&pOnMidiMsg )) &&
				SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
				(DMUS_PMSG**)&pOffMidiMsg )))
			{
				// copy the original note into this message
				memcpy( pOnMidiMsg, pPMsg, sizeof(DMUS_PMSG) );
				memcpy( pOffMidiMsg, pPMsg, sizeof(DMUS_PMSG) );
				pOnMidiMsg->dwPChannel = dwOrigPChannel;
				pOffMidiMsg->dwPChannel = dwOrigPChannel;
				pOnMidiMsg->pTool	 = (IDirectMusicTool*)this;
				pOffMidiMsg->pTool	 = (IDirectMusicTool*)this;
				pOnMidiMsg->pTool->AddRef();
				pOffMidiMsg->pTool->AddRef();
				if( pOnMidiMsg->pGraph ) pOnMidiMsg->pGraph->AddRef();
				if( pOffMidiMsg->pGraph ) pOffMidiMsg->pGraph->AddRef();
				pOnMidiMsg->punkUser = NULL;
				pOffMidiMsg->punkUser= NULL;
				pOnMidiMsg->dwSize	 = sizeof(DMUS_MIDI_PMSG);
				pOffMidiMsg->dwSize  = sizeof(DMUS_MIDI_PMSG);
				pOnMidiMsg->dwType	 = DMUS_PMSGT_USER;
				pOffMidiMsg->dwType  = DMUS_PMSGT_USER;
				pOnMidiMsg->bStatus	 = MIDI_NOTEON;
				pOffMidiMsg->bStatus = MIDI_NOTEOFF;
				pOnMidiMsg->bByte2	 = pNote->bVelocity;
				pOffMidiMsg->bByte2  = pNote->bVelocity;
				pOnMidiMsg->dwFlags	 = DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_REFTIME;
				pOffMidiMsg->mtTime += pNote->mtDuration;
				pPerf->MusicToReferenceTime( pOffMidiMsg->mtTime, &pOffMidiMsg->rtTime );
				pOffMidiMsg->dwFlags = DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_REFTIME;

				pOnMidiMsg->punkUser = this;
				AddRef();
				pOffMidiMsg->punkUser = this;
				AddRef();

				pPerf->SendPMsg( (DMUS_PMSG*)pOnMidiMsg );
				pPerf->SendPMsg( (DMUS_PMSG*)pOffMidiMsg );
			}
		}
	}

	// return DMUS_S_REQUEUE so the original message is requeued
	return DMUS_S_REQUEUE;
}

HRESULT STDMETHODCALLTYPE COutputTool::Flush(
	IDirectMusicPerformance* pPerf, 
	DMUS_PMSG* pPMsg,
	REFERENCE_TIME rt)
{
	UNREFERENCED_PARAMETER(rt);
	UNREFERENCED_PARAMETER(pPerf);

	// Check if this is a "user" message
	if( pPMsg->dwType == DMUS_PMSGT_USER )
	{
		DMUS_MIDI_PMSG* pMidi = (DMUS_MIDI_PMSG*) pPMsg;
		if( pMidi->bStatus == MIDI_NOTEON )
		{
			//ofsOutput<<"FOn, "<<pPMsg->dwPChannel<<","<<pPMsg->mtTime<<"\n";
			m_alPChannelStates[pPMsg->dwPChannel] += pMidi->bByte2;
			m_alPChannelNoteOnStates[pPMsg->dwPChannel] += pMidi->bByte2;
			m_abPChannelNoteOn[pPMsg->dwPChannel] = 1;
		}
		else if( pMidi->bStatus == MIDI_NOTEOFF )
		{
			//ofsOutput<<"FOff, "<<pPMsg->dwPChannel<<","<<pPMsg->mtTime<<"\n";
			m_alPChannelStates[pPMsg->dwPChannel] -= pMidi->bByte2;
		}
		else
		{
			ASSERT(0);
		}
		return DMUS_S_FREE;
	}

	// returning S_FREE frees the message. If StampPMsg()
	// fails, there is no destination for this message so
	// free it.
	if(( NULL == pPMsg->pGraph ) ||
		FAILED(pPMsg->pGraph->StampPMsg(pPMsg)))
	{
		return DMUS_S_FREE;
	}
	return DMUS_S_REQUEUE;
}

void COutputTool::SetPChannelMute( DWORD dwPChannel, BOOL fMute )
{
	ASSERT( !m_afMute.GetSize() ? FALSE : dwPChannel < (unsigned)m_afMute.GetSize() );
	if( m_afMute.GetSize()
	&& (dwPChannel < (unsigned)m_afMute.GetSize()) )
	{
		m_afMute[ dwPChannel ] = fMute;
	}
}

BOOL COutputTool::GetPChannelMute( DWORD dwPChannel )
{
	ASSERT( !m_afMute.GetSize() ? FALSE : dwPChannel < (unsigned)m_afMute.GetSize() );
	if( m_afMute.GetSize()
	&& (dwPChannel < (unsigned)m_afMute.GetSize()) )
	{
		return m_afMute[ dwPChannel ];
	}
	return FALSE;
}

void COutputTool::AddNew( DWORD dwPChannel )
{
	const DWORD dwOldSize = (unsigned) m_afActivePChannels.GetSize();

	// Check if we're already active
	if( dwPChannel < dwOldSize
	&&	m_afActivePChannels[dwPChannel] == TRUE )
	{
		return;
	}

	BOOL fMute = TRUE;
	int nNumUnMuted = 0;
	int nNumActive = 0;
	for( DWORD dwIndex = 0; dwIndex < dwOldSize; dwIndex ++ )
	{
		if( m_afActivePChannels[dwIndex] )
		{
			nNumActive++;
			if( !m_afMute[dwIndex] )
			{
				nNumUnMuted++;
				if( nNumUnMuted > 1 )
				{
					fMute = FALSE;
					break;
				}
			}
		}
	}

	if( fMute && (nNumActive <= 1) && (nNumUnMuted <= 1) )
	{
		// Only one PChannel active, and it's unmuted
		fMute = FALSE;
	}

	if( dwPChannel >= dwOldSize )
	{
		dwPChannel++;
		m_afMute.SetSize( dwPChannel );
		m_afActivePChannels.SetSize( dwPChannel );
		m_alPChannelStates.SetSize( dwPChannel );
		m_alPChannelNoteOnStates.SetSize( dwPChannel );
		m_abPChannelNoteOn.SetSize( dwPChannel );
		/* Not necessary - SetSize calls ConstructElements, which sets all bits
		   of the new values to 0.
		for( dwIndex = dwOldSize; dwIndex < dwPChannel; dwIndex++ )
		{
			m_afMute[dwIndex] = FALSE;
			m_afActivePChannels[dwIndex] = FALSE;
			m_alPChannelStates[dwIndex] = 0;
			m_alPChannelNoteOnStates[dwIndex] = 0;
			m_abPChannelNoteOn[dwIndex] = 0;
		}
		*/
		dwPChannel--;
	}

	m_afActivePChannels[dwPChannel] = TRUE;
	m_afMute[dwPChannel] = fMute;

	if( g_pconductor->m_pStatusToolbarHandler
	&&	g_pconductor->m_pStatusToolbarHandler->m_hWndToolbar )
	{
		::PostMessage( g_pconductor->m_pStatusToolbarHandler->m_hWndToolbar,
					   WM_COMMAND, MAKELONG( dwPChannel, ID_ADD_BUTTON ),
					   (LPARAM) g_pconductor->m_pStatusToolbarHandler->m_hWndToolbar );
	}
}

void COutputTool::MarkAllChannelsUnused( void )
{
	for( int i=0; i < m_afActivePChannels.GetSize(); i++ )
	{
		m_afMute[i] = FALSE;
		m_afActivePChannels[i] = FALSE;
	}
}

/*
class CAbortTracker : public IUnknown
{
public:
	CAbortTracker()
	{
		m_cRef = 0;
		AddRef();
	}
	~CAbortTracker()
	{
	}

	// IUnknown methods
	virtual STDMETHODIMP QueryInterface( const IID &iid, void **ppv )
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	virtual STDMETHODIMP_(ULONG) AddRef()
	{
		return InterlockedIncrement( &m_cRef );
	}
	virtual STDMETHODIMP_(ULONG) Release()
	{
		AfxDumpStack(AFX_STACK_DUMP_TARGET_TRACE);
		if( InterlockedDecrement( &m_cRef ) == 0 )
		{
			delete this;
			return 0;
		}
		return m_cRef;
	}

protected:
	LONG	m_cRef;
};
*/

// Constructor/Desctructor
CNotifyTool::CNotifyTool()
{
	m_cRef = 0;
	AddRef();
}

CNotifyTool::~CNotifyTool()
{
}

// IUnknown
HRESULT STDMETHODCALLTYPE CNotifyTool::QueryInterface( const IID &iid, void **ppv )
{
    if( ::IsEqualIID( iid, IID_IDirectMusicTool )  ||
		::IsEqualIID( iid, IID_IUnknown ) )
	{
		*ppv = static_cast<IDirectMusicTool *>(this);
	}
	else  {
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	static_cast<IUnknown *>(*ppv)->AddRef();
	return S_OK;
}

ULONG STDMETHODCALLTYPE CNotifyTool::AddRef()
{
	return InterlockedIncrement( &m_cRef );
}

ULONG STDMETHODCALLTYPE CNotifyTool::Release()
{
	if( InterlockedDecrement( &m_cRef ) == 0 )
	{
		delete this;
		return 0;
	}
	return m_cRef;
}

// IDirectMusicTool methods
HRESULT STDMETHODCALLTYPE CNotifyTool::Init(
	IDirectMusicGraph* pGraph) 
{
	UNREFERENCED_PARAMETER(pGraph);
	// This tool has no need to do any type of initialization.
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CNotifyTool::GetMsgDeliveryType(
	DWORD* pdwDeliveryType )
{
	// This tool wants messages as soon as possible
	*pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNotifyTool::GetMediaTypeArraySize(
	DWORD* pdwNumElements )
{
	// This tool only wants Notification messages, so set *pdwNumElements to 1.
	*pdwNumElements = 1;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CNotifyTool::GetMediaTypes(
	DWORD** padwMediaTypes, 
	DWORD dwNumElements)
{
	// Fill in the array padwMediaTypes with the type of
	// messages this tool wants to process. In this case,
	// dwNumElements will be 5, since that is what this
	// tool returns from GetMediaTypeArraySize().

	if( dwNumElements == 1 )
	{
		(*padwMediaTypes)[0] = DMUS_PMSGT_NOTIFICATION;
		return S_OK;
	}
	else
	{
		// this should never happen
		return E_FAIL;
	}
}

HRESULT STDMETHODCALLTYPE CNotifyTool::ProcessPMsg(
	IDirectMusicPerformance* pPerf, 
	DMUS_PMSG* pPMsg)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(pPerf);

	// The Tool is set up to only receive messages of type
	// DMUS_PMSGT_NOTIFICATION

	// returning S_FREE frees the message. If StampPMsg()
	// fails, there is no destination for this message so
	// free it.
	if( (NULL == pPMsg->pGraph)
	||	FAILED(pPMsg->pGraph->StampPMsg(pPMsg)))
	{
		//TRACE("OutputTool freeing message - StampPMSG failed. Type %d.\n", pPMsg->dwType);
		return DMUS_S_FREE;
	}

	// Handle metronome events
	if( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
	{
		DMUS_NOTIFICATION_PMSG* pNotification = (DMUS_NOTIFICATION_PMSG*) pPMsg;
		if( pNotification->guidNotificationType == GUID_NOTIFICATION_SEGMENT )
		{
			/*
			MUSIC_TIME mtNow;
			REFERENCE_TIME rtNow;
			pPerf->GetTime( &rtNow, &mtNow );
			TRACE("Segment Notification message %d for %x received at %ld | %I64d for time %ld | %I64d\n",
				pNotification->dwNotificationOption, pNotification->punkUser,
				mtNow, rtNow, pNotification->mtTime, pNotification->rtTime );
			*/
			if( pNotification->dwNotificationOption == DMUS_NOTIFICATION_SEGSTART )
			{
				AddToolsAndSetupWaveSaveForSegState( pNotification->punkUser );
			}
			/*
			else if( pNotification->dwNotificationOption == DMUS_NOTIFICATION_SEGABORT )
			{
				CAbortTracker *pAbortTracker = new CAbortTracker;
				if( pNotification->punkUser )
				{
					pNotification->punkUser->Release();
				}
				pNotification->punkUser = pAbortTracker;
			}
			*/
		}

		// Send the message on to the next tool
		return DMUS_S_REQUEUE;
	}

	// return DMUS_S_REQUEUE so the original message is requeued
	return DMUS_S_REQUEUE;
}

HRESULT STDMETHODCALLTYPE CNotifyTool::Flush(
	IDirectMusicPerformance* pPerf, 
	DMUS_PMSG* pPMsg,
	REFERENCE_TIME rt)
{
	UNREFERENCED_PARAMETER(rt);
	UNREFERENCED_PARAMETER(pPerf);

	// returning S_FREE frees the message. If StampPMsg()
	// fails, there is no destination for this message so
	// free it.
	if(( NULL == pPMsg->pGraph ) ||
		FAILED(pPMsg->pGraph->StampPMsg(pPMsg)))
	{
		return DMUS_S_FREE;
	}
	return DMUS_S_REQUEUE;
}


// Constructor/Desctructor
CMIDIInputContainer::CMIDIInputContainer(IDirectMusic* pDMusic)
{
	m_pDMusic = pDMusic;

	m_fWantToEcho = FALSE;
	m_fMIDIInputRunning = FALSE;

	ZeroMemory( m_aMIDIInputContainer, sizeof(MIDIInputContainer) * MIDI_IN_PORTS );

	ZeroMemory(	m_afThruingMIDI, sizeof(BOOL) * 16 );
	ZeroMemory( m_adwThruingMIDI, sizeof(DWORD) * 16 );

	ZeroMemory(	m_ahMIDIInputHandles, sizeof(HANDLE) * MIDI_IN_PORTS );
	m_dwValidInputHandles = 0;

	::InitializeCriticalSection( &m_csEchoMIDI );
	m_hEchoMIDIInputExitEvent = NULL;
	m_hEchoMIDIInputThread = NULL;

	for( int i=1; i < MIDI_IN_PORTS; i++ )
	{
		m_aMIDIInputContainer[i].m_fEchoMIDI = true;
	}
}

CMIDIInputContainer::~CMIDIInputContainer()
{
	// Cleans up thread
	StopMIDIInputThreadAndRemovePorts();

	// Clean up the list of MIDI input ports
	while( !m_lstMIDIInPorts.IsEmpty() )
	{
		PortContainer *pPortContainer = m_lstMIDIInPorts.RemoveHead();
		if( pPortContainer->m_pPort )
		{
			pPortContainer->m_pPort->Release();
		}
		if( pPortContainer->m_hPortEvent )
		{
			::CloseHandle( pPortContainer->m_hPortEvent );
		}

		delete pPortContainer;
	}

	// Clear the array of handles
	ZeroMemory( m_ahMIDIInputHandles, sizeof(HANDLE) * MIDI_IN_PORTS );
	m_dwValidInputHandles = 0;

	// Clean up the critical section
	::DeleteCriticalSection( &m_csEchoMIDI );
}

void CMIDIInputContainer::InitializeFromRegistry( void )
{
	TCHAR szValue[64];
	TCHAR szRegPath[MAX_PATH];
	// Look for a DirectMusic MIDI In port
	_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\PortConfiguration\\") );

	// Iterate through the list of echo MIDI input ports and initialize them
	for( int i=1; i < MIDI_IN_PORTS; i++ )
	{
		if( i==1 )
		{
			_tcscpy( szValue, _T("DMEchoMidiInPort") );
		}
		else
		{
			_stprintf( szValue, _T("DMEchoMidiInPort%d"), i );
		}

		DWORD dwCbData = sizeof(TCHAR) * 100;
		TCHAR szGuid[100];
		GUID guidPortGUID = GUID_AllZeros;
		if( GetRegString( HKEY_CURRENT_USER, szRegPath, szValue, szGuid, &dwCbData ) )
		{
			// Parse port GUID
			LPOLESTR psz = new OLECHAR[100];
			MultiByteToWideChar( CP_ACP, 0, szGuid, -1, psz, 100);

			CLSIDFromString(psz, &guidPortGUID);
			delete psz;
		}

		// Look up 'Echo MIDI In' Output PChannel group
		if( i==1 )
		{
			_tcscpy( szValue, _T("EchoMidiInPChannelGroup") );
		}
		else
		{
			_stprintf( szValue, _T("EchoMidiInPChannelGroup%d"), i );
		}

		DWORD dwPChannelBase = 0;
		GetRegDWORD( HKEY_CURRENT_USER, szRegPath, szValue, &dwPChannelBase );

		SetDMusicEchoMIDIIn( i, dwPChannelBase, guidPortGUID );
	}

	// Check if echo MIDI input is supposed to be enabled or disabled
	_tcscpy( szValue, _T("EnableEchoMidiInPort") );
	DWORD dwEnable = 0;
	if( GetRegDWORD( HKEY_CURRENT_USER, szRegPath, szValue, &dwEnable ) )
	{
		if( dwEnable != 0 )
		{
			m_fWantToEcho = TRUE;
		}
	}

	// Look for a normal MIDI input port
	DWORD dwCbData = sizeof(TCHAR) * 100;
	TCHAR szGuid[100];
	bool fGotDMusicPort = false;

	// Look in the new registry location
	if( GetNewRegString( _T("DMMidiInPort"), szGuid, &dwCbData ) )
	{
		fGotDMusicPort = true;
	}
	else
	{
		// Look in the old registry location

		// Convert CLSID_CConductor to a string
		LPOLESTR psz;
		if( SUCCEEDED( StringFromIID(CLSID_CConductor, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			// Build the registry key path
			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
			_tcscat( szRegPath, szGuid );

			// Try and read the value
			if( GetRegString( HKEY_LOCAL_MACHINE, szRegPath, _T("DMMidiInPort"), szGuid, &dwCbData ) )
			{
				// Found a GUID
				fGotDMusicPort = true;

				// Write the GUID to the new key
				SetNewRegString( _T("DMMidiInPort"), szGuid );
			}
		}
	}

	// Did we find a MIDI input port
	if( fGotDMusicPort )
	{
		// Yes - store its GUID

		// Parse port GUID
		LPOLESTR psz = new OLECHAR[100];
		MultiByteToWideChar( CP_ACP, 0, szGuid, -1, psz, 100);

		GUID guidPortGUID = GUID_AllZeros;
		CLSIDFromString(psz, &guidPortGUID);
		delete psz;

		// Store the GUID
		SetDMusicEchoMIDIIn( 0, 0, guidPortGUID );
	}
	else
	{
		// No MIDI input GUID found

		// Enumerate through all ports
		HRESULT hr;
		for(DWORD index = 0; ; index++)
		{
			// Initialize dmpc
			DMUS_PORTCAPS dmpc;
			ZeroMemory(&dmpc, sizeof(dmpc));
			dmpc.dwSize = sizeof(DMUS_PORTCAPS);

			// Get the port's capabilities
			hr = m_pDMusic->EnumPort(index, &dmpc);
			if(SUCCEEDED(hr) && hr != S_FALSE)
			{
				if ( !fGotDMusicPort && (dmpc.dwClass == DMUS_PC_INPUTCLASS) )
				{
					// Found an input port

					// Store the GUID
					SetDMusicEchoMIDIIn( 0, 0, dmpc.guidPort );

					fGotDMusicPort = true;
				}
			}
			else
			{
				break;
			}
		}
	}

	// Now, try and start the input thread (the method will decide whether it needs to or not)
	StartMIDIInputThreadAndCreatePorts();
}

HRESULT CMIDIInputContainer::OnOutputEnabled( void )
{
	return StartMIDIInputThreadAndCreatePorts();
}

HRESULT CMIDIInputContainer::StartMIDIInputThreadAndCreatePorts( void )
{
	if( !g_pconductor->m_fOutputEnabled || !AnyMIDIInputValid() )
	{
		// Output is 'disabled' or there are no valid MIDI input devices
		return S_FALSE;
	}

	// Stop and destroy the existing MIDI input thread and ports
	StopMIDIInputThreadAndRemovePorts();

	// Reset the latency offsets
	ResetLatencyOffset();

	// Not really necessary, since the thread shouldn't be doing anything, but it can't hurt
	::EnterCriticalSection( &m_csEchoMIDI );

	HRESULT hr = S_OK;

	// Iterate through all the MIDI input port settings
	int i=0;
	while( (i < MIDI_IN_PORTS) && SUCCEEDED(hr) )
	{
		// If we don't want Echo Midi Input, then only do the first port
		if( !m_fWantToEcho
		&&	i >= 1 )
		{
			break;
		}

		// We should not yet have a port container assigned
		ASSERT( !m_aMIDIInputContainer[i].m_pPortContainer );

		// Try and find an existing port
		PortContainer *pPortContainer = FindPort( m_aMIDIInputContainer[i].m_guidPort );

		// If no existing port and we have a valid GUID
		if( !pPortContainer
		&&	(m_aMIDIInputContainer[i].m_guidPort != GUID_AllZeros) )
		{
			// Create a new port container
			pPortContainer = new PortContainer;
			if( !pPortContainer )
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				// Initialize the port container
				pPortContainer->m_pPort = NULL;
				pPortContainer->m_hPortEvent = NULL;
				pPortContainer->m_lRef = 0;

				// Try and create the port
				DMUS_PORTPARAMS PortParams;
				PortParams.dwSize = sizeof( DMUS_PORTPARAMS );
				PortParams.dwValidParams = 0;
				hr = m_pDMusic->CreatePort( m_aMIDIInputContainer[i].m_guidPort, &PortParams, &pPortContainer->m_pPort, NULL );
				if( SUCCEEDED( hr ) )
				{
					// Try and create an event for the port
					pPortContainer->m_hPortEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );
					if( pPortContainer->m_hPortEvent )
					{
						// Tell the port to signal the event when MIDI data is available
						hr = pPortContainer->m_pPort->SetReadNotificationHandle( pPortContainer->m_hPortEvent );
					}
				}

				// If we failed, clean up
				if( FAILED( hr ) )
				{
					if( pPortContainer->m_pPort )
					{
						pPortContainer->m_pPort->Release();
					}
					if( pPortContainer->m_hPortEvent )
					{
						::CloseHandle( pPortContainer->m_hPortEvent );
					}

					delete pPortContainer;
					pPortContainer = NULL;
				}
				else
				{
					// Add to list of ports
					m_lstMIDIInPorts.AddHead( pPortContainer );

					// Add to array of notification handles
					m_ahMIDIInputHandles[m_dwValidInputHandles] = pPortContainer->m_hPortEvent;
					m_dwValidInputHandles++;
				}
			}
		}

		// If we have a port container
		if( pPortContainer )
		{
			// Save it
			m_aMIDIInputContainer[i].m_pPortContainer = pPortContainer;

			// Clear the latency offset
			m_aMIDIInputContainer[i].m_rtLatencyOffset = 0;

			// Increment the reference count
			InterlockedIncrement( &pPortContainer->m_lRef );
		}

		// Go to the next MIDI input port setting
		i++;
	}

	// Only start the thread if we were successful and we have at least one valid
	// handle to wait on
	if( SUCCEEDED(hr)
	&&	m_dwValidInputHandles )
	{
		// Start MIDI input thread
		CWinThread *pThread = ::AfxBeginThread( EchoMIDIInThreadProc, this );
		if( pThread )
		{
			// Save a pointer to the input thread
			m_hEchoMIDIInputThread = pThread->m_hThread;
			pThread->m_bAutoDelete = TRUE;

			// Activate the input ports
			POSITION pos = m_lstMIDIInPorts.GetHeadPosition();
			while( pos )
			{
				m_lstMIDIInPorts.GetNext(pos)->m_pPort->Activate( TRUE );
			}

			// Set the flag that we're doing MIDI input
			m_fMIDIInputRunning = TRUE;
		}
		else
		{
			TRACE("CMIDIInputContainer: Failed to start Echo MIDI input thread.\n");
			ASSERT( FALSE );

			// Clean up the MIDI input ports
			StopMIDIInputThreadAndRemovePorts();

			hr = E_FAIL;
		}
	}

	::LeaveCriticalSection( &m_csEchoMIDI );

	return hr;
}

HRESULT CMIDIInputContainer::StopMIDIInputThreadAndRemovePorts( void )
{
	// Deactivate the input ports
	POSITION pos = m_lstMIDIInPorts.GetHeadPosition();
	while( pos )
	{
		PortContainer *pPortContainer = m_lstMIDIInPorts.GetNext(pos);
		pPortContainer->m_pPort->Activate( FALSE );
		pPortContainer->m_pPort->SetReadNotificationHandle( NULL );
	}

	// Exit the thread
	if( m_hEchoMIDIInputThread )
	{
		DWORD dwExitCode;
		if( GetExitCodeThread( m_hEchoMIDIInputThread, &dwExitCode ) )
		{
			if( dwExitCode == STILL_ACTIVE )
			{
				// Create an event so we can know when the thread exits
				ASSERT( m_hEchoMIDIInputExitEvent == NULL );
				if( !m_hEchoMIDIInputExitEvent )
				{
					m_hEchoMIDIInputExitEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );
				}

				// Signal the MIDI input handler thread so it can exit
				::SetEvent( m_ahMIDIInputHandles[0] );

				// Wait for the input handler thread to exit
				::WaitForSingleObject( m_hEchoMIDIInputExitEvent, 2000 );
			}
		}
		m_hEchoMIDIInputThread = NULL;
	}

	if( m_hEchoMIDIInputExitEvent )
	{
		::CloseHandle( m_hEchoMIDIInputExitEvent );
		m_hEchoMIDIInputExitEvent = NULL;
	}

	::EnterCriticalSection( &m_csEchoMIDI );

	// Remove the input ports
	while( !m_lstMIDIInPorts.IsEmpty() )
	{
		PortContainer *pPortContainer = m_lstMIDIInPorts.RemoveHead();
		pPortContainer->m_pPort->Release();
		if( pPortContainer->m_hPortEvent )
		{
			::CloseHandle( pPortContainer->m_hPortEvent );
		}

		delete pPortContainer;
	}

	// Clear the array of handles
	ZeroMemory( m_ahMIDIInputHandles, sizeof(HANDLE) * MIDI_IN_PORTS );
	m_dwValidInputHandles = 0;

	// Clear the MIDI input pointers to the ports
	for( int i=0; i < MIDI_IN_PORTS; i++ )
	{
		m_aMIDIInputContainer[i].m_pPortContainer = NULL;
	}

	::LeaveCriticalSection( &m_csEchoMIDI );

	m_fMIDIInputRunning = FALSE;
	m_hEchoMIDIInputThread = NULL;

	return S_OK;
}

HRESULT CMIDIInputContainer::OnOutputDisabled( void )
{
	return StopMIDIInputThreadAndRemovePorts();
}

HRESULT CMIDIInputContainer::SetDMusicEchoMIDIIn( DWORD dwEchoID, DWORD dwNewOutputBlock, REFGUID guidEchoInputPort, bool fUpdateNow )
{
	ASSERT( dwEchoID < MIDI_IN_PORTS );
	if( dwEchoID >= MIDI_IN_PORTS )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;

	m_aMIDIInputContainer[dwEchoID].m_dwPChannelBase = dwNewOutputBlock * 16;

	if( m_aMIDIInputContainer[dwEchoID].m_guidPort != guidEchoInputPort )
	{
		// Port change, so stop and re-start existing MIDI Input thread, if requested
		if( fUpdateNow )
		{
			hr = StopMIDIInputThreadAndRemovePorts();
		}

		if( SUCCEEDED(hr) )
		{
			// Save the original GUID
			GUID guidOrig = m_aMIDIInputContainer[dwEchoID].m_guidPort;

			// Copy the GUID
			m_aMIDIInputContainer[dwEchoID].m_guidPort = guidEchoInputPort;

			// Restart MIDI input, if requested
			if( fUpdateNow )
			{
				hr = StartMIDIInputThreadAndCreatePorts();
			}

			// If we failed
			if( FAILED(hr) )
			{
				// Can only get here if we were requested to update the port
				ASSERT( fUpdateNow );

				// Restore the original GUID
				m_aMIDIInputContainer[dwEchoID].m_guidPort = guidOrig;

				// Try to start MIDI input again
				StartMIDIInputThreadAndCreatePorts();
			}
		}
	}

	return hr;
}

void CMIDIInputContainer::UpdateMIDIThruChannels( IDirectMusicAudioPath *pDMAudiopath )
{
	if( !m_aMIDIInputContainer[0].m_pPortContainer
	||	!m_aMIDIInputContainer[0].m_pPortContainer->m_pPort
	||	!pDMAudiopath )
	{
		return;
	}

	IDirectMusicThru *pIDMThru;
	if( SUCCEEDED( m_aMIDIInputContainer[0].m_pPortContainer->m_pPort->QueryInterface( IID_IDirectMusicThru, (void**) &pIDMThru ) ) )
	{
		for( DWORD dwPChannel = 0; dwPChannel < 16; dwPChannel++ )
		{
			if( m_afThruingMIDI[dwPChannel] )
			{
				DWORD dwRealPChannel;
				if( SUCCEEDED( pDMAudiopath->ConvertPChannel( m_adwThruingMIDI[dwPChannel], &dwRealPChannel ) ) )
				{
					IDirectMusicPort *pIDMOutputPort;
					DWORD dwGroup, dwMChannel;

					if( SUCCEEDED( g_pconductor->m_pDMPerformance->PChannelInfo( dwRealPChannel, &pIDMOutputPort, &dwGroup, &dwMChannel  ) ) )
					{
						pIDMThru->ThruChannel( 1, dwPChannel, dwGroup, dwMChannel, pIDMOutputPort );
						pIDMOutputPort->Release();
					}
				}
			}
		}
		pIDMThru->Release();
	}
}	

void CMIDIInputContainer::ClearThruConnections( void )
{
	if( !m_aMIDIInputContainer[0].m_pPortContainer
	||	!m_aMIDIInputContainer[0].m_pPortContainer->m_pPort )
	{
		return;
	}

	IDirectMusicThru *pIDMThru;
	if( SUCCEEDED( m_aMIDIInputContainer[0].m_pPortContainer->m_pPort->QueryInterface( IID_IDirectMusicThru, (void**) &pIDMThru ) ) )
	{
		for( DWORD dwPChannel = 0; dwPChannel < 16; dwPChannel++ )
		{
			if( m_afThruingMIDI[dwPChannel] )
			{
				pIDMThru->ThruChannel( 1, dwPChannel, 0, 0, NULL );
			}
		}
		pIDMThru->Release();
	}
}

void CMIDIInputContainer::UpdateRegistry( void )
{

	// Save the input GUIDs
	LPOLESTR psz;
	TCHAR szGuid[100];
	TCHAR szValue[100];
	for( int i=0; i < MIDI_IN_PORTS; i++ )
	{
		if( i==0 )
		{
			_tcscpy( szValue, _T("DMMidiInPort") );
		}
		else if( i==1 )
		{
			_tcscpy( szValue, _T("DMEchoMidiInPort") );
		}
		else
		{
			_stprintf( szValue, _T("DMEchoMidiInPort%d"), i );
		}

		// Set DirectMusic input GUID
		if( SUCCEEDED( StringFromIID(m_aMIDIInputContainer[i].m_guidPort, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );
			SetNewRegString( szValue, szGuid );
		}

		if( i > 1 )
		{
			if( i==1 )
			{
				_tcscpy( szValue, _T("EchoMidiInPChannelGroup") );
			}
			else
			{
				_stprintf( szValue, _T("EchoMidiInPChannelGroup%d"), i );
			}

			SetNewRegDWORD( szValue, m_aMIDIInputContainer[i].m_dwPChannelBase / 16, TRUE );
		}
	}

	// Set 'Echo MIDI In' Enable/Disable state
	SetNewRegDWORD(_T("EnableEchoMidiInPort"), m_fWantToEcho, TRUE);
}

void CMIDIInputContainer::RestartMIDIInThreadIfNecessary( void )
{
	// Exit the thread
	if( m_hEchoMIDIInputThread )
	{
		DWORD dwExitCode;
		if( GetExitCodeThread( m_hEchoMIDIInputThread, &dwExitCode ) )
		{
			if( dwExitCode != STILL_ACTIVE )
			{
				// If the MIDI input thread died, restart it
				CWinThread *pThread = ::AfxBeginThread( EchoMIDIInThreadProc, this );
				if( pThread )
				{
					TRACE("CMIDIInputContainer::RestartMIDIInThreadIfNecessary: Successfully restarted MIDI input thread.\n");

					// Save a pointer to the input thread
					m_hEchoMIDIInputThread = pThread->m_hThread;
					pThread->m_bAutoDelete = TRUE;
				}
				else
				{
					TRACE("CMIDIInputContainer::RestartMIDIInThreadIfNecessary: Failed to restart MIDI input thread.\n");
				}
			}
		}
	}
}

REFERENCE_TIME SampleLatency( IDirectMusicPort *pIDMOutputPort, IDirectMusicPerformance *pDMPerformance )
{
	if( g_rpLastSampledPort == pIDMOutputPort )
	{
		return s_rtLastSampledLatency;
	}

	// Default to 1 second latency
	REFERENCE_TIME rtResult = 1000 * 100000;

	IReferenceClock *pIReferenceClock;
	if( pIDMOutputPort && SUCCEEDED( pIDMOutputPort->GetLatencyClock( &pIReferenceClock ) ) )
	{
		rtResult = 0;

		REFERENCE_TIME rtNow, rtLatency;
		for( int i=0; i<40; i++ )
		{
			if( SUCCEEDED( pDMPerformance->GetTime( &rtNow, NULL ) ) )
			{
				if( SUCCEEDED( pIReferenceClock->GetTime( &rtLatency ) ) )
				{
					rtResult += rtLatency - rtNow;
				}
			}

			Sleep(3);
		}

		rtResult /= 40;

		pIReferenceClock->Release();
	}

	g_rpLastSampledPort = pIDMOutputPort;
	s_rtLastSampledLatency = rtResult;

	return rtResult;
}

HRESULT CMIDIInputContainer::SetPChannelThru( DWORD dwInputChannel, DWORD dwPChannel, IDirectMusicAudioPath *pDMAudiopath )
{
	// Ensure the audiopath pointer is valid, and that we have a MIDI input port
	if( !pDMAudiopath
	||	!m_aMIDIInputContainer[0].m_pPortContainer
	||	!m_aMIDIInputContainer[0].m_pPortContainer->m_pPort )
	{
		return E_FAIL;
	}

	// If we're already thruing, and we're just going to thru to the same channel, return S_FALSE
	if( m_afThruingMIDI[dwInputChannel] && (m_adwThruingMIDI[dwInputChannel] == dwPChannel) )
	{
		return S_FALSE;
	}

	// Convert to a PChannel that the Performance engine knows about
	DWORD dwRealPChannel;
	if( FAILED( pDMAudiopath->ConvertPChannel( dwPChannel, &dwRealPChannel ) ) )
	{
		return E_FAIL;
	}

	// Find what port, channel group, and channel the PChannel maps to
	IDirectMusicPort *pIDMOutputPort = NULL;
	DWORD dwGroup, dwMChannel;
	HRESULT hr = E_FAIL;
	if( SUCCEEDED( g_pconductor->m_pDMPerformance->PChannelInfo( dwRealPChannel, &pIDMOutputPort, &dwGroup, &dwMChannel  ) ) )
	{
		// Check to make sure we found a port
		if( pIDMOutputPort )
		{
			// Determine the latency of this output port
			REFERENCE_TIME rtLatency = SampleLatency( pIDMOutputPort, g_pconductor->m_pDMPerformance );
			TRACE("SetPChannelThru: Port latency: %I64d\n", rtLatency );

			// If the latency is low enough
			if( rtLatency < LATENCY_CUTOFF_MS * 10000 )
			{
				// Query for the Thru interface
				IDirectMusicThru *pIDMThru;
				if( SUCCEEDED( m_aMIDIInputContainer[0].m_pPortContainer->m_pPort->QueryInterface( IID_IDirectMusicThru, (void**) &pIDMThru ) ) )
				{
					// If we're already thruing this channel
					if( m_afThruingMIDI[dwInputChannel] )
					{
						// Clear the Thru channel
						if( FAILED( pIDMThru->ThruChannel( 1, dwInputChannel, 0, 0, NULL ) ) )
						{
							// Failed to clear the channel
							// TODO: Display error dialog?
							ASSERT(FALSE);
						}
						else
						{
							m_afThruingMIDI[dwInputChannel] = false;
						}
					}

					// Thru this channel to the given MIDI group, output channel, and output port
					if( SUCCEEDED( pIDMThru->ThruChannel( 1, dwInputChannel, dwGroup, dwMChannel, pIDMOutputPort ) ) )
					{

						// We succeeded - save the output PChannel and set the flag that we're thruing
						hr = S_OK;
						m_adwThruingMIDI[dwInputChannel] = dwPChannel;
						m_afThruingMIDI[dwInputChannel] = true;
					}
					pIDMThru->Release();
				}
			}
			pIDMOutputPort->Release();
		}
	}

	return hr;
}

HRESULT CMIDIInputContainer::CancelPChannelThru( DWORD dwInputChannel )
{
	// Ensure the audiopath pointer is valid, and that we have a MIDI input port
	if( !m_aMIDIInputContainer[0].m_pPortContainer
	||	!m_aMIDIInputContainer[0].m_pPortContainer->m_pPort )
	{
		return E_FAIL;
	}

	if( !m_afThruingMIDI[dwInputChannel] )
	{
		return S_FALSE;
	}

	HRESULT hr = E_FAIL;
	IDirectMusicThru *pIDMThru;
	if( SUCCEEDED( m_aMIDIInputContainer[0].m_pPortContainer->m_pPort->QueryInterface( IID_IDirectMusicThru, (void**) &pIDMThru ) ) )
	{
		hr = pIDMThru->ThruChannel( 1, dwInputChannel, 0, 0, NULL );
		pIDMThru->Release();
	}

	m_afThruingMIDI[dwInputChannel] = false;

	return hr;
}

void CMIDIInputContainer::ResetLatencyOffset( void )
{
	for( int i=1; i<MIDI_IN_PORTS; i++ )
	{
		m_aMIDIInputContainer[i].m_rtLatencyOffset = 0;
	}
}

HRESULT CMIDIInputContainer::EnableEchoMIDI( BOOL fEnable )
{
	if( m_fWantToEcho != fEnable )
	{
		m_fWantToEcho = fEnable;
		if( fEnable )
		{
			return StartMIDIInputThreadAndCreatePorts();
		}
		else
		{
			return StopMIDIInputThreadAndRemovePorts();
		}
	}

	return S_FALSE;
}

PortContainer *CMIDIInputContainer::FindPort( const REFGUID guidPort )
{
	for( int i=0; i<MIDI_IN_PORTS; i++ )
	{
		if( (guidPort == m_aMIDIInputContainer[i].m_guidPort)
		&&	m_aMIDIInputContainer[i].m_pPortContainer )
		{
			return m_aMIDIInputContainer[i].m_pPortContainer;
		}
	}

	return NULL;
}

bool CMIDIInputContainer::AnyMIDIInputValid( void )
{
	for( int i=0; i<MIDI_IN_PORTS; i++ )
	{
		if( GUID_AllZeros != m_aMIDIInputContainer[i].m_guidPort )
		{
			return true;
		}
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\OptionsToolbar.h ===
#if !defined(AFX_OPTIONSTOOLBAR_H__D2A5D885_F918_11D2_894A_00C04FBF8D15__INCLUDED_)
#define AFX_OPTIONSTOOLBAR_H__D2A5D885_F918_11D2_894A_00C04FBF8D15__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OptionsToolbar.h : header file
//

#include "DMUSProd.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// COptionsToolbarHandler definition

class COptionsToolbarHandler :
	public CComObjectRoot,
	public CWindowImpl<COptionsToolbarHandler>,
	public IDMUSProdToolBar
{
friend class CConductor;

public:
	COptionsToolbarHandler();
	~COptionsToolbarHandler();

protected:
	BOOL SetBtnState( int nID, UINT nState );

public:
	BEGIN_COM_MAP(COptionsToolbarHandler)
		COM_INTERFACE_ENTRY(IDMUSProdToolBar)
	END_COM_MAP()

	// IDMUSProdToolBar functions
	HRESULT STDMETHODCALLTYPE GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle );
	HRESULT STDMETHODCALLTYPE GetMenuText( BSTR* pbstrText );
	HRESULT STDMETHODCALLTYPE GetMenuHelpText( BSTR* pbstrHelpText );
	HRESULT STDMETHODCALLTYPE Initialize( HWND hWndToolBar );

//		TRACE( "Message: %x %x %x\n", uMsg, wParam, lParam );
	// message map
	BEGIN_MSG_MAP(COptionsToolbarHandler)
		COMMAND_HANDLER(ID_TRANSP_MIDI, BN_CLICKED, OnMidiClicked)
		COMMAND_HANDLER(ID_TRANSP_OPT, BN_CLICKED, OnOptionsClicked)
		COMMAND_HANDLER(ID_TRANSP_METRONOME, BN_CLICKED, OnMetronomeClicked)
		COMMAND_HANDLER(ID_TRANSP_CURSOR, BN_CLICKED, OnCursorClicked)
		COMMAND_HANDLER(ID_TRANSP_AUDIOPATH, CBN_CLOSEUP, OnCloseUpComboAudiopath)
		COMMAND_HANDLER(ID_TRANSP_AUDIOPATH, CBN_DROPDOWN, OnDropDownComboAudiopath)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
#pragma warning ( push )
#pragma warning ( disable : 4244 )
		NOTIFY_CODE_HANDLER(NM_RCLICK, OnRightClick)
#pragma warning ( pop )
	END_MSG_MAP()

	// message handler methods
	LRESULT OnMidiClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnOptionsClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnMetronomeClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnCursorClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnRightClick( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled );
	LRESULT OnCloseUpComboAudiopath( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnDropDownComboAudiopath( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);

	// Helper methods
	void UpdateComboBoxFromConductor( void );

	// Base class override methods
static CWndClassInfo& GetWndClassInfo();

	CComboBox		m_comboAudiopath;
	BOOL			m_fCursorEnabled;

	long			m_lCountInBars;
	BOOL			m_fCountOnlyOnRecord;

private:
	HWND			m_hWndToolbar;
	CFont			m_font;
};

#endif // !defined(AFX_OPTIONSTOOLBAR_H__D2A5D885_F918_11D2_894A_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by conduct.rc
//
#define IDS_CONDUCTOR_DESC              1
#define IDS_PROJNAME                    100
#define IDD_DIALOG_TRANSITION           102
#define IDD_DIALOG_METRONOME            104
#define IDB_Status                      105
#define IDD_SECONDARY                   106
#define IDD_SETUP_MIDI                  108
#define IDD_ALTERNATE_TEMPO             109
#define IDD_PORT_CONFIG                 110
#define IDD_DIALOG_REVERB               114
#define IDD_DIALOG_FREQ                 116
#define IDB_EXPORT_WAVE                 117
#define IDD_DIALOG_MIDI_EXPORT          117
#define IDD_DIALOG_EDIT_PCHANNEL        123
#define IDD_ECHO_ADVANCED               124
#define IDR_Conductor                   200
#define IDC_TRANSP_COMBO                201
#define IDC_RELATIVE_TEMPO              202
#define IDC_TEMPO                       203
#define IDB_Transport                   204
#define IDC_SPIN_TEMPO                  205
#define IDC_RATIO_EDIT                  206
#define IDC_SPIN_RATIO                  207
#define IDC_STATUS                      208
#define IDC_EDIT_SECONDARY              209
#define IDC_SPIN_SECONDARY              210
#define IDC_SYNTH_CPU                   211
#define IDC_SYNTH_VOICES                212
#define IDC_SYNTH_RESET                 213
#define IDC_RECORD_FILENAME             214
#define IDS_APATH_MUSIC                 215
#define IDS_APATH_STEREOPLUSREVERB      215
#define IDC_SYNTH_MEMORY                217
#define IDS_APATH_ENV                   218
#define IDC_SYNTH_LATENCY               219
#define IDS_APATH_3D_DRY                220
#define IDS_APATH_MONO                  221
#define IDS_APATH_STEREO                222
#define IDS_SYNTH_CPU_STATUS            223
#define IDS_SYNTH_VOICES_STATUS         224
#define IDS_SYNTH_MEMORY_STATUS         225
#define IDS_SYNTH_LATENCY_STATUS        226
#define IDS_APATH_MIXBIN_QUAD           227
#define IDS_APATH_MIXBIN_QUAD_MUSIC     228
#define IDS_APATH_MIXBIN_QUAD_ENV       229
#define IDS_APATH_MIXBIN_5DOT1          230
#define IDS_APATH_MIXBIN_5DOT1_MUSIC    231
#define IDS_APATH_MIXBIN_5DOT1_ENV      232
#define IDS_APATH_MIXBIN_STEREO_EFFECTS 233
#define IDS_APATH_3D_WET                234
#define IDC_CUSTOM_ID_SPIN              241
#define IDC_CUSTOM_ID                   248
#define IDC_RADIO_TIMING_QUICK          510
#define IDC_RADIO_TIMING_AFTERPREPARETIME 511
#define IDC_MIDI_INPUT                  1069
#define IDC_COMBO_ECHO_INPUT            1070
#define IDC_DEFAULT_SYNTH               1071
#define IDC_COMBO_BOUNDARY              1081
#define IDC_COMBO_PATTERN               1082
#define IDC_CHECK_LONG                  1083
#define IDC_CHECK_MODULATE              1084
#define IDC_EDIT_VELOCITY               1085
#define IDC_EDIT_ONE_VELOCITY           1085
#define IDC_SPIN_VELOCITY               1086
#define IDC_SPIN_ONE_VELOCITY           1086
#define IDC_COMBO_ONE_VALUE             1087
#define IDC_IMMEDIATE                   1088
#define IDC_EDIT_OTHER_VELOCITY         1088
#define IDC_GRID                        1089
#define IDC_SPIN_OTHER_VELOCITY         1089
#define IDC_BEAT                        1090
#define IDC_COMBO_OTHER_VALUE           1090
#define IDC_BAR                         1091
#define IDC_DEFAULT                     1092
#define IDC_CONTROL                     1093
#define IDC_LIST_PORT                   1096
#define IDC_EDIT_PCHANNEL               1097
#define IDC_SPIN_PCHANNEL               1098
#define IDC_11                          1132
#define IDC_22                          1133
#define IDC_44                          1134
#define IDC_48                          1135
#define IDC_96                          1136
#define IDC_OTHER                       1137
#define IDC_EDIT_ECHO_PCHANNELS         1138
#define IDC_SPIN_ECHO_PCHANNELS         1139
#define IDC_EDIT_COUNTIN                1145
#define IDC_SPIN_COUNTIN                1146
#define IDC_RADIO_RECORD                1147
#define IDC_RADIO_ALL_PLAYBACK          1148
#define IDC_CHECK_ECHO_MIDI             1149
#define IDC_EDIT_VOICES                 1150
#define IDC_SPIN_VOICES                 1151
#define IDC_LEADIN_MEASURE              1154
#define IDC_FIRST_MEASURE               1155
#define IDC_COMBO_EARLY_UNITS           1163
#define IDC_SPIN_WAIT_TIME              1164
#define IDC_RADIO_ENTIRE_PATTERN        1171
#define IDC_RADIO_ONE_BAR_PATTERN       1172
#define IDC_RADIO_ENTIRE_ADDITIONAL     1173
#define IDC_RADIO_ONE_BAR_ADDITIONAL    1174
#define IDC_CUSTOM_PROMPT               1175
#define IDC_RADIO_SWITCH_NEXT_BOUNDARY  1176
#define IDC_RADIO_SWITCH_ANY_TIME       1177
#define IDC_RADIO_SWITCH_ANY_GRID       1178
#define IDC_RADIO_SWITCH_ANY_BEAT       1179
#define IDC_RADIO_SWITCH_ANY_BAR        1180
#define IDC_ALIGN_OPTIONS_PROMPT        1181
#define IDC_CHECK_BOUNDARY              1182
#define IDC_STATIC_NO_MARKERS           1183
#define IDC_EDIT_LATENCY                1184
#define IDC_SPIN_LATENCY                1185
#define IDC_BUTTON_LATENCY_DEFAULT      1186
#define IDC_CHECK_LATENCY_PERSIST       1187
#define IDC_COMBO_TRANS_SEGMENT         1188
#define IDC_RADIO_QUICK_RESPONSE        1197
#define IDC_RADIO_AFTER_PREPARE         1198
#define IDC_CHECK_SEG_DEFAULT           1200
#define IDC_RADIO_GM_DOWNLOAD           1202
#define IDC_RADIO_GM_UNLOAD             1203
#define IDC_RADIO_DLS_DOWNLOAD          1204
#define IDC_RADIO_DLS_UNLOAD            1205
#define IDC_CHECK_TRANS_NOTHING         1206
#define IDC_CHECK_LOW_LATENCY           1207
#define IDC_COMBO_LOW_LAT_DEVICE        1208
#define IDC_STATIC_MS_CAPTION           1209
#define IDC_EDIT_PCHANNEL_NAME          1211
#define IDC_STATIC_PCHANNEL             1212
#define IDC_EDIT_OTHER                  1213
#define IDC_STATIC_AUDIO_SETTINGS       1215
#define IDC_RADIO_NOINVALIDATE          1216
#define IDC_RADIO_INVALIDATEPRI         1217
#define IDC_RADIO_INVALIDATE            1218
#define IDC_ECHO_ADVANCED               1219
#define IDC_COMBO_ECHO_INPUT_1          1220
#define IDC_EDIT_ECHO_PCHANNELS_1       1221
#define IDC_COMBO_ECHO_INPUT_2          1223
#define IDC_EDIT_ECHO_PCHANNELS_2       1224
#define IDC_COMBO_ECHO_INPUT_3          1229
#define IDC_EDIT_ECHO_PCHANNELS_3       1230
#define IDC_COMBO_ECHO_INPUT_4          1232
#define IDC_EDIT_ECHO_PCHANNELS_4       1233
#define IDC_COMBO_ECHO_INPUT_5          1235
#define IDC_EDIT_ECHO_PCHANNELS_5       1236
#define IDC_COMBO_ECHO_INPUT_6          1238
#define IDC_EDIT_ECHO_PCHANNELS_6       1239
#define IDC_COMBO_ECHO_INPUT_7          1241
#define IDC_EDIT_ECHO_PCHANNELS_7       1242
#define IDC_COMBO_ECHO_INPUT_8          1244
#define IDC_EDIT_ECHO_PCHANNELS_8       1245
#define IDC_SPIN_ECHO_PCHANNELS_1       1246
#define IDC_SPIN_ECHO_PCHANNELS_2       1247
#define IDC_SPIN_ECHO_PCHANNELS_3       1248
#define IDC_SPIN_ECHO_PCHANNELS_4       1249
#define IDC_SPIN_ECHO_PCHANNELS_5       1250
#define IDC_SPIN_ECHO_PCHANNELS_6       1251
#define IDC_SPIN_ECHO_PCHANNELS_7       1252
#define IDC_SPIN_ECHO_PCHANNELS_8       1253
#define ID_TRANSP_PLAY1                 2200
#define ID_TRANSP_PLAY2                 2201
#define ID_TRANSP_PLAY3                 2202
#define ID_TRANSP_PLAY4                 2203
#define ID_TRANSP_PLAY5                 2204
#define ID_TRANSP_PLAY6                 2205
#define ID_TRANSP_PLAY7                 2206
#define ID_TRANSP_PLAY8                 2207
#define ID_TRANSP_PLAY9                 2208
#define ID_TRANSP_PLAY10                2209
#define ID_TRANSP_PLAY11                2210
#define ID_TRANSP_PLAY12                2211
#define ID_TRANSP_PLAY13                2212
#define ID_TRANSP_PLAY14                2213
#define ID_TRANSP_PLAY15                2214
#define ID_TRANSP_PLAY16                2215
#define ID_TRANSP_PLAY17                2216
#define ID_TRANSP_PLAY18                2217
#define ID_TRANSP_PLAY19                2218
#define ID_TRANSP_PLAY20                2219
#define ID_TRANSP_PLAY21                2220
#define ID_TRANSP_PLAY22                2221
#define ID_TRANSP_PLAY23                2222
#define ID_TRANSP_PLAY24                2223
#define ID_TRANSP_PLAY25                2224
#define ID_TRANSP_PLAY26                2225
#define ID_TRANSP_PLAY27                2226
#define ID_TRANSP_PLAY28                2227
#define ID_TRANSP_PLAY29                2228
#define ID_TRANSP_PLAY30                2229
#define ID_TRANSP_PLAY31                2230
#define ID_TRANSP_PLAY32                2231
#define ID_TRANSP_PLAY33                2232
#define ID_TRANSP_PLAY34                2233
#define ID_TRANSP_PLAY35                2234
#define ID_TRANSP_PLAY36                2235
#define ID_TRANSP_STOP1                 2300
#define ID_TRANSP_STOP2                 2301
#define ID_TRANSP_STOP3                 2302
#define ID_TRANSP_STOP4                 2303
#define ID_TRANSP_STOP5                 2304
#define ID_TRANSP_STOP6                 2305
#define ID_TRANSP_STOP7                 2306
#define ID_TRANSP_STOP8                 2307
#define ID_TRANSP_STOP9                 2308
#define ID_TRANSP_STOP10                2309
#define ID_TRANSP_STOP11                2310
#define ID_TRANSP_STOP12                2311
#define ID_TRANSP_STOP13                2312
#define ID_TRANSP_STOP14                2313
#define ID_TRANSP_STOP15                2314
#define ID_TRANSP_STOP16                2315
#define ID_TRANSP_STOP17                2316
#define ID_TRANSP_STOP18                2317
#define ID_TRANSP_STOP19                2318
#define ID_TRANSP_STOP20                2319
#define ID_TRANSP_STOP21                2320
#define ID_TRANSP_STOP22                2321
#define ID_TRANSP_STOP23                2322
#define ID_TRANSP_STOP24                2323
#define ID_TRANSP_STOP25                2324
#define ID_TRANSP_STOP26                2325
#define ID_TRANSP_STOP27                2326
#define ID_TRANSP_STOP28                2327
#define ID_TRANSP_STOP29                2328
#define ID_TRANSP_STOP30                2329
#define ID_TRANSP_STOP31                2330
#define ID_TRANSP_STOP32                2331
#define ID_TRANSP_STOP33                2332
#define ID_TRANSP_STOP34                2333
#define ID_TRANSP_STOP35                2334
#define ID_TRANSP_STOP36                2335
#define IDC_TRANSP_COMBO1               2400
#define IDC_TRANSP_COMBO2               2401
#define IDC_TRANSP_COMBO3               2402
#define IDC_TRANSP_COMBO4               2403
#define IDC_TRANSP_COMBO5               2404
#define IDC_TRANSP_COMBO6               2405
#define IDC_TRANSP_COMBO7               2406
#define IDC_TRANSP_COMBO8               2407
#define IDC_TRANSP_COMBO9               2408
#define IDC_TRANSP_COMBO10              2409
#define IDC_TRANSP_COMBO11              2410
#define IDC_TRANSP_COMBO12              2411
#define IDC_TRANSP_COMBO13              2412
#define IDC_TRANSP_COMBO14              2413
#define IDC_TRANSP_COMBO15              2414
#define IDC_TRANSP_COMBO16              2415
#define IDC_TRANSP_COMBO17              2416
#define IDC_TRANSP_COMBO18              2417
#define IDC_TRANSP_COMBO19              2418
#define IDC_TRANSP_COMBO20              2419
#define IDC_TRANSP_COMBO21              2420
#define IDC_TRANSP_COMBO22              2421
#define IDC_TRANSP_COMBO23              2422
#define IDC_TRANSP_COMBO24              2423
#define IDC_TRANSP_COMBO25              2424
#define IDC_TRANSP_COMBO26              2425
#define IDC_TRANSP_COMBO27              2426
#define IDC_TRANSP_COMBO28              2427
#define IDC_TRANSP_COMBO29              2428
#define IDC_TRANSP_COMBO30              2429
#define IDC_TRANSP_COMBO31              2430
#define IDC_TRANSP_COMBO32              2431
#define IDC_TRANSP_COMBO33              2432
#define IDC_TRANSP_COMBO34              2433
#define IDC_TRANSP_COMBO35              2434
#define IDC_TRANSP_COMBO36              2435
#define ID_TRANSP_IDEN1                 2500
#define ID_TRANSP_IDEN2                 2501
#define ID_TRANSP_IDEN3                 2502
#define ID_TRANSP_IDEN4                 2503
#define ID_TRANSP_IDEN5                 2504
#define ID_TRANSP_IDEN6                 2505
#define ID_TRANSP_IDEN7                 2506
#define ID_TRANSP_IDEN8                 2507
#define ID_TRANSP_IDEN9                 2508
#define ID_TRANSP_IDEN10                2509
#define ID_TRANSP_IDEN11                2510
#define ID_TRANSP_IDEN12                2511
#define ID_TRANSP_IDEN13                2512
#define ID_TRANSP_IDEN14                2513
#define ID_TRANSP_IDEN15                2514
#define ID_TRANSP_IDEN16                2515
#define ID_TRANSP_IDEN17                2516
#define ID_TRANSP_IDEN18                2517
#define ID_TRANSP_IDEN19                2518
#define ID_TRANSP_IDEN20                2519
#define IDC_MUTE1                       5209
#define IDC_MUTE2                       5210
#define IDC_MUTE3                       5211
#define IDC_MUTE4                       5212
#define IDC_MUTE5                       5213
#define IDC_MUTE6                       5214
#define IDC_MUTE7                       5215
#define IDC_MUTE8                       5216
#define IDC_MUTE9                       5217
#define IDC_MUTE10                      5218
#define IDC_MUTE11                      5219
#define IDC_MUTE12                      5220
#define IDC_MUTE13                      5221
#define IDC_MUTE14                      5222
#define IDC_MUTE15                      5223
#define IDC_MUTE16                      5224
#define IDC_MUTE17                      5225
#define IDC_MUTE18                      5226
#define IDC_MUTE19                      5227
#define IDC_MUTE20                      5228
#define ID_MIDI_FILENAME                32000
#define ID_MIDI_EXPORT                  32001
#define IDC_RECORD_MIDI_FILENAME        32002
#define ID_TRANSP_PLAY                  33000
#define ID_TRANSP_STOP                  33001
#define ID_TRANSP_TRANSITION            33002
#define IDS_CONDUCTOR_COMPONENT_NAME    33003
#define IDS_TRANSPORT_HELP              33004
#define ID_TRANSP_AUDIOPATH             33005
#define ID_TRANSP_MIDI                  33006
#define ID_TRANSP_OPT                   33007
#define ID_TRANSP_RECORD                33008
#define ID_TRANSP_PANIC                 33009
#define ID_SET_STATE_AUTO               33010
#define ID_PRESS_PLAY_BUTTON            33011
#define ID_SET_ACTIVE_FROM_POINTER      33011
#define ID_MUSIC_STOPPED                33012
#define ID_TRANSP_METRONOME             33013
#define ID_PRESS_STOP_BUTTON            33014
#define ID_ADD_BUTTON                   33015
#define ID_SECONDARY_START_BOUNDARY_OPTIONS 33016
#define ID_TRANS_REWPLAY                33017
#define IDS_DEF_RATIO                   33018
#define IDS_DEFAULT_TRANSPORT_NAME      33019
#define IDS_ERR_CREATE_DMUSIC           33020
#define IDS_ERR_CREATE_PERF             33021
#define IDS_ERR_INIT_PERF               33022
#define IDS_ERR_CREATE_COLLEC           33023
#define IDS_ERR_LOAD_GMDLS              33024
#define IDS_STATUS_HELP                 33025
#define IDS_STATUS_TITLE                33026
#define IDS_STATUS_MENUTEXT             33027
#define IDS_TRANSPORT_TITLE             33028
#define IDS_TRANSPORT_MENUTEXT          33029
#define IDS_SECONDARY_TOOLBAR_TITLE     33030
#define IDS_SECONDARY_TOOLBAR_MENUTEXT  33031
#define IDS_SECONDARY_TOOLBAR_HELP      33032
#define ID_TRANS_STOPIMMEDIATE          33033
#define IDS_NO_TRANS_SEGMENT            33034
#define IDS_NO_AUDIOPATH                33035
#define IDS_DOWNLOADING_GM              33045
#define IDS_REVERB_CHARACTER            33046
#define IDS_CHORUS_CHARACTER            33047
#define IDS_WINMM_DRIVER_DESCRIPTION    33049
#define IDS_USER_MODE_DESCRIPTION       33050
#define IDS_KERNEL_MODE_DESCRIPTION     33051
#define IDS_UNKNOWN_DRIVER_DESCRIPTION  33052
#define IDS_ERR_CREATE_DSOUND           33053
#define IDS_ADD_NEW_PORT                33054
#define IDS_ERR_ALLOCATE_PCHANNEL_GROUPSGROUPS 33055
#define IDS_UNKNOWN_PORT_NAME           33056
#define IDS_ERR_REVERB_UNSUPPORTED      33057
#define IDS_ERR_CHORUS_UNSUPPORTED      33058
#define IDS_ERR_CREATE_PORT_INUSE       33059
#define IDS_ERR_PORT_INUSE              33060
#define IDS_ERR_UNKNOWN_CREATE_PORT     33061
#define IDS_ERR_DSOUND_INUSE            33062
#define IDS_NO_SAMPLE_RATE              33063
#define ID_SEG_START_NOTIFY             33064
#define IDS_NO_MIDI_INPUT               33064
#define ID_SEG_END_NOTIFY               33065
#define IDS_PCHANNEL_GROUP_FORAMT       33065
#define IDS_ECHOMIDI_MENU_TEXT          33066
#define IDS_ECHOMIDI_HELP_TEXT          33067
#define IDS_ERROR_NULLFRAMEWORK         33068
#define IDS_ERROR_NULLTOOLBAR           33069
#define IDS_ERR_UNKNOWN_ACTIVATEPORT    33070
#define ID_TRANSP_CURSOR                33071
#define IDS_ERR_ALLOCATE_PCHANNEL_GROUPSONEGROUP 33072
#define IDS_ERR_ALLOCATE_PCHANNEL_NOGROUPS 33073
#define IDS_OPTIONSTOOLBAR_MENUTEXT     33074
#define IDS_OPTIONSTOOLBAR_TITLE        33075
#define IDS_OPTIONSTOOLBAR_HELP         33076
#define IDS_SYSERR_OPEN                 33077
#define IDS_SYNTHSTATUS_MENUTEXT        33078
#define IDS_SYNTHSTATUS_TITLE           33079
#define IDS_SYNTHSTATUS_HELP            33080
#define IDS_TOOLBAR_FONT                33081
#define IDS_SYNTHSTATUS_RESET_BUTTON    33082
#define ID_WAVE_FILENAME                33083
#define ID_WAVE_RECORD                  33084
#define IDS_WAVERECORD_MENUTEXT         33085
#define IDS_WAVERECORD_TITLE            33086
#define IDS_WAVERECORD_HELP             33087
#define IDS_WAVEFILE_FILTERDESC         33088
#define IDS_WAVEFILE_TITLE              33089
#define IDS_WAVEFILE_DEFAULTEXT         33090
#define IDS_WAVEFILE_FILTER_EXT         33091
#define IDS_MIDIFILE_FILTERDESC         33092
#define IDS_MIDIFILE_TITLE              33093
#define IDS_MIDIFILE_DEFAULTEXT         33094
#define IDS_MIDIFILE_FILTER_EXT         33095
#define IDS_ERR_SAMPLE_RATE_MISMATCH    33096
#define IDS_SYSERR_SAVE                 33097
#define IDS_ERR_NOT_ALL_WAVE_CAPTURE    33098
#define IDS_ERR_NOT_ALL_FILE_OUTPUT     33098
#define IDS_ERR_APATH_CREATE_STANDARD   33099
#define IDS_ERR_APATH_CREATENODE        33100
#define IDS_ERR_APATH_GETCONFIG         33101
#define IDS_ERR_APATH_CREATE_USER       33102
#define IDS_ERR_NEED_DX8_FRAMEWORK      33103
#define IDS_ERR_INVALID_VOICES          33104
#define IDS_ERR_INVALID_3D_VOICES       33105
#define IDS_ERR_APATH_ACTIVATE          33106
#define IDS_NO_DEFAULT_SYNTH            33107
#define IDS_ERR_APATH_CREATE_USER_NOSENDDEST 33108
#define IDS_ERR_APATH_CREATE_USER_INVALIDARG 33109
#define IDS_ERR_APATH_CREATE_USER_NOENVDEST 33110
#define IDS_ERR_APATH_CREATE_USER_NOSYNTH 33111
#define IDS_LATENCY_TEXT                33112
#define IDS_UNKNOWN_LATENCY             33113
#define IDS_MS_TEXT                     33114
#define IDS_PCHANNEL_HELP               33115
#define IDS_ERR_CANNOT_CONNECT_XBOX     33116
#define IDS_ERR_WRONG_VERSION_XBOX      33117
#define IDS_ERR_INVALID_SAMPLERATE      33118
#define IDS_PC_AUDIO_INIT_SETTINGS      33119

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        126
#define _APS_NEXT_COMMAND_VALUE         33090
#define _APS_NEXT_CONTROL_VALUE         1223
#define _APS_NEXT_SYMED_VALUE           215
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6076C15F_C134_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_STDAFX_H__6076C15F_C134_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxext.h>
#include <afxtempl.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6076C15F_C134_11D0_8C10_00A0C92E1CAC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\OutputTool.h ===
#if !defined __OUTPUTTOOL_H__
#define __OUTPUTTOOL_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <dmusici.h>
//#include "fstream.h"
#include <afxtempl.h>
#include <dmusprod.h>

// One normal MIDI input port, plus 8 Echo ports
#define MIDI_IN_PORTS (9)

#define ECHO_ADVANCED_PORTS (MIDI_IN_PORTS - 1)

typedef struct
{
    IDirectMusicPort*	m_pPort;
	HANDLE				m_hPortEvent;
	long				m_lRef;
} PortContainer;

typedef struct
{
	PortContainer*		m_pPortContainer;
	GUID				m_guidPort;
	DWORD				m_dwPChannelBase;
	bool				m_fEchoMIDI;
	REFERENCE_TIME		m_rtLatencyOffset;
} MIDIInputContainer;

class CMIDIInputContainer
{
public:
	CMIDIInputContainer(IDirectMusic* pDMusic );
	~CMIDIInputContainer();

	BOOL						m_fWantToEcho;

	CTypedPtrList<CPtrList, PortContainer *> m_lstMIDIInPorts;

	// 0 is normal MIDI input, 1 - MIDI_IN_PORTS-1 are the echo MIDI input ports
	MIDIInputContainer			m_aMIDIInputContainer[MIDI_IN_PORTS];
	HANDLE						m_ahMIDIInputHandles[MIDI_IN_PORTS];
	DWORD						m_dwValidInputHandles;

	CRITICAL_SECTION			m_csEchoMIDI;
	HANDLE						m_hEchoMIDIInputExitEvent;

	HRESULT OnOutputEnabled( void );
	HRESULT OnOutputDisabled( void );

	HRESULT SetDMusicEchoMIDIIn( DWORD dwEchoID, DWORD dwNewOutputBlock, REFGUID guidEchoInputPort, bool fUpdateNow = true );

	HRESULT EnableEchoMIDI( BOOL fEnable );

	HRESULT SetPChannelThru( DWORD dwInputChannel, DWORD dwPChannel, IDirectMusicAudioPath *pDMAudiopath );
	HRESULT CancelPChannelThru( DWORD dwInputChannel );
    void UpdateMIDIThruChannels( IDirectMusicAudioPath *pDMAudiopath );
	void ClearThruConnections( void );

	void ResetLatencyOffset( void );
	void UpdateRegistry( void );
	void RestartMIDIInThreadIfNecessary( void );

	void InitializeFromRegistry( void );

protected:
	HRESULT	StartMIDIInputThreadAndCreatePorts( void );
	HRESULT	StopMIDIInputThreadAndRemovePorts( void );
	HRESULT UpdateMIDIInputThreadAndCreatePorts( void );
	PortContainer *FindPort( const REFGUID guidPort );

	bool AnyMIDIInputValid( void );

	IDirectMusic*				m_pDMusic;
	bool						m_afThruingMIDI[16];
	DWORD						m_adwThruingMIDI[16];
	BOOL						m_fMIDIInputRunning;
	HANDLE						m_hEchoMIDIInputThread;
};

class COutputTool :	public IDirectMusicTool
{
public:
	COutputTool();
	~COutputTool();

	// IUnknown methods
	virtual STDMETHODIMP QueryInterface( const IID &iid, void **ppv );
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicTool methods
	HRESULT STDMETHODCALLTYPE Init(IDirectMusicGraph* pGraph);
	HRESULT STDMETHODCALLTYPE GetMsgDeliveryType(DWORD* pdwDeliveryType);
	HRESULT STDMETHODCALLTYPE GetMediaTypeArraySize(DWORD* pdwNumElements);
	HRESULT STDMETHODCALLTYPE GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements);
	HRESULT STDMETHODCALLTYPE ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG);
	HRESULT STDMETHODCALLTYPE Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG, REFERENCE_TIME rtTime);

public:
	void SetPChannelMute( DWORD dwPChannel, BOOL fMute );
	BOOL GetPChannelMute( DWORD dwPChannel );
	CArray<BOOL, BOOL> m_afActivePChannels;
	CArray<long, long> m_alPChannelStates;
	CArray<long, long> m_alPChannelNoteOnStates;
	CArray<long, long> m_alNoteOnStates;
	CArray<BYTE, BYTE> m_abPChannelNoteOn;

	void MarkAllChannelsUnused( void );

protected:
	void AddNew( DWORD dwPChannel );
	CArray<BOOL, BOOL> m_afMute;
	LONG	m_cRef;
//	ofstream ofsOutput;
};

class CNotifyTool :	public IDirectMusicTool
{
public:
	CNotifyTool();
	~CNotifyTool();

	// IUnknown methods
	virtual STDMETHODIMP QueryInterface( const IID &iid, void **ppv );
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicTool methods
	HRESULT STDMETHODCALLTYPE Init(IDirectMusicGraph* pGraph);
	HRESULT STDMETHODCALLTYPE GetMsgDeliveryType(DWORD* pdwDeliveryType);
	HRESULT STDMETHODCALLTYPE GetMediaTypeArraySize(DWORD* pdwNumElements);
	HRESULT STDMETHODCALLTYPE GetMediaTypes(DWORD** padwMediaTypes, DWORD dwNumElements);
	HRESULT STDMETHODCALLTYPE ProcessPMsg(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG);
	HRESULT STDMETHODCALLTYPE Flush(IDirectMusicPerformance* pPerf, DMUS_PMSG* pPMSG, REFERENCE_TIME rtTime);

protected:
	LONG	m_cRef;
};


#endif // !defined __OUTPUTTOOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\SecondaryToolbar.h ===
#if !defined(SECONDARYTOOLBAR_H__36F6DDF43_46CE_11D0_B9DB_6__INCLUDED_)
#define SECONDARYTOOLBAR_H__36F6DDF43_46CE_11D0_B9DB_6__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <DMUSProd.h>
#include "resource.h"

interface IDirectMusicSegmentState;
interface IDMUSProdRIFFStream;
interface ISecondaryTransportRegEntry;

#define MAX_BUTTONS 99

struct ButtonState
{
	ButtonState()
	{
		pActiveRegEntry = NULL;
		dwSegFlags = DMUS_SEGF_DEFAULT;
	}
	virtual ~ButtonState()
	{
	}
	ISecondaryTransportRegEntry	*pActiveRegEntry;
	DWORD			dwSegFlags;
};

struct ButtonInfo : ButtonState
{
	ButtonInfo() : ButtonState()
	{
		fDisplayingPlay = TRUE;
		fWaitForStart = FALSE;
		pISegmentState = NULL;
		dwIndex = 0;
	}
	virtual ~ButtonInfo()
	{
		RELEASE(pISegmentState);
	}
	CComboBox		comboActive;
	CStatic			staticIdent;
	BOOL			fDisplayingPlay;
	BOOL			fWaitForStart;
	IDirectMusicSegmentState *pISegmentState;
	DWORD			dwIndex;
};

/////////////////////////////////////////////////////////////////////////////
// CSecondaryToolbarHandler definition

class CSecondaryToolbarHandler :
	public CComObjectRoot,
	public CWindowImpl<CSecondaryToolbarHandler>,
	public IDMUSProdToolBar
{
friend class CConductor;
friend UINT AFX_CDECL NotifyThreadProc( LPVOID pParam );

public:
	CSecondaryToolbarHandler();
	~CSecondaryToolbarHandler();

protected:
	BOOL SetBtnState( int nID, UINT nState );
	void UpdatePlayStopBtns( ButtonInfo *pButtonInfo );
	void AddButton( DWORD dwIndex );
	void SetNumButtons( DWORD dwNumButtons );
	void RemoveButton( DWORD dwIndex );

public:
	void SetStateAuto( void );
	void Activate( BOOL fActivate );

public:
	BEGIN_COM_MAP(CSecondaryToolbarHandler)
		COM_INTERFACE_ENTRY(IDMUSProdToolBar)
	END_COM_MAP()

	// IDMUSProdToolBar functions
	HRESULT STDMETHODCALLTYPE GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle );
	HRESULT STDMETHODCALLTYPE GetMenuText( BSTR* pbstrText );
	HRESULT STDMETHODCALLTYPE GetMenuHelpText( BSTR* pbstrHelpText );
	HRESULT STDMETHODCALLTYPE Initialize( HWND hWndToolBar );

	// message map
	BEGIN_MSG_MAP(CSecondaryToolbarHandler)
		COMMAND_CODE_HANDLER(ID_SET_STATE_AUTO, OnSetStateAuto)
		COMMAND_CODE_HANDLER(BN_CLICKED, OnButtonClicked)
		COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnSelchangeCombo)
		COMMAND_HANDLER(IDC_EDIT_SECONDARY, EN_CHANGE, OnChangeSecondaryEdit)
		//COMMAND_HANDLER(IDC_EDIT_SECONDARY, EN_KILLFOCUS, OnKillFocusSecondaryEdit)
#pragma warning ( push )
#pragma warning ( disable : 4244 )
		NOTIFY_HANDLER(IDC_SPIN_SECONDARY, UDN_DELTAPOS, OnDeltaPosSecondary)
		NOTIFY_CODE_HANDLER(NM_RCLICK, OnRightClick)
#pragma warning ( pop )
	END_MSG_MAP()

	// message handler methods
	LRESULT OnButtonClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnSelchangeCombo( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnPlayClicked( WORD wID );
	LRESULT OnStopClicked( WORD wID );
	//LRESULT OnKillFocusSecondaryEdit( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnChangeSecondaryEdit( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnDeltaPosSecondary( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled );

	LRESULT OnRightClick( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled );
	LRESULT OnShowBoundaryOptions( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

	LRESULT OnSetStateAuto( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled );
	HRESULT Save( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO *pckMain );

	void SetActiveTransport( CComboBox &comboActive, IDMUSProdSecondaryTransport*  pISecondaryTransport, ISecondaryTransportRegEntry *& pActiveRegEntry );

	void OnSegEndNotify( IUnknown *punkSegment );
	void OnSegStartNotify( IUnknown *punkSegment );

	// Base class override methods
static CWndClassInfo& GetWndClassInfo();

	DWORD			m_dwNumButtons;
	CTypedPtrArray<CPtrArray, ButtonInfo*> m_arrayButtons;
	ButtonInfo*		m_apOldButtonInfo[MAX_BUTTONS];

private:
	int				m_cxChar;
	int				m_cyChar;
	CSpinButtonCtrl m_spinControl;
	CEdit			m_editControl;
	//DWORD			m_dwSecondaryToolbarID;
	CFont			m_font;
	HWND			m_hWndToolbar;
};

#endif // !defined(SECONDARYTOOLBAR_H__36F6DDF43_46CE_11D0_B9DB_6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\SecondaryToolbar.cpp ===
// ToolbarHandler.cpp : implementation file
//

#include "stdafx.h"
#include <dmusici.h>
#include "CConduct.h"
#include "SecondaryToolbar.h"
#include "DlgSecondaryStart.h"
#include "TREntry.h"
#include <RiffStrm.h>
#include <NodeRefChunk.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Defined in cconduct.cpp
extern int GetIndexByDataPtr( CComboBox &combobox, void *pData );

// Defined in notify.cpp
extern void AddToolsAndSetupWaveSaveForSegState( IUnknown *punk );

CSecondaryToolbarHandler::CSecondaryToolbarHandler()
{
	m_dwNumButtons = 0;

//	m_dwSecondaryToolbarID = 0;
	m_hWndToolbar = NULL;

	// Just fill in some non-zero values - these will be overwritten in Initialize()
	m_cxChar = 4;
	m_cyChar = 4;

	for( int i=0; i< MAX_BUTTONS; i++ )
	{
		m_apOldButtonInfo[i]=NULL;
	}
}

CSecondaryToolbarHandler::~CSecondaryToolbarHandler()
{
	m_font.DeleteObject();

	while( m_arrayButtons.GetSize() )
	{
		delete m_arrayButtons[m_arrayButtons.GetUpperBound()];
		m_arrayButtons.RemoveAt(m_arrayButtons.GetUpperBound());
	}
	for( int i=0; i< MAX_BUTTONS; i++ )
	{
		if( m_apOldButtonInfo[i] )
		{
			delete m_apOldButtonInfo[i];
			m_apOldButtonInfo[i] = NULL;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSecondaryToolbarHandler IDMUSProdToolBar::GetInfo

HRESULT CSecondaryToolbarHandler::GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( (phWndOwner == NULL)
	||	(phInstance == NULL)
	||	(pnResourceId == NULL)
	||	(pbstrTitle == NULL) )
	{
		return E_POINTER;
	}

	*phWndOwner = m_hWnd;
	*phInstance = _Module.GetResourceInstance();
	*pnResourceId = (UINT)-1;  // we are going to build the toolbar from scratch

	CString strTitle;
	strTitle.LoadString(IDS_SECONDARY_TOOLBAR_TITLE);
	*pbstrTitle = strTitle.AllocSysString();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSecondaryToolbarHandler IDMUSProdToolBar::GetMenuText

HRESULT CSecondaryToolbarHandler::GetMenuText( BSTR* pbstrText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrText == NULL )
	{
		return E_POINTER;
	}

	CString strText;
	strText.LoadString(IDS_SECONDARY_TOOLBAR_MENUTEXT);
	*pbstrText = strText.AllocSysString();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSecondaryToolbarHandler IDMUSProdToolBar::GetMenuHelpText

HRESULT CSecondaryToolbarHandler::GetMenuHelpText( BSTR* pbstrMenuHelpText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrMenuHelpText == NULL )
	{
		return E_POINTER;
	}

	CString strMenuHelpText;
	strMenuHelpText.LoadString(IDS_SECONDARY_TOOLBAR_HELP);
	*pbstrMenuHelpText = strMenuHelpText.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSecondaryToolbarHandler IDMUSProdToolBar::Initialize

HRESULT CSecondaryToolbarHandler::Initialize( HWND hWndToolBar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// We had better have a valid window handle
	if( hWndToolBar == NULL )
	{
		return E_INVALIDARG;
	}

	// Save the window handle for use later
	m_hWndToolbar = hWndToolBar;
 
	// Create a CToolBarCtrl to modify the toolbar with
	CToolBarCtrl* pToolBarCtrl = new CToolBarCtrl;
	if( pToolBarCtrl == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Attach it to the window handle
	pToolBarCtrl->Attach( hWndToolBar );
	pToolBarCtrl->AddBitmap( 10, IDB_Transport );

	// Create font for toolbar combo box
	CClientDC* pDC = new CClientDC( pToolBarCtrl );

	int nHeight = -( (pDC->GetDeviceCaps(LOGPIXELSY) * 8) / 72 );

	CString strFontName;
	if( strFontName.LoadString( IDS_TOOLBAR_FONT ) == 0)
	{
		strFontName = CString("MS Sans Serif");
	}
	m_font.CreateFont( nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,
		DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
		DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, strFontName );
	
	CFont* pOldFont = pDC->SelectObject( &m_font );
	
	TEXTMETRIC tm;
	pDC->GetTextMetrics( &tm );
	m_cxChar = 30 * (tm.tmAveCharWidth);
	m_cyChar = 20 * (tm.tmHeight + tm.tmExternalLeading);

	pDC->SelectObject( pOldFont );
	delete pDC;

	// Clean up m_arrayButtons
	while( m_arrayButtons.GetSize() )
	{
		delete m_arrayButtons[m_arrayButtons.GetUpperBound()];
		m_arrayButtons.RemoveAt(m_arrayButtons.GetUpperBound());
	}

	// Initialize TBBUTTON strcture
	TBBUTTON button;
	button.dwData = 0;
	button.iString = NULL;


//	if( m_dwSecondaryToolbarID == 0 )
	{
		/*
		// 1 - Separator
		button.iBitmap = 0;
		button.idCommand = 0;
		button.fsState = TBSTATE_ENABLED;
		button.fsStyle = TBSTYLE_SEP;
		pToolBarCtrl->InsertButton( 0, &button );
		*/

		// 0 - Wide separator for edit/spin control
		button.iBitmap = m_cxChar / 4;
		button.idCommand = IDC_EDIT_SECONDARY;
		button.fsState = TBSTATE_ENABLED;
		button.fsStyle = TBSTYLE_SEP;
		pToolBarCtrl->InsertButton( 0, &button );
	}

	// Now add all the buttons
	SetNumButtons(4);

//	if( m_dwSecondaryToolbarID == 0 )
	{
		// Attach the secondary segment toolbar control window
		RECT rect;
		pToolBarCtrl->GetItemRect( 0, &rect );
		if( !m_editControl.Create(WS_CHILD | WS_VISIBLE | ES_NUMBER | ES_LEFT | ES_WANTRETURN,
			rect, pToolBarCtrl, IDC_EDIT_SECONDARY) )
		{
			return -1;
		}
		m_editControl.ModifyStyleEx( 0, WS_EX_CLIENTEDGE );
		m_editControl.SetFont( &m_font );
		m_editControl.EnableWindow(TRUE);
		m_editControl.SetLimitText(2);

		// Attach the spin control
		if( !m_spinControl.Create(WS_CHILD | WS_VISIBLE |
			UDS_ARROWKEYS | UDS_ALIGNRIGHT | UDS_WRAP | UDS_SETBUDDYINT | UDS_NOTHOUSANDS,
			rect, pToolBarCtrl, IDC_SPIN_SECONDARY) )
		{
			return -1;
		}
		m_spinControl.SetBuddy( &m_editControl );
		m_spinControl.SetRange( 1, MAX_BUTTONS );
		m_spinControl.SetPos( 4 );
		m_spinControl.EnableWindow(TRUE);
	}

	pToolBarCtrl->Detach();
	delete pToolBarCtrl;

	return S_OK;
}

void CSecondaryToolbarHandler::UpdatePlayStopBtns( ButtonInfo *pButtonInfo )
{
	ASSERT( pButtonInfo );
	if( !pButtonInfo )
	{
		return;
	}

	if( !::IsWindow( pButtonInfo->comboActive.GetSafeHwnd() ) )
	{
		return;
	}

	BOOL fHasEntries = FALSE;
	if( !g_pconductor->m_lstISecondaryTransportRegEntry.IsEmpty() )
	{
		fHasEntries = TRUE;
	}

	if( pButtonInfo->pActiveRegEntry == NULL )
	{
		SetBtnState( ID_TRANSP_PLAY1 + pButtonInfo->dwIndex, TBSTATE_INDETERMINATE );
		SetBtnState( ID_TRANSP_STOP1 + pButtonInfo->dwIndex, TBSTATE_INDETERMINATE );
		pButtonInfo->comboActive.EnableWindow( fHasEntries );
	}
	else if( pButtonInfo->fDisplayingPlay )
	{
		if( pButtonInfo->fWaitForStart || (pButtonInfo->pISegmentState && (g_pconductor->m_pDMPerformance->IsPlaying( NULL, pButtonInfo->pISegmentState ) == S_OK)) )
		{
			if( pButtonInfo->fDisplayingPlay )
			{
				//SetBtnState( ID_TRANSP_PLAY1 + pButtonInfo->dwIndex, TBSTATE_CHECKED );
				//SetBtnState( ID_TRANSP_STOP1 + pButtonInfo->dwIndex, TBSTATE_ENABLED );

				// Change Play to Stop button
				TBBUTTONINFO tbButtonInfo;
				tbButtonInfo.cbSize = sizeof( TBBUTTONINFO );
				tbButtonInfo.dwMask = TBIF_COMMAND | TBIF_IMAGE | TBIF_STATE | TBIF_STYLE;
				tbButtonInfo.idCommand = ID_TRANSP_STOP1 + pButtonInfo->dwIndex;
				tbButtonInfo.iImage = 9;
				tbButtonInfo.fsState = TBSTATE_ENABLED;
				tbButtonInfo.fsStyle = TBSTYLE_BUTTON;
				//TRACE("Change play1->stop1.\n");
				::SendMessage( m_hWndToolbar, TB_SETBUTTONINFO, ID_TRANSP_PLAY1 + pButtonInfo->dwIndex, LPARAM(&tbButtonInfo) );
				pButtonInfo->comboActive.EnableWindow( FALSE );

				//TRACE("Update m_fDisplayingPlay1\n");
				pButtonInfo->fDisplayingPlay = FALSE;
			}
		}
		else
		{
			SetBtnState( ID_TRANSP_PLAY1 + pButtonInfo->dwIndex, TBSTATE_ENABLED );
		}
	}
	else // !pButtonInfo->fDisplayingPlay
	{
		if( !pButtonInfo->fWaitForStart && (!pButtonInfo->pISegmentState || (g_pconductor->m_pDMPerformance->IsPlaying( NULL, pButtonInfo->pISegmentState ) != S_OK)) )
		{
			if( !pButtonInfo->fDisplayingPlay )
			{
				//SetBtnState( ID_TRANSP_PLAY1 + pButtonInfo->dwIndex, TBSTATE_ENABLED );
				//SetBtnState( ID_TRANSP_STOP1 + pButtonInfo->dwIndex, TBSTATE_INDETERMINATE );

				// Change Stop to Play button
				TBBUTTONINFO tbButtonInfo;
				tbButtonInfo.cbSize = sizeof( TBBUTTONINFO );
				tbButtonInfo.dwMask = TBIF_COMMAND | TBIF_IMAGE | TBIF_STATE | TBIF_STYLE;
				tbButtonInfo.idCommand = ID_TRANSP_PLAY1 + pButtonInfo->dwIndex;
				tbButtonInfo.iImage = 8;
				tbButtonInfo.fsState = TBSTATE_ENABLED;
				tbButtonInfo.fsStyle = TBSTYLE_BUTTON;
				//TRACE("Change stop1->play1.\n");
				::SendMessage( m_hWndToolbar, TB_SETBUTTONINFO, ID_TRANSP_STOP1 + pButtonInfo->dwIndex, LPARAM(&tbButtonInfo) );
				pButtonInfo->comboActive.EnableWindow( fHasEntries );

				//TRACE("Update m_fDisplayingPlay1\n");
				pButtonInfo->fDisplayingPlay = TRUE;
			}
		}
		else
		{
			SetBtnState( ID_TRANSP_STOP1 + pButtonInfo->dwIndex, TBSTATE_ENABLED );
		}
	}
}

void CSecondaryToolbarHandler::SetStateAuto( void )
{
	// Verify our window handle is still valid
	if( !::IsWindow( m_hWndToolbar ) )
	{
		return;
	}

	for( DWORD i=0; i<m_dwNumButtons; i++ )
	{
		UpdatePlayStopBtns( m_arrayButtons[i] );
	}
}

BOOL CSecondaryToolbarHandler::SetBtnState( int nID, UINT nState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( ::IsWindow( m_hWndToolbar ) )
	{
		return ::SendMessage( m_hWndToolbar, TB_SETSTATE, nID, MAKELONG(nState, 0) );
	}

	return FALSE;
}

CWndClassInfo& CSecondaryToolbarHandler::GetWndClassInfo()
{
	static CWndClassInfo wc =
	{
		{ sizeof(WNDCLASSEX), CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, StartWindowProc,
		  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, NULL, 0 },
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
	};
	return wc;
}

LRESULT CSecondaryToolbarHandler::OnRightClick(WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled)
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	//TRACE("%x %x %x %x\n",wNotifyCode, pNMHDR->hwndFrom,pNMHDR->idFrom,pNMHDR->code);

	// Get the cursor position (To put the menu there)
	POINT ptScreen, ptClient;
	BOOL  bResult;
	bResult = ::GetCursorPos( &ptScreen );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	ptClient = ptScreen;
	bResult = ::ScreenToClient( pNMHDR->hwndFrom, &ptClient );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	if( ::IsWindow( m_hWndToolbar ) )
	{
		CRect rect;

		for( DWORD i=0; i< m_dwNumButtons; i++ )
		{
			// Get rect defining boundary of Play/Stop button
//			if( m_dwSecondaryToolbarID == 0 )
			{
				::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 4 + i * 4, (LPARAM) &rect );
			}
			/*
			else
			{
				::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 3 + i * 4, (LPARAM) &rect );
			}
			*/

			if( rect.PtInRect( ptClient ) )
			{
				DlgSecondaryStart dlg;
				dlg.m_dwSegmentFlags = m_arrayButtons[i]->dwSegFlags;;

				if( IDOK == dlg.DoModal() )
				{
					m_arrayButtons[i]->dwSegFlags = dlg.m_dwSegmentFlags;
				}
				break;
			}
		}
	}

	return TRUE;
}


void CSecondaryToolbarHandler::OnSegEndNotify( IUnknown *punkSegment )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//TRACE("OnSegEndNotify %x\n", punkSegment);

	IDirectMusicSegmentState *pSegmentState = NULL;
	if( punkSegment )
	{
		punkSegment->QueryInterface( IID_IDirectMusicSegmentState, (void **)&pSegmentState );
	}

	for( DWORD i=0; i < m_dwNumButtons; i++ )
	{
		if( pSegmentState && m_arrayButtons[i]->pISegmentState &&
			(pSegmentState == m_arrayButtons[i]->pISegmentState) )
		{
			RELEASE( m_arrayButtons[i]->pISegmentState );
			m_arrayButtons[i]->fWaitForStart = FALSE;
		}
		if( !m_arrayButtons[i]->fWaitForStart && m_arrayButtons[i]->pISegmentState &&
			(g_pconductor->m_pDMPerformance->IsPlaying( NULL, m_arrayButtons[i]->pISegmentState ) != S_OK) )
		{
			RELEASE( m_arrayButtons[i]->pISegmentState );
		}
	}

	if( pSegmentState )
	{
		pSegmentState->Release();
	}
}

void CSecondaryToolbarHandler::OnSegStartNotify( IUnknown *punkSegment )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//TRACE("OnSegStartNotify %x\n", punkSegment);

	IDirectMusicSegmentState *pSegmentState = NULL;
	if( punkSegment )
	{
		punkSegment->QueryInterface( IID_IDirectMusicSegmentState, (void **)&pSegmentState );
	}

	for( DWORD i=0; i < m_dwNumButtons; i++ )
	{
		if( m_arrayButtons[i]->fWaitForStart )
		{
#ifdef _DEBUG
			if( !m_arrayButtons[i]->pISegmentState )
			{
				TRACE("Conductor: Secondary Segment %d doesn't exist when receiving notification.\n", i);
			}
#endif
			if( pSegmentState && (pSegmentState == m_arrayButtons[i]->pISegmentState) )
			{
				m_arrayButtons[i]->fWaitForStart = FALSE;
			}
			else if( !m_arrayButtons[i]->pISegmentState ||
				(g_pconductor->m_pDMPerformance->IsPlaying( NULL, m_arrayButtons[i]->pISegmentState ) == S_OK) )
			{
				m_arrayButtons[i]->fWaitForStart = FALSE;
			}
		}
	}

	if( pSegmentState )
	{
		pSegmentState->Release();
	}
}

LRESULT CSecondaryToolbarHandler::OnSetStateAuto( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(wCode);
	UNREFERENCED_PARAMETER(wLoWord);
	UNREFERENCED_PARAMETER(hWnd);
	UNREFERENCED_PARAMETER(bHandled);

	SetStateAuto();
	return TRUE;
}

HRESULT CSecondaryToolbarHandler::Save( IDMUSProdRIFFStream* pIRiffStream )
{
	ASSERT( pIRiffStream );
	if( !pIRiffStream )
	{
		return E_POINTER;
	}

	IStream *pIStream = pIRiffStream->GetStream();

	for( DWORD i=0; i < m_dwNumButtons; i++ )
	{
		// Create the toolbar state chunk
		MMCKINFO ckToolBar;
		ckToolBar.fccType = FOURCC_2NDARY_TOOLBAR_CHUNK;
		pIRiffStream->CreateChunk( &ckToolBar, MMIO_CREATELIST );

		// Write out the button's flags
		MMCKINFO ckFlags;
		ckFlags.ckid = FOURCC_2NDARY_TOOLBAR_FLAGS;
		pIRiffStream->CreateChunk( &ckFlags, 0 );
		pIStream->Write( &m_arrayButtons[i]->dwSegFlags, sizeof(DWORD), NULL );
		pIRiffStream->Ascend( &ckFlags, 0 );

		if( m_arrayButtons[i]->pActiveRegEntry )
		{
			IDMUSProdSecondaryTransport*  pISecondaryTransport;
			m_arrayButtons[i]->pActiveRegEntry->GetSecondaryTransport( &pISecondaryTransport );

			IDMUSProdNode *pNode;
			if( SUCCEEDED( pISecondaryTransport->QueryInterface( IID_IDMUSProdNode, (void **)&pNode ) ) )
			{

				CNodeRefChunk NodeRef( g_pconductor->m_pFrameWork, pNode );
				if( FAILED( NodeRef.Save( pIStream ) ) )
				{
					TRACE("CSecondaryToolbarHandler::Save unable to save node ref chunk.\n");
				}

				pNode->Release();
			}
		}
		else
		{
			// Create an empty chunk if nothing is selected
		}
		pIRiffStream->Ascend( &ckToolBar, 0 );
	}

	pIStream->Release();
	return S_OK;
}


HRESULT CSecondaryToolbarHandler::Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO *pckMain )
{
	ASSERT( pckMain );
	ASSERT( pIRiffStream );
	if( !pckMain || !pIRiffStream )
	{
		return E_POINTER;
	}

	// Get a pointer to the stream
	IStream *pIStream = pIRiffStream->GetStream();

	HRESULT hr;
	DWORD cbRead;

	for( DWORD i=0; i < m_dwNumButtons; i++ )
	{
		// Descend into the toolbar chunk
		MMCKINFO ckSubChunk;
		if( pIRiffStream->Descend( &ckSubChunk, pckMain, 0 ) != 0 )
		{
			pIStream->Release();
			return E_FAIL;
		}

		// Load combo box
		if( (ckSubChunk.ckid == FOURCC_LIST) && (ckSubChunk.fccType == FOURCC_2NDARY_TOOLBAR_CHUNK) )
		{
			if( !m_arrayButtons[i]->fWaitForStart &&
			   (!m_arrayButtons[i]->pISegmentState || (g_pconductor->m_pDMPerformance->IsPlaying( NULL, m_arrayButtons[i]->pISegmentState ) != S_OK)) )
			{
				// Read in the SegFlags
				MMCKINFO ckFlags;
				if( pIRiffStream->Descend( &ckFlags, &ckSubChunk, 0 ) != 0 )
				{
					pIStream->Release();
					return E_FAIL;
				}
				if( ckFlags.ckid == FOURCC_2NDARY_TOOLBAR_FLAGS )
				{
					hr = pIStream->Read( &m_arrayButtons[i]->dwSegFlags, sizeof(DWORD), &cbRead );
					if( FAILED(hr) || (cbRead != sizeof(DWORD)) )
					{
						pIStream->Release();
						return E_FAIL;
					}
					pIRiffStream->Ascend( &ckFlags, 0 );

					// If empty, clear the transport combo box
					if( ckSubChunk.cksize == 3 * sizeof(DWORD) + ckFlags.cksize)
					{
						SetActiveTransport( m_arrayButtons[i]->comboActive, NULL, m_arrayButtons[i]->pActiveRegEntry );
					}
					else
					{
						// Initialize the CNodeRef
						CNodeRefChunk NodeRef( g_pconductor->m_pFrameWork, NULL );

						// Load the ref chunk
						if( SUCCEEDED( NodeRef.Load( pIStream ) ) && NodeRef.m_pINode )
						{
							IDMUSProdSecondaryTransport*  pISecondaryTransport;
							if( SUCCEEDED( NodeRef.m_pINode->QueryInterface( IID_IDMUSProdSecondaryTransport, (void**)&pISecondaryTransport ) ) )
							{
								// Set active to pISecondaryTransport
								SetActiveTransport( m_arrayButtons[i]->comboActive, pISecondaryTransport, m_arrayButtons[i]->pActiveRegEntry );

								pISecondaryTransport->Release();
							}
						}
					}
				}
			}
		}

		pIRiffStream->Ascend( &ckSubChunk, 0 );
	}

	// Release the stream pointer
	pIStream->Release();
	return S_OK;
}

void CSecondaryToolbarHandler::SetActiveTransport( CComboBox &comboActive, IDMUSProdSecondaryTransport* pISecondaryTransport, ISecondaryTransportRegEntry *& pActiveRegEntry )
{
	if( pISecondaryTransport == NULL )
	{
		comboActive.SetCurSel( -1 );
		pActiveRegEntry = NULL;

		SetStateAuto();
		return;
	}

	for( int i=0; i < comboActive.GetCount(); i++ )
	{
		ISecondaryTransportRegEntry *pThisRegEntry = static_cast<ISecondaryTransportRegEntry *> (comboActive.GetItemDataPtr( i ));

		ASSERT( pThisRegEntry );
		if( pThisRegEntry )
		{
			IDMUSProdSecondaryTransport*  pITmpSecondaryTransport;
			pThisRegEntry->GetSecondaryTransport( &pITmpSecondaryTransport );

			if( pITmpSecondaryTransport == pISecondaryTransport )
			{
				comboActive.SetCurSel( i );
				pActiveRegEntry = pThisRegEntry;

				SetStateAuto();
				return;
			}
		}
	}

	return;
}

LRESULT CSecondaryToolbarHandler::OnPlayClicked( WORD wID )
{
	// This should have already been checked by the calling method
	ASSERT( wID < m_dwNumButtons );

	// Make sure the play button is currently displayed
	if( !m_arrayButtons[wID]->fDisplayingPlay )
	{
		return 0;
	}

	// Dispatch the play message to the active transport.
	if( m_arrayButtons[wID]->pActiveRegEntry )
	{
		// Force KillFocus to give controls a chance to sync changes handled in KillFocus code
		CWnd* pWndHadFocus = CWnd::GetFocus();
		::SetFocus( NULL );
		if( pWndHadFocus )
		{
			pWndHadFocus->SetFocus();
		}

		IDMUSProdSecondaryTransport*  pISecondaryTransport;
		m_arrayButtons[wID]->pActiveRegEntry->GetSecondaryTransport( &pISecondaryTransport );

		IUnknown *pIUnknown = NULL;
		if( FAILED(pISecondaryTransport->GetSecondaryTransportSegment( &pIUnknown )))
		{
			// Leave the buttons in their current state.
			return FALSE;
		}

		IDirectMusicSegment* pIDMSegment;
		if( FAILED( pIUnknown->QueryInterface( IID_IDirectMusicSegment, (void**)&pIDMSegment ) ) )
		{
			// This must be a song
			pIDMSegment = NULL;
		}

		// Fix for 22616: Secondary segment starts playing from 
		// the primary segment's start time...
		// Get the start point for the segment
		MUSIC_TIME mtPrimarySegmentStartTime = 0;
		if( pIDMSegment )
		{
			pIDMSegment->GetStartPoint(&mtPrimarySegmentStartTime);
			pIDMSegment->SetStartPoint(0);
		}

		// CONSIDER: Add flags for Queue time and Prepare time (or leave them to be picked up by segf_default?)
		DWORD dwFlags = m_arrayButtons[wID]->dwSegFlags | DMUS_SEGF_SECONDARY;
		if( FAILED( g_pconductor->m_pDMPerformance->PlaySegmentEx( pIUnknown,
																   NULL,
																   NULL,
																   dwFlags,
																   0,
																   &m_arrayButtons[wID]->pISegmentState,
																   NULL,
																   NULL ) ) )
		{
			// Leave the buttons in their current state.
			RELEASE( pIDMSegment );
			RELEASE( pIUnknown );
			return FALSE;
		}
		
		// Set the original start point back for the primary segment
		if( pIDMSegment )
		{
			pIDMSegment->SetStartPoint(mtPrimarySegmentStartTime);
		}

		//TRACE("OnPlayClicked %x\n", m_arrayButtons[wID]->pISegmentState);

		RELEASE( pIDMSegment );
		RELEASE( pIUnknown );

		// This just calls AddToolsAndSetupWaveSaveForSegState
		//g_pconductor->SetupMIDIAndWaveSave( m_arrayButtons[wID]->pISegmentState );

		AddToolsAndSetupWaveSaveForSegState( m_arrayButtons[wID]->pISegmentState );

		m_arrayButtons[wID]->fWaitForStart = TRUE;
		SetStateAuto();
		g_pconductor->SetMIDIExportFields( (IUnknown *)pISecondaryTransport );
		return TRUE;
	}
	else
	{
		// Leave the buttons in their current state.
	}

	return FALSE;
}

LRESULT CSecondaryToolbarHandler::OnStopClicked( WORD wID )
{
	// This should have already been checked by the calling method
	ASSERT( wID < m_dwNumButtons );

	// Make sure the play button is not currently displayed
	if( m_arrayButtons[wID]->fDisplayingPlay )
	{
		return 0;
	}

	if( m_arrayButtons[wID]->pISegmentState )
	{
		// Stop pISegmentState after prepare time
		MUSIC_TIME mtStopTime = 0;
		if( m_arrayButtons[wID]->dwSegFlags & DMUS_SEGF_CONTROL )
		{
			// Stop after prepare time to ensure no invalidations occur
			REFERENCE_TIME rtStopTime;
			g_pconductor->m_pDMPerformance->GetTime( &rtStopTime, &mtStopTime );
			//TRACE("Stop: Now = %I64d %d ", rtStopTime, mtStopTime );
			g_pconductor->m_pDMPerformance->GetResolvedTime( 0, &rtStopTime, DMUS_TIME_RESOLVE_AFTERPREPARETIME );
			rtStopTime += 100000;
			g_pconductor->m_pDMPerformance->ReferenceToMusicTime( rtStopTime, &mtStopTime );
			//TRACE(" Stop = %I64d ", rtStopTime );
		}

		//TRACE("Stopping %x at %d with %x\n", m_arrayButtons[wID]->pISegmentState, mtStopTime, m_arrayButtons[wID]->dwSegFlags );
		if( SUCCEEDED( g_pconductor->m_pDMPerformance->Stop( NULL, m_arrayButtons[wID]->pISegmentState, mtStopTime, m_arrayButtons[wID]->dwSegFlags ) ) )
		{
			RELEASE( m_arrayButtons[wID]->pISegmentState );
			m_arrayButtons[wID]->fWaitForStart = FALSE;
			SetStateAuto();
			return TRUE;
		}
		else
		{
			TRACE("Unable to stop secondary segment %hd\n", wID);
			ASSERT(FALSE);
		}
	}

	SetStateAuto();
	return FALSE;
}

LRESULT CSecondaryToolbarHandler::OnButtonClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wNotifyCode);
	if( (wID >= ID_TRANSP_PLAY1) && (wID < ID_TRANSP_STOP1) )
	{
		wID -= ID_TRANSP_PLAY1;
		//TRACE("Play %d\n", wID);

		ASSERT( wID < m_dwNumButtons );
		if( wID < m_dwNumButtons )
		{
			return OnPlayClicked( wID );
		}
	}
	else if( (wID >= ID_TRANSP_STOP1) && (wID < IDC_TRANSP_COMBO1) )
	{
		wID -= ID_TRANSP_STOP1;
		//TRACE("Stop %d\n", wID);

		ASSERT( wID < m_dwNumButtons );
		if( wID < m_dwNumButtons )
		{
			return OnStopClicked( wID );
		}
	}
	else
	{
		/* No need - handled by OnChangeSecondaryEdit
		// If user pressed 'Enter' in the Secondary segment # edit box, treat it as a killfocus
		if( (wNotifyCode == 0) && (wID == 1) )
		{
			return OnKillFocusSecondaryEdit( wNotifyCode, wID, hWndCtl, bHandled );
		}
		*/
		//ASSERT(FALSE);
	}
	return 0;
}

LRESULT CSecondaryToolbarHandler::OnSelchangeCombo( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wNotifyCode);
	if( (wID >= IDC_TRANSP_COMBO1) && (wID < IDC_TRANSP_COMBO1 + 100) )
	{
		wID -= IDC_TRANSP_COMBO1;
		//TRACE("Combo %d\n", wID);

		ASSERT( wID < m_dwNumButtons );
		if( wID < m_dwNumButtons )
		{
			if ( m_arrayButtons[wID]->comboActive.GetCurSel() != CB_ERR )
			{
				int nIndex = m_arrayButtons[wID]->comboActive.GetCurSel();
				m_arrayButtons[wID]->pActiveRegEntry = static_cast<ISecondaryTransportRegEntry *> (m_arrayButtons[wID]->comboActive.GetItemDataPtr(nIndex));
				SetStateAuto();
			}
		}
	}
	else
	{
		//ASSERT(FALSE);
	}
	return 0;
}

void CSecondaryToolbarHandler::AddButton( DWORD dwIndex )
{
	// Initialize TBBUTTON strcture
	TBBUTTON button;
	button.dwData = 0;
	button.iString = NULL;

	int nPositionToInsert;
//	if( m_dwSecondaryToolbarID == 0 )
	{
		nPositionToInsert = 1 + dwIndex * 4;
	}
	/*
	else
	{
		nPositionToInsert = dwIndex * 4;
	}
	*/

	// nPositionToInsert + 3 - Play/Stop
	button.iBitmap = 8;
	button.idCommand = ID_TRANSP_PLAY1 + dwIndex;
	button.fsState = TBSTATE_INDETERMINATE;
	button.fsStyle = TBSTYLE_BUTTON;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, nPositionToInsert, (LPARAM)&button );

	// nPositionToInsert + 2 - Wide separator for active transport indicator
	button.iBitmap = m_cxChar;
	button.idCommand = IDC_TRANSP_COMBO1 + dwIndex;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, nPositionToInsert, (LPARAM)&button );

	// nPositionToInsert + 1 - Identifier
	button.iBitmap = (2 * m_cxChar)/15;
	button.idCommand = ID_TRANSP_IDEN1 + dwIndex;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, nPositionToInsert, (LPARAM)&button );

	// nPositionToInsert - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = 0;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, nPositionToInsert, (LPARAM)&button );

	// Attach the combo box window
	RECT rect;
	::SendMessage( m_hWndToolbar, TB_GETITEMRECT, nPositionToInsert + 2, (LPARAM)&rect );
	rect.bottom = rect.top + m_cyChar;
	if( !m_arrayButtons[dwIndex]->comboActive.Create(WS_CHILD | WS_VISIBLE | WS_VSCROLL |
		CBS_DROPDOWNLIST | CBS_HASSTRINGS | CBS_SORT,
		rect, CWnd::FromHandle( m_hWndToolbar ), IDC_TRANSP_COMBO1 + dwIndex) )
	{
		ASSERT(FALSE);
		return;
	}
	m_arrayButtons[dwIndex]->comboActive.SetFont( &m_font );

	// Attach the static text window
	::SendMessage( m_hWndToolbar, TB_GETITEMRECT, nPositionToInsert + 1, (LPARAM)&rect );

	TCHAR tcstrName[10];
	if( dwIndex < 9 )
	{
		tcstrName[0] = '&';
		tcstrName[1] = '1' + dwIndex;
		tcstrName[2] = 0;
	}
	else if( dwIndex == 9 )
	{
		tcstrName[0] = '1';
		tcstrName[1] = '&';
		tcstrName[2] = '0';
		tcstrName[3] = 0;
	}
	else if( dwIndex < 36 )
	{
		tcstrName[0] = '&';
		tcstrName[1] = 'A' + dwIndex - 10;
		tcstrName[2] = 0;
	}
	else
	{
		_itot( dwIndex + 1, tcstrName, 10 );
	}
	if( !m_arrayButtons[dwIndex]->staticIdent.Create(tcstrName, WS_CHILD | WS_VISIBLE | SS_SUNKEN | SS_CENTER,
		rect, CWnd::FromHandle( m_hWndToolbar ), ID_TRANSP_IDEN1 + dwIndex) )
	{
		ASSERT(FALSE);
		return;
	}
	m_arrayButtons[dwIndex]->staticIdent.SetFont( &m_font );

	// Populate the combobox if we're not creating the first button
	if( dwIndex != 0 )
	{
		CString strText;
		for( int i=0; i < m_arrayButtons[0]->comboActive.GetCount(); i++ )
		{
			m_arrayButtons[0]->comboActive.GetLBText( i, strText );
			int nIndex = m_arrayButtons[dwIndex]->comboActive.InsertString( i, strText );
			ASSERT(nIndex == i);
			void *pData = m_arrayButtons[0]->comboActive.GetItemDataPtr( i );
			m_arrayButtons[dwIndex]->comboActive.SetItemDataPtr( nIndex, pData );
		}
	}

	// Set the combobox to the correct item
	m_arrayButtons[dwIndex]->comboActive.SetCurSel( GetIndexByDataPtr( m_arrayButtons[dwIndex]->comboActive, m_arrayButtons[dwIndex]->pActiveRegEntry ) );

	m_arrayButtons[dwIndex]->comboActive.EnableWindow(
		!g_pconductor->m_lstISecondaryTransportRegEntry.IsEmpty() );
}

void CSecondaryToolbarHandler::RemoveButton( DWORD dwIndex )
{
	ASSERT( dwIndex < (unsigned)m_arrayButtons.GetSize() );

	int nPositionToDelete;
//	if( m_dwSecondaryToolbarID == 0 )
	{
		nPositionToDelete = 1 + dwIndex * 4;
	}
	/*
	else
	{
		nPositionToDelete = dwIndex * 4;
	}
	*/

	m_arrayButtons[dwIndex]->comboActive.DestroyWindow();
	m_arrayButtons[dwIndex]->staticIdent.DestroyWindow();

	// Remove the Separator
	::SendMessage( m_hWndToolbar, TB_DELETEBUTTON, nPositionToDelete, 0 );
	// Remove the static text Separator
	::SendMessage( m_hWndToolbar, TB_DELETEBUTTON, nPositionToDelete, 0 );
	// Remove the combo box Separator
	::SendMessage( m_hWndToolbar, TB_DELETEBUTTON, nPositionToDelete, 0 );
	// Remove the play/stop button
	::SendMessage( m_hWndToolbar, TB_DELETEBUTTON, nPositionToDelete, 0 );
}

void CSecondaryToolbarHandler::SetNumButtons( DWORD dwNumButtons )
{
	if( dwNumButtons > m_dwNumButtons )
	{
		for( DWORD i=m_dwNumButtons; i < dwNumButtons; i++ )
		{
			// Create the button
			ButtonInfo *pButtonInfo = new ButtonInfo();
			pButtonInfo->dwIndex = i;

			// Copy saved information, if there is any
			if( m_apOldButtonInfo[i] )
			{
				memcpy( (ButtonState*) pButtonInfo, m_apOldButtonInfo[i], sizeof(ButtonState) );
			}

			// Add the new button to the array
			m_arrayButtons.SetAtGrow( i, pButtonInfo );

			// Add the button to the toolbar
			AddButton( i );
		}
		m_dwNumButtons = dwNumButtons;
	}
	else if( dwNumButtons < m_dwNumButtons )
	{
		for( DWORD i=m_dwNumButtons - 1; i >= dwNumButtons; i-- )
		{
			// Remove the button from the display
			RemoveButton(i);

			// Create a ButttonState to save information, if necessary
			if( !m_apOldButtonInfo[i] )
			{
				m_apOldButtonInfo[i] = new ButtonInfo();
			}

			// Save state information in case we recreate this button
			memcpy( m_apOldButtonInfo[i], (ButtonState *)m_arrayButtons[i], sizeof(ButtonState) );

			// Fake a click on the Stop button so we stop this transport if it's currently playing
			BOOL bHandled;
			OnButtonClicked( 0, ID_TRANSP_STOP1 + i, 0, bHandled );
			if( m_arrayButtons[i]->pISegmentState )
			{
				TRACE("SetNumButtons: Transport #%d failed to Stop() when removed\n", i);
				RELEASE( m_arrayButtons[i]->pISegmentState );
			}

			// Delete the button
			delete m_arrayButtons[i];
			m_arrayButtons.RemoveAt(i);
			m_dwNumButtons--;
		}
		ASSERT( m_dwNumButtons == dwNumButtons );
	}

	::SendMessage( m_hWndToolbar, TB_AUTOSIZE, 0, 0 );
	// Send a WM_SIZE message to the Frame window (Producer's main window) to
	// cause it to recalculate the toolbar layout.
	RECT rect;
	::GetWindowRect( ::GetParent(::GetParent(m_hWndToolbar)), &rect );
	::SendMessage( ::GetParent(::GetParent(m_hWndToolbar)), WM_SIZE, SIZE_RESTORED, MAKELPARAM( rect.right - rect.left, rect.bottom-rect.top ) );

	SetStateAuto();
}

/* No need - handled by OnChangeSecondaryEdit
LRESULT CSecondaryToolbarHandler::OnKillFocusSecondaryEdit( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (m_editControl.GetSafeHwnd() != NULL)
	{
		CString strNewNumButtons;
		m_editControl.GetWindowText( strNewNumButtons );
		strNewNumButtons.TrimRight();
		strNewNumButtons.TrimLeft();

		if( strNewNumButtons.IsEmpty() )
		{
			m_spinControl.SetPos( m_dwNumButtons );
		}
		else
		{
			DWORD dwNumButtons;
			dwNumButtons = _tcstoul(strNewNumButtons, NULL, 10);
			if( dwNumButtons > MAX_BUTTONS )
			{
				dwNumButtons = MAX_BUTTONS;
				m_spinControl.SetPos( dwNumButtons );
			}
			else if( dwNumButtons < 1 )
			{
				dwNumButtons = 1;
				m_spinControl.SetPos( dwNumButtons );
			}
			if (dwNumButtons != m_dwNumButtons )
			{
				SetNumButtons( dwNumButtons );
			}
		}
	}
	return TRUE;
}
*/

LRESULT CSecondaryToolbarHandler::OnChangeSecondaryEdit( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (m_editControl.GetSafeHwnd() != NULL)
	{
		CString strNewNumButtons;
		m_editControl.GetWindowText( strNewNumButtons );
		strNewNumButtons.TrimRight();
		strNewNumButtons.TrimLeft();

		if( !strNewNumButtons.IsEmpty() )
		{
			DWORD dwNumButtons;
			dwNumButtons = _tcstoul(strNewNumButtons, NULL, 10);
			if( dwNumButtons > MAX_BUTTONS )
			{
				dwNumButtons = MAX_BUTTONS;
				m_spinControl.SetPos( dwNumButtons );
			}
			else if( dwNumButtons < 1 )
			{
				dwNumButtons = 1;
				m_spinControl.SetPos( dwNumButtons );
			}
			if (dwNumButtons != m_dwNumButtons )
			{
				SetNumButtons( dwNumButtons );
			}
		}
		// We don't do anything if it is empty
	}
	return TRUE;
}

LRESULT CSecondaryToolbarHandler::OnDeltaPosSecondary( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (m_spinControl.GetSafeHwnd() != NULL)
	{
		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		CString strNewNumButtons;
		m_editControl.GetWindowText( strNewNumButtons );
		strNewNumButtons.TrimRight();
		strNewNumButtons.TrimLeft();

		long lNumButtons;
		lNumButtons = _tcstol(strNewNumButtons, NULL, 10);

		lNumButtons += pNMUpDown->iDelta;
		if( lNumButtons < 1 )
		{
			lNumButtons = 1;
		}
		else if( lNumButtons > MAX_BUTTONS )
		{
			lNumButtons = MAX_BUTTONS;
		}

		if( lNumButtons != pNMUpDown->iPos )
		{
			m_spinControl.SetPos( lNumButtons );
		}
		if ((unsigned)lNumButtons != m_dwNumButtons )
		{
			SetNumButtons( lNumButtons );
		}
	}
	return TRUE;
}

void CSecondaryToolbarHandler::Activate( BOOL fActivate )
{
	for( DWORD i=0; i < m_dwNumButtons; i++ )
	{
		if( m_arrayButtons[i]->pISegmentState )
		{
			IDirectMusicSegmentState8 *pIDirectMusicSegmentState8;
			if( SUCCEEDED( m_arrayButtons[i]->pISegmentState->QueryInterface( IID_IDirectMusicSegmentState8, (void **)&pIDirectMusicSegmentState8 ) ) )
			{
				IDirectMusicAudioPath *pIDirectMusicAudioPath;
				if( SUCCEEDED( pIDirectMusicSegmentState8->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH, 0, GUID_All_Objects, 0, IID_IDirectMusicAudioPath, (void **)&pIDirectMusicAudioPath ) ) )
				{
					pIDirectMusicAudioPath->Activate( fActivate );
					pIDirectMusicAudioPath->Release();
				}
				pIDirectMusicSegmentState8->Release();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\StatusToolbar.h ===
#if !defined(STATUSTOOLBAR_H__36F6DDF43_46CE_11D0_B9DB_00AA00C08146__INCLUDED_)
#define STATUSTOOLBAR_H__36F6DDF43_46CE_11D0_B9DB_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <afxtempl.h>
#include "resource.h"
#include "DMUSProd.h"

extern class CConductor* g_pconductor;
interface IDirectMusicPerformance;
interface IPChannelName;

class CMyButton :
	public CBitmapButton
{
public:
	CMyButton( DWORD dwPChannel );
	~CMyButton();

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	BOOL	m_fDown;
	BYTE	m_bLevel;
	DWORD	m_dwChannel;
	BOOL	m_fNoteOn;

	// Generated message map functions
protected:
	//{{AFX_MSG(CMyButton)
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

protected:
	CMyButton();

	static long m_lFontRefCount;
	static HFONT m_hFont;
//	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

/////////////////////////////////////////////////////////////////////////////
// CStatusToolbarHandler definition

class CStatusToolbarHandler :
	public CComObjectRoot,
	public CWindowImpl<CStatusToolbarHandler>,
	public IDMUSProdToolBar8
{
friend class CConductor;
friend class COutputTool;

public:
	CStatusToolbarHandler();
	~CStatusToolbarHandler();

public:
	void EnableTimer( BOOL fEnable );

public:
	BEGIN_COM_MAP(CStatusToolbarHandler)
		COM_INTERFACE_ENTRY(IDMUSProdToolBar)
		COM_INTERFACE_ENTRY(IDMUSProdToolBar8)
	END_COM_MAP()

	// IDMUSProdToolBar functions
	HRESULT STDMETHODCALLTYPE GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle );
	HRESULT STDMETHODCALLTYPE GetMenuText( BSTR* pbstrText );
	HRESULT STDMETHODCALLTYPE GetMenuHelpText( BSTR* pbstrHelpText );
	HRESULT STDMETHODCALLTYPE Initialize( HWND hWndToolBar );

	// IDMUSProdToolBar8 function
	HRESULT STDMETHODCALLTYPE ShowToolBar( BOOL bShowToolBar );

	// message map
	BEGIN_MSG_MAP(CStatusToolbarHandler)
	//BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0)
		//TRACE("StatusToolbarMsg: %x %x %x\n", uMsg, wParam, lParam );
		// This code fixes 18125.  It's a hack, but it works.
		if( uMsg == WM_NOTIFY )
		{
			if( m_nAfterWindowPosChanged )
			{
				if( m_nAfterWindowPosChanged == 1)
				{
					//TRACE("Notify: %x %x %x\n", ((LPNMHDR)lParam)->hwndFrom, ((LPNMHDR)lParam)->idFrom, ((LPNMHDR)lParam)->code );
					::PostMessage(m_hWndToolbar, TB_SETBUTTONSIZE, 0, MAKELPARAM(50, 22));
				}
				m_nAfterWindowPosChanged--;
			}
		}
#pragma warning ( push )
#pragma warning ( disable : 4244 )
		NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnSize)
#pragma warning ( pop )
		MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
		MESSAGE_HANDLER(WM_WINDOWPOSCHANGED, OnWindowPosChanged)
		COMMAND_HANDLER(ID_TRANSP_PANIC, BN_CLICKED, OnPanicClicked)
#pragma warning ( push )
#pragma warning ( disable : 4244 )
		NOTIFY_CODE_HANDLER(NM_RCLICK, OnRightClick)
#pragma warning ( pop )
		COMMAND_HANDLER(ID_TRANSP_PANIC, BN_DOUBLECLICKED, OnPanicDblClicked)
		COMMAND_CODE_HANDLER(ID_ADD_BUTTON, OnAddButton)
		COMMAND_CODE_HANDLER(BN_CLICKED, OnClicked)
		COMMAND_CODE_HANDLER(BN_DOUBLECLICKED, OnDblClicked)
	END_MSG_MAP()

	// message handler methods
	LRESULT OnDrawItem(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnWindowPosChanged(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnAddButton( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled );
	LRESULT OnClicked( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled );
	LRESULT OnDblClicked( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled );
	LRESULT OnSize( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled );
	LRESULT OnPanicClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnRightClick( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled );
	LRESULT OnPanicDblClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

	void RefreshAllButtons();

	// Base class override methods
static CWndClassInfo& GetWndClassInfo();

	CTypedPtrMap< CMapWordToPtr, WORD, CMyButton*> m_mpButtonStatus;

protected:
	HRESULT SendMIDIMessage( IDirectMusicPerformance *pPerformance, DWORD dwPChannel, BYTE bStatus, BYTE bByte1 );
	void RemoveAllStatusButtons( void );

private:
	HWND			m_hWndToolbar;
	UINT			m_nTimerID;
	int				m_nAfterWindowPosChanged;
};

void CALLBACK EXPORT TimerProc( HWND hWnd, UINT nMsg, UINT nIDEvent, DWORD dwTime );

#endif // !defined(STATUSTOOLBAR_H__36F6DDF43_46CE_11D0_B9DB_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\StatusToolbar.cpp ===
#include "stdafx.h"
#include "StatusToolbar.h"
#include "cconduct.h"
#include "OutputTool.h"
#include "Toolbar.h"
#include "SecondaryToolbar.h"
#include "TREntry.h"
#include <math.h>
#include <PChannelName.h>
#include "DlgEditPChannel.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

static CStatusToolbarHandler *g_pStatusToolbarHandler = NULL;

#define MIDI_CCHANGE    0xB0
#define MIDI_NOTEOFF    0x80

#ifdef _DEBUG
void DumpAudiopath( IDirectMusicAudioPath *pIDirectMusicAudiopath );
#endif

CStatusToolbarHandler::CStatusToolbarHandler()
{
	m_nTimerID = 0;
	g_pStatusToolbarHandler = this;
	m_hWndToolbar = NULL;
	m_nAfterWindowPosChanged = 0;
}

CStatusToolbarHandler::~CStatusToolbarHandler()
{
	if( m_nTimerID )
	{
		// No need to kill the timer - it was stopped when the window was destroyed.
	//	KillTimer( m_nTimerID );
		m_nTimerID = 0;
	}
	g_pStatusToolbarHandler = NULL;
	if( !m_mpButtonStatus.IsEmpty() )
	{
		CMyButton* pMyButton;
		WORD wPChannel;
		POSITION pos = m_mpButtonStatus.GetStartPosition();
		while( pos )
		{
			m_mpButtonStatus.GetNextAssoc( pos, wPChannel, pMyButton );
			m_mpButtonStatus.RemoveKey( wPChannel );
			delete pMyButton;
		}
	}
}

void CStatusToolbarHandler::RemoveAllStatusButtons( void )
{
	// Delete all buttons from the toolbar
	while( ::SendMessage( m_hWndToolbar, TB_BUTTONCOUNT, 0, 0 ) > 1 )
	{
		::SendMessage( m_hWndToolbar, TB_DELETEBUTTON, 1, 0 );
	}

	// Delete all button classes
	if( !m_mpButtonStatus.IsEmpty() )
	{
		CMyButton* pMyButton;
		WORD wPChannel;
		POSITION pos = m_mpButtonStatus.GetStartPosition();
		while( pos )
		{
			m_mpButtonStatus.GetNextAssoc( pos, wPChannel, pMyButton );
			m_mpButtonStatus.RemoveKey( wPChannel );
			pMyButton->DestroyWindow();
			delete pMyButton;
		}
	}

	// Mark all channels as unused
	if( g_pconductor
	&&	g_pconductor->m_pOutputTool )
	{
		g_pconductor->m_pOutputTool->MarkAllChannelsUnused();
	}
	// Send a WM_SIZE message to the Frame window (Producer's main window) to cause it to recalculate the
	// toolbar layout.
	RECT rect;
	::GetWindowRect( ::GetParent(::GetParent(m_hWndToolbar)), &rect );
	::PostMessage( ::GetParent(::GetParent(m_hWndToolbar)), WM_SIZE, SIZE_RESTORED, MAKELPARAM( rect.right - rect.left, rect.bottom-rect.top ) );
}

void CStatusToolbarHandler::EnableTimer( BOOL fEnable )
{
	if( fEnable )
	{
		if( m_nTimerID == 0 )
		{
			//m_nTimerID = SetTimer( 1, 100, TimerProc );
			m_nTimerID = ::SetTimer( NULL, 0, 100, TimerProc );
		}
	}
	else
	{
		if( m_nTimerID )
		{
			KillTimer( m_nTimerID );
			m_nTimerID = 0;
		}
	}
}

void CALLBACK EXPORT TimerProc(
   HWND hWnd,      // handle of CWnd that called SetTimer
   UINT nMsg,      // WM_TIMER
   UINT nIDEvent,  // timer identification
   DWORD dwTime    // system time
)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(hWnd);
	UNREFERENCED_PARAMETER(nMsg);
	UNREFERENCED_PARAMETER(nIDEvent);
	UNREFERENCED_PARAMETER(dwTime);

	if( !g_pStatusToolbarHandler || !g_pconductor )
	{
		return;
	}

	POSITION pos;
	pos = g_pStatusToolbarHandler->m_mpButtonStatus.GetStartPosition();
	if( pos && g_pconductor->m_pOutputTool )
	{
		CMyButton* pMyButton;
		WORD wPChannel;
		BYTE bNewLevel;
		while( pos )
		{
			g_pStatusToolbarHandler->m_mpButtonStatus.GetNextAssoc( pos, wPChannel, pMyButton );
			if( pMyButton )
			{
				if( ::IsWindowVisible( pMyButton->GetSafeHwnd() ) )
				{
					//m_alPChannelNoteOnStates
					if( g_pconductor->m_pOutputTool->m_abPChannelNoteOn[wPChannel] == 1 )
					{
						bNewLevel = BYTE( max( g_pconductor->m_pOutputTool->m_alPChannelStates[wPChannel],
											   g_pconductor->m_pOutputTool->m_alPChannelNoteOnStates[wPChannel] ) / 8 );
						if( bNewLevel > 15 ) bNewLevel = 15;
						g_pconductor->m_pOutputTool->m_alPChannelNoteOnStates[wPChannel] = 0;
					}
					else if( g_pconductor->m_pOutputTool->m_alPChannelStates[wPChannel] > 0 )
					{
						bNewLevel = BYTE(g_pconductor->m_pOutputTool->m_alPChannelStates[wPChannel] / 8);
						if( bNewLevel > 15 ) bNewLevel = 15;
					}
					else
					{
						bNewLevel = 0;
					}
					if( (pMyButton->m_bLevel != bNewLevel)
					||	g_pconductor->m_pOutputTool->m_abPChannelNoteOn[wPChannel] )
					{
						pMyButton->m_bLevel = bNewLevel;
						if( g_pconductor->m_pOutputTool->m_abPChannelNoteOn[wPChannel] == 1 )
						{
							pMyButton->m_fNoteOn = TRUE;
							g_pconductor->m_pOutputTool->m_abPChannelNoteOn[wPChannel] = 2;
						}
						else
						{
							g_pconductor->m_pOutputTool->m_abPChannelNoteOn[wPChannel] = 0;
						}
						//pMyButton->Invalidate( FALSE );
						static const RECT rectInvalidate = { 4, 3, 20, 18 };
						pMyButton->InvalidateRect( &rectInvalidate, FALSE );
					}
				}
			}
		}
	}
}

LRESULT CStatusToolbarHandler::OnSize( WORD , NMHDR* , BOOL& )
{
	if( !m_mpButtonStatus.IsEmpty() )
	{
		CMyButton* pMyButton;
		WORD wPChannel;
		RECT rectNew, rectOrig;
		POSITION pos = m_mpButtonStatus.GetStartPosition();
		while( pos )
		{
			m_mpButtonStatus.GetNextAssoc( pos, wPChannel, pMyButton );
			if( pMyButton )
			{
				::SendMessage( m_hWndToolbar, TB_GETRECT, IDC_MUTE1 + wPChannel, (LPARAM)&rectNew );

				POINT ptNew = {rectNew.left, rectNew.top};
				::ClientToScreen( m_hWndToolbar, &ptNew );

				HWND hWndButton = pMyButton->GetSafeHwnd();
				::GetWindowRect( hWndButton, &rectOrig );

				if( (rectOrig.left != ptNew.x)
				||	(rectOrig.top != ptNew.y) )
				{
					long lWidth = rectOrig.right - rectOrig.left;
					long lHeight = rectOrig.bottom - rectOrig.top;

					::MoveWindow( hWndButton, rectNew.left, rectNew.top, lWidth, lHeight, TRUE );
				}
			}
		}
	}
	return 0;
}

CWndClassInfo& CStatusToolbarHandler::GetWndClassInfo()
{
	static CWndClassInfo wc =
	{
		{ sizeof(WNDCLASSEX), CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, StartWindowProc,
		  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, NULL, 0 },
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
	};
	return wc;
}

/////////////////////////////////////////////////////////////////////////////
// CStatusToolbarHandler IDMUSProdToolBar::GetInfo

HRESULT CStatusToolbarHandler::GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( (phWndOwner == NULL)
	||	(phInstance == NULL)
	||	(pnResourceId == NULL)
	||	(pbstrTitle == NULL) )
	{
		return E_POINTER;
	}

	*phWndOwner = m_hWnd;
	*phInstance = _Module.GetResourceInstance();
	*pnResourceId = (UINT)-1;  // we are going to build the toolbar from scratch

	CString strTitle;
	strTitle.LoadString(IDS_STATUS_TITLE);
	*pbstrTitle = strTitle.AllocSysString();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStatusToolbarHandler IDMUSProdToolBar::GetMenuText

HRESULT CStatusToolbarHandler::GetMenuText( BSTR* pbstrText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrText == NULL )
	{
		return E_POINTER;
	}

	CString strText;
	strText.LoadString(IDS_STATUS_MENUTEXT);
	*pbstrText = strText.AllocSysString();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStatusToolbarHandler IDMUSProdToolBar::GetMenuHelpText

HRESULT CStatusToolbarHandler::GetMenuHelpText( BSTR* pbstrMenuHelpText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrMenuHelpText == NULL )
	{
		return E_POINTER;
	}

	CString strMenuHelpText;
	strMenuHelpText.LoadString(IDS_STATUS_HELP);
	*pbstrMenuHelpText = strMenuHelpText.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStatusToolbarHandler IDMUSProdToolBar::Initialize

HRESULT CStatusToolbarHandler::Initialize( HWND hWndToolBar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// We had better have a valid window handle
	ASSERT( hWndToolBar );
	if( hWndToolBar == NULL )
	{
		return E_INVALIDARG;
	}

	// Save the window handle for use later
	m_hWndToolbar = hWndToolBar;
 
	// Create a CToolBarCtrl to modify the toolbar with
	CToolBarCtrl* pToolBarCtrl = new CToolBarCtrl;
	if( pToolBarCtrl == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Attach it to the window handle
	pToolBarCtrl->Attach( hWndToolBar );
	pToolBarCtrl->SetButtonSize( CSize( 50, 22 ) );
	pToolBarCtrl->AddBitmap( 1, IDB_Status );
	pToolBarCtrl->SendMessage(TB_SETBUTTONSIZE, 0, MAKELONG(50, 22));

	// Initialize the TBBUTTON structure
	TBBUTTON button;
	button.dwData = 0;
	button.iString = NULL;

	// Force resisize to wrap controls correctly (TBSTYLE_BUTTON)
	button.iBitmap = 0;
	button.idCommand = ID_TRANSP_PANIC;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton( 0, &button );

	pToolBarCtrl->Detach();
	delete pToolBarCtrl;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CStatusToolbarHandler IDMUSProdToolBar8::ShowToolBar

HRESULT CStatusToolbarHandler::ShowToolBar( BOOL bShowToolBar )
{
	UNREFERENCED_PARAMETER(bShowToolBar);
	//AFX_MANAGE_STATE(AfxGetStaticModuleState());

	return S_OK;
}

LRESULT CStatusToolbarHandler::OnClicked( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(hWnd);
	UNREFERENCED_PARAMETER(wCode);
	// Check if the command is for a button we created
	int nChannel = wLoWord - IDC_MUTE1;

	CMyButton* pMyButton;
	if( m_mpButtonStatus.Lookup( (WORD)nChannel, pMyButton ) )
	{
		// Flip its state
		pMyButton->m_fDown = !pMyButton->m_fDown;

		// If we have an output tool (we'd better), update it with the new mute state
		if( g_pconductor && g_pconductor->m_pOutputTool )
		{
			g_pconductor->m_pOutputTool->SetPChannelMute( nChannel, pMyButton->m_fDown );

			// If mute was just enabled, send an All-notes off message
			if( pMyButton->m_fDown )
			{
				// Send Reset All Controllers (121)
				g_pconductor->SendMIDIMessage( pMyButton->m_dwChannel, 0, MIDI_CCHANGE, 121 );

				// Send All Notes Off (123)
				g_pconductor->SendMIDIMessage( pMyButton->m_dwChannel, 0, MIDI_CCHANGE, 123 );
			}
		}

		// Redraw the button since its state changed
		pMyButton->Invalidate( FALSE );

		bHandled = TRUE;
		return 0;
	}

	// Not for us
	bHandled = FALSE;
	return -1;
}

LRESULT CStatusToolbarHandler::OnDrawItem(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
	UNREFERENCED_PARAMETER(nMsg);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// If the message is for one of the mute/activity buttons we created, pass it on
	int nChannel = LOWORD(wParam) - IDC_MUTE1;
	{
		CMyButton* pMyButton;
		if( m_mpButtonStatus.Lookup( (WORD)nChannel, pMyButton ) )
		{
			pMyButton->SendMessage( WM_DRAWITEM, wParam, lParam );

			fHandled = TRUE;
			return 0;
		}
	}

	// Not for us
	fHandled = FALSE;
	return -1;
}

LRESULT CStatusToolbarHandler::OnWindowPosChanged(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
	UNREFERENCED_PARAMETER(nMsg);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(wParam);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_nAfterWindowPosChanged = 2;

	fHandled = FALSE;
	return -1;
}

LRESULT CStatusToolbarHandler::OnAddButton( WORD /*wCode*/, WORD wPChannel, HWND /*hWnd*/, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CMyButton *pMyButton;

	ASSERT( !m_mpButtonStatus.Lookup( wPChannel, pMyButton ) );
	if( !m_mpButtonStatus.Lookup( wPChannel, pMyButton ) )
	{
		Sleep(10);

		// Calculate where the button should be inserted
		int nIndex = 1;
		WORD wTmpPChannel = 0;
		while( wPChannel > wTmpPChannel )
		{
			if( m_mpButtonStatus.Lookup( wTmpPChannel, pMyButton ) )
			{
				nIndex++;
			}
			wTmpPChannel++;
		}

		nIndex = 1 + (nIndex - 1) * 2;

		// Initialize the TBBUTTON structure
		TBBUTTON button;
		button.dwData = 0;
		button.iString = NULL;

		// Insert separator
		button.iBitmap = 2;
		button.idCommand = 0;
		button.fsState = TBSTATE_ENABLED;
		button.fsStyle = TBSTYLE_SEP;
		::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, nIndex, (LPARAM)&button );

		// Add the button just after the the separator
		nIndex++;

		// Ensure the button size is correct
		::SendMessage(m_hWndToolbar, TB_SETBUTTONSIZE, 0, MAKELONG(50, 22));

		// Insert placeholder for button
		button.iBitmap = -1;
		button.idCommand = IDC_MUTE1 + wPChannel;
		button.fsState = TBSTATE_ENABLED;
		button.fsStyle = TBSTYLE_BUTTON;
		::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, nIndex, (LPARAM)&button );

		// Create and attach the button;
		TCHAR tcsText[10];
		RECT rect;

		pMyButton = new CMyButton( wPChannel );
		::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 0, (LPARAM)&rect );
		_itot( wPChannel + 1, tcsText, 10 );

		if( !pMyButton->Create(tcsText, WS_CHILD | WS_VISIBLE | BS_CHECKBOX | BS_OWNERDRAW,
			rect, CWnd::FromHandle( m_hWndToolbar ), IDC_MUTE1 + wPChannel) )
		{
			delete pMyButton;
			return -1;
		}

		// Initialize the output button with the mute state
		pMyButton->m_fDown = g_pconductor->m_pOutputTool->GetPChannelMute( wPChannel );

		pMyButton->EnableWindow(TRUE);

		m_mpButtonStatus.SetAt( wPChannel, pMyButton );

		// Update position of other buttons
		// Not needed - handled when we send a WM_SIZE message to the Frame window
		//OnSize( 0, 0, bHandled );

		// Not needed - handled when we send a WM_SIZE message to the Frame window
		//::PostMessage( m_hWndToolbar, TB_AUTOSIZE, 0, 0 );

		MSG msg;
		if( 0 == PeekMessage( &msg, m_hWndToolbar, WM_COMMAND, WM_COMMAND, PM_NOREMOVE ) )
		{
			// Send a WM_SIZE message to the Frame window (Producer's main window) to cause it to recalculate the
			// toolbar layout.
			Sleep(100);
			::GetWindowRect( ::GetParent(::GetParent(m_hWndToolbar)), &rect );
			::PostMessage( ::GetParent(::GetParent(m_hWndToolbar)), WM_SIZE, SIZE_RESTORED, MAKELPARAM( rect.right - rect.left, rect.bottom-rect.top ) );
		}
	}
	return 0;
}

LRESULT CStatusToolbarHandler::OnDblClicked( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(hWnd);
	UNREFERENCED_PARAMETER(wCode);
	// Ensure that we have an output tool
	ASSERT( g_pconductor && g_pconductor->m_pOutputTool );

	// Check if the command is for a button we created
	int nChannel = wLoWord - IDC_MUTE1;

	CMyButton* pMyButton;
	if( g_pconductor && g_pconductor->m_pOutputTool && m_mpButtonStatus.Lookup( (WORD)nChannel, pMyButton ) )
	{
		BOOL fOtherButtonState;
		if( pMyButton->m_fDown )
		{
			// Set its state to active
			pMyButton->m_fDown = FALSE;

			// Update the output tool with the new mute state
			g_pconductor->m_pOutputTool->SetPChannelMute( nChannel, FALSE );

			// Redraw the button since its state changed
			pMyButton->Invalidate( FALSE );

			if( m_mpButtonStatus.GetCount() < 2 )
			{
				bHandled = TRUE;
				return 0;
			}

			// Find out if all other buttons have the same state (and what it is)
			BOOL fFirstButtonStateSet = FALSE;
			BOOL fFirstButtonState = FALSE;
			BOOL fAllButtonsSame = TRUE;
			POSITION pos = m_mpButtonStatus.GetStartPosition();
			CMyButton *pTmpButton;
			WORD wChannel;
			while( pos && fAllButtonsSame )
			{
				m_mpButtonStatus.GetNextAssoc( pos, wChannel, pTmpButton );
				if( pTmpButton != pMyButton )
				{
					if( !fFirstButtonStateSet )
					{
						fFirstButtonStateSet = TRUE;
						fFirstButtonState = pTmpButton->m_fDown;
					}
					else
					{
						if( fFirstButtonState != pTmpButton->m_fDown )
						{
							fAllButtonsSame = FALSE;
						}
					}
				}
			}

			if( fAllButtonsSame && fFirstButtonState )
			{
				// All other buttons are muted - unmute all other buttons
				fOtherButtonState = FALSE;
			}
			else
			{
				// Mute all other buttons
				fOtherButtonState = TRUE;
			}
		}
		else
		{
			// Mute all other buttons
			fOtherButtonState = TRUE;
		}

		// Set all other buttons to fOtherButtonState
		CMyButton *pTmpButton;
		POSITION pos = m_mpButtonStatus.GetStartPosition();
		WORD wChannel;
		while( pos )
		{
			m_mpButtonStatus.GetNextAssoc( pos, wChannel, pTmpButton );
			if( (pTmpButton != pMyButton) && (pTmpButton->m_fDown != fOtherButtonState) )
			{
				// Set its state to muted (TRUE) or unmuted (FALSE)
				pTmpButton->m_fDown = fOtherButtonState;

				// Update the output tool with the new mute state
				g_pconductor->m_pOutputTool->SetPChannelMute( pTmpButton->m_dwChannel, fOtherButtonState );

				// Redraw the button since its state changed
				pTmpButton->Invalidate( FALSE );
			}
		}

		bHandled = TRUE;
		return 0;
	}

	// Not for us
	bHandled = FALSE;
	return -1;
}

LRESULT CStatusToolbarHandler::OnPanicClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	g_pconductor->StopAllNotesAndSegments();
	//EnableTimer(FALSE);

	return 0;
}

LRESULT CStatusToolbarHandler::OnRightClick( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Get the cursor position (To find out which button we've hit
	POINT ptScreen;
	BOOL  bResult = ::GetCursorPos( &ptScreen );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	POINT ptClient = ptScreen;
	bResult = ::ScreenToClient( pNMHDR->hwndFrom, &ptClient );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	if( ::IsWindow( m_hWndToolbar ) )
	{
		// Get the rect for the panic button
		RECT rect;
		::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 0, (LPARAM) &rect );

		// Check if the panic button was clicked
		if( ::PtInRect( &rect, ptClient ) )
		{
			// Yes - remove all buttons
			RemoveAllStatusButtons();

#ifdef _DEBUG
			DumpAudiopath( g_pconductor->m_pDMAudiopath );
#endif
		}
	}

	return TRUE;
}

LRESULT CStatusToolbarHandler::OnPanicDblClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( g_pconductor->m_pDMPerformance )
	{
		for( int i=0; i<32; i++)
		{
			for( BYTE bNote = 0; bNote < 127; bNote ++)
			{
				// Send Note Off
				g_pconductor->SendMIDIMessage( i, 0, MIDI_NOTEOFF, bNote );
			}
		}
		/*
		if( g_pconductor->m_pDMMIDIOutPort )
		{
			DWORD dwNumGroups;
			if( SUCCEEDED( g_pconductor->m_pDMMIDIOutPort->GetNumChannelGroups( &dwNumGroups ) ) )
			{
			}
		}
		if( g_pconductor->m_pDMSynthPort )
		{
			DWORD dwNumGroups;
			if( SUCCEEDED( g_pconductor->m_pDMSynthPort->GetNumChannelGroups( &dwNumGroups ) ) )
			{
			}
		}
		*/
	}

	return 0;
}

void CStatusToolbarHandler::RefreshAllButtons()
{
	POSITION pos = m_mpButtonStatus.GetStartPosition();
	CMyButton *pTmpButton;
	WORD wChannel;
	while( pos )
	{
		m_mpButtonStatus.GetNextAssoc( pos, wChannel, pTmpButton );
		pTmpButton->Invalidate( FALSE );
	}
}


BEGIN_MESSAGE_MAP(CMyButton, CBitmapButton)
	//{{AFX_MSG_MAP(CMyButton)
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

long CMyButton::m_lFontRefCount = 0;
HFONT CMyButton::m_hFont = NULL;

HFONT CreateMyButtonFont( void )
{
	LOGFONT lf;
	ZeroMemory( &lf, sizeof(LOGFONT));
	lf.lfHeight = 18; // Max height, in pixels
	/*
	if( m_dwChannel > 98 )
	{
	*/
		lf.lfWidth = 5; // Max width, in pixels
	/*
	}
	else
	{
		lf.lfWidth = 7; // Max width, in pixels
	}
	*/
	//lf.lfEscapement = 0;
	//lf.lfOrientation = 0;
	lf.lfWeight = 400; // Weight, 0-1000, 400 = Normal, 700 = Bold
	//lf.lfItalic = FALSE;
	//lf.lfUnderline = FALSE;
	//lf.lfStrikeOut = FALSE;
	//lf.lfCharSet = ANSI_CHARSET;
	//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	//lf.lfQuality = DEFAULT_QUALITY;
	lf.lfPitchAndFamily = VARIABLE_PITCH  | FF_ROMAN;
	//memcpy( lf.lfFaceName, _T("Arial"), 31 );
	
	// Create the font
	return ::CreateFontIndirect( &lf );
}

CMyButton::CMyButton( DWORD dwPChannel ) : CBitmapButton()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Initialize to up (active), no activity, PChannel 0
	m_fDown = FALSE;
	m_bLevel = 0;
	m_dwChannel = dwPChannel;
	m_fNoteOn = FALSE;
	
	if( InterlockedIncrement( &m_lFontRefCount ) == 1 )
	{
		if( m_hFont == NULL )
		{
			m_hFont = CreateMyButtonFont();
		}
	}
}

CMyButton::CMyButton() : CBitmapButton()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Initialize to up (active), no activity, PChannel 0
	m_fDown = FALSE;
	m_bLevel = 0;
	m_dwChannel = 0;
	m_fNoteOn = FALSE;
	
	if( InterlockedIncrement( &m_lFontRefCount ) == 1 )
	{
		if( m_hFont == NULL )
		{
			m_hFont = CreateMyButtonFont();
		}
	}
}

CMyButton::~CMyButton()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( InterlockedDecrement( &m_lFontRefCount ) == 0 )
	{
		if( m_hFont )
		{
			::DeleteObject( m_hFont );
			m_hFont = 0;
		}
	}
}

bool GetPChannelName( DWORD dwPChannel, CString &strName )
{
	bool fResult = false;

	if( g_pconductor && g_pconductor->m_pFrameWork )
	{
		ITransportRegEntry *pDisplayedRegEntry = g_pconductor->GetDisplayedTransport();
		if( pDisplayedRegEntry != NULL )
		{
			IDMUSProdTransport *pTransport;
			if( SUCCEEDED( pDisplayedRegEntry->GetTransport( &pTransport ) ) )
			{
				IDMUSProdNode *pNode;
				if( SUCCEEDED( pTransport->QueryInterface( IID_IDMUSProdNode, (void**)&pNode ) ) )
				{
					IDMUSProdProject *pProject;
					if( SUCCEEDED( g_pconductor->m_pFrameWork->FindProject( pNode, &pProject ) ) )
					{
						IDMUSProdPChannelName *pPChannelName;
						if( SUCCEEDED( pProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&pPChannelName ) ) )
						{
							// Get the PChannel name
							WCHAR wszName[MAX_PATH];
							pPChannelName->GetPChannelName( dwPChannel, wszName );

							strName = wszName;

							fResult = true;

							pPChannelName->Release();
						}
						pProject->Release();
					}
					pNode->Release();
				}
				// GetTransport doesn't AddRef, do don't Release
				//pTransport->Release();
			}
		}
	}

	return fResult;
}

void CMyButton::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(lpDrawItemStruct != NULL);

	if( lpDrawItemStruct->itemAction != ODA_DRAWENTIRE )
	{
		return;
	}

	// Attach to the drawing context handle
	if( lpDrawItemStruct->hDC )
	{
		// Create a copy of the button's rectangle
		RECT rect = lpDrawItemStruct->rcItem;

		// Draw the outside rect (typically White and Black)
		if( m_fDown )
		{
			::DrawFrameControl( lpDrawItemStruct->hDC, &rect, DFC_BUTTON, DFCS_BUTTONPUSH | DFCS_PUSHED );
		}
		else
		{
			::DrawFrameControl( lpDrawItemStruct->hDC, &rect, DFC_BUTTON, DFCS_BUTTONPUSH );
		}

		// Draw the inside rect (typically light grey and dark grey)
		// Add a two pixel gap at the top and bottom of the button
		rect.left++;
		rect.right--;
		rect.top += 3;
		rect.bottom -= 3;

		{
			// Set up our drawing rect, should be (4,4) - (20,17) (x,y)
			RECT rectMeter = rect;
			rectMeter.left += 2;
			rectMeter.right = 20;

			/*
			// Fill the background Black (active), White (inactive, down)
			if( m_fDown )
			{
				::SetBkColor(lpDrawItemStruct->hDC, RGB(255, 255, 255));
				::ExtTextOut(lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &rectMeter, NULL, 0, NULL);
			}
			else
			{
				::SetBkColor(lpDrawItemStruct->hDC, RGB(0, 0, 0));
				::ExtTextOut(lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &rectMeter, NULL, 0, NULL);
			}
			*/

			// If we're not 0
			if( m_bLevel )
			{
				// Leave a one pixel border around the volume bars
				rectMeter.left++;
				rectMeter.right--;
				rectMeter.bottom--;

				// Draw the volume bars (COLOR_BTNFACE - inactive, Yellow - active)
				if( m_fDown )
				{
					rectMeter.top = rectMeter.bottom - m_bLevel;
					::FillRect( lpDrawItemStruct->hDC, &rectMeter, (HBRUSH) (COLOR_BTNFACE + 1) );
					/*
					for( int nIndex = m_bLevel; nIndex > 0; nIndex-- )
					{
						rectMeter.top = rectMeter.bottom - 2;
						::FillRect( lpDrawItemStruct->hDC, &rectMeter, (HBRUSH) (COLOR_BTNFACE + 1) );
						rectMeter.bottom = rectMeter.top - 1;
					}
					*/
				}
				else
				{
					if( m_fNoteOn )
					{
						::SetBkColor(lpDrawItemStruct->hDC, RGB(255, 255, 0));
						m_fNoteOn = FALSE;
					}
					else
					{
						::SetBkColor(lpDrawItemStruct->hDC, RGB(235, 235, 0));
					}

					rectMeter.top = rectMeter.bottom - m_bLevel;
					::ExtTextOut(lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &rectMeter, NULL, 0, NULL);
					/*
					for( int nIndex = m_bLevel; nIndex > 0; nIndex-- )
					{
						rectMeter.top = rectMeter.bottom - 2;
						::ExtTextOut(lpDrawItemStruct->hDC, 0, 0, ETO_OPAQUE, &rectMeter, NULL, 0, NULL);
						rectMeter.bottom = rectMeter.top - 1;
					}
					*/
				}
			}
		}

		// Draw the PChannel number for this button
		{
			if( m_hFont )
			{
				HFONT oldFont;
				oldFont = (HFONT)::SelectObject( lpDrawItemStruct->hDC, m_hFont );

				// Set up our drawing rect, should be (4,4) - (20,17) (x,y)
				RECT tempRect = rect;
				tempRect.left += 2;
				tempRect.right = 20;

				// We want to draw transparently
				int nOldBkMode;
				nOldBkMode = ::SetBkMode( lpDrawItemStruct->hDC, TRANSPARENT );

				// Convert from a number to a string
				char cstrName[10];
				_itoa( m_dwChannel + 1, cstrName, 10 );

				// Black if active (up), White if muted (down)
				COLORREF oldColor;
				if( m_fDown )
				{
					oldColor = ::SetTextColor( lpDrawItemStruct->hDC, RGB(255, 255, 255) );
				}
				else
				{
					oldColor = ::SetTextColor( lpDrawItemStruct->hDC, RGB(0, 0, 0) );
				}

				// Actually draw the text
				::DrawText( lpDrawItemStruct->hDC, cstrName, strlen(cstrName), &tempRect,
					DT_NOCLIP | DT_VCENTER | DT_CENTER | DT_SINGLELINE | DT_NOPREFIX );

				// Reset everything back to how it was before
				::SetTextColor( lpDrawItemStruct->hDC, oldColor );
				::SetBkMode( lpDrawItemStruct->hDC, nOldBkMode );
				::SelectObject( lpDrawItemStruct->hDC, oldFont );
			}

			// Set up our drawing rect, should be (22,4) - (20,17) (x,y)
			RECT tempRect = rect;
			tempRect.left = 22;
			tempRect.right -= 2;

			// Get a copy of the rect that was invalidated
			RECT rectClip;
			::GetClipBox( lpDrawItemStruct->hDC, &rectClip );

			// Check if we need to draw the PChannel name
			CRect rectInter;
			if( rectInter.IntersectRect( &tempRect, &rectClip ) )
			{
			// Yep - need to draw the PChannel name
			if( m_hFont )
			{
				HFONT oldFont;
				oldFont = (HFONT)::SelectObject( lpDrawItemStruct->hDC, m_hFont );

				// We want to draw transparently
				int nOldBkMode;
				nOldBkMode = ::SetBkMode( lpDrawItemStruct->hDC, TRANSPARENT );

				// Black if active (up), White if muted (down)
				COLORREF oldColor;
				if( m_fDown )
				{
					oldColor = ::SetTextColor( lpDrawItemStruct->hDC, RGB(255, 255, 255) );
				}
				else
				{
					oldColor = ::SetTextColor( lpDrawItemStruct->hDC, RGB(0, 0, 0) );
				}

				CString strPChannelName;
				if( GetPChannelName( m_dwChannel, strPChannelName ) )
				{
					// Actually draw the text
					::DrawText( lpDrawItemStruct->hDC, strPChannelName, strPChannelName.GetLength(), &tempRect,
						DT_NOCLIP | DT_VCENTER | DT_LEFT | DT_SINGLELINE | DT_NOPREFIX );
				}

				// Reset everything back to how it was before
				::SetTextColor( lpDrawItemStruct->hDC, oldColor );
				::SetBkMode( lpDrawItemStruct->hDC, nOldBkMode );
				::SelectObject( lpDrawItemStruct->hDC, oldFont );
			}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMyButton message handlers

void CMyButton::OnRButtonUp(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CBitmapButton::OnRButtonUp(nFlags, point);

	if( g_pconductor && g_pconductor->m_pFrameWork )
	{
		ITransportRegEntry *pDisplayedRegEntry = g_pconductor->GetDisplayedTransport();
		if( pDisplayedRegEntry != NULL )
		{
			IDMUSProdTransport *pTransport;
			if( SUCCEEDED( pDisplayedRegEntry->GetTransport( &pTransport ) ) )
			{
				IDMUSProdNode *pNode;
				if( SUCCEEDED( pTransport->QueryInterface( IID_IDMUSProdNode, (void**)&pNode ) ) )
				{
					IDMUSProdProject *pProject;
					if( SUCCEEDED( g_pconductor->m_pFrameWork->FindProject( pNode, &pProject ) ) )
					{
						IDMUSProdPChannelName *pPChannelName;
						if( SUCCEEDED( pProject->QueryInterface( IID_IDMUSProdPChannelName, (void**)&pPChannelName ) ) )
						{
							DlgEditPChannel dlgEditPChannel;
							dlgEditPChannel.m_dwPChannel = m_dwChannel;

							// Get the PChannel name
							WCHAR wszName[MAX_PATH];
							pPChannelName->GetPChannelName( m_dwChannel, wszName );
							CString strOrigName = wszName;
							dlgEditPChannel.m_strName = strOrigName;

							if( (dlgEditPChannel.DoModal() == IDOK)
							&&	(dlgEditPChannel.m_strName.Compare( strOrigName ) != 0) )
							{
								// Update PChannel name
								MultiByteToWideChar( CP_ACP, 0, dlgEditPChannel.m_strName, -1, wszName, MAX_PATH );
								pPChannelName->SetPChannelName( m_dwChannel, wszName );
							}

							pPChannelName->Release();
						}
						pProject->Release();
					}
					pNode->Release();
				}
				// GetTransport doesn't AddRef, do don't Release
				//pTransport->Release();
			}
		}
	}
}


#ifdef _DEBUG
void OutputAudiopathText( TCHAR *tcstrText )
{
	TRACE("%s", tcstrText);
}

void DumpAudiopathSegment( IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IDirectMusicSegment* pIDirectMusicSegment = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( 0, DMUS_PATH_SEGMENT, 0,
		GUID_All_Objects, dwIndex, IID_IDirectMusicSegment, (void**) &pIDirectMusicSegment ) )
	{
		_stprintf( tcstrText, _T("Found segment %x.\n"), pIDirectMusicSegment );
		OutputAudiopathText( tcstrText );
		dwIndex++;
		pIDirectMusicSegment->Release();
	}

	if( dwIndex == 0 )
	{
		OutputAudiopathText( _T("No segments in audio path.\n") );
	}
}

void DumpAudiopathSegmentTrack( IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IDirectMusicTrack* pIDirectMusicTrack = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( 0, DMUS_PATH_SEGMENT_TRACK, 0,
		GUID_All_Objects, dwIndex, IID_IDirectMusicTrack, (void**) &pIDirectMusicTrack ) )
	{
		_stprintf( tcstrText, _T("Found track %x.\n"), pIDirectMusicTrack );
		OutputAudiopathText( tcstrText );
		dwIndex++;
		pIDirectMusicTrack->Release();
	}

	if( dwIndex == 0 )
	{
		OutputAudiopathText( _T("No tracks in audio path.\n") );
	}
}

void DumpAudiopathAudiopath( IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IDirectMusicAudioPath* pIDirectMusicAudiopathTmp = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( 0, DMUS_PATH_AUDIOPATH, 0,
		GUID_All_Objects, dwIndex, IID_IDirectMusicAudioPath, (void**) &pIDirectMusicAudiopathTmp ) )
	{
		_stprintf( tcstrText, _T("Found audio path %x.\n"), pIDirectMusicAudiopathTmp );
		OutputAudiopathText( tcstrText );
		dwIndex++;
		pIDirectMusicAudiopathTmp->Release();
	}

	if( dwIndex == 0 )
	{
		OutputAudiopathText( _T("No audio paths in audio path.\n") );
	}
}

void DumpAudiopathPerformance( IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IDirectMusicPerformance* pIDirectMusicPerformance = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( 0, DMUS_PATH_PERFORMANCE, 0,
		GUID_All_Objects, dwIndex, IID_IDirectMusicPerformance, (void**) &pIDirectMusicPerformance ) )
	{
		_stprintf( tcstrText, _T("Found performance %x.\n"), pIDirectMusicPerformance );
		OutputAudiopathText( tcstrText );
		dwIndex++;
		pIDirectMusicPerformance->Release();
	}

	if( dwIndex == 0 )
	{
		OutputAudiopathText( _T("No performances in audio path.\n") );
	}
}

void DumpAudiopathPort( IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR tcstrText[256];
	DMUS_PORTCAPS dmPortCaps;
	DWORD dwIndex = 0;
	IDirectMusicPort* pIDirectMusicPort = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0,
		GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void**) &pIDirectMusicPort ) )
	{
		ZeroMemory( &dmPortCaps, sizeof(DMUS_PORTCAPS) );
		dmPortCaps.dwSize = sizeof(DMUS_PORTCAPS);
		pIDirectMusicPort->GetCaps( &dmPortCaps );
		_stprintf( tcstrText, _T("Found port %x %S.\n"), pIDirectMusicPort, dmPortCaps.wszDescription );
		OutputAudiopathText( tcstrText );
		dwIndex++;
		pIDirectMusicPort->Release();
	}

	if( dwIndex == 0 )
	{
		OutputAudiopathText( _T("No ports in audio path.\n") );
	}
}

/*
void DumpAudiopathSink( IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IUnknown* pIDirectSoundSink = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_SINK, 0,
		GUID_All_Objects, dwIndex, IID_IUnknown, (void**) &pIDirectSoundSink ) )
	{
		_stprintf( tcstrText, _T("Found sink %x.\n"), pIDirectSoundSink );
		OutputAudiopathText( tcstrText );
		dwIndex++;
		pIDirectSoundSink->Release();
	}

	if( dwIndex == 0 )
	{
		OutputAudiopathText( _T("No sinks in audio path.\n") );
	}
}
*/

void DumpAudiopathGraph( DWORD dwStage, IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR *tcstrType = NULL;

	switch( dwStage )
	{
	case DMUS_PATH_SEGMENT_GRAPH:
		tcstrType = _T("segment");
		break;

	case DMUS_PATH_AUDIOPATH_GRAPH:
		tcstrType = _T("audiopath");
		break;

	case DMUS_PATH_PERFORMANCE_GRAPH:
		tcstrType = _T("performance");
		break;

	default:
		tcstrType = _T("unknown");
		break;
	}

	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IDirectMusicGraph* pIDirectMusicGraph = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( 0, dwStage, 0,
		GUID_All_Objects, dwIndex, IID_IDirectMusicGraph, (void**) &pIDirectMusicGraph ) )
	{
		_stprintf( tcstrText, _T("Found %s graph %x.\n"), tcstrType, pIDirectMusicGraph );
		OutputAudiopathText( tcstrText );
		dwIndex++;
		pIDirectMusicGraph->Release();
	}

	if( dwIndex == 0 )
	{
		_stprintf( tcstrText, _T("No %s graphs in audio path.\n"), tcstrType );
		OutputAudiopathText( tcstrText );
	}
}

void DumpAudiopathTool( DWORD dwStage, IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR *tcstrType = NULL;

	switch( dwStage )
	{
	case DMUS_PATH_SEGMENT_TOOL:
		tcstrType = _T("segment");
		break;

	case DMUS_PATH_AUDIOPATH_TOOL:
		tcstrType = _T("audio path");
		break;

	case DMUS_PATH_PERFORMANCE_TOOL:
		tcstrType = _T("performance");
		break;

	default:
		ASSERT(FALSE);
		return;
	}

	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IDirectMusicTool* pIDirectMusicTool = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, dwStage, 0,
		GUID_All_Objects, dwIndex, IID_IDirectMusicTool, (void**) &pIDirectMusicTool ) )
	{
		_stprintf( tcstrText, _T("Found %s tool %x.\n"), tcstrType, pIDirectMusicTool );
		OutputAudiopathText( tcstrText );
		dwIndex++;
		pIDirectMusicTool->Release();
	}

	if( dwIndex == 0 )
	{
		_stprintf( tcstrText, _T("No %s tools in audio path.\n"), tcstrType );
		OutputAudiopathText( tcstrText );
	}
}

void DumpAudiopathBufferDMO( DWORD dwStage, DWORD dwBufferIndex, IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR *tcstrType = NULL;

	DWORD dwPChannel;
	switch( dwStage )
	{
	case DMUS_PATH_BUFFER_DMO:
		tcstrType = _T("standard");
		dwPChannel = DMUS_PCHANNEL_ALL;
		break;

	case DMUS_PATH_MIXIN_BUFFER_DMO:
		tcstrType = _T("mixin");
		dwPChannel = 0;
		break;
	default:
		ASSERT(FALSE);
		return;
	}

	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IUnknown* pIUnknown = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( dwPChannel, dwStage, dwBufferIndex,
		GUID_All_Objects, dwIndex, IID_IUnknown, (void**) &pIUnknown ) )
	{
		_stprintf( tcstrText, _T("Found %s buffer dmo %x.\n"), tcstrType, pIUnknown );
		OutputAudiopathText( tcstrText );
		dwIndex++;
		pIUnknown->Release();
	}

	if( dwIndex == 0 )
	{
		_stprintf( tcstrText, _T("No %s buffer dmos in audio path.\n"), tcstrType );
		OutputAudiopathText( tcstrText );
	}
}

void DumpAudiopathBuffer( DWORD dwStage, IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR *tcstrType = NULL;

	DWORD dwPChannel;
	switch( dwStage )
	{
	case DMUS_PATH_BUFFER:
		tcstrType = _T("standard");
		dwPChannel = DMUS_PCHANNEL_ALL;
		break;

	case DMUS_PATH_MIXIN_BUFFER:
		tcstrType = _T("mixin");
		dwPChannel = 0;
		break;

	case DMUS_PATH_PRIMARY_BUFFER:
		tcstrType = _T("primary");
		dwPChannel = 0;
		break;

	default:
		ASSERT(FALSE);
		return;
	}

	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IDirectSoundBuffer* pIDirectSoundBuffer = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( dwPChannel, dwStage, dwIndex,
		GUID_All_Objects, 0, IID_IDirectSoundBuffer, (void**) &pIDirectSoundBuffer ) )
	{
		_stprintf( tcstrText, _T("Found %s buffer %x.\n"), tcstrType, pIDirectSoundBuffer );
		OutputAudiopathText( tcstrText );

		if( dwStage == DMUS_PATH_BUFFER )
		{
			DumpAudiopathBufferDMO( DMUS_PATH_BUFFER_DMO, dwIndex, pIDirectMusicAudiopath );
		}
		else if( dwStage == DMUS_PATH_MIXIN_BUFFER )
		{
			DumpAudiopathBufferDMO( DMUS_PATH_MIXIN_BUFFER_DMO, dwIndex, pIDirectMusicAudiopath );
		}

		dwIndex++;
		pIDirectSoundBuffer->Release();
	}

	if( dwIndex == 0 )
	{
		_stprintf( tcstrText, _T("No %s buffers in audio path.\n"), tcstrType );
		OutputAudiopathText( tcstrText );
	}
}

void DumpAudiopathPrimaryBuffer( IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	TCHAR tcstrText[256];
	DWORD dwIndex = 0;
	IDirectSoundBuffer* pIDirectSoundBuffer = NULL;
	while( S_OK == pIDirectMusicAudiopath->GetObjectInPath( 0, DMUS_PATH_PRIMARY_BUFFER, 0,
		GUID_All_Objects, dwIndex, IID_IDirectSoundBuffer, (void**) &pIDirectSoundBuffer ) )
	{
		_stprintf( tcstrText, _T("Found primary buffer %x.\n"), pIDirectSoundBuffer );
		OutputAudiopathText( tcstrText );

		dwIndex++;
		pIDirectSoundBuffer->Release();
	}

	if( dwIndex == 0 )
	{
		OutputAudiopathText( _T("No primary buffers in audio path.\n") );
	}
}

void DumpAudiopath( IDirectMusicAudioPath *pIDirectMusicAudiopath )
{
	ASSERT( pIDirectMusicAudiopath );
	if( !pIDirectMusicAudiopath )
	{
		OutputAudiopathText( _T("NULL pointer passed for audio path.\n") );
		return;
	}

	DumpAudiopathSegment( pIDirectMusicAudiopath );
	DumpAudiopathSegmentTrack( pIDirectMusicAudiopath );
	DumpAudiopathGraph( DMUS_PATH_SEGMENT_GRAPH, pIDirectMusicAudiopath );
	DumpAudiopathTool( DMUS_PATH_SEGMENT_TOOL, pIDirectMusicAudiopath );
	DumpAudiopathAudiopath( pIDirectMusicAudiopath );
	DumpAudiopathGraph( DMUS_PATH_AUDIOPATH_GRAPH, pIDirectMusicAudiopath );
	DumpAudiopathTool( DMUS_PATH_AUDIOPATH_TOOL, pIDirectMusicAudiopath );
	DumpAudiopathPerformance( pIDirectMusicAudiopath );
	DumpAudiopathGraph( DMUS_PATH_PERFORMANCE_GRAPH, pIDirectMusicAudiopath );
	DumpAudiopathTool( DMUS_PATH_PERFORMANCE_TOOL, pIDirectMusicAudiopath );
	DumpAudiopathPort( pIDirectMusicAudiopath );
	//DumpAudiopathSink( pIDirectMusicAudiopath );
	DumpAudiopathBuffer( DMUS_PATH_BUFFER, pIDirectMusicAudiopath ); // Also dumps DMOs
	DumpAudiopathBuffer( DMUS_PATH_MIXIN_BUFFER, pIDirectMusicAudiopath ); // Also dumps DMOs
	DumpAudiopathPrimaryBuffer( pIDirectMusicAudiopath );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\toolbar.cpp ===
// ToolbarHandler.cpp : implementation file
//

#include "stdafx.h"
#include "CConduct.h"
#include <math.h>
#include "Toolbar.h"
#include "OutputTool.h"
#include "DlgTransition.h"
#include "DlgAltTempo.h"
#include "TREntry.h"
#include <dmusicf.h>
#include "OptionsToolbar.h"
#include "SecondaryToolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void QueueSegmentState( IDirectMusicPerformance *pPerformance, MUSIC_TIME mtNow );

CToolbarHandler::CToolbarHandler()
{
	m_fInOnBarButtonClicked = FALSE;
	m_fPlayFromStart = FALSE;
	m_fStopImmediate = FALSE;
	m_fDontUpdateRewPlay = FALSE;
	m_fInTransition = FALSE;
	m_fDisplayingPlay = FALSE;
	m_mtPlayTime = 0;
	m_pCountInSegmentState = NULL;
}

CToolbarHandler::~CToolbarHandler()
{
	m_font.DeleteObject();
	if( m_pCountInSegmentState )
	{
		m_pCountInSegmentState->Release();
		m_pCountInSegmentState = NULL;
	}
}

BOOL CToolbarHandler::SetBtnState( int nID, UINT nState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( ::IsWindow( m_hWndToolbar ) )
	{
#ifdef _DEBUG
		if( (nID == ID_TRANSP_PLAY) && (nState == TBSTATE_ENABLED) )
		{
			ASSERT(FALSE);
		}
		else if( (nID == ID_TRANSP_STOP) && (nState == TBSTATE_ENABLED) )
		{
			ASSERT(FALSE);
		}
		else
#endif
		{
			return ::SendMessage( m_hWndToolbar, TB_SETSTATE, nID, MAKELONG(nState, 0) );
		}
	}

	return FALSE;
}

BOOL CToolbarHandler::SetState( DWORD dwFlags )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( ::IsWindow( m_hWndToolbar ) )
	{
		if( m_fDisplayingPlay )
		{
			if( (dwFlags & B_STOP_ENABLED) && !(dwFlags & B_STOP_CHECKED) )
			{
				// Change Play to Stop button
				TBBUTTONINFO buttonInfo;
				buttonInfo.cbSize = sizeof( TBBUTTONINFO );
				buttonInfo.dwMask = TBIF_COMMAND | TBIF_IMAGE | TBIF_STATE | TBIF_STYLE;
				buttonInfo.idCommand = ID_TRANSP_STOP;
				buttonInfo.iImage = 9;
				buttonInfo.fsState = TBSTATE_ENABLED;
				buttonInfo.fsStyle = TBSTYLE_BUTTON;
				buttonInfo.cx = 0;
				buttonInfo.lParam = 0;
				buttonInfo.pszText = 0;
				buttonInfo.cchText = 0;
				//TRACE("Change play->stop.\n");
				::SendMessage( m_hWndToolbar, TB_SETBUTTONINFO, ID_TRANSP_PLAY, LPARAM(&buttonInfo) );

				buttonInfo.cbSize = sizeof( TBBUTTONINFO );
				buttonInfo.dwMask = TBIF_COMMAND | TBIF_IMAGE | TBIF_STATE | TBIF_STYLE;
				buttonInfo.idCommand = ID_TRANS_STOPIMMEDIATE;
				buttonInfo.iImage = 1;
				buttonInfo.fsState = TBSTATE_ENABLED;
				buttonInfo.fsStyle = TBSTYLE_BUTTON;
				buttonInfo.cx = 0;
				buttonInfo.lParam = 0;
				buttonInfo.pszText = 0;
				buttonInfo.cchText = 0;
				//TRACE("Change play->stop.\n");
				::SendMessage( m_hWndToolbar, TB_SETBUTTONINFO, ID_TRANS_REWPLAY, LPARAM(&buttonInfo) );

				//TRACE("Update m_fDisplayingPlay\n");
				m_fDisplayingPlay = FALSE;
			}
			else
			{
				// Play button
				if (dwFlags & B_PLAY_ENABLED)
				{
					::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANSP_PLAY, MAKELONG(TRUE, 0) );
					::SendMessage( m_hWndToolbar, TB_INDETERMINATE, ID_TRANSP_PLAY, MAKELONG(FALSE, 0) );
					if ( !m_fDontUpdateRewPlay )
					{
						::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANS_REWPLAY, MAKELONG(TRUE, 0) );
						::SendMessage( m_hWndToolbar, TB_INDETERMINATE, ID_TRANS_REWPLAY, MAKELONG(FALSE, 0) );
					}
				}
				else
				{
					::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANSP_PLAY, MAKELONG(FALSE, 0) );
					if ( !m_fDontUpdateRewPlay )
					{
						::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANS_REWPLAY, MAKELONG(FALSE, 0) );
					}
				}
				if (dwFlags & B_PLAY_CHECKED)
				{
					::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_PLAY, MAKELONG(TRUE, 0) );
				}
				else
				{
					::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_PLAY, MAKELONG(FALSE, 0) );
				}
			}
		}
		else
		{
			if( (dwFlags & B_PLAY_ENABLED) && !(dwFlags & B_PLAY_CHECKED) )
			{
				// Change Stop to Play button
				TBBUTTONINFO buttonInfo;
				buttonInfo.cbSize = sizeof( TBBUTTONINFO );
				buttonInfo.dwMask = TBIF_COMMAND | TBIF_IMAGE | TBIF_STATE | TBIF_STYLE;
				buttonInfo.idCommand = ID_TRANSP_PLAY;
				buttonInfo.iImage = 0;
				buttonInfo.fsState = TBSTATE_ENABLED;
				buttonInfo.fsStyle = TBSTYLE_BUTTON;
				buttonInfo.cx = 0;
				buttonInfo.lParam = 0;
				buttonInfo.pszText = 0;
				buttonInfo.cchText = 0;
				//TRACE("Change stop->play.\n");
				::SendMessage( m_hWndToolbar, TB_SETBUTTONINFO, ID_TRANSP_STOP, LPARAM(&buttonInfo) );

				buttonInfo.cbSize = sizeof( TBBUTTONINFO );
				buttonInfo.dwMask = TBIF_COMMAND | TBIF_IMAGE | TBIF_STATE | TBIF_STYLE;
				buttonInfo.idCommand = ID_TRANS_REWPLAY;
				buttonInfo.iImage = 8;
				buttonInfo.fsState = TBSTATE_ENABLED;
				buttonInfo.fsStyle = TBSTYLE_BUTTON;
				buttonInfo.cx = 0;
				buttonInfo.lParam = 0;
				buttonInfo.pszText = 0;
				buttonInfo.cchText = 0;
				//TRACE("Change stop->play.\n");
				::SendMessage( m_hWndToolbar, TB_SETBUTTONINFO, ID_TRANS_STOPIMMEDIATE, LPARAM(&buttonInfo) );

				//TRACE("Update m_fDisplayingPlay\n");
				m_fDisplayingPlay = TRUE;
			}
			else
			{
				// Stop button
				if (dwFlags & B_STOP_ENABLED)
				{
					::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANSP_STOP, MAKELONG(TRUE, 0) );
					::SendMessage( m_hWndToolbar, TB_INDETERMINATE, ID_TRANSP_STOP, MAKELONG(FALSE, 0) );
					if ( !m_fDontUpdateRewPlay )
					{
						::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANS_STOPIMMEDIATE, MAKELONG(TRUE, 0) );
						::SendMessage( m_hWndToolbar, TB_INDETERMINATE, ID_TRANS_STOPIMMEDIATE, MAKELONG(FALSE, 0) );
					}
				}
				else
				{
					::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANSP_STOP, MAKELONG(FALSE, 0) );
					if ( !m_fDontUpdateRewPlay )
					{
						::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANS_STOPIMMEDIATE, MAKELONG(FALSE, 0) );
					}
				}
				if (dwFlags & B_STOP_CHECKED)
				{
					::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_STOP, MAKELONG(TRUE, 0) );
				}
				else
				{
					::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_STOP, MAKELONG(FALSE, 0) );
				}
			}
		}

		// Play from start button
		/*
		if( !m_fDontUpdateRewPlay )
		{
			if ((dwFlags & B_PLAY_ENABLED) || (dwFlags & B_STOP_ENABLED))
			{
				::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANS_STOPIMMEDIATE, MAKELONG(FALSE, 0) );
				m_buttonPlayFromStart.EnableWindow( TRUE );
			}
			else
			{
				::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANS_STOPIMMEDIATE, MAKELONG(FALSE, 0) );
				m_buttonPlayFromStart.EnableWindow( FALSE );
			}
			if ((dwFlags & B_PLAY_CHECKED) || (dwFlags & B_STOP_CHECKED))
			{
				if ( m_fDisplayingPlay && m_fPlayFromStart && (dwFlags & B_PLAY_CHECKED) )
				{
					m_buttonPlayFromStart.SetState( ODS_CHECKED | ODS_SELECTED | ODS_FOCUS );
				}
				else if ( !m_fDisplayingPlay && m_fStopImmediate && (dwFlags & B_STOP_CHECKED) )
				{
					m_buttonPlayFromStart.SetState( ODS_CHECKED | ODS_SELECTED | ODS_FOCUS );
				}
				else
				{
					m_buttonPlayFromStart.SetState( 0 );
				}
			}
			else
			{
				m_buttonPlayFromStart.SetState( 0 );
			}
		}
		*/

		// Transition button
		if (dwFlags & B_TRANS_ENABLED)
		{
			::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANSP_TRANSITION, MAKELONG(TRUE, 0) );
			::SendMessage( m_hWndToolbar, TB_INDETERMINATE, ID_TRANSP_TRANSITION, MAKELONG(FALSE, 0) );
		}
		else
		{
			::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANSP_TRANSITION, MAKELONG(FALSE, 0) );
		}
		if (dwFlags & B_TRANS_CHECKED)
		{
			::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_TRANSITION, MAKELONG(TRUE, 0) );
		}
		else
		{
			::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_TRANSITION, MAKELONG(FALSE, 0) );
		}

		// Record button
		if (dwFlags & B_REC_ENABLED)
		{
			::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANSP_RECORD, MAKELONG(TRUE, 0) );
			::SendMessage( m_hWndToolbar, TB_INDETERMINATE, ID_TRANSP_RECORD, MAKELONG(FALSE, 0) );
		}
		else
		{
			::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, ID_TRANSP_RECORD, MAKELONG(FALSE, 0) );
		}
		if (dwFlags & B_REC_CHECKED)
		{
			::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_RECORD, MAKELONG(TRUE, 0) );
		}
		else
		{
			::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_RECORD, MAKELONG(FALSE, 0) );
		}
		return TRUE;
	}

	return FALSE;
}

// Set the state of the play, stop and transition buttons based on the current
// state of DMUSProd.

void CToolbarHandler::SetStateFromEngine( DWORD *pdwState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT( pdwState != NULL );

	if (pdwState == NULL)
	{
		return;
	}

	#define PACK_BUTTON_STATES(play_enabled,play_checked,stop_enabled,transition_enabled) \
	((play_enabled) + ((play_checked) << 1) + ((stop_enabled) << 2) + ((transition_enabled) << 3))
	#define UNPACK_PLAY_ENABLED(c) ((c) & 1 ? B_PLAY_ENABLED:0)
	#define UNPACK_PLAY_CHECKED(c) ((c) & (1 << 1) ? B_PLAY_CHECKED:0)
	#define UNPACK_STOP_ENABLED(c) ((c) & (1 << 2) ? B_STOP_ENABLED:0)
	#define UNPACK_TRANSITION_ENABLED(c) ((c) & (1 << 3) ? B_TRANS_ENABLED:0)

	static char truthtable[] =
	{
		// +---m_rpActive != NULL (i.e. There is a valid active transport to receive play.)
		// |+---IsPlaying() == TRUE
		// ||
		/* 00 */ PACK_BUTTON_STATES(0,0,0,0),
		/* 01 */ PACK_BUTTON_STATES(0,1,1,0),
		/* 10 */ PACK_BUTTON_STATES(1,0,0,0),
		/* 11 */ PACK_BUTTON_STATES(0,1,1,1),
	};

	int select = 0;
	select = select + (g_pconductor->m_rpActive != NULL ? 1:0);
	select = select << 1;
	select = select + (g_pconductor->IsEnginePlaying() ? 1:0);
	
	char t = truthtable[select];
	
	*pdwState &= ~(B_PLAY_ENABLED | B_PLAY_CHECKED | B_STOP_ENABLED | B_TRANS_ENABLED);
	*pdwState |= UNPACK_PLAY_ENABLED(t);
	*pdwState |= UNPACK_PLAY_CHECKED(t);
	*pdwState |= UNPACK_STOP_ENABLED(t);

	if( g_pconductor->IsEnginePlaying()
	&&	g_pconductor->m_TransitionOptions.dwFlags & TRANS_TO_NOTHING )
	{
		// Always enable Transition if TRANS_TO_NOTHING is set and the engine is playing
		*pdwState |= B_TRANS_ENABLED;
	}
	else
	{
		*pdwState |= UNPACK_TRANSITION_ENABLED(t);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CToolbarHandler IDMUSProdToolBar::GetInfo

HRESULT CToolbarHandler::GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( (phWndOwner == NULL)
	||	(phInstance == NULL)
	||	(pnResourceId == NULL)
	||	(pbstrTitle == NULL) )
	{
		return E_POINTER;
	}

	*phWndOwner = m_hWnd;
	*phInstance = _Module.GetResourceInstance();
	*pnResourceId = (UINT)-1;  // we are going to build the toolbar from scratch

	CString strTitle;
	strTitle.LoadString(IDS_TRANSPORT_TITLE);
	*pbstrTitle = strTitle.AllocSysString();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CToolbarHandler IDMUSProdToolBar::GetMenuText

HRESULT CToolbarHandler::GetMenuText( BSTR* pbstrText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrText == NULL )
	{
		return E_POINTER;
	}

	CString strText;
	strText.LoadString(IDS_TRANSPORT_MENUTEXT);
	*pbstrText = strText.AllocSysString();
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CToolbarHandler IDMUSProdToolBar::GetMenuHelpText

HRESULT CToolbarHandler::GetMenuHelpText( BSTR* pbstrMenuHelpText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrMenuHelpText == NULL )
	{
		return E_POINTER;
	}

	CString strMenuHelpText;
	strMenuHelpText.LoadString(IDS_TRANSPORT_HELP);
	*pbstrMenuHelpText = strMenuHelpText.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CToolbarHandler IDMUSProdToolBar::Initialize

HRESULT CToolbarHandler::Initialize( HWND hWndToolBar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( hWndToolBar == NULL )
	{
		return E_INVALIDARG;
	}
	m_hWndToolbar = hWndToolBar;
 
	CToolBarCtrl* pToolBarCtrl = new CToolBarCtrl;
	if( pToolBarCtrl == NULL )
	{
		return E_OUTOFMEMORY;
	}

	pToolBarCtrl->Attach( hWndToolBar );
	pToolBarCtrl->AddBitmap( 10, IDB_Transport );

	// Create font for toolbar combo box
	CClientDC* pDC = new CClientDC( pToolBarCtrl );

	int nHeight = -( (pDC->GetDeviceCaps(LOGPIXELSY) * 8) / 72 );

	CString strFontName;
	if( strFontName.LoadString( IDS_TOOLBAR_FONT ) == 0)
	{
		strFontName = CString("MS Sans Serif");
	}
	m_font.CreateFont( nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,
		DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
		DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, strFontName );
	
	CFont* pOldFont = pDC->SelectObject( &m_font );
	
	TEXTMETRIC tm;
	pDC->GetTextMetrics( &tm );
	int cxChar = tm.tmAveCharWidth;
	int cyChar = tm.tmHeight + tm.tmExternalLeading;

	pDC->SelectObject( pOldFont );
	delete pDC;

	TBBUTTON button;
	button.dwData = 0;
	button.iString = NULL;

	// 9 - Wide separator for relative tempo
	button.iBitmap = cxChar * 12;
	button.idCommand = IDC_RELATIVE_TEMPO;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	pToolBarCtrl->InsertButton( 0, &button );

	// 8 - Wide separator for tempo
	button.iBitmap = cxChar * 13;
	button.idCommand = IDC_TEMPO;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	pToolBarCtrl->InsertButton( 0, &button );

	// 7 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	pToolBarCtrl->InsertButton( 0, &button );

	// 6 - Transition
	button.iBitmap = 2;
	button.idCommand = ID_TRANSP_TRANSITION;
	button.fsState = TBSTATE_INDETERMINATE;
	button.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton( 0, &button );

	// 5 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	pToolBarCtrl->InsertButton( 0, &button );

	// 4 - Record
	button.iBitmap = 5;
	button.idCommand = ID_TRANSP_RECORD;
	button.fsState = TBSTATE_INDETERMINATE;
	button.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton( 0, &button );

	// 4 - Stop
	/*
	button.iBitmap = 1;
	button.idCommand = ID_TRANSP_STOP;
	button.fsState = TBSTATE_INDETERMINATE;
	button.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton( 0, &button );
	*/

	// 3 - Play
	button.iBitmap = 0;
	button.idCommand = ID_TRANSP_PLAY;
	button.fsState = TBSTATE_INDETERMINATE;
	button.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton( 0, &button );
	m_fDisplayingPlay = TRUE;

	// 2 - Play from beggining
	button.iBitmap = 8;
	button.idCommand = ID_TRANS_REWPLAY;
	button.fsState = TBSTATE_INDETERMINATE;
	button.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton( 0, &button );

	// 1 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	pToolBarCtrl->InsertButton( 0, &button );

	// 0 - Wide separator for active transport indicator
	button.iBitmap = cxChar * 30;
	button.idCommand = IDC_TRANSP_COMBO;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	pToolBarCtrl->InsertButton( 0, &button );

	// Attach the synth button
	CRect rect;

	// Attach the relative tempo window
	pToolBarCtrl->GetItemRect( 9, &rect );
	CString str;
	if (g_pconductor)
	{
		str.Format("x%3d%%",g_pconductor->m_nRatio);
	}
	if( !m_buttonRatio.Create(str, WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX | BS_PUSHLIKE,
		rect, pToolBarCtrl, IDC_RELATIVE_TEMPO) )
	{
		return -1;
	}
	m_buttonRatio.SetFont( &m_font );
	m_buttonRatio.EnableWindow(TRUE);
	DWORD dwData;
	if( GetNewRegDWORD( _T("TempoRatioEnabled"), &dwData ) && (dwData != 0) )
	{
		m_buttonRatio.SetCheck( 1 );
		// CConductor::InitializeDirectMusic will set the state of the performance
		// engine to reflect the button's initial state
	}

	// Attach the tempo window
	pToolBarCtrl->GetItemRect( 8, &rect );
	// Don't add ES_NUMBER, or the user won't be able to enter decimal points
	if( !m_editTempo.Create(WS_CHILD | WS_VISIBLE | ES_LEFT | ES_WANTRETURN,
		rect, pToolBarCtrl, IDC_TEMPO) )
	{
		return -1;
	}
	m_editTempo.ModifyStyleEx( 0, WS_EX_CLIENTEDGE );
	m_editTempo.SetFont( &m_font );
	m_editTempo.EnableWindow(FALSE);
	m_editTempo.SetLimitText(7);// 1000.00

	// Attach the tempo spin control
	if( !m_spinTempo.Create(WS_CHILD | WS_VISIBLE |
		UDS_ARROWKEYS | UDS_ALIGNRIGHT | UDS_WRAP | UDS_SETBUDDYINT | UDS_NOTHOUSANDS,
		rect, pToolBarCtrl, IDC_SPIN_TEMPO) )
	{
		return -1;
	}
	m_spinTempo.SetBuddy( &m_editTempo );
	m_spinTempo.SetRange( DMUS_TEMPO_MIN, DMUS_TEMPO_MAX );
	m_spinTempo.SetPos( 120 );
	m_spinTempo.EnableWindow(TRUE);

	// Attach the combo box window
	pToolBarCtrl->GetItemRect( 0, &rect );
	rect.bottom = rect.top + (cyChar * 21);
	if( !m_comboActive.Create(WS_CHILD | WS_VISIBLE | WS_VSCROLL |
		CBS_DROPDOWNLIST | CBS_HASSTRINGS | CBS_SORT,
		rect, pToolBarCtrl, IDC_TRANSP_COMBO) )
	{
		return -1;
	}
	m_comboActive.SetFont( &m_font );
	m_comboActive.EnableWindow(FALSE);

	if( pToolBarCtrl )
	{
		pToolBarCtrl->Detach();
		delete pToolBarCtrl;
	}

	m_fInTransition = FALSE;
	m_fInOnBarButtonClicked = FALSE;
	m_fPlayFromStart = FALSE;
	m_fDontUpdateRewPlay = FALSE;
	m_fStopImmediate = FALSE;

	return S_OK;
}

LRESULT CToolbarHandler::OnPlayClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);

	//TRACE("OnPlayClicked enter\n");
	//ASSERT( m_fDisplayingPlay );
	if( !m_fDisplayingPlay )
	{
		//TRACE("OnPlayClicked exit - stop button enabled\n");
		m_fInOnBarButtonClicked = FALSE;
		return 0;
	}

	if ( m_fInOnBarButtonClicked )
	{
		m_fInOnBarButtonClicked = FALSE;
		m_fPlayFromStart = TRUE;
	}
	else
	{
		m_fPlayFromStart = FALSE;
	}

	// Force KillFocus to give controls a chance to sync changes handled in KillFocus code
	CWnd* pWndHadFocus = CWnd::GetFocus();
	::SetFocus( NULL );
	if( pWndHadFocus )
	{
		pWndHadFocus->SetFocus();
	}

	/*
	// If something is playing, make it stop before playing.
	if( IsValid( g_pconductor->m_rpPlaying ) )
	{
		IDMUSProdTransport*  pITransport;
		g_pconductor->m_rpPlaying->GetTransport( &pITransport );
		if (FAILED(pITransport->Stop()))
		{
			ASSERT(FALSE);
			return FALSE;
		}
		else
		{
			// If we've stopped the engine, wait for the engine to really stop
			if ( g_pconductor->IsPlayingUsingEngine() )
			{
				short n = 0;
				while( n++ < 20 )
				{
					if( !g_pconductor->IsEnginePlaying() )
					{
						break;
					}
					Sleep( 100 );
				}
				if (n>20)
				{
					ASSERT(FALSE);
					TRACE("OnPlayClicked Timed out while stopping playing transport\n");
				}
				UpdatePlayingFromEngine();
			}
			else
			{
				// Transport is responsible for updating its flags
			}
			g_pconductor->m_rpPlaying = NULL;
			SetStateAuto();
		}
	}
	*/
	// Dispatch the play message to the active transport.
	if( IsValid( g_pconductor->m_rpActive ) )
	{
		IDMUSProdTransport*  pITransport;
		g_pconductor->m_rpActive->GetTransport( &pITransport );

		// Ensure the transport correctly tracks/doesn't track the cursor
		pITransport->TrackCursor( g_pconductor->m_pOptionsToolbarHandler ? g_pconductor->m_pOptionsToolbarHandler->m_fCursorEnabled : TRUE );

		ITransportRegEntry *pTmpPlaying = g_pconductor->m_rpPlaying;
		g_pconductor->m_rpPlaying = g_pconductor->m_rpActive;

		g_pconductor->m_pDMPerformance->GetTime( NULL, &m_mtPlayTime );

		PlayCountInSegment( pITransport );

		if (FAILED(pITransport->Play( m_fPlayFromStart )))
		{
			// Leave the buttons in their current state.
			g_pconductor->m_rpPlaying = pTmpPlaying;
			//TRACE("OnPlayClicked exit - play failed\n");
			return FALSE;
		}
		
		//EnableTimer(TRUE);

		if ( g_pconductor->IsPlayingUsingEngine() )
		{
			// Wait and see if the engine really started playing.
			short n = 0;
			while( n++ < 20 )
			{
				if( g_pconductor->IsEnginePlaying() )
				{
					UpdateActiveFromEngine();
					SetStateAuto();
					g_pconductor->SetMIDIExportFields( (IUnknown *)pITransport );
					//TRACE("OnPlayClicked exit - play music succeeded\n");
					return TRUE;
				}
				Sleep( 100 );
			}

			TRACE("OnPlayClicked Timed out while starting new transport\n");

			UpdatePlayingFromEngine();
			if (g_pconductor->m_rpPlaying != g_pconductor->m_rpActive)
			{
				UpdateActiveFromEngine();
			}
			g_pconductor->m_rpPlaying = NULL;
			SetStateAuto();
			//TRACE("OnPlayClicked exit\n");
			return FALSE;
		}
		else
		{
			// Not using the engine, so we can't double-check that the
			// transport actually started playing
			// The transport is responsible for setting the button states.
			// Switch to displaying the playing buttons, rather than the active buttons
			SetStateAuto();
			g_pconductor->SetMIDIExportFields( (IUnknown *)pITransport );
			//TRACE("OnPlayClicked exit - play succeeded\n");
			return TRUE;
		}
	}
	else
	{
		// Leave the buttons in their current state.
	}
	//TRACE("OnPlayClicked exit - last\n");
	return FALSE;
}

LRESULT CToolbarHandler::OnStopClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	//TRACE("OnStopClicked enter\n");
	if( m_fDisplayingPlay )
	{
		//TRACE("OnStopClicked exiting early - play button enabled.\n");
		m_fInOnBarButtonClicked = FALSE;
		return FALSE;
	}

	if ( m_fInOnBarButtonClicked )
	{
		m_fInOnBarButtonClicked = FALSE;
		m_fStopImmediate = TRUE;
	}
	else
	{
		m_fStopImmediate = FALSE;
	}

	// Capture the state of the control key
	BOOL fCtrlKeyDown;
	fCtrlKeyDown = ((GetKeyState( VK_CONTROL ) & 0x8000) != 0);

	if( m_pCountInSegmentState )
	{
		// Stop the Count-In segment state
		// Don't pay attention to the m_fStopImmediate flag.
		g_pconductor->m_pDMPerformance->Stop( NULL, m_pCountInSegmentState, 0, 0 );

		// Release the Count-In segment state
		m_pCountInSegmentState->Release();
		m_pCountInSegmentState = NULL;
	}

	BOOL fSendAllNotesOff = TRUE;

	if( !fCtrlKeyDown )
	{
		// Control key up - stop all secondary segments.
		// Stop all Secondary Segments
		POSITION pos = g_pconductor->m_lstSecondaryToolbars.GetHeadPosition();
		while( pos )
		{
			CSecondaryToolbarHandler *pToolbarHandler = g_pconductor->m_lstSecondaryToolbars.GetNext( pos );
			BOOL bHandled;
			for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
			{
				pToolbarHandler->OnButtonClicked( 0, (WORD)(ID_TRANSP_STOP1 + i), 0, bHandled );
			}
		}
	}
	else
	{
		// Check if any secondary segments are currently playing
		POSITION pos = g_pconductor->m_lstSecondaryToolbars.GetHeadPosition();
		while( pos && fSendAllNotesOff )
		{
			CSecondaryToolbarHandler *pToolbarHandler = g_pconductor->m_lstSecondaryToolbars.GetNext( pos );
			for( DWORD i=0; i < pToolbarHandler->m_dwNumButtons; i++ )
			{
				if( pToolbarHandler->m_arrayButtons[i]->pISegmentState )
				{
					// Something's playing - don't send AllNotesOff
					fSendAllNotesOff = FALSE;
					break;
				}
			}
		}
	}

	//ASSERT( g_pconductor->m_rpPlaying != NULL );
	if( IsValid( g_pconductor->m_rpPlaying ) )
	{
		IDMUSProdTransport*  pITransport;
		ITransportRegEntry *pPlaying = g_pconductor->m_rpPlaying;
		g_pconductor->m_rpPlaying->GetTransport( &pITransport );
		if (pITransport)
		{
			if (FAILED(pITransport->Stop( m_fStopImmediate )))
			{
				// Try and stop the music
				MUSIC_TIME mtNow;
				if( SUCCEEDED( g_pconductor->m_pDMPerformance->GetTime( NULL, &mtNow ) ) )
				{
					// If stop at boundary chosen, update mtNow to reflect the boundary of the current segment state
					if( !m_fStopImmediate )
					{
						IDirectMusicSegmentState *pSegState;
						if( SUCCEEDED( g_pconductor->m_pDMPerformance->GetSegmentState( &pSegState, mtNow ) ) )
						{
							DWORD dwResolution = 0;
							IDirectMusicSegment *pSegment;
							if( SUCCEEDED( pSegState->GetSegment( &pSegment ) ) )
							{
								pSegment->GetDefaultResolution( &dwResolution );
								pSegment->Release();
							}

							REFERENCE_TIME rtNow;
							g_pconductor->m_pDMPerformance->GetQueueTime(&rtNow);
							g_pconductor->m_pDMPerformance->GetResolvedTime(rtNow, &rtNow, dwResolution);
							g_pconductor->m_pDMPerformance->ReferenceToMusicTime(rtNow, &mtNow);
							pSegState->Release();
						}
					}

					if( !fCtrlKeyDown )
					{
						// Control key up - stop all segments.
						g_pconductor->m_pDMPerformance->Stop( NULL, NULL, mtNow, 0 );
					}
					else
					{
						// Stop just primary segment
						QueueSegmentState( g_pconductor->m_pDMPerformance, mtNow );
					}
				}
				//TRACE("OnStopClicked exit - Stop failed\n");
				//return FALSE;
			}
			//EnableTimer(FALSE);

			// Always tell the transport we released the record button
			pITransport->Record( FALSE );

			// Pop up the Record button if it is pressed
			DWORD dwFlags;
			pPlaying->GetFlags( &dwFlags );
			if( (dwFlags & B_REC_CHECKED) != 0 )
			{
				dwFlags &= ~B_REC_CHECKED;
				pPlaying->SetFlags( dwFlags );
				::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_RECORD, MAKELONG(FALSE, 0) );
			}

			if ( g_pconductor->IsPlayingUsingEngine() )
			{
				// Only wait for the music to stop if an immediate stop was requested
				if( m_fStopImmediate )
				{
					short n = 0;
					while( n++ < 20 )
					{
						if( !g_pconductor->IsEnginePlaying() )
						{
							g_pconductor->m_rpPlaying = NULL;

							UpdateActiveFromEngine();
							m_fPlayFromStart = FALSE;
							m_fStopImmediate = FALSE;
							SetStateAuto();
							// Send all notes/controllers/sound off commands
							if( fSendAllNotesOff )
							{
								g_pconductor->SendAllNotesOff( 250, FALSE );
							}

							//TRACE("OnStopClicked exit - Stop succeeded\n");
							return TRUE;
						}
						Sleep( 100 );
					}

					TRACE("OnStopClicked Timed out\n");

					// Try and stop the music
					MUSIC_TIME mtNow;
					if( SUCCEEDED( g_pconductor->m_pDMPerformance->GetTime( NULL, &mtNow ) ) )
					{
						// If stop at boundary chosen, update mtNow to reflect the boundary of the current segment state
						if( !m_fStopImmediate )
						{
							IDirectMusicSegmentState *pSegState;
							if( SUCCEEDED( g_pconductor->m_pDMPerformance->GetSegmentState( &pSegState, mtNow ) ) )
							{
								DWORD dwResolution = 0;
								IDirectMusicSegment *pSegment;
								if( SUCCEEDED( pSegState->GetSegment( &pSegment ) ) )
								{
									pSegment->GetDefaultResolution( &dwResolution );
									pSegment->Release();
								}

								REFERENCE_TIME rtNow;
								g_pconductor->m_pDMPerformance->GetQueueTime(&rtNow);
								g_pconductor->m_pDMPerformance->GetResolvedTime(rtNow, &rtNow, dwResolution);
								g_pconductor->m_pDMPerformance->ReferenceToMusicTime(rtNow, &mtNow);
								pSegState->Release();
							}
						}

						if( !fCtrlKeyDown )
						{
							// Control key up - stop all segments.
							g_pconductor->m_pDMPerformance->Stop( NULL, NULL, mtNow, 0 );
						}
						else
						{
							// Stop just primary segment
							QueueSegmentState( g_pconductor->m_pDMPerformance, mtNow );
						}
					}

					// Something messed up.  Refresh the playing buttons
					UpdatePlayingFromEngine();
					m_fPlayFromStart = FALSE;
					m_fStopImmediate = FALSE;
					SetStateAuto();
					// Send all notes/controllers/sound off commands
					if( fSendAllNotesOff )
					{
						g_pconductor->SendAllNotesOff( 250, FALSE );
					}
					//TRACE("OnStopClicked exit - Stop failed\n");
				}
				return FALSE;
			}
			else
			{
				// Not using the engine, so we can't double-check that the
				// transport actually stopped
				g_pconductor->m_rpPlaying = NULL;

				// Update the active flags, if they're using the engine
				UpdateActiveFromEngine();

				// Switch to displaying the active buttons
				m_fPlayFromStart = FALSE;
				SetStateAuto();
				// Send all notes/controllers/sound off commands
				if( fSendAllNotesOff )
				{
					g_pconductor->SendAllNotesOff( 250, FALSE );
				}
				//TRACE("OnStopClicked exit - Stop no music succeeded\n");
				return TRUE;
			}
		}
	}
	else
	{
		TRACE("OnStopClicked: playing index is invalid!\n");
		if( IsValid( g_pconductor->m_rpActive ) )
		{
			ITransportRegEntry *pPlaying = g_pconductor->m_rpActive;
			IDMUSProdTransport*  pITransport;
			g_pconductor->m_rpActive->GetTransport( &pITransport );
			if (pITransport)
			{
				if (FAILED(pITransport->Stop( m_fStopImmediate )))
				{
					//TRACE("OnStopClicked exit - Stop failed\n");
				}
				//EnableTimer(FALSE);

				// Always tell the transport we released the record button
				pITransport->Record( FALSE );

				// Pop up the Record button if it is pressed
				DWORD dwFlags;
				pPlaying->GetFlags( &dwFlags );
				if( (dwFlags & B_REC_CHECKED) != 0 )
				{
					dwFlags &= ~B_REC_CHECKED;
					pPlaying->SetFlags( dwFlags );
					::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_RECORD, MAKELONG(FALSE, 0) );
				}

				// Try and stop the music
				MUSIC_TIME mtNow;
				if( SUCCEEDED( g_pconductor->m_pDMPerformance->GetTime( NULL, &mtNow ) ) )
				{
					// If stop at boundary chosen, update mtNow to reflect the boundary of the current segment state
					if( !m_fStopImmediate )
					{
						IDirectMusicSegmentState *pSegState;
						if( SUCCEEDED( g_pconductor->m_pDMPerformance->GetSegmentState( &pSegState, mtNow ) ) )
						{
							DWORD dwResolution = 0;
							IDirectMusicSegment *pSegment;
							if( SUCCEEDED( pSegState->GetSegment( &pSegment ) ) )
							{
								pSegment->GetDefaultResolution( &dwResolution );
								pSegment->Release();
							}

							REFERENCE_TIME rtNow;
							g_pconductor->m_pDMPerformance->GetQueueTime(&rtNow);
							g_pconductor->m_pDMPerformance->GetResolvedTime(rtNow, &rtNow, dwResolution);
							g_pconductor->m_pDMPerformance->ReferenceToMusicTime(rtNow, &mtNow);
							pSegState->Release();
						}
					}

					if( !fCtrlKeyDown )
					{
						// Control key up - stop all segments.
						g_pconductor->m_pDMPerformance->Stop( NULL, NULL, mtNow, 0 );
					}
					else
					{
						// Stop just primary segment
						QueueSegmentState( g_pconductor->m_pDMPerformance, mtNow );
					}
				}

				UpdateActiveFromEngine();
				m_fPlayFromStart = FALSE;
				m_fStopImmediate = FALSE;
				SetStateAuto();
				// Send all notes/controllers/sound off commands
				if( fSendAllNotesOff )
				{
					g_pconductor->SendAllNotesOff( 250, FALSE );
				}

				//TRACE("OnStopClicked exit - Stop succeeded\n");
				return TRUE;
			}
		}
	}

	//TRACE("OnStopClicked exit\n");
	return FALSE;
}

LRESULT CToolbarHandler::OnTransitionClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);

	m_fInTransition = TRUE;

	if( g_pconductor->m_TransitionOptions.dwFlags & TRANS_TO_NOTHING )
	{
		// Transition to nothing
		TransitionToNothing();
		m_fInTransition = FALSE;
		return TRUE;
	}

	ASSERT( g_pconductor->m_rpActive != NULL );
	// We should never even get here if m_rpActive is NULL, but just in case.
	if( IsValid( g_pconductor->m_rpActive ) )
	{
		// Get a pointer to the active transport
		IDMUSProdTransport*  pITransportActive;
		g_pconductor->m_rpActive->GetTransport( &pITransportActive );

		// Try and get pointers to the currently playing transport
		IDMUSProdTransport*  pITransportPlaying = NULL;
		if( IsValid( g_pconductor->m_rpPlaying ) )
		{
			g_pconductor->m_rpPlaying->GetTransport( &pITransportPlaying );
		}

		// Save the original settings, in case we have to change them
		DWORD dwOrigFlags = g_pconductor->m_TransitionOptions.dwFlags;
		DWORD dwOrigBoundaryFlags = g_pconductor->m_TransitionOptions.dwBoundaryFlags;

		// If the current segment repeats endlessly, change the transition option from
		// 'End of segment' to 'next bar'
		if( (g_pconductor->m_TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT)
		||	( (g_pconductor->m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_SEGMENTEND)
			 && !(g_pconductor->m_TransitionOptions.dwBoundaryFlags & DMUS_COMPOSEF_ALIGN) ) )
		{
			MUSIC_TIME mtNow;
			if( SUCCEEDED( g_pconductor->m_pDMPerformance->GetTime( NULL, &mtNow ) ) )
			{
				IDirectMusicSegmentState* pSegState;
				if( SUCCEEDED( g_pconductor->m_pDMPerformance->GetSegmentState( &pSegState, mtNow ) ) )
				{
					IDirectMusicSegment* pSegment;
					if( SUCCEEDED( pSegState->GetSegment( &pSegment ) ) )
					{
						// Check if this segment is a Pattern audition segment
						IDirectMusicObject *pIDirectMusicObject = NULL;
						if( SUCCEEDED( pSegment->QueryInterface( IID_IDirectMusicObject, (void **)&pIDirectMusicObject ) ) )
						{
							DMUS_OBJECTDESC objDesc;
							objDesc.dwSize = sizeof( DMUS_OBJECTDESC );
							if( SUCCEEDED( pIDirectMusicObject->GetDescriptor( &objDesc ) )
							&&	(objDesc.dwValidData & DMUS_OBJ_OBJECT)
							&&	(objDesc.guidObject == GUID_PatternAuditionSegment) )
							{
								// This is a pattern audition segment - change the boundary to 'measure'
								g_pconductor->m_TransitionOptions.dwFlags &= ~TRANS_END_OF_SEGMENT;
								g_pconductor->m_TransitionOptions.dwBoundaryFlags = DMUS_COMPOSEF_MEASURE;
							}
							pIDirectMusicObject->Release();
						}
						pSegment->Release();
					}
					pSegState->Release();
				}
			}
		}

		// Ensure the transport correctly tracks/doesn't track the cursor
		pITransportActive->TrackCursor( g_pconductor->m_pOptionsToolbarHandler ? g_pconductor->m_pOptionsToolbarHandler->m_fCursorEnabled : TRUE );

		// Try to transition to the active transport
		HRESULT hr;
		hr = pITransportActive->Transition();
		if( hr == E_NOTIMPL )
		{
			// Reset the transition options
			g_pconductor->m_TransitionOptions.dwFlags = dwOrigFlags;
			g_pconductor->m_TransitionOptions.dwBoundaryFlags = dwOrigBoundaryFlags ;

			// Since anything may have happened during the above call to Transition()
			// (even it is supposedly not implemented) reset pITransportActive and
			// pITransportPlaying
			if ( IsValid( g_pconductor->m_rpPlaying ) )
			{
				g_pconductor->m_rpPlaying->GetTransport( &pITransportPlaying );
			}
			else
			{
				pITransportPlaying = NULL;
			}
			if ( IsValid( g_pconductor->m_rpActive ) )
			{
				// Transition from what is currently playing to the active transport
				g_pconductor->m_rpActive->GetTransport( &pITransportActive );

				ASSERT( pITransportActive );

				if ( pITransportPlaying )
				{
					if (FAILED(pITransportPlaying->Stop( TRUE )))
					{
						ASSERT(FALSE);
						// If Stop() failed, update the toolbar state and return.
						UpdatePlayingFromEngine();
						// If the playing transport isn't using the engine, it should update
						// its buttons itself
						m_fInTransition = FALSE;
						SetStateAuto();
						return FALSE;
					}
					if ( g_pconductor->IsPlayingUsingEngine() )
					{
						// Wait until the engine actually stops
						short n = 0;
						while( n++ < 20 )
						{
							if( !g_pconductor->IsEnginePlaying() )
							{
								g_pconductor->m_rpPlaying = NULL;
								break;
							}
							Sleep( 100 );
						}

						TRACE("OnTransitionClicked Timed out while stopping transport\n");
					}
					else
					{
						// Not using the engine, clear the playing index
						g_pconductor->m_rpPlaying = NULL;
					}
				}

				// no longer necessarily playing from start
				m_fPlayFromStart = FALSE;
				// update the toolbar state 
				SetStateAuto();

				if (FAILED(pITransportActive->Play( TRUE )))
				{
					// Update the active flags, if they're using the engine
					UpdateActiveFromEngine();
					// update the toolbar state and return
					m_fInTransition = FALSE;
					SetStateAuto();
					return FALSE;
				}

				//EnableTimer(TRUE);

				// Assume that it really started..
				// Set the playing index
				g_pconductor->m_rpPlaying = g_pconductor->m_rpActive;
				if ( g_pconductor->IsActiveUsingEngine() )
				{
					short n = 0;
					while( n++ < 20 )
					{
						if( g_pconductor->IsEnginePlaying() )
						{
							// Update the playing and active buttons.  This one call does both
							// because m_rpPlaying == m_rpActive
							UpdateActiveFromEngine();
							// Update the buttons on the toolbar
							m_fInTransition = FALSE;
							SetStateAuto();
							return TRUE;
						}
						Sleep( 100 );
					}

					TRACE("OnTransitionClicked Timed out while starting transport\n");

					g_pconductor->m_rpPlaying = NULL;
					// Update the active buttons, if it's using the engine
					UpdateActiveFromEngine();
					// Update the buttons on the toolbar
					m_fInTransition = FALSE;
					SetStateAuto();
					return FALSE;
				}
				SetStateAuto();
			}
		}
		else if( SUCCEEDED( hr ) )
		{
			// Transition succeeded
			// Reset the transition options
			g_pconductor->m_TransitionOptions.dwFlags = dwOrigFlags;
			g_pconductor->m_TransitionOptions.dwBoundaryFlags = dwOrigBoundaryFlags ;

			g_pconductor->m_rpPlaying = g_pconductor->m_rpActive;
			SetStateAuto();
		}
		else
		{
			// Transition failed, but didn't return E_NOTIMPL

			// Leave the buttons in their current state.
			//TRACE("OnTransitionClicked exit - transition failed\n");
			return FALSE;
		}
	}
	m_fInTransition = FALSE;
	return TRUE;
}

LRESULT CToolbarHandler::OnRecordClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ITransportRegEntry *pDisplayedRegEntry = g_pconductor->GetDisplayedTransport();

	if ( !IsValid( pDisplayedRegEntry ) )
	{
		return TRUE;
	}

	IDMUSProdTransport*  pITransport = NULL;
	pDisplayedRegEntry->GetTransport( &pITransport );
	if( !pITransport )
	{
		return FALSE;
	}
	DWORD dwFlags;
	pDisplayedRegEntry->GetFlags( &dwFlags );

	if( !(dwFlags & B_REC_ENABLED) )
	{
		return FALSE;
	}

	if( (dwFlags & B_REC_CHECKED) == 0 )
	{
		if( SUCCEEDED( pITransport->Record( TRUE ) ) )
		{
			dwFlags |= B_REC_CHECKED;
			pDisplayedRegEntry->SetFlags( dwFlags );
			SetStateAuto();
		}
	}
	else
	{
		if( SUCCEEDED( pITransport->Record( FALSE ) ) )
		{
			dwFlags &= ~B_REC_CHECKED;
			pDisplayedRegEntry->SetFlags( dwFlags );
			SetStateAuto();
		}
	}

	return TRUE;
}

LRESULT CToolbarHandler::OnSelchangeComboTransport( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if ( m_comboActive.GetCurSel() != CB_ERR )
	{
		g_pconductor->m_rpActive = static_cast<ITransportRegEntry *>(m_comboActive.GetItemDataPtr( m_comboActive.GetCurSel() ));
		SetStateAuto();
	}
	return TRUE;
}

void CToolbarHandler::SetStateAuto( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Verify our window handle is still valid
	if( !::IsWindow( m_hWndToolbar ) )
	{
		return;
	}

	// Get the index of the currently displayed transport
	ITransportRegEntry *pDisplayedRegEntry = g_pconductor->GetDisplayedTransport();

	// Make sure the index is within the size of the registry
	if ( !IsValid( pDisplayedRegEntry ) )
	{
		SetState( 0 );
		return;
	}

	// Get the flags to display from the displayed transport
	DWORD dwFlags;
	pDisplayedRegEntry->GetFlags( &dwFlags );

	// If the displayed transport uses the engine, update its flags from the engine's state
	if (!(dwFlags & B_NOT_USING_ENGINE))
	{
		SetStateFromEngine(&dwFlags);
	}

	if (pDisplayedRegEntry != g_pconductor->m_rpActive)
	{
		// If we didn't get the flags from the active transport, get
		// the transition button state from the active transport flags.
		dwFlags &= ~(B_TRANS_ENABLED | B_TRANS_CHECKED);
		if( IsValid( g_pconductor->m_rpActive ) )
		{
			// If there is a valid active transport, get the transition flags from it.
			DWORD dwTmpFlags;
			g_pconductor->m_rpActive->GetFlags( &dwTmpFlags );
			
			// If the active transport uses the engine, update its flags from the engine's state
			if( !(dwTmpFlags & B_NOT_USING_ENGINE) )
			{
				SetStateFromEngine(&dwTmpFlags);
			}

			// Finally, set the transition flags from the active transport
			dwFlags |= dwTmpFlags & (B_TRANS_ENABLED | B_TRANS_CHECKED);
		}
	}

	// Set the button states to what the flags describe.
	SetState( dwFlags );

	// Make sure the index is within the size of the registry
	if ( !IsValid( pDisplayedRegEntry ) )
	{
		SetState( 0 );

		// Disable the tempo edit box
		if( ::IsWindow( m_editTempo.GetSafeHwnd() ) )
		{
			m_editTempo.EnableWindow(FALSE);
			m_spinTempo.EnableWindow(FALSE);
		}
		return;
	}

	BOOL fTempoUpdated = FALSE;
	IDMUSProdTransport* pITransport;
	pDisplayedRegEntry->GetTransport( &pITransport );
	if (pITransport)
	{
		IDMUSProdConductorTempo* pIConductorTempo;
		if( SUCCEEDED( pITransport->QueryInterface(IID_IDMUSProdConductorTempo, (void **)&pIConductorTempo) ) )
		{
			// We've found an IConductorTempo interface - the transport probably supports the tempo controls
			ASSERT( pIConductorTempo );

			// Ask the transport what it wants the tempo modifier to display
			/*
			double dModifier;
			if ( ::IsWindow( m_buttonRatio.GetSafeHwnd() ) &&
				 SUCCEEDED( pIConductorTempo->GetTempoModifier( &dModifier )))
			{
				// Limit the ratio to 0.25 - 2.0
				if ( dModifier < DMUS_MASTERTEMPO_MIN )
				{
					dModifier = DMUS_MASTERTEMPO_MIN;
				}
				else if ( dModifier > DMUS_MASTERTEMPO_MAX )
				{
					dModifier = DMUS_MASTERTEMPO_MAX;
				}

				// Update the button, if anything has changed.
				if( g_pconductor->m_nRatio != int (dModifier * 100.0) )
				{
					g_pconductor->m_nRatio = int (dModifier * 100.0);
					UpdateButtonRatio();
				}
			}
			*/

			// Ask the transport what it wants the tempo to display
			double dTempo;
			if ( ::IsWindow( m_editTempo.GetSafeHwnd() ) )
			{
				HRESULT hr = pIConductorTempo->GetTempo( &dTempo );
				// Update the edit box, if anything has changed.
				if( SUCCEEDED(hr) && (g_pconductor->m_dblTempo != dTempo) )
				{
					g_pconductor->m_dblTempo = dTempo;
					m_spinTempo.SetPos( int(dTempo) );
					if (m_editTempo.GetSafeHwnd())
					{
						CString str;
						str.Format("%.2f",dTempo);
						m_editTempo.SetWindowText(str);
					}
				}

				if( FAILED(hr) )
				{
					// Clear the control, since the transport doesn't provide a tempo
					m_editTempo.SetWindowText(NULL);
					g_pconductor->m_dblTempo = 0.0;
				}

				if( hr == S_OK )
				{
					// Enable the control, since the transport supports it
					m_editTempo.EnableWindow(TRUE);
					m_spinTempo.EnableWindow(TRUE);
				}
				else
				{
					// Disable the control, since the transport doesn't support changing tempos
					m_editTempo.EnableWindow(FALSE);
					m_spinTempo.EnableWindow(FALSE);
				}
			}
			pIConductorTempo->Release();

			// Note that we've updated the tempo control
			fTempoUpdated = TRUE;
		}
	}

	if( !fTempoUpdated )
	{
		// Disable the tempo edit box
		if( ::IsWindow( m_editTempo.GetSafeHwnd() ) )
		{
			m_editTempo.EnableWindow(FALSE);
			m_spinTempo.EnableWindow(FALSE);
		}
	}
}

void CToolbarHandler::UpdateActiveFromEngine( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Make sure m_rpActive is valid
	if( IsValid( g_pconductor->m_rpActive ) )
	{
		// Get the flags for the active transport
		DWORD dwFlags;
		g_pconductor->m_rpActive->GetFlags( &dwFlags );

		// If the active transport uses the engine, update its flags from the engine's state
		if (!(dwFlags & B_NOT_USING_ENGINE))
		{
			SetStateFromEngine(&dwFlags);
			g_pconductor->m_rpActive->SetFlags( dwFlags );
		}
	}
}

void CToolbarHandler::UpdatePlayingFromEngine( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Make sure m_rpActive is valid
	if( IsValid( g_pconductor->m_rpPlaying ) )
	{
		// Get the flags for the playing transport
		DWORD dwFlags;
		g_pconductor->m_rpPlaying->GetFlags( &dwFlags );

		// If the playing transport uses the engine, update its flags from the engine's state
		if (!(dwFlags & B_NOT_USING_ENGINE))
		{
			SetStateFromEngine(&dwFlags);
			g_pconductor->m_rpPlaying->SetFlags( dwFlags );
		}
	}
}

LRESULT CToolbarHandler::OnRelTempoClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	ITransportRegEntry *pDisplayedRegEntry = g_pconductor->GetDisplayedTransport();

	if ( !IsValid( pDisplayedRegEntry ) )
	{
		return TRUE;
	}

	IDMUSProdTransport* pITransport;
	pDisplayedRegEntry->GetTransport( &pITransport );

	if (!pITransport)
	{
		return TRUE;
	}

	IDMUSProdConductorTempo* pIConductorTempo = NULL;
	pITransport->QueryInterface(IID_IDMUSProdConductorTempo, (void **)&pIConductorTempo);
	*/

	BOOL fDone = FALSE;
	if (m_buttonRatio.GetCheck() & 1)
	{
		// Checked
		/*
		if ( pIConductorTempo && SUCCEEDED(pIConductorTempo->TempoModified(TRUE)) )
		{
			fDone = TRUE;
		}
		*/
		if ( !fDone )
		{
			if ( g_pconductor->m_pDMPerformance )
			{
				float fModifier;
				fModifier = float(g_pconductor->m_nRatio) / 100.0f;
				g_pconductor->m_pDMPerformance->SetGlobalParam( GUID_PerfMasterTempo, &fModifier, sizeof(float) );
			}
		}
	}
	else
	{
		// Unchecked
		/*
		if ( pIConductorTempo && SUCCEEDED(pIConductorTempo->TempoModified(FALSE)) )
		{
			fDone = TRUE;
		}
		*/
		if ( !fDone )
		{
			if ( g_pconductor->m_pDMPerformance )
			{
				float fModifier;
				fModifier = 1.0;
				g_pconductor->m_pDMPerformance->SetGlobalParam( GUID_PerfMasterTempo, &fModifier, sizeof(float) );
			}
		}
	}
	/*
	if ( pIConductorTempo )
	{
		pIConductorTempo->Release();
	}
	*/

	// Save the state in the registry
	SetNewRegDWORD( _T("TempoRatioEnabled"), m_buttonRatio.GetCheck() & 1, TRUE );

	return TRUE;
}

void CToolbarHandler::UpdateButtonRatio( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString str;
	if (g_pconductor)
	{
		str.Format( "x%3d%%", g_pconductor->m_nRatio );
		m_buttonRatio.SetWindowText(str);

		// Update the associated transport
		BOOL fDone = FALSE;

		/*
		ITransportRegEntry *pDisplayedRegEntry = g_pconductor->GetDisplayedTransport();
		if ( IsValid( pDisplayedRegEntry ) )
		{
			IDMUSProdTransport* pITransport;
			pDisplayedRegEntry->GetTransport( &pITransport );

			if (pITransport)
			{
				IDMUSProdConductorTempo* pIConductorTempo;
				if( SUCCEEDED( pITransport->QueryInterface(IID_IDMUSProdConductorTempo, (void **)&pIConductorTempo) ) )
				{
					ASSERT( pIConductorTempo );

					if( SUCCEEDED( pIConductorTempo->SetTempoModifier( double(g_pconductor->m_nRatio) / 100.0) ) )
					{
						fDone = TRUE;
					}
					pIConductorTempo->Release();
				}
			}
		}
		*/

		// If not set abive, and the ratio button is checked, update GUID_PerfMasterTempo
		if ( (m_buttonRatio.GetState() & 1) && !fDone )
		{
			if ( g_pconductor->m_pDMPerformance )
			{
				float fModifier;
				fModifier = float(g_pconductor->m_nRatio) / 100.0f;
				g_pconductor->m_pDMPerformance->SetGlobalParam( GUID_PerfMasterTempo, &fModifier, sizeof(float) );
			}
		}

	}
}

LRESULT CToolbarHandler::OnKillFocusTempo( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (g_pconductor && (m_editTempo.GetSafeHwnd() != NULL))
	{
		// Update the associated transport
		ITransportRegEntry *pDisplayedRegEntry = g_pconductor->GetDisplayedTransport();

		if ( !IsValid( pDisplayedRegEntry ) )
		{
			return TRUE;
		}

		IDMUSProdTransport* pITransport;
		pDisplayedRegEntry->GetTransport( &pITransport );

		if (!pITransport)
		{
			return TRUE;
		}

		IDMUSProdConductorTempo* pIConductorTempo;
		if( FAILED( pITransport->QueryInterface(IID_IDMUSProdConductorTempo, (void **)&pIConductorTempo) ) )
		{
			return TRUE;
		}

		ASSERT( pIConductorTempo );

		CString strNewTempo;
		m_editTempo.GetWindowText( strNewTempo );
		strNewTempo.TrimRight();
		strNewTempo.TrimLeft();

		if( strNewTempo.IsEmpty() )
		{
			m_spinTempo.SetPos( int(g_pconductor->m_dblTempo) );
			if( floor(g_pconductor->m_dblTempo) != g_pconductor->m_dblTempo )
			{
				strNewTempo.Format("%.2f",g_pconductor->m_dblTempo);
				m_editTempo.SetWindowText( strNewTempo );
			}
		}
		else
		{
			double dblTempo;
			dblTempo = _tcstod(strNewTempo, NULL);
			if( dblTempo > DMUS_TEMPO_MAX )
			{
				dblTempo = DMUS_TEMPO_MAX;
				m_spinTempo.SetPos( int(dblTempo) );
			}
			else if( dblTempo < DMUS_TEMPO_MIN )
			{
				dblTempo = DMUS_TEMPO_MIN;
				m_spinTempo.SetPos( int(dblTempo) );
			}
			if (dblTempo != g_pconductor->m_dblTempo )
			{
				pIConductorTempo->SetTempo( dblTempo );
				g_pconductor->m_dblTempo = dblTempo;
				if( floor(dblTempo) != dblTempo )
				{
					m_spinTempo.SetPos( int(dblTempo) );
					strNewTempo.Format("%.2f",dblTempo);
					m_editTempo.SetWindowText( strNewTempo );
				}
			}
		}
		pIConductorTempo->Release();
	}
	return TRUE;
}

LRESULT CToolbarHandler::OnDeltaPosTempo( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (g_pconductor && (m_spinTempo.GetSafeHwnd() != NULL))
	{
		// Update the associated transport
		ITransportRegEntry *pDisplayedRegEntry = g_pconductor->GetDisplayedTransport();

		if ( !IsValid( pDisplayedRegEntry ) )
		{
			return TRUE;
		}

		IDMUSProdTransport* pITransport;
		pDisplayedRegEntry->GetTransport( &pITransport );

		if (!pITransport)
		{
			return TRUE;
		}

		IDMUSProdConductorTempo* pIConductorTempo;
		if( FAILED( pITransport->QueryInterface(IID_IDMUSProdConductorTempo, (void **)&pIConductorTempo) ) )
		{
			return TRUE;
		}

		ASSERT( pIConductorTempo );

		NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

		CString strNewTempo;
		m_editTempo.GetWindowText( strNewTempo );
		strNewTempo.TrimRight();
		strNewTempo.TrimLeft();

		double dblTempo;
		dblTempo = _tcstod(strNewTempo, NULL);

		int nNewValue = int(floor(dblTempo)) + pNMUpDown->iDelta;
		if( nNewValue < DMUS_TEMPO_MIN )
		{
			nNewValue = DMUS_TEMPO_MIN;
		}
		else if( nNewValue > DMUS_TEMPO_MAX )
		{
			nNewValue = DMUS_TEMPO_MAX;
		}

		if( nNewValue != pNMUpDown->iPos )
		{
			m_spinTempo.SetPos( nNewValue );
		}
		if( nNewValue != g_pconductor->m_dblTempo )
		{
			g_pconductor->m_dblTempo = nNewValue;

			// Update the display
			CString str;
			str.Format("%.2f",g_pconductor->m_dblTempo);
			m_editTempo.SetWindowText(str);

			pIConductorTempo->SetTempo( nNewValue );
		}
		pIConductorTempo->Release();
	}
	return TRUE;
}

LRESULT CToolbarHandler::OnRewPlayClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	m_fInOnBarButtonClicked = TRUE;
	return OnPlayClicked( wNotifyCode, wID, hWndCtl, bHandled);
}

LRESULT CToolbarHandler::OnStopImmediateClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	m_fInOnBarButtonClicked = TRUE;
	return OnStopClicked( wNotifyCode, wID, hWndCtl, bHandled);
}

LRESULT CToolbarHandler::OnSetStateAuto( WORD /*wCode*/, WORD /*wLoWord*/, HWND /*hWnd*/, BOOL& /*bHandled*/ )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_fDontUpdateRewPlay = TRUE;
	SetStateAuto();
	m_fDontUpdateRewPlay = FALSE;
	return TRUE;
}

LRESULT CToolbarHandler::OnMusicStopped( WORD /*wCode*/, WORD /*wLoWord*/, HWND /*hWnd*/, BOOL& /*bHandled*/ )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( IsValid( g_pconductor->m_rpPlaying ) )
	{
		IDMUSProdTransport*  pITransport;
		g_pconductor->m_rpPlaying->GetTransport( &pITransport );
		if (pITransport)
		{
			// Always tell the transport we released the record button
			pITransport->Record( FALSE );
		}

		// Pop up the Record button if it is pressed
		DWORD dwFlags;
		g_pconductor->m_rpPlaying->GetFlags( &dwFlags );
		if( (dwFlags & B_REC_CHECKED) != 0 )
		{
			dwFlags &= ~B_REC_CHECKED;
			g_pconductor->m_rpPlaying->SetFlags( dwFlags );
			::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, ID_TRANSP_RECORD, MAKELONG(FALSE, 0) );
		}
	}

	g_pconductor->m_rpPlaying = NULL;
	SetStateAuto();
	return TRUE;
}

LRESULT CToolbarHandler::OnPressPlayButton( WORD /*wCode*/, WORD /*wLoWord*/, HWND /*hWnd*/, BOOL& /*bHandled*/ )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SetBtnState( ID_TRANSP_PLAY, TBSTATE_ENABLED | TBSTATE_CHECKED );
	return TRUE;
}

LRESULT CToolbarHandler::OnPressStopButton( WORD /*wCode*/, WORD /*wLoWord*/, HWND /*hWnd*/, BOOL& /*bHandled*/ )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SetBtnState( ID_TRANSP_STOP, TBSTATE_ENABLED | TBSTATE_CHECKED );
	return TRUE;
}

CWndClassInfo& CToolbarHandler::GetWndClassInfo()
{
	static CWndClassInfo wc =
	{
		{ sizeof(WNDCLASSEX), CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, StartWindowProc,
		  0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, NULL, 0 },
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
	};
	return wc;
}


LRESULT CToolbarHandler::OnRightClick(WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled)
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	//TRACE("%x %x %x %x\n",wNotifyCode, pNMHDR->hwndFrom,pNMHDR->idFrom,pNMHDR->code);

	// Get the cursor position (To put the menu there)
	POINT ptScreen, ptClient;
	BOOL  bResult;
	bResult = ::GetCursorPos( &ptScreen );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	ptClient = ptScreen;
	bResult = ::ScreenToClient( pNMHDR->hwndFrom, &ptClient );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	if( ::IsWindow( m_hWndToolbar ) )
	{
		CRect rect;
		// Transition is 6th item.
		::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 6, (LPARAM) &rect );

		if( rect.PtInRect( ptClient ) )
		{
			DlgTransition dlg;
			if( IDOK == dlg.DoModal() )
			{
				g_pconductor->m_TransitionOptions.dwBoundaryFlags = dlg.m_TransitionOptions.dwBoundaryFlags;
				g_pconductor->m_TransitionOptions.wPatternType = dlg.m_TransitionOptions.wPatternType;
				g_pconductor->m_TransitionOptions.dwFlags = dlg.m_TransitionOptions.dwFlags;
				g_pconductor->m_TransitionOptions.pDMUSProdNodeSegmentTransition = dlg.m_TransitionOptions.pDMUSProdNodeSegmentTransition;

				SetNewRegDWORD( _T("TransitionBoundary"), g_pconductor->m_TransitionOptions.dwBoundaryFlags, TRUE );
				SetNewRegDWORD( _T("TransitionPattern"), g_pconductor->m_TransitionOptions.wPatternType, TRUE );
				SetNewRegDWORD( _T("TransitionFlags"), g_pconductor->m_TransitionOptions.dwFlags, TRUE );
				// TODO: Save transition segment?
			}
		}
		else
		{
			// Relative tempo is handled by CRatioButton
		}
	}

	return TRUE;
}


IMPLEMENT_DYNCREATE( CMyEdit, CEdit )

CMyEdit::CMyEdit() : CEdit()
{
}

LRESULT CMyEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		switch( wParam )
		{
		case 8:  // Backspace
		case '.':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 71: // Home
		case 75: // Left
		case 77: // Right
		case 79: // End
		case 82: // Ins
		case 83: // Del
			break;
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}

void CToolbarHandler::PlayCountInSegment( IDMUSProdTransport* pITransport )
{
	ASSERT( pITransport );
	if( !pITransport )
	{
		return;
	}

	if( m_pCountInSegmentState )
	{
		m_pCountInSegmentState->Release();
		m_pCountInSegmentState = NULL;
	}

	if( !g_pconductor->m_fMetronomeEnabled || !g_pconductor->m_pOptionsToolbarHandler )
	{
		return;
	}

	if( g_pconductor->m_pOptionsToolbarHandler->m_lCountInBars <= 0 )
	{
		return;
	}

	if( g_pconductor->m_pOptionsToolbarHandler->m_fCountOnlyOnRecord )
	{
		// This must be called just after m_rpPlaying was updated
		ASSERT( g_pconductor->m_rpPlaying == g_pconductor->m_rpActive );
		ASSERT( IsValid( g_pconductor->m_rpPlaying ) );
		if( !IsValid( g_pconductor->m_rpPlaying ) )
		{
			return;
		}

		// Check if the Record button is pressed
		DWORD dwFlags;
		g_pconductor->m_rpPlaying->GetFlags( &dwFlags );
		if( (dwFlags & B_REC_CHECKED) == 0 )
		{
			// It's not pressed - exit
			return;
		}
	}		

	IDMUSProdNode *pTransportNode = NULL;
	if( SUCCEEDED( pITransport->QueryInterface( IID_IDMUSProdNode, (void**)&pTransportNode ) ) )
	{
		// mtTime == 0 -> Get TimeSig/Tempo from from Start
		// mtTime != 0 -> Get TimeSig/Tempo from cursor
		DMUS_TIMESIGNATURE TimeSig;
		TimeSig.mtTime = m_fPlayFromStart ? 0 : 1;
		DMUS_TEMPO_PARAM Tempo;
		Tempo.mtTime = m_fPlayFromStart ? 0 : 1;
		if( SUCCEEDED( pTransportNode->GetObject( GUID_TimeSignature, GUID_TimeSignature, (void**)&TimeSig ) ) )
		{
			bool fGotTempo = false;
			if( SUCCEEDED( pTransportNode->GetObject( GUID_TempoParam, GUID_TempoParam, (void**)&Tempo ) ) )
			{
				fGotTempo = true;
			}
			// If not playing from start, get a 'fudge' factor to make the beat remain constant
			MUSIC_TIME mtOffset = 0;
			if( !m_fPlayFromStart )
			{
				pTransportNode->GetObject( GUID_ConductorCountInBeatOffset, GUID_ConductorCountInBeatOffset, (void**)&mtOffset );
			}

			IDirectMusicSegment *pSegment = NULL;
			if( SUCCEEDED( ::CoCreateInstance( CLSID_DirectMusicSegment, NULL, CLSCTX_INPROC, 
								 			   IID_IDirectMusicSegment, (void**)&pSegment ) ) )
			{
				IDirectMusicTrack *pTimeSigTrack = NULL;
				if( SUCCEEDED(  ::CoCreateInstance( CLSID_DirectMusicTimeSigTrack, NULL, CLSCTX_INPROC, 
								 					IID_IDirectMusicTrack, (void**)&pTimeSigTrack ) ) )
				{
					IDirectMusicTrack *pTempoTrack = NULL;
					if( !fGotTempo
					||	SUCCEEDED(  ::CoCreateInstance( CLSID_DirectMusicTempoTrack, NULL, CLSCTX_INPROC, 
								 						IID_IDirectMusicTrack, (void**)&pTempoTrack ) ) )
					{
						// Set the times of the Tempo and TimeSig events to 0
						TimeSig.mtTime = 0;
						Tempo.mtTime = 0;

						//TRACE("TimeSig: %d/%d\n", TimeSig.bBeatsPerMeasure, TimeSig.bBeat );
						//TRACE("Tempo: %lf\n", Tempo.dblTempo );

						// Insert the TimeSig event
						// This is unsupported in DX 6.1 and DX 7.
						// pTimeSigTrack->SetParam( GUID_TimeSignature, 0, &TimeSig );
						{
							IPersistStream *pIPersistStream;
							if( SUCCEEDED( pTimeSigTrack->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
							{
								IStream *pIStream;
								if( SUCCEEDED( ::CreateStreamOnHGlobal( NULL, TRUE, &pIStream ) ) )
								{
									// Write the FOURCC id
									FOURCC ckid = DMUS_FOURCC_TIMESIGNATURE_TRACK; // chunk ID to write
									pIStream->Write( &ckid, sizeof(FOURCC), NULL );

									// Write out the size of the chunk
									DWORD dwSize = sizeof( DMUS_IO_TIMESIGNATURE_ITEM ) + sizeof(DWORD);
									pIStream->Write( &dwSize, sizeof(DWORD), NULL );

									// Write out the size of the TimeSig item
									dwSize -= 4;
									pIStream->Write( &dwSize, sizeof(DWORD), NULL );

									// Write out the TimeSig item
									DMUS_IO_TIMESIGNATURE_ITEM oTimeSig;
									ZeroMemory( &oTimeSig, sizeof( DMUS_IO_TIMESIGNATURE_ITEM ) );
									oTimeSig.lTime = 0;
									oTimeSig.bBeatsPerMeasure = TimeSig.bBeatsPerMeasure;
									oTimeSig.bBeat = TimeSig.bBeat;
									oTimeSig.wGridsPerBeat = TimeSig.wGridsPerBeat;
									pIStream->Write( &oTimeSig, sizeof(DMUS_IO_TIMESIGNATURE_ITEM), NULL );

									// Seek back to the start
									LARGE_INTEGER li;
									li.HighPart = 0;
									li.LowPart = 0;
									pIStream->Seek( li, SEEK_SET, NULL );

									// Load in the TimeSig stream
									pIPersistStream->Load( pIStream );

									pIStream->Release();
								}
								pIPersistStream->Release();
							}
						}

						// Inset the TimeSig track
						pSegment->InsertTrack( pTimeSigTrack, 0xFFFFFFFF );

						// If necessary, insert the Tempo event and track
						if( pTempoTrack )
						{
							pTempoTrack->SetParam( GUID_TempoParam, 0, &Tempo );
							pSegment->InsertTrack( pTempoTrack, 0xFFFFFFFF );
						}

						// Set the length
						pSegment->SetLength( mtOffset + ((DMUS_PPQ * 4 / TimeSig.bBeat) * TimeSig.bBeatsPerMeasure * g_pconductor->m_pOptionsToolbarHandler->m_lCountInBars) );

						// Play the segment
						g_pconductor->m_pDMPerformance->PlaySegment( pSegment, 0, 0, &m_pCountInSegmentState );

						if( pTempoTrack )
						{
							pTempoTrack->Release();
						}
					}
					pTimeSigTrack->Release();
				}
				pSegment->Release();
			}
		}
		pTransportNode->Release();
	}
}

IMPLEMENT_DYNCREATE( CRatioButton, CButton )

CRatioButton::CRatioButton() : CButton()
{
}

LRESULT CRatioButton::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	switch( message )
	{
	case WM_RBUTTONUP:
		{
			DlgAltTempo dlg;
			if( IDOK == dlg.DoModal() )
			{
				g_pconductor->m_nRatio = dlg.m_nRatio;
				g_pconductor->m_pToolbarHandler->UpdateButtonRatio();

				SetNewRegDWORD( _T("TempoRatio"), g_pconductor->m_nRatio, TRUE );
			}
			break;
		}
	}
	return CButton::WindowProc( message, wParam, lParam );
}

void QueueSegmentState( IDirectMusicPerformance *pPerformance, MUSIC_TIME mtNow )
{
	// Validate parameter
	if( pPerformance )
	{
		IDirectMusicSegment *pSegment;
		if( SUCCEEDED( ::CoCreateInstance( CLSID_DirectMusicSegment, NULL, CLSCTX_INPROC, 
										   IID_IDirectMusicSegment, (void**)&pSegment ) ) )
		{
			pSegment->SetLength( 5 );
			int nCount = 20;
			while( (nCount > 0) && (pPerformance->PlaySegment( pSegment, 0, mtNow, NULL ) == DMUS_E_TIME_PAST) )
			{
				nCount--;
				mtNow += DMUS_PPQ / 4;
			}
			ASSERT( nCount > 0 );
			pSegment->Release();
		}
	}
}
/*
void DeQueueSegmentState( IDirectMusicPerformance *pPerformance, IDirectMusicSegmentState *pSegState, DWORD dwStopFlags )
{
	// Validate parameters
	if( pPerformance && pSegState )
	{
		// Get the segment this segment state refers to 
		IDirectMusicSegment *pSegment;
		if( SUCCEEDED( pSegState->GetSegment( &pSegment ) ) )
		{
			// Get the starting time, point, and duration of this segment
			MUSIC_TIME mtStartPoint, mtStartTime, mtDuration;
			VERIFY( SUCCEEDED( pSegState->GetStartPoint( &mtStartPoint ) ) );
			VERIFY( SUCCEEDED( pSegState->GetStartTime( &mtStartTime ) ) );
			VERIFY( SUCCEEDED( pSegment->GetLength( &mtDuration ) ) );

			// Get the number of loops in this segment
			DWORD dwLoops;
			VERIFY( SUCCEEDED( pSegment->GetRepeats( &dwLoops ) ) );

			if( dwLoops )
			{
				MUSIC_TIME dwLoopStart, dwLoopEnd;
				VERIFY( SUCCEEDED( pSegment->GetLoopPoints( &dwLoopStart, &dwLoopEnd ) ) );
				if( mtStartPoint < dwLoopEnd )
				{
					mtStartTime += (dwLoopEnd - dwLoopStart) * dwLoops;
				}
			}
			// Look for a segment state after this one
			IDirectMusicSegmentState *pNewSegState = NULL;
			mtStartPoint = mtStartTime - mtStartPoint + mtDuration;
			for( mtStartTime = mtStartPoint; mtStartTime < mtStartPoint + DMUS_PPQ * 4; mtStartTime += 100 )
			{
				if( SUCCEEDED( pPerformance->GetSegmentState( &pNewSegState, mtStartTime ) ) )
				{
					if( pNewSegState != pSegState )
					{
						break;
					}
					else
					{
						pNewSegState->Release();
						pNewSegState = NULL;
					}
				}
			}

			// Found another segment state, stop it first
			if( pNewSegState )
			{
				DeQueueSegmentState( pPerformance, pNewSegState, dwStopFlags );
				pNewSegState->Release();
			}

			// Stop this segment
			pPerformance->Stop( pSegment, pSegState, 0, dwStopFlags );

			//TRACE("Stoping SegState %x that ends at time %d with duration %d\n", pSegState, mtStartPoint, mtDuration);

			pSegment->Release();
		}
	}
}
*/

void CToolbarHandler::TransitionToNothing( void )
{
	IDirectMusicComposer8 *pIDMComposer;
	if( FAILED( ::CoCreateInstance( CLSID_DirectMusicComposer, NULL, CLSCTX_INPROC, 
					   IID_IDirectMusicComposer8, (void**)&pIDMComposer ) )
	||	!pIDMComposer )
	{
		return;
	}

	// Set the transition pattern (embellishment)
	WORD wCommand = 0;
	if( !(g_pconductor->m_TransitionOptions.dwFlags & TRANS_REGULAR_PATTERN) )
	{
		// if we have an embellishment, set it.
		wCommand = g_pconductor->m_TransitionOptions.wPatternType;
	}

	// Set the boundary flags
	DWORD dwFlags = g_pconductor->m_TransitionOptions.dwBoundaryFlags;

	// Set the end of segment boundary flag
	if( g_pconductor->m_TransitionOptions.dwFlags & TRANS_END_OF_SEGMENT )
	{
		// Can't transition at COMPOSEF_QUEUE, so just use COMPOSEF_SEGMENTEND
		dwFlags |= DMUS_COMPOSEF_SEGMENTEND;
	}

	IDirectMusicSegment *pITransitionSegment = NULL;
	pIDMComposer->AutoTransition(g_pconductor->m_pDMPerformance,
											   NULL,
											   wCommand,
											   dwFlags,
											   NULL,
											   &pITransitionSegment,
											   NULL,
											   NULL);

	if( pITransitionSegment )
	{
		pITransitionSegment->Release();
		pITransitionSegment = NULL;
	}
}

void CToolbarHandler::AddTransport( ITransportRegEntry *pITransportRegEntry )
{
	// Ensure the pointer is valid
	if( pITransportRegEntry == NULL )
	{
		ASSERT(FALSE);
		return;
	}

	// Ensure the transport is valid
	IDMUSProdTransport* pTransport = NULL;
	pITransportRegEntry->GetTransport( &pTransport );
	if( pTransport == NULL )
	{
		ASSERT(FALSE);
		return;
	}

	BSTR  bstrName;
	CString strName;
	// If the transport doens't have a name, use a default name
	if ( SUCCEEDED(	pTransport->GetName( &bstrName ) ) )
	{
		strName = bstrName;
		SysFreeString( bstrName );
	}
	else
	{
		strName.LoadString( IDS_DEFAULT_TRANSPORT_NAME );
	}
	int nIndex = m_comboActive.AddString( strName );
	m_comboActive.SetItemDataPtr( nIndex, pITransportRegEntry );

	if(m_comboActive.GetCount() >= 1)
	{
		m_comboActive.EnableWindow( TRUE );
	}
}

void CToolbarHandler::RemoveTransport( ITransportRegEntry *pITransportRegEntry )
{
	// Ensure the pointer is valid
	if( pITransportRegEntry == NULL )
	{
		ASSERT(FALSE);
		return;
	}

	for( int nIndex = m_comboActive.GetCount() - 1; nIndex >= 0; nIndex-- )
	{
		if( m_comboActive.GetItemDataPtr( nIndex ) == pITransportRegEntry )
		{
			m_comboActive.DeleteString( nIndex );

			if(m_comboActive.GetCount() == 0)
			{
				m_comboActive.EnableWindow( FALSE );
			}
			else
			{
				m_comboActive.SetCurSel( min( m_comboActive.GetCount() - 1, nIndex) );
			}
			return;
		}
	}

	ASSERT(FALSE);
}

void CToolbarHandler::SetActiveTransport( ITransportRegEntry *pITransportRegEntry )
{
	// Ensure the pointer is valid
	if( pITransportRegEntry == NULL )
	{
		ASSERT(FALSE);
		return;
	}

	for( int nIndex = m_comboActive.GetCount() - 1; nIndex >= 0; nIndex-- )
	{
		if( m_comboActive.GetItemDataPtr( nIndex ) == pITransportRegEntry )
		{
			m_comboActive.SetCurSel( nIndex );
			return;
		}
	}

	ASSERT(FALSE);
}

LRESULT CToolbarHandler::OnSetActiveFromPointer( WORD /*wCode*/, WORD /*wLoWord*/, HWND /*hWnd*/, BOOL& /*bHandled*/ )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SetActiveTransport( g_pconductor->m_rpActive );
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\SynthStatusToolbar.cpp ===
// SynthStatusToolbar.cpp : implementation file
//

#include "stdafx.h"
#include "cconduct.h"
#include "SynthStatusToolbar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static CSynthStatusToolbar *g_pSynthStatusToolbar = NULL;

static CString s_strCPUFormat;
static CString s_strVoicesFormat;
static CString s_strMemoryFormat;
static CString s_strLatencyFormat;

static DWORD s_adwLatency[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
static DWORD s_dwLatencyIndex = 0;
static DWORD s_dwLatencyCount = 0;


void RefTimeToString( REFERENCE_TIME rtTime, CString &cstrTime )
{
	bool fNegative = false;
	if( rtTime < 0 )
	{
		fNegative = true;
		rtTime = -rtTime;
	}

	int iMillisecond, iSecond, iMinute, iHour;
	// Convert to milliseconds
	iMillisecond = int(rtTime / 10000);
	iSecond = iMillisecond / 1000;
	iMillisecond %= 1000;
	iMinute = iSecond / 60;
	iSecond %= 60;
	iHour = iMinute / 60;
	iMinute %= 60;

	cstrTime.Format("%02d:%02d:%02d.%03d", iHour, iMinute, iSecond, iMillisecond);

	if( fNegative )
	{
		cstrTime = CString("-") + cstrTime;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CResetButton

CResetButton::CResetButton()
{
}

CResetButton::~CResetButton()
{
}


BEGIN_MESSAGE_MAP(CResetButton, CButton)
	//{{AFX_MSG_MAP(CResetButton)
	ON_WM_ACTIVATE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CResetButton message handlers

void CResetButton::OnLButtonDown(UINT nFlags, CPoint point) 
{
	CButton::OnLButtonDown(nFlags, point);

	UpdateStyle();
}

void CResetButton::OnLButtonUp(UINT nFlags, CPoint point) 
{
	CButton::OnLButtonUp(nFlags, point);

	UpdateStyle();
}

void CResetButton::OnSetFocus(CWnd* pOldWnd) 
{
	CButton::OnSetFocus(pOldWnd);
	
	UpdateStyle();
}

void CResetButton::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) 
{
	CButton::OnActivate(nState, pWndOther, bMinimized);
	
	UpdateStyle();
}

void CResetButton::UpdateStyle( void )
{
	ModifyStyle( BS_DEFPUSHBUTTON, BS_PUSHBUTTON, 0 );
}


/////////////////////////////////////////////////////////////////////////////
// CSynthStatusToolbar

CSynthStatusToolbar::CSynthStatusToolbar()
{
	m_nTimerID = 0;
	m_hWndToolbar = NULL;
	g_pSynthStatusToolbar = this;
	m_dwPeakCPU = 0;
	m_dwPeakVoices = 0;
	m_rtPeakCPU = 0;
	m_rtPeakVoices = 0;
	if( s_strCPUFormat.IsEmpty() )
	{
		if( !s_strCPUFormat.LoadString( IDS_SYNTH_CPU_STATUS ) )
		{
			s_strCPUFormat = _T("CPU %02d.%1.1d%% Peak %02d.%1.1d%% at %s");
		}
	}
	if( s_strVoicesFormat.IsEmpty() )
	{
		if( !s_strVoicesFormat.LoadString( IDS_SYNTH_VOICES_STATUS ) )
		{
			s_strVoicesFormat = _T("Voices %d Peak %d at %s");
		}
	}
	if( s_strMemoryFormat.IsEmpty() )
	{
		if( !s_strMemoryFormat.LoadString( IDS_SYNTH_MEMORY_STATUS ) )
		{
			s_strMemoryFormat = _T("Memory Use %dK");
		}
	}
	if( s_strLatencyFormat.IsEmpty() )
	{
		if( !s_strLatencyFormat.LoadString( IDS_SYNTH_LATENCY_STATUS ) )
		{
			s_strLatencyFormat = _T("Latency %dms");
		}
	}
}

CSynthStatusToolbar::~CSynthStatusToolbar()
{
	g_pSynthStatusToolbar = NULL;
	if( m_nTimerID )
	{
		// No need to kill the timer - it was stopped when the window was destroyed.
	//	KillTimer( m_nTimerID );
		m_nTimerID = 0;
	}
	if( m_font.GetSafeHandle() )
	{
		m_font.DeleteObject();
	}
}

void CSynthStatusToolbar::EnableTimer( BOOL fEnable )
{
	if( fEnable )
	{
		if( m_nTimerID == 0 )
		{
			// Synth stats are only refreshed twice a second - we refresh twice as fast to
			// try and get a more accurate reference to the point in time where the highs occurred.
			m_nTimerID = ::SetTimer( NULL, 0, 500, SynthStatusTimerProc );
		}
	}
	else
	{
		if( m_nTimerID )
		{
			KillTimer( m_nTimerID );
			m_nTimerID = 0;
		}
	}
}


void CALLBACK EXPORT SynthStatusTimerProc(
   HWND hWnd,      // handle of CWnd that called SetTimer
   UINT nMsg,      // WM_TIMER
   UINT nIDEvent,  // timer identification
   DWORD dwTime    // system time
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(hWnd);
	UNREFERENCED_PARAMETER(nMsg);
	UNREFERENCED_PARAMETER(nIDEvent);
	UNREFERENCED_PARAMETER(dwTime);

	// Verify our pointers to the toolbar and conductor
	if( !g_pSynthStatusToolbar || !g_pconductor )
	{
		return;
	}

	// Copy the Conductor's pointer to the audio path
	::EnterCriticalSection( &g_pconductor->m_csAudiopath );
	IDirectMusicAudioPath *pDMAudiopath = g_pconductor->m_pDMAudiopath;
	if( pDMAudiopath )
	{
		pDMAudiopath->AddRef();
	}
	::LeaveCriticalSection( &g_pconductor->m_csAudiopath );

	DWORD dwTotalCPU = 0;
	DWORD dwVoices = 0;
	DWORD dwMemUse = 0;
	DWORD dwLatency = 0;

	// Iterate through the default Audiopath's port
	DMUS_SYNTHSTATS8 synthStats;
	DWORD dwIndex = 0;
	IDirectMusicPort *pDMPort = NULL;
	if( pDMAudiopath )
	{
		while( S_OK == pDMAudiopath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void**)&pDMPort ) )
		{
			// Initialize the DMUS_SYNTHSTATS8 structure
			ZeroMemory( &synthStats, sizeof( DMUS_SYNTHSTATS8 ) );
			synthStats.dwSize = sizeof( DMUS_SYNTHSTATS8 );

			// Try and get the stats for this port
			if( SUCCEEDED( pDMPort->GetRunningStats( (LPDMUS_SYNTHSTATS)&synthStats ) ) )
			{
				// Add this port's stats to the total
				if( synthStats.dwValidStats & DMUS_SYNTHSTATS_TOTAL_CPU )
				{
					dwTotalCPU += synthStats.dwTotalCPU;
				}
				if( synthStats.dwValidStats & DMUS_SYNTHSTATS_VOICES )
				{
					dwVoices += synthStats.dwVoices;
				}
				// BUGBUG: Replace with the real value when it's added to dmusicc.h
				//if( synthStats.dwValidStats & DMUS_SYNTHSTATS_FREE_MEMORY )
				{
					dwMemUse += synthStats.dwSynthMemUse;
				}
			}

			// Release the port
			pDMPort->Release();

			// Go on to the next port in the audio path
			dwIndex++;
		}
		pDMAudiopath->Release();
	}

	if( g_pSynthStatusToolbar->m_dwPeakCPU < dwTotalCPU )
	{
		g_pSynthStatusToolbar->m_dwPeakCPU = dwTotalCPU;

		IDirectMusicSegmentState *pSegState;
		REFERENCE_TIME rtTimeNow;
		MUSIC_TIME mtTimeNow;
		if( g_pconductor->m_pDMPerformance
		&&	SUCCEEDED( g_pconductor->m_pDMPerformance->GetTime( &rtTimeNow, &mtTimeNow ) )
		&&	SUCCEEDED( g_pconductor->m_pDMPerformance->GetSegmentState( &pSegState, mtTimeNow ) ) )
		{
			MUSIC_TIME mtStartTime;
			if( SUCCEEDED( pSegState->GetStartTime( &mtStartTime ) ) )
			{
				REFERENCE_TIME rtSegmentStart;
				VERIFY( SUCCEEDED( g_pconductor->m_pDMPerformance->MusicToReferenceTime( mtStartTime, &rtSegmentStart ) ) );
				g_pSynthStatusToolbar->m_rtPeakCPU = rtTimeNow - rtSegmentStart;
			}
			pSegState->Release();
		}
	}

	if( (dwVoices < 20000) && (g_pSynthStatusToolbar->m_dwPeakVoices < dwVoices) )
	{
		g_pSynthStatusToolbar->m_dwPeakVoices = dwVoices;

		IDirectMusicSegmentState *pSegState;
		REFERENCE_TIME rtTimeNow;
		MUSIC_TIME mtTimeNow;
		if( g_pconductor->m_pDMPerformance
		&&	SUCCEEDED( g_pconductor->m_pDMPerformance->GetTime( &rtTimeNow, &mtTimeNow ) )
		&&	SUCCEEDED( g_pconductor->m_pDMPerformance->GetSegmentState( &pSegState, mtTimeNow ) ) )
		{
			MUSIC_TIME mtStartTime;
			if( SUCCEEDED( pSegState->GetStartTime( &mtStartTime ) ) )
			{
				REFERENCE_TIME rtSegmentStart;
				VERIFY( SUCCEEDED( g_pconductor->m_pDMPerformance->MusicToReferenceTime( mtStartTime, &rtSegmentStart ) ) );
				g_pSynthStatusToolbar->m_rtPeakVoices = rtTimeNow - rtSegmentStart;
			}
			pSegState->Release();
		}
	}

	if( g_pconductor->m_pDMPerformance )
	{
		long lCount = 20;
		REFERENCE_TIME rtNow = 0, rtLatency = 0, rtNowNext = 20000;
		while( (lCount != 0) && (rtNowNext - rtNow > 10000) )
		{
			g_pconductor->m_pDMPerformance->GetTime( &rtNow, NULL );
			g_pconductor->m_pDMPerformance->GetLatencyTime( &rtLatency );
			g_pconductor->m_pDMPerformance->GetTime( &rtNowNext, NULL );
			lCount--;
		}

		if( lCount != 0 )
		{
			dwLatency = DWORD((rtLatency - rtNow + 5000) / 10000);

			if( s_dwLatencyCount < 20 )
			{
				s_adwLatency[s_dwLatencyCount] = dwLatency;
				s_dwLatencyCount++;
			}
			else
			{
				s_dwLatencyIndex++;
				if( s_dwLatencyIndex > 19 )
				{
					s_dwLatencyIndex = 0;
				}
				s_adwLatency[s_dwLatencyIndex] = dwLatency;
			}

			dwLatency = 0;
			for( lCount = s_dwLatencyCount - 1; lCount >= 0; lCount-- )
			{
				dwLatency += s_adwLatency[lCount];
			}
			dwLatency /= s_dwLatencyCount;
		}
	}

	CString strTime;
	RefTimeToString( g_pSynthStatusToolbar->m_rtPeakCPU, strTime );

	TCHAR tcstrText[100];
	_stprintf( tcstrText, s_strCPUFormat,
		dwTotalCPU / 100, (dwTotalCPU % 100) / 10,
		g_pSynthStatusToolbar->m_dwPeakCPU / 100, (g_pSynthStatusToolbar->m_dwPeakCPU % 100) / 10,
		strTime );
	::SendMessage( g_pSynthStatusToolbar->m_staticCPUText.GetSafeHwnd(), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tcstrText );


	RefTimeToString( g_pSynthStatusToolbar->m_rtPeakVoices, strTime );

	_stprintf( tcstrText, s_strVoicesFormat,
		dwVoices, g_pSynthStatusToolbar->m_dwPeakVoices, strTime );
	::SendMessage( g_pSynthStatusToolbar->m_staticVoicesText.GetSafeHwnd(), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tcstrText );

	_stprintf( tcstrText, s_strMemoryFormat, dwMemUse >> 10 ); // Divide by 1024
	::SendMessage( g_pSynthStatusToolbar->m_staticMemoryText.GetSafeHwnd(), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tcstrText );

	_stprintf( tcstrText, s_strLatencyFormat, dwLatency );
	::SendMessage( g_pSynthStatusToolbar->m_staticLatencyText.GetSafeHwnd(), WM_SETTEXT, 0, (LPARAM)(LPCTSTR)tcstrText );
}

/////////////////////////////////////////////////////////////////////////////
// CSynthStatusToolbar IDMUSProdToolBar::GetInfo

HRESULT CSynthStatusToolbar::GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( (phWndOwner == NULL)
	||	(phInstance == NULL)
	||	(pnResourceId == NULL)
	||	(pbstrTitle == NULL) )
	{
		return E_POINTER;
	}

	*phWndOwner = m_hWnd;
	*phInstance = _Module.GetResourceInstance();
	*pnResourceId = (UINT)-1;  // we are going to build the toolbar from scratch

	CComBSTR bstrMenuHelpText;
	if( bstrMenuHelpText.LoadString( IDS_SYNTHSTATUS_TITLE ) )
	{
		*pbstrTitle = bstrMenuHelpText.Detach();
	}
	else
	{
		*pbstrTitle = NULL;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSynthStatusToolbar IDMUSProdToolBar::GetMenuText

HRESULT CSynthStatusToolbar::GetMenuText( BSTR* pbstrText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrText == NULL )
	{
		return E_POINTER;
	}

	CComBSTR bstrMenuHelpText;
	if( bstrMenuHelpText.LoadString( IDS_SYNTHSTATUS_MENUTEXT ) )
	{
		*pbstrText = bstrMenuHelpText.Detach();
		return S_OK;
	}
	else
	{
		*pbstrText = NULL;
		return E_FAIL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSynthStatusToolbar IDMUSProdToolBar::GetMenuHelpText

HRESULT CSynthStatusToolbar::GetMenuHelpText( BSTR* pbstrMenuHelpText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrMenuHelpText == NULL )
	{
		return E_POINTER;
	}

	CComBSTR bstrMenuHelpText;
	if( bstrMenuHelpText.LoadString( IDS_SYNTHSTATUS_HELP ) )
	{
		*pbstrMenuHelpText = bstrMenuHelpText.Detach();
		return S_OK;
	}
	else
	{
		*pbstrMenuHelpText = NULL;
		return E_FAIL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSynthStatusToolbar IDMUSProdToolBar::Initialize

HRESULT CSynthStatusToolbar::Initialize( HWND hWndToolBar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( hWndToolBar == NULL )
	{
		return E_INVALIDARG;
	}
	m_hWndToolbar = hWndToolBar;
 
	// Create font for toolbar text
	CClientDC* pDC = new CClientDC( CWnd::FromHandle( m_hWndToolbar) );

	int nHeight = -( (pDC->GetDeviceCaps(LOGPIXELSY) * 8) / 72 );

	CString strFontName;
	if( strFontName.LoadString( IDS_TOOLBAR_FONT ) == 0)
	{
		strFontName = CString("MS Sans Serif");
	}
	m_font.CreateFont( nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,
		DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
		DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, strFontName );
	
	CFont* pOldFont = pDC->SelectObject( &m_font );
	
	TEXTMETRIC tm;
	pDC->GetTextMetrics( &tm );
	int cxChar =  tm.tmAveCharWidth;
	//int cyChar = tm.tmHeight + tm.tmExternalLeading;
	pDC->SelectObject( pOldFont );
	delete pDC;

	::SendMessage( m_hWndToolbar, TB_SETMAXTEXTROWS, 1, 0 );
	::SendMessage( m_hWndToolbar, TB_SETDRAWTEXTFLAGS, DT_LEFT | DT_SINGLELINE | DT_TOP, DT_LEFT | DT_SINGLELINE | DT_TOP);

	TBBUTTON button;
	button.dwData = 0;
	button.iString = 1;

	// 8 - Wide separator for reset button
	button.iBitmap = cxChar * 8;
	button.idCommand = IDC_SYNTH_RESET;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 7 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 6 - Wide separator for latency
	button.iBitmap = cxChar * 20;
	button.idCommand = IDC_SYNTH_LATENCY;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 5 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 4 - Wide separator for memory use
	button.iBitmap = cxChar * 25;
	button.idCommand = IDC_SYNTH_MEMORY;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 3 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 2 - Wide separator for number of voices
	button.iBitmap = cxChar * 41;
	button.idCommand = IDC_SYNTH_VOICES;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 1 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 0 - Wide separator for CPU usage
	button.iBitmap = cxChar * 42;
	button.idCommand = IDC_SYNTH_CPU;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// Attach the reset button
	RECT rect;
	::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 8, (LPARAM)&rect );
	CString strButtonText;
	strButtonText.LoadString( IDS_SYNTHSTATUS_RESET_BUTTON );
	if( !m_buttonReset.Create(strButtonText, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
		rect, CWnd::FromHandle( m_hWndToolbar), IDC_SYNTH_RESET) )
	{
		return -1;
	}
	m_buttonReset.SetFont( &m_font );
	m_buttonReset.EnableWindow(TRUE);

	// Attach the Latency static text box
	::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 6, (LPARAM)&rect );
	if( !m_staticLatencyText.Create(NULL, WS_CHILD | WS_VISIBLE | SS_SUNKEN | SS_CENTER,
		rect, CWnd::FromHandle( m_hWndToolbar), IDC_SYNTH_LATENCY) )
	{
		return -1;
	}
	m_staticLatencyText.SetFont( &m_font );
	//m_staticLatencyText.EnableWindow(TRUE);

	// Attach the Memory static text box
	::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 4, (LPARAM)&rect );
	if( !m_staticMemoryText.Create(NULL, WS_CHILD | WS_VISIBLE | SS_SUNKEN | SS_CENTER,
		rect, CWnd::FromHandle( m_hWndToolbar), IDC_SYNTH_MEMORY) )
	{
		return -1;
	}
	m_staticMemoryText.SetFont( &m_font );
	//m_staticMemoryText.EnableWindow(TRUE);

	// Attach the Voices static text box
	::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 2, (LPARAM)&rect );
	if( !m_staticVoicesText.Create(NULL, WS_CHILD | WS_VISIBLE | SS_SUNKEN | SS_CENTER,
		rect, CWnd::FromHandle( m_hWndToolbar), IDC_SYNTH_VOICES) )
	{
		return -1;
	}
	m_staticVoicesText.SetFont( &m_font );
	//m_staticVoicesText.EnableWindow(TRUE);

	// Attach the CPU usage static text box
	::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 0, (LPARAM)&rect );
	if( !m_staticCPUText.Create(NULL, WS_CHILD | WS_VISIBLE | SS_SUNKEN | SS_CENTER,
		rect, CWnd::FromHandle( m_hWndToolbar), IDC_SYNTH_CPU) )
	{
		ASSERT(FALSE);
		return -1;
	}
	m_staticCPUText.SetFont( &m_font );
	//m_staticCPUText.EnableWindow(TRUE);

	return S_OK;
}

LRESULT CSynthStatusToolbar::OnResetClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_dwPeakCPU = 0;
	m_dwPeakVoices = 0;
	m_rtPeakCPU = 0;
	m_rtPeakVoices = 0;

	ZeroMemory( s_adwLatency, sizeof(DWORD) * 20 );
	s_dwLatencyIndex = 0;
	s_dwLatencyCount = 0;

	return FALSE; // Don't process further
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\Toolbar.h ===
#if !defined(TOOLBAR_H__36F6DDF43_46CE_11D0_B9DB_00AA00C08146__INCLUDED_)
#define TOOLBAR_H__36F6DDF43_46CE_11D0_B9DB_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "DMUSProd.h"
#include "resource.h"

interface IDMUSProdConductorToolbar : public IDMUSProdToolBar
{
	HWND Create( HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL, DWORD dwStyle = WS_CHILD | WS_VISIBLE, DWORD dwExStyle = 0, UINT nID = 0 );
};

class CMyEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CMyEdit)
public:
	CMyEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

class CRatioButton : public CButton
{
	DECLARE_DYNCREATE(CRatioButton)
public:
	CRatioButton();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
};

/////////////////////////////////////////////////////////////////////////////
// CToolbarHandler definition

class CToolbarHandler :
	public CComObjectRoot,
	public CWindowImpl<CToolbarHandler>,
	public IDMUSProdToolBar
{
friend class CConductor;
friend class CStatusToolbarHandler;
friend UINT AFX_CDECL NotifyThreadProc( LPVOID pParam );

public:
	CToolbarHandler();
	~CToolbarHandler();

protected:
	BOOL SetBtnState( int nID, UINT nState );
	BOOL SetState( DWORD dwFlags );
	void SetStateFromEngine( DWORD *pdwState );
	void PlayCountInSegment( IDMUSProdTransport* pITransport );
	void TransitionToNothing( void );

public:
	void UpdateButtonRatio( void );
	void UpdatePlayingFromEngine( void );
	void UpdateActiveFromEngine( void );
	void SetStateAuto( void );
	inline BOOL IsValid( ITransportRegEntry *pITransportRegEntry )
	{
		return ( pITransportRegEntry != NULL ) ? TRUE : FALSE;
	}
	void AddTransport( ITransportRegEntry *pITransportRegEntry );
	void RemoveTransport( ITransportRegEntry *pITransportRegEntry );
	void SetActiveTransport( ITransportRegEntry *pITransportRegEntry );

public:
	BEGIN_COM_MAP(CToolbarHandler)
		COM_INTERFACE_ENTRY(IDMUSProdToolBar)
	END_COM_MAP()

	// IDMUSProdToolBar functions
	HRESULT STDMETHODCALLTYPE GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle );
	HRESULT STDMETHODCALLTYPE GetMenuText( BSTR* pbstrText );
	HRESULT STDMETHODCALLTYPE GetMenuHelpText( BSTR* pbstrHelpText );
	HRESULT STDMETHODCALLTYPE Initialize( HWND hWndToolBar );

//		TRACE( "Message: %x %x %x\n", uMsg, wParam, lParam );
	// message map
	BEGIN_MSG_MAP(CToolbarHandler)
		COMMAND_HANDLER(ID_TRANSP_PLAY, BN_CLICKED, OnPlayClicked)
		COMMAND_HANDLER(ID_TRANSP_STOP, BN_CLICKED, OnStopClicked)
		COMMAND_HANDLER(ID_TRANSP_TRANSITION, BN_CLICKED, OnTransitionClicked)
		COMMAND_HANDLER(ID_TRANSP_RECORD, BN_CLICKED, OnRecordClicked)
		COMMAND_HANDLER(IDC_TRANSP_COMBO, CBN_SELCHANGE, OnSelchangeComboTransport)
		COMMAND_HANDLER(IDC_RELATIVE_TEMPO, BN_CLICKED, OnRelTempoClicked)
		COMMAND_HANDLER(IDC_TEMPO, EN_KILLFOCUS, OnKillFocusTempo)
		COMMAND_HANDLER(1, 0, OnKillFocusTempo)
		COMMAND_HANDLER(ID_TRANS_REWPLAY, BN_CLICKED, OnRewPlayClicked)
		COMMAND_HANDLER(ID_TRANS_STOPIMMEDIATE, BN_CLICKED, OnStopImmediateClicked)
		COMMAND_CODE_HANDLER(ID_SET_STATE_AUTO, OnSetStateAuto)
		COMMAND_CODE_HANDLER(ID_SET_ACTIVE_FROM_POINTER, OnSetActiveFromPointer)
		COMMAND_CODE_HANDLER(ID_MUSIC_STOPPED, OnMusicStopped)
		COMMAND_CODE_HANDLER(ID_PRESS_PLAY_BUTTON, OnPressPlayButton)
		COMMAND_CODE_HANDLER(ID_PRESS_STOP_BUTTON, OnPressStopButton)
#pragma warning ( push )
#pragma warning ( disable : 4244 )
		NOTIFY_HANDLER(IDC_SPIN_TEMPO, UDN_DELTAPOS, OnDeltaPosTempo)
		NOTIFY_CODE_HANDLER(NM_RCLICK, OnRightClick)
#pragma warning ( pop )
	END_MSG_MAP()

	// message handler methods
	LRESULT OnPlayClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnStopClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnTransitionClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnRecordClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnSelchangeComboTransport( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnRelTempoClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnKillFocusTempo( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnDeltaPosTempo( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled );
	LRESULT OnRewPlayClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnStopImmediateClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnSetStateAuto( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled );
	LRESULT OnSetActiveFromPointer( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled );
	LRESULT OnMusicStopped( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled );
	LRESULT OnPressPlayButton( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled );
	LRESULT OnPressStopButton( WORD wCode, WORD wLoWord, HWND hWnd, BOOL& bHandled );
	LRESULT OnRightClick( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled );
	LRESULT OnParentNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);

	// Base class override methods
static CWndClassInfo& GetWndClassInfo();

	CComboBox		m_comboActive;
	CRatioButton	m_buttonRatio;
	CSpinButtonCtrl m_spinTempo;
	CMyEdit			m_editTempo;
	BOOL			m_fInTransition;
	MUSIC_TIME		m_mtPlayTime;

	IDirectMusicSegmentState *m_pCountInSegmentState;

private:
	CFont			m_font;
	HWND			m_hWndToolbar;
	BOOL			m_fInOnBarButtonClicked;
	BOOL			m_fPlayFromStart;
	BOOL			m_fDontUpdateRewPlay;
	BOOL			m_fDisplayingPlay;
	BOOL			m_fStopImmediate;
};

#endif // !defined(TOOLBAR_H__36F6DDF43_46CE_11D0_B9DB_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\SynthStatusToolbar.h ===
#if !defined(AFX_SYNTHSTATUSTOOLBAR_H__9DA12B12_089B_11D3_A709_00105A26620B__INCLUDED_)
#define AFX_SYNTHSTATUSTOOLBAR_H__9DA12B12_089B_11D3_A709_00105A26620B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SynthStatusToolbar.h : header file
//

class CResetButton :
	public CButton
{
// Construction
public:
	CResetButton();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResetButton)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CResetButton();

	// Generated message map functions
protected:
	//{{AFX_MSG(CResetButton)
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG

	void UpdateStyle( void );

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CSynthStatusToolbar window

class CSynthStatusToolbar :
	public CComObjectRoot,
	public CWindowImpl<COptionsToolbarHandler>,
	public IDMUSProdToolBar
{
friend class CConductor;
friend void CALLBACK EXPORT SynthStatusTimerProc( HWND hWnd, UINT nMsg, UINT nIDEvent, DWORD dwTime );

// Construction
public:
	CSynthStatusToolbar();

// Implementation
public:
	virtual ~CSynthStatusToolbar();

public:
	BEGIN_COM_MAP(CSynthStatusToolbar)
		COM_INTERFACE_ENTRY(IDMUSProdToolBar)
	END_COM_MAP()

	// IDMUSProdToolBar functions
	HRESULT STDMETHODCALLTYPE GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle );
	HRESULT STDMETHODCALLTYPE GetMenuText( BSTR* pbstrText );
	HRESULT STDMETHODCALLTYPE GetMenuHelpText( BSTR* pbstrHelpText );
	HRESULT STDMETHODCALLTYPE Initialize( HWND hWndToolBar );

	// message map
	BEGIN_MSG_MAP(CSynthStatusToolbar)
		COMMAND_HANDLER(IDC_SYNTH_RESET, BN_CLICKED, OnResetClicked)
/*
#pragma warning ( push )
#pragma warning ( disable : 4244 )
		NOTIFY_CODE_HANDLER(NM_RCLICK, OnRightClick)
#pragma warning ( pop )
*/
	END_MSG_MAP()

	// message handler methods
	LRESULT OnResetClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
//	LRESULT OnRightClick( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled );

	// Operations
	void EnableTimer( BOOL fEnable );

	// Base class override methods
//static CWndClassInfo& GetWndClassInfo();

private:
	CFont			m_font;
	HWND			m_hWndToolbar;
	CStatic			m_staticCPUText;
	CStatic			m_staticVoicesText;
	CStatic			m_staticMemoryText;
	CStatic			m_staticLatencyText;
	CResetButton	m_buttonReset;
	int				m_nTimerID;
	DWORD			m_dwPeakCPU;
	DWORD			m_dwPeakVoices;
	REFERENCE_TIME	m_rtPeakCPU;
	REFERENCE_TIME	m_rtPeakVoices;
};

#endif // !defined(AFX_SYNTHSTATUSTOOLBAR_H__9DA12B12_089B_11D3_A709_00105A26620B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\trentry.cpp ===
// CTransportRegEntry implementation

#include "stdafx.h"
#include "CConduct.h"
#include "TREntry.h"

// {439C9E01-CDFA-11d0-8C10-00A0C92E1CAC}
static const GUID IID_ITransportRegEntry = 
{ 0x439c9e01, 0xcdfa, 0x11d0, { 0x8c, 0x10, 0x0, 0xa0, 0xc9, 0x2e, 0x1c, 0xac } };

// IUnknown
HRESULT __stdcall CTransportRegEntry::QueryInterface( const IID &iid, void **ppv )
{
    if( ::IsEqualIID( iid, IID_ITransportRegEntry )  ||
		::IsEqualIID( iid, IID_IUnknown ) )
	{
		*ppv = static_cast<ITransportRegEntry *>(this);
	}
	else  {
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	static_cast<IUnknown *>(*ppv)->AddRef();
	return S_OK;
}

ULONG __stdcall CTransportRegEntry::AddRef()
{
	return InterlockedIncrement( &m_cRef );
}

ULONG __stdcall CTransportRegEntry::Release()
{
	if( InterlockedDecrement( &m_cRef ) == 0 )
	{
		delete this;
		return 0;
	}
	return m_cRef;
}

// ITransportRegEntry
HRESULT __stdcall CTransportRegEntry::GetTransport( IDMUSProdTransport **ppITransport )
{
	ASSERT( ppITransport != NULL);
	if (ppITransport == NULL)
	{
		return E_POINTER;
	}
	*ppITransport = m_pITransport;
	return S_OK;
}

HRESULT __stdcall CTransportRegEntry::GetFlags( DWORD *pdwFlags )
{
	ASSERT( pdwFlags != NULL);
	if (pdwFlags == NULL)
	{
		return E_POINTER;
	}
	*pdwFlags = m_dwFlags;
	return S_OK;
}

HRESULT __stdcall CTransportRegEntry::SetFlags( DWORD dwFlags )
{
	m_dwFlags = dwFlags;
	return S_OK;
}


// {DD630C6C-228C-11d2-88F7-00C04FBF8D15}
static const GUID IID_ISecondaryTransportRegEntry = 
{ 0xdd630c6c, 0x228c, 0x11d2, { 0x88, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8d, 0x15 } };

// IUnknown
HRESULT __stdcall CSecondaryTransportRegEntry::QueryInterface( const IID &iid, void **ppv )
{
    if( ::IsEqualIID( iid, IID_ISecondaryTransportRegEntry )  ||
		::IsEqualIID( iid, IID_IUnknown ) )
	{
		*ppv = static_cast<ISecondaryTransportRegEntry *>(this);
	}
	else  {
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	static_cast<IUnknown *>(*ppv)->AddRef();
	return S_OK;
}

ULONG __stdcall CSecondaryTransportRegEntry::AddRef()
{
	return InterlockedIncrement( &m_cRef );
}

ULONG __stdcall CSecondaryTransportRegEntry::Release()
{
	if( InterlockedDecrement( &m_cRef ) == 0 )
	{
		delete this;
		return 0;
	}
	return m_cRef;
}

// ISecondaryTransportRegEntry
HRESULT __stdcall CSecondaryTransportRegEntry::GetSecondaryTransport( IDMUSProdSecondaryTransport **ppISecondaryTransport )
{
	ASSERT( ppISecondaryTransport != NULL);
	if (ppISecondaryTransport == NULL)
	{
		return E_POINTER;
	}
	*ppISecondaryTransport = m_pISecondaryTransport;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\WaveRecordToolbar.cpp ===
// WaveRecordToolbar.cpp : implementation file
//

#include "stdafx.h"
#include <mmsystem.h>
#include "dsoundp.h"
#include "CConduct.h"
#include "phoneyds.h"
#include <PChannelName.h>
#include "WaveRecordToolbar.h"
#include <commdlg.h>
#include <dmksctrl.h>
#include <initguid.h>
//#include "dmusics.h"
#include "MIDISave.h"
#include "DlgMIDIExport.h"
#include "..\WaveSaveDmo\testdmo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern DWORD g_dwLatency; // Defined in dslink.cpp

/////////////////////////////////////////////////////////////////////////////
// CWaveRecordToolbar

CWaveRecordToolbar::CWaveRecordToolbar()
{
	m_hWndToolbar = NULL;

	// Wave recording
	m_strOriginalWaveFilename.Empty();
	m_fRecordingWave = FALSE;
	m_fSetWaveFilenameForRecording = FALSE;

	// MIDI recording
	m_strMIDIFilename.Empty();
	m_fExportingMIDI = FALSE;
}

CWaveRecordToolbar::~CWaveRecordToolbar()
{
	if( m_fRecordingWave )
	{
		StartOrStopDumpDMOs( false );
		m_fRecordingWave = FALSE;
	}

	StopExportingMIDI();

	if( m_font.GetSafeHandle() )
	{
		m_font.DeleteObject();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWaveRecordToolbar IDMUSProdToolBar::GetInfo

HRESULT CWaveRecordToolbar::GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( (phWndOwner == NULL)
	||	(phInstance == NULL)
	||	(pnResourceId == NULL)
	||	(pbstrTitle == NULL) )
	{
		return E_POINTER;
	}

	*phWndOwner = m_hWnd;
	*phInstance = _Module.GetResourceInstance();
	*pnResourceId = (UINT)-1;  // we are going to build the toolbar from scratch

	CComBSTR bstrMenuHelpText;
	if( bstrMenuHelpText.LoadString( IDS_WAVERECORD_TITLE ) )
	{
		*pbstrTitle = bstrMenuHelpText.Detach();
	}
	else
	{
		*pbstrTitle = NULL;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRecordToolbar IDMUSProdToolBar::GetMenuText

HRESULT CWaveRecordToolbar::GetMenuText( BSTR* pbstrText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrText == NULL )
	{
		return E_POINTER;
	}

	CComBSTR bstrMenuHelpText;
	if( bstrMenuHelpText.LoadString( IDS_WAVERECORD_MENUTEXT ) )
	{
		*pbstrText = bstrMenuHelpText.Detach();
		return S_OK;
	}
	else
	{
		*pbstrText = NULL;
		return E_FAIL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRecordToolbar IDMUSProdToolBar::GetMenuHelpText

HRESULT CWaveRecordToolbar::GetMenuHelpText( BSTR* pbstrMenuHelpText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( pbstrMenuHelpText == NULL )
	{
		return E_POINTER;
	}

	CComBSTR bstrMenuHelpText;
	if( bstrMenuHelpText.LoadString( IDS_WAVERECORD_HELP ) )
	{
		*pbstrMenuHelpText = bstrMenuHelpText.Detach();
		return S_OK;
	}
	else
	{
		*pbstrMenuHelpText = NULL;
		return E_FAIL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRecordToolbar IDMUSProdToolBar::Initialize

HRESULT CWaveRecordToolbar::Initialize( HWND hWndToolBar )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( hWndToolBar == NULL )
	{
		return E_INVALIDARG;
	}
	m_hWndToolbar = hWndToolBar;
 
	// Create font for toolbar text
	CClientDC* pDC = new CClientDC( CWnd::FromHandle( m_hWndToolbar) );

	int nHeight = -( (pDC->GetDeviceCaps(LOGPIXELSY) * 8) / 72 );

	CString strFontName;
	if( strFontName.LoadString( IDS_TOOLBAR_FONT ) == 0)
	{
		strFontName = CString("MS Sans Serif");
	}
	m_font.CreateFont( nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,
		DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
		DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, strFontName );
	
	CFont* pOldFont = pDC->SelectObject( &m_font );
	
	TEXTMETRIC tm;
	pDC->GetTextMetrics( &tm );
	int cxChar =  tm.tmAveCharWidth;
	//int cyChar = tm.tmHeight + tm.tmExternalLeading;
	pDC->SelectObject( pOldFont );
	delete pDC;

	::SendMessage( m_hWndToolbar, TB_SETMAXTEXTROWS, 1, 0 );

	TBADDBITMAP tbAddBitmap;
	tbAddBitmap.hInst = _Module.GetResourceInstance();
	tbAddBitmap.nID = IDB_EXPORT_WAVE;
	::SendMessage( m_hWndToolbar, TB_ADDBITMAP, 4, (LPARAM)&tbAddBitmap );

	TBBUTTON button;
	button.dwData = 0;
	button.iString = 0;

	// 8 - Record MIDI
	button.iBitmap = 3;
	button.idCommand = ID_MIDI_EXPORT;
	button.fsState = 0;
	button.fsStyle = TBSTYLE_CHECK;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 7 - MIDI Filename
	button.iBitmap = 2;
	button.idCommand = ID_MIDI_FILENAME;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_BUTTON;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 6 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 5 - Wide separator for MIDI Filename
	button.iBitmap = cxChar * 20;
	button.idCommand = IDC_RECORD_MIDI_FILENAME;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 4 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 3 - Record wave
	button.iBitmap = 1;
	button.idCommand = ID_WAVE_RECORD;
	button.fsState = 0;
	button.fsStyle = TBSTYLE_CHECK;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 2 - Filename
	button.iBitmap = 0;
	button.idCommand = ID_WAVE_FILENAME;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_BUTTON;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 1 - Separator
	button.iBitmap = 0;
	button.idCommand = 0;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// 0 - Wide separator for Filename
	button.iBitmap = cxChar * 20;
	button.idCommand = IDC_RECORD_FILENAME;
	button.fsState = TBSTATE_ENABLED;
	button.fsStyle = TBSTYLE_SEP;
	::SendMessage( m_hWndToolbar, TB_INSERTBUTTON, 0, (LPARAM)&button );

	// Attach the wave filename static text box
	RECT rect;
	::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 0, (LPARAM)&rect );
	if( !m_staticWaveFilename.Create(NULL, WS_CHILD | WS_VISIBLE | SS_SUNKEN | SS_CENTER,
		rect, CWnd::FromHandle( m_hWndToolbar), IDC_RECORD_FILENAME) )
	{
		return -1;
	}
	m_staticWaveFilename.SetFont( &m_font );

	// Attach the MIDI filename static text box
	::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 5, (LPARAM)&rect );
	if( !m_staticMIDIFilename.Create(NULL, WS_CHILD | WS_VISIBLE | SS_SUNKEN | SS_CENTER,
		rect, CWnd::FromHandle( m_hWndToolbar), IDC_RECORD_MIDI_FILENAME) )
	{
		return -1;
	}
	m_staticMIDIFilename.SetFont( &m_font );

	return S_OK;
}

LRESULT CWaveRecordToolbar::OnWaveFilenameClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CFileDialog dlgFile( FALSE );

	// Set buffer for file name
	TCHAR tcstrFileName[_MAX_PATH];
	ZeroMemory( tcstrFileName, sizeof(TCHAR) * _MAX_PATH );
	dlgFile.m_ofn.lpstrFile = tcstrFileName;
	dlgFile.m_ofn.nMaxFile = _MAX_PATH;

	// Set buffer for file title
	TCHAR tcstrFileTitle[_MAX_FNAME];
	ZeroMemory( tcstrFileTitle, sizeof(TCHAR) * _MAX_FNAME );
	dlgFile.m_ofn.lpstrFileTitle = tcstrFileTitle;
	dlgFile.m_ofn.nMaxFileTitle = _MAX_FNAME;

	CString strTitle, strDefaultExt, strWaveFilterExt;
	VERIFY( strTitle.LoadString( IDS_WAVEFILE_TITLE ) );
	VERIFY( strDefaultExt.LoadString( IDS_WAVEFILE_DEFAULTEXT ) );
	VERIFY( strWaveFilterExt.LoadString( IDS_WAVEFILE_FILTER_EXT ) );

	dlgFile.m_ofn.lpstrDefExt = strDefaultExt;
	dlgFile.m_ofn.lpstrTitle = strTitle;

	// Contruct *.wav filter
	CString strFilter;
	VERIFY( strFilter.LoadString( IDS_WAVEFILE_FILTERDESC ) );
	strFilter += (TCHAR)'\0';
	strFilter += strWaveFilterExt;
	strFilter += (TCHAR)'\0';
	
	// Append *.* filter
	CString strAllFilter;
	VERIFY( strAllFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += strAllFilter;
	strFilter += (TCHAR)'\0';
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';

	dlgFile.m_ofn.lpstrFilter = strFilter;
	dlgFile.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT );

	// Get the default directory for this template
	TCHAR tcstrInitialDir[MAX_PATH];
	ZeroMemory( tcstrInitialDir, sizeof(TCHAR) * MAX_PATH );
	DWORD dwCbData = sizeof(TCHAR) * MAX_PATH;
	GetRegString( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\"), _T("WaveOutputRecordPath"),
		tcstrInitialDir, &dwCbData );

	if( tcstrInitialDir[0] )
	{
		dlgFile.m_ofn.lpstrInitialDir = tcstrInitialDir;
	}

	BOOL bResult = dlgFile.DoModal() == IDOK ? TRUE : FALSE;

	if( bResult )
	{
		// Store the default directory for the next Export Wave dialog
		TCHAR tcsPath[MAX_PATH];
		ZeroMemory( tcsPath, sizeof(TCHAR) * MAX_PATH );
		TCHAR *pLastSlash = _tcsrchr( dlgFile.m_ofn.lpstrFile, '\\' );
		_tcsncpy( tcsPath, dlgFile.m_ofn.lpstrFile, pLastSlash - dlgFile.m_ofn.lpstrFile );
		SetRegString( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\"), _T("WaveOutputRecordPath"), tcsPath );

		// Selected filename
		m_strOriginalWaveFilename = dlgFile.m_ofn.lpstrFile;
		m_staticWaveFilename.SetWindowText( dlgFile.m_ofn.lpstrFileTitle );

		m_fSetWaveFilenameForRecording = TRUE;

		/* Always enable the button
		if( g_pconductor->m_fAudiopathHasDumpDMOs )
		{
		*/
			::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG(TRUE, 0) );
		/*
		}
		*/
	}

	return FALSE; // Don't process further
}

LRESULT CWaveRecordToolbar::OnWaveRecordClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !m_fRecordingWave )
	{
		StartRecording();
	}
	else
	{
		StopRecording();
	}

	return FALSE; // Don't process further
}

void CWaveRecordToolbar::StopAll( void )
{
	// Stop wave export
	if( m_fRecordingWave )
	{
		StopRecording();
	}
	
	// Stop MIDI export
	StopExportingMIDI();
}

void CWaveRecordToolbar::StartRecording( void )
{
	// Start recording
	if( g_pconductor->m_fUsePhoneyDSound )
	{
		HRESULT hr;

		if( m_strOriginalWaveFilename.IsEmpty() )
		{
			// Uncheck the record button
			::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG(FALSE, 0) );
			return;
		}
		
		WAVEFORMATEX wfex;
		hr = g_pconductor->m_pPhoneyDSound->GetFormat( &wfex );

		if (FAILED(hr) || (wfex.wFormatTag != WAVE_FORMAT_PCM) || (wfex.cbSize != 0))
		{
			// Uncheck the record button
			::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG(FALSE, 0) );
			return;
		}

		HANDLE hCaptureFile;
		hCaptureFile = CreateFile(m_strOriginalWaveFilename,
								 GENERIC_WRITE,
								 0,					// No sharing
								 NULL,				// No security attributes
								 CREATE_ALWAYS,		
								 FILE_ATTRIBUTE_NORMAL,
								 NULL);				// No template file

		if (hCaptureFile == INVALID_HANDLE_VALUE)
		{
			CString strMsg;
			LPVOID lpMessageBuffer;
			
			FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
						   NULL, GetLastError(),
						   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
						   (LPTSTR)&lpMessageBuffer, 0, NULL );

			HINSTANCE hInstanceOld = AfxGetResourceHandle();
			AfxSetResourceHandle( _Module.GetResourceInstance() );

			AfxFormatString1( strMsg, IDS_SYSERR_OPEN, m_strOriginalWaveFilename );
			strMsg = strMsg + (LPTSTR)lpMessageBuffer;
			AfxMessageBox( strMsg );

			AfxSetResourceHandle( hInstanceOld );

			LocalFree( lpMessageBuffer );
			// Uncheck the record button
			::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG(FALSE, 0) );
			return;
		}

		SetFilePointer(hCaptureFile, sizeof(WaveFileHeader), 0, FILE_BEGIN);

		// Start recording
		g_pconductor->m_pPhoneyDSound->SetFileHandle( hCaptureFile );
		m_fRecordingWave = TRUE;
		::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG(TRUE, 0) );

		return;
	}
	else
	{
		StartOrStopDumpDMOs( true );

		// Start recording
		m_fRecordingWave = TRUE;
		::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG(TRUE, 0) );
	}
}

void CWaveRecordToolbar::StopRecording( void )
{
	//GetFileHandle
	m_fRecordingWave = FALSE;

	// Stop recording
	if( g_pconductor->m_fUsePhoneyDSound )
	{
		HANDLE hCaptureFile = g_pconductor->m_pPhoneyDSound->GetFileHandle();

		if (hCaptureFile != INVALID_HANDLE_VALUE)
		{
			g_pconductor->m_pPhoneyDSound->SetFileHandle( INVALID_HANDLE_VALUE );

			// Wait for twice the latency, to ensure that the file is no longer being written to
			Sleep( g_dwLatency * 2 );

			WaveFileHeader wfHeader;
			memset(&wfHeader, 0, sizeof(&wfHeader));
			wfHeader.FourCCRiff = FOURCC_RIFF;
			wfHeader.FourCCWave = mmioFOURCC('W', 'A', 'V', 'E');
			wfHeader.FourCCFmt  = mmioFOURCC('f', 'm', 't', ' ');
			wfHeader.FmtLength  = sizeof(wfHeader.Fmt);
			wfHeader.FourCCData = mmioFOURCC('d', 'a', 't', 'a');

			WAVEFORMATEX wfex;
			if( FAILED( g_pconductor->m_pPhoneyDSound->GetFormat( &wfex ) ) )
			{
				wfex.cbSize = 0;
				wfex.nAvgBytesPerSec = 22050 * 2 * 2;
				wfex.nBlockAlign = 4;
				wfex.nChannels = 2;
				wfex.nSamplesPerSec = 22050;
				wfex.wBitsPerSample = 16;
				wfex.wFormatTag = WAVE_FORMAT_PCM;
			}

			memcpy(&wfHeader.Fmt, &wfex, sizeof(wfHeader.Fmt));

			DWORD dwSize = GetFileSize(hCaptureFile, NULL);

			wfHeader.FileLength = dwSize - sizeof(FOURCC) - sizeof(DWORD);
			wfHeader.DataLength = dwSize - sizeof(wfHeader);
			
			SetFilePointer(hCaptureFile, 0, 0, FILE_BEGIN);
			DWORD dwWritten;
			WriteFile(hCaptureFile, &wfHeader, sizeof(wfHeader), &dwWritten, NULL);
		
			CloseHandle(hCaptureFile);
		}
	}
	else
	{
		StartOrStopDumpDMOs( false );
	}

	// Reset static window to NULL and disable the record button
	m_staticWaveFilename.SetWindowText( NULL );
	::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG(FALSE, 0) );
	::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG(FALSE, 0) );
	m_fSetWaveFilenameForRecording = FALSE;

	// Display the file in the project tree
	while( !m_lstUsedWaveFilenames.IsEmpty() )
	{
		BSTR bstrFileName = m_lstUsedWaveFilenames.RemoveHead().AllocSysString();
		g_pconductor->m_pFrameWork->ShowFile( bstrFileName );
	}
}

void IncrementFilename( CHAR szDumpWave[_MAX_PATH] )
{
	// Copy the original name
	CHAR szOrigName[_MAX_PATH];
	strcpy( szOrigName, szDumpWave );

	// Find the position of the last '.'
	CHAR *pDot = strrchr( szOrigName, '.' );

	// If we didn't find the dot
	if( pDot == NULL )
	{
		// Point pDot at the trailing NULL
		pDot = szOrigName + strlen( szOrigName );
	}
	else
	{
		// Cut off the name at the dot
		*pDot = NULL;
	}

	// The string to store the number in
	CHAR *pNumberStart = pDot-1;
	CHAR szNbr[_MAX_PATH];
	while( pNumberStart > szOrigName  &&  isdigit( *pNumberStart ) )
	{
		pNumberStart--;
	}

	// Increment to the first number
	*pNumberStart++;

	// Check if we didn't find a number
	if( pNumberStart == pDot )
	{
		// No number - make szNbr empty
		szNbr[0] = NULL;
	}
	else
	{
		// Copy the number to szNbr
		strcpy( szNbr, pNumberStart );

		// Cut off the name at the start of the number
		*pNumberStart = NULL;
	}

	// Save the length of the textual part of the original name
	const int nOrigNameLength = strlen( szOrigName );

	// Set the first number to use
	int i = atoi( szNbr );

	// Convert from a number to a string
	_itoa( ++i, szNbr, 10 );

	// Get the length of the number text
	int nNbrLength = strlen(szNbr);

	// Ensure the name doesn't go longer than _MAX_PATH (5 = length of ".wav" plus the trailing NULL)
	if( (nOrigNameLength + nNbrLength + 5) <= _MAX_PATH )
	{
		// Name will fit within _MAX_PATH, just copy it
		strcpy( szDumpWave, szOrigName );
		strcat( szDumpWave, szNbr );
		strcat( szDumpWave, ".wav" );
	}
	else
	{
		// Name won't fit within _MAX_PATH, clip szOrigName
		ZeroMemory( szDumpWave, _MAX_PATH );
		strncpy( szDumpWave, szOrigName, _MAX_PATH - nNbrLength - 5 );
		strcat( szDumpWave, szNbr );
		strcat( szDumpWave, ".wav" );
	}
}

HRESULT StartOrStopDumpDMOsInternal( const bool fStart, const DWORD dwPChannel, const DWORD dwBufferPath, const DWORD dwDMOPath, bool &fOneSucceeded, bool &fOneFailed, IDirectMusicAudioPath *pAudiopath, char *szFileName, CStringList &stringList, CString &strFailedFiles )
{
	HRESULT hr = S_FALSE;
	WCHAR wcstrFileName[_MAX_PATH];
	wcstrFileName[0] = NULL;
	IDirectSoundBuffer *pIDirectSoundBuffer;
	DWORD dwBufferIndex = 0;
	while( S_OK == pAudiopath->GetObjectInPath( dwPChannel, dwBufferPath, dwBufferIndex,
		 GUID_All_Objects, 0, IID_IDirectSoundBuffer, (void**) &pIDirectSoundBuffer ) )
	{
		IDump* pIDump = NULL;
		DWORD dwDMOIndex = 0;
		while( S_OK == pAudiopath->GetObjectInPath( dwPChannel, dwDMOPath, dwBufferIndex,
			GUID_DSFX_STANDARD_DUMP, dwDMOIndex, IID_IDump, (void**) &pIDump ) )
		{
			if( fStart )
			{
				// If we've found a DMO, increment the filename
				if( fOneSucceeded
				||	fOneFailed )
				{
					IncrementFilename( szFileName );
				}

				// Convert to a wide character string
				VERIFY( mbstowcs( wcstrFileName, szFileName, strlen(szFileName) + 1 ) > 0 );

				// Set the filename
				pIDump->SetOverwrite( TRUE );
				hr = pIDump->SetDumpWave( wcstrFileName );
				if( SUCCEEDED( hr ) )
				{
					TRACE("Starting dump DMO %s\n", szFileName);
					hr = pIDump->Start();
					if( SUCCEEDED( hr ) )
					{
						fOneSucceeded = true;
						stringList.AddTail( wcstrFileName );
					}
					else
					{
						if( strFailedFiles.IsEmpty() )
						{
							strFailedFiles = szFileName;
						}
						else
						{
							strFailedFiles += CString(_T("\n")) + CString(szFileName);
						}
						fOneFailed = true;
					}
				}
				else
				{
					if( strFailedFiles.IsEmpty() )
					{
						strFailedFiles = szFileName;
					}
					else
					{
						strFailedFiles += CString(_T("\n")) + CString(szFileName);
					}
					fOneFailed = true;
				}
			}
			else
			{
				hr = pIDump->Stop();
				if( SUCCEEDED( hr ) )
				{
					fOneSucceeded = true;
				}
				else
				{
					fOneFailed = true;
				}
			}
			dwDMOIndex++;
			pIDump->Release();
		}

		dwBufferIndex++;
		pIDirectSoundBuffer->Release();
	}

	return hr;
}

HRESULT	CWaveRecordToolbar::StartOrStopDumpDMOsOnAudiopath( bool fStart, IDirectMusicAudioPath *pAudiopath )
{
	// If no audiopath, nothing to do
	if( pAudiopath == NULL )
	{
		return S_FALSE;
	}

	char szFileName[_MAX_PATH];
	szFileName[0] = NULL;
	if( m_lstUsedWaveFilenames.IsEmpty() )
	{
		strcpy( szFileName, m_strOriginalWaveFilename );
	}
	else
	{
		strcpy( szFileName, m_lstUsedWaveFilenames.GetTail() );
		IncrementFilename( szFileName );
	}

	bool fOneSucceeded = false;
	bool fOneFailed = false;
	CString strFailedFiles;
	HRESULT hr1 = StartOrStopDumpDMOsInternal( fStart, DMUS_PCHANNEL_ALL, DMUS_PATH_BUFFER, DMUS_PATH_BUFFER_DMO,
											   fOneSucceeded, fOneFailed, pAudiopath, szFileName, m_lstUsedWaveFilenames, strFailedFiles );

	HRESULT hr2 = StartOrStopDumpDMOsInternal( fStart, 0, DMUS_PATH_MIXIN_BUFFER, DMUS_PATH_MIXIN_BUFFER_DMO,
											   fOneSucceeded, fOneFailed, pAudiopath, szFileName, m_lstUsedWaveFilenames, strFailedFiles );

	// If something failed, display an error message
	if( fOneFailed
	&&	!strFailedFiles.IsEmpty() )
	{
		CString strError;
		AfxFormatString1( strError, IDS_ERR_NOT_ALL_FILE_OUTPUT, strFailedFiles );
		AfxMessageBox( strError, MB_ICONWARNING | MB_OK );
	}

	// If something succeeded, return S_OK
	if( fOneSucceeded )
	{
		return S_OK;
	}
	// If something failed, return hr
	if( fOneFailed )
	{
		if( FAILED( hr1 ) )
		{
			return hr1;
		}
		return hr2;
	}
	// Otherwise, return E_FAIL;
	return E_FAIL;
}

HRESULT	CWaveRecordToolbar::StartOrStopDumpDMOs( bool fStart )
{
	ASSERT( !fStart || m_lstUsedWaveFilenames.IsEmpty() );

	HRESULT hr = StartOrStopDumpDMOsOnAudiopath( fStart, g_pconductor->m_pDMAudiopath );

	::EnterCriticalSection( &g_pconductor->m_csAudiopathList );
	POSITION pos = g_pconductor->m_lstSegStateAudioPaths.GetHeadPosition();
	while( pos )
	{
		SegStateAudioPath *pSegStateAudioPath = g_pconductor->m_lstSegStateAudioPaths.GetNext( pos );
		HRESULT hrTmp = StartOrStopDumpDMOsOnAudiopath( fStart, pSegStateAudioPath->pAudiopath );
		if( SUCCEEDED( hrTmp ) )
		{
			hr = hrTmp;
		}
	}
	::LeaveCriticalSection( &g_pconductor->m_csAudiopathList );

	return hr;
}

void CWaveRecordToolbar::UpdateRecordButtonState( void )
{
	if( m_fRecordingWave )
	{
		return;
	}

	// Enable the button even if we don't have any dump DMOs.
	BOOL fEnable = m_fSetWaveFilenameForRecording && g_pconductor->m_fOutputEnabled/* && g_pconductor->m_fAudiopathHasDumpDMOs*/;

	::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, (WPARAM)ID_WAVE_RECORD, (LPARAM) MAKELONG( fEnable, 0) );
}

LRESULT CWaveRecordToolbar::OnMIDIFilenameClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CFileDialog dlgFile( FALSE );

	// Set buffer for file name
	TCHAR tcstrFileName[_MAX_PATH];
	ZeroMemory( tcstrFileName, sizeof(TCHAR) * _MAX_PATH );
	dlgFile.m_ofn.lpstrFile = tcstrFileName;
	dlgFile.m_ofn.nMaxFile = _MAX_PATH;

	// Set buffer for file title
	TCHAR tcstrFileTitle[_MAX_FNAME];
	ZeroMemory( tcstrFileTitle, sizeof(TCHAR) * _MAX_FNAME );
	dlgFile.m_ofn.lpstrFileTitle = tcstrFileTitle;
	dlgFile.m_ofn.nMaxFileTitle = _MAX_FNAME;

	CString strTitle, strDefaultExt, strMIDIFilterExt;
	VERIFY( strTitle.LoadString( IDS_MIDIFILE_TITLE ) );
	VERIFY( strDefaultExt.LoadString( IDS_MIDIFILE_DEFAULTEXT ) );
	VERIFY( strMIDIFilterExt.LoadString( IDS_MIDIFILE_FILTER_EXT ) );

	dlgFile.m_ofn.lpstrDefExt = strDefaultExt;
	dlgFile.m_ofn.lpstrTitle = strTitle;

	// Contruct *.wav filter
	CString strFilter;
	VERIFY( strFilter.LoadString( IDS_MIDIFILE_FILTERDESC ) );
	strFilter += (TCHAR)'\0';
	strFilter += strMIDIFilterExt;
	strFilter += (TCHAR)'\0';
	
	// Append *.* filter
	CString strAllFilter;
	VERIFY( strAllFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += strAllFilter;
	strFilter += (TCHAR)'\0';
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';

	dlgFile.m_ofn.lpstrFilter = strFilter;
	dlgFile.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT );

	// Get the default directory for this template
	TCHAR tcstrInitialDir[MAX_PATH];
	ZeroMemory( tcstrInitialDir, sizeof(TCHAR) * MAX_PATH );
	DWORD dwCbData = sizeof(TCHAR) * MAX_PATH;
	GetRegString( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\"), _T("MIDIExportDefaultPath"),
		tcstrInitialDir, &dwCbData );

	if( tcstrInitialDir[0] )
	{
		dlgFile.m_ofn.lpstrInitialDir = tcstrInitialDir;
	}

	BOOL bResult = dlgFile.DoModal() == IDOK ? TRUE : FALSE;

	// Store the default directory for the next Export MIDI dialog
	if( bResult )
	{
		TCHAR tcsPath[MAX_PATH];
		ZeroMemory( tcsPath, sizeof(TCHAR) * MAX_PATH );
		TCHAR *pLastSlash = _tcsrchr( dlgFile.m_ofn.lpstrFile, '\\' );
		_tcsncpy( tcsPath, dlgFile.m_ofn.lpstrFile, pLastSlash - dlgFile.m_ofn.lpstrFile );
		SetRegString( HKEY_CURRENT_USER, _T("Software\\Microsoft\\DMUSProducer\\"), _T("MIDIExportDefaultPath"), tcsPath );

		// Selected filename
		m_strMIDIFilename = dlgFile.m_ofn.lpstrFile;
		m_staticMIDIFilename.SetWindowText( dlgFile.m_ofn.lpstrFileTitle );

		UpdateExportMIDIButtonState();
	}

	return FALSE; // Don't process further
}

LRESULT CWaveRecordToolbar::OnMIDIExportClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(hWndCtl);
	UNREFERENCED_PARAMETER(wID);
	UNREFERENCED_PARAMETER(wNotifyCode);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !m_fExportingMIDI )
	{
		StartExportingMIDI();
	}
	else
	{
		StopExportingMIDI();
	}

	return FALSE; // Don't process further
}

void CWaveRecordToolbar::StartExportingMIDI( void )
{
	if( m_fExportingMIDI )
	{
		// Already exporting, so just exit
		return;
	}

	if( m_strMIDIFilename.IsEmpty() )
	{
		// Can't export unless there is a filename
		return;
	}
		
	m_fExportingMIDI = TRUE;

	// Update UI
	::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, (WPARAM)ID_MIDI_EXPORT, (LPARAM) MAKELONG(TRUE, 0) );

	// Start exporting
	if( g_pconductor->m_pMIDISaveTool )
	{
		g_pconductor->m_pMIDISaveTool->SetChannels( GetMaxPChannelNbr() );
		g_pconductor->m_pMIDISaveTool->StartRecording();
	}
}

void CWaveRecordToolbar::StopExportingMIDI( void )
{
	if( m_fExportingMIDI == FALSE )
	{
		RELEASE( g_pconductor->m_pIUnknownMIDIExport );
		RELEASE( g_pconductor->m_pISegStateMIDIExport );
		return;
	}

	m_fExportingMIDI = FALSE;

	// Stop exporting and save the MIDI file
	if( g_pconductor->m_pMIDISaveTool )
	{
		g_pconductor->m_pMIDISaveTool->StopRecording();
		SetTrackNames();
		if( SUCCEEDED ( g_pconductor->m_pMIDISaveTool->SaveMIDIFile( m_strMIDIFilename,
																	 g_pconductor->m_pISegStateMIDIExport,
																	 g_pconductor->m_fLeadInMeasureMIDIExport,
																	 FALSE ) ) )
		{
			BSTR bstrFileName = m_strMIDIFilename.AllocSysString();
			g_pconductor->m_pFrameWork->ShowFile( bstrFileName );

			m_strMIDIFilename.Empty();
			m_staticMIDIFilename.SetWindowText( NULL );
	
			// Update UI
			if( ::IsWindow( m_hWndToolbar ) )
			{
				::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, (WPARAM)ID_MIDI_EXPORT, (LPARAM) MAKELONG(FALSE, 0) );
				::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, (WPARAM)ID_MIDI_EXPORT, (LPARAM) MAKELONG(FALSE, 0) );
			}
		}
		else
		{
			// Update UI
			if( ::IsWindow( m_hWndToolbar ) )
			{
				::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, (WPARAM)ID_MIDI_EXPORT, (LPARAM) MAKELONG(TRUE, 0) );
				::SendMessage( m_hWndToolbar, TB_CHECKBUTTON, (WPARAM)ID_MIDI_EXPORT, (LPARAM) MAKELONG(FALSE, 0) );
			}
		}
	}

	RELEASE( g_pconductor->m_pIUnknownMIDIExport );
	RELEASE( g_pconductor->m_pISegStateMIDIExport );
}

void CWaveRecordToolbar::UpdateExportMIDIButtonState( void )
{
	if( m_fExportingMIDI )
	{
		return;
	}

	BOOL fEnable = FALSE;
	if(	m_strMIDIFilename.IsEmpty() == FALSE
	&&  g_pconductor->m_fOutputEnabled )
	{
		fEnable = TRUE;
	}

	::SendMessage( m_hWndToolbar, TB_ENABLEBUTTON, (WPARAM)ID_MIDI_EXPORT, (LPARAM) MAKELONG( fEnable, 0) );
}

DWORD CWaveRecordToolbar::GetMaxPChannelNbr( void )
{
	if( g_pconductor->m_pDMAudiopath )
	{
		for( DWORD dwPChannelNbr = 999; dwPChannelNbr > 0; dwPChannelNbr-- )
		{
			IDirectMusicPort *pDMPort = NULL;
			if( SUCCEEDED( g_pconductor->m_pDMAudiopath->GetObjectInPath( dwPChannelNbr,
					DMUS_PATH_PORT, 0, GUID_All_Objects, 0, IID_IDirectMusicPort, (void **)&pDMPort ) ) )
			{
				pDMPort->Release();
				return dwPChannelNbr + 1;
			}
		}
	}

	return 0;
}

void CWaveRecordToolbar::SetTrackNames( void )
{
	IDMUSProdPChannelName* pIPChannelName;
	WCHAR pszPChannelName[DMUS_MAX_NAME];
	char  pszTheName[DMUS_MAX_NAME / 2];

	if( g_pconductor->m_pMIDISaveTool == NULL
	||  g_pconductor->m_pIUnknownMIDIExport == NULL )
	{
		return;
	}

	IDMUSProdNode* pINode;
	if( SUCCEEDED( g_pconductor->m_pIUnknownMIDIExport->QueryInterface( IID_IDMUSProdNode, (void**)&pINode ) ) )
	{
		IDMUSProdProject* pIProject;
		if( SUCCEEDED( g_pconductor->m_pFrameWork->FindProject( pINode, &pIProject ) ) )
		{
			if( pIProject->QueryInterface(IID_IDMUSProdPChannelName, (void**)&pIPChannelName) == S_OK )
			{
				// Iterate through all PChannels
				const DWORD dwMaxPChannel = GetMaxPChannelNbr();

				for( DWORD dwPChannelNbr = 0; dwPChannelNbr < dwMaxPChannel; dwPChannelNbr++ )
				{
					pIPChannelName->GetPChannelName( dwPChannelNbr, pszPChannelName );

					memset( pszTheName, 0, (DMUS_MAX_NAME / 2) );
					wcstombs( pszTheName, pszPChannelName, wcslen(pszPChannelName) );
					g_pconductor->m_pMIDISaveTool->SetChannelName( dwPChannelNbr, pszTheName );
				}

				RELEASE( pIPChannelName );
			}

			RELEASE( pIProject );
		}

		RELEASE( pINode );
	}
}

LRESULT CWaveRecordToolbar::OnSegmentEnd( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(uMsg);
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(bHandled);
	
	if( g_pconductor->AllTransportsSetToPlay() )
	{
		StopExportingMIDI();
	}

	return 0;
}

LRESULT CWaveRecordToolbar::OnRightClick( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(bHandled);
	UNREFERENCED_PARAMETER(wNotifyCode);

	// Get the cursor position (To put the menu there)
	POINT ptScreen, ptClient;
	BOOL  bResult;
	bResult = ::GetCursorPos( &ptScreen );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	ptClient = ptScreen;
	bResult = ::ScreenToClient( pNMHDR->hwndFrom, &ptClient );
	ASSERT( bResult );
	if( !bResult )
	{
		return FALSE;
	}

	if( ::IsWindow( m_hWndToolbar ) )
	{
		CRect rect;

		// See if right click was on MIDI Export button
		::SendMessage( m_hWndToolbar, TB_GETITEMRECT, 8, (LPARAM) &rect );
		if( rect.PtInRect( ptClient ) )
		{
			// Make sure button is enabled
			if( ::SendMessage( m_hWndToolbar, TB_ISBUTTONENABLED, ID_MIDI_EXPORT, 0 ) )
			{
				CDlgMIDIExport dlg;

				dlg.m_fLeadInMeasureMIDIExport = g_pconductor->m_fLeadInMeasureMIDIExport;

				if( dlg.DoModal() == IDOK )
				{
					g_pconductor->m_fLeadInMeasureMIDIExport = dlg.m_fLeadInMeasureMIDIExport;
				}
			}
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\TREntry.h ===
#if !defined(TRENTRY_H__36F6EDF3_46CE_11D0_B9DB_00AA00C08146__INCLUDED_)
#define TRENTRY_H__36F6EDF3_46CE_11D0_B9DB_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// TREntry.h : Declaration of CTransportRegEntry and CSecondaryTransportRegEntry

/////////////////////////////////////////////////////////////////////////////
// ITransportRegEntry interface

interface ITransportRegEntry : IUnknown
{
	virtual HRESULT __stdcall GetTransport( IDMUSProdTransport **ppITransport ) = 0;
	virtual HRESULT __stdcall GetFlags( DWORD *pdwFlags ) = 0;
	virtual HRESULT __stdcall SetFlags( DWORD dwFlags ) = 0;
};

// CTransportRegEntry definition
class CTransportRegEntry : ITransportRegEntry
{
public:
	// IUnknown methods
	virtual HRESULT __stdcall QueryInterface( const IID &iid, void **ppv );
	virtual ULONG __stdcall AddRef();
	virtual ULONG __stdcall Release();

	// ITransportRegEntry methods
	HRESULT __stdcall GetTransport( IDMUSProdTransport **ppITransport );
	HRESULT __stdcall GetFlags( DWORD *pdwFlags );
	HRESULT __stdcall SetFlags( DWORD dwFlags );

	// Constructor
	CTransportRegEntry( IDMUSProdTransport *pITransport ) :
		m_cRef(0),
		m_pITransport(pITransport),
		m_dwFlags(0) {}

private:
	// Member variables
	long  m_cRef;
	IDMUSProdTransport	*m_pITransport;
	DWORD m_dwFlags;
};

/////////////////////////////////////////////////////////////////////////////
// ISecondaryTransportRegEntry interface

interface ISecondaryTransportRegEntry : IUnknown
{
	virtual HRESULT __stdcall GetSecondaryTransport( IDMUSProdSecondaryTransport **ppISecondaryTransport ) = 0;
};

// CSecondaryTransportRegEntry definition
class CSecondaryTransportRegEntry : ISecondaryTransportRegEntry
{
public:
	// IUnknown methods
	virtual HRESULT __stdcall QueryInterface( const IID &iid, void **ppv );
	virtual ULONG __stdcall AddRef();
	virtual ULONG __stdcall Release();

	// ISecondaryTransportRegEntry methods
	HRESULT __stdcall GetSecondaryTransport( IDMUSProdSecondaryTransport **ppISecondaryTransport );

	// Constructor
	CSecondaryTransportRegEntry( IDMUSProdSecondaryTransport *pISecondaryTransport ) :
		m_cRef(0),
			m_pISecondaryTransport(pISecondaryTransport) {}

private:
	// Member variables
	long  m_cRef;
	IDMUSProdSecondaryTransport	*m_pISecondaryTransport;
};

#endif // !defined(TRENTRY_H__36F6EDF3_46CE_11D0_B9DB_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\audiosink.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//	    audiosink.h

#ifndef __AUDIO_SINK__
#define __AUDIO_SINK__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <math.h>
#include <mmsystem.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "cclock.h"
#include "PLClock.h"
#include "dslink.h"
#include "dsoundp.h"
#include "dmksctrl.h"

#define DEFAULT_PHONEY_DS_LATENCY 20

#ifdef _DEBUG
#define IS_VALID_READ_PTR(a, b)         !IsBadReadPtr(a, b)
#define IS_VALID_WRITE_PTR(a, b)        !IsBadWritePtr(a, b)
#else // _DEBUG
#define IS_VALID_READ_PTR(a, b)         ((a) || (!(b)))
#define IS_VALID_WRITE_PTR(a, b)        ((a) || (!(b)))
#endif // _DEBUG

DEFINE_GUID(IID_CBuffer, 0xf1e13d57, 0x7c29, 0x4ae6, 0x8d, 0x77, 0x94, 0x32, 0xb6, 0x51, 0xf3, 0xa6);

class CAudioSink;
class CEffectChain;

#define AUDIOSINK_MAX_CHANNELS  2           // Max number of buses connected to buffer. We're limiting to 2 for now.
#define AUDIOSINK_NULL_BUS_ID   0xFFFFFFFF  // NULL bus ID.
#define AUDIOSINK_BUS_SIZE      30          // Bus size, in milliseconds

class CBuffer : public IDirectSoundBuffer8, public AListItem
{
friend class CAudioSink;
friend class CSendEffect;
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundBuffer methods
    STDMETHODIMP GetCaps(LPDSBCAPS pBufferCaps) ;
    STDMETHODIMP GetCurrentPosition(LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) ;
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) ;
    STDMETHODIMP GetVolume(LPLONG plVolume) ;
    STDMETHODIMP GetPan(LPLONG plPan) ;
    STDMETHODIMP GetFrequency(LPDWORD pdwFrequency) ;
    STDMETHODIMP GetStatus(LPDWORD pdwStatus) ;
    STDMETHODIMP Initialize(LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcBufferDesc) ;
    STDMETHODIMP Lock(DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,
                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) ;
    STDMETHODIMP Play(DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) ;
    STDMETHODIMP SetCurrentPosition(DWORD dwNewPosition) ;
    STDMETHODIMP SetFormat(LPCWAVEFORMATEX pcfxFormat) ;
    STDMETHODIMP SetVolume(LONG lVolume) ;
    STDMETHODIMP SetPan(LONG lPan) ;
    STDMETHODIMP SetFrequency(DWORD dwFrequency) ;
    STDMETHODIMP Stop() ;
    STDMETHODIMP Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) ;
    STDMETHODIMP Restore() ;

    // IDirectSoundBuffer8 methods
    STDMETHODIMP SetFX(DWORD dwEffectsCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes) ;
    STDMETHODIMP AcquireResources(DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes) ;
    STDMETHODIMP GetObjectInPath(REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) ;

    CBuffer(CAudioSink *pParent,LPCDSBUFFERDESC pcBufferDesc,LPDWORD pdwFuncID, DWORD dwBusIDCount,REFGUID guidBufferID);
    CBuffer(CAudioSink *pParent,IUnknown *punkBufferConfig);
    ~CBuffer();
    CBuffer* GetNext() { return (CBuffer*)AListItem::GetNext();}
	WAVEFORMATEX* Format( void );
	DWORD GetBufferType( void ) { return m_dwType; }
	bool IsPlaying( void ) { return true; }
    HRESULT FindSendLoop(CBuffer*);
    CAudioSink *        m_pParentSink;                  // Pointer to parent sink that manages the buffers.
private:
    DWORD               DBToMultiplier(long lGain);
    void                CalcVolume();
    long                m_cRef;
	DWORD				m_dwType;						// Buffer flags DSBCAPS_*
    DWORD               m_dwFrequency;                  // Buffer playback frequency.
    long                m_lPBend;                       // Equivalent pitch bend.
    long                m_lVolume;                      // Gain, in dB.
    long                m_lPan;                         // Pan.
    DWORD               m_dwLeftVolume;                 // Left volume linear multiplier.
    DWORD               m_dwRightVolume;                // Right volume linear multiplier.
    GUID                m_guidBufferID;                 // Each mixin buffer has a unique guid.
    DWORD               m_dwChannels;                   // Number of channels in buffer itself.
    DWORD               m_dwBusCount;                   // Number of buses connected to buffer. We're maxing at 2 for now.
    DWORD               m_dwFunctionIDs[AUDIOSINK_MAX_CHANNELS];  // Function ids for each bus that feeds this buffer.
    DWORD               m_dwBusIDs[AUDIOSINK_MAX_CHANNELS];       // Equivalent bus ids.
    short *             m_pBusBuffer[AUDIOSINK_MAX_CHANNELS]; // Bus buffers to feed to synth.
	short *				m_pExtraBuffer;					// Buffer for doing effects or mixin
    static DWORD        m_sdwNextBusID;                 // Global bus id generator.
	WAVEFORMATEX		m_wfBufferFormat;				// Format for audio.
	CEffectChain *		m_fxChain;
    CRITICAL_SECTION	m_CriticalSection;				// Critical section to manage access.

	void Render( long *plBuffer, DWORD dwLength, REFERENCE_TIME rtTime ); // Render the buffer into a temporary 32-bit buffer
	void PreRender( DWORD dwLength ); // Do any pre-render setup
	void RenderNoFX( long *plBuffer, DWORD dwLength ); // Render the buffer into a temporary 32-bit buffer
	void RenderFX( long *plBuffer, DWORD dwLength, REFERENCE_TIME rtTime ); // Render the buffer into a temporary 32-bit buffer
	void RenderFXFinalMix( long *plBuffer, DWORD dwLength ); // Render the buffer into a temporary 32-bit buffer
};

class CBufferList : public AList
{
public:
    void Clear();
    void AddHead(CBuffer* pBuffer) { AList::AddHead((AListItem*)pBuffer);}
    CBuffer* GetHead(){return (CBuffer*)AList::GetHead();}
    CBuffer* RemoveHead() {return (CBuffer *) AList::RemoveHead();}
    void Remove(CBuffer* pBuffer){AList::Remove((AListItem*)pBuffer);}
    void AddTail(CBuffer* pBuffer){AList::AddTail((AListItem*)pBuffer);}
    BOOL IsMember(CBuffer* pBuffer){return AList::IsMember((AListItem*)pBuffer);}
};

class CAudioSink :  public IDirectSoundSynthSink, public IDirectSoundConnect, public IReferenceClock, public IKsControl
{
friend class CBuffer;
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundSynthSink methods
    STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock) ;
    STDMETHODIMP Activate(BOOL fEnable) ;
    STDMETHODIMP SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prtTime) ;
    STDMETHODIMP RefToSampleTime(REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) ;
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) ;

    // IDirectSoundConnect methods
    STDMETHODIMP AddSource(LPDIRECTSOUNDSOURCE pDSSource) ;
    STDMETHODIMP RemoveSource(LPDIRECTSOUNDSOURCE pDSSource) ;
    STDMETHODIMP SetMasterClock(IReferenceClock *pClock) ;
    STDMETHODIMP CreateSoundBuffer(LPCDSBUFFERDESC pcBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppBuffer) ;
    STDMETHODIMP CreateSoundBufferFromConfig(LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppBuffer) ;
    STDMETHODIMP GetSoundBuffer(DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppBuffer) ;
    STDMETHODIMP GetBusCount(LPDWORD pdwCount) ;
    STDMETHODIMP GetBusIDs(LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount) ;
    STDMETHODIMP GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID) ;
    STDMETHODIMP GetSoundBufferBusIDs(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount) ;

    /* IReferenceClock methods */
    STDMETHODIMP GetTime(REFERENCE_TIME *pTime);
    STDMETHODIMP AdviseTime(REFERENCE_TIME baseTime,REFERENCE_TIME streamTime,HANDLE hEvent,DWORD *pdwAdviseCookie);
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME startTime,REFERENCE_TIME periodTime,HANDLE hSemaphore,DWORD *pdwAdviseCookie);
    STDMETHODIMP STDMETHODCALLTYPE Unadvise(DWORD dwAdviseCookie);

    /* IKsControl methods */
    STDMETHODIMP KsProperty(PKSPROPERTY Property,ULONG PropertyLength,
        LPVOID PropertyData,ULONG DataLength,ULONG* BytesReturned);
    STDMETHODIMP KsMethod(PKSMETHOD Method,ULONG MethodLength,
        LPVOID MethodData,ULONG DataLength,ULONG* BytesReturned) ;
    STDMETHODIMP KsEvent(PKSEVENT Event OPTIONAL,ULONG EventLength,
        LPVOID EventData,ULONG DataLength,ULONG* BytesReturned);

    CAudioSink(WAVEFORMATEX *pwfxFormat);
    ~CAudioSink();
    void                    Render(short *pnBuffer,DWORD dwLength,LONGLONG llWritePosition, LONGLONG llPlayPosition);
    void                    RemoveBuffer(CBuffer *pBuffer);
	void					AddBuffer(CBuffer *pBuffer);
	CBuffer *				FindBufferFromGUID( REFGUID rguidBuffer );
    CDSLink                 m_DSLink;
private:
    void                    ResizeBusArrays();
    void                    FillBusArrays();
    void                    Mix(short *pnBuffer,DWORD dwLength, REFERENCE_TIME rtTime);

    CSampleClock            m_SampleClock;
    long                    m_cRef;
	WAVEFORMATEX		    m_wfSinkFormat;     // Format for audio.
    IReferenceClock *       m_pMasterClock;
    IDirectSoundSinkSync *  m_pMasterClockSync; // Control back over the master clock timing.
    BOOL                    m_fActive;
    CBufferList             m_BufferList;
    DWORD *                 m_pBusIDs;          // Array of bus ids.
    DWORD *                 m_pFunctionIDs;     // Array of function ids.
    long *                  m_pPBends;          // Array of pitch bends.
    short **                m_ppBusBuffers;     // Array of bus buffers to write into.
	long *					m_plTmpMixBuffer;	// 32-bit stereo array to mix into
    DWORD                   m_dwBusCount;       // Number of buses currently in use.
    IDirectSoundSource *    m_pSynthSource;     // Pointer to synth. Ultimately, we can host a list of these, but this will do for now.
    DWORD                   m_dwBusBufferSize;  // Size of the bus buffers, used to read from the synth.
	bool					m_fStartSampleClock;// Flag to start the sample clock
    CRITICAL_SECTION		m_CriticalSection;	// Critical section to manage access.
    CRITICAL_SECTION		m_csClock;			// Critical section to manage access to clock data
};


#endif // __AUDIO_SINK__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\main\WaveRecordToolbar.h ===
#if !defined(AFX_WAVERECORDTOOLBAR_H__F283E750_097F_11D3_A709_00105A26620B__INCLUDED_)
#define AFX_WAVERECORDTOOLBAR_H__F283E750_097F_11D3_A709_00105A26620B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WaveRecordToolbar.h : header file
//

#include <pshpack1.h>
struct WaveFileHeader
{
	FOURCC			FourCCRiff;		// 'RIFF'
	DWORD			FileLength;		// Riff content length (filesize - 8)
	FOURCC			FourCCWave;		// 'WAVE'
	FOURCC			FourCCFmt;		// 'fmt '
	DWORD			FmtLength;		// Length of format chunk 
	PCMWAVEFORMAT	Fmt;			// Only support render -> PCM wave format
									// (known to obey RIFF alignment requirements)
	FOURCC			FourCCData;		// 'data'
	DWORD			DataLength;		// Length of actual PCM data
};
#include <poppack.h>

/////////////////////////////////////////////////////////////////////////////
// CWaveRecordToolbar window

class CWaveRecordToolbar :
	public CComObjectRoot,
	public CWindowImpl<COptionsToolbarHandler>,
	public IDMUSProdToolBar
{
friend class CConductor;
friend UINT AFX_CDECL NotifyThreadProc( LPVOID pParam );

// Construction
public:
	CWaveRecordToolbar();

// Implementation
public:
	virtual ~CWaveRecordToolbar();

public:
	BEGIN_COM_MAP(CWaveRecordToolbar)
		COM_INTERFACE_ENTRY(IDMUSProdToolBar)
	END_COM_MAP()

	// IDMUSProdToolBar functions
	HRESULT STDMETHODCALLTYPE GetInfo( HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle );
	HRESULT STDMETHODCALLTYPE GetMenuText( BSTR* pbstrText );
	HRESULT STDMETHODCALLTYPE GetMenuHelpText( BSTR* pbstrHelpText );
	HRESULT STDMETHODCALLTYPE Initialize( HWND hWndToolBar );

	// message map
	BEGIN_MSG_MAP(CWaveRecordToolbar)
		COMMAND_HANDLER(ID_WAVE_FILENAME, BN_CLICKED, OnWaveFilenameClicked)
		COMMAND_HANDLER(ID_WAVE_RECORD, BN_CLICKED, OnWaveRecordClicked)
		COMMAND_HANDLER(ID_MIDI_FILENAME, BN_CLICKED, OnMIDIFilenameClicked)
		COMMAND_HANDLER(ID_MIDI_EXPORT, BN_CLICKED, OnMIDIExportClicked)
		MESSAGE_HANDLER(WM_USER + 3, OnSegmentEnd)
#pragma warning ( push )
#pragma warning ( disable : 4244 )
		NOTIFY_CODE_HANDLER(NM_RCLICK, OnRightClick)
#pragma warning ( pop )
	END_MSG_MAP()

	// message handler methods
	LRESULT OnWaveFilenameClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnWaveRecordClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnMIDIFilenameClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnMIDIExportClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnSegmentEnd( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnRightClick( WORD wNotifyCode, NMHDR* pNMHDR, BOOL& bHandled );

	void	StopAll( void );

	void	StartRecording( void );
	void	StopRecording( void );
	HRESULT	StartOrStopDumpDMOs( bool fStart );
	HRESULT	StartOrStopDumpDMOsOnAudiopath( bool fStart, IDirectMusicAudioPath *pAudiopath );
	void	UpdateRecordButtonState( void );

	void	StartExportingMIDI( void );
	void	StopExportingMIDI( void );
	void	UpdateExportMIDIButtonState( void );
	DWORD	GetMaxPChannelNbr( void );
	void	SetTrackNames( void );

	// Base class override methods
//static CWndClassInfo& GetWndClassInfo();

private:
	CFont			m_font;
	HWND			m_hWndToolbar;
	CString			m_strOriginalWaveFilename;
	CStringList		m_lstUsedWaveFilenames;
	BOOL			m_fRecordingWave;
	BOOL			m_fSetWaveFilenameForRecording;
	CStatic			m_staticWaveFilename;

	CStatic			m_staticMIDIFilename;
	CString			m_strMIDIFilename;
	BOOL			m_fExportingMIDI;
};

#endif // !defined(AFX_WAVERECORDTOOLBAR_H__F283E750_097F_11D3_A709_00105A26620B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\cclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

//  clock.h
#ifndef __CCLOCK_H__
#define __CCLOCK_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CDSLink;

class CClock : public IReferenceClock
{
public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
        /* [out] */ REFERENCE_TIME __RPC_FAR *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
        /* [in] */ DWORD dwAdviseCookie);
                CClock();
    void        Init(CDSLink *pDSLink);
    void        Stop();         // Call store current time as offset.
    void        Start();        // Call to reinstate running.
private:
    BOOL        m_fStopped;     // Currently changing configuration.
    CDSLink *	m_pDSLink;      // Pointer to parent DSLink structure.
};

#endif //__CCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\decibels.cpp ===
//--------------------------------------------------------------------------;
//
//  File: decibels.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	FrankYe
//
//--------------------------------------------------------------------------;
#include "stdafx.h"
#include "decibels.h"

#ifndef Not_VxD
#pragma warning(disable:4002)
#undef DPF
#define DPF()
#endif

//
// This table covers -96.4 dB to -0.1 dB in 0.1 dB units
//
DWORD tblDBTenthsToAmpFactor[] = {
    0x0000, // (-964/10)dB = 0.000015 * amplitude
    0x0001, // (-963/10)dB = 0.000015 * amplitude
    0x0001, // (-962/10)dB = 0.000015 * amplitude
    0x0001, // (-961/10)dB = 0.000016 * amplitude
    0x0001, // (-960/10)dB = 0.000016 * amplitude
    0x0001, // (-959/10)dB = 0.000016 * amplitude
    0x0001, // (-958/10)dB = 0.000016 * amplitude
    0x0001, // (-957/10)dB = 0.000016 * amplitude
    0x0001, // (-956/10)dB = 0.000017 * amplitude
    0x0001, // (-955/10)dB = 0.000017 * amplitude
    0x0001, // (-954/10)dB = 0.000017 * amplitude
    0x0001, // (-953/10)dB = 0.000017 * amplitude
    0x0001, // (-952/10)dB = 0.000017 * amplitude
    0x0001, // (-951/10)dB = 0.000018 * amplitude
    0x0001, // (-950/10)dB = 0.000018 * amplitude
    0x0001, // (-949/10)dB = 0.000018 * amplitude
    0x0001, // (-948/10)dB = 0.000018 * amplitude
    0x0001, // (-947/10)dB = 0.000018 * amplitude
    0x0001, // (-946/10)dB = 0.000019 * amplitude
    0x0001, // (-945/10)dB = 0.000019 * amplitude
    0x0001, // (-944/10)dB = 0.000019 * amplitude
    0x0001, // (-943/10)dB = 0.000019 * amplitude
    0x0001, // (-942/10)dB = 0.000019 * amplitude
    0x0001, // (-941/10)dB = 0.000020 * amplitude
    0x0001, // (-940/10)dB = 0.000020 * amplitude
    0x0001, // (-939/10)dB = 0.000020 * amplitude
    0x0001, // (-938/10)dB = 0.000020 * amplitude
    0x0001, // (-937/10)dB = 0.000021 * amplitude
    0x0001, // (-936/10)dB = 0.000021 * amplitude
    0x0001, // (-935/10)dB = 0.000021 * amplitude
    0x0001, // (-934/10)dB = 0.000021 * amplitude
    0x0001, // (-933/10)dB = 0.000022 * amplitude
    0x0001, // (-932/10)dB = 0.000022 * amplitude
    0x0001, // (-931/10)dB = 0.000022 * amplitude
    0x0001, // (-930/10)dB = 0.000022 * amplitude
    0x0001, // (-929/10)dB = 0.000023 * amplitude
    0x0001, // (-928/10)dB = 0.000023 * amplitude
    0x0001, // (-927/10)dB = 0.000023 * amplitude
    0x0001, // (-926/10)dB = 0.000023 * amplitude
    0x0001, // (-925/10)dB = 0.000024 * amplitude
    0x0001, // (-924/10)dB = 0.000024 * amplitude
    0x0001, // (-923/10)dB = 0.000024 * amplitude
    0x0001, // (-922/10)dB = 0.000025 * amplitude
    0x0001, // (-921/10)dB = 0.000025 * amplitude
    0x0001, // (-920/10)dB = 0.000025 * amplitude
    0x0001, // (-919/10)dB = 0.000025 * amplitude
    0x0001, // (-918/10)dB = 0.000026 * amplitude
    0x0001, // (-917/10)dB = 0.000026 * amplitude
    0x0001, // (-916/10)dB = 0.000026 * amplitude
    0x0001, // (-915/10)dB = 0.000027 * amplitude
    0x0001, // (-914/10)dB = 0.000027 * amplitude
    0x0001, // (-913/10)dB = 0.000027 * amplitude
    0x0001, // (-912/10)dB = 0.000028 * amplitude
    0x0001, // (-911/10)dB = 0.000028 * amplitude
    0x0001, // (-910/10)dB = 0.000028 * amplitude
    0x0001, // (-909/10)dB = 0.000029 * amplitude
    0x0001, // (-908/10)dB = 0.000029 * amplitude
    0x0001, // (-907/10)dB = 0.000029 * amplitude
    0x0001, // (-906/10)dB = 0.000030 * amplitude
    0x0001, // (-905/10)dB = 0.000030 * amplitude
    0x0001, // (-904/10)dB = 0.000030 * amplitude
    0x0002, // (-903/10)dB = 0.000031 * amplitude
    0x0002, // (-902/10)dB = 0.000031 * amplitude
    0x0002, // (-901/10)dB = 0.000031 * amplitude
    0x0002, // (-900/10)dB = 0.000032 * amplitude
    0x0002, // (-899/10)dB = 0.000032 * amplitude
    0x0002, // (-898/10)dB = 0.000032 * amplitude
    0x0002, // (-897/10)dB = 0.000033 * amplitude
    0x0002, // (-896/10)dB = 0.000033 * amplitude
    0x0002, // (-895/10)dB = 0.000033 * amplitude
    0x0002, // (-894/10)dB = 0.000034 * amplitude
    0x0002, // (-893/10)dB = 0.000034 * amplitude
    0x0002, // (-892/10)dB = 0.000035 * amplitude
    0x0002, // (-891/10)dB = 0.000035 * amplitude
    0x0002, // (-890/10)dB = 0.000035 * amplitude
    0x0002, // (-889/10)dB = 0.000036 * amplitude
    0x0002, // (-888/10)dB = 0.000036 * amplitude
    0x0002, // (-887/10)dB = 0.000037 * amplitude
    0x0002, // (-886/10)dB = 0.000037 * amplitude
    0x0002, // (-885/10)dB = 0.000038 * amplitude
    0x0002, // (-884/10)dB = 0.000038 * amplitude
    0x0002, // (-883/10)dB = 0.000038 * amplitude
    0x0002, // (-882/10)dB = 0.000039 * amplitude
    0x0002, // (-881/10)dB = 0.000039 * amplitude
    0x0002, // (-880/10)dB = 0.000040 * amplitude
    0x0002, // (-879/10)dB = 0.000040 * amplitude
    0x0002, // (-878/10)dB = 0.000041 * amplitude
    0x0002, // (-877/10)dB = 0.000041 * amplitude
    0x0002, // (-876/10)dB = 0.000042 * amplitude
    0x0002, // (-875/10)dB = 0.000042 * amplitude
    0x0002, // (-874/10)dB = 0.000043 * amplitude
    0x0002, // (-873/10)dB = 0.000043 * amplitude
    0x0002, // (-872/10)dB = 0.000044 * amplitude
    0x0002, // (-871/10)dB = 0.000044 * amplitude
    0x0002, // (-870/10)dB = 0.000045 * amplitude
    0x0002, // (-869/10)dB = 0.000045 * amplitude
    0x0002, // (-868/10)dB = 0.000046 * amplitude
    0x0003, // (-867/10)dB = 0.000046 * amplitude
    0x0003, // (-866/10)dB = 0.000047 * amplitude
    0x0003, // (-865/10)dB = 0.000047 * amplitude
    0x0003, // (-864/10)dB = 0.000048 * amplitude
    0x0003, // (-863/10)dB = 0.000048 * amplitude
    0x0003, // (-862/10)dB = 0.000049 * amplitude
    0x0003, // (-861/10)dB = 0.000050 * amplitude
    0x0003, // (-860/10)dB = 0.000050 * amplitude
    0x0003, // (-859/10)dB = 0.000051 * amplitude
    0x0003, // (-858/10)dB = 0.000051 * amplitude
    0x0003, // (-857/10)dB = 0.000052 * amplitude
    0x0003, // (-856/10)dB = 0.000052 * amplitude
    0x0003, // (-855/10)dB = 0.000053 * amplitude
    0x0003, // (-854/10)dB = 0.000054 * amplitude
    0x0003, // (-853/10)dB = 0.000054 * amplitude
    0x0003, // (-852/10)dB = 0.000055 * amplitude
    0x0003, // (-851/10)dB = 0.000056 * amplitude
    0x0003, // (-850/10)dB = 0.000056 * amplitude
    0x0003, // (-849/10)dB = 0.000057 * amplitude
    0x0003, // (-848/10)dB = 0.000058 * amplitude
    0x0003, // (-847/10)dB = 0.000058 * amplitude
    0x0003, // (-846/10)dB = 0.000059 * amplitude
    0x0003, // (-845/10)dB = 0.000060 * amplitude
    0x0003, // (-844/10)dB = 0.000060 * amplitude
    0x0003, // (-843/10)dB = 0.000061 * amplitude
    0x0004, // (-842/10)dB = 0.000062 * amplitude
    0x0004, // (-841/10)dB = 0.000062 * amplitude
    0x0004, // (-840/10)dB = 0.000063 * amplitude
    0x0004, // (-839/10)dB = 0.000064 * amplitude
    0x0004, // (-838/10)dB = 0.000065 * amplitude
    0x0004, // (-837/10)dB = 0.000065 * amplitude
    0x0004, // (-836/10)dB = 0.000066 * amplitude
    0x0004, // (-835/10)dB = 0.000067 * amplitude
    0x0004, // (-834/10)dB = 0.000068 * amplitude
    0x0004, // (-833/10)dB = 0.000068 * amplitude
    0x0004, // (-832/10)dB = 0.000069 * amplitude
    0x0004, // (-831/10)dB = 0.000070 * amplitude
    0x0004, // (-830/10)dB = 0.000071 * amplitude
    0x0004, // (-829/10)dB = 0.000072 * amplitude
    0x0004, // (-828/10)dB = 0.000072 * amplitude
    0x0004, // (-827/10)dB = 0.000073 * amplitude
    0x0004, // (-826/10)dB = 0.000074 * amplitude
    0x0004, // (-825/10)dB = 0.000075 * amplitude
    0x0004, // (-824/10)dB = 0.000076 * amplitude
    0x0005, // (-823/10)dB = 0.000077 * amplitude
    0x0005, // (-822/10)dB = 0.000078 * amplitude
    0x0005, // (-821/10)dB = 0.000079 * amplitude
    0x0005, // (-820/10)dB = 0.000079 * amplitude
    0x0005, // (-819/10)dB = 0.000080 * amplitude
    0x0005, // (-818/10)dB = 0.000081 * amplitude
    0x0005, // (-817/10)dB = 0.000082 * amplitude
    0x0005, // (-816/10)dB = 0.000083 * amplitude
    0x0005, // (-815/10)dB = 0.000084 * amplitude
    0x0005, // (-814/10)dB = 0.000085 * amplitude
    0x0005, // (-813/10)dB = 0.000086 * amplitude
    0x0005, // (-812/10)dB = 0.000087 * amplitude
    0x0005, // (-811/10)dB = 0.000088 * amplitude
    0x0005, // (-810/10)dB = 0.000089 * amplitude
    0x0005, // (-809/10)dB = 0.000090 * amplitude
    0x0005, // (-808/10)dB = 0.000091 * amplitude
    0x0006, // (-807/10)dB = 0.000092 * amplitude
    0x0006, // (-806/10)dB = 0.000093 * amplitude
    0x0006, // (-805/10)dB = 0.000094 * amplitude
    0x0006, // (-804/10)dB = 0.000095 * amplitude
    0x0006, // (-803/10)dB = 0.000097 * amplitude
    0x0006, // (-802/10)dB = 0.000098 * amplitude
    0x0006, // (-801/10)dB = 0.000099 * amplitude
    0x0006, // (-800/10)dB = 0.000100 * amplitude
    0x0006, // (-799/10)dB = 0.000101 * amplitude
    0x0006, // (-798/10)dB = 0.000102 * amplitude
    0x0006, // (-797/10)dB = 0.000104 * amplitude
    0x0006, // (-796/10)dB = 0.000105 * amplitude
    0x0006, // (-795/10)dB = 0.000106 * amplitude
    0x0007, // (-794/10)dB = 0.000107 * amplitude
    0x0007, // (-793/10)dB = 0.000108 * amplitude
    0x0007, // (-792/10)dB = 0.000110 * amplitude
    0x0007, // (-791/10)dB = 0.000111 * amplitude
    0x0007, // (-790/10)dB = 0.000112 * amplitude
    0x0007, // (-789/10)dB = 0.000114 * amplitude
    0x0007, // (-788/10)dB = 0.000115 * amplitude
    0x0007, // (-787/10)dB = 0.000116 * amplitude
    0x0007, // (-786/10)dB = 0.000117 * amplitude
    0x0007, // (-785/10)dB = 0.000119 * amplitude
    0x0007, // (-784/10)dB = 0.000120 * amplitude
    0x0007, // (-783/10)dB = 0.000122 * amplitude
    0x0008, // (-782/10)dB = 0.000123 * amplitude
    0x0008, // (-781/10)dB = 0.000124 * amplitude
    0x0008, // (-780/10)dB = 0.000126 * amplitude
    0x0008, // (-779/10)dB = 0.000127 * amplitude
    0x0008, // (-778/10)dB = 0.000129 * amplitude
    0x0008, // (-777/10)dB = 0.000130 * amplitude
    0x0008, // (-776/10)dB = 0.000132 * amplitude
    0x0008, // (-775/10)dB = 0.000133 * amplitude
    0x0008, // (-774/10)dB = 0.000135 * amplitude
    0x0008, // (-773/10)dB = 0.000136 * amplitude
    0x0009, // (-772/10)dB = 0.000138 * amplitude
    0x0009, // (-771/10)dB = 0.000140 * amplitude
    0x0009, // (-770/10)dB = 0.000141 * amplitude
    0x0009, // (-769/10)dB = 0.000143 * amplitude
    0x0009, // (-768/10)dB = 0.000145 * amplitude
    0x0009, // (-767/10)dB = 0.000146 * amplitude
    0x0009, // (-766/10)dB = 0.000148 * amplitude
    0x0009, // (-765/10)dB = 0.000150 * amplitude
    0x0009, // (-764/10)dB = 0.000151 * amplitude
    0x000A, // (-763/10)dB = 0.000153 * amplitude
    0x000A, // (-762/10)dB = 0.000155 * amplitude
    0x000A, // (-761/10)dB = 0.000157 * amplitude
    0x000A, // (-760/10)dB = 0.000158 * amplitude
    0x000A, // (-759/10)dB = 0.000160 * amplitude
    0x000A, // (-758/10)dB = 0.000162 * amplitude
    0x000A, // (-757/10)dB = 0.000164 * amplitude
    0x000A, // (-756/10)dB = 0.000166 * amplitude
    0x000B, // (-755/10)dB = 0.000168 * amplitude
    0x000B, // (-754/10)dB = 0.000170 * amplitude
    0x000B, // (-753/10)dB = 0.000172 * amplitude
    0x000B, // (-752/10)dB = 0.000174 * amplitude
    0x000B, // (-751/10)dB = 0.000176 * amplitude
    0x000B, // (-750/10)dB = 0.000178 * amplitude
    0x000B, // (-749/10)dB = 0.000180 * amplitude
    0x000B, // (-748/10)dB = 0.000182 * amplitude
    0x000C, // (-747/10)dB = 0.000184 * amplitude
    0x000C, // (-746/10)dB = 0.000186 * amplitude
    0x000C, // (-745/10)dB = 0.000188 * amplitude
    0x000C, // (-744/10)dB = 0.000191 * amplitude
    0x000C, // (-743/10)dB = 0.000193 * amplitude
    0x000C, // (-742/10)dB = 0.000195 * amplitude
    0x000C, // (-741/10)dB = 0.000197 * amplitude
    0x000D, // (-740/10)dB = 0.000200 * amplitude
    0x000D, // (-739/10)dB = 0.000202 * amplitude
    0x000D, // (-738/10)dB = 0.000204 * amplitude
    0x000D, // (-737/10)dB = 0.000207 * amplitude
    0x000D, // (-736/10)dB = 0.000209 * amplitude
    0x000D, // (-735/10)dB = 0.000211 * amplitude
    0x000E, // (-734/10)dB = 0.000214 * amplitude
    0x000E, // (-733/10)dB = 0.000216 * amplitude
    0x000E, // (-732/10)dB = 0.000219 * amplitude
    0x000E, // (-731/10)dB = 0.000221 * amplitude
    0x000E, // (-730/10)dB = 0.000224 * amplitude
    0x000E, // (-729/10)dB = 0.000226 * amplitude
    0x000F, // (-728/10)dB = 0.000229 * amplitude
    0x000F, // (-727/10)dB = 0.000232 * amplitude
    0x000F, // (-726/10)dB = 0.000234 * amplitude
    0x000F, // (-725/10)dB = 0.000237 * amplitude
    0x000F, // (-724/10)dB = 0.000240 * amplitude
    0x000F, // (-723/10)dB = 0.000243 * amplitude
    0x0010, // (-722/10)dB = 0.000245 * amplitude
    0x0010, // (-721/10)dB = 0.000248 * amplitude
    0x0010, // (-720/10)dB = 0.000251 * amplitude
    0x0010, // (-719/10)dB = 0.000254 * amplitude
    0x0010, // (-718/10)dB = 0.000257 * amplitude
    0x0011, // (-717/10)dB = 0.000260 * amplitude
    0x0011, // (-716/10)dB = 0.000263 * amplitude
    0x0011, // (-715/10)dB = 0.000266 * amplitude
    0x0011, // (-714/10)dB = 0.000269 * amplitude
    0x0011, // (-713/10)dB = 0.000272 * amplitude
    0x0012, // (-712/10)dB = 0.000275 * amplitude
    0x0012, // (-711/10)dB = 0.000279 * amplitude
    0x0012, // (-710/10)dB = 0.000282 * amplitude
    0x0012, // (-709/10)dB = 0.000285 * amplitude
    0x0012, // (-708/10)dB = 0.000288 * amplitude
    0x0013, // (-707/10)dB = 0.000292 * amplitude
    0x0013, // (-706/10)dB = 0.000295 * amplitude
    0x0013, // (-705/10)dB = 0.000299 * amplitude
    0x0013, // (-704/10)dB = 0.000302 * amplitude
    0x0014, // (-703/10)dB = 0.000305 * amplitude
    0x0014, // (-702/10)dB = 0.000309 * amplitude
    0x0014, // (-701/10)dB = 0.000313 * amplitude
    0x0014, // (-700/10)dB = 0.000316 * amplitude
    0x0014, // (-699/10)dB = 0.000320 * amplitude
    0x0015, // (-698/10)dB = 0.000324 * amplitude
    0x0015, // (-697/10)dB = 0.000327 * amplitude
    0x0015, // (-696/10)dB = 0.000331 * amplitude
    0x0015, // (-695/10)dB = 0.000335 * amplitude
    0x0016, // (-694/10)dB = 0.000339 * amplitude
    0x0016, // (-693/10)dB = 0.000343 * amplitude
    0x0016, // (-692/10)dB = 0.000347 * amplitude
    0x0016, // (-691/10)dB = 0.000351 * amplitude
    0x0017, // (-690/10)dB = 0.000355 * amplitude
    0x0017, // (-689/10)dB = 0.000359 * amplitude
    0x0017, // (-688/10)dB = 0.000363 * amplitude
    0x0018, // (-687/10)dB = 0.000367 * amplitude
    0x0018, // (-686/10)dB = 0.000372 * amplitude
    0x0018, // (-685/10)dB = 0.000376 * amplitude
    0x0018, // (-684/10)dB = 0.000380 * amplitude
    0x0019, // (-683/10)dB = 0.000385 * amplitude
    0x0019, // (-682/10)dB = 0.000389 * amplitude
    0x0019, // (-681/10)dB = 0.000394 * amplitude
    0x001A, // (-680/10)dB = 0.000398 * amplitude
    0x001A, // (-679/10)dB = 0.000403 * amplitude
    0x001A, // (-678/10)dB = 0.000407 * amplitude
    0x001B, // (-677/10)dB = 0.000412 * amplitude
    0x001B, // (-676/10)dB = 0.000417 * amplitude
    0x001B, // (-675/10)dB = 0.000422 * amplitude
    0x001B, // (-674/10)dB = 0.000427 * amplitude
    0x001C, // (-673/10)dB = 0.000432 * amplitude
    0x001C, // (-672/10)dB = 0.000437 * amplitude
    0x001C, // (-671/10)dB = 0.000442 * amplitude
    0x001D, // (-670/10)dB = 0.000447 * amplitude
    0x001D, // (-669/10)dB = 0.000452 * amplitude
    0x001D, // (-668/10)dB = 0.000457 * amplitude
    0x001E, // (-667/10)dB = 0.000462 * amplitude
    0x001E, // (-666/10)dB = 0.000468 * amplitude
    0x001F, // (-665/10)dB = 0.000473 * amplitude
    0x001F, // (-664/10)dB = 0.000479 * amplitude
    0x001F, // (-663/10)dB = 0.000484 * amplitude
    0x0020, // (-662/10)dB = 0.000490 * amplitude
    0x0020, // (-661/10)dB = 0.000495 * amplitude
    0x0020, // (-660/10)dB = 0.000501 * amplitude
    0x0021, // (-659/10)dB = 0.000507 * amplitude
    0x0021, // (-658/10)dB = 0.000513 * amplitude
    0x0022, // (-657/10)dB = 0.000519 * amplitude
    0x0022, // (-656/10)dB = 0.000525 * amplitude
    0x0022, // (-655/10)dB = 0.000531 * amplitude
    0x0023, // (-654/10)dB = 0.000537 * amplitude
    0x0023, // (-653/10)dB = 0.000543 * amplitude
    0x0024, // (-652/10)dB = 0.000550 * amplitude
    0x0024, // (-651/10)dB = 0.000556 * amplitude
    0x0024, // (-650/10)dB = 0.000562 * amplitude
    0x0025, // (-649/10)dB = 0.000569 * amplitude
    0x0025, // (-648/10)dB = 0.000575 * amplitude
    0x0026, // (-647/10)dB = 0.000582 * amplitude
    0x0026, // (-646/10)dB = 0.000589 * amplitude
    0x0027, // (-645/10)dB = 0.000596 * amplitude
    0x0027, // (-644/10)dB = 0.000603 * amplitude
    0x0027, // (-643/10)dB = 0.000610 * amplitude
    0x0028, // (-642/10)dB = 0.000617 * amplitude
    0x0028, // (-641/10)dB = 0.000624 * amplitude
    0x0029, // (-640/10)dB = 0.000631 * amplitude
    0x0029, // (-639/10)dB = 0.000638 * amplitude
    0x002A, // (-638/10)dB = 0.000646 * amplitude
    0x002A, // (-637/10)dB = 0.000653 * amplitude
    0x002B, // (-636/10)dB = 0.000661 * amplitude
    0x002B, // (-635/10)dB = 0.000668 * amplitude
    0x002C, // (-634/10)dB = 0.000676 * amplitude
    0x002C, // (-633/10)dB = 0.000684 * amplitude
    0x002D, // (-632/10)dB = 0.000692 * amplitude
    0x002D, // (-631/10)dB = 0.000700 * amplitude
    0x002E, // (-630/10)dB = 0.000708 * amplitude
    0x002E, // (-629/10)dB = 0.000716 * amplitude
    0x002F, // (-628/10)dB = 0.000724 * amplitude
    0x0030, // (-627/10)dB = 0.000733 * amplitude
    0x0030, // (-626/10)dB = 0.000741 * amplitude
    0x0031, // (-625/10)dB = 0.000750 * amplitude
    0x0031, // (-624/10)dB = 0.000759 * amplitude
    0x0032, // (-623/10)dB = 0.000767 * amplitude
    0x0032, // (-622/10)dB = 0.000776 * amplitude
    0x0033, // (-621/10)dB = 0.000785 * amplitude
    0x0034, // (-620/10)dB = 0.000794 * amplitude
    0x0034, // (-619/10)dB = 0.000804 * amplitude
    0x0035, // (-618/10)dB = 0.000813 * amplitude
    0x0035, // (-617/10)dB = 0.000822 * amplitude
    0x0036, // (-616/10)dB = 0.000832 * amplitude
    0x0037, // (-615/10)dB = 0.000841 * amplitude
    0x0037, // (-614/10)dB = 0.000851 * amplitude
    0x0038, // (-613/10)dB = 0.000861 * amplitude
    0x0039, // (-612/10)dB = 0.000871 * amplitude
    0x0039, // (-611/10)dB = 0.000881 * amplitude
    0x003A, // (-610/10)dB = 0.000891 * amplitude
    0x003B, // (-609/10)dB = 0.000902 * amplitude
    0x003B, // (-608/10)dB = 0.000912 * amplitude
    0x003C, // (-607/10)dB = 0.000923 * amplitude
    0x003D, // (-606/10)dB = 0.000933 * amplitude
    0x003D, // (-605/10)dB = 0.000944 * amplitude
    0x003E, // (-604/10)dB = 0.000955 * amplitude
    0x003F, // (-603/10)dB = 0.000966 * amplitude
    0x0040, // (-602/10)dB = 0.000977 * amplitude
    0x0040, // (-601/10)dB = 0.000989 * amplitude
    0x0041, // (-600/10)dB = 0.001000 * amplitude
    0x0042, // (-599/10)dB = 0.001012 * amplitude
    0x0043, // (-598/10)dB = 0.001023 * amplitude
    0x0043, // (-597/10)dB = 0.001035 * amplitude
    0x0044, // (-596/10)dB = 0.001047 * amplitude
    0x0045, // (-595/10)dB = 0.001059 * amplitude
    0x0046, // (-594/10)dB = 0.001072 * amplitude
    0x0047, // (-593/10)dB = 0.001084 * amplitude
    0x0047, // (-592/10)dB = 0.001096 * amplitude
    0x0048, // (-591/10)dB = 0.001109 * amplitude
    0x0049, // (-590/10)dB = 0.001122 * amplitude
    0x004A, // (-589/10)dB = 0.001135 * amplitude
    0x004B, // (-588/10)dB = 0.001148 * amplitude
    0x004C, // (-587/10)dB = 0.001161 * amplitude
    0x004C, // (-586/10)dB = 0.001175 * amplitude
    0x004D, // (-585/10)dB = 0.001189 * amplitude
    0x004E, // (-584/10)dB = 0.001202 * amplitude
    0x004F, // (-583/10)dB = 0.001216 * amplitude
    0x0050, // (-582/10)dB = 0.001230 * amplitude
    0x0051, // (-581/10)dB = 0.001245 * amplitude
    0x0052, // (-580/10)dB = 0.001259 * amplitude
    0x0053, // (-579/10)dB = 0.001274 * amplitude
    0x0054, // (-578/10)dB = 0.001288 * amplitude
    0x0055, // (-577/10)dB = 0.001303 * amplitude
    0x0056, // (-576/10)dB = 0.001318 * amplitude
    0x0057, // (-575/10)dB = 0.001334 * amplitude
    0x0058, // (-574/10)dB = 0.001349 * amplitude
    0x0059, // (-573/10)dB = 0.001365 * amplitude
    0x005A, // (-572/10)dB = 0.001380 * amplitude
    0x005B, // (-571/10)dB = 0.001396 * amplitude
    0x005C, // (-570/10)dB = 0.001413 * amplitude
    0x005D, // (-569/10)dB = 0.001429 * amplitude
    0x005E, // (-568/10)dB = 0.001445 * amplitude
    0x005F, // (-567/10)dB = 0.001462 * amplitude
    0x0060, // (-566/10)dB = 0.001479 * amplitude
    0x0062, // (-565/10)dB = 0.001496 * amplitude
    0x0063, // (-564/10)dB = 0.001514 * amplitude
    0x0064, // (-563/10)dB = 0.001531 * amplitude
    0x0065, // (-562/10)dB = 0.001549 * amplitude
    0x0066, // (-561/10)dB = 0.001567 * amplitude
    0x0067, // (-560/10)dB = 0.001585 * amplitude
    0x0069, // (-559/10)dB = 0.001603 * amplitude
    0x006A, // (-558/10)dB = 0.001622 * amplitude
    0x006B, // (-557/10)dB = 0.001641 * amplitude
    0x006C, // (-556/10)dB = 0.001660 * amplitude
    0x006E, // (-555/10)dB = 0.001679 * amplitude
    0x006F, // (-554/10)dB = 0.001698 * amplitude
    0x0070, // (-553/10)dB = 0.001718 * amplitude
    0x0071, // (-552/10)dB = 0.001738 * amplitude
    0x0073, // (-551/10)dB = 0.001758 * amplitude
    0x0074, // (-550/10)dB = 0.001778 * amplitude
    0x0075, // (-549/10)dB = 0.001799 * amplitude
    0x0077, // (-548/10)dB = 0.001820 * amplitude
    0x0078, // (-547/10)dB = 0.001841 * amplitude
    0x007A, // (-546/10)dB = 0.001862 * amplitude
    0x007B, // (-545/10)dB = 0.001884 * amplitude
    0x007C, // (-544/10)dB = 0.001905 * amplitude
    0x007E, // (-543/10)dB = 0.001928 * amplitude
    0x007F, // (-542/10)dB = 0.001950 * amplitude
    0x0081, // (-541/10)dB = 0.001972 * amplitude
    0x0082, // (-540/10)dB = 0.001995 * amplitude
    0x0084, // (-539/10)dB = 0.002018 * amplitude
    0x0085, // (-538/10)dB = 0.002042 * amplitude
    0x0087, // (-537/10)dB = 0.002065 * amplitude
    0x0088, // (-536/10)dB = 0.002089 * amplitude
    0x008A, // (-535/10)dB = 0.002113 * amplitude
    0x008C, // (-534/10)dB = 0.002138 * amplitude
    0x008D, // (-533/10)dB = 0.002163 * amplitude
    0x008F, // (-532/10)dB = 0.002188 * amplitude
    0x0091, // (-531/10)dB = 0.002213 * amplitude
    0x0092, // (-530/10)dB = 0.002239 * amplitude
    0x0094, // (-529/10)dB = 0.002265 * amplitude
    0x0096, // (-528/10)dB = 0.002291 * amplitude
    0x0097, // (-527/10)dB = 0.002317 * amplitude
    0x0099, // (-526/10)dB = 0.002344 * amplitude
    0x009B, // (-525/10)dB = 0.002371 * amplitude
    0x009D, // (-524/10)dB = 0.002399 * amplitude
    0x009F, // (-523/10)dB = 0.002427 * amplitude
    0x00A0, // (-522/10)dB = 0.002455 * amplitude
    0x00A2, // (-521/10)dB = 0.002483 * amplitude
    0x00A4, // (-520/10)dB = 0.002512 * amplitude
    0x00A6, // (-519/10)dB = 0.002541 * amplitude
    0x00A8, // (-518/10)dB = 0.002570 * amplitude
    0x00AA, // (-517/10)dB = 0.002600 * amplitude
    0x00AC, // (-516/10)dB = 0.002630 * amplitude
    0x00AE, // (-515/10)dB = 0.002661 * amplitude
    0x00B0, // (-514/10)dB = 0.002692 * amplitude
    0x00B2, // (-513/10)dB = 0.002723 * amplitude
    0x00B4, // (-512/10)dB = 0.002754 * amplitude
    0x00B6, // (-511/10)dB = 0.002786 * amplitude
    0x00B8, // (-510/10)dB = 0.002818 * amplitude
    0x00BA, // (-509/10)dB = 0.002851 * amplitude
    0x00BD, // (-508/10)dB = 0.002884 * amplitude
    0x00BF, // (-507/10)dB = 0.002917 * amplitude
    0x00C1, // (-506/10)dB = 0.002951 * amplitude
    0x00C3, // (-505/10)dB = 0.002985 * amplitude
    0x00C5, // (-504/10)dB = 0.003020 * amplitude
    0x00C8, // (-503/10)dB = 0.003055 * amplitude
    0x00CA, // (-502/10)dB = 0.003090 * amplitude
    0x00CC, // (-501/10)dB = 0.003126 * amplitude
    0x00CF, // (-500/10)dB = 0.003162 * amplitude
    0x00D1, // (-499/10)dB = 0.003199 * amplitude
    0x00D4, // (-498/10)dB = 0.003236 * amplitude
    0x00D6, // (-497/10)dB = 0.003273 * amplitude
    0x00D9, // (-496/10)dB = 0.003311 * amplitude
    0x00DB, // (-495/10)dB = 0.003350 * amplitude
    0x00DE, // (-494/10)dB = 0.003388 * amplitude
    0x00E0, // (-493/10)dB = 0.003428 * amplitude
    0x00E3, // (-492/10)dB = 0.003467 * amplitude
    0x00E5, // (-491/10)dB = 0.003508 * amplitude
    0x00E8, // (-490/10)dB = 0.003548 * amplitude
    0x00EB, // (-489/10)dB = 0.003589 * amplitude
    0x00ED, // (-488/10)dB = 0.003631 * amplitude
    0x00F0, // (-487/10)dB = 0.003673 * amplitude
    0x00F3, // (-486/10)dB = 0.003715 * amplitude
    0x00F6, // (-485/10)dB = 0.003758 * amplitude
    0x00F9, // (-484/10)dB = 0.003802 * amplitude
    0x00FC, // (-483/10)dB = 0.003846 * amplitude
    0x00FE, // (-482/10)dB = 0.003890 * amplitude
    0x0101, // (-481/10)dB = 0.003936 * amplitude
    0x0104, // (-480/10)dB = 0.003981 * amplitude
    0x0107, // (-479/10)dB = 0.004027 * amplitude
    0x010A, // (-478/10)dB = 0.004074 * amplitude
    0x010E, // (-477/10)dB = 0.004121 * amplitude
    0x0111, // (-476/10)dB = 0.004169 * amplitude
    0x0114, // (-475/10)dB = 0.004217 * amplitude
    0x0117, // (-474/10)dB = 0.004266 * amplitude
    0x011A, // (-473/10)dB = 0.004315 * amplitude
    0x011E, // (-472/10)dB = 0.004365 * amplitude
    0x0121, // (-471/10)dB = 0.004416 * amplitude
    0x0124, // (-470/10)dB = 0.004467 * amplitude
    0x0128, // (-469/10)dB = 0.004519 * amplitude
    0x012B, // (-468/10)dB = 0.004571 * amplitude
    0x012F, // (-467/10)dB = 0.004624 * amplitude
    0x0132, // (-466/10)dB = 0.004677 * amplitude
    0x0136, // (-465/10)dB = 0.004732 * amplitude
    0x0139, // (-464/10)dB = 0.004786 * amplitude
    0x013D, // (-463/10)dB = 0.004842 * amplitude
    0x0140, // (-462/10)dB = 0.004898 * amplitude
    0x0144, // (-461/10)dB = 0.004955 * amplitude
    0x0148, // (-460/10)dB = 0.005012 * amplitude
    0x014C, // (-459/10)dB = 0.005070 * amplitude
    0x0150, // (-458/10)dB = 0.005129 * amplitude
    0x0154, // (-457/10)dB = 0.005188 * amplitude
    0x0157, // (-456/10)dB = 0.005248 * amplitude
    0x015B, // (-455/10)dB = 0.005309 * amplitude
    0x015F, // (-454/10)dB = 0.005370 * amplitude
    0x0164, // (-453/10)dB = 0.005433 * amplitude
    0x0168, // (-452/10)dB = 0.005495 * amplitude
    0x016C, // (-451/10)dB = 0.005559 * amplitude
    0x0170, // (-450/10)dB = 0.005623 * amplitude
    0x0174, // (-449/10)dB = 0.005689 * amplitude
    0x0179, // (-448/10)dB = 0.005754 * amplitude
    0x017D, // (-447/10)dB = 0.005821 * amplitude
    0x0181, // (-446/10)dB = 0.005888 * amplitude
    0x0186, // (-445/10)dB = 0.005957 * amplitude
    0x018A, // (-444/10)dB = 0.006026 * amplitude
    0x018F, // (-443/10)dB = 0.006095 * amplitude
    0x0194, // (-442/10)dB = 0.006166 * amplitude
    0x0198, // (-441/10)dB = 0.006237 * amplitude
    0x019D, // (-440/10)dB = 0.006310 * amplitude
    0x01A2, // (-439/10)dB = 0.006383 * amplitude
    0x01A7, // (-438/10)dB = 0.006457 * amplitude
    0x01AC, // (-437/10)dB = 0.006531 * amplitude
    0x01B0, // (-436/10)dB = 0.006607 * amplitude
    0x01B6, // (-435/10)dB = 0.006683 * amplitude
    0x01BB, // (-434/10)dB = 0.006761 * amplitude
    0x01C0, // (-433/10)dB = 0.006839 * amplitude
    0x01C5, // (-432/10)dB = 0.006918 * amplitude
    0x01CA, // (-431/10)dB = 0.006998 * amplitude
    0x01CF, // (-430/10)dB = 0.007079 * amplitude
    0x01D5, // (-429/10)dB = 0.007161 * amplitude
    0x01DA, // (-428/10)dB = 0.007244 * amplitude
    0x01E0, // (-427/10)dB = 0.007328 * amplitude
    0x01E5, // (-426/10)dB = 0.007413 * amplitude
    0x01EB, // (-425/10)dB = 0.007499 * amplitude
    0x01F1, // (-424/10)dB = 0.007586 * amplitude
    0x01F6, // (-423/10)dB = 0.007674 * amplitude
    0x01FC, // (-422/10)dB = 0.007762 * amplitude
    0x0202, // (-421/10)dB = 0.007852 * amplitude
    0x0208, // (-420/10)dB = 0.007943 * amplitude
    0x020E, // (-419/10)dB = 0.008035 * amplitude
    0x0214, // (-418/10)dB = 0.008128 * amplitude
    0x021A, // (-417/10)dB = 0.008222 * amplitude
    0x0221, // (-416/10)dB = 0.008318 * amplitude
    0x0227, // (-415/10)dB = 0.008414 * amplitude
    0x022D, // (-414/10)dB = 0.008511 * amplitude
    0x0234, // (-413/10)dB = 0.008610 * amplitude
    0x023A, // (-412/10)dB = 0.008710 * amplitude
    0x0241, // (-411/10)dB = 0.008810 * amplitude
    0x0248, // (-410/10)dB = 0.008913 * amplitude
    0x024E, // (-409/10)dB = 0.009016 * amplitude
    0x0255, // (-408/10)dB = 0.009120 * amplitude
    0x025C, // (-407/10)dB = 0.009226 * amplitude
    0x0263, // (-406/10)dB = 0.009333 * amplitude
    0x026A, // (-405/10)dB = 0.009441 * amplitude
    0x0271, // (-404/10)dB = 0.009550 * amplitude
    0x0279, // (-403/10)dB = 0.009661 * amplitude
    0x0280, // (-402/10)dB = 0.009772 * amplitude
    0x0287, // (-401/10)dB = 0.009886 * amplitude
    0x028F, // (-400/10)dB = 0.010000 * amplitude
    0x0296, // (-399/10)dB = 0.010116 * amplitude
    0x029E, // (-398/10)dB = 0.010233 * amplitude
    0x02A6, // (-397/10)dB = 0.010351 * amplitude
    0x02AE, // (-396/10)dB = 0.010471 * amplitude
    0x02B6, // (-395/10)dB = 0.010593 * amplitude
    0x02BE, // (-394/10)dB = 0.010715 * amplitude
    0x02C6, // (-393/10)dB = 0.010839 * amplitude
    0x02CE, // (-392/10)dB = 0.010965 * amplitude
    0x02D6, // (-391/10)dB = 0.011092 * amplitude
    0x02DF, // (-390/10)dB = 0.011220 * amplitude
    0x02E7, // (-389/10)dB = 0.011350 * amplitude
    0x02F0, // (-388/10)dB = 0.011482 * amplitude
    0x02F9, // (-387/10)dB = 0.011614 * amplitude
    0x0301, // (-386/10)dB = 0.011749 * amplitude
    0x030A, // (-385/10)dB = 0.011885 * amplitude
    0x0313, // (-384/10)dB = 0.012023 * amplitude
    0x031D, // (-383/10)dB = 0.012162 * amplitude
    0x0326, // (-382/10)dB = 0.012303 * amplitude
    0x032F, // (-381/10)dB = 0.012445 * amplitude
    0x0339, // (-380/10)dB = 0.012589 * amplitude
    0x0342, // (-379/10)dB = 0.012735 * amplitude
    0x034C, // (-378/10)dB = 0.012882 * amplitude
    0x0356, // (-377/10)dB = 0.013032 * amplitude
    0x035F, // (-376/10)dB = 0.013183 * amplitude
    0x0369, // (-375/10)dB = 0.013335 * amplitude
    0x0374, // (-374/10)dB = 0.013490 * amplitude
    0x037E, // (-373/10)dB = 0.013646 * amplitude
    0x0388, // (-372/10)dB = 0.013804 * amplitude
    0x0393, // (-371/10)dB = 0.013964 * amplitude
    0x039D, // (-370/10)dB = 0.014125 * amplitude
    0x03A8, // (-369/10)dB = 0.014289 * amplitude
    0x03B3, // (-368/10)dB = 0.014454 * amplitude
    0x03BE, // (-367/10)dB = 0.014622 * amplitude
    0x03C9, // (-366/10)dB = 0.014791 * amplitude
    0x03D4, // (-365/10)dB = 0.014962 * amplitude
    0x03DF, // (-364/10)dB = 0.015136 * amplitude
    0x03EB, // (-363/10)dB = 0.015311 * amplitude
    0x03F7, // (-362/10)dB = 0.015488 * amplitude
    0x0402, // (-361/10)dB = 0.015668 * amplitude
    0x040E, // (-360/10)dB = 0.015849 * amplitude
    0x041A, // (-359/10)dB = 0.016032 * amplitude
    0x0426, // (-358/10)dB = 0.016218 * amplitude
    0x0433, // (-357/10)dB = 0.016406 * amplitude
    0x043F, // (-356/10)dB = 0.016596 * amplitude
    0x044C, // (-355/10)dB = 0.016788 * amplitude
    0x0458, // (-354/10)dB = 0.016982 * amplitude
    0x0465, // (-353/10)dB = 0.017179 * amplitude
    0x0472, // (-352/10)dB = 0.017378 * amplitude
    0x0480, // (-351/10)dB = 0.017579 * amplitude
    0x048D, // (-350/10)dB = 0.017783 * amplitude
    0x049A, // (-349/10)dB = 0.017989 * amplitude
    0x04A8, // (-348/10)dB = 0.018197 * amplitude
    0x04B6, // (-347/10)dB = 0.018408 * amplitude
    0x04C4, // (-346/10)dB = 0.018621 * amplitude
    0x04D2, // (-345/10)dB = 0.018836 * amplitude
    0x04E0, // (-344/10)dB = 0.019055 * amplitude
    0x04EF, // (-343/10)dB = 0.019275 * amplitude
    0x04FD, // (-342/10)dB = 0.019498 * amplitude
    0x050C, // (-341/10)dB = 0.019724 * amplitude
    0x051B, // (-340/10)dB = 0.019953 * amplitude
    0x052A, // (-339/10)dB = 0.020184 * amplitude
    0x053A, // (-338/10)dB = 0.020417 * amplitude
    0x0549, // (-337/10)dB = 0.020654 * amplitude
    0x0559, // (-336/10)dB = 0.020893 * amplitude
    0x0569, // (-335/10)dB = 0.021135 * amplitude
    0x0579, // (-334/10)dB = 0.021380 * amplitude
    0x0589, // (-333/10)dB = 0.021627 * amplitude
    0x0599, // (-332/10)dB = 0.021878 * amplitude
    0x05AA, // (-331/10)dB = 0.022131 * amplitude
    0x05BB, // (-330/10)dB = 0.022387 * amplitude
    0x05CC, // (-329/10)dB = 0.022646 * amplitude
    0x05DD, // (-328/10)dB = 0.022909 * amplitude
    0x05EE, // (-327/10)dB = 0.023174 * amplitude
    0x0600, // (-326/10)dB = 0.023442 * amplitude
    0x0612, // (-325/10)dB = 0.023714 * amplitude
    0x0624, // (-324/10)dB = 0.023988 * amplitude
    0x0636, // (-323/10)dB = 0.024266 * amplitude
    0x0648, // (-322/10)dB = 0.024547 * amplitude
    0x065B, // (-321/10)dB = 0.024831 * amplitude
    0x066E, // (-320/10)dB = 0.025119 * amplitude
    0x0681, // (-319/10)dB = 0.025410 * amplitude
    0x0694, // (-318/10)dB = 0.025704 * amplitude
    0x06A8, // (-317/10)dB = 0.026002 * amplitude
    0x06BB, // (-316/10)dB = 0.026303 * amplitude
    0x06CF, // (-315/10)dB = 0.026607 * amplitude
    0x06E3, // (-314/10)dB = 0.026915 * amplitude
    0x06F8, // (-313/10)dB = 0.027227 * amplitude
    0x070D, // (-312/10)dB = 0.027542 * amplitude
    0x0721, // (-311/10)dB = 0.027861 * amplitude
    0x0737, // (-310/10)dB = 0.028184 * amplitude
    0x074C, // (-309/10)dB = 0.028510 * amplitude
    0x0762, // (-308/10)dB = 0.028840 * amplitude
    0x0777, // (-307/10)dB = 0.029174 * amplitude
    0x078E, // (-306/10)dB = 0.029512 * amplitude
    0x07A4, // (-305/10)dB = 0.029854 * amplitude
    0x07BB, // (-304/10)dB = 0.030200 * amplitude
    0x07D2, // (-303/10)dB = 0.030549 * amplitude
    0x07E9, // (-302/10)dB = 0.030903 * amplitude
    0x0800, // (-301/10)dB = 0.031261 * amplitude
    0x0818, // (-300/10)dB = 0.031623 * amplitude
    0x0830, // (-299/10)dB = 0.031989 * amplitude
    0x0848, // (-298/10)dB = 0.032359 * amplitude
    0x0861, // (-297/10)dB = 0.032734 * amplitude
    0x087A, // (-296/10)dB = 0.033113 * amplitude
    0x0893, // (-295/10)dB = 0.033497 * amplitude
    0x08AC, // (-294/10)dB = 0.033884 * amplitude
    0x08C6, // (-293/10)dB = 0.034277 * amplitude
    0x08E0, // (-292/10)dB = 0.034674 * amplitude
    0x08FA, // (-291/10)dB = 0.035075 * amplitude
    0x0915, // (-290/10)dB = 0.035481 * amplitude
    0x0930, // (-289/10)dB = 0.035892 * amplitude
    0x094B, // (-288/10)dB = 0.036308 * amplitude
    0x0967, // (-287/10)dB = 0.036728 * amplitude
    0x0982, // (-286/10)dB = 0.037154 * amplitude
    0x099F, // (-285/10)dB = 0.037584 * amplitude
    0x09BB, // (-284/10)dB = 0.038019 * amplitude
    0x09D8, // (-283/10)dB = 0.038459 * amplitude
    0x09F5, // (-282/10)dB = 0.038905 * amplitude
    0x0A13, // (-281/10)dB = 0.039355 * amplitude
    0x0A31, // (-280/10)dB = 0.039811 * amplitude
    0x0A4F, // (-279/10)dB = 0.040272 * amplitude
    0x0A6D, // (-278/10)dB = 0.040738 * amplitude
    0x0A8C, // (-277/10)dB = 0.041210 * amplitude
    0x0AAB, // (-276/10)dB = 0.041687 * amplitude
    0x0ACB, // (-275/10)dB = 0.042170 * amplitude
    0x0AEB, // (-274/10)dB = 0.042658 * amplitude
    0x0B0C, // (-273/10)dB = 0.043152 * amplitude
    0x0B2C, // (-272/10)dB = 0.043652 * amplitude
    0x0B4D, // (-271/10)dB = 0.044157 * amplitude
    0x0B6F, // (-270/10)dB = 0.044668 * amplitude
    0x0B91, // (-269/10)dB = 0.045186 * amplitude
    0x0BB3, // (-268/10)dB = 0.045709 * amplitude
    0x0BD6, // (-267/10)dB = 0.046238 * amplitude
    0x0BF9, // (-266/10)dB = 0.046774 * amplitude
    0x0C1C, // (-265/10)dB = 0.047315 * amplitude
    0x0C40, // (-264/10)dB = 0.047863 * amplitude
    0x0C65, // (-263/10)dB = 0.048417 * amplitude
    0x0C89, // (-262/10)dB = 0.048978 * amplitude
    0x0CAE, // (-261/10)dB = 0.049545 * amplitude
    0x0CD4, // (-260/10)dB = 0.050119 * amplitude
    0x0CFA, // (-259/10)dB = 0.050699 * amplitude
    0x0D21, // (-258/10)dB = 0.051286 * amplitude
    0x0D48, // (-257/10)dB = 0.051880 * amplitude
    0x0D6F, // (-256/10)dB = 0.052481 * amplitude
    0x0D97, // (-255/10)dB = 0.053088 * amplitude
    0x0DBF, // (-254/10)dB = 0.053703 * amplitude
    0x0DE8, // (-253/10)dB = 0.054325 * amplitude
    0x0E11, // (-252/10)dB = 0.054954 * amplitude
    0x0E3B, // (-251/10)dB = 0.055590 * amplitude
    0x0E65, // (-250/10)dB = 0.056234 * amplitude
    0x0E90, // (-249/10)dB = 0.056885 * amplitude
    0x0EBB, // (-248/10)dB = 0.057544 * amplitude
    0x0EE6, // (-247/10)dB = 0.058210 * amplitude
    0x0F13, // (-246/10)dB = 0.058884 * amplitude
    0x0F3F, // (-245/10)dB = 0.059566 * amplitude
    0x0F6C, // (-244/10)dB = 0.060256 * amplitude
    0x0F9A, // (-243/10)dB = 0.060954 * amplitude
    0x0FC8, // (-242/10)dB = 0.061660 * amplitude
    0x0FF7, // (-241/10)dB = 0.062373 * amplitude
    0x1027, // (-240/10)dB = 0.063096 * amplitude
    0x1056, // (-239/10)dB = 0.063826 * amplitude
    0x1087, // (-238/10)dB = 0.064565 * amplitude
    0x10B8, // (-237/10)dB = 0.065313 * amplitude
    0x10E9, // (-236/10)dB = 0.066069 * amplitude
    0x111C, // (-235/10)dB = 0.066834 * amplitude
    0x114E, // (-234/10)dB = 0.067608 * amplitude
    0x1182, // (-233/10)dB = 0.068391 * amplitude
    0x11B5, // (-232/10)dB = 0.069183 * amplitude
    0x11EA, // (-231/10)dB = 0.069984 * amplitude
    0x121F, // (-230/10)dB = 0.070795 * amplitude
    0x1255, // (-229/10)dB = 0.071614 * amplitude
    0x128B, // (-228/10)dB = 0.072444 * amplitude
    0x12C2, // (-227/10)dB = 0.073282 * amplitude
    0x12FA, // (-226/10)dB = 0.074131 * amplitude
    0x1332, // (-225/10)dB = 0.074989 * amplitude
    0x136B, // (-224/10)dB = 0.075858 * amplitude
    0x13A4, // (-223/10)dB = 0.076736 * amplitude
    0x13DF, // (-222/10)dB = 0.077625 * amplitude
    0x141A, // (-221/10)dB = 0.078524 * amplitude
    0x1455, // (-220/10)dB = 0.079433 * amplitude
    0x1491, // (-219/10)dB = 0.080353 * amplitude
    0x14CE, // (-218/10)dB = 0.081283 * amplitude
    0x150C, // (-217/10)dB = 0.082224 * amplitude
    0x154B, // (-216/10)dB = 0.083176 * amplitude
    0x158A, // (-215/10)dB = 0.084140 * amplitude
    0x15CA, // (-214/10)dB = 0.085114 * amplitude
    0x160A, // (-213/10)dB = 0.086099 * amplitude
    0x164B, // (-212/10)dB = 0.087096 * amplitude
    0x168E, // (-211/10)dB = 0.088105 * amplitude
    0x16D0, // (-210/10)dB = 0.089125 * amplitude
    0x1714, // (-209/10)dB = 0.090157 * amplitude
    0x1758, // (-208/10)dB = 0.091201 * amplitude
    0x179E, // (-207/10)dB = 0.092257 * amplitude
    0x17E4, // (-206/10)dB = 0.093325 * amplitude
    0x182A, // (-205/10)dB = 0.094406 * amplitude
    0x1872, // (-204/10)dB = 0.095499 * amplitude
    0x18BB, // (-203/10)dB = 0.096605 * amplitude
    0x1904, // (-202/10)dB = 0.097724 * amplitude
    0x194E, // (-201/10)dB = 0.098855 * amplitude
    0x1999, // (-200/10)dB = 0.100000 * amplitude
    0x19E5, // (-199/10)dB = 0.101158 * amplitude
    0x1A32, // (-198/10)dB = 0.102329 * amplitude
    0x1A7F, // (-197/10)dB = 0.103514 * amplitude
    0x1ACE, // (-196/10)dB = 0.104713 * amplitude
    0x1B1D, // (-195/10)dB = 0.105925 * amplitude
    0x1B6E, // (-194/10)dB = 0.107152 * amplitude
    0x1BBF, // (-193/10)dB = 0.108393 * amplitude
    0x1C11, // (-192/10)dB = 0.109648 * amplitude
    0x1C65, // (-191/10)dB = 0.110917 * amplitude
    0x1CB9, // (-190/10)dB = 0.112202 * amplitude
    0x1D0E, // (-189/10)dB = 0.113501 * amplitude
    0x1D64, // (-188/10)dB = 0.114815 * amplitude
    0x1DBB, // (-187/10)dB = 0.116145 * amplitude
    0x1E13, // (-186/10)dB = 0.117490 * amplitude
    0x1E6C, // (-185/10)dB = 0.118850 * amplitude
    0x1EC7, // (-184/10)dB = 0.120226 * amplitude
    0x1F22, // (-183/10)dB = 0.121619 * amplitude
    0x1F7E, // (-182/10)dB = 0.123027 * amplitude
    0x1FDC, // (-181/10)dB = 0.124451 * amplitude
    0x203A, // (-180/10)dB = 0.125893 * amplitude
    0x209A, // (-179/10)dB = 0.127350 * amplitude
    0x20FA, // (-178/10)dB = 0.128825 * amplitude
    0x215C, // (-177/10)dB = 0.130317 * amplitude
    0x21BF, // (-176/10)dB = 0.131826 * amplitude
    0x2223, // (-175/10)dB = 0.133352 * amplitude
    0x2288, // (-174/10)dB = 0.134896 * amplitude
    0x22EE, // (-173/10)dB = 0.136458 * amplitude
    0x2356, // (-172/10)dB = 0.138038 * amplitude
    0x23BF, // (-171/10)dB = 0.139637 * amplitude
    0x2429, // (-170/10)dB = 0.141254 * amplitude
    0x2494, // (-169/10)dB = 0.142889 * amplitude
    0x2500, // (-168/10)dB = 0.144544 * amplitude
    0x256E, // (-167/10)dB = 0.146218 * amplitude
    0x25DD, // (-166/10)dB = 0.147911 * amplitude
    0x264D, // (-165/10)dB = 0.149624 * amplitude
    0x26BF, // (-164/10)dB = 0.151356 * amplitude
    0x2732, // (-163/10)dB = 0.153109 * amplitude
    0x27A6, // (-162/10)dB = 0.154882 * amplitude
    0x281B, // (-161/10)dB = 0.156675 * amplitude
    0x2892, // (-160/10)dB = 0.158489 * amplitude
    0x290B, // (-159/10)dB = 0.160325 * amplitude
    0x2984, // (-158/10)dB = 0.162181 * amplitude
    0x29FF, // (-157/10)dB = 0.164059 * amplitude
    0x2A7C, // (-156/10)dB = 0.165959 * amplitude
    0x2AFA, // (-155/10)dB = 0.167880 * amplitude
    0x2B79, // (-154/10)dB = 0.169824 * amplitude
    0x2BFA, // (-153/10)dB = 0.171791 * amplitude
    0x2C7C, // (-152/10)dB = 0.173780 * amplitude
    0x2D00, // (-151/10)dB = 0.175792 * amplitude
    0x2D86, // (-150/10)dB = 0.177828 * amplitude
    0x2E0D, // (-149/10)dB = 0.179887 * amplitude
    0x2E95, // (-148/10)dB = 0.181970 * amplitude
    0x2F1F, // (-147/10)dB = 0.184077 * amplitude
    0x2FAB, // (-146/10)dB = 0.186209 * amplitude
    0x3038, // (-145/10)dB = 0.188365 * amplitude
    0x30C7, // (-144/10)dB = 0.190546 * amplitude
    0x3158, // (-143/10)dB = 0.192752 * amplitude
    0x31EA, // (-142/10)dB = 0.194984 * amplitude
    0x327E, // (-141/10)dB = 0.197242 * amplitude
    0x3314, // (-140/10)dB = 0.199526 * amplitude
    0x33AB, // (-139/10)dB = 0.201837 * amplitude
    0x3444, // (-138/10)dB = 0.204174 * amplitude
    0x34DF, // (-137/10)dB = 0.206538 * amplitude
    0x357C, // (-136/10)dB = 0.208930 * amplitude
    0x361A, // (-135/10)dB = 0.211349 * amplitude
    0x36BB, // (-134/10)dB = 0.213796 * amplitude
    0x375D, // (-133/10)dB = 0.216272 * amplitude
    0x3801, // (-132/10)dB = 0.218776 * amplitude
    0x38A7, // (-131/10)dB = 0.221309 * amplitude
    0x394F, // (-130/10)dB = 0.223872 * amplitude
    0x39F9, // (-129/10)dB = 0.226464 * amplitude
    0x3AA5, // (-128/10)dB = 0.229087 * amplitude
    0x3B53, // (-127/10)dB = 0.231739 * amplitude
    0x3C03, // (-126/10)dB = 0.234423 * amplitude
    0x3CB5, // (-125/10)dB = 0.237137 * amplitude
    0x3D68, // (-124/10)dB = 0.239883 * amplitude
    0x3E1F, // (-123/10)dB = 0.242661 * amplitude
    0x3ED7, // (-122/10)dB = 0.245471 * amplitude
    0x3F91, // (-121/10)dB = 0.248313 * amplitude
    0x404D, // (-120/10)dB = 0.251189 * amplitude
    0x410C, // (-119/10)dB = 0.254097 * amplitude
    0x41CD, // (-118/10)dB = 0.257040 * amplitude
    0x4290, // (-117/10)dB = 0.260016 * amplitude
    0x4355, // (-116/10)dB = 0.263027 * amplitude
    0x441D, // (-115/10)dB = 0.266073 * amplitude
    0x44E7, // (-114/10)dB = 0.269153 * amplitude
    0x45B3, // (-113/10)dB = 0.272270 * amplitude
    0x4682, // (-112/10)dB = 0.275423 * amplitude
    0x4753, // (-111/10)dB = 0.278612 * amplitude
    0x4826, // (-110/10)dB = 0.281838 * amplitude
    0x48FC, // (-109/10)dB = 0.285102 * amplitude
    0x49D4, // (-108/10)dB = 0.288403 * amplitude
    0x4AAF, // (-107/10)dB = 0.291743 * amplitude
    0x4B8D, // (-106/10)dB = 0.295121 * amplitude
    0x4C6D, // (-105/10)dB = 0.298538 * amplitude
    0x4D4F, // (-104/10)dB = 0.301995 * amplitude
    0x4E34, // (-103/10)dB = 0.305492 * amplitude
    0x4F1C, // (-102/10)dB = 0.309030 * amplitude
    0x5007, // (-101/10)dB = 0.312608 * amplitude
    0x50F4, // (-100/10)dB = 0.316228 * amplitude
    0x51E4, // (-99/10)dB = 0.319890 * amplitude
    0x52D7, // (-98/10)dB = 0.323594 * amplitude
    0x53CC, // (-97/10)dB = 0.327341 * amplitude
    0x54C5, // (-96/10)dB = 0.331131 * amplitude
    0x55C0, // (-95/10)dB = 0.334965 * amplitude
    0x56BE, // (-94/10)dB = 0.338844 * amplitude
    0x57BF, // (-93/10)dB = 0.342768 * amplitude
    0x58C3, // (-92/10)dB = 0.346737 * amplitude
    0x59CA, // (-91/10)dB = 0.350752 * amplitude
    0x5AD5, // (-90/10)dB = 0.354813 * amplitude
    0x5BE2, // (-89/10)dB = 0.358922 * amplitude
    0x5CF2, // (-88/10)dB = 0.363078 * amplitude
    0x5E06, // (-87/10)dB = 0.367282 * amplitude
    0x5F1C, // (-86/10)dB = 0.371535 * amplitude
    0x6036, // (-85/10)dB = 0.375837 * amplitude
    0x6154, // (-84/10)dB = 0.380189 * amplitude
    0x6274, // (-83/10)dB = 0.384592 * amplitude
    0x6398, // (-82/10)dB = 0.389045 * amplitude
    0x64BF, // (-81/10)dB = 0.393550 * amplitude
    0x65EA, // (-80/10)dB = 0.398107 * amplitude
    0x6718, // (-79/10)dB = 0.402717 * amplitude
    0x684A, // (-78/10)dB = 0.407380 * amplitude
    0x697F, // (-77/10)dB = 0.412098 * amplitude
    0x6AB7, // (-76/10)dB = 0.416869 * amplitude
    0x6BF4, // (-75/10)dB = 0.421697 * amplitude
    0x6D34, // (-74/10)dB = 0.426580 * amplitude
    0x6E78, // (-73/10)dB = 0.431519 * amplitude
    0x6FBF, // (-72/10)dB = 0.436516 * amplitude
    0x710A, // (-71/10)dB = 0.441570 * amplitude
    0x7259, // (-70/10)dB = 0.446684 * amplitude
    0x73AC, // (-69/10)dB = 0.451856 * amplitude
    0x7503, // (-68/10)dB = 0.457088 * amplitude
    0x765E, // (-67/10)dB = 0.462381 * amplitude
    0x77BD, // (-66/10)dB = 0.467735 * amplitude
    0x7920, // (-65/10)dB = 0.473151 * amplitude
    0x7A87, // (-64/10)dB = 0.478630 * amplitude
    0x7BF2, // (-63/10)dB = 0.484172 * amplitude
    0x7D62, // (-62/10)dB = 0.489779 * amplitude
    0x7ED5, // (-61/10)dB = 0.495450 * amplitude
    0x804D, // (-60/10)dB = 0.501187 * amplitude
    0x81CA, // (-59/10)dB = 0.506991 * amplitude
    0x834A, // (-58/10)dB = 0.512861 * amplitude
    0x84D0, // (-57/10)dB = 0.518800 * amplitude
    0x8659, // (-56/10)dB = 0.524807 * amplitude
    0x87E8, // (-55/10)dB = 0.530884 * amplitude
    0x897A, // (-54/10)dB = 0.537032 * amplitude
    0x8B12, // (-53/10)dB = 0.543250 * amplitude
    0x8CAE, // (-52/10)dB = 0.549541 * amplitude
    0x8E4F, // (-51/10)dB = 0.555904 * amplitude
    0x8FF5, // (-50/10)dB = 0.562341 * amplitude
    0x91A0, // (-49/10)dB = 0.568853 * amplitude
    0x9350, // (-48/10)dB = 0.575440 * amplitude
    0x9504, // (-47/10)dB = 0.582103 * amplitude
    0x96BE, // (-46/10)dB = 0.588844 * amplitude
    0x987D, // (-45/10)dB = 0.595662 * amplitude
    0x9A41, // (-44/10)dB = 0.602560 * amplitude
    0x9C0A, // (-43/10)dB = 0.609537 * amplitude
    0x9DD9, // (-42/10)dB = 0.616595 * amplitude
    0x9FAD, // (-41/10)dB = 0.623735 * amplitude
    0xA186, // (-40/10)dB = 0.630957 * amplitude
    0xA365, // (-39/10)dB = 0.638263 * amplitude
    0xA549, // (-38/10)dB = 0.645654 * amplitude
    0xA733, // (-37/10)dB = 0.653131 * amplitude
    0xA923, // (-36/10)dB = 0.660693 * amplitude
    0xAB18, // (-35/10)dB = 0.668344 * amplitude
    0xAD13, // (-34/10)dB = 0.676083 * amplitude
    0xAF14, // (-33/10)dB = 0.683912 * amplitude
    0xB11B, // (-32/10)dB = 0.691831 * amplitude
    0xB328, // (-31/10)dB = 0.699842 * amplitude
    0xB53B, // (-30/10)dB = 0.707946 * amplitude
    0xB755, // (-29/10)dB = 0.716143 * amplitude
    0xB974, // (-28/10)dB = 0.724436 * amplitude
    0xBB9A, // (-27/10)dB = 0.732825 * amplitude
    0xBDC6, // (-26/10)dB = 0.741310 * amplitude
    0xBFF9, // (-25/10)dB = 0.749894 * amplitude
    0xC232, // (-24/10)dB = 0.758578 * amplitude
    0xC471, // (-23/10)dB = 0.767361 * amplitude
    0xC6B8, // (-22/10)dB = 0.776247 * amplitude
    0xC905, // (-21/10)dB = 0.785236 * amplitude
    0xCB59, // (-20/10)dB = 0.794328 * amplitude
    0xCDB3, // (-19/10)dB = 0.803526 * amplitude
    0xD015, // (-18/10)dB = 0.812831 * amplitude
    0xD27E, // (-17/10)dB = 0.822243 * amplitude
    0xD4EE, // (-16/10)dB = 0.831764 * amplitude
    0xD765, // (-15/10)dB = 0.841395 * amplitude
    0xD9E4, // (-14/10)dB = 0.851138 * amplitude
    0xDC6A, // (-13/10)dB = 0.860994 * amplitude
    0xDEF7, // (-12/10)dB = 0.870964 * amplitude
    0xE18C, // (-11/10)dB = 0.881049 * amplitude
    0xE429, // (-10/10)dB = 0.891251 * amplitude
    0xE6CD, // (-9/10)dB = 0.901571 * amplitude
    0xE979, // (-8/10)dB = 0.912011 * amplitude
    0xEC2D, // (-7/10)dB = 0.922571 * amplitude
    0xEEE9, // (-6/10)dB = 0.933254 * amplitude
    0xF1AD, // (-5/10)dB = 0.944061 * amplitude
    0xF47A, // (-4/10)dB = 0.954993 * amplitude
    0xF74F, // (-3/10)dB = 0.966051 * amplitude
    0xFA2C, // (-2/10)dB = 0.977237 * amplitude
    0xFD11, // (-1/10)dB = 0.988553 * amplitude
    };

;

//
//  DBToAmpFactor
//
//  Converts lDB, specified in 100ths decibels, into a
//  linear amplification factor.  For all lDB >= 0 this
//  function returns 0xffff.  This is because our current
//  implementation of DirectSound doesn't allow amplification,
//  and users of this function often require 16-bit results
//
DWORD DBToAmpFactor( LONG lDB )
{
    DWORD dwFactor;

    // input lDB is 100ths of decibels

    // REMIND hack to make mixer code work- it only handles 16-bit factors and
    //  cannot amplify
    if (0 <= lDB) return 0x0000FFFF;
    
    //
    // bias and scale the input and check boundaries for indexing into table
    //
    lDB = (lDB+5)/10;		    // scaled to 1/10th dB units
    
    if (lDB > -1)   lDB = -1;	    // upper boundary
    if (lDB < -964) lDB = -964;	    // lower boundary

    lDB = (lDB + 964);		    // bias

    // lDB better be a good index.
    ASSERT(lDB >= 0);
    ASSERT(lDB <= sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]));
    
    dwFactor = tblDBTenthsToAmpFactor[lDB];

    return dwFactor;
}

// Note, could use DirectSound3D's fyl2x function instead of searching 
// through the table.
LONG AmpFactorToDB( DWORD dwFactor )
{
    LONG    lDB;
    int	    i;
    int	    iMax;

    // dwFactor better be valid.
    ASSERT((LONG)dwFactor >= 0);

    iMax = sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]) - 1;
    
    if (dwFactor < 0x0000FFFF) 
    {
        for (i = 0; i <= iMax - 1; i++) {
	         if (dwFactor <= tblDBTenthsToAmpFactor[i]) break;
        }
        lDB = (i - 964) * 10;
    }
    else
    {
        lDB = 0; 
    }


    return lDB;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\decibels.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       decibels.h
 *  Content:    Decibel helper functions
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/13/97     dereks  Created
 *
 ***************************************************************************/

#ifndef __DECIBELS_H__
#define __DECIBELS_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern DWORD DBToAmpFactor(LONG);
extern LONG AmpFactorToDB(DWORD);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DECIBELS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-1999 Microsoft Corporation
//

#include "stdafx.h"
#include <mmsystem.h>
#include "dsoundp.h"
#include "dmusicc.h"
#include "dmstrm.h"

CRiffParser::CRiffParser(IStream *pStream)

{
    ASSERT(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    ASSERT (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    ASSERT (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DEBUG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            //DPF(DPFLVL_MOREINFO, "Parsing %S, Read %ld of %ld\n",
            //    szName, m_pChunk->lRead, RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DEBUG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                //DPF(DPFLVL_MOREINFO, "Entering %S, Length %ld, File position is %ld",
                //    szName, m_pChunk->cksize, (long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DEBUG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        //DPF(DPFLVL_MOREINFO, "Type %S", szName);
                    }
#endif
                }
                else
                {
                    //DPF(DPFLVL_WARNING, "Unable to read file");
                }
		    }
        }
        else
        {
            //DPF(DPFLVL_WARNING, "Unable to read file");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                //DPF(DPFLVL_WARNING, "Unable to read file");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DEBUG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            //DPF(DPFLVL_MOREINFO, "Leaving %S, Read %ld of %ld, File Position is %ld",
            //    szName, m_pChunk->lRead, lSize, (long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            //DPF(DPFLVL_ERROR, "Unable to read %ld bytes from file", cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the ASSERT will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart + RIFF_ALIGN(m_pChunk->cksize);
    }
}

HRESULT CRiffParser::SeekBack()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    ASSERT(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\audiosink.cpp ===
#include "stdafx.h"
#include "dslink.h"
#include <objbase.h>
#include "audiosink.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//#define _FILE_DEBUG 1
#ifdef _FILE_DEBUG
void FTRACE( LPSTR pszFormat, ... );
#endif

CAudioSink::CAudioSink(WAVEFORMATEX *pwfxFormat)
{
	::InitializeCriticalSection( &m_CriticalSection );
	::InitializeCriticalSection( &m_csClock );
    m_DSLink.SetWaveFormat(pwfxFormat);
    m_cRef = 0;
    m_pMasterClock = NULL;
    m_pMasterClockSync = NULL;
    m_fActive = FALSE;
    m_pSynthSource = NULL;
	m_wfSinkFormat = *pwfxFormat;
	m_fStartSampleClock = true;
    m_pBusIDs = NULL;
    m_pFunctionIDs = NULL;
    m_ppBusBuffers = NULL;
    m_pPBends = NULL;
    m_dwBusCount = 0;
    m_dwBusBufferSize = (m_wfSinkFormat.nSamplesPerSec * AUDIOSINK_BUS_SIZE) / 1000;
	m_plTmpMixBuffer = new long[m_dwBusBufferSize * 2]; // Stereo
}

CAudioSink::~CAudioSink()
{
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
    }
    if (m_pSynthSource)
    {
        m_pSynthSource->Release();
    }
    if (m_pMasterClockSync)
    {
        m_pMasterClockSync->Release();
    }
    m_DSLink.CloseDown();
    if (m_pBusIDs) delete [] m_pBusIDs;
    if (m_pFunctionIDs) delete [] m_pFunctionIDs;
    if (m_ppBusBuffers) delete [] m_ppBusBuffers;
    if (m_pPBends) delete [] m_pPBends;
	if (m_plTmpMixBuffer) delete [] m_plTmpMixBuffer;
	::DeleteCriticalSection( &m_csClock );
	::DeleteCriticalSection( &m_CriticalSection );
}

STDMETHODIMP CAudioSink::QueryInterface(const IID &iid, void **ppv)
{
    if(iid == IID_IUnknown || iid == IID_IDirectSoundSynthSink)
    {
        *ppv = static_cast<IDirectSoundSynthSink*>(this);
    } 
    else if(iid == IID_IDirectSoundConnect) 
    {
        *ppv = static_cast<IDirectSoundConnect*>(this);
    } 
    else if(iid == IID_IReferenceClock) 
    {
        *ppv = static_cast<IReferenceClock*>(this);
    }
    else if(iid == IID_IKsControl) 
    {
        *ppv = static_cast<IKsControl*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CAudioSink::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioSink::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP CAudioSink::AddSource(LPDIRECTSOUNDSOURCE pDSSource) 
{
	::EnterCriticalSection( &m_CriticalSection );
    if (m_pSynthSource)
    {
        m_pSynthSource->Release();
    }
    m_pSynthSource = pDSSource;
    if (m_pSynthSource)
    {
        m_pSynthSource->AddRef();
        DWORD dwSizeWritten;

		// NT bug 465060 causes the synth to return the wrong sample rate, so we ignore
		// the sample rate returned by GetFormat.
		WAVEFORMATEX wfTemp;
        m_pSynthSource->GetFormat(&wfTemp,sizeof(m_wfSinkFormat),&dwSizeWritten);
		m_wfSinkFormat.nBlockAlign = wfTemp.nBlockAlign;
		m_wfSinkFormat.nChannels = wfTemp.nChannels;
		m_wfSinkFormat.wBitsPerSample = wfTemp.wBitsPerSample;
        m_wfSinkFormat.nAvgBytesPerSec = m_wfSinkFormat.nSamplesPerSec * m_wfSinkFormat.nBlockAlign;
		// BUGBUG: Can't do this, as the buffers we've already created are using the old
		// m_dwBusBufferSize value.  Look in CBuffer::CBuffer() and CAudioSink::Render().
        //m_dwBusBufferSize = (m_wfSinkFormat.nSamplesPerSec * AUDIOSINK_BUS_SIZE) / 1000;

		// Flag to reset the SampleClock
		m_fStartSampleClock = true;
    }
	::LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

STDMETHODIMP CAudioSink::RemoveSource(LPDIRECTSOUNDSOURCE pDSSource) 
{
	::EnterCriticalSection( &m_CriticalSection );
    if (m_pSynthSource && (m_pSynthSource == pDSSource))
    {
        m_pSynthSource->Release();
        m_pSynthSource = NULL;
    }
	::LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

STDMETHODIMP CAudioSink::SetMasterClock(IReferenceClock *pClock)
{
	::EnterCriticalSection( &m_csClock );
    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
    }
    if (m_pMasterClockSync)
    {
        m_pMasterClockSync->Release();
        m_pMasterClockSync = NULL;
    }
    m_pMasterClock = pClock;
    if (m_pMasterClock)
    {
        m_pMasterClock->AddRef();
        m_pMasterClock->QueryInterface(IID_IDirectSoundSinkSync, (void**)&m_pMasterClockSync);
    }
	::LeaveCriticalSection( &m_csClock );
    return S_OK;
}

STDMETHODIMP CAudioSink::CreateSoundBuffer(LPCDSBUFFERDESC pcBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppBuffer) 
{
    CBuffer *pBuffer = new CBuffer(this,pcBufferDesc,pdwFuncID,dwBusIDCount,guidBufferID);
    if (pBuffer)
    {
        pBuffer->QueryInterface(IID_IDirectSoundBuffer,(void **)ppBuffer);
		pBuffer->Release();
        ResizeBusArrays();
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP CAudioSink::CreateSoundBufferFromConfig(LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppBuffer)
{
    CBuffer *pBuffer = new CBuffer(this,pConfig);
    if (pBuffer)
    {
        pBuffer->QueryInterface(IID_IDirectSoundBuffer,(void **)ppBuffer);
		pBuffer->Release();
        ResizeBusArrays();
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP CAudioSink::GetSoundBuffer(DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppBuffer)
{
	::EnterCriticalSection( &m_CriticalSection );
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        DWORD dwBus = 0; 
        for (;dwBus < pBuffer->m_dwBusCount; dwBus++)
        {
            if (pBuffer->m_dwBusIDs[dwBus] == dwBusID)
            {
				::LeaveCriticalSection( &m_CriticalSection );
                return pBuffer->QueryInterface(IID_IDirectSoundBuffer, (void **) ppBuffer);
            }
        }
    }
	::LeaveCriticalSection( &m_CriticalSection );
    return DSERR_INVALIDPARAM;
}

STDMETHODIMP CAudioSink::GetBusCount(LPDWORD pdwCount)
{
	::EnterCriticalSection( &m_CriticalSection );
    DWORD dwCount = 0;
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        dwCount += pBuffer->m_dwBusCount;
    }
    *pdwCount = dwCount;
	::LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

STDMETHODIMP CAudioSink::GetBusIDs(LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount)
{
	::EnterCriticalSection( &m_CriticalSection );
    if (dwBusCount > m_dwBusCount) dwBusCount = m_dwBusCount;
    if (pdwBusIDs)
    {
        memcpy(pdwBusIDs,m_pBusIDs,dwBusCount*sizeof(DWORD));
    }
    if (pdwFuncIDs)
    {
        memcpy(pdwFuncIDs,m_pFunctionIDs,dwBusCount*sizeof(DWORD));
    }
	::LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

STDMETHODIMP CAudioSink::GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID) 
{
	::EnterCriticalSection( &m_CriticalSection );
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        DWORD dwBus = 0; 
        for (;dwBus < pBuffer->m_dwBusCount; dwBus++)
        {
            if (pBuffer->m_dwBusIDs[dwBus] == dwBusID)
            {
                *pdwFuncID = pBuffer->m_dwFunctionIDs[dwBus];
				::LeaveCriticalSection( &m_CriticalSection );
                return S_OK;
            }
        }
    }
	::LeaveCriticalSection( &m_CriticalSection );
    return DSERR_INVALIDPARAM;
}

STDMETHODIMP CAudioSink::GetSoundBufferBusIDs(LPDIRECTSOUNDBUFFER pDSBuffer, 
                                              LPDWORD pdwBusIDs, 
                                              LPDWORD pdwFuncIDs, 
                                              LPDWORD pdwBusCount)
{
	::EnterCriticalSection( &m_CriticalSection );
    CBuffer *pCBuffer;
    if (SUCCEEDED(pDSBuffer->QueryInterface(IID_CBuffer,(void **)&pCBuffer)))
    {
        pCBuffer->Release();
        CBuffer *pBuffer = m_BufferList.GetHead();
        for (;pBuffer;pBuffer = pBuffer->GetNext())
        {
            if (pBuffer == pCBuffer)
            {
                DWORD dwMaxBusCount = *pdwBusCount;
                if (dwMaxBusCount > pBuffer->m_dwBusCount)
                {
                    dwMaxBusCount = pBuffer->m_dwBusCount;
                }
                *pdwBusCount = 0;

                for (DWORD dwBus = 0; dwBus < dwMaxBusCount; dwBus++)
                {
                    if (pBuffer->m_dwBusIDs[dwBus] == AUDIOSINK_NULL_BUS_ID)
                        break;

                    pdwBusIDs[dwBus] = pBuffer->m_dwBusIDs[dwBus];
                    if (pdwFuncIDs)
                    {
                        pdwFuncIDs[dwBus] = pBuffer->m_dwFunctionIDs[dwBus];
                    }
                    (*pdwBusCount)++;
                }
				::LeaveCriticalSection( &m_CriticalSection );
                return DS_OK;
            }
        }
    }
	::LeaveCriticalSection( &m_CriticalSection );
    return DSERR_INVALIDPARAM;
}

STDMETHODIMP CAudioSink::GetLatencyClock(IReferenceClock **ppClock)
{
    return QueryInterface(IID_IReferenceClock,(void **)ppClock);
}

STDMETHODIMP CAudioSink::Activate(BOOL fEnable)
{
	// Critical section not necessary - m_fActive is not used anywhere else
    if (m_fActive != fEnable)
    {
        if (fEnable)
        {
            if (m_DSLink.OpenUp(this))
            {
                m_fActive = TRUE;
                return S_OK;
            }
            return E_FAIL;
        }
        else
        {
            m_DSLink.CloseDown();
        }
        m_fActive = FALSE;
    }
    return S_OK;
}

STDMETHODIMP CAudioSink::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prtTime)
{
    m_SampleClock.SampleToRefTime(llSampleTime, prtTime);
    return S_OK;
}

STDMETHODIMP CAudioSink::RefToSampleTime(REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) 
{
    *pllSampleTime = m_SampleClock.RefToSampleTime(rtTime);
    return S_OK;
}

STDMETHODIMP CAudioSink::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) 
{
    if (dwSizeAllocated > sizeof(m_wfSinkFormat))
    {
        dwSizeAllocated = sizeof(m_wfSinkFormat);
    }
    memcpy(pwfxFormat,&m_wfSinkFormat,dwSizeAllocated);
    if (pdwSizeWritten) *pdwSizeWritten = dwSizeAllocated;
    return S_OK;
}

STDMETHODIMP CAudioSink::AdviseTime(REFERENCE_TIME ,REFERENCE_TIME,HANDLE,DWORD *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAudioSink::AdvisePeriodic(REFERENCE_TIME,REFERENCE_TIME,HANDLE,DWORD * )
{
    return E_NOTIMPL;
}

STDMETHODIMP CAudioSink::Unadvise( DWORD )
{
    return E_NOTIMPL;
}

STDMETHODIMP CAudioSink::GetTime(LPREFERENCE_TIME pTime)
{
    HRESULT hr = E_FAIL;

    if( pTime == NULL )
    {
        return E_INVALIDARG;
    }

	::EnterCriticalSection( &m_csClock );
    REFERENCE_TIME rtCompare;
    if (m_pMasterClock)
    {
        m_pMasterClock->GetTime(&rtCompare);

        hr = SampleToRefTime(m_DSLink.GetAbsWriteSample(), pTime);

        if (FAILED(hr))
        {
            TRACE(/*DPFLVL_WARNING, */"Sink Latency Clock: SampleToRefTime failed");

			::LeaveCriticalSection( &m_csClock );
            return hr;
        }

        if (*pTime < rtCompare)
        {
//            DPF(DPFLVL_INFO, "Sink Latency Clock off. Latency time is %ldms, Master time is %ldms",
//                (long) (*pTime / 10000), (long) (rtCompare / 10000));
			TRACE("Sink Latency Clock off (early). Latency time is %ldms, Master time is %ldms\n",
				(long) (*pTime / 10000), (long) (rtCompare / 10000));
            *pTime = rtCompare;
        }
        else if (*pTime > (rtCompare + (10000 * 1000)))
        {
//                DPF(DPFLVL_INFO, "Sink Latency Clock off. Latency time is %ldms, Master time is %ldms",
//                    (long) (*pTime / 10000), (long) (rtCompare / 10000));
            TRACE("Sink Latency Clock off (late). Latency time is %ldms, Master time is %ldms\n",
			    (long) (*pTime / 10000), (long) (rtCompare / 10000));
            *pTime = rtCompare + (10000 * 1000);
        }
        hr = S_OK;
    }
    else
    {
        TRACE(/*DPFLVL_WARNING, */"Sink Latency Clock - GetTime called with no master clock");
    }
	::LeaveCriticalSection( &m_csClock );
    return hr;
}

STDMETHODIMP CAudioSink::KsProperty(PKSPROPERTY Property,ULONG PropertyLength,
        LPVOID PropertyData,ULONG DataLength,ULONG* BytesReturned)
{
	UNREFERENCED_PARAMETER(Property);
	UNREFERENCED_PARAMETER(PropertyLength);
	UNREFERENCED_PARAMETER(PropertyData);
	UNREFERENCED_PARAMETER(DataLength);
	UNREFERENCED_PARAMETER(BytesReturned);
    return E_NOTIMPL;
}

STDMETHODIMP CAudioSink::KsMethod(PKSMETHOD Method,ULONG MethodLength,
                                  LPVOID MethodData,ULONG DataLength,ULONG* BytesReturned) 
{
	UNREFERENCED_PARAMETER(Method);
	UNREFERENCED_PARAMETER(MethodLength);
	UNREFERENCED_PARAMETER(MethodData);
	UNREFERENCED_PARAMETER(DataLength);
	UNREFERENCED_PARAMETER(BytesReturned);
    return E_NOTIMPL;
}

STDMETHODIMP CAudioSink::KsEvent(PKSEVENT Event OPTIONAL,ULONG EventLength,
                                 LPVOID EventData,ULONG DataLength,ULONG* BytesReturned)
{
	UNREFERENCED_PARAMETER(Event);
	UNREFERENCED_PARAMETER(EventLength);
	UNREFERENCED_PARAMETER(EventData);
	UNREFERENCED_PARAMETER(DataLength);
	UNREFERENCED_PARAMETER(BytesReturned);
    return E_NOTIMPL;
}


void CAudioSink::ResizeBusArrays()
{
	::EnterCriticalSection( &m_CriticalSection );
    GetBusCount(&m_dwBusCount);
    if (m_pBusIDs) delete [] m_pBusIDs;
    if (m_pFunctionIDs) delete [] m_pFunctionIDs;
    if (m_ppBusBuffers) delete [] m_ppBusBuffers;
    if (m_pPBends) delete [] m_pPBends;
    if (m_dwBusCount)
    {
        m_pBusIDs = new DWORD[m_dwBusCount];
        m_pFunctionIDs = new DWORD[m_dwBusCount];
        m_ppBusBuffers = new short *[m_dwBusCount];
        m_pPBends = new long[m_dwBusCount];
        FillBusArrays();
    }
    else
    {
        m_pBusIDs = NULL;
        m_pFunctionIDs = NULL;
        m_ppBusBuffers = NULL;
        m_pPBends = NULL;
    }
	::LeaveCriticalSection( &m_CriticalSection );
}

void CAudioSink::FillBusArrays()
{
	::EnterCriticalSection( &m_CriticalSection );
    DWORD dwIndex = 0;
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
        DWORD dwBus = 0; 
        for (;dwBus < pBuffer->m_dwBusCount; dwBus++)
        {
            // Make sure we don't go beyond the array bounds.
            if (dwIndex < m_dwBusCount)
            {
                m_pBusIDs[dwIndex] = pBuffer->m_dwBusIDs[dwBus];
                m_pFunctionIDs[dwIndex] = pBuffer->m_dwFunctionIDs[dwBus];
                m_ppBusBuffers[dwIndex] = pBuffer->m_pBusBuffer[dwBus];
                m_pPBends[dwIndex++] = pBuffer->m_lPBend;
            }
        }
    }
	::LeaveCriticalSection( &m_CriticalSection );
}

void CAudioSink::RemoveBuffer(CBuffer *pBuffer)

{
	::EnterCriticalSection( &m_CriticalSection );
    m_BufferList.Remove(pBuffer);
    ResizeBusArrays();
	::LeaveCriticalSection( &m_CriticalSection );
}

void CAudioSink::AddBuffer(CBuffer *pBuffer)

{
	::EnterCriticalSection( &m_CriticalSection );

	// Must add buffers to the head of the list, so that all send source buffers
	// are processed before send destination buffers
    m_BufferList.AddHead(pBuffer);
    ResizeBusArrays();
	::LeaveCriticalSection( &m_CriticalSection );
}

void CAudioSink::Mix(short *pnBuffer,DWORD dwLength, REFERENCE_TIME rtTime)

{
	ZeroMemory( m_plTmpMixBuffer, sizeof(long) * m_dwBusBufferSize * 2 );

    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
		pBuffer->PreRender( dwLength );
    }

    pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
		pBuffer->Render( m_plTmpMixBuffer, dwLength, rtTime );
    }

	// Now, clip temp mix buffer to destination buffer
	long *plMixBuffer = m_plTmpMixBuffer;
	for( DWORD dwIndex = dwLength * 2; dwIndex > 0; dwIndex-- )
	{
		long lAccum = *plMixBuffer;

		// Do the final shift
		lAccum = lAccum >>4;

		// Clip
		if (lAccum > 32767) lAccum = 32767;
		else if (lAccum < -32767) lAccum = -32767;

		*pnBuffer = (short) lAccum;
		pnBuffer++;
		plMixBuffer++;
	}
}

void CAudioSink::Render(short *pnBuffer,
                        DWORD dwLength,
                        LONGLONG /*llWritePosition*/,
                        LONGLONG llPlayPosition)
{
	::EnterCriticalSection( &m_csClock );
    if (m_fStartSampleClock)
    {
		ASSERT( llPlayPosition < ULONG_MAX );
		TRACE("Starting clock at %I64d\n",llPlayPosition);
        m_SampleClock.Start(m_pMasterClock, m_wfSinkFormat.nSamplesPerSec, DWORD(llPlayPosition));
		m_fStartSampleClock = false;
    }
    // Now, sync the audio to the master clock.
    // If we are in the first two seconds, just let the sample clock sync to the master clock.
    // This allows it to overcome jitter and get a tight starting position.
    // Then, after that first two seconds, switch to letting the sample
    // clock drive the master clock.
    // Also, if there is no way of adjusting the master clock (no m_pMasterClockSync),
    // then always adjust the sample clock instead.
    BOOL fLockToMaster = (!m_pMasterClockSync) || (m_DSLink.GetAbsPlaySample() < m_wfSinkFormat.nSamplesPerSec * 2);
    m_SampleClock.SyncToMaster(m_DSLink.GetAbsPlaySample(),m_pMasterClock,fLockToMaster);
    // Then, take the same offset that was generated by the sync code
    // and use it to adjust the timing of the master clock.
    if (!fLockToMaster)
    {
        // First, get the new offset that was generated by SyncToMaster.
        REFERENCE_TIME rtOffset;
        m_SampleClock.GetClockOffset(&rtOffset);
//        TRACE("Offset is now %ld.%ld\n",(long) (rtOffset / 10000),(long)rtOffset);
        m_pMasterClockSync->SetClockOffset(-rtOffset);
    }
	::LeaveCriticalSection( &m_csClock );

	::EnterCriticalSection( &m_CriticalSection );
    if (m_pSynthSource && m_dwBusCount)
    {
        DWORD dwStartPoint = 0;
        while (dwLength > 0)
        {
            DWORD dwSliceSize = dwLength;
            if (dwLength > m_dwBusBufferSize)
            {
                dwLength -= m_dwBusBufferSize;
                dwSliceSize = m_dwBusBufferSize;
            }
            else
            {
                dwLength = 0;
            }
            ULONGLONG llBytesToRead = dwSliceSize * 2; // 16-bit samples, so two bytes per sample
            DWORD dwIndex = 0;
            for (;dwIndex < m_dwBusCount;dwIndex++)
            {
				ZeroMemory( m_ppBusBuffers[dwIndex], dwSliceSize * 2 );
            }
#ifdef _FILE_DEBUG
			FTRACE("Render: %d %I64d\n", timeGetTime(), m_DSLink.GetAbsWriteSample() * 2 + dwStartPoint * 2 );
#endif
			m_pSynthSource->Seek( m_DSLink.GetAbsWriteSample() * 2 + dwStartPoint * 2 );
            m_pSynthSource->Read((void**)m_ppBusBuffers, m_pBusIDs, m_pFunctionIDs, 
                m_pPBends,m_dwBusCount, &llBytesToRead);


			REFERENCE_TIME rtStart = 0;
			SampleToRefTime( m_DSLink.GetAbsWriteSample() + dwStartPoint, &rtStart );

#ifdef _FILE_DEBUG
			FTRACE("Mix: %d %I64d\n", timeGetTime(), rtStart );
#endif
            Mix(&pnBuffer[dwStartPoint*2],dwSliceSize, rtStart);
            dwStartPoint += dwSliceSize;
        }
    }
	::LeaveCriticalSection( &m_CriticalSection );
}

CBuffer *CAudioSink::FindBufferFromGUID( REFGUID rguidBuffer )
{
	::EnterCriticalSection( &m_CriticalSection );
    CBuffer *pBuffer = m_BufferList.GetHead();
    for (;pBuffer;pBuffer = pBuffer->GetNext())
    {
		if( rguidBuffer == pBuffer->m_guidBufferID )
		{
			::LeaveCriticalSection( &m_CriticalSection );
			return pBuffer;
		}
    }

	::LeaveCriticalSection( &m_CriticalSection );
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\dmstrm.h ===
//
// dmstrm.h
// 
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//

#ifndef DMSTRM_H
#define DMSTRM_H

#ifdef __cplusplus

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

#endif // __cplusplus

#endif // #ifndef DMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\dsbufcfg.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbufcfg.cpp
 *  Content:    DirectSound Buffer Configuration 
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 11/17/99     jimge   Created.
 * 11/24/99     petchey Completed implementation.
 *
 ***************************************************************************/

#include "stdafx.h"
#include <mmsystem.h>
#include "dsoundp.h"
#include "dmusici.h"
#include "dsbufcfg.h"
#include "mediaobj.h"
#include "dmstrm.h"

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::QueryInterface"

HRESULT CDirectSoundBufferConfig::QueryInterface(REFIID iid, LPVOID *ppv)
{
    if(iid == IID_IUnknown || iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    } 
    else if(iid == IID_IPersist)
    {
        *ppv = static_cast<IPersist*>(this);
    } 
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    } 
    else if (iid == CLSID_PRIVATE_CDirectSoundBufferConfig)
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CDirectSoundBufferConfig::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDirectSoundBufferConfig::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::CDirectSoundBufferConfig"

CDirectSoundBufferConfig::CDirectSoundBufferConfig()
{
    //DPF_ENTER();
    //DPF_CONSTRUCT(CDirectSoundBufferConfig);

    //CreateAndRegisterInterface(this, IID_IPersistStream, this, &m_pImpPersistStream);
    // FIXME: Should RegisterInterface(IID_IPersist, m_pImpPersistStream, (IPersist*)m_pImpPersistStream) too?
    //CreateAndRegisterInterface(this, IID_IDirectMusicObject, this, &m_pImpDirectMusicObject);

    m_pdwFuncIDs = NULL;
    m_dwFuncIDsCount = 0;

    m_pDXDMOMapList = NULL;
    m_dwDXDMOMapCount = 0;

    ZeroMemory(&m_DMUSObjectDesc,sizeof(m_DMUSObjectDesc));
    ZeroMemory(&m_DSBufferDesc,sizeof(m_DSBufferDesc));

    m_DMUSObjectDesc.dwSize      = sizeof(m_DMUSObjectDesc);
    m_DMUSObjectDesc.dwValidData = DMUS_OBJ_CLASS;
    m_DMUSObjectDesc.guidClass   = CLSID_DirectSoundBufferConfig;

    m_fLoadFlags = 0;
	m_cRef = 0;
	AddRef();

    // Register this object with the administrator
    //g_pDsAdmin->RegisterObject(this);

    //DPF_LEAVE_VOID();
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::~CDirectSoundBufferConfig"

CDirectSoundBufferConfig::~CDirectSoundBufferConfig()
{
    //DPF_ENTER();
    //DPF_DESTRUCT(CDirectSoundBufferConfig);

    // Unregister with the administrator
    //g_pDsAdmin->UnregisterObject(this);

    if (m_pDXDMOMapList)
    {
        CDXDMODesc *pObj = m_pDXDMOMapList;
        CDXDMODesc *pNextObj;
        while (pObj) 
        {
            pNextObj = pObj->pNext;
            if (pObj->m_pMediaObject)
            {
                //We are releasing an object in another DLL.  If we are called
                //via an AbsoluteRelease call, this dll may already be unloaded.
                try
                {
                    pObj->m_pMediaObject->Release();
                }
                catch(...)
                {
                }
            }
            delete pObj;
            pObj = pNextObj;
        }
    }
    delete []m_pdwFuncIDs;
    //delete m_pImpPersistStream;
    //delete m_pImpDirectMusicObject;

    //DPF_LEAVE_VOID();
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::GetClassID"

HRESULT CDirectSoundBufferConfig::GetClassID(CLSID *pClassID)
{
    //DPF_ENTER();

    HRESULT hr = S_OK;

    *pClassID = CLSID_DirectSoundBufferConfig;

    //DPF_LEAVE_HRESULT(hr);
    return hr;
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::Load"

HRESULT CDirectSoundBufferConfig::Load(IStream *pStream)
{
    //DPF_ENTER();

    //
    // Parse file
    //

    CRiffParser Parser(pStream);
    HRESULT hr = S_OK;
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckChild;
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_DSBC_FORM))
    {
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &m_DMUSObjectDesc.guidObject, sizeof(GUID));
                m_DMUSObjectDesc.dwValidData |= DMUS_OBJ_OBJECT;
                break;
            case DMUS_FOURCC_DSBD_CHUNK:
                hr = Parser.Read( &m_DSBufferDesc, sizeof(DSOUND_IO_DSBUFFERDESC) );
                m_fLoadFlags |= DSBCFG_DSBD;
                break;
            case DMUS_FOURCC_BSID_CHUNK:
                m_pdwFuncIDs = (LPDWORD)new char[ckNext.cksize];
                if ( m_pdwFuncIDs )
                {
                    hr = Parser.Read( m_pdwFuncIDs, ckNext.cksize );
                    if( SUCCEEDED(hr) )
                    {
                        m_fLoadFlags |= DSBCFG_BSID;
                        m_dwFuncIDsCount = ckNext.cksize/sizeof(DWORD);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                break;
            case DMUS_FOURCC_DS3D_CHUNK:
                hr = Parser.Read( &m_DS3DDesc, sizeof(DSOUND_IO_3D) );
                m_fLoadFlags |= DSBCFG_DS3D;
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckChild);
                    while(Parser.NextChunk(&hr))
                    {
                        if ( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = Parser.Read(&m_DMUSObjectDesc.wszName, DMUS_MAX_NAME * sizeof(WCHAR));
                            m_DMUSObjectDesc.dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    Parser.LeaveList();
                    break;
                case DMUS_FOURCC_DSBC_LIST:
                    Parser.EnterList(&ckChild);
                    while(Parser.NextChunk(&hr))
                    {
                        if ((ckChild.ckid == FOURCC_RIFF) && (ckChild.fccType == DMUS_FOURCC_DSFX_FORM))
                        {
                            hr = LoadFx(&Parser);
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;
            }
        }
        Parser.LeaveList();
    }
    else
    {
        hr = DMUS_E_INVALIDCHUNK;
    }

    if (SUCCEEDED(hr))
    {
        m_DMUSObjectDesc.dwValidData |= DMUS_OBJ_LOADED;
    }

    //DPF_LEAVE_HRESULT(hr);
    return hr;
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::GetDescriptor"

HRESULT CDirectSoundBufferConfig::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    //DPF_ENTER();

    HRESULT hr = S_OK;

    CopyMemory(pDesc, &m_DMUSObjectDesc, sizeof(m_DMUSObjectDesc));

    //DPF_LEAVE_HRESULT(hr);
    return hr;
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::SetDescriptor"

HRESULT CDirectSoundBufferConfig::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    //DPF_ENTER();

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_DMUSObjectDesc.guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            lstrcpyW(m_DMUSObjectDesc.wszName, pDesc->wszName);
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            lstrcpyW(m_DMUSObjectDesc.wszCategory, pDesc->wszCategory);
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_DMUSObjectDesc.wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if ( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_DMUSObjectDesc.vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_DMUSObjectDesc.ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }

        m_DMUSObjectDesc.dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }

    //DPF_LEAVE_HRESULT(hr);
    return hr;
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::ParseDescriptor"

HRESULT CDirectSoundBufferConfig::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    //DPF_ENTER();
    CRiffParser Parser(pStream);
    RIFFIO ckMain;
	RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData = 0;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_DSBC_FORM))
    {
        dwValidData = 0;
        Parser.EnterList(&ckNext);
	    while(Parser.NextChunk(&hr))
	    {
		    switch(ckNext.ckid)
		    {
            case DMUS_FOURCC_GUID_CHUNK:
				hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
				dwValidData |= DMUS_OBJ_OBJECT;
				break;
            case DMUS_FOURCC_VERSION_CHUNK:
				hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
				dwValidData |= DMUS_OBJ_VERSION;
				break;
			case DMUS_FOURCC_CATEGORY_CHUNK:
				hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
				dwValidData |= DMUS_OBJ_CATEGORY;
				break;
			case DMUS_FOURCC_DATE_CHUNK:
				hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                dwValidData |= DMUS_OBJ_DATE;
				break;
			case FOURCC_LIST:
				switch(ckNext.fccType)
				{
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
					{
						if (ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK)
						{
							hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            dwValidData |= DMUS_OBJ_NAME;
						}
					}
                    Parser.LeaveList();
					break;            
				}
				break;
		    }
        }
        Parser.LeaveList();
    }
    else
    {
        hr = DMUS_E_CHUNKNOTFOUND;
    }

    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    //DPF_LEAVE_HRESULT(hr);

    return hr;
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::Save"

HRESULT CDirectSoundBufferConfig::Save(IStream *pStream, BOOL fClearDirty)
{
    //DPF_ENTER();

    HRESULT hr = E_NOTIMPL;

    //DPF_LEAVE_HRESULT(hr);
    return hr;
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::GetSizeMax"

HRESULT CDirectSoundBufferConfig::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    //DPF_ENTER();

    HRESULT hr = E_NOTIMPL;

    //DPF_LEAVE_HRESULT(hr);
    return hr;
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::IsDirty"

HRESULT CDirectSoundBufferConfig::IsDirty()
{
    //DPF_ENTER();

    HRESULT hr = E_NOTIMPL;

    //DPF_LEAVE_HRESULT(hr);
    return hr;
}

//#undef DPF_FNAME
//#define DPF_FNAME "CDirectSoundBufferConfig::LoadFx"

HRESULT CDirectSoundBufferConfig::LoadFx(CRiffParser *pParser)
{
    //DPF_ENTER();

    RIFFIO ckNext;
    
    DSOUND_IO_DXDMO_HEADER ioDxDMOHdr;
    CDXDMODesc *pCurrDXDMODesc = NULL;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        if(ckNext.ckid == DMUS_FOURCC_DSFX_CHUNK)
        {    
            hr = pParser->Read(&ioDxDMOHdr, sizeof(DSOUND_IO_DXDMO_HEADER));
            if(SUCCEEDED(hr) && (ioDxDMOHdr.dwReserved != 0 || ioDxDMOHdr.guidReserved != GUID_NULL))
            {
                //DPF(DPFLVL_WARNING, "DSOUND_IO_DXDMO_HEADER chunk invalid: reserved fields must be zero");
                hr = DMUS_E_INVALIDCHUNK;
            }

            if (SUCCEEDED(hr) && (ioDxDMOHdr.guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
                || ioDxDMOHdr.guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
                ))
            {
                if (ioDxDMOHdr.guidSendBuffer == GUID_NULL)
                {
                    //DPF(DPFLVL_WARNING, "DSOUND_IO_DXDMO_HEADER chunk invalid: send effect must specify a non-null guidSendBuffer");
                    hr = DMUS_E_INVALIDCHUNK;
                }
            }
            else
            {
                if (ioDxDMOHdr.guidSendBuffer != GUID_NULL)
                {
                    //DPF(DPFLVL_WARNING, "DSOUND_IO_DXDMO_HEADER chunk invalid: not a send effect, so guidSendBuffer must be null");
                    hr = DMUS_E_INVALIDCHUNK;
                }
            }

            if(SUCCEEDED(hr) && (m_fLoadFlags & DSBCFG_DSBD))
            {
                pCurrDXDMODesc = NULL;

                CDXDMODesc *pDXDMODesc = new CDXDMODesc;
				if( pDXDMODesc == NULL )
				{
					hr = E_OUTOFMEMORY;
				}
                //hr = HRFROMP(pDXDMODesc);
                if (SUCCEEDED(hr))
                {
                    pCurrDXDMODesc = pDXDMODesc;
                    pDXDMODesc->m_dwEffectFlags = ioDxDMOHdr.dwEffectFlags;
                    pDXDMODesc->m_guidDSFXClass = ioDxDMOHdr.guidDSFXClass;
                    pDXDMODesc->m_guidSendBuffer = ioDxDMOHdr.guidSendBuffer;
                    pDXDMODesc->m_dwReserved = ioDxDMOHdr.dwReserved;
                    pDXDMODesc->m_lSendLevel = 0;
					pDXDMODesc->pNext = NULL;
					pDXDMODesc->m_pMediaObject = NULL;

                    if (!IsEqualGUID(pDXDMODesc->m_guidDSFXClass, GUID_DSFX_SEND)
#ifdef ENABLE_I3DL2SOURCE
                        && !IsEqualGUID(pDXDMODesc->m_guidDSFXClass, GUID_DSFX_STANDARD_I3DL2SOURCE)
#endif
                        )
                    {
                        hr = CoCreateInstance(pDXDMODesc->m_guidDSFXClass, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&pDXDMODesc->m_pMediaObject);
                    }

                    if (SUCCEEDED(hr))
                    {
                        AddDXDMODesc(pDXDMODesc);
                        // FIXME: we shouldn't be ferreting away all this info (m_pDXDMOMapList etc);
                        // once we have the DMOs, we don't need all this data just to call Clone()
                        m_fLoadFlags |= DSBCFG_DSFX;
                    }

                    if (FAILED(hr))
                    {
                        delete pDXDMODesc;
                    }
                }
            }
        }
        else if(ckNext.ckid == DMUS_FOURCC_DSFX_DATA && pCurrDXDMODesc)
        {    
            if (pCurrDXDMODesc->m_pMediaObject)
            {
                IPersistStream* pPersistStream = NULL;
                hr = pCurrDXDMODesc->m_pMediaObject->QueryInterface(IID_IPersistStream,(void**)&pPersistStream);
                if (SUCCEEDED(hr))
                {
                    pParser->MarkPosition();
                    hr = pPersistStream->Load(pParser->GetStream());
                    pParser->SeekForward();
                    pPersistStream->Release();
                }
            }
            // Special case for Send Effects -- Read the send level manually.  The
            // Send effect doesn't implement IPersistStream.
            else if (IsEqualGUID(pCurrDXDMODesc->m_guidDSFXClass, GUID_DSFX_SEND))
            {
                hr = pParser->Read((void*)&pCurrDXDMODesc->m_lSendLevel, sizeof(long));
                if (SUCCEEDED(hr))
                {
                    // validate the SendLevel
                    if (!((pCurrDXDMODesc->m_lSendLevel <= 0) && (pCurrDXDMODesc->m_lSendLevel >= -10000)))
                    {
                        // Invalid Send Level
                        pCurrDXDMODesc->m_lSendLevel = 0;
                        hr = DSERR_INVALIDPARAM;
                    }
                }
            }
            pCurrDXDMODesc = NULL;    // clear this just in case 
        }
    }
    pParser->LeaveList();

    //DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\dslink.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//	DSLink.h

#ifndef __DS_LINK__
#define __DS_LINK__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "directks.h"
#include <math.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "cclock.h"
#include "PLClock.h"
#include "alist.h"

//#define USE_STREAMING_BUFFERS 1
//#define USE_PINGPONG_BUFFERS 1
#define USE_LOOPING_BUFFERS 1

#ifdef USE_STREAMING_BUFFERS
#define DSBUFFER_LENGTH_MS 100
#define NUM_FRAMES 6
#endif //USE_STREAMING_BUFFERS

#ifdef USE_PINGPONG_BUFFERS
#define DSBUFFER_LENGTH_MS 1000
#define NUM_FRAMES 2
#endif //USE_PINGPONG_BUFFERS

#ifdef USE_LOOPING_BUFFERS
#define DSBUFFER_LENGTH_MS 1000
#define NUM_FRAMES 1
#endif //USE_LOOPING_BUFFERS

class CAudioSink;
class CBuffer;

class CDSLink 
{
public:
    // IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

public:
						CDSLink();
						~CDSLink();
	BOOL				OpenUp(CAudioSink *pSink);
    void				CloseDown();
    void                SetWaveFormat(WAVEFORMATEX *pWaveFormat);
    ULONGLONG			GetAbsPlaySample(void);
    ULONGLONG			GetAbsWriteSample(void) {return ByteToSample(m_llAbsWrite);}
private:
	static DWORD WINAPI SynthThread (LPVOID lpThreadParameter);
	void				SynthProc();
	void				Clear();
	void				Activate();
	void				Deactivate();			
	void				ReadBuffer();
	BOOL				m_fPleaseDie;		// Triggers exit.
    DWORD               m_dwResolution;     // Synth thread timeout (ms)
    BOOL                m_fOpened;
    HANDLE				m_hThread;          // Handle for synth thread.
    DWORD				m_dwThread;         // ID for thread.
    HANDLE				m_hEvent;           // Used to signal thread.

    CAudioSink *        m_pAudioSink;       // Pointer to parent sink.
	long				m_cRef;
	WAVEFORMATEX		m_wfSynth;		// Waveform requested by synth.

	CPCMAudioPin *		m_pPCMAudioPin;		// PCM Audio pin

    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage access.
	ULONGLONG			m_llAbsPlay;		// Absolute point where play head is.
	ULONGLONG			m_llAbsWrite;	    // Absolute point we've written up to.
#ifdef USE_LOOPING_BUFFERS
	DWORD				m_dwLastPlay;		// Last point where play head is.
#endif
	DWORD				m_dwWriteTo;		// Distance between write head and where we are writing.
	DWORD               m_dwWriteFromMax;   // Max distance observed between play and write head.
	BOOL				m_fActive;			// Currently active.
	DWORD				m_dwFrame;			// Current frame in use
	BYTE				*m_apbData[NUM_FRAMES];// Array of pointers to the buffers

	HRESULT				Connect();
	HRESULT				Disconnect();

    // helpers
    ULONGLONG SampleToByte(ULONGLONG llSamples) {return llSamples << m_wfSynth.nChannels;}   // REVIEW: dwSamples * m_wfSynth.nBlockAlign
    DWORD SampleToByte(DWORD dwSamples) {return dwSamples << m_wfSynth.nChannels;}   // REVIEW: dwSamples * m_wfSynth.nBlockAlign
    ULONGLONG ByteToSample(ULONGLONG llBytes)   {return llBytes >> m_wfSynth.nChannels;}     // REVIEW: dwBytes / m_wfSynth.nBlockAlign
    DWORD ByteToSample(DWORD dwBytes)   {return dwBytes >> m_wfSynth.nChannels;}     // REVIEW: dwBytes / m_wfSynth.nBlockAlign
    ULONGLONG SampleAlign(ULONGLONG llBytes)    {return SampleToByte(ByteToSample(llBytes));}
    DWORD SampleAlign(DWORD dwBytes)    {return SampleToByte(ByteToSample(dwBytes));}
    
};

#ifdef _DEBUG
class LogClass : public LogStub
{
public:
    virtual int      _cdecl Log( UINT nLevel, LPSTR pszFormat, ...);
    virtual int      _cdecl LogEx( DWORD dwType, UINT nLevel, LPSTR pszFormat, ...);
    virtual int      _cdecl LogSummary( UINT nLevel, LPSTR pszFormat, ...);
    virtual int      _cdecl LogStatusBar( LPSTR pszFormat, ...);
    virtual void     LogStdErrorString(DWORD dwErrorCode);
};
#endif

#endif // __DS_LINK__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\effects.cpp ===
/***************************************************************************
 *
 *	Copyright (C) 1999-2000 Microsoft Corporation.	All Rights Reserved.
 *
 *	File:		 effects.cpp
 *
 *	Content:	 Implementation of the CEffectChain class and the CEffect
 *				 class hierarchy (CEffect, CDmoEffect and CSendEffect).
 *
 *	Description: These classes support audio effects and effect sends, a new
 *				 feature in DX8.  The CDirectSoundSecondaryBuffer object is
 *				 extended with a pointer to an associated CEffectChain,
 *				 which in turn manages a list of CEffect-derived objects.
 *
 *				 Almost everything here would fit more logically into the
 *				 existing CDirectSoundSecondaryBuffer class, but has been
 *				 segregated for ease of maintenance (and because dsbuf.cpp
 *				 is complex enough as it is).  So the CEffectChain object
 *				 should be understood as a sort of helper object belonging to
 *				 CDirectSoundSecondaryBuffer.  In particular, a CEffectChain
 *				 object's lifetime is contained by the lifetime of its owning
 *				 CDirectSoundSecondaryBuffer, so we can safely fiddle with
 *				 this buffer's innards at any time in CEffectChain code.
 *
 *	History:
 *
 * Date 	 By 	  Reason
 * ========  =======  ======================================================
 * 08/10/99  duganp   Created
 *
 ***************************************************************************/

#include "stdafx.h"
#include <mmsystem.h>
#include "dsoundp.h"
#include "effects.h"
#include "audiosink.h"
#include "cconduct.h"
#include <uuids.h>		// For MEDIATYPE_Audio, MEDIASUBTYPE_PCM and FORMAT_WaveFormatEx
#include "dsbufcfg.h"
#include "decibels.h"



/***************************************************************************
 *
 *	CEffectChain::CEffectChain
 *
 *	Description:
 *		Object constructor.
 *
 *	Arguments:
 *		CBuffer* [in]: Pointer to our associated buffer.
 *
 *	Returns:
 *		(void)
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffectChain::CEffectChain"

CEffectChain::CEffectChain(CBuffer* pBuffer)
{
	//DPF_ENTER();
	//DPF_CONSTRUCT(CEffectChain);

	// Set up initial values
	m_hrInit		= DSERR_UNINITIALIZED;
	m_pDsBuffer 	= pBuffer;

	// Keep a pointer to the audio format for convenience
	m_pFormat = pBuffer->Format();

	m_fHasSend = FALSE;

	m_cRef = 0;

	AddRef();
	//DPF(DPFLVL_INFO, "Created effect chain with PreFxBuffer=0x%p, PostFxBuffer=0x%p, BufSize=%lu",
	//	  m_pPreFxBuffer, m_pPostFxBuffer, m_dwBufSize);
	//DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *	CEffectChain::~CEffectChain
 *
 *	Description:
 *		Object destructor.
 *
 *	Arguments:
 *		(void)
 *
 *	Returns:
 *		(void)
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffectChain::~CEffectChain"

CEffectChain::~CEffectChain(void)
{
	//DPF_ENTER();
	//DPF_DESTRUCT(CEffectChain);

	// Ensure we don't re-enter the destructor
	m_cRef = LONG_MAX / 2;

	// m_fxList's destructor takes care of releasing our CEffect objects
	// Not anymore...
	while( !m_fxList.IsEmpty() )
	{
		m_fxList.RemoveHead()->Release();
	}

	//DPF_LEAVE_VOID();
}



STDMETHODIMP CEffectChain::QueryInterface(const IID &iid, void **ppv)
{
	if(iid == IID_IUnknown )
	{
		*ppv = static_cast<IUnknown*>(this);
	} 
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG) CEffectChain::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEffectChain::Release()
{
	if(!InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

/***************************************************************************
 *
 *	CEffectChain::Initialize
 *
 *	Description:
 *		Initializes the chain with the effects requested.
 *
 *	Arguments:
 *		DWORD [in]: Number of effects requested
 *		LPDSEFFECTDESC [in]: Pointer to effect description structures
 *		DWORD* [out]: Receives the effect creation status codes
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffectChain::Initialize"

HRESULT CEffectChain::Initialize(DWORD dwFxCount, LPDSEFFECTDESC pFxDesc, LPDWORD pdwResultCodes)
{
	HRESULT hr = DS_OK;
	//DPF_ENTER();
	HRESULT hrFirstFailure = DS_OK; // HR for the first FX creation failure

	ASSERT(dwFxCount > 0);
	if( !IS_VALID_READ_PTR(pFxDesc, sizeof( DSEFFECTDESC ) ) )
	{
		return DSERR_INVALIDPARAM;
	}

	DMO_MEDIA_TYPE dmt;
	ZeroMemory(&dmt, sizeof dmt);
	dmt.majortype				= MEDIATYPE_Audio;
	dmt.subtype 				= MEDIASUBTYPE_PCM;
	dmt.bFixedSizeSamples		= TRUE;
	dmt.bTemporalCompression	= FALSE;
	dmt.lSampleSize 			= m_pFormat->wBitsPerSample == 16 ? 2 : 1;
	dmt.formattype				= FORMAT_WaveFormatEx;
	dmt.cbFormat				= sizeof(WAVEFORMATEX);
	dmt.pbFormat				= PBYTE(m_pFormat);

	for (DWORD i=0; i<dwFxCount; ++i)
	{
		CEffect* pEffect = NULL;
		BOOL fIsSend = FALSE;

		if (pFxDesc[i].guidDSFXClass == GUID_DSFX_SEND /*|| pFxDesc[i].guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE*/)
#ifdef ENABLE_SENDS
		{
			fIsSend = TRUE;
			pEffect = new CSendEffect(pFxDesc[i], m_pDsBuffer);
		}
#else
		hr = DSERR_INVALIDPARAM;
#endif // ENABLE_SENDS
		else
		{
			//fIsSend = FALSE;
			pEffect = new CDmoEffect(pFxDesc[i]);
		}

		if( pEffect == NULL )
		{
			hr = E_OUTOFMEMORY;
		}

		if (SUCCEEDED(hr))
			hr = pEffect->Initialize(&dmt);

		if (SUCCEEDED(hr))
		{
			m_fxList.AddTail(pEffect);
			pEffect->AddRef();
			m_fHasSend = m_fHasSend || fIsSend;
			if (pdwResultCodes)
				pdwResultCodes[i] = DSFXR_PRESENT;
		}
		else // We didn't get the effect for some reason.
		{
			if (pdwResultCodes)
				pdwResultCodes[i] = (hr == DSERR_SENDLOOP) ? DSFXR_SENDLOOP : DSFXR_UNKNOWN;
			if (SUCCEEDED(hrFirstFailure))
				hrFirstFailure = hr;
		}

		RELEASE(pEffect);  // It's managed by m_fxList now
	}

	hr = hrFirstFailure;

	m_hrInit = hr;
	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CEffectChain::Clone
 *
 *	Description:
 *		Creates a replica of this effect chain object (or should do!).
 *
 *	Arguments:
 *		FIXME - the arguments will change when we do a 'true' Clone.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffectChain::Clone"

HRESULT CEffectChain::Clone(CDirectSoundBufferConfig* pDSBConfigObj)
{
	HRESULT hr = DS_OK;
	//DPF_ENTER();

	//CHECK_WRITE_PTR(pDSBConfigObj);
	if( !IS_VALID_WRITE_PTR(pDSBConfigObj, sizeof( CDirectSoundBufferConfig ) ) )
	{
		return DSERR_INVALIDPARAM;
	}

	DMO_MEDIA_TYPE dmt;
	ZeroMemory(&dmt, sizeof dmt);
	dmt.majortype				= MEDIATYPE_Audio;
	dmt.subtype 				= MEDIASUBTYPE_PCM;
	dmt.bFixedSizeSamples		= TRUE;
	dmt.bTemporalCompression	= FALSE;
	dmt.lSampleSize 			= m_pFormat->wBitsPerSample == 16 ? 2 : 1;
	dmt.formattype				= FORMAT_WaveFormatEx;
	dmt.cbFormat				= sizeof(WAVEFORMATEX);
	dmt.pbFormat				= PBYTE(m_pFormat);

	CDirectSoundBufferConfig::CDXDMODesc *pDXDMOMap = pDSBConfigObj->m_pDXDMOMapList;
	for (; pDXDMOMap && SUCCEEDED(hr); pDXDMOMap = pDXDMOMap->pNext)
	{
		DSEFFECTDESC effectDesc;
		effectDesc.dwSize = sizeof effectDesc;
		effectDesc.dwFlags = pDXDMOMap->m_dwEffectFlags;
		effectDesc.guidDSFXClass = pDXDMOMap->m_guidDSFXClass;
		effectDesc.dwReserved2 = pDXDMOMap->m_dwReserved;
		effectDesc.dwReserved1 = NULL;

		CEffect* pEffect = NULL;

		// If this is a send effect, map the send buffer GUID to an actual buffer interface pointer
		if (pDXDMOMap->m_guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
			|| pDXDMOMap->m_guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
			)
		{
			CBuffer* pSendBuffer = m_pDsBuffer->m_pParentSink->FindBufferFromGUID(pDXDMOMap->m_guidSendBuffer);
			if (pSendBuffer)
			{
#ifndef _WIN64	// FIXME: temporary fix for Win64 build error
				effectDesc.dwReserved1 = DWORD(pSendBuffer);
				if(IsValidEffectDesc(&effectDesc, m_pDsBuffer))
				{
					CSendEffect* pSendEffect;
					pSendEffect = new CSendEffect(effectDesc, m_pDsBuffer);
					pEffect = pSendEffect;
					if( pEffect == NULL )
					{
						hr = E_OUTOFMEMORY;
					}
					if (SUCCEEDED(hr))
						hr = pEffect->Initialize(&dmt);
					if (SUCCEEDED(hr))
					{
						DSFXSend SendParam;
						SendParam.lSendLevel = pDXDMOMap->m_lSendLevel;
						hr = pSendEffect->SetAllParameters(&SendParam);
					}
				}
				else
#endif // _WIN64 
				{
					hr = DSERR_INVALIDPARAM;
				}
			}
			else
			{
				hr = DSERR_BADSENDBUFFERGUID;
			}
		}
		else
		{
			pEffect = new CDmoEffect(effectDesc);
			if( pEffect == NULL )
			{
				hr = E_OUTOFMEMORY;
			}
			// FIXME: Do we need to validate pEffect as well?
			if (SUCCEEDED(hr))
				hr = pEffect->Clone(pDXDMOMap->m_pMediaObject, &dmt);
		}

		if (SUCCEEDED(hr))
		{
			m_fxList.AddTail(pEffect);
			pEffect->AddRef();
			if (pDXDMOMap->m_guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
				|| pDXDMOMap->m_guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
				)
				m_fHasSend = TRUE;
		}

		RELEASE(pEffect);  // It's managed by m_fxList now
	}

	m_hrInit = hr;
	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CEffectChain::AcquireFxResources
 *
 *	Description:
 *		Allocates each effect to software (host processing) or hardware
 *		(processed by the audio device), according to its creation flags.
 *
 *	Arguments:
 *		(void)
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *				 Will return the partial success code DS_INCOMPLETE if any
 *				 effects that didn't obtain resources were marked OPTIONAL.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffectChain::AcquireFxResources"

HRESULT CEffectChain::AcquireFxResources(void)
{
	HRESULT hr = DS_OK;
	HRESULT hrTemp;
	//DPF_ENTER();

	// FIXME: Don't reacquire resources unnecessarily; only if (we have none / they're suboptimal?)

	// We loop through all the effects, even if some of them fail,
	// in order to return more complete information to the app

	for (POSITION pos = m_fxList.GetHeadPosition(); pos; m_fxList.GetNext(pos))
	{
		hrTemp = m_fxList.GetAt( pos )->AcquireFxResources();
		if (FAILED(hrTemp))
			hr = hrTemp;
		else if (hrTemp == DS_INCOMPLETE && SUCCEEDED(hr))
			hr = DS_INCOMPLETE;
	}

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CEffectChain::GetFxStatus
 *
 *	Description:
 *		Obtains the current effects' resource allocation status codes.
 *
 *	Arguments:
 &		DWORD* [out]: Receives the resource acquisition status codes
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffectChain::GetFxStatus"

HRESULT CEffectChain::GetFxStatus(LPDWORD pdwResultCodes)
{
	//DPF_ENTER();
	ASSERT(IS_VALID_WRITE_PTR(pdwResultCodes, GetFxCount() * sizeof(DWORD)));

	DWORD n = 0;
	for (POSITION pos = m_fxList.GetHeadPosition(); pos; m_fxList.GetNext(pos))
		pdwResultCodes[n++] = m_fxList.GetAt( pos )->m_fxStatus;

	//DPF_LEAVE_HRESULT(DS_OK);
	return DS_OK;
}


/***************************************************************************
 *
 *	CEffectChain::GetEffectInterface
 *
 *	Description:
 *		Searches the effect chain for an effect with a given COM CLSID and
 *		interface IID at a given index; returns a pointer to the interface.
 *
 *	Arguments:
 *		REFGUID [in]: CLSID required, or GUID_All_Objects for any CLSID.
 *		DWORD [in]: Index N of effect desired.	If the first argument was
 *					GUID_All_Objects, we will return the Nth effect in the
 *					chain; and if it was a specific CLSID, we return the
 *					Nth effect with that CLSID.
 *		REFGUID [in]: Interface to query for from the selected effect.
 *		VOID** [out]: Receives a pointer to the requested COM interface.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffectChain::GetEffectInterface"

HRESULT CEffectChain::GetEffectInterface(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
	HRESULT hr = DSERR_OBJECTNOTFOUND;
	//DPF_ENTER();

	BOOL fAllObjects = (guidObject == GUID_All_Objects);

	DWORD count = 0;
	for (POSITION pos = m_fxList.GetHeadPosition(); pos; m_fxList.GetNext(pos))
		if (fAllObjects || m_fxList.GetAt(pos)->m_fxDescriptor.guidDSFXClass == guidObject)
			if (count++ == dwIndex)
				break;

	if (pos)
		hr = m_fxList.GetAt(pos)->GetInterface(iidInterface, ppObject);

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}



/***************************************************************************
 *
 *	CEffectChain::NotifyRelease
 *
 *	Description:
 *		Informs this effect chain of the release of a MIXIN buffer.  We in
 *		turn traverse our list of effects informing them, so that if one of
 *		them was a send to the MIXIN buffer it can react appropriately.
 *
 *	Arguments:
 *		CBuffer* [in]: Departing MIXIN buffer.
 *
 *	Returns:
 *		(void)
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffectChain::NotifyRelease"

void CEffectChain::NotifyRelease(CBuffer* pDsBuffer)
{
	//DPF_ENTER();

	// Call NotifyRelease() on each effect
	for (POSITION pos = m_fxList.GetHeadPosition(); pos; m_fxList.GetNext(pos))
		m_fxList.GetAt(pos)->NotifyRelease(pDsBuffer);

	//DPF_LEAVE_VOID();
}


void CEffectChain::Render( short *pnBuffer,DWORD dwLength,REFERENCE_TIME refTimeStart )
{
	HRESULT hr;

	// Call Process() on each effect
	for (POSITION pos = m_fxList.GetHeadPosition(); pos; m_fxList.GetNext(pos))
	{
		hr = m_fxList.GetAt(pos)->Process(dwLength, (BYTE *)pnBuffer, refTimeStart, 0/*dwSendOffset*/, m_pFormat );
		if (FAILED(hr))
		{
			//DPF(DPFLVL_WARNING, "DMO "DPF_GUID_STRING" failed with %s", DPF_GUID_VAL(pFxNode->m_data->m_fxDescriptor.guidDSFXClass), HRESULTtoSTRING(hr));
			break;
		}
	}
}


/***************************************************************************
 *
 *	CEffectChain::FxDiscontinuity
 *
 *	Description:
 *		Calls Discontinuity() on each effect of the effect chain.
 *
 *	Arguments:
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffectChain::FxDiscontinuity"

HRESULT CEffectChain::FxDiscontinuity(void)
{
	HRESULT hr = DS_OK;
	//DPF_ENTER();

	//DPF_TIMING(DPFLVL_INFO, "Discontinuity on effects chain at 0x%08X", this);

	//if (GetCurrentProcessId() != this->GetOwnerProcessId())
		//DPF(DPFLVL_MOREINFO, "Bailing out because we're being called from a different process");
	/*else*/ for (POSITION pos = m_fxList.GetHeadPosition(); pos && SUCCEEDED(hr); m_fxList.GetNext(pos))
		m_fxList.GetAt(pos)->Discontinuity();

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CEffect::CEffect
 *
 *	Description:
 *		Object constructor.
 *
 *	Arguments:
 *		DSEFFECTDESC& [in]: Effect description structure.
 *
 *	Returns:
 *		(void)
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffect::CEffect"

CEffect::CEffect(DSEFFECTDESC& fxDescriptor)
{
	//DPF_ENTER();
	//DPF_CONSTRUCT(CEffect);

	// Keep local copy of effect description structure
	m_fxDescriptor = fxDescriptor;

	// Initialize defaults
	m_fxStatus = DSFXR_UNALLOCATED;

	m_cRef = 0;

	AddRef();
	//DPF_LEAVE_VOID();
}


STDMETHODIMP CEffect::QueryInterface(const IID &iid, void **ppv)
{
	if(iid == IID_IUnknown )
	{
		*ppv = static_cast<IUnknown*>(this);
	} 
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	
	return S_OK;
}

STDMETHODIMP_(ULONG) CEffect::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEffect::Release()
{
	if(!InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

/***************************************************************************
 *
 *	CEffect::AcquireFxResources
 *
 *	Description:
 *		Acquires the hardware or software resources necessary to perform
 *		this effect.  Currently a bit of a no-op, but will come into its
 *		own when we do hardware acceleration of effects.
 *
 *	Arguments:
 *		(void)
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CEffect::AcquireFxResources"

HRESULT CEffect::AcquireFxResources(void)
{
	HRESULT hr = DS_OK;
	//DPF_ENTER();

	if (m_fxStatus == DSFXR_FAILED || m_fxStatus == DSFXR_UNKNOWN)
	{
		hr = DSERR_INVALIDCALL;
	}
	else if (m_fxStatus == DSFXR_UNALLOCATED)
	{
		if (m_fxDescriptor.dwFlags & DSFX_LOCHARDWARE)
		{
			hr = DSERR_INVALIDPARAM;
			m_fxStatus = DSFXR_FAILED;
		}
		else
		{
			m_fxStatus = DSFXR_LOCSOFTWARE;
		}
	}

	// FIXME: this code is due for resurrection in DX8.1
	//	  if (FAILED(hr) && (m_fxDescriptor.dwFlags & DSFX_OPTIONAL))
	//		  hr = DS_INCOMPLETE;

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CDmoEffect::CDmoEffect
 *
 *	Description:
 *		Object constructor.
 *
 *	Arguments:
 *		DSEFFECTDESC& [in]: Effect description structure.
 *
 *	Returns:
 *		(void)
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CDmoEffect::CDmoEffect"

CDmoEffect::CDmoEffect(DSEFFECTDESC& fxDescriptor)
	: CEffect(fxDescriptor)
{
	//DPF_ENTER();
	//DPF_CONSTRUCT(CDmoEffect);

	m_pMediaObject = NULL;
	m_pMediaObjectInPlace = NULL;

	// Check initial values
	ASSERT(m_pMediaObject == NULL);
	ASSERT(m_pMediaObjectInPlace == NULL);

	//DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *	CDmoEffect::~CDmoEffect
 *
 *	Description:
 *		Object destructor.
 *
 *	Arguments:
 *		(void)
 *
 *	Returns:
 *		(void)
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CDmoEffect::~CDmoEffect"

CDmoEffect::~CDmoEffect(void)
{
	//DPF_ENTER();
	//DPF_DESTRUCT(CDmoEffect);

	// During shutdown, if the buffer hasn't been freed, these calls can
	// cause an access violation because the DMO DLL has been unloaded.
	try
	{
		if (m_pMediaObject)
			m_pMediaObject->Release();
		if (m_pMediaObjectInPlace)
			m_pMediaObjectInPlace->Release();
	}
	catch (...) {}
	
	//DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *	CDmoEffect::Initialize
 *
 *	Description:
 *		Create the DirectX Media Object corresponding to this effect.
 *
 *	Arguments:
 *		DMO_MEDIA_TYPE* [in]: Wave format etc. information used to
 *							  initialize our contained DMO.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CDmoEffect::Initialize"

HRESULT CDmoEffect::Initialize(DMO_MEDIA_TYPE* pDmoMediaType)
{
	//DPF_ENTER();

	HRESULT hr = CoCreateInstance(m_fxDescriptor.guidDSFXClass, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&m_pMediaObject);

	if (SUCCEEDED(hr))
	{
		//CHECK_COM_INTERFACE(m_pMediaObject);
		hr = m_pMediaObject->QueryInterface(IID_IMediaObjectInPlace, (void**)&m_pMediaObjectInPlace);
		if (SUCCEEDED(hr))
		{
			//CHECK_COM_INTERFACE(m_pMediaObjectInPlace);
		}
		else
		{
			ASSERT(m_pMediaObjectInPlace == NULL);
			//DPF(DPFLVL_INFO, "Failed to obtain the IMediaObjectInPlace interface on effect "
			//	  DPF_GUID_STRING " (%s)", DPF_GUID_VAL(m_fxDescriptor.guidDSFXClass), HRESULTtoSTRING(hr));
		}

		// Throw away the previous return code - we can live without IMediaObjectInPlace
		hr = m_pMediaObject->SetInputType(0, pDmoMediaType, 0);
		if (SUCCEEDED(hr))
			hr = m_pMediaObject->SetOutputType(0, pDmoMediaType, 0);
	}

	if (FAILED(hr))
	{
		RELEASE(m_pMediaObject);
		RELEASE(m_pMediaObjectInPlace);
	}

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CDmoEffect::Clone
 *
 *	Description:
 *		Creates a replica of this DMO effect object (or should do!).
 *
 *	Arguments:
 *		FIXME - the arguments will change when we do a 'true' Clone.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CDmoEffect::Clone"

HRESULT CDmoEffect::Clone(IMediaObject *pMediaObject, DMO_MEDIA_TYPE* pDmoMediaType)
{
	//DPF_ENTER();

	IMediaObjectInPlace *pMediaObjectInPlace = NULL;

	HRESULT hr = pMediaObject->QueryInterface(IID_IMediaObjectInPlace, (void**)&pMediaObjectInPlace);
	if (SUCCEEDED(hr))
	{
		//CHECK_COM_INTERFACE(pMediaObjectInPlace);
		hr = pMediaObjectInPlace->Clone(&m_pMediaObjectInPlace);
		pMediaObjectInPlace->Release();

		if (SUCCEEDED(hr))
		{
			//CHECK_COM_INTERFACE(m_pMediaObjectInPlace);
			hr = m_pMediaObjectInPlace->QueryInterface(IID_IMediaObject, (void**)&m_pMediaObject);
		}
		if (SUCCEEDED(hr))
		{
			//CHECK_COM_INTERFACE(m_pMediaObject);
			hr = m_pMediaObject->SetInputType(0, pDmoMediaType, 0);
		}
		if (SUCCEEDED(hr))
		{
			hr = m_pMediaObject->SetOutputType(0, pDmoMediaType, 0);
		}
	}

	if (FAILED(hr))
	{
		RELEASE(m_pMediaObject);
		RELEASE(m_pMediaObjectInPlace);
	}

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CDmoEffect::Process
 *
 *	Description:
 *		Actually invoke effect processing on our contained DMO.
 *
 *	Arguments:
 *		DWORD [in]: Number of audio bytes to process.
 *		BYTE* [in, out]: Pointer to start of audio buffer to process.
 *		REFERENCE_TIME [in]: Timestamp of first sample to be processed
 *		DWORD [ignored]: Offset of a wrapped audio region.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CDmoEffect::Process"

HRESULT CDmoEffect::Process(DWORD dwBytes, BYTE *pAudio, REFERENCE_TIME rtTime, DWORD /*ignored*/, LPWAVEFORMATEX pFormat)
{
	HRESULT hr = DS_OK;
	//DPF_ENTER();

	// if (m_fxStatus == DSFXR_LOCSOFTWARE) ...
	// FIXME: We may need to handle hardware and software buffers differently here.

	if (m_pMediaObjectInPlace)	// If the DMO provides this interface, use it
	{
		static const int nPeriod = 3;

		// We divide the region to be processed into nPeriod-ms pieces so that the
		// DMO's parameter curve will have a nPeriod-ms update period (manbug 36228)

		DWORD dwStep = MsToBytes(nPeriod, pFormat);
		for (DWORD dwCur = 0; dwCur < dwBytes && SUCCEEDED(hr); dwCur += dwStep)
		{
			if (dwStep > dwBytes - dwCur)
				dwStep = dwBytes - dwCur;

			hr = m_pMediaObjectInPlace->Process(dwStep, pAudio + dwCur, rtTime, DMO_INPLACE_NORMAL);

			rtTime += MsToRefTime(nPeriod);
		}
	}
	else  // FIXME: Support for IMediaObject-only DMOs goes here
	{
		hr = DSERR_GENERIC;
	}

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CSendEffect::CSendEffect
 *
 *	Description:
 *		Object constructor.
 *
 *	Arguments:
 *		DSEFFECTDESC& [in]: Effect description structure.
 *		CBuffer* [in]: Pointer to our source buffer.
 *
 *	Returns:
 *		(void)
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CSendEffect::CSendEffect"

CSendEffect::CSendEffect(DSEFFECTDESC& fxDescriptor, CBuffer* pSrcBuffer)
	: CEffect(fxDescriptor)
{
	//DPF_ENTER();
	//DPF_CONSTRUCT(CSendEffect);

	// Double check we really are a send effect
#ifdef ENABLE_I3DL2SOURCE
	ASSERT(fxDescriptor.guidDSFXClass == GUID_DSFX_SEND || fxDescriptor.guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE);
#else
	ASSERT(fxDescriptor.guidDSFXClass == GUID_DSFX_SEND);
#endif

#ifndef _WIN64	// FIXME: temporary fix for Win64 build error
	// Figure out our destination buffer

	CBuffer* pDestBuffer = (CBuffer*)fxDescriptor.dwReserved1;
	//CHECK_WRITE_PTR(pDestBuffer);
	if( !IS_VALID_WRITE_PTR(pDestBuffer, sizeof( CBuffer ) ) )
	{
		m_pSrcBuffer = NULL;
		m_pDestBuffer = NULL;
		return;// DSERR_INVALIDPARAM;
	}

	// Set up the initial send configuration
	m_impDSFXSend.m_pObject = this;
	m_pMixFunction = pSrcBuffer->Format()->wBitsPerSample == 16 ? Mix16bit : Mix8bit;
	m_mixMode = pSrcBuffer->Format()->nChannels == pDestBuffer->Format()->nChannels ? OneToOne : MonoToStereo;
	m_pSrcBuffer = pSrcBuffer;
	m_pDestBuffer = pDestBuffer;
	m_lSendLevel = DSBVOLUME_MAX;
	m_dwAmpFactor = 0xffff;
#endif // _WIN64 

#ifdef ENABLE_I3DL2SOURCE
	ASSERT(m_pI3DL2SrcDMO == NULL);
	ASSERT(m_pI3DL2SrcDMOInPlace == NULL);
#endif

	//DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *	CSendEffect::~CSendEffect
 *
 *	Description:
 *		Object destructor.
 *
 *	Arguments:
 *		(void)
 *
 *	Returns:
 *		(void)
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CSendEffect::~CSendEffect"

CSendEffect::~CSendEffect()
{
	//DPF_ENTER();
	//DPF_DESTRUCT(CSendEffect);

	// Unregister in our destination buffer's list of senders
	// (as long as the buffer hasn't been released already)

	// Only needed for synchronizing DSound buffers
	//if (m_pDestBuffer)
	//	m_pDestBuffer->UnregisterSender(m_pSrcBuffer);

#ifdef ENABLE_I3DL2SOURCE
	// During shutdown, if the buffer hasn't been freed, these calls can
	// cause an access violation because the DMO DLL has been unloaded.
	try
	{
		if (m_pI3DL2SrcDMO)
			m_pI3DL2SrcDMO->Release();
		if (m_pI3DL2SrcDMOInPlace)
			m_pI3DL2SrcDMOInPlace->Release();
	}
	catch (...) {}
#endif

	//DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *	CSendEffect::Initialize
 *
 *	Description:
 *		Initializes the send effect object.
 *
 *	Arguments:
 *		DMO_MEDIA_TYPE* [in]: Wave format etc. information used to initialize
 *							  our contained I3DL2 source DMO, if we have one.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CSendEffect::Initialize"

HRESULT CSendEffect::Initialize(DMO_MEDIA_TYPE* pDmoMediaType)
{
	//DPF_ENTER();

	// First we need to detect any send loops
	HRESULT hr = m_pSrcBuffer->FindSendLoop(m_pDestBuffer);

#ifdef ENABLE_I3DL2SOURCE
	if (SUCCEEDED(hr) && m_fxDescriptor.guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE)
	{
		hr = CoCreateInstance(GUID_DSFX_STANDARD_I3DL2SOURCE, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&m_pI3DL2SrcDMO);
		if (SUCCEEDED(hr))
		{
			//CHECK_COM_INTERFACE(m_pI3DL2SrcDMO);
			hr = m_pI3DL2SrcDMO->QueryInterface(IID_IMediaObjectInPlace, (void**)&m_pI3DL2SrcDMOInPlace);
			//if (SUCCEEDED(hr))
			//	  CHECK_COM_INTERFACE(m_pI3DL2SrcDMOInPlace);
			//else
			//	  DPF(DPFLVL_WARNING, "Failed to obtain the IMediaObjectInPlace interface on the STANDARD_I3DL2SOURCE effect");

			// Throw away the return code - we can live without IMediaObjectInPlace

			// FIXME: maybe this will change when we restrict I3DL2 to mono buffers
			// and/or change the way the I3DL2 DMO returns two output streams.

			// If we have a mono buffer, special-case the I3DL2 DMO to use stereo
			BOOL fTweakedMediaType = FALSE;
			LPWAVEFORMATEX pFormat = LPWAVEFORMATEX(pDmoMediaType->pbFormat);
			if (pFormat->nChannels == 1)
			{
				fTweakedMediaType = TRUE;
				pFormat->nChannels = 2;
				pFormat->nBlockAlign *= 2;
				pFormat->nAvgBytesPerSec *= 2;
			}

			// Finally set up the (possibly tweaked) media type on the DMO
			hr = m_pI3DL2SrcDMO->SetInputType(0, pDmoMediaType, 0);
			if (SUCCEEDED(hr))
				hr = m_pI3DL2SrcDMO->SetOutputType(0, pDmoMediaType, 0);

			// Undo changes to the wave format if necessary
			if (fTweakedMediaType)
			{
				pFormat->nChannels = 1;
				pFormat->nBlockAlign /= 2;
				pFormat->nAvgBytesPerSec /= 2;
			}

			if (SUCCEEDED(hr))
			{
				// OK, we now need to hook-up the reverb source to its environment.
				// There is a special interface on the I3DL2SourceDMO just for this.

				LPDIRECTSOUNDFXI3DL2SOURCEENV pSrcEnv = NULL;
				LPDIRECTSOUNDFXI3DL2REVERB pEnvReverb = NULL;

				HRESULT hrTemp = m_pI3DL2SrcDMO->QueryInterface(IID_IDirectSoundFXI3DL2SourceEnv, (void**)&pSrcEnv);
				if (SUCCEEDED(hrTemp))
				{
					//CHECK_COM_INTERFACE(pSrcEnv);
					hrTemp = m_pDestBuffer->GetObjectInPath(GUID_DSFX_STANDARD_I3DL2REVERB, 0, IID_IDirectSoundFXI3DL2Reverb, (void**)&pEnvReverb);
				}

				if (SUCCEEDED(hrTemp))
				{
					//CHECK_COM_INTERFACE(pEnvReverb);
					hrTemp = pSrcEnv->SetEnvironmentReverb(pEnvReverb);
				}

				//if (SUCCEEDED(hrTemp))
				//	  DPF(DPFLVL_INFO, "Connected the I3DL2 source to its environment successfully");

				// We're done with these interfaces.  The lifetime of the two buffers is managed
				// by DirectSound.	It will handle releasing the destination buffer.  We do not
				// hold a reference to it, and neither does the I3DL2 Source DMO.
				RELEASE(pSrcEnv);
				RELEASE(pEnvReverb);
			}
		}

		if (FAILED(hr))
		{
			RELEASE(m_pI3DL2SrcDMO);
			RELEASE(m_pI3DL2SrcDMOInPlace);
		}
	}
#endif

	// Register in our destination buffer's list of senders
	// Only needed for synchronizing DSound buffers
	//if (SUCCEEDED(hr))
	//	m_pDestBuffer->RegisterSender(m_pSrcBuffer);
	
	// Save the effect creation status for future reference
	m_fxStatus = SUCCEEDED(hr)				? DSFXR_UNALLOCATED :
				 hr == REGDB_E_CLASSNOTREG	? DSFXR_UNKNOWN 	:
				 DSFXR_FAILED;

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CSendEffect::Clone
 *
 *	Description:
 *		Creates a replica of this send effect object (or should do!).
 *
 *	Arguments:
 *		FIXME - the arguments will change when we do a 'true' Clone.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CSendEffect::Clone"

HRESULT CSendEffect::Clone(IMediaObject*, DMO_MEDIA_TYPE*)
{
	HRESULT hr = DS_OK;
	//DPF_ENTER();

	// FIXME: todo - some code currently in CEffectChain::Clone() should move here.

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CSendEffect::CImpDirectSoundFXSend::QueryInterface
 *
 *	Description:
 *		Helper QueryInterface() method for our IDirectSoundFXSend interface.
 *
 *	Arguments:
 *		REFIID [in]: IID of interface desired.
 *		VOID** [out]: Receives pointer to COM interface.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CSendEffect::CImpDirectSoundFXSend::QueryInterface"

HRESULT CSendEffect::CImpDirectSoundFXSend::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
	HRESULT hr = E_NOINTERFACE;
	//DPF_ENTER();

	// This should really be handled by our glorious COM interface manager, but... ;-)

	//CHECK_WRITE_PTR(pDSBConfigObj);
	if( !IS_VALID_WRITE_PTR(ppvObj, sizeof( LPVOID ) ) )
	{
		hr = E_INVALIDARG;
	}
#ifdef ENABLE_I3DL2SOURCE
	else if (m_pObject->m_pI3DL2SrcDMO)  // We are an I3DL2 Source - pass call to the DMO
	{
		//DPF(DPFLVL_INFO, "Forwarding QueryInterface() call to the I3DL2 Source DMO");
		hr = m_pObject->m_pI3DL2SrcDMO->QueryInterface(riid, ppvObj);
	}
#endif
	else if (riid == IID_IUnknown)
	{
		*ppvObj = (IUnknown*)this;
		m_pObject->AddRef();
		hr = S_OK;
	}
	else if (riid == IID_IDirectSoundFXSend)
	{
		*ppvObj = (IDirectSoundFXSend*)this;
		m_pObject->AddRef();
		hr = S_OK;
	}

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CSendEffect::SetAllParameters
 *
 *	Description:
 *		Sets all our parameters - i.e., our send level.
 *
 *	Arguments:
 *		DSFXSend* [in]: Pointer to send parameter structure.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CSendEffect::SetAllParameters"

HRESULT CSendEffect::SetAllParameters(LPCDSFXSend pcDsFxSend)
{
	HRESULT hr;
	//DPF_ENTER();

	if( !IS_VALID_READ_PTR(pcDsFxSend, sizeof( DSFXSend ) ) )
	{
		//RPF(DPFLVL_ERROR, "Invalid pcDsFxSend pointer");
		hr = DSERR_INVALIDPARAM;
	}
	else if (pcDsFxSend->lSendLevel < DSBVOLUME_MIN || pcDsFxSend->lSendLevel > DSBVOLUME_MAX)
	{
		//RPF(DPFLVL_ERROR, "Volume out of bounds");
		hr = DSERR_INVALIDPARAM;
	}
	else
	{
		m_lSendLevel = pcDsFxSend->lSendLevel;
		m_dwAmpFactor = DBToAmpFactor(m_lSendLevel);
		hr = DS_OK;
	}

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CSendEffect::GetAllParameters
 *
 *	Description:
 *		Gets all our parameters - i.e., our send level.
 *
 *	Arguments:
 *		DSFXSend* [out]: Receives send parameter structure.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CSendEffect::GetAllParameters"

HRESULT CSendEffect::GetAllParameters(LPDSFXSend pDsFxSend)
{
	HRESULT hr;
	//DPF_ENTER();

	if( !IS_VALID_WRITE_PTR(pDsFxSend, sizeof( DSFXSend ) ) )
	{
		//RPF(DPFLVL_ERROR, "Invalid pDsFxSend pointer");
		hr = DSERR_INVALIDPARAM;
	}
	else
	{
		pDsFxSend->lSendLevel = m_lSendLevel;
		hr = DS_OK;
	}

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	CSendEffect::NotifyRelease
 *
 *	Description:
 *		Informs this send effect of the release of a MIXIN buffer.	If it
 *		happens to be our destination buffer, we record that it's gone.
 *
 *	Arguments:
 *		CBuffer* [in]: Departing MIXIN buffer.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CSendEffect::NotifyRelease"

void CSendEffect::NotifyRelease(CBuffer* pDsBuffer)
{
	//DPF_ENTER();

	// Check if it was our destination buffer that was released
	if (pDsBuffer == m_pDestBuffer)
	{
		m_pDestBuffer = NULL;
		m_fxStatus = DSFXR_FAILED;
	}

	//DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *	CSendEffect::Process
 *
 *	Description:
 *		Handles mixing data from our source buffer into its destination,
 *		and invokes effect processing on the I3DL2 source DMO if necessary.
 *
 *	Arguments:
 *		DWORD [in]: Number of audio bytes to process.
 *		BYTE* [in, out]: Pointer to start of audio buffer to process.
 *		REFERENCE_TIME [in]: Timestamp of first sample to be processed
 *		DWORD [in]: Offset of a wrapped audio region.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "CSendEffect::Process"

HRESULT CSendEffect::Process(DWORD dwBytes, BYTE *pAudio, REFERENCE_TIME /*rtTime*/, DWORD /*dwSendOffset*/, LPWAVEFORMATEX /*ignored*/)
{
	//DWORD dwDestSliceBegin, dwDestSliceEnd;
	HRESULT hr = DS_OK;
	//DPF_ENTER();

	// Pointer to the audio data we'll actually send; this pointer
	// may be modified below if this is an I3DL2 send
	BYTE* pSendAudio = pAudio;

	// Check whether our source buffer is active.  If it isn't,
	// we must be pre-rolling FX, so we don't perform the send.
	BOOL fPlaying = m_pSrcBuffer->IsPlaying();

	// If the source buffer is active, check the destination too.
	// (Note: if it has been released, m_pDestBuffer will be NULL)
	BOOL fSending = fPlaying && m_pDestBuffer && m_pDestBuffer->IsPlaying();

#ifdef ENABLE_I3DL2SOURCE
	// OPTIMIZE: replace the CopyMemorys below with BYTE, WORD or DWORD
	// assignments, since we only support nBlockSizes of 1, 2 or 4...
	// But hopefully this code can disappear altogether (see bug 40236).

	// First call the I3DL2 DMO if this is an I3DL2 Source effect
	if (m_pI3DL2SrcDMOInPlace)
	{
		// If we're processing a mono buffer, an ugly hack is required; copying
		// the data into the L and R channels of a temporary stereo buffer, so
		// we have room for the two output streams returned by the I3DL2 DMO.

		WORD nBlockSize = m_pSrcBuffer->Format()->nBlockAlign;

		if (m_pSrcBuffer->Format()->nChannels == 1)
		{
			hr = MEMALLOC_A_HR(pSendAudio, BYTE, 2*dwBytes);
			if (SUCCEEDED(hr))
			{
				for (DWORD i=0; i<dwBytes; i += nBlockSize)
				{
					CopyMemory(pSendAudio + 2*i,			  pAudio + i, nBlockSize); // L channel
					CopyMemory(pSendAudio + 2*i + nBlockSize, pAudio + i, nBlockSize); // R channel
				}
				hr = m_pI3DL2SrcDMOInPlace->Process(dwBytes, pSendAudio, rtTime, DMO_INPLACE_NORMAL);
			}

			if (SUCCEEDED(hr))
			{
				// Now we extract the two output streams from the data returned;
				// the direct path goes back to pAudio, and the reflected path
				// goes to the first half of pSendAudio.
				for (DWORD i=0; i<dwBytes; i += nBlockSize)
				{
					CopyMemory(pAudio + i, pSendAudio + 2*i, nBlockSize);
					if (fSending)  // Needn't preserve the reflected audio if we aren't sending it anywhere
						CopyMemory(pSendAudio + i, pSendAudio + 2*i + nBlockSize, nBlockSize);
				}
			}
		}
		else // Processing a stereo buffer
		{
			hr = m_pI3DL2SrcDMOInPlace->Process(dwBytes, pAudio, rtTime, DMO_INPLACE_NORMAL);

			if (SUCCEEDED(hr))
				hr = MEMALLOC_A_HR(pSendAudio, BYTE, dwBytes);

			if (SUCCEEDED(hr))
			{
				// Extract the output streams and stereoize them at the same time
				for (DWORD i=0; i<dwBytes; i += nBlockSize)
				{
					if (fSending)  // Needn't preserve the reflected audio if we aren't sending it anywhere
					{
						// Copy the R channel from pAudio into both channels of pSendAudio
						CopyMemory(pSendAudio + i,				  pAudio + i + nBlockSize/2, nBlockSize/2);
						CopyMemory(pSendAudio + i + nBlockSize/2, pAudio + i + nBlockSize/2, nBlockSize/2);
					}
					// Copy pAudio's L channel onto its R channel
					CopyMemory(pAudio + i + nBlockSize/2, pAudio + i, nBlockSize/2);
				}
			}
		}
	}
#endif

	// Now we handle the actual send
	if (SUCCEEDED(hr) && fSending)
	{
		m_pMixFunction(pSendAudio, (BYTE*)m_pDestBuffer->m_pExtraBuffer, dwBytes, m_dwAmpFactor, m_mixMode);
	}

#ifdef ENABLE_I3DL2SOURCE
	if (pSendAudio != pAudio)
		MEMFREE(pSendAudio);
#endif

	//DPF_LEAVE_HRESULT(hr);
	return hr;
}


/***************************************************************************
 *
 *	Mix8bit
 *
 *	Description:
 *		Primitive 8-bit mixing function.  Attenuates source audio by a
 *		given factor, adds it to the destination audio, and clips.
 *
 *	Arguments:
 *		VOID* [in]: Pointer to source audio buffer.
 *		VOID* [in, out]: Pointer to destination audio buffer.
 *		DWORD [in]: Number of bytes to mix.
 *		DWORD [in]: Amplification factor (in 1/65536 units).
 *		MIXMODE: Whether to double the channel data or not.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "Mix8bit"

static void Mix8bit(PVOID pSrc, PVOID pDest, DWORD dwBytes, DWORD dwAmpFactor, MIXMODE mixMode)
{
	unsigned char* pSampSrc = (unsigned char*)pSrc;
	unsigned char* pSampDest = (unsigned char*)pDest;
	//DPF_ENTER();

	while (dwBytes--)
	{
		INT sample = (INT(*pSampSrc++) - 0x80) * INT(dwAmpFactor) / 0xffff;
		INT mixedSample = sample + *pSampDest;
		if (mixedSample > 0xff) mixedSample = 0xff;
		else if (mixedSample < 0) mixedSample = 0;
		*pSampDest++ = unsigned char(mixedSample);
		if (mixMode == MonoToStereo)
		{
			INT mixedSample = sample + *pSampDest;
			if (mixedSample > 0xff) mixedSample = 0xff;
			else if (mixedSample < 0) mixedSample = 0;
			*pSampDest++ = unsigned char(mixedSample);
		}
	}

	//DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *	Mix16bit
 *
 *	Description:
 *		Primitive 16-bit mixing function.  Attenuates source audio by a
 *		given factor, adds it to the destination audio, and clips.
 *
 *	Arguments:
 *		VOID* [in]: Pointer to source audio buffer.
 *		VOID* [in, out]: Pointer to destination audio buffer.
 *		DWORD [in]: Number of bytes to mix.
 *		DWORD [in]: Amplification factor (in 1/65536 units).
 *		MIXMODE: Whether to double the channel data or not.
 *
 *	Returns:
 *		HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "Mix16bit"

static void Mix16bit(PVOID pSrc, PVOID pDest, DWORD dwBytes, DWORD dwAmpFactor, MIXMODE mixMode)
{
	DWORD dwSamples = dwBytes / 2;
	short* pSampSrc = (short*)pSrc;
	short* pSampDest = (short*)pDest;
	//DPF_ENTER();

	while (dwSamples--)
	{
		INT sample = INT(*pSampSrc++) * INT(dwAmpFactor) / 0xffff;
		INT mixedSample = sample + *pSampDest;
		if (mixedSample > 32767) mixedSample = 32767;
		else if (mixedSample < -32768) mixedSample = -32768;
		*pSampDest++ = short(mixedSample);
		if (mixMode == MonoToStereo)
		{
			INT mixedSample = sample + *pSampDest;
			if (mixedSample > 32767) mixedSample = 32767;
			else if (mixedSample < -32768) mixedSample = -32768;
			*pSampDest++ = short(mixedSample);
		}
	}

	//DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *	IsValidEffectDesc
 *
 *	Description:
 *		Determines if the given effect descriptor structure is valid for
 *		the given secondary buffer.
 *
 *	Arguments:
 *		DSEFFECTDESC* [in]: Effect descriptor to be validated.
 *		CBuffer* [in]: Host buffer for the effect.
 *
 *	Returns:
 *		BOOL: TRUE if the descriptor is valid.
 *
 ***************************************************************************/

//#undef DPF_FNAME
//#define DPF_FNAME "IsValidEffectDesc"

BOOL IsValidEffectDesc(LPCDSEFFECTDESC pEffectDesc, CBuffer* pDsBuffer)
{
	BOOL fValid = TRUE;
	//DPF_ENTER();

	if (pEffectDesc->dwSize != sizeof(DSEFFECTDESC))
	{
		//RPF(DPFLVL_ERROR, "Invalid DSEFFECTDESC structure size");
		fValid = FALSE;
	}
	else if (pEffectDesc->dwReserved2 != 0)
	{
		//RPF(DPFLVL_ERROR, "Reserved fields in the DSEFFECTDESC structure must be 0");
		fValid = FALSE;
	}

	//if (fValid)
	//{
	//	fValid = IsValidFxFlags(pEffectDesc->dwFlags);
	//}

	if (fValid)
	{
		BOOL fSendEffect = pEffectDesc->guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
						   || pEffectDesc->guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
						   ;
		if (!fSendEffect && pEffectDesc->dwReserved1)
		{
			//RPF(DPFLVL_ERROR, "lpSendBuffer should only be specified with GUID_DSFX_SEND"
#ifdef ENABLE_I3DL2SOURCE
			//				  " or GUID_DSFX_STANDARD_I3DL2SOURCE"
#endif
			//);
			fValid = FALSE;
		}
		else if (fSendEffect)
		{
			//CImpDirectSoundBuffer<CBuffer>* pImpBuffer =
			//	(CImpDirectSoundBuffer<CBuffer>*) (pEffectDesc->dwReserved1);
			CBuffer *pBuffer = (CBuffer*)pEffectDesc->dwReserved1;
			LPWAVEFORMATEX pSrcWfx, pDstWfx;

			if (!pBuffer)
			{
				//RPF(DPFLVL_ERROR, "lpSendBuffer must be specified for GUID_DSFX_SEND"
#ifdef ENABLE_I3DL2SOURCE
				//				  " and GUID_DSFX_STANDARD_I3DL2SOURCE"
#endif
				//);
				fValid = FALSE;
			}
			//else if (!IS_VALID_IDIRECTSOUNDBUFFER(pImpBuffer))
			else if (!IS_VALID_WRITE_PTR(pBuffer, sizeof( CBuffer ) ) )
			{
				//RPF(DPFLVL_ERROR, "lpSendBuffer points to an invalid DirectSound buffer");
				fValid = FALSE;
			}
			else if (!(pBuffer->GetBufferType() & DSBCAPS_MIXIN))
			{
				//RPF(DPFLVL_ERROR, "lpSendBuffer must point to a DSBCAPS_MIXIN buffer");
				fValid = FALSE;
			}
			/*
			else if (pBuffer->GetDirectSound() != pDsBuffer->GetDirectSound())
			{
				//RPF(DPFLVL_ERROR, "Can't send to a buffer on a different DirectSound object");
				fValid = FALSE;
			}
			*/
			else if ((pSrcWfx = pDsBuffer->Format())->nSamplesPerSec !=
					 (pDstWfx = pBuffer->Format())->nSamplesPerSec)
			{
				//RPF(DPFLVL_ERROR, "The buffer sent to must have the same nSamplesPerSec as the sender");
				fValid = FALSE;
			}
			else if (pSrcWfx->wBitsPerSample != pDstWfx->wBitsPerSample)
			{
				//RPF(DPFLVL_ERROR, "The buffer sent to must have the same wBitsPerSample as the sender");
				fValid = FALSE;
			}
			else if ((pSrcWfx->nChannels > 2 || pDstWfx->nChannels > 2) && (pSrcWfx->nChannels != pDstWfx->nChannels))
			{
				//RPF(DPFLVL_ERROR, "If either the send buffer or the receive buffer has more than two channels, the number of channels must match");
				fValid = FALSE;
			}
			else if (pSrcWfx->nChannels == 2 && pDstWfx->nChannels == 1)
			{
				//RPF(DPFLVL_ERROR, "You can't send from a stereo buffer to a mono buffer");
				fValid = FALSE;
			}
			else if (pEffectDesc->dwFlags & (DSFX_LOCSOFTWARE | DSFX_LOCHARDWARE))
			{
				//RPF(DPFLVL_ERROR, "Location flags should not be specified for GUID_DSFX_SEND"
#ifdef ENABLE_I3DL2SOURCE
				//				  " or GUID_DSFX_STANDARD_I3DL2SOURCE"
#endif
				//);
				fValid = FALSE;
			}
		}
	}

	//DPF_LEAVE(fValid);
	return fValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\phoneyds.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//	    PhoneyDS.h

#ifndef __PHONEY_DS__
#define __PHONEY_DS__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <math.h>
#include <mmsystem.h>
#include "dsoundp.h"
#include "dmusicc.h"
#include "dmusics.h"
#include "cclock.h"
#include "PLClock.h"
#include "dslink.h"
#include "audiosink.h"


class CPhoneyDSound : public IDirectSound8, public IDirectSoundPrivate 
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSound methods
    STDMETHODIMP CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) ;
    STDMETHODIMP GetCaps(LPDSCAPS pDSCaps) ;
    STDMETHODIMP DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) ;
    STDMETHODIMP SetCooperativeLevel(HWND hwnd, DWORD dwLevel) ;
    STDMETHODIMP Compact() ;
    STDMETHODIMP GetSpeakerConfig(LPDWORD pdwSpeakerConfig) ;
    STDMETHODIMP SetSpeakerConfig(DWORD dwSpeakerConfig) ;
    STDMETHODIMP Initialize(LPCGUID pcGuidDevice) ;
    STDMETHODIMP VerifyCertification(LPDWORD pdwCertified) ;

    // IDirectSoundPrivate methods
    STDMETHODIMP AllocSink(LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) ;

	HRESULT GetFormat( LPWAVEFORMATEX pwfxFormat );
	HANDLE GetFileHandle( void );
	void SetFileHandle( HANDLE hFile );

    CPhoneyDSound();
    ~CPhoneyDSound();
private:
    long				m_cRef;
	bool				m_fFormatSet;
	WAVEFORMATEX		m_wfFormat;
	HANDLE				m_hFile;
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage access.
};
#endif // __PHONEY_DS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\phoneyds.cpp ===
#include "stdafx.h"
#include "phoneyds.h"


CPhoneyDSound::CPhoneyDSound()
{
    m_cRef = 0;
	m_fFormatSet = false;
	m_hFile = INVALID_HANDLE_VALUE;
	::InitializeCriticalSection( &m_CriticalSection );
	AddRef();
}

CPhoneyDSound::~CPhoneyDSound()
{
	::DeleteCriticalSection( &m_CriticalSection );
}

STDMETHODIMP CPhoneyDSound::QueryInterface(const IID &iid, void **ppv)
{
    if(iid == IID_IUnknown || iid == IID_IDirectSound || iid == IID_IDirectSound8)
    {
        *ppv = static_cast<IDirectSound8*>(this);
    } 
    else if(iid == IID_IDirectSoundPrivate) 
    {
        *ppv = static_cast<IDirectSoundPrivate*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CPhoneyDSound::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CPhoneyDSound::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CPhoneyDSound::CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) 
{ 
    CBuffer *pBuffer = new CBuffer(NULL,NULL,NULL,0,GUID_NULL);
    if (pBuffer)
    {
        pBuffer->QueryInterface(IID_IDirectSoundBuffer,(void **)ppDSBuffer);
        return S_OK;
    }
    return E_OUTOFMEMORY; 
}

STDMETHODIMP CPhoneyDSound::GetCaps(LPDSCAPS pDSCaps) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::SetCooperativeLevel(HWND hwnd, DWORD dwLevel) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::Compact() 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::GetSpeakerConfig(LPDWORD pdwSpeakerConfig) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::SetSpeakerConfig(DWORD dwSpeakerConfig) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::Initialize(LPCGUID pcGuidDevice) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPhoneyDSound::VerifyCertification(LPDWORD pdwCertified) 
{ 
    return E_NOTIMPL; 
}

// IDirectSoundPrivate methods
STDMETHODIMP CPhoneyDSound::AllocSink(LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) 
{ 
    CAudioSink *pSink = new CAudioSink(pwfxFormat);
    if (pSink)
    {
		if( pwfxFormat )
		{
			m_wfFormat = *pwfxFormat;
			if( m_wfFormat.nChannels == 1 )
			{
				m_wfFormat.nChannels = 2;
				m_wfFormat.nBlockAlign *= 2;
				m_wfFormat.nAvgBytesPerSec *= 2;
			}
			m_fFormatSet = true;
		}
        return pSink->QueryInterface(IID_IDirectSoundConnect,(void **)ppSinkConnect);
    }
    return E_OUTOFMEMORY;
}

HRESULT CPhoneyDSound::GetFormat( LPWAVEFORMATEX pwfxFormat )
{
	if( pwfxFormat == NULL )
	{
		return E_POINTER;
	}

	if( !m_fFormatSet )
	{
		return E_UNEXPECTED;
	}

	*pwfxFormat = m_wfFormat;

	return S_OK;
}

HANDLE CPhoneyDSound::GetFileHandle( void )
{
	HANDLE hFile;
    ::EnterCriticalSection(&m_CriticalSection);
	hFile = m_hFile;
    ::LeaveCriticalSection(&m_CriticalSection);
	return hFile;
}

void CPhoneyDSound::SetFileHandle( HANDLE hFile )
{
    ::EnterCriticalSection(&m_CriticalSection);
	m_hFile = hFile;
    ::LeaveCriticalSection(&m_CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\dsbufcfg.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbufcfg.h
 *  Content:    DirectSound Buffer Descriptor.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/17/99    jimge   Created.
 *  11/24/99    petchey Completed implementation.
 *
 ***************************************************************************/

#ifndef __DSBUFCFG_H__
#define __DSBUFCFG_H__

#ifdef __cplusplus

//>>>>>>>>>>>>>> should this be inside a DSOUND id header?
#include "dmusicf.h"

#define DMUS_E_INVALID_FX_HDR E_FAIL
#define DMUS_E_FX_HDR_NOT_FIRST_CK E_FAIL

#define DSBC_PARTIALLOAD_S_OK   (1 << 1)
#define DSBC_PARTIALLOAD_E_FAIL (1 << 2)

class CRiffParser;
class CEffectChain;
class CBuffer;
interface IMediaObject;

enum {
    DSBCFG_DSBD = 0x00000001,
    DSBCFG_BSID = 0x00000002,
    DSBCFG_DS3D = 0x00000004,
    DSBCFG_DSFX = 0x00000008,
};

class CDirectSoundBufferConfig
    : public IPersistStream, public IDirectMusicObject
{
friend CBuffer;
friend CEffectChain;

protected:
    struct CDXDMODesc
    {
        DWORD m_dwEffectFlags;
        GUID m_guidDSFXClass;
        GUID m_guidSendBuffer;
        DWORD m_dwReserved;
        IMediaObject* m_pMediaObject;
        long m_lSendLevel;
        CDXDMODesc* pNext;
    };

private:
    void AddDXDMODesc(CDXDMODesc *pDXDMODesc)
    {
        if ( m_pDXDMOMapList )
        {
            CDXDMODesc *pObj = m_pDXDMOMapList;
            while(pObj->pNext)
                pObj = pObj->pNext;
            pObj->pNext = pDXDMODesc;
        }
        else
        {
            m_pDXDMOMapList = pDXDMODesc;
        }
        m_dwDXDMOMapCount++;
    };

public:
    CDirectSoundBufferConfig();
    virtual ~CDirectSoundBufferConfig();

    // IUnknown methods
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
    //
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistStream
    //
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream *pStream);
    STDMETHODIMP Save(IStream *pStream, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

    // IDirectMusicObject
    //
    STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

protected:
    long					 m_cRef;
    DWORD                    m_fLoadFlags;
    DMUS_OBJECTDESC          m_DMUSObjectDesc;  // DirectMusicObjectDescription
    DSOUND_IO_DSBUFFERDESC   m_DSBufferDesc;
    DSOUND_IO_3D             m_DS3DDesc;
    LPDWORD                  m_pdwFuncIDs;      // Array of functional IDs associated with the bus
    DWORD                    m_dwFuncIDsCount;  // Number of functional IDs
    CDXDMODesc              *m_pDXDMOMapList;   // Pointer to a list of FX descriptions
    DWORD                    m_dwDXDMOMapCount;

    HRESULT LoadFx(CRiffParser *pParser);

private:
    //CImpPersistStream<CDirectSoundBufferConfig> *m_pImpPersistStream;
    //CImpDirectMusicObject<CDirectSoundBufferConfig> *m_pImpDirectMusicObject;
};

#endif // __cplusplus

#endif // __DSBUFCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6076C15F_C134_11D0_8C10_00A0C92E1CAC__INCLUDED_)
#define AFX_STDAFX_H__6076C15F_C134_11D0_8C10_00A0C92E1CAC__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxext.h>
#include <afxtempl.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6076C15F_C134_11D0_8C10_00A0C92E1CAC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\effects.h ===
/***************************************************************************
 *
 *	Copyright (C) 1999-2000 Microsoft Corporation.	All Rights Reserved.
 *
 *	File:		 effects.h
 *
 *	Content:	 Declarations for the CEffectChain class and the CEffect
 *				 class hierarchy (CEffect, CDmoEffect and CSendEffect).
 *
 *	Description: These classes implement DX8 audio effects and sends.
 *				 More info in effects.cpp.
 *
 *	History:
 *
 * Date 	 By 	  Reason
 * ========  =======  ======================================================
 * 08/10/99  duganp   Created
 *
 ***************************************************************************/

#ifndef __EFFECTS_H__
#define __EFFECTS_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "mediaobj.h"

// Various conversions between reftimes, milliseconds, samples and bytes.
// (Defining 'sample' as a sample *block*, with samples for all channels)
// REFERENCE_TIME is in 100-ns units (so 1 reftime tick == 1e-7 seconds).

#define BLOCKALIGN(a, b) \
			(((a) / (b)) * (b))

__inline DWORD MsToBytes(DWORD ms, LPWAVEFORMATEX pwfx)
{
	return BLOCKALIGN(ms * pwfx->nAvgBytesPerSec / 1000, pwfx->nBlockAlign);
}
__inline DWORD BytesToMs(DWORD bytes, LPWAVEFORMATEX pwfx)
{
	return bytes * 1000 / pwfx->nAvgBytesPerSec;
}
__inline DWORD MsToSamples(DWORD ms, LPWAVEFORMATEX pwfx)
{
	return ms * pwfx->nSamplesPerSec / 1000;
}
__inline DWORD SamplesToMs(DWORD samples, LPWAVEFORMATEX pwfx)
{
	return samples * 1000 / pwfx->nSamplesPerSec;
}
__inline DWORD RefTimeToMs(REFERENCE_TIME rt)
{
	return (DWORD)(rt / 10000);
}
__inline REFERENCE_TIME MsToRefTime(DWORD ms)
{
	return (REFERENCE_TIME)ms * 10000;
}
__inline DWORD RefTimeToBytes(REFERENCE_TIME rt, LPWAVEFORMATEX pwfx)
{
	return (DWORD)(BLOCKALIGN(rt * pwfx->nAvgBytesPerSec / 10000000, pwfx->nBlockAlign));
}
__inline REFERENCE_TIME BytesToRefTime(DWORD bytes, LPWAVEFORMATEX pwfx)
{
	return (REFERENCE_TIME)bytes * 10000000 / pwfx->nAvgBytesPerSec;
}

// Figure out if position X is between A and B in a cyclic buffer
#define CONTAINED(A, B, X) ((A) < (B) ? (A) <= (X) && (X) <= (B) \

// Find the distance between positions A and B in a buffer of length L
#define DISTANCE(A, B, L) ((A) <= (B) ? (B) - (A) : (L) + (B) - (A))


#ifdef __cplusplus

//#include "mediaobj.h"   // For DMO_MEDIA_TYPE
//#include "tlist.h"	  // For the CObjectList class template

// Forward declarations
class CBuffer;
class CDirectSoundBufferConfig;
class CEffect;

// Utility functions for the simple mixer used by CSendEffect below
enum MIXMODE {OneToOne=1, MonoToStereo=2};
typedef void MIXFUNCTION(PVOID pSrc, PVOID pDest, DWORD dwSamples, DWORD dwAmpFactor, MIXMODE mixMode);
MIXFUNCTION Mix8bit;
MIXFUNCTION Mix16bit;

// Validator for effect descriptors (can't be in dsvalid.c because it uses C++)
BOOL IsValidEffectDesc(LPCDSEFFECTDESC, CBuffer*);


//
// The DirectSound effects chain class
//

class CEffectChain : public IUnknown //: public CDsBasicRuntime
{
	friend class CDSLink;  // FIXME - try to dissolve some of these friendships
	friend class CBuffer;  // So FindSendLoop() can get at m_fxList

// FIXME: sprinkle 'private/protected' liberally in this file
public:
	CEffectChain				 (CBuffer* pBuffer);
	~CEffectChain				 (void);

	HRESULT Initialize			 (DWORD dwFxCount, LPDSEFFECTDESC pFxDesc, LPDWORD pdwResultCodes);
	HRESULT Clone				 (CDirectSoundBufferConfig* pDSBConfigObj);
	HRESULT AcquireFxResources	 (void);
	HRESULT GetFxStatus 		 (LPDWORD pdwResultCodes);
	HRESULT GetEffectInterface	 (REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID* ppObject);
	void	NotifyRelease		 (CBuffer*);
	DWORD	GetFxCount()		 {return m_fxList.GetCount();}

	// Effects processing methods
	void	Render				 (short *pnBuffer,DWORD dwLength,REFERENCE_TIME refTimeStart);


	// IUnknown methods
	STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

private:
	HRESULT FxDiscontinuity 	 (void);

	// Reference Count
	long						 m_cRef;

	// Effects processing state
	CTypedPtrList<CPtrList, CEffect *> m_fxList;		// Effect object chain
	CBuffer*					 m_pDsBuffer;			// Owning DirectSound buffer object
	LPWAVEFORMATEX				 m_pFormat; 			// Pointer to owning buffer's audio format
	BOOL						 m_fHasSend;			// Whether this FX chain contains any sends
														// FIXME: may not be necessary later
	HRESULT 					 m_hrInit;				// Return code from initialization
};


//
// Base class for all DirectSound audio effects
//

class CEffect : public IUnknown//: public CDsBasicRuntime  // FIXME: to save some memory we could derive CEffect from CRefCount 
										// and implement the ": CRefCount(1)", "delete this" stuff etc here.
{
public:
	CEffect 						(DSEFFECTDESC& fxDescriptor);
	virtual ~CEffect				(void) {}
	virtual HRESULT Initialize		(DMO_MEDIA_TYPE*) =0;
	virtual HRESULT Clone			(IMediaObject*, DMO_MEDIA_TYPE*) =0;
	virtual HRESULT Process 		(DWORD dwBytes, BYTE* pAudio, REFERENCE_TIME refTimeStart, DWORD dwSendOffset, LPWAVEFORMATEX pFormat) =0;
	virtual HRESULT Discontinuity	(void) = 0;
	virtual HRESULT GetInterface	(REFIID, LPVOID*) =0;

	// These two methods are only required by CSendEffect:
	virtual void NotifyRelease(CBuffer*) {}
	virtual CBuffer* GetDestBuffer(void) {return NULL;}

	// IUnknown methods
	STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();
	long							m_cRef;

	HRESULT AcquireFxResources		(void);

	DSEFFECTDESC					m_fxDescriptor; 	// Creation parameters
	DWORD							m_fxStatus; 		// Current effect status
};


//
// Class representing DirectX Media Object effects
//

class CDmoEffect : public CEffect
{
public:
	CDmoEffect				(DSEFFECTDESC& fxDescriptor);
	~CDmoEffect 			(void);
	HRESULT Initialize		(DMO_MEDIA_TYPE*);
	HRESULT Clone			(IMediaObject*, DMO_MEDIA_TYPE*);
	HRESULT Process 		(DWORD dwBytes, BYTE* pAudio, REFERENCE_TIME refTimeStart, DWORD dwSendOffset =0, LPWAVEFORMATEX pFormat =NULL);
	HRESULT Discontinuity	(void)							{return m_pMediaObject->Discontinuity(0);}
	HRESULT GetInterface	(REFIID riid, LPVOID* ppvObj)	{return m_pMediaObject->QueryInterface(riid, ppvObj);}

	IMediaObject*			m_pMediaObject; 		// The DMO's standard interface (required)
	IMediaObjectInPlace*	m_pMediaObjectInPlace;	// The DMO's special interface (optional)
};


//
// Class representing DirectSound audio sends
//

class CSendEffect : public CEffect
{
public:
	CSendEffect(DSEFFECTDESC& fxDescriptor, CBuffer* pSrcBuffer);
	~CSendEffect(void);

	HRESULT Initialize		(DMO_MEDIA_TYPE*);
	HRESULT Clone			(IMediaObject*, DMO_MEDIA_TYPE*);
	HRESULT Process 		(DWORD dwBytes, BYTE* pAudio, REFERENCE_TIME refTimeStart, DWORD dwSendOffset =0, LPWAVEFORMATEX pFormat =NULL);
	void	NotifyRelease	(CBuffer*);
#ifdef ENABLE_I3DL2SOURCE
	HRESULT Discontinuity	(void)							{return m_pI3DL2SrcDMO ? m_pI3DL2SrcDMO->Discontinuity(0) : DS_OK;}
#else
	HRESULT Discontinuity	(void)							{return DS_OK;}
#endif
	HRESULT GetInterface	(REFIID riid, LPVOID* ppvObj)	{return m_impDSFXSend.QueryInterface(riid, ppvObj);}
	CBuffer* GetDestBuffer(void)		{return m_pDestBuffer;}

	// IDirectSoundFXSend methods
	HRESULT SetAllParameters(LPCDSFXSend);
	HRESULT GetAllParameters(LPDSFXSend);

private:
	// COM interface helper object
	struct CImpDirectSoundFXSend : public IDirectSoundFXSend
	{
		// INTERFACE_SIGNATURE m_signature;
		CSendEffect* m_pObject;

		// IUnknown methods (FIXME - missing the param validation layer)
		ULONG	STDMETHODCALLTYPE AddRef()	{return m_pObject->AddRef();}
		ULONG	STDMETHODCALLTYPE Release() {return m_pObject->Release();}
		HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);

		// IDirectSoundFXSend methods (FIXME - missing the param validation layer)
		HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDSFXSend pcDsFxSend) {return m_pObject->SetAllParameters(pcDsFxSend);}
		HRESULT STDMETHODCALLTYPE GetAllParameters(LPDSFXSend pDsFxSend)  {return m_pObject->GetAllParameters(pDsFxSend);}
	};
	friend struct CImpDirectSoundFXSend;

	// Data members
	CImpDirectSoundFXSend		 m_impDSFXSend; 		// COM interface helper object
	MIXFUNCTION*				 m_pMixFunction;		// Current mixing routine
	MIXMODE 					 m_mixMode; 			// Current mixing mode
	CBuffer*					 m_pSrcBuffer;			// Source buffer for the send - FIXME: may be able to lose this
	CBuffer*					 m_pDestBuffer; 		// Destination buffer for the send
	LONG						 m_lSendLevel;			// DSBVOLUME attenuation (millibels)
	DWORD						 m_dwAmpFactor; 		// Corresponding amplification factor
#ifdef ENABLE_I3DL2SOURCE
	IMediaObject*				 m_pI3DL2SrcDMO;		// Interfaces on our contained I3DL2 source DMO
	IMediaObjectInPlace*		 m_pI3DL2SrcDMOInPlace; // (if this happends to be an I3DL2 send effect).
#endif
};


// FIXME: Support for IMediaObject-only DMOs goes here
#if 0

//
// Utility class used to wrap our audio buffers in an IMediaBuffer interface,
// so we can use a DMO's IMediaObject interface if it lacks IMediaObjectInPlace.
//

class CMediaBuffer //: public CUnknown // (but this has dependencies on CImpUnknown...)
{
	// Blah.
};

#endif // 0
#endif // __cplusplus
#endif // __EFFECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\plclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	PLClock.h

  */

#ifndef __PLCLOCK_H__
#define __PLCLOCK_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CPhaseLockClock
{
public:
						CPhaseLockClock();
	void				Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
	void				GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime,BOOL fLockToMaster);
	void				GetClockOffset(REFERENCE_TIME *prfTime) { *prfTime = m_rfOffset; };
private:
	REFERENCE_TIME		m_rfOffset;
    REFERENCE_TIME      m_rfBaseOffset;
};

class CSampleClock
{
public:
						CSampleClock();
						~CSampleClock();
	void				Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples);
	void				SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock,BOOL fLockToMaster);
	LONGLONG			RefToSampleTime(REFERENCE_TIME rfTime);
	void				GetClockOffset(REFERENCE_TIME *prfTime) { m_PLClock.GetClockOffset(prfTime); };

private:
	CPhaseLockClock		m_PLClock;
	DWORD				m_dwStart;			// Initial sample offset.
	DWORD				m_dwSampleRate;
};
#endif	// __PLCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Conductor\PhoneyDS\plclock.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	CPhaseLockClock

  */

#include "stdafx.h"
#include "dmusici.h"
#include "dmusicc.h"
#include "plclock.h"

//#define _FILE_DEBUG 1
#ifdef _FILE_DEBUG
void FTRACE( LPSTR pszFormat, ... );
#endif

#define MILS_TO_REF	10000

CPhaseLockClock::CPhaseLockClock()
{
	m_rfOffset = 0;
    m_rfBaseOffset = 0;
}

// When the clock starts, it needs to mark down the 
// difference between the time it is given and its concept of time. 

void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)
{
	m_rfOffset = 0;
    m_rfBaseOffset = rfMasterTime - rfSlaveTime;
}	


// Convert the passed time to use the same base as the master clock.

void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)
{
	rfSlaveTime += (m_rfBaseOffset + m_rfOffset);
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

{
	rfSlaveTime -= m_rfBaseOffset;
	*prfTime = rfSlaveTime;
}

/*	SyncToMaster provides the needed magic to keep the clock
	in sync. Since the clock uses its own clock (rfSlaveTime)
	to increment, it can drift. This call provides a reference
	time which the clock compares with its internal 
	concept of time. The difference between the two is
	considered the drift. Since the sync time may increment in
	a lurching way, the correction has to be subtle. 
	So, the difference between the two is divided by
	100 and added to the offset.
*/
void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime, BOOL fLockToMaster)
{
	rfSlaveTime += (m_rfOffset + m_rfBaseOffset);
	rfSlaveTime -= rfMasterTime;	// Find difference between calculated and expected time.
	rfSlaveTime /= 10;				// Reduce in magnitude.
    // If fLockToMaster is true, we want to adjust our offset that we use for conversions, 
    // so our clock will slave to the master clock.
    if (fLockToMaster)
    {
        m_rfBaseOffset -= rfSlaveTime;
    }
    // Otherwise, we want to put a value into m_rfOffset that will be used to 
    // tweak the master clock so it will slave to our time.
    else
    {
	    m_rfOffset -= rfSlaveTime;		// Subtract that from the original offset.
    }
}

CSampleClock::CSampleClock()
{
	m_dwStart = 0;
	m_dwSampleRate = 22050;
}

void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples)
{
	REFERENCE_TIME rfStart;
	m_dwStart = dwSamples;
	m_dwSampleRate = dwSampleRate;
	if (pIClock)
	{
		pIClock->GetTime(&rfStart);
		m_PLClock.Start(rfStart,0);
	}
}

CSampleClock::~CSampleClock()
{
}

void CSampleClock::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prfTime)
{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

LONGLONG CSampleClock::RefToSampleTime(REFERENCE_TIME rfTime)
{
	m_PLClock.SetSlaveTime(rfTime, &rfTime);
	rfTime /= 1000;
	rfTime *= m_dwSampleRate;
	rfTime /= MILS_TO_REF;
	rfTime += m_dwStart;
	return rfTime;
}

void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock, BOOL fLockToMaster)
{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	if (pIClock)
	{
		REFERENCE_TIME rfMasterTime;
		pIClock->GetTime(&rfMasterTime);

#ifdef _FILE_DEBUG
		REFERENCE_TIME rtSlaveTime;
		m_PLClock.GetSlaveTime(llSampleTime, &rtSlaveTime);
		FTRACE("SyncToMaster: %d SampleTime %I64d MasterTime %I64d\n", timeGetTime(), rtSlaveTime, rfMasterTime );
#endif

		m_PLClock.SyncToMaster(llSampleTime, rfMasterTime,fLockToMaster);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerCtl.cpp ===
// ContainerCtl.cpp : Implementation of the CContainerCtrl ActiveX Control class.

#include "stdafx.h"
#include "ContainerDesignerDLL.h"
#include "ContainerCtl.h"
#include "ContainerPpg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CContainerCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CContainerCtrl, COleControl)
	//{{AFX_MSG_MAP(CContainerCtrl)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CContainerCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CContainerCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CContainerCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CContainerCtrl, COleControl)
	//{{AFX_EVENT_MAP(CContainerCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CContainerCtrl, 1)
	PROPPAGEID(CContainerPropPage::guid)
END_PROPPAGEIDS(CContainerCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CContainerCtrl, "CONTAINERDESIGNER.ContainerCtrl.1",
	0x778a0b8f, 0x6f81, 0x11d3, 0xb4, 0x5f, 0, 0x10, 0x5a, 0x27, 0x96, 0xde)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CContainerCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DContainer =
		{ 0x778a0b8d, 0x6f81, 0x11d3, { 0xb4, 0x5f, 0, 0x10, 0x5a, 0x27, 0x96, 0xde } };
const IID BASED_CODE IID_DContainerEvents =
		{ 0x778a0b8e, 0x6f81, 0x11d3, { 0xb4, 0x5f, 0, 0x10, 0x5a, 0x27, 0x96, 0xde } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwContainerOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CContainerCtrl, IDS_CONTAINER, _dwContainerOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CContainerCtrl::CContainerCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CContainerCtrl

BOOL CContainerCtrl::CContainerCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_CONTAINER,
			IDB_CONTAINER,
			afxRegApartmentThreading,
			_dwContainerOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CContainerCtrl::CContainerCtrl - Constructor

CContainerCtrl::CContainerCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DContainer, &IID_DContainerEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DContainer;
	m_piidEvents = &IID_DContainerEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////
}


/////////////////////////////////////////////////////////////////////////////
// CContainerCtrl::~CContainerCtrl - Destructor

CContainerCtrl::~CContainerCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CContainerCtrl::OnDraw - Drawing function

void CContainerCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	// TODO: Replace the following code with your own drawing code.
	pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
	pdc->Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CContainerCtrl::DoPropExchange - Persistence support

void CContainerCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CContainerCtrl::OnResetState - Reset control to default state

void CContainerCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CContainerCtrl::AboutBox - Display an "About" box to the user

void CContainerCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_CONTAINER);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CContainerCtrl message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerComponent.cpp ===
// ContainerComponent.cpp : implementation file
//

#include "stdafx.h"

#include "ContainerDesignerDLL.h"
#include "Container.h"
#include "ContainerRef.h"
#include "DupeFileDlg.h"


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent constructor/destructor 

CContainerComponent::CContainerComponent()
{
    m_dwRef = 0;
	
	m_pIFramework8 = NULL;
	m_pIDMPerformance = NULL;

	m_pIContainerDocType8 = NULL;
	m_pIConductor = NULL;
	m_nFirstImage = 0;

	m_nNextContainer = 0;

	m_dwEmbeddedFileListUseCount = 0;
	m_pIEmbeddedFileStream = NULL;
	m_pEmbeddedFileRootFile = NULL;
	m_pContainerBeingLoaded = NULL;
	m_pIDupeFileTargetProject = NULL;
	m_nDupeFileDlgReturnCode = 0;

	m_cfProducerFile = 0;
	m_cfContainer = 0;
	m_cfContainerList = 0;
}

CContainerComponent::~CContainerComponent()
{
	ReleaseAll();
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::ReleaseAll

void CContainerComponent::ReleaseAll( void )
{
 	CDirectMusicContainer* pContainer;
	while( !m_lstContainers.IsEmpty() )
	{
		pContainer = static_cast<CDirectMusicContainer*>( m_lstContainers.RemoveHead() );
		RELEASE( pContainer );
	}

 	RegisteredObject* pRegisteredObject;
	while( !m_lstRegisteredObjects.IsEmpty() )
	{
		pRegisteredObject = static_cast<RegisteredObject*>( m_lstRegisteredObjects.RemoveHead() );
		delete pRegisteredObject;
	}

	ASSERT( m_lstEmbeddedFiles.IsEmpty() );
 	EmbeddedFile* pEmbeddedFile;
	while( !m_lstEmbeddedFiles.IsEmpty() )
	{
		pEmbeddedFile = static_cast<EmbeddedFile*>( m_lstEmbeddedFiles.RemoveHead() );
		delete pEmbeddedFile;
	}
	m_dwEmbeddedFileListUseCount = 0;
	RELEASE( m_pIEmbeddedFileStream );

	if( m_pEmbeddedFileRootFile )
	{
		delete m_pEmbeddedFileRootFile;
		m_pEmbeddedFileRootFile = NULL;
	}

	RELEASE( m_pIFramework8 );
	RELEASE( m_pIContainerDocType8 );
	RELEASE( m_pIDMPerformance );
	RELEASE( m_pIConductor );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::LoadRegisteredObjects

BOOL CContainerComponent::LoadRegisteredObjects( void )
{
	HKEY	  hKeyOpen;
	HKEY	  hKeyOpenClsId;
	DWORD	  dwIndex;
	LONG	  lResult;
	DWORD	  dwType;
	DWORD	  dwCbData;
	FILETIME  ftFileTime;
	wchar_t	  awchBuffer[MID_BUFFER << 1];
	_TCHAR	  achClsId[MID_BUFFER];
	_TCHAR	  achGuid[MID_BUFFER];
	RegisteredObject* pRegisteredObject;

	lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
						  	  _T("Software\\Microsoft\\DMUSProducer\\Container Objects"),
							  0, KEY_READ, &hKeyOpen );
	if( lResult != ERROR_SUCCESS )
	{
		AfxMessageBox( IDS_ERR_REG_OBJECT);
		return FALSE;
	}

	dwIndex = 0;
	for( ; ; )
	{
		dwCbData = MID_BUFFER;
		lResult  = ::RegEnumKeyEx( hKeyOpen, dwIndex++, achClsId, &dwCbData,
								   NULL, NULL, NULL, &ftFileTime );
		if( lResult == ERROR_NO_MORE_ITEMS )
		{
			break;
		}
		if( lResult != ERROR_SUCCESS )
		{
			AfxMessageBox( IDS_ERR_REG_OBJECT);
			break;
		}

		lResult    = ::RegOpenKeyEx( hKeyOpen, achClsId,
								     0, KEY_QUERY_VALUE, &hKeyOpenClsId );
		if( lResult == ERROR_SUCCESS )
		{
			// We have another registered object
			pRegisteredObject = new RegisteredObject();
			
			if( pRegisteredObject )
			{
				// Store GUID of Node
				if( MultiByteToWideChar( CP_ACP, 0, achClsId, -1, awchBuffer, sizeof(awchBuffer) / sizeof(wchar_t) ) != 0 )
				{
					IIDFromString( awchBuffer, &pRegisteredObject->guidNodeId );
				}

				// Store object type of Node
				dwCbData = MID_BUFFER;
				lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T(""), NULL,
											  &dwType, (LPBYTE)&achGuid, &dwCbData );
				if( (lResult == ERROR_SUCCESS)
				&&  (dwType == REG_SZ) )
				{
					pRegisteredObject->strObjectType = achGuid;
				}

				// Store GUID of RefNode
				dwCbData = MID_BUFFER;
				lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T("RefNode"), NULL,
											  &dwType, (LPBYTE)&achGuid, &dwCbData );
				if( (lResult == ERROR_SUCCESS)
				&&  (dwType == REG_SZ) )
				{
					if( MultiByteToWideChar( CP_ACP, 0, achGuid, -1, awchBuffer, sizeof(awchBuffer) / sizeof(wchar_t) ) != 0 )
					{
						IIDFromString( awchBuffer, &pRegisteredObject->guidRefNodeId );
					}
				}
			
				// Store CLSID of Component
				dwCbData = MID_BUFFER;
				lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T("Component"), NULL,
											  &dwType, (LPBYTE)&achGuid, &dwCbData );
				if( (lResult == ERROR_SUCCESS)
				&&  (dwType == REG_SZ) )
				{
					if( MultiByteToWideChar( CP_ACP, 0, achGuid, -1, awchBuffer, sizeof(awchBuffer) / sizeof(wchar_t) ) != 0 )
					{
						IIDFromString( awchBuffer, &pRegisteredObject->clsidComponent );
					}
				}
			
				// Store CLSID of corresponding DirectMusic object
				dwCbData = MID_BUFFER;
				lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T("DMObject"), NULL,
											  &dwType, (LPBYTE)&achGuid, &dwCbData );
				if( (lResult == ERROR_SUCCESS)
				&&  (dwType == REG_SZ) )
				{
					if( MultiByteToWideChar( CP_ACP, 0, achGuid, -1, awchBuffer, sizeof(awchBuffer) / sizeof(wchar_t) ) != 0 )
					{
						IIDFromString( awchBuffer, &pRegisteredObject->clsidDMObject );
					}
				}

				// RIFF chunk ids must be filled in later - after ALL Components have been loaded
				// Code to fill in RIFF chunk ids is in FindRegisteredObjectByRIFFIds()

				// Place registered object in list
				m_lstRegisteredObjects.AddTail( pRegisteredObject );
			}
			
			::RegCloseKey( hKeyOpenClsId );
		}
	}

	::RegCloseKey( hKeyOpen );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IUnknown implementation

HRESULT CContainerComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdComponent *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdRIFFExt) )
    {
        AddRef();
        *ppvObj = (IDMUSProdRIFFExt *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdUnpackingFiles) )
    {
        AddRef();
        *ppvObj = (IDMUSProdUnpackingFiles *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CContainerComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CContainerComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdComponent::Initialize

HRESULT CContainerComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdComponent* pIComponent = NULL;
	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework8 )		// already initialized
	{
		return S_OK;
	}

	ASSERT( pIFramework != NULL );
	ASSERT( pbstrErrMsg != NULL );

	if( pbstrErrMsg == NULL )
	{
		return E_POINTER;
	}

	if( pIFramework == NULL )
	{
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_INVALIDARG;
	}

	// Get IDMUSProdFramework8 interface pointers
	if( FAILED ( pIFramework->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pIFramework8 ) ) )
	{
		m_pIFramework8 = NULL;
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	theApp.m_pContainerComponent = this;
//	theApp.m_pContainerComponent->AddRef();	intentionally missing

	// Get IConductor and IDirectMusicPerformance interface pointers 
	if( FAILED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  FAILED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor ) )
	||  FAILED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIDMPerformance ) ) )
	{
		ReleaseAll();
		if( pIComponent )
		{
			RELEASE( pIComponent );
		}
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE( pIComponent );

	// Add applicable images to the Project Tree control's image list 
	if( FAILED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register clipboard formats
	if( RegisterClipboardFormats() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register the clipboard format for an .cop file 
	CString strExt = _T(".cop");
	BSTR bstrExt = strExt.AllocSysString();
	if( FAILED ( pIFramework->RegisterClipFormatForFile(m_cfContainer, bstrExt) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register applicable doc types with the Framework 
	m_pIContainerDocType8 = new CContainerDocType;
    if( m_pIContainerDocType8 == NULL )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_OUTOFMEMORY;
	}

	m_pIContainerDocType8->AddRef();

	IDMUSProdDocType* pIDocType;
	if( FAILED ( m_pIContainerDocType8->QueryInterface( IID_IDMUSProdDocType, (void**)&pIDocType ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	if( FAILED ( pIFramework->AddDocType(pIDocType) ) )
	{
		RELEASE( pIDocType );
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE( pIDocType );

	// Load registered objects
	LoadRegisteredObjects();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdComponent::CleanUp

HRESULT CContainerComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicContainer *pContainer;
	while( !m_lstContainers.IsEmpty() )
	{
		pContainer = static_cast<CDirectMusicContainer*>( m_lstContainers.RemoveHead() );
		RELEASE( pContainer );
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdComponent::GetName

HRESULT CContainerComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_CONTAINER_COMPONENT_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::IDMUSProdComponent::AllocReferenceNode

HRESULT CContainerComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( !( IsEqualGUID ( guidRefNodeId, GUID_ContainerRefNode ) ) )
	{
		return E_INVALIDARG;
	}

	// Create ContainerRefNode
	CContainerRef* pContainerRef = new CContainerRef;
	if( pContainerRef == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppIRefNode = (IDMUSProdNode *)pContainerRef;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdComponent::OnActivateApp

HRESULT CContainerComponent::OnActivateApp( BOOL fActivate )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fActivate);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdRIFFExt implementation

/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdRIFFExt::LoadRIFFChunk

HRESULT CContainerComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr;

	ASSERT( pIStream != NULL );
	ASSERT( m_pIFramework8 != NULL );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	// Create a new Container 
	CDirectMusicContainer* pContainer = new CDirectMusicContainer();
	if( pContainer == NULL )
	{
		return E_OUTOFMEMORY ;
	}
			
	// Create the Undo Manager
	if( pContainer->CreateUndoMgr() == FALSE )
	{
		pContainer->Release();
		return E_OUTOFMEMORY;
	}

	// Load the Container file
	hr = pContainer->Load( pIStream );
	if( !SUCCEEDED ( hr ) )
	{
		pContainer->Release();
		return hr;
	}

	*ppINode = (IDMUSProdNode *)pContainer;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdUnpackingFiles implementation

/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdUnpackingFiles::GetDocRootOfEmbeddedFile

HRESULT CContainerComponent::GetDocRootOfEmbeddedFile( IUnknown* pIDocType, BSTR bstrObjectName, IUnknown** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIFramework8 != NULL );

	CString strObjectName;
	if( bstrObjectName == NULL )
	{
		return E_INVALIDARG;
	}
	else
	{
		strObjectName = bstrObjectName;
		::SysFreeString( bstrObjectName );
	}

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}
	*ppIDocRootNode = NULL;

	if( pIDocType == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
	while( pos )
	{
		EmbeddedFile* pEmbeddedFile = m_lstEmbeddedFiles.GetNext( pos );

		ASSERT( pEmbeddedFile->dwStreamPos != 0 );	// temporary check

		if( strObjectName.CompareNoCase( pEmbeddedFile->strObjectName ) == 0 )
		{
			// Object names are equal
			RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( pEmbeddedFile->guidDMClass );
			if( pRegisteredObject )
			{
				// Check to see if CLSID is type of object we want
				IDMUSProdDocType* pIDocTypeList;
				if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocTypeList ) ) )
				{
					if( pIDocTypeList == pIDocType )
					{
						// This is the object we are looking for...
						if( pEmbeddedFile->fBeingLoaded )
						{
							// We are already in the process of loading this file
							hr = E_PENDING;
						}
						else
						{
							// Set m_pIEmbeddedFileStream position
							DWORD dwOrigStreamPos = StreamTell( m_pIEmbeddedFileStream );
							StreamSeek( m_pIEmbeddedFileStream, pEmbeddedFile->dwStreamPos, 0 );

							*ppIDocRootNode = LoadEmbeddedFile( pEmbeddedFile->guidDMClass, m_pIEmbeddedFileStream );
							if( *ppIDocRootNode )
							{
								hr = S_OK;
							}

							// Restore original m_pIEmbeddedFileStream position
							StreamSeek( m_pIEmbeddedFileStream, dwOrigStreamPos, 0 );
						}

						RELEASE( pIDocTypeList );
						break;
					}
				
					RELEASE( pIDocTypeList );
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent IDMUSProdUnpackingFiles::AddToNotifyWhenLoadFinished

HRESULT CContainerComponent::AddToNotifyWhenLoadFinished( IUnknown* pIDocType, BSTR bstrObjectName, IUnknown* punkNotifySink, GUID* pguidFile )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIFramework8 != NULL );

	if( pguidFile )
	{
		*pguidFile = GUID_AllZeros;
	}

	CString strObjectName;
	if( bstrObjectName == NULL )
	{
		return E_INVALIDARG;
	}
	else
	{
		strObjectName = bstrObjectName;
		::SysFreeString( bstrObjectName );
	}

	if( pguidFile == NULL )
	{
		return E_POINTER;
	}

	if( pIDocType == NULL 
	||  punkNotifySink == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
	while( pos )
	{
		EmbeddedFile* pEmbeddedFile = m_lstEmbeddedFiles.GetNext( pos );

		ASSERT( pEmbeddedFile->dwStreamPos != 0 );	// temporary check

		if( strObjectName.CompareNoCase( pEmbeddedFile->strObjectName ) == 0 )
		{
			// Object names are equal
			RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( pEmbeddedFile->guidDMClass );
			if( pRegisteredObject )
			{
				// Check to see if CLSID is type of object we want
				IDMUSProdDocType* pIDocTypeList;
				if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocTypeList ) ) )
				{
					if( pIDocTypeList == pIDocType )
					{
						// This is the object we are looking for...
						if( pEmbeddedFile->fBeingLoaded )
						{
							// Add pINotifySink to embedded file's notification list
							IDMUSProdNotifySink* pINotifySink;
							if( SUCCEEDED ( punkNotifySink->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
							{
								pEmbeddedFile->m_lstNotifyWhenLoadFinished.AddTail( pINotifySink );
								*pguidFile = pEmbeddedFile->guidNotification;
								hr = S_OK;
							}
						}

						RELEASE( pIDocTypeList );
						break;
					}
				
					RELEASE( pIDocTypeList );
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent additional functions

/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::AddNodeImageLists

HRESULT CContainerComponent::AddNodeImageLists( void )
{
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 8, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_CONTAINER_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_CONTAINER_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_CONTAINERREF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_CONTAINERREF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_GRAY) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_GRAY_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( FAILED (m_pIFramework8->AddNodeImageList( lstImages.Detach(), &m_nFirstImage ) ) )
	{
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::RegisterClipboardFormats

BOOL CContainerComponent::RegisterClipboardFormats( void )
{
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfContainer = ::RegisterClipboardFormat( CF_CONTAINER );
	m_cfContainerList = ::RegisterClipboardFormat( CF_CONTAINERLIST );

	if( m_cfProducerFile == 0
	||  m_cfContainer == 0
	||  m_cfContainerList == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::GetContainerImageIndex

HRESULT CContainerComponent::GetContainerImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_CONTAINER_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::GetContainerRefImageIndex

HRESULT CContainerComponent::GetContainerRefImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_CONTAINERREF_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::GetFolderImageIndex

HRESULT CContainerComponent::GetFolderImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_FOLDER_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::GetFolderGrayImageIndex

HRESULT CContainerComponent::GetFolderGrayImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_FOLDER_GRAY_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::IsRegisteredObject

HRESULT CContainerComponent::IsRegisteredObject( IDMUSProdNode* pIDocRootNode )
{
	if( pIDocRootNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Get DocRoot's NodeId
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		RegisteredObject* pRegisteredObject;

		// Find registered object
		POSITION pos = m_lstRegisteredObjects.GetHeadPosition();
		while( pos )
		{
			pRegisteredObject = m_lstRegisteredObjects.GetNext( pos );

			if( ::IsEqualGUID( pRegisteredObject->guidNodeId, guidNodeId ) )
			{
				return S_OK;
			}
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::FindRegisteredObjectByCLSID

RegisteredObject* CContainerComponent::FindRegisteredObjectByCLSID( CLSID clsidDMObject )
{
	RegisteredObject* pTheRegisteredObject = NULL;

	RegisteredObject* pRegisteredObject;
	POSITION pos = m_lstRegisteredObjects.GetHeadPosition();
	while( pos )
	{
		pRegisteredObject = m_lstRegisteredObjects.GetNext( pos );

		if( ::IsEqualGUID( pRegisteredObject->clsidDMObject, clsidDMObject ) )
		{
			pTheRegisteredObject = pRegisteredObject;
			break;
		}
	}

	return pTheRegisteredObject;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::FindRegisteredObjectByDocRoot

RegisteredObject* CContainerComponent::FindRegisteredObjectByDocRoot( IDMUSProdNode* pIDocRootNode )
{
	RegisteredObject* pTheRegisteredObject = NULL;

	if( pIDocRootNode )
	{
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId( &guidNodeId ) ) )
		{
			RegisteredObject* pRegisteredObject;
			POSITION pos = m_lstRegisteredObjects.GetHeadPosition();
			while( pos )
			{
				pRegisteredObject = m_lstRegisteredObjects.GetNext( pos );

				if( ::IsEqualGUID( pRegisteredObject->guidNodeId, guidNodeId ) )
				{
					pTheRegisteredObject = pRegisteredObject;
					break;
				}
			}
		}
	}

	return pTheRegisteredObject;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::FindRegisteredObjectByRIFFIds

RegisteredObject* CContainerComponent::FindRegisteredObjectByRIFFIds( DWORD dwRIFFckid, DWORD dwRIFFfccType )
{
	RegisteredObject* pTheRegisteredObject = NULL;

	RegisteredObject* pRegisteredObject;
	POSITION pos = m_lstRegisteredObjects.GetHeadPosition();
	while( pos )
	{
		pRegisteredObject = m_lstRegisteredObjects.GetNext( pos );

		if( pRegisteredObject->dwRIFFckid == 0
		&&  pRegisteredObject->dwRIFFfccType == 0 )
		{
			// Needs to be initialized!
			// Can't initialize in LoadRegisteredObjects() because
			// Components still in process of loading and all DocTypes
			// have not been registered
			IDMUSProdDocType* pIDocType;
			if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocType ) ) )
			{
				IDMUSProdDocType8* pIDocType8;
				if( SUCCEEDED ( pIDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDocType8 ) ) )
				{
					DWORD dwRIFFckid;
					DWORD dwRIFFfccType;
					if( SUCCEEDED ( pIDocType8->GetObjectRiffId( pRegisteredObject->guidNodeId, &dwRIFFckid, &dwRIFFfccType ) ) )
					{
						pRegisteredObject->dwRIFFckid = dwRIFFckid;
						pRegisteredObject->dwRIFFfccType = dwRIFFfccType;
					}
			
					RELEASE( pIDocType8 );
				}

				RELEASE( pIDocType );
			}
		}

		if( pRegisteredObject->dwRIFFckid == dwRIFFckid
		&&  pRegisteredObject->dwRIFFfccType == dwRIFFfccType )
		{
			pTheRegisteredObject = pRegisteredObject;
			break;
		}
	}

	return pTheRegisteredObject;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::CreateRefNode

HRESULT CContainerComponent::CreateRefNode( IDMUSProdNode* pIDocRootNode, IDMUSProdNode** ppIRefNode )
{
	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	if( pIDocRootNode == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Get DocRoot's NodeId
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		RegisteredObject* pRegisteredObject;

		// Find registered object
		POSITION pos = m_lstRegisteredObjects.GetHeadPosition();
		while( pos )
		{
			pRegisteredObject = m_lstRegisteredObjects.GetNext( pos );

			if( ::IsEqualGUID( pRegisteredObject->guidNodeId, guidNodeId ) )
			{
				// Now create the reference node
				IDMUSProdComponent* pIComponent;

				if( SUCCEEDED ( m_pIFramework8->FindComponent( pRegisteredObject->clsidComponent, &pIComponent ) ) )
				{
					IDMUSProdNode* pIRefNode;

					if( SUCCEEDED ( pIComponent->AllocReferenceNode( pRegisteredObject->guidRefNodeId, &pIRefNode ) ) )
					{
						IDMUSProdReferenceNode* pIReferenceNode;

						if( SUCCEEDED ( pIRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pIReferenceNode ) ) )
						{
							if( SUCCEEDED ( pIReferenceNode->SetReferencedFile( pIDocRootNode ) ) )
							{
								*ppIRefNode = pIRefNode;
								pIRefNode->AddRef();
								hr = S_OK;
							}

							RELEASE( pIReferenceNode );
						}

						RELEASE( pIRefNode );
					}

					RELEASE( pIComponent );
				}

				break;
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::DetermineAction

int CContainerComponent::DetermineAction( IDMUSProdNode* pIDocRootNode, RegisteredObject* pRegisteredObject,
 									      IStream* pIStream, IDMUSProdNode** ppIDupeDocRootNode )
{
	int nReturn = IDC_KEEP_BOTH;

	IDMUSProdNode* pIDupeFileNode = NULL;

	if( ppIDupeDocRootNode == NULL )
	{
		return nReturn;
	}
	*ppIDupeDocRootNode = NULL;

	if( pIDocRootNode == NULL 
	||  pIStream == NULL )
	{
		return nReturn;
	}

	// Get guidNodeId of pIDocRootNode
	GUID guidNodeId;
	if( FAILED ( pIDocRootNode->GetNodeId( &guidNodeId ) ) )
	{
		return nReturn;
	}

	// Get DocRoot of pIDocRootNode
	IDMUSProdDocType* pIDocType = NULL;
	if( FAILED ( m_pIFramework8->FindDocTypeByNodeId( guidNodeId, &pIDocType ) ) )
	{
		return nReturn;
	}

	// Initialize the DMUS_OBJECTDESC structure
	DMUS_OBJECTDESC dmusObjectDesc;
	memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);

	CString strDupeFileNodeName;

	// Get object descriptor for pIDocRootNode
	IDMUSProdDocType8* pIDocType8;
	if( SUCCEEDED ( pIDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDocType8 ) ) )
	{
		if( SUCCEEDED ( pIDocType8->GetObjectDescriptorFromNode( pIDocRootNode, &dmusObjectDesc ) ) )
		{
			IDMUSProdProject* pINextProject;
			IDMUSProdProject* pIProject;
			IDMUSProdNode* pINextFileNode;
			IDMUSProdNode* pIFileNode;
			DMUSProdListInfo ListInfo;

			// Search all files in the Project Tree for a matching object descriptor
			HRESULT hrProject = m_pIFramework8->GetFirstProject( &pINextProject );

			while( (pIDupeFileNode == NULL)  &&  SUCCEEDED( hrProject )  &&  pINextProject )
			{
				pIProject = pINextProject;

				HRESULT hrFile = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

				while( (pIDupeFileNode == NULL)  &&  (hrFile == S_OK) )
				{
					pIFileNode = pINextFileNode;

					ZeroMemory( &ListInfo, sizeof(ListInfo) );
					ListInfo.wSize = sizeof(ListInfo);

					if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
					{
						CString strName;
						if( ListInfo.bstrName )
						{
							strName = ListInfo.bstrName;
							::SysFreeString( ListInfo.bstrName );
						}
						if( ListInfo.bstrDescriptor )
						{
							::SysFreeString( ListInfo.bstrDescriptor );
						}

						if( (strName == dmusObjectDesc.wszName)
						&&  (::IsEqualGUID(ListInfo.guidObject, dmusObjectDesc.guidObject)) )
						{
							strDupeFileNodeName = strName;
							pIDupeFileNode = pIFileNode;
							pIDupeFileNode->AddRef();
						}
					}

					if( pIDupeFileNode == NULL )
					{
						hrFile = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
					}
					RELEASE( pIFileNode );
				}
			
				if( pIDupeFileNode == NULL )
				{
					hrProject = m_pIFramework8->GetNextProject( pIProject, &pINextProject );
				}
				RELEASE( pIProject );
			}
		}

		RELEASE( pIDocType8 );
	}

	if( pIDupeFileNode )
	{
		CDupeFileDlg dlgDupeFile;

		// Get Project name
		CString strProjectName;
		IDMUSProdProject* pIProject;
		if( SUCCEEDED ( m_pIFramework8->FindProject( pIDupeFileNode, &pIProject ) ) )
		{
			BSTR bstrProjectName;
			if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
			{
				strProjectName = bstrProjectName;
				::SysFreeString( bstrProjectName );
			}

			RELEASE( pIProject );
		}

		// Get Container's filename
		CString strContainerFileName;
		IDMUSProdPersistInfo* pIPersistInfo;
		if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
		{
			BSTR bstrContainerFileName;
			if( SUCCEEDED ( pIPersistInfo->GetFileName( &bstrContainerFileName ) ) )
			{
				strContainerFileName = bstrContainerFileName;
				::SysFreeString( bstrContainerFileName );
			}

			TCHAR achFileName[FILENAME_MAX];
			TCHAR achFName[_MAX_FNAME];
			TCHAR achExt[_MAX_EXT];

			_tsplitpath( strContainerFileName, NULL, NULL, achFName, achExt );
			_tmakepath( achFileName, NULL, NULL, achFName, achExt );
			strContainerFileName = achFileName;

			RELEASE( pIPersistInfo );
		}
		
		// Prepare dialog's prompt text
		CString strText;
		CString strObjectType = pRegisteredObject->strObjectType;
		strObjectType.MakeLower();
		AfxFormatString2( dlgDupeFile.m_strPrompt, IDS_DUPE_FILE_PROMPT1, strProjectName, strObjectType );
		AfxFormatString2( strText, IDS_DUPE_FILE_PROMPT2, strDupeFileNodeName, strContainerFileName );
		dlgDupeFile.m_strPrompt += strText;

		// Prepare dialog's 'Use Existing' prompt text
		AfxFormatString1( dlgDupeFile.m_strPromptUseExisting, IDS_DUPE_FILE_PROMPT3, strProjectName );

		// Prepare dialog's 'Use Embedded' prompt text
		AfxFormatString1( dlgDupeFile.m_strPromptUseEmbedded, IDS_DUPE_FILE_PROMPT4, strProjectName );

		// Prepare dialog's 'Keep Both' prompt text
		if( m_pIDupeFileTargetProject )
		{
			CString strTargetProjectName;
			BSTR bstrTargetProjectName;
			if( SUCCEEDED ( m_pIDupeFileTargetProject->GetName( &bstrTargetProjectName ) ) )
			{
				strTargetProjectName = bstrTargetProjectName;
				::SysFreeString( bstrTargetProjectName );
			}
			AfxFormatString1( dlgDupeFile.m_strPromptKeepBoth, IDS_DUPE_FILE_PROMPT5, strTargetProjectName );
		}
		else
		{
			dlgDupeFile.m_strPromptKeepBoth.LoadString( IDS_DUPE_FILE_PROMPT6 );
		}

		// Ask user what they want to do
		switch( m_nDupeFileDlgReturnCode )
		{
			case IDC_USE_EXISTING_ALL_FILES:
			case IDC_USE_EMBEDDED_ALL_FILES:
			case IDC_KEEP_BOTH_ALL_FILES:
				nReturn = m_nDupeFileDlgReturnCode;
				break;

			default:
				nReturn = dlgDupeFile.DoModal();
				if( nReturn == IDC_USE_EXISTING_ALL_FILES
				||  nReturn == IDC_USE_EMBEDDED_ALL_FILES
				||  nReturn == IDC_KEEP_BOTH_ALL_FILES )
				{
					m_nDupeFileDlgReturnCode = nReturn;
				}
				break;
		}

		switch( nReturn )
		{
			case IDC_USE_EXISTING:
			case IDC_USE_EXISTING_ALL_FILES:
			case IDC_USE_EMBEDDED:
			case IDC_USE_EMBEDDED_ALL_FILES:
				// Get the FileNode's DocRoot node
				GUID guidFile;
				if( SUCCEEDED ( m_pIFramework8->GetNodeFileGUID ( pIDupeFileNode, &guidFile ) ) )
				{
					IDMUSProdNode* pIDupeDocRootNode;
					if( SUCCEEDED ( m_pIFramework8->FindDocRootNodeByFileGUID(guidFile, &pIDupeDocRootNode) ) )
					{
						*ppIDupeDocRootNode = pIDupeDocRootNode;
					}
				}
				break;
			
			case IDC_KEEP_BOTH:
			case IDC_KEEP_BOTH_ALL_FILES:
				// Don't need to open the file to get the FileNode's DocRoot node
				break;

			default:
				// Should not happen!
				ASSERT( 0 );
				break;
		}
	}
		
	RELEASE( pIDupeFileNode );
	RELEASE( pIDocType );
	return nReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::LoadEmbeddedFile

IDMUSProdNode* CContainerComponent::LoadEmbeddedFile( CLSID clsidDMObject, IStream* pIStream )
{
	IDMUSProdNode*		pITheDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdNode*		pIDocRootNode;
	IDMUSProdNode*		pIDupeDocRootNode;
	IDMUSProdNode*		pINewDocRootNode;
	IDMUSProdComponent* pIComponent;
	HRESULT				hr;

	ASSERT( m_pIFramework8 != NULL );
	ASSERT( pIStream != NULL );

	// No need to load the file again if it is already loaded
	EmbeddedFile* pTheEmbeddedFile = NULL;
	DWORD dwStreamPos = StreamTell( pIStream );
	POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
	while( pos )
	{
		EmbeddedFile* pEmbeddedFile = m_lstEmbeddedFiles.GetNext( pos );

		if( pEmbeddedFile->dwStreamPos == dwStreamPos )
		{
			pTheEmbeddedFile = pEmbeddedFile;

			ASSERT( ::IsEqualGUID(pEmbeddedFile->guidDMClass, clsidDMObject) );
			if( ::IsEqualGUID(pEmbeddedFile->guidFile, GUID_AllZeros) == FALSE )
			{
				if( SUCCEEDED ( m_pIFramework8->FindDocRootNodeByFileGUID( pEmbeddedFile->guidFile, &pIDocRootNode ) ) )
				{
					return pIDocRootNode;
				}
			}
			break;
		}
	}
	ASSERT( pTheEmbeddedFile );	// Just to make sure the EmbeddedFile list was built correctly

	// Set flag to indicate we are in the process of loading this embedded file
	if( pTheEmbeddedFile )
	{
		pTheEmbeddedFile->fBeingLoaded = true;
	}

	// Get RegisteredObject corresponding to clsidDMObject
	RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( clsidDMObject );
	if( pRegisteredObject == NULL )
	{
		goto ON_ERROR;
	}

	// Load the object
	if( SUCCEEDED ( m_pIFramework8->FindComponent( pRegisteredObject->clsidComponent, &pIComponent ) ) )
	{
		IDMUSProdRIFFExt* pIRIFFExt;
		if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			if( ::IsEqualGUID( pRegisteredObject->clsidComponent, CLSID_DLSComponent ) )
			{
				// We don't want DLS Designer to download wave/collection at this point in time
				IDMUSProdNotifySink* pINotifySink;
				if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
				{
					BOOL fDownload = FALSE;
					pINotifySink->OnUpdate( NULL, GUID_DownloadOnLoadRIFFChunk, &fDownload ); 

					RELEASE( pINotifySink );
				}
			}
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pIDocRootNode );
			if( SUCCEEDED ( hr ) )
			{
				// Set root and parent node of ALL children
				theApp.SetNodePointers( pIDocRootNode, pIDocRootNode, NULL );

				int nReturn = DetermineAction( pIDocRootNode, pRegisteredObject, pIStream, &pIDupeDocRootNode );

				switch( nReturn )
				{
					case IDC_USE_EXISTING:
					case IDC_USE_EXISTING_ALL_FILES:
						// Use the file in the Project Tree
						pITheDocRootNode = pIDupeDocRootNode;
						break;

					case IDC_USE_EMBEDDED:
					case IDC_USE_EMBEDDED_ALL_FILES:
					case IDC_KEEP_BOTH:
					case IDC_KEEP_BOTH_ALL_FILES:
					{
						// Get the target directory
						DMUSProdStreamInfo	StreamInfo;
						StreamInfo.pITargetDirectoryNode = NULL;

						// Get additional stream information
						IDMUSProdPersistInfo* pPersistInfo;
						if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
						{
							pPersistInfo->GetStreamInfo( &StreamInfo );
							pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
							pPersistInfo->Release();
						}

						// Place embedded file in the Project Tree
						if( SUCCEEDED ( m_pIFramework8->CopyFile( pIDocRootNode, pITargetDirectoryNode, &pINewDocRootNode ) ) )
						{
							// Use the embedded file that was just placed in the Project Tree
							pITheDocRootNode = pINewDocRootNode;

							if( nReturn == IDC_USE_EMBEDDED 
							||  nReturn == IDC_USE_EMBEDDED_ALL_FILES )
							{
								if( pIDupeDocRootNode )
								{
									// Update all references to point to the new file
									m_pIFramework8->NotifyNodes( pIDupeDocRootNode, FRAMEWORK_FileReplaced, pINewDocRootNode );
									// Delete the duplicate file
									pIDupeDocRootNode->DeleteNode( FALSE );
								}
							}
						}
						RELEASE( pIDupeDocRootNode );
						break;
					}

					default:
						// Should not happen
						ASSERT( 0 );
						break;
				}

				pIDocRootNode->DeleteNode( FALSE );
				RELEASE( pIDocRootNode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIComponent);
	}

ON_ERROR:
	if( pTheEmbeddedFile )
	{
		pTheEmbeddedFile->fBeingLoaded = false;
	    
		if( pITheDocRootNode )
		{
			m_pIFramework8->GetNodeFileGUID( pITheDocRootNode, &pTheEmbeddedFile->guidFile );

			// Send FRAMEWORK_FileLoadFinished notifications
			while( !pTheEmbeddedFile->m_lstNotifyWhenLoadFinished.IsEmpty() )
			{
				IDMUSProdNotifySink* pINotifySink = pTheEmbeddedFile->m_lstNotifyWhenLoadFinished.RemoveHead();

				pINotifySink->OnUpdate( pITheDocRootNode, FRAMEWORK_FileLoadFinished, &pTheEmbeddedFile->guidNotification );  
				RELEASE( pINotifySink );
			}
		}
	}

	return pITheDocRootNode;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::FindReferencedFile

HRESULT CContainerComponent::FindReferencedFile( CContainerObject* pObject,
											     CLSID clsidDMObject, CString strObjectName,
												 IStream* pIStream, IDMUSProdNode** ppIDocRootNode )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	BSTR				bstrObjectName;
	HRESULT				hr;

	ASSERT( m_pIFramework8 != NULL );
	ASSERT( strObjectName.IsEmpty() == FALSE );
	ASSERT( pIStream != NULL );

	// Get RegisteredObject corresponding to clsidDMObject
	RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( clsidDMObject );
	if( pRegisteredObject == NULL )
	{
		goto ON_ERROR;
	}

	// Get DocType for guidNodeId;
	hr = m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// If a target directory is not associated with the stream
	// use the container's DocRoot node
	if( pITargetDirectoryNode == NULL )
	{
		IDMUSProdNode* pIDocNode;
		if( SUCCEEDED ( pObject->GetDocRootNode( &pIDocNode ) ) )
		{
			pITargetDirectoryNode = pIDocNode;
			RELEASE( pIDocNode );
		}
	}

	// See if there is an "XXX object" named 'strObjectName' in this Project
	bstrObjectName = strObjectName.AllocSysString();
	hr = m_pIFramework8->GetBestGuessDocRootNode( pIDocType, bstrObjectName, pITargetDirectoryNode, &pIDocRootNode );
	if( FAILED ( hr ) )
	{
		pIDocRootNode = NULL;
		if( hr == E_PENDING )
		{
			// File is in process of being loaded
			// Store temporary GUID so we can resolve reference in our handler 
			// for the FRAMEWORK_FileLoadFinished notification
			bstrObjectName = strObjectName.AllocSysString();
			pObject->ResolveBestGuessWhenLoadFinished( pIDocType, bstrObjectName, pITargetDirectoryNode );
			goto ON_ERROR;
		}
	}

	if( pIDocRootNode == NULL )
	{
		// Determine File Open dialog prompt
		CString	strOpenDlgTitle;
		AfxFormatString2( strOpenDlgTitle, IDS_FILE_OPEN_OBJECT, strObjectName, pRegisteredObject->strObjectType );
		BSTR bstrOpenDlgTitle = strOpenDlgTitle.AllocSysString();

		// Display File open dialog
		hr = m_pIFramework8->OpenFile( pIDocType, bstrOpenDlgTitle, pITargetDirectoryNode, &pIDocRootNode );
		if( hr != S_OK )
		{
			// Did not open a file, or opened file other than expected type of file
			// so we do not want this DocRoot
			RELEASE( pIDocRootNode );
		}
	}

ON_ERROR:
	RELEASE( pIDocType );

	*ppIDocRootNode = pIDocRootNode;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::AddToContainerFileList

void CContainerComponent::AddToContainerFileList( CDirectMusicContainer* pContainer )
{
	if( pContainer )
	{
		GUID guidContainer;
		pContainer->GetGUID( &guidContainer );

		// Prevent duplicate object GUIDs
		GUID guidContainerList;
		POSITION pos = m_lstContainers.GetHeadPosition();
		while( pos )
		{
			CDirectMusicContainer* pContainerList = m_lstContainers.GetNext( pos );

			pContainerList->GetGUID( &guidContainerList );
			if( ::IsEqualGUID( guidContainerList, guidContainer ) )
			{
				::CoCreateGuid( &guidContainer );
				pContainer->SetGUID( guidContainer );
				break;
			}
		}

		// Add to list
		pContainer->AddRef();
		m_lstContainers.AddTail( pContainer );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::RemoveFromContainerFileList

void CContainerComponent::RemoveFromContainerFileList( CDirectMusicContainer* pContainer )
{
	if( pContainer )
	{
		// Remove from list
		POSITION pos = m_lstContainers.Find( pContainer );
		if( pos )
		{
			m_lstContainers.RemoveAt( pos );
			pContainer->Release();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::CreateEmbeddedFileList

HRESULT CContainerComponent::CreateEmbeddedFileList( IStream* pIStream )
{
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	m_dwEmbeddedFileListUseCount++;

	if( m_dwEmbeddedFileListUseCount > 1 )
	{
		return S_OK;
	}

	m_pIEmbeddedFileStream = pIStream;
	m_pIEmbeddedFileStream->AddRef();

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = S_OK;

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		// Make sure the file containing this Container is stored in m_pEmbeddedFileRootFile
		DWORD dwCurrentFilePos = StreamTell( pIStream );
		if( dwCurrentFilePos > 0 )
		{
			MMCKINFO ckThisFile;

			StreamSeek( pIStream, 0, 0 );
			if( pIRiffStream->Descend( &ckThisFile, 0, 0 ) == 0 )
			{
				RegisteredObject* pRegisteredObject = FindRegisteredObjectByRIFFIds( ckThisFile.ckid, ckThisFile.fccType );
				if( pRegisteredObject )
				{
					IDMUSProdDocType* pIDocType;
					if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocType ) ) )
					{
						DMUSProdListInfo ListInfo;
						ZeroMemory( &ListInfo, sizeof(ListInfo) );
						ListInfo.wSize = sizeof(ListInfo);

						StreamSeek( pIStream, 0, 0 );
						if( SUCCEEDED ( pIDocType->GetListInfo ( pIStream, &ListInfo ) ) )
						{
							EmbeddedFile* pEmbeddedFile = new EmbeddedFile();
							if( pEmbeddedFile )
							{
								pEmbeddedFile->dwStreamPos = 0;
								pEmbeddedFile->fBeingLoaded = true;
								pEmbeddedFile->guidDMClass = pRegisteredObject->clsidDMObject;

								if( ListInfo.bstrName )
								{
									pEmbeddedFile->strObjectName = ListInfo.bstrName;
									::SysFreeString( ListInfo.bstrName );
								}
								if( ListInfo.bstrDescriptor )
								{
									::SysFreeString( ListInfo.bstrDescriptor );
								}
								memcpy( &pEmbeddedFile->guidObject, &ListInfo.guidObject, sizeof(GUID) );

								if( m_pEmbeddedFileRootFile )
								{
									// Names are equal
									if( pEmbeddedFile->strObjectName.Compare(m_pEmbeddedFileRootFile->strObjectName) == 0 )
									{
										// GUIDs are equal
										if( ::IsEqualGUID(pEmbeddedFile->guidDMClass, m_pEmbeddedFileRootFile->guidDMClass)
										&&  ::IsEqualGUID(pEmbeddedFile->guidObject, m_pEmbeddedFileRootFile->guidObject) )
										{
											// We must keep the notification GUID
											pEmbeddedFile->guidNotification = m_pEmbeddedFileRootFile->guidNotification;
										}
									}
									delete m_pEmbeddedFileRootFile;
									m_pEmbeddedFileRootFile = NULL;
								}
								m_pEmbeddedFileRootFile = pEmbeddedFile;
							}
						}

						RELEASE( pIDocType );
					}
				}
			}
			StreamSeek( pIStream, dwCurrentFilePos, 0 );
		}

		// Make sure all files embedded in this Container are placed in the EmbeddedFile list
		ckMain.fccType = DMUS_FOURCC_CONTAINER_FORM;
		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			hr = ParseContainerForEmbeddedFiles( pIRiffStream, &ckMain );
		}

		RELEASE( pIRiffStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::ReleaseEmbeddedFileList

void CContainerComponent::ReleaseEmbeddedFileList( void )
{
    ASSERT( m_dwEmbeddedFileListUseCount != 0 );

    m_dwEmbeddedFileListUseCount--;

    if( m_dwEmbeddedFileListUseCount == 0 )
    {
 		EmbeddedFile* pEmbeddedFile;
		while( !m_lstEmbeddedFiles.IsEmpty() )
		{
			pEmbeddedFile = static_cast<EmbeddedFile*>( m_lstEmbeddedFiles.RemoveHead() );
			delete pEmbeddedFile;
		}

		RELEASE( m_pIEmbeddedFileStream );
    }
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::ParseContainerForEmbeddedFiles

HRESULT CContainerComponent::ParseContainerForEmbeddedFiles( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*    pIStream;
	MMCKINFO	ck;
	MMCKINFO	ckList;
    HRESULT     hr = S_OK;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_CONTAINED_OBJECTS_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_LIST:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_CONTAINED_OBJECT_LIST:
											hr = AddEmbeddedFileListItem( pIRiffStream, &ckList );
											if( FAILED ( hr ) )
											{
												ASSERT( 0 );
												goto ON_ERROR;
											}
											else if( hr == S_FALSE )
											{
												// File was referenced
												// Change S_FALSE to S_OK
												hr = S_OK;
											}
											break;
									}
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::AddEmbeddedFileListItem

HRESULT CContainerComponent::AddEmbeddedFileListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*    pIStream;
	MMCKINFO	ck;
	DWORD		dwByteCount;
	DWORD		dwSize;
	DWORD		dwStartFilePos;
	DWORD		dwInsideFilePos;
    HRESULT     hr = S_OK;

	EmbeddedFile* pEmbeddedFile = NULL;
	DWORD		  dwRIFFckid = 0;
	DWORD		  dwRIFFfccType = 0;
	CLSID		  clsidDMObject;
	memset( &clsidDMObject, 0, sizeof(CLSID) );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwStartFilePos = StreamTell( pIStream );

	// Find DMUS_FOURCC_CONTAINED_OBJECT_CHUNK
	ck.ckid = DMUS_FOURCC_CONTAINED_OBJECT_CHUNK;
	if( pIRiffStream->Descend( &ck, pckMain, MMIO_FINDCHUNK ) == 0 )
	{
		DMUS_IO_CONTAINED_OBJECT_HEADER dmusContainedObjectIO;

		dwSize = min( ck.cksize, sizeof( DMUS_IO_CONTAINED_OBJECT_HEADER ) );
		hr = pIStream->Read( &dmusContainedObjectIO, dwSize, &dwByteCount );
		if( FAILED( hr )
		||  dwByteCount != dwSize )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		clsidDMObject = dmusContainedObjectIO.guidClassID;
		dwRIFFckid = dmusContainedObjectIO.ckid;
		dwRIFFfccType = dmusContainedObjectIO.fccType;
	}
	else
	{
		ASSERT( 0 );
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Find DMUS_FOURCC_REF_LIST - Is file embedded or referenced?
	ck.fccType = DMUS_FOURCC_REF_LIST;
	if( pIRiffStream->Descend( &ck, pckMain, MMIO_FINDLIST ) == 0 )
	{
		// File is referenced, nothing more to do
		hr = S_FALSE;
		goto ON_ERROR;
	}

	// Process embedded file
	{
		StreamSeek( pIStream, dwStartFilePos, 0 );

		MMCKINFO ckEmbeddedFile;
		ckEmbeddedFile.ckid = dwRIFFckid;
		ckEmbeddedFile.fccType = dwRIFFfccType;

		if( ckEmbeddedFile.ckid == FOURCC_RIFF )
		{
			if( pIRiffStream->Descend( &ckEmbeddedFile, pckMain, MMIO_FINDRIFF ) == 0 )
			{
				if( ckEmbeddedFile.fccType == mmioFOURCC('W','A','V','E') 
				&&  ::IsEqualGUID(clsidDMObject, CLSID_DirectMusicSegment) ) 
				{
					// CLSID_DirectSoundWave was saved as CLSID_DirectMusicSegment
					// so convert it bak to CLSID_DirectSoundWave
					clsidDMObject = CLSID_DirectSoundWave;
				}
			    dwInsideFilePos = StreamTell( pIStream );
				StreamSeek( pIStream, -12, STREAM_SEEK_CUR );
			}
			else
			{
				ASSERT( 0 );
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
		else if( ckEmbeddedFile.ckid == FOURCC_LIST )
		{
			if( pIRiffStream->Descend( &ckEmbeddedFile, pckMain, MMIO_FINDLIST ) == 0 )
			{
			    dwInsideFilePos = StreamTell( pIStream );
				StreamSeek( pIStream, -12, STREAM_SEEK_CUR );
			}
			else
			{
				ASSERT( 0 );
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
		else
		{
			if( pIRiffStream->Descend( &ckEmbeddedFile, pckMain, MMIO_FINDCHUNK ) == 0 )
			{
			    dwInsideFilePos = StreamTell( pIStream );
				StreamSeek( pIStream, -8, STREAM_SEEK_CUR );
			}
			else
			{
				ASSERT( 0 );
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Fill in the EmbeddedFile struct
		if( SUCCEEDED ( hr ) )
		{
			hr = E_FAIL;

			pEmbeddedFile = new EmbeddedFile();
			if( pEmbeddedFile == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERROR;
			}

			pEmbeddedFile->dwStreamPos = StreamTell( pIStream );
			pEmbeddedFile->guidDMClass = clsidDMObject;

			// Get RegisteredObject corresponding to pEmbeddedFile->guidClass
			RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( pEmbeddedFile->guidDMClass );
			if( pRegisteredObject )
			{
				// Get DocType for corresponding guidNodeId
				IDMUSProdDocType* pIDocType;
				if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocType ) ) )
				{
					DMUSProdListInfo ListInfo;
					ZeroMemory( &ListInfo, sizeof(ListInfo) );
					ListInfo.wSize = sizeof(ListInfo);

					if( SUCCEEDED ( pIDocType->GetListInfo ( pIStream, &ListInfo ) ) )
					{
						if( ListInfo.bstrName )
						{
							pEmbeddedFile->strObjectName = ListInfo.bstrName;
							::SysFreeString( ListInfo.bstrName );
						}
						if( ListInfo.bstrDescriptor )
						{
							::SysFreeString( ListInfo.bstrDescriptor );
						}
						memcpy( &pEmbeddedFile->guidObject, &ListInfo.guidObject, sizeof(GUID) );

						hr = S_OK;
					}

					RELEASE( pIDocType );
				}
			}
		}
	}

ON_ERROR:
	if( hr == S_OK )
	{
		if( pEmbeddedFile )
		{
			// Keep track of the embedded file's stream position
			m_lstEmbeddedFiles.AddTail( pEmbeddedFile );

			// Look for a container in this embedded file
			MMCKINFO ckEmbeddedFile;
			StreamSeek( pIStream, dwInsideFilePos, 0 );
			ckEmbeddedFile.fccType = DMUS_FOURCC_CONTAINER_FORM;
			if( pIRiffStream->Descend( &ckEmbeddedFile, NULL, MMIO_FINDRIFF ) == 0 )
			{
				hr = ParseContainerForEmbeddedFiles( pIRiffStream, &ckEmbeddedFile );
			}
		}
		else
		{
			hr = E_UNEXPECTED;
		}
	}
	else
	{
		if( pEmbeddedFile )
		{
			delete pEmbeddedFile;
		}
	}
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerComponent::FindEmbeddedFile

EmbeddedFile* CContainerComponent::FindEmbeddedFile( IDMUSProdDocType* pIDocType, CString& strObjectName )
{
	ASSERT( m_pIFramework8 != NULL );

	EmbeddedFile* pTheEmbeddedFile = NULL;

	// This 'private' method must also search m_pEmbeddedFileRootFile
	if( m_pEmbeddedFileRootFile )
	{
		if( strObjectName.CompareNoCase( m_pEmbeddedFileRootFile->strObjectName ) == 0 )
		{
			// Object names are equal
			RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( m_pEmbeddedFileRootFile->guidDMClass );
			if( pRegisteredObject )
			{
				// Check to see if CLSID is type of object we want
				IDMUSProdDocType* pIDocTypeList;
				if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocTypeList ) ) )
				{
					if( pIDocTypeList == pIDocType )
					{
						pTheEmbeddedFile = m_pEmbeddedFileRootFile;
					}
				
					RELEASE( pIDocTypeList );
				}
			}

			if( pTheEmbeddedFile )
			{
				return pTheEmbeddedFile;
			}
		}
	}
	
	// Search m_lstEmbeddedFiles
	POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
	while( pos )
	{
		EmbeddedFile* pEmbeddedFile = m_lstEmbeddedFiles.GetNext( pos );

		if( strObjectName.CompareNoCase( pEmbeddedFile->strObjectName ) == 0 )
		{
			// Object names are equal
			RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( pEmbeddedFile->guidDMClass );
			if( pRegisteredObject )
			{
				// Check to see if CLSID is type of object we want
				IDMUSProdDocType* pIDocTypeList;
				if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocTypeList ) ) )
				{
					if( pIDocTypeList == pIDocType )
					{
						pTheEmbeddedFile =  pEmbeddedFile;
						RELEASE( pIDocTypeList );
						break;
					}
				
					RELEASE( pIDocTypeList );
				}
			}
		}
	}

	return pTheEmbeddedFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\Container.h ===
#ifndef __CONTAINER_H__
#define __CONTAINER_H__

// Container.h : header file
//

#include <RiffStrm.h>
#include "ContainerComponent.h"
#include "ContainerDocType.h"
#include "Folder.h"

class CDirectMusicContainer;


#define MAX_FILE_PRIORITY	10

class CObjectToSave
{
public:
	CObjectToSave( CContainerObject* pContainerObject, BOOL fFromReferenceFolder );
	~CObjectToSave();

protected:
	short GetPriority();

public:	
	CContainerObject*	m_pContainerObject;
	short				m_nPriority;
	BOOL				m_fFromReferenceFolder;
};


//////////////////////////////////////////////////////////////////////
//  CContainerPropPageManager

class CContainerPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabContainer;
friend class CTabInfo;

public:
	CContainerPropPageManager();
	virtual ~CContainerPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabContainer*				m_pTabContainer;
	CTabInfo*					m_pTabInfo;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CDirectMusicContainer

class CDirectMusicContainer : public IDMUSProdNode, public IPersistStream, public IDMUSProdPropPageObject,
							  public IDMUSProdNotifySink, IDMUSProdContainerInfo
{
friend class CContainerDocType;
friend class CContainerCtrl;
friend class CContainerDlg;
friend class CTabContainer;
friend class CTabInfo;
friend class CTabObjectFlags;
friend class CFolder;

public:
    CDirectMusicContainer();
	~CDirectMusicContainer();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdNotifySink
	HRESULT STDMETHODCALLTYPE OnUpdate( IDMUSProdNode* pINode, GUID guidUpdateType, VOID* pData );

	// IDMUSProdContainerInfo
    HRESULT STDMETHODCALLTYPE FindDocRootFromName( BSTR bstrName, IUnknown** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE FindDocRootFromScriptAlias( BSTR bstrAlias, IUnknown** ppIDocRootNode );

	//Additional functions
protected:
	HRESULT LoadContainer( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT SaveContainer( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveHeader( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveGUID( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveInfoList( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveVersion( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveObjects( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT IsCircularReference( IDMUSProdNode* pIDocRootNode, CFolder* pTargetFolder ); 
	
	HRESULT CreateObjectsToSaveList( CTypedPtrList<CPtrList, CObjectToSave*>& list );
	void InsertObjectToSave( CTypedPtrList<CPtrList, CObjectToSave*>& list, CObjectToSave* pObjectToInsert );

public:
	HRESULT ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo );
	BOOL CreateUndoMgr();
	BOOL IsInScript();
	BOOL IsInSegment();
	BOOL IsScriptAliasUnique( CContainerObject* pObject );
	void MakeUniqueScriptAlias( CContainerObject* pObject );
	void SetModified( BOOL fModified );
	void SyncContainerEditor();
	HRESULT IsDocRootInContainer( IDMUSProdNode* pIDocRootNode );
	HRESULT IsFileGUIDInContainer( GUID guidFile );
	void GetGUID( GUID* pguidContainer );
	void SetGUID( GUID guidContainer );
	void OnAddRemoveFiles();

private:
    DWORD				m_dwRef;
	BOOL				m_fModified;

	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*	    m_pIParentNode;

	HWND				m_hWndEditor;

public:
	CString				m_strOrigFileName;
	CContainerCtrl*		m_pContainerCtrl;
	IDMUSProdNode*		m_pINodeBeingDeleted;
	IDMUSProdProject*	m_pIProject;
	CJazzUndoMan*		m_pUndoMgr;

private:
	CFolder				m_FolderEmbed;
	CFolder				m_FolderReference;

    // Persisted for DirectMusic
    CString				m_strName;
    CString				m_strAuthor;
    CString				m_strCopyright;
    CString				m_strSubject;
    CString				m_strInfo;
	GUID				m_guidContainer;
	DMUS_VERSION        m_vVersion;
	DWORD				m_dwFlagsDM;
};

#endif // __CONTAINER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerComponent.h ===
#ifndef __CONTAINERCOMPONENT_H__
#define __CONTAINERCOMPONENT_H__

// ContainerComponent.h : header file
//

#include <afxtempl.h>
#include <Conductor.h>
#include <PrivateUnpackingFiles.h>


class CDirectMusicContainer;
class CContainerObject;


/////////////////////////////////////////////////////////////////////
// Structures
//

#pragma pack(2)

typedef struct RegisteredObject
{
	RegisteredObject()
	{
		memset( &guidNodeId, 0, sizeof(GUID) );
		memset( &guidRefNodeId, 0, sizeof(GUID) );
		memset( &clsidComponent, 0, sizeof(CLSID) );
		memset( &clsidDMObject, 0, sizeof(CLSID) );
		dwRIFFckid = 0;
		dwRIFFfccType = 0;
	}

	GUID    guidNodeId;
	GUID    guidRefNodeId;
	CLSID	clsidComponent;
	CLSID	clsidDMObject;
	CString strObjectType;
	DWORD	dwRIFFckid;
	DWORD	dwRIFFfccType;
} RegisteredObject;

typedef struct EmbeddedFile
{
	EmbeddedFile()
	{
		dwStreamPos = 0;
		memset( &guidDMClass, 0, sizeof(GUID) );
		memset( &guidObject, 0, sizeof(GUID) );
		memset( &guidFile, 0, sizeof(GUID) );
		CoCreateGuid( &guidNotification ); 
		fBeingLoaded = false;
	}

	~EmbeddedFile()
	{
 		IDMUSProdNotifySink* pINotifySink;
		while( !m_lstNotifyWhenLoadFinished.IsEmpty() )
		{
			pINotifySink = static_cast<IDMUSProdNotifySink*>( m_lstNotifyWhenLoadFinished.RemoveHead() );
			RELEASE( pINotifySink );
		}
	}

	DWORD		dwStreamPos;		// Stream position
    GUID        guidDMClass;		// DirectMusic GUID for the class of object
    GUID        guidObject;			// Unique GUID for this object
    CString		strObjectName;		// Name of object

	// Filled in when file is actually loaded
	GUID        guidFile;			// Producer generated GUID
	GUID		guidNotification;	// Used for FRAMEWORK_FileLoadFinished notifications
	bool		fBeingLoaded;		// Indicates file in process of loading
	CTypedPtrList<CPtrList, IDMUSProdNotifySink*> m_lstNotifyWhenLoadFinished;
} EmbeddedFile;

#pragma pack()


/////////////////////////////////////////////////////////////////////
// CContainerComponent class
//

class CContainerComponent : public IDMUSProdComponent, public IDMUSProdRIFFExt, public IDMUSProdUnpackingFiles
{
public:
    CContainerComponent();
	~CContainerComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp( BOOL fActivate );

    // IDMUSProdRIFFExt functions
    HRESULT STDMETHODCALLTYPE LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode );

	// IDMUSProdUnpackingFiles functions
    HRESULT STDMETHODCALLTYPE GetDocRootOfEmbeddedFile( IUnknown* pIDocType, BSTR bstrObjectName, IUnknown** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE AddToNotifyWhenLoadFinished( IUnknown* pIDocType, BSTR bstrObjectName, IUnknown* punkNotifySink, GUID* pguidFile );

    // Additional functions
private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists();
	BOOL RegisterClipboardFormats();
	void ReleaseAll();
	BOOL LoadRegisteredObjects();

public:
    HRESULT STDMETHODCALLTYPE GetContainerImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetContainerRefImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFolderImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFolderGrayImageIndex( short* pnNbrFirstImage );
	HRESULT STDMETHODCALLTYPE IsRegisteredObject( IDMUSProdNode* pIDocRootNode );
	HRESULT STDMETHODCALLTYPE CreateRefNode( IDMUSProdNode* pIDocRootNode, IDMUSProdNode** ppIRefNode );
	RegisteredObject* FindRegisteredObjectByCLSID( CLSID clsidDMObject );
	RegisteredObject* FindRegisteredObjectByDocRoot( IDMUSProdNode* pIDocRootNode );
	RegisteredObject* FindRegisteredObjectByRIFFIds( DWORD dwRIFFckid, DWORD dwRIFFfccType );
	HRESULT FindReferencedFile( CContainerObject* pObject, CLSID clsidDMObject, CString strObjectName, IStream* pIStream, IDMUSProdNode** ppIDocRootNode );
	IDMUSProdNode* LoadEmbeddedFile( CLSID clsidDMObject, IStream* pIStream );
	int DetermineAction( IDMUSProdNode* pIDocRootNode, RegisteredObject* pRegisteredObject, IStream* pIStream, IDMUSProdNode** ppIDupeDocRootNode );
	void AddToContainerFileList( CDirectMusicContainer* pContainer );
	void RemoveFromContainerFileList( CDirectMusicContainer* pContainer );

	// EmbeddedFile list methods
	HRESULT CreateEmbeddedFileList( IStream* pIStream );
	void ReleaseEmbeddedFileList();
	HRESULT ParseContainerForEmbeddedFiles( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT AddEmbeddedFileListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	EmbeddedFile* FindEmbeddedFile( IDMUSProdDocType* pIDocType, CString& strObjectName );

public:
	IDMUSProdFramework8*		m_pIFramework8;
	IDirectMusicPerformance*	m_pIDMPerformance;
	IDMUSProdConductor*			m_pIConductor;
	short						m_nNextContainer;		// appended to name of new Container
	UINT						m_cfProducerFile;		// CF_DMUSPROD_FILE clipboard format
	UINT						m_cfContainer;			// CF_CONTAINER clipboard format
	UINT						m_cfContainerList;		// CF_CONTAINERLIST clipboard format
	
	// Used when unpacking files from runtime Container
    DWORD						m_dwEmbeddedFileListUseCount;
    IStream*					m_pIEmbeddedFileStream;
	EmbeddedFile*				m_pEmbeddedFileRootFile;
	CTypedPtrList<CPtrList, EmbeddedFile*> m_lstEmbeddedFiles;
	
	// Used when unpacking duplicate files from runtime Container
	IDMUSProdNode*				m_pContainerBeingLoaded;
	IDMUSProdProject*			m_pIDupeFileTargetProject;
	int							m_nDupeFileDlgReturnCode;

private:
    DWORD						m_dwRef;
	IDMUSProdDocType8*			m_pIContainerDocType8;
	short						m_nFirstImage;

	CTypedPtrList<CPtrList, CDirectMusicContainer*> m_lstContainers;
	CTypedPtrList<CPtrList, RegisteredObject*> m_lstRegisteredObjects;
};

#endif // __CONTAINERCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\Container.cpp ===
// Container.cpp : implementation file
//

#include "stdafx.h"
#include "ContainerDesignerDLL.h"

#include "RiffStrm.h"
#include "Container.h"
#include <mmreg.h>
#include <math.h>
#include "TabContainer.h"
#include "TabInfo.h"
#include "ContainerCtl.h"
#include "DlgAddFiles.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// {F078ACC0-67AA-11d3-B45D-00105A2796DE}
static const GUID GUID_ContainerPropPageManager = 
{ 0xf078acc0, 0x67aa, 0x11d3, { 0xb4, 0x5d, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde } };

short CContainerPropPageManager::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CContainerPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CContainerPropPageManager::CContainerPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabContainer = NULL;
	m_pTabInfo = NULL;
}

CContainerPropPageManager::~CContainerPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabContainer )
	{
		delete m_pTabContainer;
	}

	if( m_pTabInfo )
	{
		delete m_pTabInfo;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager::RemoveCurrentObject

void CContainerPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager IUnknown implementation

HRESULT CContainerPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CContainerPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CContainerPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CContainerPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_CONTAINER_TEXT );

	CDirectMusicContainer *pContainer;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pContainer))) )
	{
		CString strNodeName;
		BSTR bstrNodeName;

		if( SUCCEEDED ( pContainer->GetNodeName( &bstrNodeName ) ) )
		{
			strNodeName = bstrNodeName;
			::SysFreeString( bstrNodeName );
		}
		strTitle = strNodeName + _T(" ") + strTitle;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CContainerPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Container tab
	m_pTabContainer = new CTabContainer( this );
	if( m_pTabContainer )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabContainer->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Info tab
	m_pTabInfo = new CTabInfo( this );
	if( m_pTabInfo )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabInfo->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CContainerPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CContainerPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CContainerPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CContainerPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CContainerPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CContainerPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicContainer* pContainer;
	
	if( m_pIPropPageObject == NULL )
	{
		pContainer = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pContainer ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Container are processed in OnKillFocus
	// messages before setting the new Container
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabContainer->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new Container
	m_pTabContainer->SetContainer( pContainer);
	m_pTabInfo->SetContainer( pContainer);

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CContainerPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_ContainerPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CObjectToSave constructor/destructor 

CObjectToSave::CObjectToSave( CContainerObject* pContainerObject, BOOL fFromReferenceFolder )
{
	ASSERT( pContainerObject != NULL );
	m_pContainerObject = pContainerObject;

	m_fFromReferenceFolder = fFromReferenceFolder;
	m_nPriority = GetPriority();
}

CObjectToSave::~CObjectToSave()
{
}

short CObjectToSave::GetPriority( void )
{
	// (MAX_FILE_PRIORITY - 1) reserved for Container files
	// (MAX_FILE_PRIORITY - 2) reserved for Song files
	// (MAX_FILE_PRIORITY - 3) reserved for Segment files
	short nPriority = MAX_FILE_PRIORITY - 4;
	
	if( m_pContainerObject->m_FileRef.pIDocRootNode == NULL )
	{
		// Use the default priority
		return nPriority;
	}

	GUID guidNodeId;
	if( SUCCEEDED ( m_pContainerObject->m_FileRef.pIDocRootNode->GetNodeId( &guidNodeId ) ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_CollectionNode ) )
		{
			nPriority = 1;
		}
		else if( ::IsEqualGUID( guidNodeId, GUID_StyleNode ) )
		{
			nPriority = 2;
		}
		else if( ::IsEqualGUID( guidNodeId, GUID_PersonalityNode ) )
		{
			nPriority = 3;
		}
		else if( ::IsEqualGUID( guidNodeId, GUID_WaveNode ) )
		{
			nPriority = 4;
		}
		else if( ::IsEqualGUID( guidNodeId, GUID_ScriptNode ) )
		{
			nPriority = 5;
		}
		else if( ::IsEqualGUID( guidNodeId, GUID_SegmentNode ) )
		{
			nPriority = MAX_FILE_PRIORITY - 3;
		}
		/*
		else if( ::IsEqualGUID( guidNodeId, GUID_SongNode ) )
		{
			nPriority = MAX_FILE_PRIORITY - 2;
		}
		*/
		else if( ::IsEqualGUID( guidNodeId, GUID_ContainerNode ) )
		{
			nPriority = MAX_FILE_PRIORITY - 1;
		}
	}
	
	return nPriority;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer constructor/destructor

CDirectMusicContainer::CDirectMusicContainer()
{
	ASSERT( theApp.m_pContainerComponent != NULL );

	// Container needs Container Component
	theApp.m_pContainerComponent->AddRef();

    m_dwRef = 0;
	AddRef();

	m_pUndoMgr = NULL;
	m_fModified = FALSE;

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;

	m_hWndEditor = NULL;
	m_pContainerCtrl = NULL;
	m_pINodeBeingDeleted = NULL;
	m_pIProject = NULL;

	TCHAR achName[MID_BUFFER];

	m_FolderEmbed.m_pContainer = this;
	m_FolderEmbed.m_guidTypeNode = GUID_ContainerEmbedFolderNode;
	::LoadString( theApp.m_hInstance, IDS_EMBED_FOLDER_NAME, achName, MID_BUFFER );
	m_FolderEmbed.m_strName = achName;

	m_FolderReference.m_pContainer = this;
	m_FolderReference.m_guidTypeNode = GUID_ContainerRefFolderNode;
	::LoadString( theApp.m_hInstance, IDS_REF_FOLDER_NAME, achName, MID_BUFFER );
	m_FolderReference.m_strName = achName;

// Container info block
	::LoadString( theApp.m_hInstance, IDS_CONTAINER_TEXT, achName, MID_BUFFER );
    m_strName.Format( "%s%d", achName, ++theApp.m_pContainerComponent->m_nNextContainer );

	CoCreateGuid( &m_guidContainer ); 
	m_vVersion.dwVersionMS = 0x00010000;
	m_vVersion.dwVersionLS = 0x00000000;

	m_dwFlagsDM = 0;
}

CDirectMusicContainer::~CDirectMusicContainer()
{
	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	// Remove Container from clipboard
	theApp.FlushClipboard( this );

	// Remove Container from property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	// Cleanup the Undo Manager
	if( m_pUndoMgr )
	{
		delete m_pUndoMgr;
	}

	// Container no longer needs Container Component
	theApp.m_pContainerComponent->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::CreateUndoMgr

BOOL CDirectMusicContainer::CreateUndoMgr()
{
	// Should only be called once - after Container first created
	ASSERT( m_pUndoMgr == NULL );

	ASSERT( theApp.m_pContainerComponent != NULL ); 
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL ); 

	m_pUndoMgr = new CJazzUndoMan( theApp.m_pContainerComponent->m_pIFramework8 );
	if( m_pUndoMgr )
	{
		m_pUndoMgr->SetStreamAttributes( FT_DESIGN, GUID_CurrentVersion );
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::IsInScript

BOOL CDirectMusicContainer::IsInScript( void )
{
	BOOL fInScript = FALSE;

	if( m_pIParentNode )
	{
		GUID guidNodeId;
		if( SUCCEEDED ( m_pIParentNode->GetNodeId( &guidNodeId ) ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_ScriptNode ) )
			{
				fInScript = TRUE;
			}
		}
	}

	return fInScript;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::IsInSegment

BOOL CDirectMusicContainer::IsInSegment( void )
{
	BOOL fInSegment = FALSE;

	if( m_pIParentNode )
	{
		GUID guidNodeId;
		if( SUCCEEDED ( m_pIParentNode->GetNodeId( &guidNodeId ) ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_SegmentNode ) )
			{
				fInSegment = TRUE;
			}
		}
	}

	return fInSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::IsScriptAliasUnique

BOOL CDirectMusicContainer::IsScriptAliasUnique( CContainerObject* pObject )
{
	CContainerObject* pObjectList;
	CString strScriptAlias;
	CString strScriptAliasList;

	pObject->GetScriptAlias( strScriptAlias );

	// Check embedded files
	POSITION pos = m_FolderEmbed.m_lstObjects.GetHeadPosition();
	while( pos )
	{
		pObjectList = m_FolderEmbed.m_lstObjects.GetNext( pos );

		if( pObjectList != pObject )
		{
			pObjectList->GetScriptAlias( strScriptAliasList );
			if( strScriptAliasList.CompareNoCase( strScriptAlias ) == 0 )
			{
				return FALSE;
			}
		}
	}

	// Check referenced files
	pos = m_FolderReference.m_lstObjects.GetHeadPosition();
	while( pos )
	{
		pObjectList = m_FolderReference.m_lstObjects.GetNext( pos );

		if( pObjectList != pObject )
		{
			pObjectList->GetScriptAlias( strScriptAliasList );
			if( strScriptAliasList.CompareNoCase( strScriptAlias ) == 0 )
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::MakeUniqueScriptAlias

void CDirectMusicContainer::MakeUniqueScriptAlias( CContainerObject* pObject )
{
	CString	strAlias;
	CString	strOrigAlias;
	CString	strNbr;
	int	nOrigAliasLength;
	int	nNbrLength;
	int	i;

	// Get current script alias
	pObject->GetScriptAlias( strAlias );
	strAlias = strAlias.Left( DMUS_MAX_NAME );

	// Make sure alias starts with a letter
	for( i = 0 ;  i < strAlias.GetLength() ;  i++ )
	{
		if( _istalpha( strAlias[i] ) )
		{
			break;
		}
	}
	strAlias = strAlias.Right( strAlias.GetLength() - i );

	// Strip characters other than letters, digits and underscores
	for( i = 0 ;  i < strAlias.GetLength() ;  i++ )
	{
		if( _istalpha( strAlias[i] )
		||  _istdigit( strAlias[i] )
		||   strAlias[i] == _T('_') )
		{
			strOrigAlias +=  strAlias[i];
		}
	}

	// Make sure alias is not empty
	if( strOrigAlias.IsEmpty() )
	{
		strOrigAlias.LoadString( IDS_DEFAULT_SCRIPT_ALIAS );
	}

	// Update the object with the adjusted script alias
	pObject->SetScriptAlias( strOrigAlias );

	// Strip the number from the end of the script alias
	while( !strOrigAlias.IsEmpty()  &&  _istdigit(strOrigAlias[strOrigAlias.GetLength() - 1]) )
	{
		strNbr = strOrigAlias.Right(1) + strNbr;
		strOrigAlias = strOrigAlias.Left( strOrigAlias.GetLength() - 1 );
	}

	nOrigAliasLength = strOrigAlias.GetLength();
	i = _ttoi( strNbr );

	// Get a unique name
	while( IsScriptAliasUnique( pObject ) == FALSE )
	{
		strNbr.Format( "%d", ++i ); 
		nNbrLength = strNbr.GetLength();
		
		if( (nOrigAliasLength + nNbrLength) <= DMUS_MAX_NAME )
		{
			strAlias = strOrigAlias + strNbr;
		}
		else
		{
			strAlias = strOrigAlias.Left(DMUS_MAX_NAME - nNbrLength) + strNbr;
		}

		pObject->SetScriptAlias( strAlias );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::SyncContainerEditor

void CDirectMusicContainer::SyncContainerEditor( void )
{
// AMC delete??

//	if( m_pContainerCtrl
//	&&  m_pContainerCtrl->m_pContainerDlg )
//	{
//		m_pContainerCtrl->m_pContainerDlg->RefreshControls();
//	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::SetModified

void CDirectMusicContainer::SetModified( BOOL fModified )
{
	m_fModified = fModified;

	if( m_fModified )
	{
		if( m_pIDocRootNode
		&&  m_pIDocRootNode != this )
		{
			// Notify DocRoot that the container has changed
			IDMUSProdNotifySink* pINotifySink;
			if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
			{
				pINotifySink->OnUpdate( this, CONTAINER_ChangeNotification, NULL );

				RELEASE( pINotifySink );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IUnknown implementation

HRESULT CDirectMusicContainer::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdNode *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersist) )
    {
        *ppvObj = (IPersist *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        *ppvObj = (IPersistStream *)this;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        *ppvObj = (IDMUSProdPropPageObject *)this;
    }
	else if( ::IsEqualIID(riid, IID_IDMUSProdNotifySink) )
	{
		*ppvObj = (IDMUSProdNotifySink*) this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdContainerInfo) )
	{
		*ppvObj = (IDMUSProdContainerInfo*) this;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CDirectMusicContainer::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CDirectMusicContainer::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetNodeImageIndex

HRESULT CDirectMusicContainer::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );

	return( theApp.m_pContainerComponent->GetContainerImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetFirstChild

HRESULT CDirectMusicContainer::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	m_FolderEmbed.AddRef();
	*ppIFirstChildNode = (IDMUSProdNode *)&m_FolderEmbed;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetNextChild

HRESULT CDirectMusicContainer::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIChildNode == (IDMUSProdNode *)&m_FolderEmbed )
	{
		m_FolderReference.AddRef();
		*ppINextChildNode = (IDMUSProdNode *)&m_FolderReference;
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetComponent

HRESULT CDirectMusicContainer::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );

	return theApp.m_pContainerComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetDocRootNode

HRESULT CDirectMusicContainer::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::SetDocRootNode

HRESULT CDirectMusicContainer::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetParentNode

HRESULT CDirectMusicContainer::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if( m_pIParentNode )
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::SetParentNode

HRESULT CDirectMusicContainer::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetNodeId

HRESULT CDirectMusicContainer::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ContainerNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetNodeName

HRESULT CDirectMusicContainer::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetNodeNameMaxLength

HRESULT CDirectMusicContainer::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( IsInScript() ) 
	{
		// Can't rename a Container in a Script
		*pnMaxLength = -1;	
	}
	else
	{
		*pnMaxLength = DMUS_MAX_NAME;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::ValidateNodeName

HRESULT CDirectMusicContainer::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;

	strName = bstrName;
	::SysFreeString( bstrName );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::SetNodeName

HRESULT CDirectMusicContainer::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_strName == strName )
	{
		return S_OK;
	}

	m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_CONTAINER_NAME );
	m_strName = strName;

	// Sync change with property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		RELEASE( pIPropSheet );
	}
	
	SetModified( TRUE );

	// Notify connected nodes that Container name has changed
	theApp.m_pContainerComponent->m_pIFramework8->NotifyNodes( this, CONTAINER_NameChange, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetNodeListInfo

HRESULT CDirectMusicContainer::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strDescriptor;

    pListInfo->bstrName = m_strName.AllocSysString();
    pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_guidContainer, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetEditorClsId

HRESULT CDirectMusicContainer::GetEditorClsId( CLSID* pClsId )
{
// AMC delete??

// 	AFX_MANAGE_STATE(_afxModuleAddrThis);

//   *pClsId = CLSID_ContainerEditor;
	
//	return S_OK;
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetEditorTitle

HRESULT CDirectMusicContainer::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_CONTAINER_TEXT, achTitle, MID_BUFFER );
	strTitle  = achTitle;
	strTitle += _T(": " );
	strTitle += m_strName;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetEditorWindow

HRESULT CDirectMusicContainer::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::SetEditorWindow

HRESULT CDirectMusicContainer::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::UseOpenCloseImages

HRESULT CDirectMusicContainer::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetRightClickMenuId

HRESULT CDirectMusicContainer::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;

	if( IsInScript() )
	{
		*pnMenuId = IDM_SCRIPT_CONTAINER_NODE_RMENU;
	}
	else
	{
		*pnMenuId = IDM_CONTAINER_NODE_RMENU;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::OnRightClickMenuInit

HRESULT CDirectMusicContainer::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::OnRightClickMenuSelect

HRESULT CDirectMusicContainer::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_ADD_FILES:
			OnAddRemoveFiles();
			hr = S_OK;
			break;

		case IDM_RENAME:
			if( IsInScript() == FALSE )
			{
				hr = theApp.m_pContainerComponent->m_pIFramework8->EditNodeLabel( this );
			}
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::DeleteChildNode

HRESULT CDirectMusicContainer::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// Container nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::InsertChildNode

HRESULT CDirectMusicContainer::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// Container nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::DeleteNode

HRESULT CDirectMusicContainer::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;

	IDMUSProdNode* pIParentNode;

	// Let our parent delete us
	if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			// Remove embedded objects from Framework's notification list
			CContainerObject* pContainerObject;
			POSITION pos = m_FolderEmbed.m_lstObjects.GetHeadPosition();
			while( pos )
			{
				pContainerObject = m_FolderEmbed.m_lstObjects.GetNext( pos );
				pContainerObject->SetFileReference( NULL );
			}

			// Remove referenced objects from Framework's notification list
			pos = m_FolderReference.m_lstObjects.GetHeadPosition();
			while( pos )
			{
				pContainerObject = m_FolderReference.m_lstObjects.GetNext( pos );
				pContainerObject->SetFileReference( NULL );
			}

			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			RELEASE( pIParentNode );
			return hr;
		}
	}

	// No parent so we will delete ourself
	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	// Remove from Project Tree
	if( theApp.m_pContainerComponent->m_pIFramework8->RemoveNode( this, fPromptUser ) == S_FALSE )
	{
		// User cancelled delete
		return E_FAIL;
	}

	// Remove embedded objects from Framework's notification list
	CContainerObject* pContainerObject;
	POSITION pos = m_FolderEmbed.m_lstObjects.GetHeadPosition();
	while( pos )
	{
		pContainerObject = m_FolderEmbed.m_lstObjects.GetNext( pos );
		pContainerObject->SetFileReference( NULL );
	}

	// Remove referenced objects from Framework's notification list
	pos = m_FolderReference.m_lstObjects.GetHeadPosition();
	while( pos )
	{
		pContainerObject = m_FolderReference.m_lstObjects.GetNext( pos );
		pContainerObject->SetFileReference( NULL );
	}

	// Remove from Component Container list
	theApp.m_pContainerComponent->RemoveFromContainerFileList( this );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::OnNodeSelChanged

HRESULT CDirectMusicContainer::OnNodeSelChanged( BOOL fSelected )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::CreateDataObject

HRESULT CDirectMusicContainer::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Container into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_CONTAINER into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pContainerComponent->m_cfContainer, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->SaveClipFormat( theApp.m_pContainerComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// Container nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pContainerComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			RELEASE( pIStream );
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::CanCut

HRESULT CDirectMusicContainer::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::CanCopy

HRESULT CDirectMusicContainer::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::CanDelete

HRESULT CDirectMusicContainer::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			return m_pIParentNode->CanDeleteChildNode( this );
		}
		else
		{
			return S_FALSE;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::CanDeleteChildNode

HRESULT CDirectMusicContainer::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Container nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::CanPasteFromData

HRESULT CDirectMusicContainer::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}
	
	if( m_pIDocRootNode != this )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent node decide what can be dropped
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}
	
	return S_FALSE;		// Can't paste anything on a Container node
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::PasteFromData

HRESULT CDirectMusicContainer::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode != this )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle paste
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}
	
	ASSERT( 0 );	// Should not happen!
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::CanChildPasteFromData

HRESULT CDirectMusicContainer::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	ASSERT( 0 );

	return E_NOTIMPL;	// Container folder nodes are the nodes that handle paste
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::ChildPasteFromData

HRESULT CDirectMusicContainer::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Container folder nodes are the nodes that handle paste
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdNode::GetObject

HRESULT CDirectMusicContainer::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( 0 );

    *ppvObject = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdPropPageObject::GetData

HRESULT CDirectMusicContainer::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdPropPageObject::SetData

HRESULT CDirectMusicContainer::SetData( void* pData )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdPropPageObject::OnShowProperties

HRESULT CDirectMusicContainer::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	// Get the Container page manager
	CContainerPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_ContainerPropPageManager ) == S_OK )
	{
		pPageManager = (CContainerPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CContainerPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Container properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CContainerPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CDirectMusicContainer::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IPersist::GetClassID

HRESULT CDirectMusicContainer::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IPersistStream::IsDirty

HRESULT CDirectMusicContainer::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fModified )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::LoadContainer

HRESULT CDirectMusicContainer::LoadContainer( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*      pIStream;
	MMCKINFO	  ck;
	MMCKINFO	  ckList;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
    HRESULT       hr = S_OK;

	ASSERT( theApp.m_pContainerComponent != NULL );

	// Following strings only saved when they have values
	// So make sure they are initialized!!
	m_strAuthor.Empty();
	m_strCopyright.Empty();
	m_strSubject.Empty();
	m_strInfo.Empty();

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_CONTAINER_CHUNK:
			{
			    DMUS_IO_CONTAINER_HEADER dmusContainerIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_CONTAINER_HEADER ) );
				hr = pIStream->Read( &dmusContainerIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwFlagsDM = dmusContainerIO.dwFlags;
				break;
			}

			case DMUS_FOURCC_GUID_CHUNK:
				dwSize = min( ck.cksize, sizeof( GUID ) );
				hr = pIStream->Read( &m_guidContainer, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
			{
			    DMUS_IO_VERSION dmusVersionIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
				hr = pIStream->Read( &dmusVersionIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_vVersion.dwVersionMS = dmusVersionIO.dwVersionMS;
				m_vVersion.dwVersionLS = dmusVersionIO.dwVersionLS;
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_CONTAINED_OBJECTS_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_LIST:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_CONTAINED_OBJECT_LIST:
										{
											CContainerObject* pContainerObject = new CContainerObject( this );
											if( pContainerObject == NULL )
											{
												hr = E_OUTOFMEMORY;
												goto ON_ERROR;
											}

											BOOL fReference = FALSE;

											hr = pContainerObject->Load( pIRiffStream, &ckList, &fReference );
											if( hr == S_OK )
											{
												if( fReference  )
												{
													m_FolderReference.m_lstObjects.AddTail( pContainerObject );
												}
												else
												{
													m_FolderEmbed.m_lstObjects.AddTail( pContainerObject );
												}
											}
											else if( hr == S_FALSE )
											{
												// Could not resolve file reference so discard this object
												delete pContainerObject;
												hr = S_OK;
											}
											else
											{
												delete pContainerObject;
												goto ON_ERROR;
											}
											break;
										}
									}
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_UNAM_CHUNK:
								{
									CString strName;

									ReadMBSfromWCS( pIStream, ckList.cksize, &strName );
									if( strName.CompareNoCase( m_strName ) != 0 )
									{
										m_strName = strName;
										theApp.m_pContainerComponent->m_pIFramework8->RefreshNode( this );

										// Notify connected nodes that the Container name has changed
										theApp.m_pContainerComponent->m_pIFramework8->NotifyNodes( this, CONTAINER_NameChange, NULL );
									}
									break;
								}

								case DMUS_FOURCC_UART_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strAuthor );
									break;

								case DMUS_FOURCC_UCOP_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCopyright );
									break;

								case DMUS_FOURCC_USBJ_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strSubject );
									break;

								case DMUS_FOURCC_UCMT_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strInfo );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IPersistStream::Load

HRESULT CDirectMusicContainer::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// Generate EmbeddedFile list
	DWORD dwCurrentFilePos = StreamTell( pIStream );
	theApp.m_pContainerComponent->CreateEmbeddedFileList( pIStream );
	StreamSeek( pIStream, dwCurrentFilePos, 0 );

	// Load the Container
    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_CONTAINER_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			hr = LoadContainer( pIRiffStream, &ckMain );
		}

		RELEASE( pIRiffStream );
	}

	// Sync UI
	if( m_pIDocRootNode )
	{
		// Already in Project Tree so sync changes
		// Refresh Container editor (when open)
		SyncContainerEditor();

		// Sync change with property sheet
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->RefreshTitle();
			pIPropSheet->RefreshActivePage();
			RELEASE( pIPropSheet );
		}
	}

	// Release EmbeddedFile list
	theApp.m_pContainerComponent->ReleaseEmbeddedFileList();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer InsertObjectToSave
    
void CDirectMusicContainer::InsertObjectToSave( CTypedPtrList<CPtrList, CObjectToSave*>& list, CObjectToSave* pObjectToInsert )
{
	// Ensure the pObjectToInsert pointer is valid
	if ( pObjectToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	CObjectToSave* pObject;
	POSITION posCurrent, posNext = list.GetHeadPosition();

	while( posNext )
	{
		posCurrent = posNext;
		pObject = list.GetNext( posNext );

		if( pObject->m_nPriority > pObjectToInsert->m_nPriority )
		{
			// Insert before posCurrent (which is the position of pObject)
			list.InsertBefore( posCurrent, pObjectToInsert );
			return;
		}
	}

	// pObjectToInsert has highr priority than all items in the list, add it at the end of the list
	list.AddTail( pObjectToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer CreateObjectsToSaveList
    
HRESULT CDirectMusicContainer::CreateObjectsToSaveList( CTypedPtrList<CPtrList, CObjectToSave*>& list )
{
	CContainerObject* pContainerObject;
	CObjectToSave* pObjectToSave;

	// Embedded list
	POSITION pos = m_FolderEmbed.m_lstObjects.GetHeadPosition();
	while( pos )
	{
		pContainerObject = m_FolderEmbed.m_lstObjects.GetNext( pos );

		pObjectToSave = new CObjectToSave( pContainerObject, false );
		if( pObjectToSave == NULL )
		{
			return E_OUTOFMEMORY;
		}

		InsertObjectToSave( list, pObjectToSave );
	}

	// Referenced list 
	pos = m_FolderReference.m_lstObjects.GetHeadPosition();
	while( pos )
	{
		pContainerObject = m_FolderReference.m_lstObjects.GetNext( pos );

		pObjectToSave = new CObjectToSave( pContainerObject, true );
		if( pObjectToSave == NULL )
		{
			return E_OUTOFMEMORY;
		}

		InsertObjectToSave( list, pObjectToSave );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer SaveObjects
    
HRESULT CDirectMusicContainer::SaveObjects( IDMUSProdRIFFStream* pIRiffStream )
{
	CObjectToSave* pObjectToSave;
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
	POSITION pos;
	CTypedPtrList<CPtrList, CObjectToSave*> lstObjectsToSave;

	if( m_FolderEmbed.m_lstObjects.IsEmpty()
	&&  m_FolderReference.m_lstObjects.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write DMUS_FOURCC_CONTAINED_OBJECTS_LIST header
	ckMain.fccType = DMUS_FOURCC_CONTAINED_OBJECTS_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Create the list of objects to save
	// List combines "Embedded" and "Referenced" folder items
	// List is sorted in an order appropriate for saving
	hr = CreateObjectsToSaveList( lstObjectsToSave );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Write "ObjectsToSave" list
	pos = lstObjectsToSave.GetHeadPosition();
	while( pos )
	{
		pObjectToSave = lstObjectsToSave.GetNext( pos );

		hr = pObjectToSave->m_pContainerObject->Save( pIRiffStream, pObjectToSave->m_fFromReferenceFolder );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
		hr = S_OK;	// Change possible S_FALSE to S_OK;
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	// Cleanup "ObjectsToSave" list
	while( !lstObjectsToSave.IsEmpty() )
	{
		pObjectToSave = lstObjectsToSave.RemoveHead();
		delete pObjectToSave;
	}

    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer SaveVersion
    
HRESULT CDirectMusicContainer::SaveVersion( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_VERSION dmusVersionIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Version chunk header
	ck.ckid = DMUS_FOURCC_VERSION_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_VERSION structure
	memset( &dmusVersionIO, 0, sizeof(DMUS_IO_VERSION) );

	dmusVersionIO.dwVersionMS = m_vVersion.dwVersionMS ;
	dmusVersionIO.dwVersionLS = m_vVersion.dwVersionLS;

	// Write Version chunk data
	hr = pIStream->Write( &dmusVersionIO, sizeof(DMUS_IO_VERSION), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_VERSION) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer SaveInfoList
    
HRESULT CDirectMusicContainer::SaveInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

	if( m_strName.IsEmpty()
	&&  m_strAuthor.IsEmpty()
	&&  m_strCopyright.IsEmpty()
	&&  m_strSubject.IsEmpty()
	&&  m_strInfo.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Container name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Container author
	if( !m_strAuthor.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strAuthor );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Container copyright
	if( !m_strCopyright.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCOP_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strCopyright );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Container subject
	if( !m_strSubject.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_USBJ_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strSubject );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Container comments
	if( !m_strInfo.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCMT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strInfo );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer SaveGUID
    
HRESULT CDirectMusicContainer::SaveGUID( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write GUID chunk header
	ck.ckid = DMUS_FOURCC_GUID_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Container GUID
	hr = pIStream->Write( &m_guidContainer, sizeof(GUID), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(GUID) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer SaveHeader
    
HRESULT CDirectMusicContainer::SaveHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_CONTAINER_HEADER dmusContainerIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Container chunk header
	ck.ckid = DMUS_FOURCC_CONTAINER_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_CONTAINER_HEADER structure
	memset( &dmusContainerIO, 0, sizeof(DMUS_IO_CONTAINER_HEADER) );

	// Containers in scripts always have the DMUS_CONTAINER_NOLOADS bit set
	if( IsInScript() )
	{
		m_dwFlagsDM |= DMUS_CONTAINER_NOLOADS;
	}
	dmusContainerIO.dwFlags = m_dwFlagsDM;

	// Write Container chunk data
	hr = pIStream->Write( &dmusContainerIO, sizeof(DMUS_IO_CONTAINER_HEADER), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_CONTAINER_HEADER) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer SaveContainer
    
HRESULT CDirectMusicContainer::SaveContainer( IDMUSProdRIFFStream* pIRiffStream )
{
	HRESULT hr = S_OK;

// Save Container header chunk
	hr = SaveHeader( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Container GUID
	hr = SaveGUID( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Container info
	hr = SaveInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Container version
	hr = SaveVersion( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Container objects
	hr = SaveObjects( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

ON_ERROR:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IPersistStream::Save

HRESULT CDirectMusicContainer::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pIPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
	{
		pIPersistInfo->GetStreamInfo( &StreamInfo );

		// Validate requested data format
		if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion )
		||  IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ) )
		{
			// Make sure DocRoot is in stream's embedded file list
			if( m_pIDocRootNode )
			{
				if( pIPersistInfo->IsInEmbeddedFileList(m_pIDocRootNode) == S_FALSE )
				{
					pIPersistInfo->AddToEmbeddedFileList( m_pIDocRootNode );		
				}
			}
		}

		RELEASE( pIPersistInfo );
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	// Validate requested data format
	if( IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion )
	||  IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ) )
	{
		// DirectMusic format
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_CONTAINER_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( SaveContainer( pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModified( FALSE );
				}

				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer IPersistStream::GetSizeMax

HRESULT CDirectMusicContainer::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer Additional functions

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::ReadListInfoFromStream

HRESULT CDirectMusicContainer::ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;
	CString strName;
	CString strDescriptor;
	GUID guidContainer;

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	memset( &guidContainer, 0, sizeof(GUID) );

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_CONTAINER_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			// Get Container GUID
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				dwSize = min( ck.cksize, sizeof( GUID ) );
				if( FAILED ( pIStream->Read( &guidContainer, dwSize, &dwByteCount ) )
				||  dwByteCount != dwSize )
				{
					memset( &guidContainer, 0, sizeof(GUID) );
				}
			}

			// Get Container name
			ck.fccType = DMUS_FOURCC_UNFO_LIST;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
			{
				ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	if( !strName.IsEmpty() )
	{
		pListInfo->bstrName = strName.AllocSysString();
		pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
		memcpy( &pListInfo->guidObject, &guidContainer, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


///////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer  IDMUSProdNotifySink::OnUpdate

HRESULT CDirectMusicContainer::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check Embed Runtime folder
	m_FolderEmbed.OnUpdate( pIDocRootNode, guidUpdateType, pData );

	// Check Reference Runtime folder
	m_FolderReference.OnUpdate( pIDocRootNode, guidUpdateType, pData );

	return S_OK;
}


///////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer  IDMUSProdContainerInfo::FindDocRootFromName

HRESULT CDirectMusicContainer::FindDocRootFromName( BSTR bstrName, IUnknown** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( bstrName == NULL )
	{
		return E_INVALIDARG;
	}
	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}
	*ppIDocRootNode = NULL;

	// Check Embed Runtime folder
	HRESULT hr = m_FolderEmbed.FindDocRootFromName( strName, ppIDocRootNode );
	
	if( hr != S_OK )
	{
		// Check Reference Runtime folder
		hr = m_FolderReference.FindDocRootFromName( strName, ppIDocRootNode );
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer  IDMUSProdContainerInfo::FindDocRootFromScriptAlias

HRESULT CDirectMusicContainer::FindDocRootFromScriptAlias( BSTR bstrAlias, IUnknown** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( bstrAlias == NULL )
	{
		return E_INVALIDARG;
	}
	CString strAlias = bstrAlias;
	::SysFreeString( bstrAlias );

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}
	*ppIDocRootNode = NULL;

	// Check Embed Runtime folder
	HRESULT hr = m_FolderEmbed.FindDocRootFromScriptAlias( strAlias, ppIDocRootNode );
	
	if( hr != S_OK )
	{
		// Check Reference Runtime folder
		hr = m_FolderReference.FindDocRootFromScriptAlias( strAlias, ppIDocRootNode );
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer  IsCircularReference

HRESULT CDirectMusicContainer::IsCircularReference( IDMUSProdNode* pIDocRootNode, CFolder* pTargetFolder )
{
	if( pIDocRootNode == NULL )
	{
		return E_INVALIDARG;
	}

	GUID guidNodeId;
	if( FAILED ( pIDocRootNode->GetNodeId( &guidNodeId ) ) )
	{
		return E_FAIL;
	}

	HRESULT hr = S_FALSE;

	if( ::IsEqualGUID( guidNodeId, GUID_ContainerNode ) )
	{
		CDirectMusicContainer* pContainer = (CDirectMusicContainer *)pIDocRootNode;

		if( (pContainer == this)
		||  (pContainer->m_FolderEmbed.IsDocRootInFolder( this ) == S_OK)
		||  (pContainer->m_FolderReference.IsDocRootInFolder( this ) == S_OK) )
		{
			hr = S_OK;
		}
	}
	else
	{
		// Need to be careful about what is dropped into the "embed" folder
		if( pTargetFolder == &m_FolderEmbed )
		{
			// Can't embed a DocRoot in it's own child container
			if( pIDocRootNode == m_pIDocRootNode )
			{
				hr = S_OK;
			}
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::IsDocRootInContainer

HRESULT CDirectMusicContainer::IsDocRootInContainer( IDMUSProdNode* pIDocRootNode )
{
	HRESULT hr = S_FALSE;

	if( (m_FolderEmbed.IsDocRootInFolder( pIDocRootNode ) == S_OK)
	||  (m_FolderReference.IsDocRootInFolder( pIDocRootNode ) == S_OK) )
	{
		hr = S_OK;
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::IsFileGUIDInContainer

HRESULT CDirectMusicContainer::IsFileGUIDInContainer( GUID guidFile )
{
	HRESULT hr = S_FALSE;

	if( (m_FolderEmbed.IsFileGUIDInFolder( guidFile ) == S_OK)
	||  (m_FolderReference.IsFileGUIDInFolder( guidFile ) == S_OK) )
	{
		hr = S_OK;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::GetGUID

void CDirectMusicContainer::GetGUID( GUID* pguidContainer )
{
	if( pguidContainer )
	{
		*pguidContainer = m_guidContainer;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::SetGUID

void CDirectMusicContainer::SetGUID( GUID guidContainer )
{
	m_guidContainer = guidContainer;
	SetModified( TRUE );

	// Notify connected nodes that Container GUID has changed
	theApp.m_pContainerComponent->m_pIFramework8->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicContainer::OnAddRemoveFiles

void CDirectMusicContainer::OnAddRemoveFiles( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	IDMUSProdProject* pIProject;
	if( FAILED ( theApp.m_pContainerComponent->m_pIFramework8->FindProject( this, &pIProject ) ) )
	{
		return;
	}

	// Store this container's GUID
	GUID guidThisContainer;
	theApp.m_pContainerComponent->m_pIFramework8->GetNodeFileGUID( this, &guidThisContainer );

	// Display Add/Remove Files dialog
	CDlgAddFiles dlgAddFiles = new CDlgAddFiles;

	// Disable "referenced" controls when appropriate
	if( IsInSegment() )
	{
		dlgAddFiles.m_fDisableReferenced = true;
	}

	// Determine dialog title
	BSTR bstrName;
	if( m_pIDocRootNode )
	{
		if( SUCCEEDED ( m_pIDocRootNode->GetNodeName( &bstrName ) ) )
		{
			CString strName = bstrName;
			::SysFreeString( bstrName );

			AfxFormatString1( dlgAddFiles.m_strTitle, IDS_ADD_REMOVE_FILES_TITLE, strName );
		}
	}

	// Create dialog's "Available" list
	IDMUSProdNode* pIFileNode;
	IDMUSProdNode* pINextFileNode;
	GUID guidFile;
	HRESULT hr = pIProject->GetFirstFile( &pINextFileNode );
	while( hr == S_OK )
	{
		pIFileNode = pINextFileNode;

		theApp.m_pContainerComponent->m_pIFramework8->GetNodeFileGUID( pIFileNode, &guidFile );
		if( ::IsEqualGUID(guidFile, guidThisContainer) == FALSE )
		{
			if( IsFileGUIDInContainer(guidFile) != S_OK )
			{
				dlgAddFiles.m_lstAvailable.AddTail( pIFileNode );
			}
		}

		hr = pIProject->GetNextFile( pIFileNode, &pINextFileNode );
		pIFileNode->Release();
	}

	// Create dialog's "Embedded" list
	POSITION pos = m_FolderEmbed.m_lstObjects.GetHeadPosition();
	while( pos )
	{
		CContainerObject* pContainerObject = m_FolderEmbed.m_lstObjects.GetNext( pos );

		dlgAddFiles.m_lstEmbedded.AddTail( pContainerObject->m_FileRef.pIDocRootNode );
	}

	// Create dialog's "References" list
	pos = m_FolderReference.m_lstObjects.GetHeadPosition();
	while( pos )
	{
		CContainerObject* pContainerObject = m_FolderReference.m_lstObjects.GetNext( pos );

		dlgAddFiles.m_lstReferenced.AddTail( pContainerObject->m_FileRef.pIDocRootNode );
	}

	if( dlgAddFiles.DoModal() == IDOK )
	{
		IDMUSProdPropPageManager* pIPageManager = theApp.m_pIPageManager;

		// Need to keep pIPageManager while processing IDOK
		if( pIPageManager )
		{
			pIPageManager->AddRef();
		}

		// Update Container's "Embedded" folder
		m_FolderEmbed.ReplaceContent( dlgAddFiles.m_lstEmbedded );

		// Update Container's "Referenced" folder
		m_FolderReference.ReplaceContent( dlgAddFiles.m_lstReferenced );

		// OK - We don't need pIPageManager any more...
		if( pIPageManager )
		{
			pIPageManager->Release();
		}
	}

	RELEASE( pIProject );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerCtl.h ===
#if !defined(AFX_CONTAINERCTL_H__778A0B9D_6F81_11D3_B45F_00105A2796DE__INCLUDED_)
#define AFX_CONTAINERCTL_H__778A0B9D_6F81_11D3_B45F_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// ContainerCtl.h : Declaration of the CContainerCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CContainerCtrl : See ContainerCtl.cpp for implementation.

class CContainerCtrl : public COleControl
{
	DECLARE_DYNCREATE(CContainerCtrl)

// Constructor
public:
	CContainerCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContainerCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CContainerCtrl();

	DECLARE_OLECREATE_EX(CContainerCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CContainerCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CContainerCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CContainerCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CContainerCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CContainerCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CContainerCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CContainerCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTAINERCTL_H__778A0B9D_6F81_11D3_B45F_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerDesignerDLL.cpp ===
// ContainerDesignerDLL.cpp : Implementation of CContainerDesignerApp and DLL registration.

#include "stdafx.h"
#include <RiffStrm.h>
#include <initguid.h>
#include "ContainerDesignerDLL.h"
#include "ContainerComponent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CContainerDesignerApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x778a0b8c, 0x6f81, 0x11d3, { 0xb4, 0x5f, 0, 0x10, 0x5a, 0x27, 0x96, 0xde } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CContainerDesignerApp::InitInstance - DLL initialization

BOOL CContainerDesignerApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if( bInit )
	{
		AfxEnableControlContainer();
	}

	m_pIPageManager = NULL;
	m_pContainerComponent = NULL;

	m_pClipboardObject = NULL;
	m_pIClipboardDataObject = NULL;

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CContainerDesignerApp::ExitInstance - DLL termination

int CContainerDesignerApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDesignerApp::GetHelpFileName

BOOL CContainerDesignerApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CContainerDesignerApp::SetNodePointers  (used by all components)

void CContainerDesignerApp::SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode )
{
	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;

	ASSERT( pINode != NULL );
	ASSERT( pIDocRootNode != NULL );

	pINode->SetDocRootNode( pIDocRootNode );    
	pINode->SetParentNode( pIParentNode );    

	hr = pINode->GetFirstChild( &pINextChild );

	while( SUCCEEDED( hr )  &&  pINextChild )
	{
		pIChild = pINextChild;

		SetNodePointers( pIChild, pIDocRootNode, pINode );

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		RELEASE( pIChild );
	}
}


////////////////////////////////////////////////////////////////////////////
// CContainerDesignerApp::PutDataInClipboard

BOOL CContainerDesignerApp::PutDataInClipboard( IDataObject* pIDataObject, void* pObject )
{
	if( pIDataObject )
	{
		if( ::OleSetClipboard( pIDataObject ) == S_OK )
		{
			RELEASE( m_pIClipboardDataObject );

			m_pIClipboardDataObject = pIDataObject;
			m_pIClipboardDataObject->AddRef();

			m_pClipboardObject = pObject;

			return TRUE;
		}
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CContainerDesignerApp::FlushClipboard

void CContainerDesignerApp::FlushClipboard( void* pClipboardObject )
{
	if( m_pClipboardObject == pClipboardObject )
	{
		ASSERT( m_pIClipboardDataObject != NULL );

		if( ::OleIsCurrentClipboard( m_pIClipboardDataObject ) == S_OK )
		{
			::OleFlushClipboard();
		}

		RELEASE( m_pIClipboardDataObject );

		m_pClipboardObject = NULL;
	}
}


////////////////////////////////////////////////////////////////////////////
// CContainerDesignerApp::GetFileVersion  (used by all components)

BOOL CContainerDesignerApp::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds registry entries for DMUS Producer components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz1;
    LPOLESTR psz2;
    LPOLESTR psz3;
    LPOLESTR psz4;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
	TCHAR	 szInProcServer32[SMALL_BUFFER];
	TCHAR	 szThreadingModel[SMALL_BUFFER];
	TCHAR	 szApartment[SMALL_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
    TCHAR    szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    TCHAR    szGuid2[MID_BUFFER];
    TCHAR    szGuid3[MID_BUFFER];
    TCHAR    szGuid4[MID_BUFFER];
    CString  strName;
    TCHAR    szComponentPath[MAX_BUFFER];
	TCHAR	 szSkip[SMALL_BUFFER];
	DWORD    dwSkip = 0;
    TCHAR    szContainerPath[MAX_BUFFER];
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szInProcServer32, _T("InProcServer32") );
	_tcscpy( szThreadingModel, _T("ThreadingModel") );
	_tcscpy( szApartment, _T("Apartment") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szSkip, _T("Skip") );

	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	
// Register Container Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_ContainerComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_CONTAINER_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, szSkip, &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_ContainerNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_ContainerRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_ContainerComponent, &psz3) )
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicContainer, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_CONTAINER_OBJECT_TEXT );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes registry entries for DMUS Producer components

static BOOL UnregisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
    TCHAR    szGuid[MID_BUFFER];
    TCHAR    szComponentPath[MAX_BUFFER];
    TCHAR    szContainerPath[MAX_BUFFER];
	TCHAR	 szRefNode[SMALL_BUFFER];
    
	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	_tcscpy( szRefNode, _T("RefNode") );
	
// Unregister Container Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_ContainerComponent, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_ContainerNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
			AfxOleLockApp(); 
        }
        else
        {
			AfxOleUnlockApp(); 
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
    return hrReturn; \
}

CREATE_INSTANCE( CContainerComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_ContainerComponent) )
	{
        pfunc = CContainerComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
// AMC delete???
//  else if( IsEqualCLSID(rclsid, CLSID_ContainerEditor) )
//	{
//		AfxDllGetClassObject( rclsid, riid, ppv );
//		if( *ppv == NULL )
//		{
//			return E_OUTOFMEMORY;
//		}
//	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerDesignerDLL.h ===
#if !defined(AFX_CONTAINERDESIGNER_H__778A0B95_6F81_11D3_B45F_00105A2796DE__INCLUDED_)
#define AFX_CONTAINERDESIGNER_H__778A0B95_6F81_11D3_B45F_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// ContainerDesignerDLL.h : main header file for CONTAINERDESIGNER.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusicc.h>
#include <dmusici.h>
#include <dmusicf.h>
#pragma warning( pop )
#include "DMUSProd.h"
#include "ContainerDesigner.h"
#include "SegmentDesigner.h"
#include "StyleDesigner.h"
#include "ScriptDesigner.h"
#include "ChordMapDesigner.h"
#include "DLSDesigner.h"
#include "BandEditor.h"
#include "DllJazzDataObject.h"
#include "DllBasePropPageManager.h"
#include "JazzUndoMan.h"


/////////////////////////////////////////////////////////////////////////////
// DLL defines
//

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256

#define FIRST_CONTAINER_IMAGE		0
#define FIRST_CONTAINERREF_IMAGE	2
#define FIRST_FOLDER_IMAGE			4
#define FIRST_FOLDER_GRAY_IMAGE		6


class CContainerComponent;

/////////////////////////////////////////////////////////////////////////////
// CContainerDesignerApp : See ContainerDesignerDLL.cpp for implementation.

class CContainerDesignerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode );
	BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );
	BOOL PutDataInClipboard( IDataObject* pIDataObject, void* pClipboardObject );
	void FlushClipboard( void* pClipboardObject );

private:
	IDataObject*	m_pIClipboardDataObject;	// Data copied into clipboard
	void*			m_pClipboardObject;			// Object responsible for data copied into clipboard

public:
	IDMUSProdPropPageManager*	m_pIPageManager;
	CContainerComponent*		m_pContainerComponent;
};

extern CContainerDesignerApp NEAR theApp;

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTAINERDESIGNER_H__778A0B95_6F81_11D3_B45F_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerEditorGuids.c ===
// ContainerEditorGuids.c : Contains GUIDs not found in MIDL generated ContainerDesigner_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;

#endif /* GUID_DEFINED */


const GUID CLSID_ContainerComponent = {0x1ca84b10,0x7d17,0x11d3,{0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde}};
const GUID GUID_ContainerNode = {0x1ca84b11,0x7d17,0x11d3,{0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde}};  
const GUID GUID_ContainerRefNode = {0x1ca84b12,0x7d17,0x11d3,{0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde}};   
const GUID GUID_ContainerEmbedFolderNode = {0x1ca84b13,0x7d17,0x11d3,{0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde}};  
const GUID GUID_ContainerRefFolderNode = {0x1ca84b14,0x7d17,0x11d3,{0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde}};   
const GUID GUID_ContainerObjectNode = {0x1ca84b15,0x7d17,0x11d3,{0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde}};   

const GUID CONTAINER_NameChange = {0x1ca84b16,0x7d17,0x11d3,{0xb4,0x72,0x00,0x10,0x5a,0x27,0x96,0xde}};
const GUID CONTAINER_ChangeNotification = {0xfde73220,0x7c26,0x45b0,{0xa5,0x83,0xd,0x19,0xe6,0x98,0x52,0xf1}};
const GUID CONTAINER_FileLoadFinished = {0x4e81c756,0x3228,0x4964,{0x8f,0x40,0xfa,0x79,0x84,0x66,0x24,0xd6}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerPpg.h ===
#if !defined(AFX_CONTAINERPPG_H__778A0B9F_6F81_11D3_B45F_00105A2796DE__INCLUDED_)
#define AFX_CONTAINERPPG_H__778A0B9F_6F81_11D3_B45F_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// ContainerPpg.h : Declaration of the CContainerPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CContainerPropPage : See ContainerPpg.cpp.cpp for implementation.

class CContainerPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CContainerPropPage)
	DECLARE_OLECREATE_EX(CContainerPropPage)

// Constructor
public:
	CContainerPropPage();

// Dialog Data
	//{{AFX_DATA(CContainerPropPage)
	enum { IDD = IDD_PROPPAGE_CONTAINER };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CContainerPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTAINERPPG_H__778A0B9F_6F81_11D3_B45F_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerDocType.cpp ===
// ContainerDocType.cpp : implementation file
//

#include "stdafx.h"

#include "ContainerDesignerDLL.h"
#include "Container.h"
#include <mmreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType constructor/destructor

CContainerDocType::CContainerDocType()
{
    m_dwRef = 0;
}

CContainerDocType::~CContainerDocType()
{
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType IUnknown implementation

HRESULT CContainerDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
    ||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CContainerDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CContainerDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::GetResourceId

HRESULT CContainerDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_CONTAINER_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::DoesExtensionMatch

HRESULT CContainerDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_CONTAINER_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::DoesIdMatch

HRESULT CContainerDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualGUID(rguid, GUID_ContainerNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::AllocNode

HRESULT STDMETHODCALLTYPE CContainerDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_ContainerNode) )
	{
		// Create a new Container 
		CDirectMusicContainer* pContainer = new CDirectMusicContainer;
		if( pContainer == NULL )
		{
			return E_OUTOFMEMORY ;
		}
			
		// Create the Undo Manager
		if( pContainer->CreateUndoMgr() == FALSE )
		{
			RELEASE( pContainer );
			return E_OUTOFMEMORY;
		}

		*ppINode = (IDMUSProdNode *)pContainer;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType:::OnFileNew

HRESULT CContainerDocType::OnFileNew( IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
									  IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIContainerNode;

	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new Container 
	hr = AllocNode( GUID_ContainerNode, &pIContainerNode );
	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pIContainerNode, pIContainerNode, NULL );

		// Add node to Project Tree
		if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->AddNode(pIContainerNode, NULL) ) )
		{
			CDirectMusicContainer* pContainer = (CDirectMusicContainer *)pIContainerNode;

			// Store the Container's Project
			pContainer->m_pIProject = pITargetProject;
//			pContainer->m_pIProject->AddRef();			intentionally missing

			// Get the filename
			BSTR bstrName;

			if( SUCCEEDED ( pIContainerNode->GetNodeName( &bstrName ) ) )
			{
				pContainer->m_strOrigFileName = bstrName;
				pContainer->m_strOrigFileName += _T(".cop");
				::SysFreeString( bstrName );
			}

			// Add Container to Container component list 
			theApp.m_pContainerComponent->AddToContainerFileList( pContainer );

			*ppIDocRootNode = pIContainerNode;
			pContainer->SetModified( TRUE );
			hr = S_OK;
		}
		else
		{
			RELEASE( pIContainerNode );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::OnFileOpen

HRESULT CContainerDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* pITargetProject,
									   IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;
	CDirectMusicContainer* pContainer;
	CString strFileName;
	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;
	// Create a new Container 
	pContainer = new CDirectMusicContainer;
	if( pContainer == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	theApp.m_pContainerComponent->m_nNextContainer--;

	if( pContainer->CreateUndoMgr() == FALSE )
	{
		RELEASE( pContainer );
		return E_OUTOFMEMORY;
	}

	// Store the Container's Project
	pContainer->m_pIProject = pITargetProject;
//	pContainer->m_pIProject->AddRef();			intentionally missing

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		pContainer->m_strOrigFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		int nFindPos = pContainer->m_strOrigFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			pContainer->m_strOrigFileName = pContainer->m_strOrigFileName.Right( pContainer->m_strOrigFileName.GetLength() - nFindPos - 1 );
		}

		pPersistInfo->Release();
	}

	// Load the Container file
	if( theApp.m_pContainerComponent->m_pContainerBeingLoaded == NULL )
	{
		theApp.m_pContainerComponent->m_pContainerBeingLoaded = pContainer;
		theApp.m_pContainerComponent->m_pIDupeFileTargetProject = pITargetProject;
		theApp.m_pContainerComponent->m_nDupeFileDlgReturnCode = 0;
	}
	hr = pContainer->Load( pIStream );
	if( theApp.m_pContainerComponent->m_pContainerBeingLoaded == pContainer )
	{
		theApp.m_pContainerComponent->m_pContainerBeingLoaded = NULL;
		theApp.m_pContainerComponent->m_pIDupeFileTargetProject = NULL;
		theApp.m_pContainerComponent->m_nDupeFileDlgReturnCode = 0;
	}
	if( !SUCCEEDED ( hr ) )
	{
		RELEASE( pContainer );
		return hr;
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pContainer, pContainer, NULL );

	// Add node to Project Tree
	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->AddNode(pContainer, NULL) ) )
	{
		pContainer->SetModified( FALSE );

		// Add Container to Container component list 
		theApp.m_pContainerComponent->AddToContainerFileList( pContainer );

		*ppIDocRootNode = pContainer;

		hr = S_OK;
	}
	else
	{
		RELEASE( pContainer );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::OnFileSave

HRESULT CContainerDocType::OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::GetListInfo

HRESULT CContainerDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Create temporary container object to retrieve list info
	CDirectMusicContainer* pContainer = new CDirectMusicContainer;
	if( pContainer )
	{
		// Create the Undo Manager
		if( pContainer->CreateUndoMgr() )
		{
			hr = pContainer->ReadListInfoFromStream( pIStream, pListInfo );
		}

		RELEASE( pContainer );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::IsFileTypeExtension

HRESULT CContainerDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	strExt.MakeLower();

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( strExt == _T(".cop") )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( strExt == _T(".con") )
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::GetObjectDescriptorFromNode

HRESULT CContainerDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Container Node
	CDirectMusicContainer* pContainer;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_ContainerNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pContainer = (CDirectMusicContainer *)pIDocRootNode;

	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	// Set values in DMUS_OBJECTDESC structure
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &pContainer->m_guidContainer, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicContainer, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = pContainer->m_vVersion.dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = pContainer->m_vVersion.dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, pContainer->m_strName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::GetObjectRiffId

HRESULT CContainerDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Container Node
	if( IsEqualGUID ( guidNodeId, GUID_ContainerNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = DMUS_FOURCC_CONTAINER_FORM;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerDocType::GetObjectExt

HRESULT CContainerDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Container Node
	if( IsEqualGUID ( guidNodeId, GUID_ContainerNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".cop";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".con";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerPpg.cpp ===
// ContainerPpg.cpp : Implementation of the CContainerPropPage property page class.

#include "stdafx.h"
#include "ContainerDesignerDLL.h"
#include "ContainerPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CContainerPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CContainerPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CContainerPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CContainerPropPage, "CONTAINERDESIGNER.ContainerPropPage.1",
	0x778a0b90, 0x6f81, 0x11d3, 0xb4, 0x5f, 0, 0x10, 0x5a, 0x27, 0x96, 0xde)


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPage::CContainerPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CContainerPropPage

BOOL CContainerPropPage::CContainerPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_CONTAINER_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPage::CContainerPropPage - Constructor

CContainerPropPage::CContainerPropPage() :
	COlePropertyPage(IDD, IDS_CONTAINER_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CContainerPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPage::DoDataExchange - Moves data between page and properties

void CContainerPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CContainerPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CContainerPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerDocType.h ===
#ifndef __CONTAINERDOCTYPE_H__
#define __CONTAINERDOCTYPE_H__

// ContainerDocType.h : header file
//


class CContainerDocType : public IDMUSProdDocType8
{
public:
    CContainerDocType();
	~CContainerDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );

	HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );   

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

	// Additional functions

	// Member variables
private:
    DWORD m_dwRef;
};

#endif // __CONTAINERDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerRef.h ===
#ifndef __CONTAINERREF_H__
#define __CONTAINERREF_H__

// ContainerRef.h : header file
//

#include <RiffStrm.h>
#include "ContainerComponent.h"
#include "ContainerDocType.h"

class CContainerRef : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CContainerRef();
	~CContainerRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions

public:
	CDirectMusicContainer*	m_pContainer;		// ContainerRef refers to this Container

private:
    DWORD					m_dwRef;
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;
};

#endif // __CONTAINERREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\ContainerRef.cpp ===
// ContainerRef.cpp : implementation file
//

#include "stdafx.h"
#include "ContainerDesignerDLL.h"

#include "Container.h"
#include "ContainerRef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CContainerRef constructor/destructor

CContainerRef::CContainerRef()
{
    m_dwRef = 0;
	AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pContainer = NULL;
}

CContainerRef::~CContainerRef()
{
	RELEASE( m_pContainer );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IUnknown implementation

HRESULT CContainerRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CContainerRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CContainerRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetNodeImageIndex

HRESULT CContainerRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );

	return( theApp.m_pContainerComponent->GetContainerRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetFirstChild

HRESULT CContainerRef::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// ContainerRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetNextChild

HRESULT CContainerRef::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// ContainerRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetComponent

HRESULT CContainerRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );

	return theApp.m_pContainerComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetDocRootNode

HRESULT CContainerRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::SetDocRootNode

HRESULT CContainerRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetParentNode

HRESULT CContainerRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::SetParentNode

HRESULT CContainerRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetNodeId

HRESULT CContainerRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ContainerRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetNodeName

HRESULT CContainerRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer == NULL )
	{
		TCHAR achNoContainer[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_CONTAINER, achNoContainer, MID_BUFFER );
		CString strNoContainer = achNoContainer;
		*pbstrName = strNoContainer.AllocSysString();
		return S_OK;
	}

    return m_pContainer->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CContainerRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a ContainerRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::ValidateNodeName

HRESULT CContainerRef::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a ContainerRef node
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::SetNodeName

HRESULT CContainerRef::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a ContainerRef node
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetNodeListInfo

HRESULT CContainerRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer == NULL )
	{
		return E_FAIL;
	}

    return m_pContainer->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetEditorClsId

HRESULT CContainerRef::GetEditorClsId( CLSID* pClsId )
{
// AMC delete??

//	AFX_MANAGE_STATE(_afxModuleAddrThis);
//
//	if( m_pContainer == NULL )
//	{
//		return E_FAIL;
//	}
//
//  *pClsId = CLSID_ContainerEditor;
//	
//	return S_OK;
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetEditorTitle

HRESULT CContainerRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer == NULL )
	{
		return E_FAIL;
	}

    return m_pContainer->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetEditorWindow

HRESULT CContainerRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer == NULL )
	{
		return E_FAIL;
	}

    return m_pContainer->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::SetEditorWindow

HRESULT CContainerRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer == NULL )
	{
		return E_FAIL;
	}

    return m_pContainer->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::UseOpenCloseImages

HRESULT CContainerRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetRightClickMenuId

HRESULT CContainerRef::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_CONTAINERREF_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CContainerRef::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CContainerRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pContainer )
			{
				return m_pContainer->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::DeleteChildNode

HRESULT CContainerRef::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// ContainerRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::InsertChildNode

HRESULT CContainerRef::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// ContainerRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::DeleteNode

HRESULT CContainerRef::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_FAIL;		// Cannot delete ContainerRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::OnNodeSelChanged

HRESULT CContainerRef::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::CreateDataObject

HRESULT CContainerRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pContainer )
	{
		// Let Container create data object
		return m_pContainer->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::CanCut

HRESULT CContainerRef::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::CanCopy

HRESULT CContainerRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pContainer )
	{
		return S_OK;	// Will copy the Container
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::CanDelete

HRESULT CContainerRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::CanDeleteChildNode

HRESULT CContainerRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Container Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::CanPasteFromData

HRESULT CContainerRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Container
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pContainerComponent->m_cfContainer );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Container
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pContainer )
	{
		// Let Container decide what can be dropped
		return m_pContainer->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::PasteFromData

HRESULT CContainerRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Container
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pContainerComponent->m_cfContainer );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of Container
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pContainer )
	{
		// Let Container handle paste
		return m_pContainer->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::CanChildPasteFromData

HRESULT CContainerRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Container Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::ChildPasteFromData

HRESULT CContainerRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Container Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdNode::GetObject

HRESULT CContainerRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CContainerRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CContainerRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pContainer )
	{
		m_pContainer->AddRef();
		*ppIDocRootNode = m_pContainer;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CContainerRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a Container Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_ContainerNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pContainer );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pContainer = (CDirectMusicContainer *)pIDocRootNode;
		m_pContainer->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerRef Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\DlgAddFiles.h ===
#if !defined(AFX_DLGADDFILES_H__A1C4955C_94FC_40B5_833C_0D471C57F42B__INCLUDED_)
#define AFX_DLGADDFILES_H__A1C4955C_94FC_40B5_833C_0D471C57F42B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgAddFiles.h : header file
//


#define SORT_NAME		1
#define SORT_TYPE		2
#define SORT_SIZE		3


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles dialog

class CDlgAddFiles : public CDialog
{
// Construction
public:
	CDlgAddFiles(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgAddFiles)
	enum { IDD = IDD_DLG_ADD_FILES };
	CStatic	m_staticReferencePrompt1;
	CStatic	m_staticReferencePrompt2;
	CButton	m_btnOK;
	CListBox	m_lstbxReference;
	CListBox	m_lstbxAvailable;
	CListBox	m_lstbxEmbed;
	CButton	m_btnReset;
	CButton	m_btnRemoveReference;
	CButton	m_btnAddReference;
	CButton	m_btnRemoveEmbed;
	CButton	m_btnAddEmbed;
	CButton	m_radioSortName;
	CButton	m_radioSortType;
	CButton	m_radioSortSize;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgAddFiles)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void FillAvailableList();
	void FillEmbedList();
	void FillReferenceList();
	void SortAvailableList();
	void SortEmbedList();
	void SortReferenceList();
	void FormatTextUI( IDMUSProdNode* pINode, CString& strText );
	CFont* CreateFont();

	// Generated message map functions
	//{{AFX_MSG(CDlgAddFiles)
	virtual BOOL OnInitDialog();
	afx_msg int OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnRadioSortName();
	afx_msg void OnDoubleClickedRadioSortName();
	afx_msg void OnRadioSortType();
	afx_msg void OnDoubleClickedRadioSortType();
	afx_msg void OnRadioSortSize();
	afx_msg void OnDoubleClickedRadioSortSize();
	virtual void OnOK();
	afx_msg void OnBtnEmbedAdd();
	afx_msg void OnBtnEmbedRemove();
	afx_msg void OnBtnReferenceAdd();
	afx_msg void OnBtnReferenceRemove();
	afx_msg void OnBtnReset();
	afx_msg void OnDblClkListAvailable();
	afx_msg void OnDblClkListEmbed();
	afx_msg void OnDblClkListReference();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	short	m_nSortType;

public:
	bool	m_fDisableReferenced;
	CString m_strTitle;

	CTypedPtrList<CPtrList, IDMUSProdNode*> m_lstAvailable;
	CTypedPtrList<CPtrList, IDMUSProdNode*> m_lstEmbedded;
	CTypedPtrList<CPtrList, IDMUSProdNode*> m_lstReferenced;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGADDFILES_H__A1C4955C_94FC_40B5_833C_0D471C57F42B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\Folder.cpp ===
// Folder.cpp : implementation file
//

#include "stdafx.h"

#include "ContainerDesignerDLL.h"
#include "Container.h"
#include "ContainerCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CFolder constructor/destructor

CFolder::CFolder()
{
	m_pContainer = NULL;
	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
}

CFolder::~CFolder()
{
	CContainerObject* pContainerObject;

	while( !m_lstObjects.IsEmpty() )
	{
		pContainerObject = m_lstObjects.RemoveHead();
		RELEASE( pContainerObject );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IUnknown implementation

HRESULT CFolder::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
		if( m_pContainer )
		{
	        return m_pContainer->QueryInterface( riid, ppvObj );
		}

		*ppvObj = NULL;
		return E_NOINTERFACE;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CFolder::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pContainer != NULL );

	AfxOleLockApp(); 

	return m_pContainer->AddRef();
}

ULONG CFolder::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pContainer != NULL );

	AfxOleUnlockApp(); 

	return m_pContainer->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeImageIndex

HRESULT CFolder::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );


	if( m_pContainer->IsInSegment() 
	&&  ::IsEqualGUID( m_guidTypeNode, GUID_ContainerRefFolderNode ) ) 
	{
		return( theApp.m_pContainerComponent->GetFolderGrayImageIndex(pnFirstImage) );
	}

	return( theApp.m_pContainerComponent->GetFolderImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetFirstChild

HRESULT CFolder::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstChildNode = NULL;

	if( !m_lstObjects.IsEmpty() )
	{
		CContainerObject* pContainerObject = m_lstObjects.GetHead();
		
		if( pContainerObject )
		{
			pContainerObject->AddRef();
			*ppIFirstChildNode = (IDMUSProdNode *)pContainerObject;
		}
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNextChild

HRESULT CFolder::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	CContainerObject* pContainerObject;

    POSITION pos = m_lstObjects.GetHeadPosition();

    while( pos )
    {
        pContainerObject = m_lstObjects.GetNext( pos );
		if( pIChildNode == (IDMUSProdNode *)pContainerObject )
		{
			if( pos )
			{
				pContainerObject = m_lstObjects.GetNext( pos );

				pContainerObject->AddRef();
				*ppINextChildNode = (IDMUSProdNode *)pContainerObject;
			}
			break;
		}
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetComponent

HRESULT CFolder::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );

	return theApp.m_pContainerComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetDocRootNode

HRESULT CFolder::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::SetDocRootNode

HRESULT CFolder::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetParentNode

HRESULT CFolder::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::SetParentNode

HRESULT CFolder::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeId

HRESULT CFolder::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = m_guidTypeNode;		// GUID_ContainerEmbedFolderNode
									// GUID_ContainerRefFolderNode

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeName

HRESULT CFolder::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeNameMaxLength

HRESULT CFolder::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a folder

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::ValidateNodeName

HRESULT CFolder::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::SetNodeName

HRESULT CFolder::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeListInfo

HRESULT CFolder::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( _afxModuleAddrThis );
	UNREFERENCED_PARAMETER(pListInfo);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetEditorClsId

HRESULT CFolder::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pClsId);

	return E_NOTIMPL;	// Can't edit a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetEditorTitle

HRESULT CFolder::GetEditorTitle( BSTR* pbstrTitle )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pbstrTitle);

	return E_NOTIMPL;	// Can't edit a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetEditorWindow

HRESULT CFolder::GetEditorWindow( HWND* hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hWndEditor);

	return E_NOTIMPL;	// Can't edit a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::SetEditorWindow

HRESULT CFolder::SetEditorWindow( HWND hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hWndEditor);

	return E_NOTIMPL;	// Can't edit a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::UseOpenCloseImages

HRESULT CFolder::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetRightClickMenuId

HRESULT CFolder::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_FOLDER_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::OnRightClickMenuInit

HRESULT CFolder::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		IDMUSProdPropPageObject* pIPageObject;

		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_PROPERTIES
		if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_ENABLED | MF_BYCOMMAND) );
			RELEASE( pIPageObject );
		}
		else
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::OnRightClickMenuSelect

HRESULT CFolder::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pContainer != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_ADD_FILES:
			m_pContainer->OnAddRemoveFiles();
			break;

		case IDM_PASTE:
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				RELEASE( pIDataObject );
			}
			break;
		}

		case IDM_PROPERTIES:
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				pIPageObject->OnShowProperties();
				RELEASE( pIPageObject );
			}
			hr = S_OK;
			break;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::DeleteChildNode

HRESULT CFolder::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIChildNode != NULL );
	ASSERT( m_pContainer != NULL );
	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	CWaitCursor wait;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Make sure we received a ContainerObject node
	GUID guidNodeId;
	HRESULT hr = pIChildNode->GetNodeId( &guidNodeId );
	if( SUCCEEDED ( hr ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_ContainerObjectNode ) == FALSE )
		{
			hr = E_FAIL;
		}
	}
	if( FAILED( hr ) )
	{
		return hr;
	}
	CContainerObject* pContainerObject = (CContainerObject *)pIChildNode;

	// Are you sure?
	if( fPromptUser )
	{
		CString strPrompt;

		if( m_pContainer->IsInScript() )
		{
			ASSERT( pContainerObject->m_FileRef.strScriptAlias.IsEmpty() == FALSE );
			AfxFormatString1( strPrompt, IDS_DELETE_ALIAS_PROMPT, pContainerObject->m_FileRef.strScriptAlias );
		}
		else
		{
			CString strObjectName;
			ASSERT( pContainerObject->m_FileRef.pIRefNode != NULL );
			if( pContainerObject->m_FileRef.pIRefNode == NULL )
			{
				TCHAR achNoObject[MID_BUFFER];
				::LoadString( theApp.m_hInstance, IDS_EMPTY_TEXT, achNoObject, MID_BUFFER );
				strObjectName = achNoObject;
			}
			else
			{
				BSTR bstrObjectName;
				if( SUCCEEDED ( pContainerObject->m_FileRef.pIRefNode->GetNodeName( &bstrObjectName ) ) )
				{
					strObjectName = bstrObjectName;
					::SysFreeString( bstrObjectName );
				}
			}
			AfxFormatString1( strPrompt, IDS_DELETE_NODE_PROMPT, strObjectName );
		}

		if( AfxMessageBox( strPrompt, MB_OKCANCEL ) != IDOK )
		{
			return E_FAIL;
		}
	}

	// Remove node from Project Tree
	if( theApp.m_pContainerComponent->m_pIFramework8->RemoveNode( pIChildNode, FALSE ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Save undo state
//	m_pContainer->m_pINodeBeingDeleted = pIChildNode;
//	m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_DELETE_BAND );
//	m_pContainer->m_pINodeBeingDeleted = NULL;

	// Need to keep node until after SyncContainerEditor() 
	pIChildNode->AddRef();

	// Remove from object list
	POSITION pos = m_lstObjects.Find( pContainerObject );
	if( pos )
	{
		m_lstObjects.RemoveAt( pos );
		pContainerObject->Release();
	}

	// Sync Container editor (when open)
	m_pContainer->SyncContainerEditor();
	RELEASE( pIChildNode );

	m_pContainer->SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::InsertChildNode

HRESULT CFolder::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIChildNode != NULL );
	ASSERT( m_pContainer != NULL );
	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	// Make sure we received a ContainerObject node
	GUID guidNodeId;
	HRESULT hr = pIChildNode->GetNodeId( &guidNodeId );
	if( SUCCEEDED ( hr ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_ContainerObjectNode ) == FALSE )
		{
			hr = E_FAIL;
		}
	}
	if( FAILED( hr ) )
	{
		return hr;
	}

	// We received the right type of node
	pIChildNode->AddRef();

	// Add to object list
	CContainerObject* pContainerObject = (CContainerObject *)pIChildNode;
	m_lstObjects.AddTail( pContainerObject );

	// Set root and parent node of ALL children
	ASSERT( m_pIDocRootNode != NULL );
	theApp.SetNodePointers( pIChildNode, m_pIDocRootNode, (IDMUSProdNode *)this );

	// Add node to Project Tree
	if( !SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->AddNode(pIChildNode, (IDMUSProdNode *)this) ) )
	{
		DeleteChildNode( pIChildNode, FALSE );
		return E_FAIL;
	}

	// Sync Container editor (when open)
	m_pContainer->SyncContainerEditor();

	m_pContainer->SetModified( TRUE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::DeleteNode

HRESULT CFolder::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// Can't delete a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::OnNodeSelChanged

HRESULT CFolder::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CreateDataObject

HRESULT CFolder::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanCut

HRESULT CFolder::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_FALSE;		// Can't remove folder from Container
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanCopy

HRESULT CFolder::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanDelete

HRESULT CFolder::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_FALSE;		// Can't delete folder from Container
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanDeleteChildNode

HRESULT CFolder::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure we received a ContainerObject node
	GUID guidNodeId;
	HRESULT hr = pIChildNode->GetNodeId( &guidNodeId );
	if( SUCCEEDED ( hr ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_ContainerObjectNode ) == FALSE )
		{
			hr = E_FAIL;
		}
	}
	if( FAILED( hr ) )
	{
		return hr;
	}

	// Make sure node is in object list
	CContainerObject* pContainerObject = (CContainerObject *)pIChildNode;
	POSITION pos = m_lstObjects.Find( pContainerObject );
	if( pos == NULL )
	{
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanPasteFromData

HRESULT CFolder::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pContainer != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = TRUE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pContainer->IsInSegment() )
	{
		if( ::IsEqualGUID( m_guidTypeNode, GUID_ContainerRefFolderNode ) ) 
		{
			// Can't place items in a Segment Container's reference folder
			return E_FAIL;
		}
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pContainerComponent->m_cfProducerFile ) ) )
	{
		IDMUSProdNode* pIDocRootNode;
			
		if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode ) ) )
		{
			GUID guidNodeId;

			if( SUCCEEDED ( pIDocRootNode->GetNodeId( &guidNodeId ) ) )
			{
				IDMUSProdDocType* pIDocType;

				if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->FindDocTypeByNodeId( guidNodeId, &pIDocType ) ) )
				{
					IDMUSProdDocType8* pIDocType8;

					if( SUCCEEDED ( pIDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDocType8 ) ) )
					{
						if( SUCCEEDED ( theApp.m_pContainerComponent->IsRegisteredObject( pIDocRootNode ) ) )
						{
							if( IsDocRootInFolder( pIDocRootNode ) == S_FALSE )
							{
								if( m_pContainer->IsCircularReference( pIDocRootNode, this ) == S_FALSE )
								{
									if( m_pContainer->IsInScript() )
									{
										// Can't place an external container in a script's container
										GUID guidNodeId;
										if( SUCCEEDED ( pIDocRootNode->GetNodeId( &guidNodeId ) ) )
										{
											if( ::IsEqualGUID( guidNodeId, GUID_ContainerNode ) == FALSE)
											{
												hr = S_OK;
											}
										}
									}
									else
									{
										hr = S_OK;
									}
								}
							}
						}

						RELEASE( pIDocType8 );
					}

					RELEASE( pIDocType );
				}
			}
			

			RELEASE( pIDocRootNode );
		}
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::PasteFromData

HRESULT CFolder::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pContainer != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pContainer->IsInSegment() )
	{
		if( ::IsEqualGUID( m_guidTypeNode, GUID_ContainerRefFolderNode ) ) 
		{
			// Can't place items in a Segment Container's reference folder
			return E_FAIL;
		}
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr;

	hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pContainerComponent->m_cfProducerFile );
	if( SUCCEEDED ( hr ) )
	{
		IDMUSProdNode* pIDocRootNode;
			
		hr = theApp.m_pContainerComponent->m_pIFramework8->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode );
		if( SUCCEEDED ( hr ) )
		{
			if( theApp.m_pContainerComponent->IsRegisteredObject( pIDocRootNode ) == S_OK )
			{
				CContainerObject* pContainerObject = NULL;

				// If DocRoot is in the other folder - remove it
				if( ::IsEqualGUID( m_guidTypeNode, GUID_ContainerEmbedFolderNode ) ) 
				{
					pContainerObject = m_pContainer->m_FolderReference.GetObjectFromDocRoot( pIDocRootNode );
					if( pContainerObject )
					{
						pContainerObject->AddRef();
						m_pContainer->m_FolderReference.DeleteChildNode( pContainerObject, FALSE );
					}
				}
				else if( ::IsEqualGUID( m_guidTypeNode, GUID_ContainerRefFolderNode ) ) 
				{
					pContainerObject = m_pContainer->m_FolderEmbed.GetObjectFromDocRoot( pIDocRootNode );
					if( pContainerObject )
					{
						pContainerObject->AddRef();
						m_pContainer->m_FolderEmbed.DeleteChildNode( pContainerObject, FALSE );
					}
				}
				else
				{
					ASSERT( 0 );
				}

				// Make sure a ContainerObject exists for the DocRoot
				if( pContainerObject == NULL )
				{
					pContainerObject = new CContainerObject( m_pContainer );
					if( pContainerObject )
					{
						if( FAILED ( pContainerObject->SetFileReference( pIDocRootNode ) ) )
						{
							RELEASE( pContainerObject );
						}
					}
				}

				// Add the DocRoot to this folder
				if( pContainerObject )
				{
					hr = InsertChildNode( pContainerObject );
					if( FAILED ( hr ) )
					{
						pContainerObject->AddRef();
						DeleteChildNode( pContainerObject, FALSE );
					}
				}
				else
				{
					hr = E_FAIL;
				}

				RELEASE( pContainerObject );
			}

			RELEASE( pIDocRootNode );
		}
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanChildPasteFromData

HRESULT CFolder::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										BOOL *pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return CanPasteFromData( pIDataObject, pfWillSetReference );
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::ChildPasteFromData

HRESULT CFolder::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return PasteFromData( pIDataObject );
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetObject

HRESULT CFolder::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::OnUpdate	(handles Container's IDMUSProdNotifSink notifications)

HRESULT CFolder::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CContainerObject* pContainerObject;

	// FRAMEWORK_FileLoadFinished
	if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileLoadFinished ) )
	{
		GUID guidFile = *(GUID *)pData;

		BOOL fChanged = FALSE;
		
		POSITION pos = m_lstObjects.GetHeadPosition();
		while( pos )
		{
			pContainerObject = m_lstObjects.GetNext( pos );

			if( ::IsEqualGUID( pContainerObject->m_FileRef.li.guidFile, guidFile ) )
			{ 
				CString strOrigScriptAlias = pContainerObject->m_FileRef.strScriptAlias;

				if( SUCCEEDED ( pContainerObject->SetFileReference( pIDocRootNode ) ) )
				{
					// Restore Alias from file
					// Must do this sooner because SetFileReference() resets alias
					if( strOrigScriptAlias.IsEmpty() == FALSE )
					{
						if( strOrigScriptAlias.Compare( pContainerObject->m_FileRef.strScriptAlias ) != 0 )
						{
							pContainerObject->m_FileRef.strScriptAlias = strOrigScriptAlias;
						}
					}

					if( pContainerObject->m_pIDocRootNode
					&&  pContainerObject->m_pIParentNode )
					{
						// Need to refresh node name and node image index
						theApp.m_pContainerComponent->m_pIFramework8->RefreshNode( pContainerObject );
					}
				}

				fChanged = TRUE;
			}
		}

		if( fChanged )
		{
			if( m_pIDocRootNode
			&&  m_pIDocRootNode != this )
			{
				// Notify DocRoot that the container has changed
				IDMUSProdNotifySink* pINotifySink;
				if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
				{
					pINotifySink->OnUpdate( m_pContainer, CONTAINER_FileLoadFinished, NULL );

					RELEASE( pINotifySink );
				}
			}
		}

		if( theApp.m_pContainerComponent->m_pEmbeddedFileRootFile )
		{
			if( ::IsEqualGUID(theApp.m_pContainerComponent->m_pEmbeddedFileRootFile->guidNotification, guidFile) )
			{ 
				delete theApp.m_pContainerComponent->m_pEmbeddedFileRootFile;
				theApp.m_pContainerComponent->m_pEmbeddedFileRootFile = NULL;
			}
		}
	}
	else
	{
		POSITION pos = m_lstObjects.GetHeadPosition();
		while( pos )
		{
			pContainerObject = m_lstObjects.GetNext( pos );

			if( pContainerObject->m_FileRef.pIDocRootNode == pIDocRootNode )
			{
				// FRAMEWORK_FileDeleted
				// FRAMEWORK_FileClosed
				if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileDeleted )
				||  ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileClosed ) )
				{
					DeleteChildNode( pContainerObject, FALSE );
					return S_OK;
				}

				// FRAMEWORK_FileReplaced
				else if( ::IsEqualGUID(guidUpdateType, FRAMEWORK_FileReplaced ) )
				{
					pContainerObject->SetFileReference( (IDMUSProdNode *)pData );
					theApp.m_pContainerComponent->m_pIFramework8->RefreshNode( pContainerObject );
					m_pContainer->SetModified( TRUE );
					return S_OK;
				}

				// DOCROOT_GuidChange
				else if( ::IsEqualGUID(guidUpdateType, DOCROOT_GuidChange ) )
				{
					m_pContainer->SetModified( TRUE );
					return S_OK;
				}

				// GUID_DMCollectionResync
				else if( ::IsEqualGUID(guidUpdateType, GUID_DMCollectionResync ) )
				{
					if( m_pIDocRootNode 
					&&  m_pIDocRootNode != m_pContainer )
					{
						// Pass on the notification to our DocRoot node
						IDMUSProdNotifySink* pINotifySink;
						if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
						{
							pINotifySink->OnUpdate( pIDocRootNode, guidUpdateType, pData );

							RELEASE( pINotifySink );
						}
					}
					return S_OK;
				}

				// All other notifications
				else
				{
					theApp.m_pContainerComponent->m_pIFramework8->RefreshNode( pContainerObject );
					pContainerObject->SyncListInfo();

					// Directly setting modified flag instead of going through SetModified().
					// SetModified() sends CONTAINER_ChangeNotifications.
					// Does not make sense to send CONTAINER_ChangeNotifications  
					// for every little change that might occur to a referenced file.
					m_pContainer->m_fModified = TRUE;
					return S_OK;
				}
			}
		}
	}

	return E_INVALIDARG;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::FindDocRootFromName

HRESULT CFolder::FindDocRootFromName( LPCTSTR pszName, IUnknown** ppIDocRootNode )
{
	CContainerObject* pContainerObject;
	HRESULT hr = S_FALSE;

    POSITION pos = m_lstObjects.GetHeadPosition();
    while( pos )
    {
        pContainerObject = m_lstObjects.GetNext( pos );

		if( pContainerObject->m_FileRef.li.strName.CompareNoCase( pszName ) == 0 )
		{
			if( pContainerObject->m_FileRef.pIDocRootNode )
			{
				pContainerObject->m_FileRef.pIDocRootNode->AddRef();
				*ppIDocRootNode = pContainerObject->m_FileRef.pIDocRootNode;
				hr = S_OK;
			}
			break;
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::FindDocRootFromScriptAlias

HRESULT CFolder::FindDocRootFromScriptAlias( LPCTSTR pszAlias, IUnknown** ppIDocRootNode )
{
	CContainerObject* pContainerObject;
	HRESULT hr = S_FALSE;

    POSITION pos = m_lstObjects.GetHeadPosition();
    while( pos )
    {
        pContainerObject = m_lstObjects.GetNext( pos );

		if( pContainerObject->m_FileRef.strScriptAlias.CompareNoCase( pszAlias ) == 0 )
		{
			if( pContainerObject->m_FileRef.pIDocRootNode )
			{
				pContainerObject->m_FileRef.pIDocRootNode->AddRef();
				*ppIDocRootNode = pContainerObject->m_FileRef.pIDocRootNode;
				hr = S_OK;
			}
			break;
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::IsDocRootInFolder

HRESULT CFolder::IsDocRootInFolder( IDMUSProdNode* pIDocRootNode )
{
	CContainerObject* pContainerObject;
	HRESULT hr = S_FALSE;

    POSITION pos = m_lstObjects.GetHeadPosition();
    while( pos )
    {
        pContainerObject = m_lstObjects.GetNext( pos );

		if( pContainerObject->m_FileRef.pIDocRootNode == pIDocRootNode )
		{
			hr = S_OK;
			break;
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::IsFileGUIDInFolder

HRESULT CFolder::IsFileGUIDInFolder( GUID guidFile )
{
	CContainerObject* pContainerObject;
	HRESULT hr = S_FALSE;

    POSITION pos = m_lstObjects.GetHeadPosition();
    while( pos )
    {
        pContainerObject = m_lstObjects.GetNext( pos );

		if( pContainerObject->m_FileRef.pIDocRootNode )
		{
			if( ::IsEqualGUID( pContainerObject->m_FileRef.li.guidFile, guidFile ) )
			{
				hr = S_OK;
				break;
			}
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::GetObjectFromDocRoot

CContainerObject* CFolder::GetObjectFromDocRoot( IDMUSProdNode* pIDocRootNode )
{
	CContainerObject* pTheContainerObject = NULL;
	CContainerObject* pContainerObject;

    POSITION pos = m_lstObjects.GetHeadPosition();
    while( pos )
    {
        pContainerObject = m_lstObjects.GetNext( pos );

		if( pContainerObject->m_FileRef.pIDocRootNode == pIDocRootNode )
		{
			pTheContainerObject = pContainerObject;
			break;
		}
	}

	return pTheContainerObject;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::ReplaceContent

void CFolder::ReplaceContent( CTypedPtrList<CPtrList, IDMUSProdNode*>& list )
{
	CTypedPtrList<CPtrList, IDMUSProdNode*> listToBeDeleted;

	// Save original list of DocRoot nodes
	POSITION pos = m_lstObjects.GetHeadPosition();
	while( pos )
	{
		CContainerObject* pContainerObject = m_lstObjects.GetNext( pos);

		listToBeDeleted.AddTail( pContainerObject->m_FileRef.pIDocRootNode );
	}

	// Process the new list of files
	pos = list.GetHeadPosition();
	while( pos )
	{
		IDMUSProdNode* pINode = list.GetNext( pos );

		GUID guidFile;
		theApp.m_pContainerComponent->m_pIFramework8->GetNodeFileGUID( pINode, &guidFile );

		IDMUSProdNode* pIDocRootNode;
		if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->FindDocRootNodeByFileGUID( guidFile, &pIDocRootNode ) ) )
		{
			if( theApp.m_pContainerComponent->IsRegisteredObject( pIDocRootNode ) == S_OK )
			{
				POSITION posFind = listToBeDeleted.Find( pIDocRootNode );
				if( posFind )
				{
					// DocRoot is already in this folder - so remove it from the "To Be Deleted" list
					listToBeDeleted.RemoveAt( posFind );
				}
				
				else
				{
					CContainerObject* pContainerObject = NULL;

					// If DocRoot is in the other folder - remove it
					if( ::IsEqualGUID( m_guidTypeNode, GUID_ContainerEmbedFolderNode ) ) 
					{
						pContainerObject = m_pContainer->m_FolderReference.GetObjectFromDocRoot( pIDocRootNode );
						if( pContainerObject )
						{
							pContainerObject->AddRef();
							m_pContainer->m_FolderReference.DeleteChildNode( pContainerObject, FALSE );
						}
					}
					else if( ::IsEqualGUID( m_guidTypeNode, GUID_ContainerRefFolderNode ) ) 
					{
						pContainerObject = m_pContainer->m_FolderEmbed.GetObjectFromDocRoot( pIDocRootNode );
						if( pContainerObject )
						{
							pContainerObject->AddRef();
							m_pContainer->m_FolderEmbed.DeleteChildNode( pContainerObject, FALSE );
						}
					}
					else
					{
						ASSERT( 0 );
					}

					// Make sure a ContainerObject exists for the DocRoot
					if( pContainerObject == NULL )
					{
						pContainerObject = new CContainerObject( m_pContainer );
						if( pContainerObject )
						{
							if( FAILED ( pContainerObject->SetFileReference( pIDocRootNode ) ) )
							{
								RELEASE( pContainerObject );
							}
						}
					}

					// Add the DocRoot to this folder
					if( pContainerObject )
					{
						if( FAILED ( InsertChildNode( pContainerObject ) ) )
						{
							pContainerObject->AddRef();
							DeleteChildNode( pContainerObject, FALSE );
						}
					}

					RELEASE( pContainerObject );
				}
			}

			RELEASE( pIDocRootNode );
		}
	}

	// Delete files no longer in the folder
	while( !listToBeDeleted.IsEmpty() )
	{
		IDMUSProdNode* pIDocRootNode = listToBeDeleted.RemoveHead();

		CContainerObject* pContainerObject = GetObjectFromDocRoot( pIDocRootNode );
		DeleteChildNode( pContainerObject, FALSE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\DlgAddFiles.cpp ===
// DlgAddFiles.cpp : implementation file
//

#include "stdafx.h"
#include "ContainerDesignerDll.h"
#include "Container.h"
#include "DlgAddFiles.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles dialog

CDlgAddFiles::CDlgAddFiles(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgAddFiles::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgAddFiles)
	//}}AFX_DATA_INIT

	m_nSortType = SORT_NAME;
	m_fDisableReferenced = false;
}


void CDlgAddFiles::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgAddFiles)
	DDX_Control(pDX, IDC_REFERENCE_PROMPT1, m_staticReferencePrompt1);
	DDX_Control(pDX, IDC_REFERENCE_PROMPT2, m_staticReferencePrompt2);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_LIST_REFERENCE, m_lstbxReference);
	DDX_Control(pDX, IDC_LIST_AVAILABLE, m_lstbxAvailable);
	DDX_Control(pDX, IDC_LIST_EMBED, m_lstbxEmbed);
	DDX_Control(pDX, IDC_BTN_RESET, m_btnReset);
	DDX_Control(pDX, IDC_BTN_REFERENCE_REMOVE, m_btnRemoveReference);
	DDX_Control(pDX, IDC_BTN_REFERENCE_ADD, m_btnAddReference);
	DDX_Control(pDX, IDC_BTN_EMBED_REMOVE, m_btnRemoveEmbed);
	DDX_Control(pDX, IDC_BTN_EMBED_ADD, m_btnAddEmbed);
	DDX_Control(pDX, IDC_RADIO_SORT_NAME, m_radioSortName);
	DDX_Control(pDX, IDC_RADIO_SORT_TYPE, m_radioSortType);
	DDX_Control(pDX, IDC_RADIO_SORT_SIZE, m_radioSortSize);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::FillAvailableList

void CDlgAddFiles::FillAvailableList( void )
{
	m_lstbxAvailable.SetRedraw( FALSE );

	// Initialize the list box
	m_lstbxAvailable.ResetContent();
	m_lstbxAvailable.SetHorizontalExtent( 0 );

	// Fill the list box
    POSITION pos = m_lstAvailable.GetHeadPosition();
    while( pos )
    {
        IDMUSProdNode* pINode = m_lstAvailable.GetNext( pos );

		m_lstbxAvailable.AddString( (LPCTSTR)pINode );
	}

	m_lstbxAvailable.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::FillEmbedList

void CDlgAddFiles::FillEmbedList( void )
{
	m_lstbxEmbed.SetRedraw( FALSE );

	// Initialize the list box
	m_lstbxEmbed.ResetContent();
	m_lstbxEmbed.SetHorizontalExtent( 0 );

	// Fill the list box
    POSITION pos = m_lstEmbedded.GetHeadPosition();
    while( pos )
    {
        IDMUSProdNode* pINode = m_lstEmbedded.GetNext( pos );

		m_lstbxEmbed.AddString( (LPCTSTR)pINode );
	}

	m_lstbxEmbed.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::FillReferenceList

void CDlgAddFiles::FillReferenceList( void )
{
	m_lstbxReference.SetRedraw( FALSE );

	// Initialize the list box
	m_lstbxReference.ResetContent();
	m_lstbxReference.SetHorizontalExtent( 0 );

	// Fill the list box
    POSITION pos = m_lstReferenced.GetHeadPosition();
    while( pos )
    {
        IDMUSProdNode* pINode = m_lstReferenced.GetNext( pos );

		m_lstbxReference.AddString( (LPCTSTR)pINode );
	}

	m_lstbxReference.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::SortAvailableList

void CDlgAddFiles::SortAvailableList( void )
{
	m_lstbxAvailable.SetRedraw( FALSE );

	// Store current list
	CTypedPtrList<CPtrList, IDMUSProdNode*> listAvailable;
	int nCount = m_lstbxAvailable.GetCount();
	for( int nPos = 0 ;  nPos < nCount ;  nPos++ )
	{
		IDMUSProdNode* pINode = (IDMUSProdNode *)m_lstbxAvailable.GetItemData( nPos ); 

		if( pINode )
		{
			listAvailable.AddTail( pINode );
		}
	}

	// Initialize the list box
	m_lstbxAvailable.ResetContent();
	m_lstbxAvailable.SetHorizontalExtent( 0 );

	// Fill the list box
    POSITION pos = listAvailable.GetHeadPosition();
    while( pos )
    {
        IDMUSProdNode* pINode = listAvailable.GetNext( pos );

		m_lstbxAvailable.AddString( (LPCTSTR)pINode );
	}

	m_lstbxAvailable.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::SortEmbedList

void CDlgAddFiles::SortEmbedList( void )
{
	m_lstbxEmbed.SetRedraw( FALSE );

	// Store current list
	CTypedPtrList<CPtrList, IDMUSProdNode*> listEmbedded;
	int nCount = m_lstbxEmbed.GetCount();
	for( int nPos = 0 ;  nPos < nCount ;  nPos++ )
	{
		IDMUSProdNode* pINode = (IDMUSProdNode *)m_lstbxEmbed.GetItemData( nPos ); 

		if( pINode )
		{
			listEmbedded.AddTail( pINode );
		}
	}

	// Initialize the list box
	m_lstbxEmbed.ResetContent();
	m_lstbxEmbed.SetHorizontalExtent( 0 );

	// Fill the list box
    POSITION pos = listEmbedded.GetHeadPosition();
    while( pos )
    {
        IDMUSProdNode* pINode = listEmbedded.GetNext( pos );

		m_lstbxEmbed.AddString( (LPCTSTR)pINode );
	}

	m_lstbxEmbed.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::SortReferenceList

void CDlgAddFiles::SortReferenceList( void )
{
	m_lstbxReference.SetRedraw( FALSE );

	// Store current list
	CTypedPtrList<CPtrList, IDMUSProdNode*> listReferenced;
	int nCount = m_lstbxReference.GetCount();
	for( int nPos = 0 ;  nPos < nCount ;  nPos++ )
	{
		IDMUSProdNode* pINode = (IDMUSProdNode *)m_lstbxReference.GetItemData( nPos ); 

		if( pINode )
		{
			listReferenced.AddTail( pINode );
		}
	}

	// Initialize the list box
	m_lstbxReference.ResetContent();
	m_lstbxReference.SetHorizontalExtent( 0 );

	// Fill the list box
    POSITION pos = listReferenced.GetHeadPosition();
    while( pos )
    {
        IDMUSProdNode* pINode = listReferenced.GetNext( pos );

		m_lstbxReference.AddString( (LPCTSTR)pINode );
	}

	m_lstbxReference.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::FormatTextUI

void CDlgAddFiles::FormatTextUI( IDMUSProdNode* pINode, CString& strText )
{
	strText.Empty();

	CString strProjectDir;
	
	BSTR bstrFileName;
	IDMUSProdProject* pIProject;
	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->FindProject( pINode, &pIProject ) ) )
	{
		IDMUSProdNode* pIProjectNode;
		if( SUCCEEDED ( pIProject->QueryInterface( IID_IDMUSProdNode, (void**)&pIProjectNode ) ) )
		{
			if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->GetNodeFileName( pIProjectNode, &bstrFileName ) ) )
			{
				strProjectDir = bstrFileName;
				::SysFreeString( bstrFileName );

				int nFindPos = strProjectDir.ReverseFind( (TCHAR)'\\' );
				if( nFindPos != -1 )
				{
					strProjectDir = strProjectDir.Left( nFindPos + 1 );
				}
			}

			RELEASE( pIProjectNode );
		}

		RELEASE( pIProject );
	}

	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->GetNodeFileName( pINode, &bstrFileName ) ) )
	{
		strText = bstrFileName;
		::SysFreeString( bstrFileName );

		// Strip Project directory from path
		strText = strText.Right( strText.GetLength() - strProjectDir.GetLength() );

		int nFindPos = strText.Find( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strText = _T( "..\\" ) + strText;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::CreateFont

CFont* CDlgAddFiles::CreateFont( void )
{
	CFont* pFont = new CFont;

	if( pFont 
	&&  pFont->CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						   DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						   DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		return pFont;
	}

	if( pFont )
	{
		delete pFont;
	}
	return NULL;
}


BEGIN_MESSAGE_MAP(CDlgAddFiles, CDialog)
	//{{AFX_MSG_MAP(CDlgAddFiles)
	ON_WM_COMPAREITEM()
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_BN_CLICKED(IDC_RADIO_SORT_NAME, OnRadioSortName)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SORT_NAME, OnDoubleClickedRadioSortName)
	ON_BN_CLICKED(IDC_RADIO_SORT_TYPE, OnRadioSortType)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SORT_TYPE, OnDoubleClickedRadioSortType)
	ON_BN_CLICKED(IDC_RADIO_SORT_SIZE, OnRadioSortSize)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SORT_SIZE, OnDoubleClickedRadioSortSize)
	ON_BN_CLICKED(IDC_BTN_EMBED_ADD, OnBtnEmbedAdd)
	ON_BN_CLICKED(IDC_BTN_EMBED_REMOVE, OnBtnEmbedRemove)
	ON_BN_CLICKED(IDC_BTN_REFERENCE_ADD, OnBtnReferenceAdd)
	ON_BN_CLICKED(IDC_BTN_REFERENCE_REMOVE, OnBtnReferenceRemove)
	ON_BN_CLICKED(IDC_BTN_RESET, OnBtnReset)
	ON_LBN_DBLCLK(IDC_LIST_AVAILABLE, OnDblClkListAvailable)
	ON_LBN_DBLCLK(IDC_LIST_EMBED, OnDblClkListEmbed)
	ON_LBN_DBLCLK(IDC_LIST_REFERENCE, OnDblClkListReference)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles message handlers

/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnInitDialog

BOOL CDlgAddFiles::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	// Set dialog title
	if( m_strTitle.IsEmpty() == FALSE )
	{
		SetWindowText( m_strTitle );
	}

	// Initialize list boxes
	FillAvailableList();
	FillEmbedList();
	FillReferenceList();

	// Initialize sort order radio buttons
	m_radioSortName.SetCheck( (m_nSortType == SORT_NAME) ? 1 : 0 );
	m_radioSortType.SetCheck( (m_nSortType == SORT_TYPE) ? 1 : 0 );
	m_radioSortSize.SetCheck( (m_nSortType == SORT_SIZE) ? 1 : 0 );

	// Disable "reference" controls
	if( m_fDisableReferenced )
	{
		m_lstbxReference.EnableWindow( FALSE );
		m_btnAddReference.EnableWindow( FALSE );
		m_btnRemoveReference.EnableWindow( FALSE );
		m_staticReferencePrompt1.EnableWindow( FALSE );
		m_staticReferencePrompt2.EnableWindow( FALSE );
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnCompareItem

int CDlgAddFiles::OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( nIDCtl )
	{
		case IDC_LIST_AVAILABLE:
		case IDC_LIST_EMBED:
		case IDC_LIST_REFERENCE:
		{
			IDMUSProdNode* pINode1 = (IDMUSProdNode *)lpCompareItemStruct->itemData1;
			IDMUSProdNode* pINode2 = (IDMUSProdNode *)lpCompareItemStruct->itemData2;
			
			CString strName1;
			FormatTextUI( pINode1, strName1 );
			
			CString strName2;
			FormatTextUI( pINode2, strName2 );

			switch( m_nSortType )
			{
				// Sort by file type
				case SORT_TYPE:
				{
					CString strExt1;
					int nFindPos = strName1.ReverseFind( (TCHAR)'.' );
					if( nFindPos != -1 )
					{
						strExt1 = strName1.Right( strName1.GetLength() - nFindPos - 1 );
					}

					CString strExt2;
					nFindPos = strName2.ReverseFind( (TCHAR)'.' );
					if( nFindPos != -1 )
					{
						strExt2 = strName2.Right( strName2.GetLength() - nFindPos - 1 );
					}

					if( strExt1.CompareNoCase( strExt2 ) > 0 )
					{
						return 1;
					}
					if( strExt1.CompareNoCase( strExt2 ) < 0 )
					{
						return -1;
					}
					return strName1.CompareNoCase( strName2 );
				}

				// Sort by file size
				case SORT_SIZE:
				{
					BSTR bstrFileName1;
					theApp.m_pContainerComponent->m_pIFramework8->GetNodeFileName( pINode1, &bstrFileName1 );
					CString strFileName1 = bstrFileName1;
					::SysFreeString( bstrFileName1 );

					BSTR bstrFileName2;
					theApp.m_pContainerComponent->m_pIFramework8->GetNodeFileName( pINode2, &bstrFileName2 );
					CString strFileName2 = bstrFileName2;
					::SysFreeString( bstrFileName2 );

					DWORD dwFileSize1 = 0;
					HANDLE hFile = ::CreateFile( strFileName1, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 											 FILE_ATTRIBUTE_NORMAL, NULL );
					if( hFile != INVALID_HANDLE_VALUE )
					{
						dwFileSize1 = GetFileSize( hFile, NULL );
						CloseHandle( hFile );
					}

					DWORD dwFileSize2 = 0;
					hFile = ::CreateFile( strFileName2, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 									  FILE_ATTRIBUTE_NORMAL, NULL );
					if( hFile != INVALID_HANDLE_VALUE )
					{
						dwFileSize2 = GetFileSize( hFile, NULL );
						CloseHandle( hFile );
					}

					if( dwFileSize1 < dwFileSize2 )
					{
						return 1;
					}
					if( dwFileSize1 > dwFileSize2 )
					{
						return -1;
					}
					return strName1.CompareNoCase( strName2 );
				}

				// Sort by file name
				default:
					return strName1.CompareNoCase( strName2 );
			}
		}
	}
	
	return CDialog::OnCompareItem( nIDCtl, lpCompareItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnDrawItem

void CDlgAddFiles::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( lpDrawItemStruct->itemID == -1 )
	{
		// Just deal with focus rect
		InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
		DrawFocusRect( lpDrawItemStruct->hDC, &lpDrawItemStruct->rcItem );
		InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
		return;
	}

	if( nIDCtl != IDC_LIST_AVAILABLE
	&&  nIDCtl != IDC_LIST_EMBED
	&&  nIDCtl != IDC_LIST_REFERENCE )
	{
		ASSERT( 0 );
		CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
	}

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

    if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
    ||  lpDrawItemStruct->itemAction & ODA_SELECT 
    ||  lpDrawItemStruct->itemAction & ODA_FOCUS )
	{
		IDMUSProdNode* pINode = (IDMUSProdNode *)lpDrawItemStruct->itemData; 
		ASSERT( pINode != NULL );

		// Determine text
		CString strText;
		FormatTextUI( pINode, strText );

	    int nWidth  = lpDrawItemStruct->rcItem.right  - lpDrawItemStruct->rcItem.left;
		int nHeight = lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;

		CRect rect( 0, 0, nWidth, nHeight );

		CDC dc;
		CBitmap bmp;

		if( dc.CreateCompatibleDC( pDC )
		&&  bmp.CreateCompatibleBitmap( pDC, nWidth, nHeight ) )
		{
			CFont* pFontOld = NULL;
			CFont* pFont = CreateFont();
			if( pFont )
			{
				pFontOld = dc.SelectObject( pFont );
			}
			CBitmap* pBitmapOld = dc.SelectObject( &bmp );
			int nBkModeOld = dc.SetBkMode( TRANSPARENT );

			// Set horizontal extent
			TEXTMETRIC tm;
			dc.GetTextMetrics( &tm );
			CSize sizeText = dc.GetTextExtent( strText );
			sizeText.cx += tm.tmMaxCharWidth;
			if( sizeText.cx > ::SendMessage(lpDrawItemStruct->hwndItem, LB_GETHORIZONTALEXTENT, 0, 0) )
			{
				::SendMessage( lpDrawItemStruct->hwndItem, LB_SETHORIZONTALEXTENT, sizeText.cx, 0 );
			}

			if( lpDrawItemStruct->itemState & ODS_SELECTED )
			{
				if( ::GetFocus() == lpDrawItemStruct->hwndItem )
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
					dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
				}
				else
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
					dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
				}
			}
			else
			{
				dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
				dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
			}

			// Draw the item
			rect.left  += 3;
			dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );
			pDC->BitBlt( lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, nWidth, nHeight, 
						 &dc, 0, 0, SRCCOPY );

			// Clean up
			dc.SetBkMode( nBkModeOld );
			if( pFontOld )
			{
				dc.SelectObject( pFontOld );
				pFont->DeleteObject();
				delete pFont;
			}
			if( pBitmapOld )
			{
				dc.SelectObject( pBitmapOld );
			}
		}

		if( ::GetFocus() == lpDrawItemStruct->hwndItem )
		{
			if( (lpDrawItemStruct->itemAction & ODA_FOCUS)
			&&  (lpDrawItemStruct->itemState & ODS_FOCUS) )
			{
				InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
				pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
				InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnMeasureItem

void CDlgAddFiles::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( nIDCtl )
	{
		case IDC_LIST_AVAILABLE:
		case IDC_LIST_EMBED:
		case IDC_LIST_REFERENCE:
		{
			CDC* pDC = GetDC();
			if( pDC )
			{
				CFont* pFontOld = NULL;
				CFont* pFont = CreateFont();
				if( pFont )
				{
					pFontOld = pDC->SelectObject( pFont );
				}

				TEXTMETRIC tm;
				pDC->GetTextMetrics( &tm );
				lpMeasureItemStruct->itemHeight = tm.tmHeight + 1;
				
				if( pFontOld )
				{
					pDC->SelectObject( pFontOld );
					pFont->DeleteObject();
					delete pFont;
				}

				ReleaseDC( pDC );
				return;
			}
		}
	}
	
	CDialog::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnRadioSortName

void CDlgAddFiles::OnRadioSortName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;

	m_radioSortName.SetCheck( 1 );

	if( m_nSortType != SORT_NAME )
	{
		m_nSortType = SORT_NAME;

		// Sort list boxes
		SortAvailableList();
		SortEmbedList();
		SortReferenceList();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnDoubleClickedRadioSortName

void CDlgAddFiles::OnDoubleClickedRadioSortName() 
{
	OnRadioSortName();
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnRadioSortType

void CDlgAddFiles::OnRadioSortType() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;

	m_radioSortType.SetCheck( 1 );

	if( m_nSortType != SORT_TYPE )
	{
		m_nSortType = SORT_TYPE;

		// Sort list boxes
		SortAvailableList();
		SortEmbedList();
		SortReferenceList();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnDoubleClickedRadioSortType

void CDlgAddFiles::OnDoubleClickedRadioSortType() 
{
	OnRadioSortType();
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnRadioSortSize

void CDlgAddFiles::OnRadioSortSize() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;

	m_radioSortSize.SetCheck( 1 );

	if( m_nSortType != SORT_SIZE )
	{
		m_nSortType = SORT_SIZE;

		// Sort list boxes
		SortAvailableList();
		SortEmbedList();
		SortReferenceList();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnDoubleClickedRadioSortSize

void CDlgAddFiles::OnDoubleClickedRadioSortSize() 
{
	OnRadioSortSize();
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnBtnEmbedAdd

void CDlgAddFiles::OnBtnEmbedAdd() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nNbrSelItems = m_lstbxAvailable.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	m_lstbxAvailable.SetRedraw( FALSE );
	m_lstbxEmbed.SetRedraw( FALSE );

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_lstbxAvailable.GetSelItems( nNbrSelItems, pnSelItems );

		m_lstbxAvailable.SetSel( -1, FALSE ); 
		m_lstbxEmbed.SetSel( -1, FALSE ); 

		for( int nPos = (nNbrSelItems - 1);  nPos >= 0 ;  nPos-- )
		{
			IDMUSProdNode* pINode = (IDMUSProdNode *)m_lstbxAvailable.GetItemDataPtr( pnSelItems[nPos] );
		
			if( pINode
			&&  pINode != (IDMUSProdNode *)0xFFFFFFFF )
			{
				// Delete selected item from "Available" list
				m_lstbxAvailable.DeleteString( pnSelItems[nPos] );

				// Place selected item in "Embed" list
				int nThePos = m_lstbxEmbed.AddString( (LPCTSTR)pINode );
				m_lstbxEmbed.SetSel( nThePos, TRUE ); 
				m_lstbxEmbed.SetCaretIndex( nThePos, 0 ); 
			}
		}

		delete [] pnSelItems;
	}

	m_lstbxAvailable.SetRedraw( TRUE );
	m_lstbxEmbed.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnBtnEmbedRemove

void CDlgAddFiles::OnBtnEmbedRemove() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nNbrSelItems = m_lstbxEmbed.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	m_lstbxAvailable.SetRedraw( FALSE );
	m_lstbxEmbed.SetRedraw( FALSE );

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_lstbxEmbed.GetSelItems( nNbrSelItems, pnSelItems );

		m_lstbxAvailable.SetSel( -1, FALSE ); 
		m_lstbxEmbed.SetSel( -1, FALSE ); 

		for( int nPos = (nNbrSelItems - 1);  nPos >= 0 ;  nPos-- )
		{
			IDMUSProdNode* pINode = (IDMUSProdNode *)m_lstbxEmbed.GetItemDataPtr( pnSelItems[nPos] );
		
			if( pINode
			&&  pINode != (IDMUSProdNode *)0xFFFFFFFF )
			{
				// Delete selected item from "Embed" list
				m_lstbxEmbed.DeleteString( pnSelItems[nPos] );

				// Place selected item in "Available" list
				int nThePos = m_lstbxAvailable.AddString( (LPCTSTR)pINode );
				m_lstbxAvailable.SetSel( nThePos, TRUE ); 
				m_lstbxAvailable.SetCaretIndex( nThePos, 0 ); 
			}
		}

		delete [] pnSelItems;
	}

	m_lstbxAvailable.SetRedraw( TRUE );
	m_lstbxEmbed.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnBtnReferenceAdd

void CDlgAddFiles::OnBtnReferenceAdd() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nNbrSelItems = m_lstbxAvailable.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	m_lstbxAvailable.SetRedraw( FALSE );
	m_lstbxReference.SetRedraw( FALSE );

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_lstbxAvailable.GetSelItems( nNbrSelItems, pnSelItems );

		m_lstbxAvailable.SetSel( -1, FALSE ); 
		m_lstbxReference.SetSel( -1, FALSE ); 

		for( int nPos = (nNbrSelItems - 1);  nPos >= 0 ;  nPos-- )
		{
			IDMUSProdNode* pINode = (IDMUSProdNode *)m_lstbxAvailable.GetItemDataPtr( pnSelItems[nPos] );
		
			if( pINode
			&&  pINode != (IDMUSProdNode *)0xFFFFFFFF )
			{
				// Delete selected item from "Available" list
				m_lstbxAvailable.DeleteString( pnSelItems[nPos] );

				// Place selected item in "Reference" list
				int nThePos = m_lstbxReference.AddString( (LPCTSTR)pINode );
				m_lstbxReference.SetSel( nThePos, TRUE ); 
				m_lstbxReference.SetCaretIndex( nThePos, 0 ); 
			}
		}

		delete [] pnSelItems;
	}

	m_lstbxAvailable.SetRedraw( TRUE );
	m_lstbxReference.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnBtnReferenceRemove

void CDlgAddFiles::OnBtnReferenceRemove() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nNbrSelItems = m_lstbxReference.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	m_lstbxAvailable.SetRedraw( FALSE );
	m_lstbxReference.SetRedraw( FALSE );

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_lstbxReference.GetSelItems( nNbrSelItems, pnSelItems );

		m_lstbxAvailable.SetSel( -1, FALSE ); 
		m_lstbxReference.SetSel( -1, FALSE ); 

		for( int nPos = (nNbrSelItems - 1);  nPos >= 0 ;  nPos-- )
		{
			IDMUSProdNode* pINode = (IDMUSProdNode *)m_lstbxReference.GetItemDataPtr( pnSelItems[nPos] );
		
			if( pINode
			&&  pINode != (IDMUSProdNode *)0xFFFFFFFF )
			{
				// Delete selected item from "Reference" list
				m_lstbxReference.DeleteString( pnSelItems[nPos] );

				// Place selected item in "Available" list
				int nThePos = m_lstbxAvailable.AddString( (LPCTSTR)pINode );
				m_lstbxAvailable.SetSel( nThePos, TRUE ); 
				m_lstbxAvailable.SetCaretIndex( nThePos, 0 ); 
			}
		}

		delete [] pnSelItems;
	}

	m_lstbxAvailable.SetRedraw( TRUE );
	m_lstbxReference.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnBtnReset

void CDlgAddFiles::OnBtnReset() 
{
	// Reset content of list boxes
	FillAvailableList();
	FillEmbedList();
	FillReferenceList();
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnDblClkListAvailable

void CDlgAddFiles::OnDblClkListAvailable() 
{
	OnBtnEmbedAdd();
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnDblClkListEmbed

void CDlgAddFiles::OnDblClkListEmbed() 
{
	OnBtnEmbedRemove();
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnDblClkListReference

void CDlgAddFiles::OnDblClkListReference() 
{
	OnBtnReferenceRemove();
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddFiles::OnOK

void CDlgAddFiles::OnOK() 
{
	IDMUSProdNode* pINode;
	int nPos;

	// Recreate "Available" list
	m_lstAvailable.RemoveAll();
	int nNbrItems = m_lstbxAvailable.GetCount();
	for( nPos = 0 ;  nPos < nNbrItems ;  nPos++ )
	{
		pINode = (IDMUSProdNode *)m_lstbxAvailable.GetItemDataPtr( nPos );
	
		if( pINode
		&&  pINode != (IDMUSProdNode *)0xFFFFFFFF )
		{
			// Place item in "Available" list
			m_lstAvailable.AddTail( pINode );
		}
	}
	
	// Recreate "Embedded" list
	m_lstEmbedded.RemoveAll();
	nNbrItems = m_lstbxEmbed.GetCount();
	for( nPos = 0 ;  nPos < nNbrItems ;  nPos++ )
	{
		pINode = (IDMUSProdNode *)m_lstbxEmbed.GetItemDataPtr( nPos );
	
		if( pINode
		&&  pINode != (IDMUSProdNode *)0xFFFFFFFF )
		{
			// Place item in "Embedded" list
			m_lstEmbedded.AddTail( pINode );
		}
	}
	
	// Recreate "Referenced" list
	m_lstReferenced.RemoveAll();
	nNbrItems = m_lstbxReference.GetCount();
	for( nPos = 0 ;  nPos < nNbrItems ;  nPos++ )
	{
		pINode = (IDMUSProdNode *)m_lstbxReference.GetItemDataPtr( nPos );
	
		if( pINode
		&&  pINode != (IDMUSProdNode *)0xFFFFFFFF )
		{
			// Place item in "Referenced" list
			m_lstReferenced.AddTail( pINode );
		}
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\Folder.h ===
#ifndef __FOLDER_H__
#define __FOLDER_H__

// Folder.h : header file
//

#include <afxtempl.h>
#include "Object.h"


class CDirectMusicContainer;

class CFolder : public IDMUSProdNode
{
friend class CDirectMusicContainer;
friend class CTabContainer;

public:
    CFolder();
	~CFolder();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// Additional methods
private:
	HRESULT OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData );
    HRESULT FindDocRootFromName( LPCTSTR pszName, IUnknown** ppIDocRootNode );
    HRESULT FindDocRootFromScriptAlias( LPCTSTR pszAlias, IUnknown** ppIDocRootNode );
	HRESULT IsDocRootInFolder( IDMUSProdNode* pIDocRootNode );
	HRESULT IsFileGUIDInFolder( GUID guidFile );
	CContainerObject* GetObjectFromDocRoot( IDMUSProdNode* pIDocRootNode );
	void ReplaceContent( CTypedPtrList<CPtrList, IDMUSProdNode*>& list );

private:
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;

	CTypedPtrList<CPtrList, CContainerObject*> m_lstObjects;
	CDirectMusicContainer*	m_pContainer;
	CString					m_strName;
	GUID					m_guidTypeNode;
};

#endif // __FOLDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\Object.h ===
#ifndef __CONTAINER_OBJECT_H_
#define __CONTAINER_OBJECT_H_

#include "RiffStrm.h"


#define DMUS_FOURCC_CONTAINED_OBJECT_UI_CHUNK			mmioFOURCC('c','o','b','u')

#define COBU_REFERENCE	0x0001


#pragma pack(2)

typedef struct ioObjectUI
{
	WORD	wFlags;			// COBU_ flags
} ioObjectUI;

typedef struct FileListInfo
{
	FileListInfo()
	{
		pIProject = NULL;
		memset( &guidFile, 0, sizeof(GUID) );
	}

	IDMUSProdProject*	pIProject;
	CString				strProjectName;
	CString				strName;
	CString				strDescriptor;
	GUID				guidFile;
} FileListInfo;

typedef struct FileRef
{
	FileRef()
	{
		pIDocRootNode = NULL;
		pIRefNode = NULL;
		fRemoveNotify = FALSE;
	}

	IDMUSProdNode*		pIDocRootNode;	// Pointer to referenced file's DocRoot node
	IDMUSProdNode*		pIRefNode;		// Pointer to referenced file's Reference node
	CString				strScriptAlias;	// Used by scripting
	BOOL				fRemoveNotify;
	FileListInfo		li;
} FileRef;

#pragma pack()


//////////////////////////////////////////////////////////////////////
//  CObjectPropPageManager

class CObjectPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabObjectDesign;
friend class CTabObjectRuntime;
friend class CTabObjectFlags;

public:
	CObjectPropPageManager();
	virtual ~CObjectPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabObjectDesign*			m_pTabDesign;
	CTabObjectRuntime*			m_pTabRuntime;
	CTabObjectFlags*			m_pTabFlags;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CContainerObject

class CContainerObject : public IDMUSProdNode, public IDMUSProdPropPageObject
{
friend class CDirectMusicContainer;
friend class CObjectToSave;
friend class CObjectPropPageManager;
friend class CTabContainer;
friend class CTabObjectDesign;
friend class CTabObjectRuntime;
friend class CTabObjectFlags;
friend class CFolder;

public:
	CContainerObject( CDirectMusicContainer* pContainer );
	virtual ~CContainerObject();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// Additional methods
	HRESULT Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, BOOL* pfReference );
    HRESULT Save( IDMUSProdRIFFStream* pIRiffStream, BOOL fSaveReference );
	HRESULT SetFileReference( IDMUSProdNode* pINewDocRootNode );
	HRESULT SetFileReference( GUID guidFile );
	HRESULT SyncListInfo();
	void ClearListInfo();
	void GetScriptAlias( CString& strScriptAlias );
	void SetScriptAlias( const LPCTSTR pszScriptAlias );
	HRESULT ResolveBestGuessWhenLoadFinished( IDMUSProdDocType* pIDocType, BSTR bstrObjectName, IDMUSProdNode* pITargetDirectoryNode );

private:
	HRESULT SaveDMRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode, DMUS_OBJECTDESC* pdmusObjectDesc, WhichLoader whichLoader );
	HRESULT SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode );
	HRESULT SaveObjectPendingLoad( IDMUSProdRIFFStream* pIRiffStream, BOOL fSaveReference );
	void SetModifiedFlag();

private:
    DWORD					m_dwRef;
	CDirectMusicContainer*	m_pContainer;
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;

	FileRef					m_FileRef;		// Info pertaining to referenced file
	DWORD					m_dwFlagsDM;	// DirectMusic DMUS_CONTAINED_OBJF flags
};

#endif // __CONTAINER_OBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ContainerDesignerDLL.rc
//
#define IDS_CONTAINER                   1
#define IDD_ABOUTBOX_CONTAINER          1
#define IDB_CONTAINER                   1
#define IDI_ABOUTDLL                    1
#define IDS_CONTAINER_PPG               2
#define IDD_TAB_OBJECT_DESIGN           153
#define IDD_TAB_OBJECT_RUNTIME          154
#define IDS_CONTAINER_PPG_CAPTION       200
#define IDD_PROPPAGE_CONTAINER          200
#define IDI_CONTAINERREF_SEL            201
#define IDS_CONTAINER_COMPONENT_NAME    201
#define IDC_CACHE                       201
#define IDS_HELP_FILE_EXT               202
#define IDC_DUPE_PROMPT                 202
#define IDI_CONTAINERREF                203
#define IDS_ERR_INVALIDARG              203
#define IDC_USE_EXISTING                203
#define IDR_CONTAINER_DOCTYPE           204
#define IDC_USE_EMBEDDED                204
#define IDC_BTN_EMBED_ADD               204
#define IDS_ERR_REGISTER_CF             205
#define IDM_CONTAINER_NODE_RMENU        205
#define IDI_CONTAINER_DOCTYPE_SEL       205
#define IDC_KEEP_BOTH                   205
#define IDC_BTN_REFERENCE_ADD           205
#define IDS_ERR_ADD_CLIPFORMAT          206
#define IDI_FOLDER_SEL                  206
#define IDS_ERR_ADD_IMAGELIST           207
#define IDI_FOLDER                      207
#define IDS_ERR_MEMORY                  208
#define IDD_DUPLICATE_FILE              208
#define IDS_ERR_ADD_DOCTYPE             209
#define IDS_ERR_MISSING_CONDUCTOR       210
#define IDS_CONTAINER_TEXT              211
#define IDS_CONTAINER_VERSION_TEXT      212
#define IDS_NO_CONTAINER                213
#define IDS_UNDO_CONTAINER_NAME         214
#define IDS_UNDO_CONTAINER_GUID         215
#define IDS_UNDO_OBJECT_KEEP            216
#define IDS_UNDO                        217
#define IDS_UNDO_ACCEL                  218
#define IDS_REDO                        219
#define IDS_REDO_ACCEL                  220
#define IDS_UNDO_CONTAINER_AUTHOR       222
#define IDC_FILE_VERSION                222
#define IDS_UNDO_CONTAINER_COPYRIGHT    223
#define IDS_UNDO_CONTAINER_SUBJECT      224
#define IDS_UNDO_CONTAINER_VERSION      225
#define IDC_AUTHOR                      225
#define IDC_COPYRIGHT                   226
#define IDS_UNDO_CONTAINER_INFO         226
#define IDC_VERSION_1                   227
#define IDM_FOLDER_RMENU                227
#define IDS_EMBED_FOLDER_NAME           227
#define IDC_VERSION_2                   228
#define IDS_REF_FOLDER_NAME             228
#define IDC_VERSION_3                   229
#define IDS_EMPTY_TEXT                  229
#define IDC_VERSION_4                   230
#define IDD_TAB_CONTAINER               230
#define IDS_CONTAINER_OBJECT_TEXT       230
#define IDC_SUBJECT                     231
#define IDC_NAME                        231
#define IDS_ERR_REG_OBJECT              231
#define IDS_FILE_OPEN_OBJECT            232
#define IDS_UNKNOWN                     233
#define IDS_NOT_SAVED                   234
#define IDS_SIZE_BYTES                  235
#define IDS_SIZE_KB                     236
#define IDS_DUPE_FILE_PROMPT1           237
#define IDS_DUPE_FILE_PROMPT2           238
#define IDS_DEFAULT_SCRIPT_ALIAS        239
#define IDS_DUPE_OBJECT_ALIAS           240
#define IDS_UNDO_OBJECT_ALIAS           241
#define IDM_CONTAINERREF_NODE_RMENU     242
#define IDS_INVALID_OBJECT_ALIAS        242
#define IDM_OBJECT_NODE_RMENU           243
#define IDS_DUPE_FILE_PROMPT3           243
#define IDD_DLG_GUID                    244
#define IDM_SCRIPT_OBJECT_NODE_RMENU    244
#define IDS_DUPE_FILE_PROMPT4           244
#define IDM_SCRIPT_CONTAINER_NODE_RMENU 245
#define IDS_DUPE_FILE_PROMPT5           245
#define IDD_TAB_INFO                    246
#define IDS_DELETE_NODE_PROMPT          246
#define IDD_TAB_OBJECT_FLAGS            247
#define IDS_DELETE_ALIAS_PROMPT         247
#define IDC_USE_EXISTING_ALL_FILES      248
#define IDS_DUPE_FILE_PROMPT6           248
#define IDC_USE_EMBEDDED_ALL_FILES      249
#define IDS_ADD_REMOVE_FILES_TITLE      249
#define IDC_KEEP_BOTH_ALL_FILES         250
#define IDC_OK_ALL                      251
#define IDC_EDIT_GUID                   305
#define IDC_NEW_GUID                    306
#define IDD_DLG_ADD_FILES               309
#define IDI_FOLDER_GRAY                 310
#define IDI_FOLDER_GRAY_SEL             311
#define IDC_BUTTON_CONTENTS             500
#define IDC_RADIO_SORT_NAME             501
#define IDC_RADIO_SORT_TYPE             502
#define IDC_REFERENCE_PROMPT2           503
#define IDC_REFERENCE_PROMPT1           504
#define IDC_RADIO_SORT_SIZE             505
#define IDC_LIST_AVAILABLE              523
#define IDC_BTN_EMBED_REMOVE            527
#define IDC_BTN_RESET                   528
#define IDC_LIST_EMBED                  529
#define IDC_LIST_REFERENCE              530
#define IDC_BTN_REFERENCE_REMOVE        531
#define IDC_DESIGN_MODIFIED             1015
#define IDC_DESIGN_FILENAME             1016
#define IDC_INFO                        1017
#define IDC_DESIGN_CREATE               1017
#define IDC_DESIGN_SIZE                 1019
#define IDC_RUNTIME_FILE                1043
#define IDC_RUNTIME_CREATE              1044
#define IDC_RUNTIME_MODIFIED            1045
#define IDC_RUNTIME_SIZE                1046
#define IDM_RENAME                      1047
#define IDM_OBJECT_ALIAS                1048
#define IDM_PROPERTIES                  32768
#define IDM_LOCATE                      32769
#define IDM_DELETE                      32770
#define IDM_ADD_FILES                   32771
#define ID_EDIT_DELETE                  32777
#define ID_EDIT_INSERT                  32796
#define IDM_PASTE                       32810
#define IDM_HELP_FINDER                 32815

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        312
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         505
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\StdAfx.h ===
#if !defined(AFX_STDAFX_H__778A0B93_6F81_11D3_B45F_00105A2796DE__INCLUDED_)
#define AFX_STDAFX_H__778A0B93_6F81_11D3_B45F_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Comon Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__778A0B93_6F81_11D3_B45F_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabInfo.cpp ===
// TabInfo.cpp : implementation file
//

#include "stdafx.h"
#include "TabInfo.h"
#include "ContainerDesignerDll.h"
#include "Container.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabInfo property page

CTabInfo::CTabInfo( CContainerPropPageManager* pContainerPropPageManager ) : CPropertyPage(CTabInfo::IDD)
{
	//{{AFX_DATA_INIT(CTabInfo)
	//}}AFX_DATA_INIT
	
	ASSERT( pContainerPropPageManager != NULL );

	m_pContainer = NULL;
	m_pPageManager = pContainerPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabInfo::~CTabInfo()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::SetContainer

void CTabInfo::SetContainer( CDirectMusicContainer* pContainer )
{
	m_pContainer = pContainer;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::SetModifiedFlag

void CTabInfo::SetModifiedFlag( void ) 
{
	ASSERT( m_pContainer != NULL );

	m_pContainer->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::EnableControls

void CTabInfo::EnableControls( BOOL fEnable ) 
{
	m_editAuthor.EnableWindow( fEnable );
	m_editCopyright.EnableWindow( fEnable );
	m_editSubject.EnableWindow( fEnable );
	m_editInfo.EnableWindow( fEnable );
	m_editVersion_1.EnableWindow( fEnable );
	m_editVersion_2.EnableWindow( fEnable );
	m_editVersion_3.EnableWindow( fEnable );
	m_editVersion_4.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::UpdateControls

void CTabInfo::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editVersion_1.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editVersion_1.LimitText( 4 );
	m_editVersion_2.LimitText( 4 );
	m_editVersion_3.LimitText( 4 );
	m_editVersion_4.LimitText( 4 );

	if( m_pContainer )
	{
		CString strText;

		EnableControls( TRUE );

		m_editAuthor.SetWindowText( m_pContainer->m_strAuthor );
		m_editCopyright.SetWindowText( m_pContainer->m_strCopyright );
		m_editSubject.SetWindowText( m_pContainer->m_strSubject );
		m_editInfo.SetWindowText( m_pContainer->m_strInfo );
		
		strText.Format( "%u", ((m_pContainer->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
		m_editVersion_1.SetWindowText( strText );
		
		strText.Format( "%u", (m_pContainer->m_vVersion.dwVersionMS & 0x0000FFFF) );
		m_editVersion_2.SetWindowText( strText );
		
		strText.Format( "%u", ((m_pContainer->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
		m_editVersion_3.SetWindowText( strText );
		
		strText.Format( "%u", (m_pContainer->m_vVersion.dwVersionLS & 0x0000FFFF) );
		m_editVersion_4.SetWindowText( strText );
	}
	else
	{
		m_editAuthor.SetWindowText( _T("") );
		m_editCopyright.SetWindowText( _T("") );
		m_editSubject.SetWindowText( _T(""));
		m_editInfo.SetWindowText( _T(""));
		m_editVersion_1.SetWindowText( _T("") );
		m_editVersion_2.SetWindowText( _T("") );
		m_editVersion_3.SetWindowText( _T("") );
		m_editVersion_4.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CTabInfo::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabInfo)
	DDX_Control(pDX, IDC_VERSION_4, m_editVersion_4);
	DDX_Control(pDX, IDC_VERSION_3, m_editVersion_3);
	DDX_Control(pDX, IDC_VERSION_2, m_editVersion_2);
	DDX_Control(pDX, IDC_VERSION_1, m_editVersion_1);
	DDX_Control(pDX, IDC_SUBJECT, m_editSubject);
	DDX_Control(pDX, IDC_COPYRIGHT, m_editCopyright);
	DDX_Control(pDX, IDC_AUTHOR, m_editAuthor);
	DDX_Control(pDX, IDC_INFO, m_editInfo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabInfo, CPropertyPage)
	//{{AFX_MSG_MAP(CTabInfo)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_INFO, OnKillFocusInfo)
	ON_EN_KILLFOCUS(IDC_AUTHOR, OnKillFocusAuthor)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillFocusCopyright)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillFocusSubject)
	ON_EN_KILLFOCUS(IDC_VERSION_1, OnKillFocusVersion_1)
	ON_EN_KILLFOCUS(IDC_VERSION_2, OnKillFocusVersion_2)
	ON_EN_KILLFOCUS(IDC_VERSION_3, OnKillFocusVersion_3)
	ON_EN_KILLFOCUS(IDC_VERSION_4, OnKillFocusVersion_4)
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabInfo message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnSetActive

BOOL CTabInfo::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CContainerPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnCreate

int CTabInfo::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnDestroy

void CTabInfo::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusInfo

void CTabInfo::OnKillFocusInfo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer )
	{
		CString strInfo;

		m_editInfo.GetWindowText( strInfo );

		// Strip leading and trailing spaces
		strInfo.TrimRight();
		strInfo.TrimLeft();

		if( strInfo.Compare( m_pContainer->m_strInfo ) != 0 )
		{
			m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_CONTAINER_INFO );
			m_pContainer->m_strInfo = strInfo;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusAuthor

void CTabInfo::OnKillFocusAuthor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer )
	{
		CString strAuthor;

		m_editAuthor.GetWindowText( strAuthor );

		// Strip leading and trailing spaces
		strAuthor.TrimRight();
		strAuthor.TrimLeft();

		if( strAuthor.Compare( m_pContainer->m_strAuthor ) != 0 )
		{
			m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_CONTAINER_AUTHOR );
			m_pContainer->m_strAuthor = strAuthor;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusCopyright

void CTabInfo::OnKillFocusCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer )
	{
		CString strCopyright;

		m_editCopyright.GetWindowText( strCopyright );

		// Strip leading and trailing spaces
		strCopyright.TrimRight();
		strCopyright.TrimLeft();

		if( strCopyright.Compare( m_pContainer->m_strCopyright ) != 0 )
		{
			m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_CONTAINER_COPYRIGHT );
			m_pContainer->m_strCopyright = strCopyright;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusSubject

void CTabInfo::OnKillFocusSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer )
	{
		CString strSubject;

		m_editSubject.GetWindowText( strSubject );

		// Strip leading and trailing spaces
		strSubject.TrimRight();
		strSubject.TrimLeft();

		if( strSubject.Compare( m_pContainer->m_strSubject ) != 0 )
		{
			m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_CONTAINER_SUBJECT );
			m_pContainer->m_strSubject = strSubject;
			SetModifiedFlag();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_1

void CTabInfo::OnKillFocusVersion_1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer )
	{
		CString strVersion_1;
		CString strContainerVersion_1;

		m_editVersion_1.GetWindowText( strVersion_1 );

		// Strip leading and trailing spaces
		strVersion_1.TrimRight();
		strVersion_1.TrimLeft();

		if( strVersion_1.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pContainer->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			m_editVersion_1.SetWindowText( strText );
		}
		else
		{
			strContainerVersion_1.Format( "%u", ((m_pContainer->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			
			if( strVersion_1.Compare( strContainerVersion_1 ) != 0 )
			{
				DWORD dwVersion_1 = _ttoi( strVersion_1 );
				dwVersion_1 = (dwVersion_1 & 0x0000FFFF) << 16;

				m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_CONTAINER_VERSION );
				m_pContainer->m_vVersion.dwVersionMS &= 0x0000FFFF;
				m_pContainer->m_vVersion.dwVersionMS |= dwVersion_1;
				SetModifiedFlag();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_2

void CTabInfo::OnKillFocusVersion_2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer )
	{
		CString strVersion_2;
		CString strContainerVersion_2;

		m_editVersion_2.GetWindowText( strVersion_2 );

		// Strip leading and trailing spaces
		strVersion_2.TrimRight();
		strVersion_2.TrimLeft();

		if( strVersion_2.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pContainer->m_vVersion.dwVersionMS & 0x0000FFFF) );
			m_editVersion_2.SetWindowText( strText );
		}
		else
		{
			strContainerVersion_2.Format( "%u", (m_pContainer->m_vVersion.dwVersionMS & 0x0000FFFF) );
			
			if( strVersion_2.Compare( strContainerVersion_2 ) != 0 )
			{
				DWORD dwVersion_2 = _ttoi( strVersion_2 );
				dwVersion_2 &= 0x0000FFFF;

				m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_CONTAINER_VERSION );
				m_pContainer->m_vVersion.dwVersionMS &= 0xFFFF0000;
				m_pContainer->m_vVersion.dwVersionMS |= dwVersion_2;
				SetModifiedFlag();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_3

void CTabInfo::OnKillFocusVersion_3() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer )
	{
		CString strVersion_3;
		CString strContainerVersion_3;

		m_editVersion_3.GetWindowText( strVersion_3 );

		// Strip leading and trailing spaces
		strVersion_3.TrimRight();
		strVersion_3.TrimLeft();

		if( strVersion_3.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pContainer->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			m_editVersion_3.SetWindowText( strText );
		}
		else
		{
			strContainerVersion_3.Format( "%u", ((m_pContainer->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			
			if( strVersion_3.Compare( strContainerVersion_3 ) != 0 )
			{
				DWORD dwVersion_3 = _ttoi( strVersion_3 );
				dwVersion_3 = (dwVersion_3 & 0x0000FFFF) << 16;

				m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_CONTAINER_VERSION );
				m_pContainer->m_vVersion.dwVersionLS &= 0x0000FFFF;
				m_pContainer->m_vVersion.dwVersionLS |= dwVersion_3;
				SetModifiedFlag();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_4

void CTabInfo::OnKillFocusVersion_4() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer )
	{
		CString strVersion_4;
		CString strContainerVersion_4;

		m_editVersion_4.GetWindowText( strVersion_4 );

		// Strip leading and trailing spaces
		strVersion_4.TrimRight();
		strVersion_4.TrimLeft();

		if( strVersion_4.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pContainer->m_vVersion.dwVersionLS & 0x0000FFFF) );
			m_editVersion_4.SetWindowText( strText );
		}
		else
		{
			strContainerVersion_4.Format( "%u", (m_pContainer->m_vVersion.dwVersionLS & 0x0000FFFF) );
			
			if( strVersion_4.Compare( strContainerVersion_4 ) != 0 )
			{
				DWORD dwVersion_4 = _ttoi( strVersion_4 );
				dwVersion_4 &= 0x0000FFFF;

				m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_CONTAINER_VERSION );
				m_pContainer->m_vVersion.dwVersionLS &= 0xFFFF0000;
				m_pContainer->m_vVersion.dwVersionLS |= dwVersion_4;
				SetModifiedFlag();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnEditGUID

void CTabInfo::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer )
	{
		CGuidDlg dlg;

		memcpy( &dlg.m_guid, &m_pContainer->m_guidContainer, sizeof(GUID) );

		if( dlg.DoModal() == IDOK )
		{
			m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_CONTAINER_GUID );
			memcpy( &m_pContainer->m_guidContainer, &dlg.m_guid, sizeof(GUID) );
			SetModifiedFlag();

			// Notify connected nodes that Container GUID has changed
			theApp.m_pContainerComponent->m_pIFramework8->NotifyNodes( m_pContainer, DOCROOT_GuidChange, NULL );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabContainer.cpp ===
// TabContainer.cpp : implementation file
//

#include "stdafx.h"
#include "TabContainer.h"
#include "ContainerDesignerDll.h"
#include "Container.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabContainer property page

CTabContainer::CTabContainer( CContainerPropPageManager* pContainerPropPageManager ) : CPropertyPage(CTabContainer::IDD)
{
	//{{AFX_DATA_INIT(CTabContainer)
	//}}AFX_DATA_INIT
	
	ASSERT( pContainerPropPageManager != NULL );

	m_pContainer = NULL;
	m_pPageManager = pContainerPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabContainer::~CTabContainer()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::SetContainer

void CTabContainer::SetContainer( CDirectMusicContainer* pContainer )
{
	m_pContainer = pContainer;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::SetModifiedFlag

void CTabContainer::SetModifiedFlag( void ) 
{
	ASSERT( m_pContainer != NULL );

	m_pContainer->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::EnableControls

void CTabContainer::EnableControls( BOOL fEnable ) 
{
	if( m_pContainer
	&&  m_pContainer->IsInScript() )
	{
		m_editName.EnableWindow( FALSE );
	}
	else
	{
		m_editName.EnableWindow( fEnable );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::UpdateControls

void CTabContainer::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editName.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );

	if( m_pContainer )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pContainer->m_strName );
	}
	else
	{
		m_editName.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CTabContainer::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabContainer)
	DDX_Control(pDX, IDC_BUTTON_CONTENTS, m_btnContents);
	DDX_Control(pDX, IDC_NAME, m_editName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabContainer, CPropertyPage)
	//{{AFX_MSG_MAP(CTabContainer)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	ON_BN_CLICKED(IDC_BUTTON_CONTENTS, OnButtonContents)
	ON_BN_DOUBLECLICKED(IDC_BUTTON_CONTENTS, OnDoubleClickedButtonContents)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabContainer message handlers


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::OnInitDialog

BOOL CTabContainer::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::OnSetActive

BOOL CTabContainer::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CContainerPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::OnCreate

int CTabContainer::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::OnDestroy

void CTabContainer::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::OnKillFocusName

void CTabContainer::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	if( m_pContainer )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pContainer->m_strName );
		}
		else
		{
			if( strName.Compare( m_pContainer->m_strName ) != 0 )
			{
				BSTR bstrName = strName.AllocSysString();
				m_pContainer->SetNodeName( bstrName );
				theApp.m_pContainerComponent->m_pIFramework8->RefreshNode( m_pContainer );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::OnButtonContents

void CTabContainer::OnButtonContents( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer == NULL )
	{
		return;
	}

	m_pContainer->OnAddRemoveFiles();
}


/////////////////////////////////////////////////////////////////////////////
// CTabContainer::OnDoubleClickedButtonContents

void CTabContainer::OnDoubleClickedButtonContents( void ) 
{
	OnButtonContents();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabContainer.h ===
#if !defined(AFX_TABCONTAINER_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABCONTAINER_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabContainer.h : header file
//

#include "resource.h"

class CContainerPropPageManager;
class CDirectMusicContainer;

/////////////////////////////////////////////////////////////////////////////
// CTabContainer dialog

class CTabContainer : public CPropertyPage
{
// Construction
public:
	CTabContainer( CContainerPropPageManager* pContainerPropPageManager );
	virtual ~CTabContainer();
	void SetContainer( CDirectMusicContainer* pContainer );

// Dialog Data
	//{{AFX_DATA(CTabContainer)
	enum { IDD = IDD_TAB_CONTAINER };
	CButton	m_btnContents;
	CEdit	m_editName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabContainer)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicContainer*		m_pContainer;
	CContainerPropPageManager*	m_pPageManager;
	BOOL						m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabContainer)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonContents();
	afx_msg void OnDoubleClickedButtonContents();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABCONTAINER_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabInfo.h ===
#if !defined(AFX_TABINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabInfo.h : header file
//

#include "resource.h"

class CContainerPropPageManager;
class CDirectMusicContainer;

/////////////////////////////////////////////////////////////////////////////
// CTabInfo dialog

class CTabInfo : public CPropertyPage
{
// Construction
public:
	CTabInfo( CContainerPropPageManager* pContainerPropPageManager );
	virtual ~CTabInfo();
	void SetContainer( CDirectMusicContainer* pContainer );

// Dialog Data
	//{{AFX_DATA(CTabInfo)
	enum { IDD = IDD_TAB_INFO };
	CEdit	m_editVersion_4;
	CEdit	m_editVersion_3;
	CEdit	m_editVersion_2;
	CEdit	m_editVersion_1;
	CEdit	m_editSubject;
	CEdit	m_editCopyright;
	CEdit	m_editAuthor;
	CEdit	m_editInfo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabInfo)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicContainer*		m_pContainer;
	CContainerPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabInfo)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusInfo();
	afx_msg void OnKillFocusAuthor();
	afx_msg void OnKillFocusCopyright();
	afx_msg void OnKillFocusSubject();
	afx_msg void OnKillFocusVersion_1();
	afx_msg void OnKillFocusVersion_2();
	afx_msg void OnKillFocusVersion_3();
	afx_msg void OnKillFocusVersion_4();
	afx_msg void OnEditGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabObjectDesign.h ===
#if !defined(AFX_TABOBJECTDESIGN_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABOBJECTDESIGN_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabObjectDesign.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTabObjectDesign dialog

class CTabObjectDesign : public CPropertyPage
{
// Construction
public:
	CTabObjectDesign( CObjectPropPageManager* pPageManager );
	~CTabObjectDesign();
	void SetContainerObject( CContainerObject* pContainerObject );

// Dialog Data
	//{{AFX_DATA(CTabObjectDesign)
	enum { IDD = IDD_TAB_OBJECT_DESIGN };
	CEdit	m_editDesignFileName;
	CStatic	m_staticDesignCreate;
	CStatic	m_staticDesignSize;
	CStatic	m_staticDesignModified;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabObjectDesign)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CContainerObject*		m_pContainerObject;
	CObjectPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabObjectDesign)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABOBJECTDESIGN_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabObjectDesign.cpp ===
// TabObjectDesign.cpp : implementation file
//

#include "stdafx.h"
#include "ContainerDesignerDLL.h"

#include "Container.h"
#include "Object.h"
#include "TabObjectDesign.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabObjectDesign property page

CTabObjectDesign::CTabObjectDesign( CObjectPropPageManager* pPageManager ) : CPropertyPage(CTabObjectDesign::IDD)
{
	//{{AFX_DATA_INIT(CTabObjectDesign)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pContainerObject = NULL;
	m_pPageManager = pPageManager;
	m_fNeedToDetach = FALSE;
}

CTabObjectDesign::~CTabObjectDesign()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectDesign::SetContainerObject

void CTabObjectDesign::SetContainerObject( CContainerObject* pContainerObject )
{
	m_pContainerObject = pContainerObject;
}


void CTabObjectDesign::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabObjectDesign)
	DDX_Control(pDX, IDC_DESIGN_FILENAME, m_editDesignFileName);
	DDX_Control(pDX, IDC_DESIGN_CREATE, m_staticDesignCreate);
	DDX_Control(pDX, IDC_DESIGN_SIZE, m_staticDesignSize);
	DDX_Control(pDX, IDC_DESIGN_MODIFIED, m_staticDesignModified);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectDesign::EnableControls

void CTabObjectDesign::EnableControls( BOOL fEnable ) 
{
	// May need this method at a later time
}


BEGIN_MESSAGE_MAP(CTabObjectDesign, CPropertyPage)
	//{{AFX_MSG_MAP(CTabObjectDesign)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabObjectDesign message handlers

BOOL CTabObjectDesign::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainerObject == NULL )
	{
		EnableControls( FALSE );
		return CPropertyPage::OnSetActive();
	}

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CObjectPropPageManager::sm_nActiveTab );

	EnableControls( TRUE );

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	BSTR bstrFileName;
	CString strFileName;
	CString strFileCreate;
	CString strFileModified;
	CString strFileSize;

	strFileName.LoadString( IDS_UNKNOWN );
	strFileCreate.LoadString( IDS_UNKNOWN );
	strFileModified.LoadString( IDS_UNKNOWN );
	strFileSize.LoadString( IDS_UNKNOWN );

	// Determine design file filename
	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->GetNodeFileName( m_pContainerObject->m_FileRef.pIDocRootNode, &bstrFileName ) ) )
	{
		CString strTheFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		if( strTheFileName.IsEmpty() == FALSE )
		{
			strFileName = strTheFileName;

			// Set design file modified date and size
			HANDLE hFile = ::CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 									 FILE_ATTRIBUTE_NORMAL, NULL );
			if( hFile != INVALID_HANDLE_VALUE )
			{
				FILETIME ftModified;
				FILETIME ftCreate;
				DWORD dwFileSize;

				if( ::GetFileTime(hFile, &ftCreate, NULL, &ftModified) )
				{
					CTime timeFile;
					
					timeFile = ftCreate;
					strFileCreate = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );

					timeFile = ftModified;
					strFileModified = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );
				}

				dwFileSize = GetFileSize( hFile, NULL );

				CString strSize;
				CString strBytes;
				strSize.Format( "%u", dwFileSize );

				int i, j;
				int nLength = strSize.GetLength();

				for( i=0, j=nLength;  i < nLength ; i++ )
				{
					strBytes += strSize[i];
					j--;
					if( (j > 0)
					&& !(j % 3) )
					{
						strBytes += ',';
					}
				}
				
				if( dwFileSize < 1024 )
				{
					AfxFormatString1( strFileSize, IDS_SIZE_BYTES, strBytes );
				}
				else
				{
					CString strKB;
					
					double dblKB = dwFileSize / 1024.0;
					strKB.Format( "%.2f", dblKB );

					AfxFormatString2( strFileSize, IDS_SIZE_KB, strKB, strBytes );
				}

				CloseHandle( hFile );
			}
		}
	}

	m_editDesignFileName.SetWindowText( strFileName );
	m_staticDesignCreate.SetWindowText( strFileCreate );
	m_staticDesignModified.SetWindowText( strFileModified );
	m_staticDesignSize.SetWindowText( strFileSize );

	AfxSetResourceHandle( hInstance );
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectDesign::OnDestroy

void CTabObjectDesign::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectDesign::OnCreate

int CTabObjectDesign::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabObjectRuntime.h ===
#if !defined(AFX_TABOBJECTRUNTIME_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABOBJECTRUNTIME_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabObjectRuntime.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTabObjectRuntime dialog

class CTabObjectRuntime : public CPropertyPage
{
// Construction
public:
	CTabObjectRuntime( CObjectPropPageManager* pPageManager );
	~CTabObjectRuntime();
	void SetContainerObject( CContainerObject* pContainerObject );

// Dialog Data
	//{{AFX_DATA(CTabObjectRuntime)
	enum { IDD = IDD_TAB_OBJECT_RUNTIME };
	CEdit	m_editRuntimeFile;
	CStatic	m_staticRuntimeCreate;
	CStatic	m_staticRuntimeSize;
	CStatic	m_staticRuntimeModified;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabObjectRuntime)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CContainerObject*		m_pContainerObject;
	CObjectPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabObjectRuntime)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABOBJECTRUNTIME_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\AboutDlg.cpp ===
// AboutDlg.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "dlsdesignerdll.h"
#include "AboutDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog


CAboutDlg::CAboutDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAboutDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAboutDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg message handlers

BOOL CAboutDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// Get version information
	TCHAR achJazzExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[MID_BUFFER];

	if( GetModuleFileName ( theApp.m_hInstance, achJazzExeName, FILENAME_MAX ) )
	{
		if( GetFileVersion( achJazzExeName, achFileVersion, MID_BUFFER ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_DLS_EDITOR_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


// ==============================================================
// ==============================================================
BOOL CAboutDlg::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabObjectFlags.cpp ===
// TabObjectFlags.cpp : implementation file
//

#include "stdafx.h"
#include "ContainerDesignerDLL.h"

#include "Container.h"
#include "Object.h"
#include "TabObjectFlags.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags property page

CTabObjectFlags::CTabObjectFlags( CObjectPropPageManager* pPageManager ) : CPropertyPage(CTabObjectFlags::IDD)
{
	//{{AFX_DATA_INIT(CTabObjectFlags)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pContainerObject = NULL;
	m_pPageManager = pPageManager;
	m_fNeedToDetach = FALSE;
}

CTabObjectFlags::~CTabObjectFlags()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags::SetContainerObject	

void CTabObjectFlags::SetContainerObject( CContainerObject* pContainerObject )
{
	m_pContainerObject = pContainerObject;
}


void CTabObjectFlags::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabObjectFlags)
	DDX_Control(pDX, IDC_CACHE, m_checkCache);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags::SetModifiedFlag

void CTabObjectFlags::SetModifiedFlag( void ) 
{
	ASSERT( m_pContainerObject != NULL );
	ASSERT( m_pContainerObject->m_pContainer != NULL );

	if( m_pContainerObject
	&&  m_pContainerObject->m_pContainer )
	{
		m_pContainerObject->m_pContainer->SetModified( TRUE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags::EnableControls

void CTabObjectFlags::EnableControls( BOOL fEnable ) 
{
	m_checkCache.EnableWindow( fEnable );
}


BEGIN_MESSAGE_MAP(CTabObjectFlags, CPropertyPage)
	//{{AFX_MSG_MAP(CTabObjectFlags)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_CACHE, OnCache)
	ON_BN_DOUBLECLICKED(IDC_CACHE, OnDoubleClickedCache)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags::OnSetActive

BOOL CTabObjectFlags::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainerObject == NULL )
	{
		EnableControls( FALSE );
		return CPropertyPage::OnSetActive();
	}

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CObjectPropPageManager::sm_nActiveTab );

	EnableControls( TRUE );

	// Cache check
	if( m_pContainerObject->m_dwFlagsDM & DMUS_CONTAINED_OBJF_KEEP )
	{
		m_checkCache.SetCheck( 1 );
	}
	else
	{
		m_checkCache.SetCheck( 0 );
	}
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags::OnDestroy

void CTabObjectFlags::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags::OnCreate

int CTabObjectFlags::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags::OnCache

void CTabObjectFlags::OnCache() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainerObject
	&&  m_pContainerObject->m_pContainer )
	{
		m_pContainerObject->m_pContainer->m_pUndoMgr->SaveState( m_pContainerObject->m_pContainer, theApp.m_hInstance, IDS_UNDO_OBJECT_KEEP );
					
		if( m_checkCache.GetCheck() )
		{
			m_pContainerObject->m_dwFlagsDM |= DMUS_CONTAINED_OBJF_KEEP;
		}
		else
		{
			m_pContainerObject->m_dwFlagsDM &= ~DMUS_CONTAINED_OBJF_KEEP;
		}

		SetModifiedFlag();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags::OnDoubleClickedCache

void CTabObjectFlags::OnDoubleClickedCache() 
{
	OnCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\Object.cpp ===
// Object.cpp : implementation file
//

#include "stdafx.h"
#include "ContainerDesignerDLL.h"

#include "Container.h"
#include "Object.h"
#include <mmreg.h>
#include "TabObjectDesign.h"
#include "TabObjectRuntime.h"
#include "TabObjectFlags.h"
#include <ScriptDesigner.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// {637FD240-8C9D-11d3-B473-00105A2796DE}
static const GUID GUID_ObjectPropPageManager = 
{ 0x637fd240, 0x8c9d, 0x11d3, { 0xb4, 0x73, 0x0, 0x10, 0x5a, 0x27, 0x96, 0xde } };

short CObjectPropPageManager::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CObjectPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CObjectPropPageManager::CObjectPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabDesign = NULL;
	m_pTabRuntime = NULL;
	m_pTabFlags = NULL;
}

CObjectPropPageManager::~CObjectPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabDesign )
	{
		delete m_pTabDesign;
	}

	if( m_pTabRuntime )
	{
		delete m_pTabRuntime;
	}

	if( m_pTabFlags )
	{
		delete m_pTabFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager::RemoveCurrentObject

void CObjectPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager IUnknown implementation

HRESULT CObjectPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CObjectPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CObjectPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CObjectPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_CONTAINER_TEXT );

	CContainerObject *pContainerObject;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pContainerObject))) )
	{
		CString strName;
		BSTR bstrName;

		strTitle += _T(": ");

		// Add name of Container
		if( pContainerObject->m_pContainer )
		{
			if( SUCCEEDED ( pContainerObject->m_pContainer->GetNodeName( &bstrName ) ) )
			{
				strName = bstrName;
				::SysFreeString( bstrName );
		
				strTitle += strName;
				strTitle += _T(" - ");
			}
		}

		// Add Name of Object
		if( SUCCEEDED ( pContainerObject->GetNodeName( &bstrName ) ) )
		{
			strName = bstrName;
			::SysFreeString( bstrName );
		
			strTitle += _T("'");
			strTitle += strName;
			strTitle += _T("' ");
		}

		// Add type of Object
		RegisteredObject* pRegisteredObject;
		pRegisteredObject = theApp.m_pContainerComponent->FindRegisteredObjectByDocRoot( pContainerObject->m_FileRef.pIDocRootNode );
		if( pRegisteredObject )
		{
			strTitle += pRegisteredObject->strObjectType;
		}
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CObjectPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Design tab
	m_pTabDesign = new CTabObjectDesign( this );
	if( m_pTabDesign )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabDesign->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Runtime tab
	m_pTabRuntime = new CTabObjectRuntime( this );
	if( m_pTabRuntime )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabRuntime->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Cache tab
	m_pTabFlags = new CTabObjectFlags( this );
	if( m_pTabFlags )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabFlags->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CObjectPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CObjectPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CObjectPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CObjectPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CObjectPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CObjectPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CContainerObject* pContainerObject;
	
	if( m_pIPropPageObject == NULL )
	{
		pContainerObject = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pContainerObject ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Container Object are processed in OnKillFocus
	// messages before setting the new Container Object
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabDesign->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new Container Object
	m_pTabDesign->SetContainerObject( pContainerObject);
	m_pTabRuntime->SetContainerObject( pContainerObject);
	m_pTabFlags->SetContainerObject( pContainerObject);

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CObjectPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CObjectPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_ObjectPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//	CContainerObject Constructor/Destructor

CContainerObject::CContainerObject( CDirectMusicContainer* pContainer )
{
	m_dwRef = 0;
	AddRef();

	ASSERT( pContainer != NULL );
	m_pContainer = pContainer;
//	m_pContainer->AddRef();			intentionally missing

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;

	SetFileReference( NULL );
	m_dwFlagsDM = 0;
}

CContainerObject::~CContainerObject( void )
{
	// Remove Container Objectfrom property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	SetFileReference( NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject::SetModifiedFlag

void CContainerObject::SetModifiedFlag( void ) 
{
	ASSERT( m_pContainer != NULL );

	m_pContainer->SetModified( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IUnknown implementation

HRESULT CContainerObject::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CContainerObject::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CContainerObject::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetNodeImageIndex

HRESULT CContainerObject::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_FileRef.pIRefNode == NULL )
	{
		// Will happen while waiting for FRAMEWORK_FileLoadFinished notification
		return E_UNEXPECTED;
	}

	return( m_FileRef.pIRefNode->GetNodeImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetFirstChild

HRESULT CContainerObject::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// ContainerObject node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetNextChild

HRESULT CContainerObject::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// ContainerObject node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetComponent

HRESULT CContainerObject::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );

	return theApp.m_pContainerComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetDocRootNode

HRESULT CContainerObject::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::SetDocRootNode

HRESULT CContainerObject::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetParentNode

HRESULT CContainerObject::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::SetParentNode

HRESULT CContainerObject::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetNodeId

HRESULT CContainerObject::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ContainerObjectNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetNodeName

HRESULT CContainerObject::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	if( m_pContainer->IsInScript() )
	{
		ASSERT( m_FileRef.strScriptAlias.IsEmpty() == FALSE );
		*pbstrName = m_FileRef.strScriptAlias.AllocSysString();
		hr = S_OK;
	}
	else
	{
		if( m_FileRef.pIRefNode == NULL )
		{
			TCHAR achNoObject[MID_BUFFER];

			::LoadString( theApp.m_hInstance, IDS_EMPTY_TEXT, achNoObject, MID_BUFFER );
			CString strNoObject = achNoObject;
			*pbstrName = strNoObject.AllocSysString();
			hr = S_OK;
		}
		else
		{
			hr = m_FileRef.pIRefNode->GetNodeName( pbstrName );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetNodeNameMaxLength

HRESULT CContainerObject::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainer->IsInScript() )
	{
		// Can rename an Object if it belongs to a Container in a Script
		// The Object name is used as the "Alias" for scripting
		*pnMaxLength = DMUS_MAX_NAME;	
	}
	else
	{
		// Can't rename an Object in a Contaner
		*pnMaxLength = -1;				
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::ValidateNodeName

HRESULT CContainerObject::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strAlias = bstrName;
	::SysFreeString( bstrName );

	if( m_pContainer->IsInScript() == FALSE )
	{
		// Can't rename an Object in a Container
		ASSERT( 0 );	// This should not happen
		return S_FALSE;
	}

	HRESULT hr = S_OK;

	// Store original alias
	CString strOrigAlias = m_FileRef.strScriptAlias;

	m_FileRef.strScriptAlias = strAlias;

	// Make sure new alias starts with a letter
	if( hr == S_OK )
	{
		if( !(_istalpha( strAlias[0] )) )
		{
			CString strMsg;

			AfxFormatString1( strMsg, IDS_INVALID_OBJECT_ALIAS, strAlias );
			AfxMessageBox( strMsg, MB_OK );
			hr = S_FALSE;
		}
	}

	// Make sure new alias contains valid characters
	if( hr == S_OK )
	{
		for( int i = 0 ;  i < strAlias.GetLength() ;  i++ )
		{
			if( !(_istalpha( strAlias[i] ))
			&&  !(_istdigit( strAlias[i] ))
			&&  !(strAlias[i] == _T('_')) )
			{
				CString strMsg;

				AfxFormatString1( strMsg, IDS_INVALID_OBJECT_ALIAS, strAlias );
				AfxMessageBox( strMsg, MB_OK );
				hr = S_FALSE;
			}
		}
	}

	// Make sure new alias is unique
	if( hr == S_OK )
	{
		if( m_pContainer->IsScriptAliasUnique( this ) == FALSE )
		{
			CString strMsg;

			AfxFormatString1( strMsg, IDS_DUPE_OBJECT_ALIAS, m_FileRef.strScriptAlias );
			AfxMessageBox( strMsg, MB_OK );
			hr = S_FALSE;
		}
	}

	// Put back original alias
	m_FileRef.strScriptAlias = strOrigAlias;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::SetNodeName

HRESULT CContainerObject::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strAlias = bstrName;
	::SysFreeString( bstrName );

	if( m_pContainer->IsInScript() == FALSE )
	{
		// Can't rename an Object in a Container
		ASSERT( 0 );	// This should not happen
		return S_FALSE;
	}

	if( strAlias.Compare( m_FileRef.strScriptAlias ) != 0 )
	{
		m_pContainer->m_pUndoMgr->SaveState( m_pContainer, theApp.m_hInstance, IDS_UNDO_OBJECT_ALIAS );

		CString strOrigName = m_FileRef.strScriptAlias;
		m_FileRef.strScriptAlias = strAlias;

		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			pIPropSheet->RefreshTitleByObject( this );
			pIPropSheet->RefreshActivePageByObject( this );
			RELEASE( pIPropSheet );
		}

		SetModifiedFlag();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetNodeListInfo

HRESULT CContainerObject::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_FileRef.pIRefNode != NULL );
	if( m_FileRef.pIRefNode == NULL )
	{
		return E_UNEXPECTED;
	}

	return( m_FileRef.pIRefNode->GetNodeListInfo(pListInfo) );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetEditorClsId

HRESULT CContainerObject::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
//
//	ASSERT( m_FileRef.pIRefNode != NULL );
//	if( m_FileRef.pIRefNode == NULL )
//	{
//		return E_UNEXPECTED;
//	}
//
//	return( m_FileRef.pIRefNode->GetEditorClsId(pClsId) );
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetEditorTitle

HRESULT CContainerObject::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_FileRef.pIRefNode != NULL );
	if( m_FileRef.pIRefNode == NULL )
	{
		return E_UNEXPECTED;
	}

	return( m_FileRef.pIRefNode->GetEditorTitle(pbstrTitle) );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetEditorWindow

HRESULT CContainerObject::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_FileRef.pIRefNode  )
	{
		return( m_FileRef.pIRefNode->GetEditorWindow(hWndEditor) );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::SetEditorWindow

HRESULT CContainerObject::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_FileRef.pIRefNode != NULL );
	if( m_FileRef.pIRefNode == NULL )
	{
		return E_UNEXPECTED;
	}

	return( m_FileRef.pIRefNode->SetEditorWindow(hWndEditor) );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::UseOpenCloseImages

HRESULT CContainerObject::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetRightClickMenuId

HRESULT CContainerObject::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;

	if( m_pContainer->IsInScript() )
	{
		*pnMenuId = IDM_SCRIPT_OBJECT_NODE_RMENU;
	}
	else
	{
		*pnMenuId = IDM_OBJECT_NODE_RMENU;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::OnRightClickMenuInit

HRESULT CContainerObject::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		// IDM_DELETE
		if( CanDelete() == S_OK )
		{
			menu.EnableMenuItem( IDM_DELETE, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_DELETE, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::OnRightClickMenuSelect

HRESULT CContainerObject::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_LOCATE:
			if( m_FileRef.pIDocRootNode )
			{
				theApp.m_pContainerComponent->m_pIFramework8->SetSelectedNode( m_FileRef.pIDocRootNode );
			}
			break;

		case IDM_DELETE:
			DeleteNode( TRUE );
			break;

		case IDM_OBJECT_ALIAS:
			if( m_pContainer->IsInScript() )
			{
				theApp.m_pContainerComponent->m_pIFramework8->EditNodeLabel( this );
			}
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::DeleteChildNode

HRESULT CContainerObject::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// ContainerObject nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::InsertChildNode

HRESULT CContainerObject::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// ContainerObject nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::DeleteNode

HRESULT CContainerObject::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Let our parent delete us
	return m_pIParentNode->DeleteChildNode( this, fPromptUser );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::OnNodeSelChanged

HRESULT CContainerObject::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::CreateDataObject

HRESULT CContainerObject::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_FileRef.pIRefNode )
	{
		return m_FileRef.pIRefNode->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::CanCut

HRESULT CContainerObject::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::CanCopy

HRESULT CContainerObject::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_FileRef.pIRefNode )
	{
		return m_FileRef.pIRefNode->CanCopy();	// Will copy the Container
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::CanDelete

HRESULT CContainerObject::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::CanDeleteChildNode

HRESULT CContainerObject::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Container Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::CanPasteFromData

HRESULT CContainerObject::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Let parent decide whether it wants to paste
	return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::PasteFromData

HRESULT CContainerObject::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Let parent handle pasting of Container
	return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::CanChildPasteFromData

HRESULT CContainerObject::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												 BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Container Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::ChildPasteFromData

HRESULT CContainerObject::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Container Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdNode::GetObject

HRESULT CContainerObject::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdPropPageObject::GetData

HRESULT CContainerObject::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdPropPageObject::SetData

HRESULT CContainerObject::SetData( void* pData )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdPropPageObject::OnShowProperties

HRESULT CContainerObject::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pContainerComponent != NULL );
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	// Get the Container Object page manager
	CObjectPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_ObjectPropPageManager ) == S_OK )
	{
		pPageManager = (CObjectPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CObjectPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Container Object's properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CObjectPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CContainerObject::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
//	CContainerObject::GetScriptAlias

void CContainerObject::GetScriptAlias( CString& strScriptAlias )
{
	strScriptAlias = m_FileRef.strScriptAlias;
}


//////////////////////////////////////////////////////////////////////
//	CContainerObject::SetScriptAlias

void CContainerObject::SetScriptAlias( const LPCTSTR pszScriptAlias )
{
	m_FileRef.strScriptAlias = pszScriptAlias;
}


//////////////////////////////////////////////////////////////////////
//	CContainerObject::ClearListInfo

void CContainerObject::ClearListInfo()
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	m_FileRef.li.pIProject = NULL;

	m_FileRef.li.strProjectName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strDescriptor.LoadString( IDS_EMPTY_TEXT );

	memset( &m_FileRef.li.guidFile, 0, sizeof(GUID) );

	AfxSetResourceHandle( hInstance );
}


//////////////////////////////////////////////////////////////////////
//	CContainerObject::SetFileReference

HRESULT CContainerObject::SetFileReference( IDMUSProdNode* pINewDocRootNode )
{
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	HRESULT hr = S_OK;

	// Clean up old file reference
	if( m_FileRef.pIDocRootNode )
	{
		// Turn off notifications for this node
		if( m_FileRef.fRemoveNotify )
		{
			ASSERT( m_pContainer != NULL );
			if( m_pContainer )
			{
				hr = theApp.m_pContainerComponent->m_pIFramework8->RemoveFromNotifyList( m_FileRef.pIDocRootNode, m_pContainer );
			}
		}
	}

	// Initialize pertinent fields
	RELEASE( m_FileRef.pIDocRootNode );
	RELEASE( m_FileRef.pIRefNode );
	m_FileRef.strScriptAlias.Empty();
	m_FileRef.fRemoveNotify = FALSE;
	ClearListInfo();

	// Set DocRoot of new file reference
	if( pINewDocRootNode )
	{
		IDMUSProdNode* pINewRefNode;

		hr = theApp.m_pContainerComponent->CreateRefNode( pINewDocRootNode, &pINewRefNode );
		if( SUCCEEDED ( hr ) )
		{
			// Turn on notifications
			ASSERT( m_pContainer != NULL );
			if( m_pContainer )
			{
				ASSERT( m_FileRef.fRemoveNotify == FALSE );
				hr = theApp.m_pContainerComponent->m_pIFramework8->AddToNotifyList( pINewDocRootNode, m_pContainer );
				if( SUCCEEDED ( hr ) )
				{
					m_FileRef.fRemoveNotify = TRUE;
				}
			}
			
			// Update file reference's DocRoot member variable
			m_FileRef.pIDocRootNode = pINewDocRootNode;
			m_FileRef.pIDocRootNode->AddRef();
			
			// Update file reference's RefNode member variable
			m_FileRef.pIRefNode = pINewRefNode;
//			m_FileRef.pIRefNode->AddRef();		Already AddRef'd by CreateRefNode()

			// Update file reference's list info
			SyncListInfo();

			// Update file reference's script alias
			BSTR bstrScriptAlias;
			hr = m_FileRef.pIDocRootNode->GetNodeName( &bstrScriptAlias );
			if( SUCCEEDED ( hr ) )
			{
				m_FileRef.strScriptAlias = bstrScriptAlias;
				::SysFreeString( bstrScriptAlias );
				m_pContainer->MakeUniqueScriptAlias( this );
			}
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CContainerObject::SetFileReference

HRESULT CContainerObject::SetFileReference( GUID guidFile )
{
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	HRESULT hr = E_FAIL;

	IDMUSProdNode* pIDocRootNode;
	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->FindDocRootNodeByFileGUID( guidFile, &pIDocRootNode ) ) )
	{
		hr = SetFileReference( pIDocRootNode );

		RELEASE( pIDocRootNode );
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CContainerObject::SyncListInfo

HRESULT CContainerObject::SyncListInfo( void )
{
	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );

	HRESULT hr = S_OK;

	ClearListInfo();

	if( m_FileRef.pIDocRootNode )
	{
		DMUSProdListInfo ListInfo;
		ZeroMemory( &ListInfo, sizeof(ListInfo) );
		ListInfo.wSize = sizeof(ListInfo);

		hr = m_FileRef.pIDocRootNode->GetNodeListInfo ( &ListInfo );
		if( SUCCEEDED ( hr ) )
		{
			IDMUSProdProject* pIProject;

			if( ListInfo.bstrName )
			{
				m_FileRef.li.strName = ListInfo.bstrName;
				::SysFreeString( ListInfo.bstrName );
			}
			if( ListInfo.bstrDescriptor )
			{
				m_FileRef.li.strDescriptor = ListInfo.bstrDescriptor;
				::SysFreeString( ListInfo.bstrDescriptor );
			}
			if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->FindProject( m_FileRef.pIDocRootNode, &pIProject ) ) )
			{
				BSTR bstrProjectName;

				m_FileRef.li.pIProject = pIProject;
//				m_FileRef.li.pIProject->AddRef();		intentionally missing

				if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
				{
					m_FileRef.li.strProjectName = bstrProjectName;
					::SysFreeString( bstrProjectName );
				}

				pIProject->Release();
			}

		    theApp.m_pContainerComponent->m_pIFramework8->GetNodeFileGUID( m_FileRef.pIDocRootNode, &m_FileRef.li.guidFile );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject Load

HRESULT CContainerObject::Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, BOOL* pfReference )
{
    IStream*       pIStream;
	MMCKINFO	   ck;
	DWORD		   dwByteCount;
	DWORD		   dwSize;
	DWORD		   dwCurrentFilePos;
	DWORD		   dwStartFilePos;
    HRESULT        hr = S_OK;
    HRESULT        hrReference = S_OK;

	CString		   strObjectName;
	CString		   strScriptAlias;
	IDMUSProdNode* pIDocRootNode = NULL;
	DWORD		   dwRIFFckid = 0;
	DWORD		   dwRIFFfccType = 0;
	CLSID		   clsidDMObject;
	GUID		   guidDocRootNodeId;
	BOOL		   fWasReference = FALSE;
	short		   nReferenceFlagUI = -1;
	memset( &clsidDMObject, 0, sizeof(CLSID) );
	memset( &guidDocRootNodeId, 0, sizeof(GUID) );

	ASSERT( theApp.m_pContainerComponent != NULL );

	if( pfReference == NULL )
	{
		ASSERT( 0 );
		return E_POINTER;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwCurrentFilePos = StreamTell( pIStream );
    dwStartFilePos = dwCurrentFilePos;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_CONTAINED_ALIAS_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &strScriptAlias );
				break;

			case DMUS_FOURCC_CONTAINED_OBJECT_CHUNK:
			{
			    DMUS_IO_CONTAINED_OBJECT_HEADER dmusContainedObjectIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_CONTAINED_OBJECT_HEADER ) );
				hr = pIStream->Read( &dmusContainedObjectIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				clsidDMObject = dmusContainedObjectIO.guidClassID;
				m_dwFlagsDM = dmusContainedObjectIO.dwFlags;
				dwRIFFckid = dmusContainedObjectIO.ckid;
				dwRIFFfccType = dmusContainedObjectIO.fccType;
				break;
			}

			case DMUS_FOURCC_CONTAINED_OBJECT_UI_CHUNK:
			{
			    ioObjectUI iObjectUI;

				dwSize = min( ck.cksize, sizeof( ioObjectUI ) );
				hr = pIStream->Read( &iObjectUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( iObjectUI.wFlags & COBU_REFERENCE )
				{
					nReferenceFlagUI = TRUE;
				}
				else
				{
					nReferenceFlagUI = FALSE;
				}
				break;
			}

			case FOURCC_DMUSPROD_FILEREF:
			{
				IDMUSProdFileRefChunk* pIFileRef;

				fWasReference = TRUE;
				hr = theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
				StreamSeek( pIStream, dwCurrentFilePos, 0 );
				hrReference = pIFileRef->LoadRefChunk( pIStream, &pIDocRootNode );
				if( hrReference != S_OK )
				{
					if( hrReference == E_PENDING )
					{
						IDMUSProdNotifySink* pINotifySink;
						if( SUCCEEDED ( m_pContainer->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
						{
							// Store File's GUID so we can resolve reference in our handler 
							// for the FRAMEWORK_FileLoadFinished notification
							StreamSeek( pIStream, dwCurrentFilePos, 0 );
							pIFileRef->ResolveWhenLoadFinished( pIStream, pINotifySink, &m_FileRef.li.guidFile );
							RELEASE( pINotifySink );
						}
					}
					else
					{
						DMUSProdFileRefInfo FileRefInfo;
						memset( &FileRefInfo, 0, sizeof(DMUSProdFileRefInfo) );
						FileRefInfo.wSize = sizeof(DMUSProdFileRefInfo);
						StreamSeek( pIStream, dwCurrentFilePos, 0 );
						if( SUCCEEDED( pIFileRef->GetFileRefInfo( pIStream, &FileRefInfo ) ) )
						{
							guidDocRootNodeId = FileRefInfo.guidDocRootNodeId;
						}
					}
				}
				RELEASE( pIFileRef );
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_REF_LIST:
					{
						MMCKINFO ckName;

						fWasReference = TRUE;
						ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
						if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
						{
							// Store object name (segment or style)
							ReadMBSfromWCS( pIStream, ckName.cksize, &strObjectName );
						}
						break;
					}
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwCurrentFilePos = StreamTell( pIStream );
    }

	if( pIDocRootNode == NULL
	&&  hrReference != E_PENDING )
	{
		if( fWasReference == TRUE )
		{
			if( ::IsEqualGUID( clsidDMObject, CLSID_DirectMusicSegment ) 
			&&  ::IsEqualGUID( guidDocRootNodeId, GUID_WaveNode ) )
			{
				// We really are looking for a wave
				clsidDMObject = CLSID_DirectSoundWave;
			}

			// Resolve reference
			if( !(strObjectName.IsEmpty()) 
			&&  !(::IsEqualGUID(clsidDMObject, GUID_AllZeros)) )
			{
				// Framework could not resolve file reference
				// so we will ask user to help
				hrReference = theApp.m_pContainerComponent->FindReferencedFile( this, clsidDMObject, strObjectName, pIStream, &pIDocRootNode );
				if( SUCCEEDED ( hrReference ) )
				{
					if( m_pContainer->IsDocRootInContainer( pIDocRootNode ) == S_OK )
					{
						// Already in container
						// so we do not want another reference to the DocRoot
						RELEASE( pIDocRootNode );
					}
					else
					{
						SetModifiedFlag();
					}
				}
			}
		}
		else
		{
			// Load embedded file
			StreamSeek( pIStream, dwStartFilePos, 0 );

			MMCKINFO ckEmbeddedFile;
			ckEmbeddedFile.ckid = dwRIFFckid;
			ckEmbeddedFile.fccType = dwRIFFfccType;

			if( ckEmbeddedFile.ckid == FOURCC_RIFF )
			{
				if( pIRiffStream->Descend( &ckEmbeddedFile, pckMain, MMIO_FINDRIFF ) == 0 )
				{
					if( ckEmbeddedFile.fccType == mmioFOURCC('W','A','V','E') 
					&&  ::IsEqualGUID(clsidDMObject, CLSID_DirectMusicSegment) ) 
					{
						// CLSID_DirectSoundWave was saved as CLSID_DirectMusicSegment
						// so convert it bak to CLSID_DirectSoundWave
						clsidDMObject = CLSID_DirectSoundWave;
					}
					StreamSeek( pIStream, -12, STREAM_SEEK_CUR );
					pIDocRootNode = theApp.m_pContainerComponent->LoadEmbeddedFile( clsidDMObject, pIStream );
				}
			}
			else if( ckEmbeddedFile.ckid == FOURCC_LIST )
			{
				if( pIRiffStream->Descend( &ckEmbeddedFile, pckMain, MMIO_FINDLIST ) == 0 )
				{
					StreamSeek( pIStream, -12, STREAM_SEEK_CUR );
					pIDocRootNode = theApp.m_pContainerComponent->LoadEmbeddedFile( clsidDMObject, pIStream );
				}
			}
			else
			{
				if( pIRiffStream->Descend( &ckEmbeddedFile, pckMain, MMIO_FINDCHUNK ) == 0 )
				{
					StreamSeek( pIStream, -8, STREAM_SEEK_CUR );
					pIDocRootNode = theApp.m_pContainerComponent->LoadEmbeddedFile( clsidDMObject, pIStream );
				}
			}
		}
	}

	if( pIDocRootNode == NULL
	&&  hrReference == E_PENDING )
	{
		m_FileRef.strScriptAlias = strScriptAlias;

		if( nReferenceFlagUI == -1 )
		{
			// Did not encounter UI chunk
			// so preserve manner object was stored in the container file
			*pfReference = fWasReference;
		}
		else
		{
			*pfReference = nReferenceFlagUI;
		}
	}
	else if( pIDocRootNode )
	{
		hr = SetFileReference( pIDocRootNode );
		pIDocRootNode->Release();

		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}

		// Store Alias from file
		// Can't do this sooner because SetFileReference() resets alias
		if( strScriptAlias.IsEmpty() == FALSE )
		{
			if( strScriptAlias.Compare( m_FileRef.strScriptAlias ) != 0 )
			{
				m_FileRef.strScriptAlias = strScriptAlias;

				if( m_pIDocRootNode
				&&  m_pIParentNode )
				{
					theApp.m_pContainerComponent->m_pIFramework8->RefreshNode( this );
					SetModifiedFlag();	// To send CONTAINER_ChangeNotification
				}
			}
		}

		if( nReferenceFlagUI == -1 )
		{
			// Did not encounter UI chunk
			// so preserve manner object was stored in the container file
			*pfReference = fWasReference;
		}
		else
		{
			*pfReference = nReferenceFlagUI;
		}
	}
	else
	{
		hr = S_FALSE;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject::SaveDMRef

HRESULT CContainerObject::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream,
									 IDMUSProdNode* pIDocRootNode, DMUS_OBJECTDESC* pdmusObjectDesc, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk* pIRefChunkLoader;

	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );
	if( theApp.m_pContainerComponent->m_pIFramework8 == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED( theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
	{
		if( pIRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_DIRECTMUSIC:
				case WL_PRODUCER:
					hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																  pIDocRootNode,
																  pdmusObjectDesc->guidClass,
																  pdmusObjectDesc,
																  whichLoader );
					break;
			}

			pIRefChunkLoader->Release();
		}
	}

	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject::SaveProducerRef

HRESULT CContainerObject::SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode )
{
	IDMUSProdFileRefChunk* pIFileRefChunk;

	ASSERT( theApp.m_pContainerComponent->m_pIFramework8 != NULL );
	if( theApp.m_pContainerComponent->m_pIFramework8 == NULL )
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if ( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIStream->Release();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject Save
    
HRESULT CContainerObject::Save( IDMUSProdRIFFStream* pIRiffStream, BOOL fSaveReference )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	BOOL fIsEmbeddedInStream = TRUE;

	if( m_FileRef.pIDocRootNode == NULL )
	{
		// Will happen while waiting for FRAMEWORK_FileLoadFinished notification
		return SaveObjectPendingLoad( pIRiffStream, fSaveReference );
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pIPersistInfo;
	if( FAILED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
	{
		ASSERT( 0 );
		pIPersistInfo = NULL;
	}

	if( pIPersistInfo )
	{
		pIPersistInfo->GetStreamInfo( &StreamInfo );
	}

	// Initialize the DMUS_OBJECTDESC structure
	DMUS_OBJECTDESC dmusObjectDesc;
	memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);
	DWORD dwRIFFckid = 0;
	DWORD dwRIFFfccType = 0;
	
	// Prepare the DMUS_OBJECTDESC structure
	{
		IDMUSProdDocType *pIDocType;
		IDMUSProdDocType8 *pIDocType8;
		GUID guidNodeId;

		// Got DocRoot's NodeId
		hr = m_FileRef.pIDocRootNode->GetNodeId( &guidNodeId );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}

		// Get DocRoot's DocType
		hr = theApp.m_pContainerComponent->m_pIFramework8->FindDocTypeByNodeId( guidNodeId, &pIDocType );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		hr = pIDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDocType8 );
		RELEASE( pIDocType );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		hr = pIDocType8->GetObjectDescriptorFromNode( m_FileRef.pIDocRootNode, &dmusObjectDesc );
		if( SUCCEEDED ( hr ) )
		{
			hr = pIDocType8->GetObjectRiffId( guidNodeId, &dwRIFFckid, &dwRIFFfccType );
		}
		RELEASE( pIDocType8 );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( !(dmusObjectDesc.dwValidData & DMUS_OBJ_CLASS) )
		{
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}

		if( m_pContainer->IsInScript() )
		{
			// CLSID_DirectSoundWave should be saved as CLSID_DirectMusicSegment
			// so that a segment containing the wave in a wavetrack will be
			// returned by the loader
			if( ::IsEqualGUID( dmusObjectDesc.guidClass, CLSID_DirectSoundWave ) )
			{
				dmusObjectDesc.guidClass = CLSID_DirectMusicSegment;
			}
		}
	}

	// Write DMUS_FOURCC_CONTAINED_OBJECT_LIST header
	ckMain.fccType = DMUS_FOURCC_CONTAINED_OBJECT_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write DMUS_FOURCC_CONTAINED_ALIAS_CHUNK 
	// Only applies to containers within scripts
	if( m_pContainer->IsInScript() )
	{
		// Write chunk header
		ck.ckid = DMUS_FOURCC_CONTAINED_ALIAS_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_FileRef.strScriptAlias );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write DMUS_FOURCC_CONTAINED_OBJECT_CHUNK
	{
		DMUS_IO_CONTAINED_OBJECT_HEADER dmusContainedObjectIO;

		// Write chunk header
		ck.ckid = DMUS_FOURCC_CONTAINED_OBJECT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare DMUS_IO_CONTAINER_HEADER structure
		memset( &dmusContainedObjectIO, 0, sizeof(DMUS_IO_CONTAINED_OBJECT_HEADER) );

		dmusContainedObjectIO.guidClassID = dmusObjectDesc.guidClass;
		dmusContainedObjectIO.dwFlags = m_dwFlagsDM;
		if( StreamInfo.ftFileType != FT_RUNTIME
		||  fSaveReference )
		{
			dmusContainedObjectIO.ckid = FOURCC_LIST;
			dmusContainedObjectIO.fccType = DMUS_FOURCC_REF_LIST;
		}
		else
		{
			dmusContainedObjectIO.ckid = dwRIFFckid;
			dmusContainedObjectIO.fccType = dwRIFFfccType;
		}

		// Write Container chunk data
		hr = pIStream->Write( &dmusContainedObjectIO, sizeof(DMUS_IO_CONTAINED_OBJECT_HEADER), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(DMUS_IO_CONTAINED_OBJECT_HEADER) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write DMUS_FOURCC_CONTAINED_OBJECT_UI_CHUNK
	if( StreamInfo.ftFileType != FT_RUNTIME )
	{
		ioObjectUI oObjectUI;

		// Write chunk header
		ck.ckid = DMUS_FOURCC_CONTAINED_OBJECT_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare ioObjectUI structure
		memset( &oObjectUI, 0, sizeof(ioObjectUI) );

		if( fSaveReference )
		{
			oObjectUI.wFlags |= COBU_REFERENCE;
		}

		// Write Container chunk data
		hr = pIStream->Write( &oObjectUI, sizeof(ioObjectUI), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioObjectUI) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	
	// Determine whether file is already embedded in this stream
	if( pIPersistInfo 
	&&  pIPersistInfo->IsInEmbeddedFileList(m_FileRef.pIDocRootNode) == S_FALSE )
	{
		fIsEmbeddedInStream = FALSE;
	}

	// Write object data
	if( (::IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ))
	||  (StreamInfo.ftFileType != FT_RUNTIME)
	||   fSaveReference 
	||   fIsEmbeddedInStream )
	{
		if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ) )
		{
			SaveDMRef( pIRiffStream, m_FileRef.pIDocRootNode, &dmusObjectDesc, WL_PRODUCER );
		}
		else if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion ) )
		{
			SaveDMRef( pIRiffStream, m_FileRef.pIDocRootNode, &dmusObjectDesc, WL_DIRECTMUSIC );
			if( StreamInfo.ftFileType == FT_DESIGN )
			{
				SaveProducerRef( pIRiffStream, m_FileRef.pIDocRootNode );
			}
		}
	}
	else
	{
		IPersistStream* pIPersistStream;

		hr = m_FileRef.pIDocRootNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
		if( pIPersistInfo )
		{
			// Need to do this BEFORE Save()
			pIPersistInfo->AddToEmbeddedFileList( m_FileRef.pIDocRootNode );
		}
		hr = pIPersistStream->Save( pIStream, FALSE );
		RELEASE( pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIPersistInfo );
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject SaveObjectPendingLoad
    
HRESULT CContainerObject::SaveObjectPendingLoad( IDMUSProdRIFFStream* pIRiffStream, BOOL fSaveReference )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	MMCKINFO ckRef;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwLength;

	// Make sure we do not yet have a DocRoot pointer
	if( m_FileRef.pIDocRootNode != NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Make sure we are waiting for this object to finish loading
	EmbeddedFile* pTheEmbeddedFile = NULL;
	if( theApp.m_pContainerComponent->m_pEmbeddedFileRootFile )
	{
		if( ::IsEqualGUID(theApp.m_pContainerComponent->m_pEmbeddedFileRootFile->guidNotification, m_FileRef.li.guidFile) )
		{
			pTheEmbeddedFile = theApp.m_pContainerComponent->m_pEmbeddedFileRootFile;
		}
	}
	if( pTheEmbeddedFile == NULL )
	{
		POSITION pos = theApp.m_pContainerComponent->m_lstEmbeddedFiles.GetHeadPosition();
		while( pos )
		{
			EmbeddedFile* pEmbeddedFile = theApp.m_pContainerComponent->m_lstEmbeddedFiles.GetNext( pos );

			if( ::IsEqualGUID(pEmbeddedFile->guidNotification, m_FileRef.li.guidFile) )
			{
				pTheEmbeddedFile = pEmbeddedFile;
				break;
			}
		}
	}
	if( pTheEmbeddedFile == NULL )
	{
		// We are NOT waiting for FRAMEWORK_FileLoadFinished notification
		ASSERT( 0 );
		return S_FALSE;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pIPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
	{
		pIPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pIPersistInfo );
	}

	if( StreamInfo.ftFileType == FT_RUNTIME )
	{
		// This method must save FT_DESIGN format
		// because it cannot embed files
		ASSERT( 0 );
		hr = E_UNEXPECTED;
		goto ON_ERROR;
	}

	// Initialize the DMUS_OBJECTDESC structure
	DMUS_OBJECTDESC dmusObjectDesc;
	memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);
	
	// Prepare the DMUS_OBJECTDESC structure
	{
		dmusObjectDesc.dwValidData = ( DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_NAME );
		memcpy( &dmusObjectDesc.guidObject, &pTheEmbeddedFile->guidObject, sizeof(GUID) );
		memcpy( &dmusObjectDesc.guidClass, &pTheEmbeddedFile->guidDMClass, sizeof(CLSID) );
		MultiByteToWideChar( CP_ACP, 0, pTheEmbeddedFile->strObjectName, -1, dmusObjectDesc.wszName, DMUS_MAX_NAME );

		if( m_pContainer->IsInScript() )
		{
			// CLSID_DirectSoundWave should be saved as CLSID_DirectMusicSegment
			// so that a segment containing the wave in a wavetrack will be
			// returned by the loader
			if( ::IsEqualGUID( dmusObjectDesc.guidClass, CLSID_DirectSoundWave ) )
			{
				dmusObjectDesc.guidClass = CLSID_DirectMusicSegment;
			}
		}
	}

	// Write DMUS_FOURCC_CONTAINED_OBJECT_LIST header
	ckMain.fccType = DMUS_FOURCC_CONTAINED_OBJECT_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write DMUS_FOURCC_CONTAINED_ALIAS_CHUNK 
	// Only applies to containers within scripts
	if( m_pContainer->IsInScript() )
	{
		// Write chunk header
		ck.ckid = DMUS_FOURCC_CONTAINED_ALIAS_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_FileRef.strScriptAlias );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write DMUS_FOURCC_CONTAINED_OBJECT_CHUNK
	{
		DMUS_IO_CONTAINED_OBJECT_HEADER dmusContainedObjectIO;

		// Write chunk header
		ck.ckid = DMUS_FOURCC_CONTAINED_OBJECT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare DMUS_IO_CONTAINER_HEADER structure
		memset( &dmusContainedObjectIO, 0, sizeof(DMUS_IO_CONTAINED_OBJECT_HEADER) );

		dmusContainedObjectIO.guidClassID = dmusObjectDesc.guidClass;
		dmusContainedObjectIO.dwFlags = m_dwFlagsDM;
		dmusContainedObjectIO.ckid = FOURCC_LIST;
		dmusContainedObjectIO.fccType = DMUS_FOURCC_REF_LIST;

		// Write Container chunk data
		hr = pIStream->Write( &dmusContainedObjectIO, sizeof(DMUS_IO_CONTAINED_OBJECT_HEADER), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(DMUS_IO_CONTAINED_OBJECT_HEADER) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write DMUS_FOURCC_CONTAINED_OBJECT_UI_CHUNK
	{
		ioObjectUI oObjectUI;

		// Write chunk header
		ck.ckid = DMUS_FOURCC_CONTAINED_OBJECT_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare ioObjectUI structure
		memset( &oObjectUI, 0, sizeof(ioObjectUI) );

		if( fSaveReference )
		{
			oObjectUI.wFlags |= COBU_REFERENCE;
		}

		// Containers in Segments do not support referenced files
		if( m_pContainer->IsInSegment() )
		{
			oObjectUI.wFlags &= ~COBU_REFERENCE;
		}

		// Write Container chunk data
		hr = pIStream->Write( &oObjectUI, sizeof(ioObjectUI), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioObjectUI) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	
	// Write DMUS_FOURCC_REF_LIST
	{
		// Write REF LIST header
		ckRef.fccType = DMUS_FOURCC_REF_LIST;
		if( pIRiffStream->CreateChunk(&ckRef, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write REF chunk
		{
			DMUS_IO_REFERENCE dmusReference;

			ck.ckid = DMUS_FOURCC_REF_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Prepare DMUS_IO_REFERENCE structure
			memset( &dmusReference, 0, sizeof(DMUS_IO_REFERENCE) );
			memcpy( &dmusReference.guidClassID, &dmusObjectDesc.guidClass, sizeof(GUID) );
			dmusReference.dwValidData = dmusObjectDesc.dwValidData;

			// Write REF chunk data 
			hr = pIStream->Write( &dmusReference, sizeof(DMUS_IO_REFERENCE), &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_REFERENCE) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Write GUID chunk
		{
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			hr = pIStream->Write( &dmusObjectDesc.guidObject, sizeof(GUID), &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(GUID) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Write Name chunk
		{
			ck.ckid = DMUS_FOURCC_NAME_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			dwLength = wcslen( dmusObjectDesc.wszName ) + 1; 
			dwLength *= sizeof( wchar_t );
			hr = pIStream->Write( &dmusObjectDesc.wszName, dwLength, &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != dwLength )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		if( pIRiffStream->Ascend(&ckRef, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CContainerObject ResolveBestGuessWhenLoadFinished

HRESULT CContainerObject::ResolveBestGuessWhenLoadFinished( IDMUSProdDocType* pIDocType, BSTR bstrObjectName, IDMUSProdNode* pITargetDirectoryNode )
{
	HRESULT hr = E_FAIL;

	IDMUSProdNotifySink* pINotifySink;
	if( SUCCEEDED ( m_pContainer->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
	{
		// Don't free BSTR - it will get freed in ResolveBestGuessWhenLoadFinished()
		CString strObjectName = bstrObjectName;

		// Store temporary GUID so we can resolve reference in our handler 
		// for the FRAMEWORK_FileLoadFinished notification
		hr = theApp.m_pContainerComponent->m_pIFramework8->ResolveBestGuessWhenLoadFinished( pIDocType,
																							 bstrObjectName,
																							 pITargetDirectoryNode,
																							 pINotifySink,
																							 &m_FileRef.li.guidFile );
		if( SUCCEEDED ( hr ) )
		{
			EmbeddedFile* pEmbeddedFile = theApp.m_pContainerComponent->FindEmbeddedFile( pIDocType, strObjectName );

			if( pEmbeddedFile
			&&  pEmbeddedFile->dwStreamPos == 0 
			&&  ::IsEqualGUID(pEmbeddedFile->guidDMClass, CLSID_DirectMusicContainer) == FALSE )
			{
				// Need to special case when root file is not a Container
				pEmbeddedFile->guidNotification = m_FileRef.li.guidFile;
			}
		}

		RELEASE( pINotifySink );
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabObjectRuntime.cpp ===
// TabObjectRuntime.cpp : implementation file
//

#include "stdafx.h"
#include "ContainerDesignerDLL.h"

#include "Container.h"
#include "Object.h"
#include "TabObjectRuntime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabObjectRuntime property page

CTabObjectRuntime::CTabObjectRuntime( CObjectPropPageManager* pPageManager ) : CPropertyPage(CTabObjectRuntime::IDD)
{
	//{{AFX_DATA_INIT(CTabObjectRuntime)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pContainerObject = NULL;
	m_pPageManager = pPageManager;
	m_fNeedToDetach = FALSE;
}

CTabObjectRuntime::~CTabObjectRuntime()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectRuntime::SetContainerObject

void CTabObjectRuntime::SetContainerObject( CContainerObject* pContainerObject )
{
	m_pContainerObject = pContainerObject;
}


void CTabObjectRuntime::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabObjectRuntime)
	DDX_Control(pDX, IDC_RUNTIME_FILE, m_editRuntimeFile);
	DDX_Control(pDX, IDC_RUNTIME_CREATE, m_staticRuntimeCreate);
	DDX_Control(pDX, IDC_RUNTIME_SIZE, m_staticRuntimeSize);
	DDX_Control(pDX, IDC_RUNTIME_MODIFIED, m_staticRuntimeModified);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectRuntime::EnableControls

void CTabObjectRuntime::EnableControls( BOOL fEnable ) 
{
	// May need this routine later
}


BEGIN_MESSAGE_MAP(CTabObjectRuntime, CPropertyPage)
	//{{AFX_MSG_MAP(CTabObjectRuntime)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabObjectRuntime message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabObjectRuntime::OnSetActive

BOOL CTabObjectRuntime::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pContainerObject == NULL )
	{
		EnableControls( FALSE );
		return CPropertyPage::OnSetActive();
	}

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CObjectPropPageManager::sm_nActiveTab );

	EnableControls( TRUE );

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	// Set runtime file name, modified date, size
	BSTR bstrFile;
	CString strFile;
	CString strFileCreate;
	CString strFileModified;
	CString strFileSize;

	strFile.LoadString( IDS_NOT_SAVED );
	strFileCreate.LoadString( IDS_UNKNOWN );
	strFileModified.LoadString( IDS_UNKNOWN );
	strFileSize.LoadString( IDS_UNKNOWN );

	// Determine filename of last saved runtime file
	if( SUCCEEDED ( theApp.m_pContainerComponent->m_pIFramework8->GetNodeRuntimeFileName( m_pContainerObject->m_FileRef.pIDocRootNode, &bstrFile ) ) )
	{
		CString strTheFile = bstrFile;
		::SysFreeString( bstrFile );

		if( strTheFile.IsEmpty() == FALSE )
		{
			strFile = strTheFile;

			HANDLE hFile = ::CreateFile( strFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 									 FILE_ATTRIBUTE_NORMAL, NULL );
			if( hFile != INVALID_HANDLE_VALUE )
			{
				FILETIME ftCreate;
				FILETIME ftModified;
				DWORD dwFileSize;

				if( ::GetFileTime(hFile, &ftCreate, NULL, &ftModified) )
				{
					CTime timeFile;
					
					timeFile = ftCreate;
					strFileCreate = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );
					
					timeFile = ftModified;
					strFileModified = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );
				}

				dwFileSize = GetFileSize( hFile, NULL );

				CString strSize;
				CString strBytes;
				strSize.Format( "%u", dwFileSize );

				int i, j;
				int nLength = strSize.GetLength();

				for( i=0, j=nLength;  i < nLength ; i++ )
				{
					strBytes += strSize[i];
					j--;
					if( (j > 0)
					&& !(j % 3) )
					{
						strBytes += ',';
					}
				}
				
				if( dwFileSize < 1024 )
				{
					AfxFormatString1( strFileSize, IDS_SIZE_BYTES, strBytes );
				}
				else
				{
					CString strKB;
					
					double dblKB = dwFileSize / 1024.0;
					strKB.Format( "%.2f", dblKB );

					AfxFormatString2( strFileSize, IDS_SIZE_KB, strKB, strBytes );
				}

				CloseHandle( hFile );
			}
		}
	}

	m_editRuntimeFile.SetWindowText( strFile );
	m_staticRuntimeCreate.SetWindowText( strFileCreate );
	m_staticRuntimeModified.SetWindowText( strFileModified );
	m_staticRuntimeSize.SetWindowText( strFileSize );
	
	AfxSetResourceHandle( hInstance );
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectRuntime::OnDestroy

void CTabObjectRuntime::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabObjectRuntime::OnCreate

int CTabObjectRuntime::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\ContainerDesigner\TabObjectFlags.h ===
#if !defined(AFX_TABOBJECTFLAGS_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABOBJECTFLAGS_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabObjectFlags.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTabObjectFlags dialog

class CTabObjectFlags : public CPropertyPage
{
// Construction
public:
	CTabObjectFlags( CObjectPropPageManager* pPageManager );
	~CTabObjectFlags();
	void SetContainerObject( CContainerObject* pContainerObject );

// Dialog Data
	//{{AFX_DATA(CTabObjectFlags)
	enum { IDD = IDD_TAB_OBJECT_FLAGS };
	CButton	m_checkCache;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabObjectFlags)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CContainerObject*		m_pContainerObject;
	CObjectPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void SetModifiedFlag();
	void EnableControls( BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabObjectFlags)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnCache();
	afx_msg void OnDoubleClickedCache();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABOBJECTFLAGS_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\AboutDlg.h ===
#if !defined(AFX_ABOUTDLG_H__B4912982_3902_11D1_8B4E_006097B01078__INCLUDED_)
#define AFX_ABOUTDLG_H__B4912982_3902_11D1_8B4E_006097B01078__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AboutDlg.h : header file
//
#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog

class CAboutDlg : public CDialog
{
// Construction
public:
	CAboutDlg(CWnd* pParent = NULL);   // standard constructor
    BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_DLS_ABOUT_BOX };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ABOUTDLG_H__B4912982_3902_11D1_8B4E_006097B01078__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\adsrenvelope.h ===
#if !defined(AFX_ADSRENVELOPE_H__01CAA562_CC67_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_ADSRENVELOPE_H__01CAA562_CC67_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CADSREnvelope wrapper class

class CADSREnvelope : public CWnd
{
protected:
	DECLARE_DYNCREATE(CADSREnvelope)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x71ae3626, 0xa9bd, 0x11d0, { 0xbc, 0xba, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	long GetReleaseTime();
	void SetReleaseTime(long);
	long GetDelayTime();
	void SetDelayTime(long);
	long GetAttackTime();
	void SetAttackTime(long);
	long GetHoldTime();
	void SetHoldTime(long);
	long GetDecayTime();
	void SetDecayTime(long);
	long GetSustainLevel();
	void SetSustainLevel(long);
	void SetDLS1(BOOL bDLS1);

// Operations
public:
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADSRENVELOPE_H__01CAA562_CC67_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Articulation.cpp ===
// Articulation.cpp : implementation file
//

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"

#include "Region.h"
#include "Articulation.h"
#include "ArticulationList.h"
#include "Collection.h"
#include "Instrument.h"
#include "InstrumentFVEditor.h"
#include "InstrumentCtl.h"
#include <math.h>

#include "resource.h"
#include "DLSLoadSaveUtils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CArticulation constructor/destructor

CArticulation::CArticulation(CDLSComponent* pComponent, CInstrument* pInstrument) :
m_pInstrument(pInstrument),
m_pRegion(NULL),
m_dwRef(0),
m_pIRootNode(NULL),
m_pIParentNode(NULL),
m_bDeletingArticulation(false),
m_bOwnerIsInstrument(TRUE),
#ifndef DMP_XBOX
m_bDLS1(TRUE)
#else
m_bDLS1(FALSE)
#endif
{
	ASSERT( pComponent != NULL );

	AddRef();
	m_pComponent = pComponent;
	m_pComponent->AddRef();

	InitDefaultArticParams();
}

CArticulation::CArticulation(CDLSComponent* pComponent, CRegion* pRegion) :
m_pInstrument(NULL),
m_pRegion(pRegion),
m_dwRef(0),
m_pIRootNode(NULL),
m_pIParentNode(NULL),
m_bDeletingArticulation(false),
m_bOwnerIsInstrument(FALSE),
#ifndef DMP_XBOX
m_bDLS1(TRUE)
#else
m_bDLS1(FALSE)
#endif
{
	ASSERT( pComponent != NULL );

	AddRef();
	m_pComponent = pComponent;
	m_pComponent->AddRef();

	InitDefaultArticParams();
}


CArticulation::~CArticulation()
{
	if(m_pComponent)
	{
		m_pComponent->Release();
	}
}


void CArticulation::InitDefaultArticParams()
{
	ZeroMemory(&m_ArticParams, sizeof(m_ArticParams));

	// Modulator LFO params
    m_ArticParams.m_LFO.m_tcDelay = Mils2TimeCents(0);
    m_ArticParams.m_LFO.m_pcFrequency = FIVE_HERTZ;

	// Vibrato LFO params
	m_ArticParams.m_LFO.m_tcDelayVibrato = Mils2TimeCents(0);
    m_ArticParams.m_LFO.m_pcFrequencyVibrato = FIVE_HERTZ;

	m_ArticParams.m_VolEG.m_tcDelay = Mils2TimeCents(0);
    m_ArticParams.m_VolEG.m_tcAttack = Mils2TimeCents(0);
	m_ArticParams.m_VolEG.m_tcHold = Mils2TimeCents(0);
    m_ArticParams.m_VolEG.m_tcDecay = Mils2TimeCents(0);
    m_ArticParams.m_VolEG.m_ptSustain = 1000 << 16;
    m_ArticParams.m_VolEG.m_tcRelease = Mils2TimeCents(0);
	m_ArticParams.m_VolEG.m_tcShutdownTime = 0;
    m_ArticParams.m_VolEG.m_tcVel2Attack = 0;
    m_ArticParams.m_VolEG.m_tcKey2Decay = 0;
	m_ArticParams.m_VolEG.m_tcKey2Hold = 0;
	m_ArticParams.m_PitchEG.m_tcDelay = Mils2TimeCents(0);
    m_ArticParams.m_PitchEG.m_tcAttack = Mils2TimeCents(0);
	m_ArticParams.m_PitchEG.m_tcHold = Mils2TimeCents(0);
    m_ArticParams.m_PitchEG.m_tcDecay = Mils2TimeCents(0);
    m_ArticParams.m_PitchEG.m_ptSustain = 1000 << 16;
    m_ArticParams.m_PitchEG.m_tcRelease = Mils2TimeCents(0);
    m_ArticParams.m_PitchEG.m_tcVel2Attack = 0;
	m_ArticParams.m_PitchEG.m_tcKey2Hold = 0;
    m_ArticParams.m_PitchEG.m_tcKey2Decay = 0;
    m_ArticParams.m_Misc.m_ptDefaultPan = 0; // Mid

	// Filter parameters
	m_ArticParams.m_FilterParams.m_pcInitialFc = 0x7FFFFFFF;
}


CArticulation* CArticulation::GetNext()
{
	return (CArticulation*) AListItem::GetNext();
}

DWORD CArticulation::PrepareTags(DWORD dwTag)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_dwEditTag = dwTag;
	
	if(dwTag) dwTag++;
	
	return dwTag;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IUnknown implementation

HRESULT CArticulation::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

	if( ::IsEqualIID(riid, IID_IPersist) )
    {
        AddRef();
        *ppvObj = (IPersist *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        AddRef();
        *ppvObj = (IPersistStream *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CArticulation::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CArticulation::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetNodeImageIndex

HRESULT CArticulation::GetNodeImageIndex(short* pnFirstImage)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnFirstImage);
	ASSERT(m_pComponent != NULL);

	BOOL bConditionOK = FALSE;

	IDMUSProdNode* pIParentNode =  NULL;
	GetParentNode(&pIParentNode);
	ASSERT(pIParentNode);
	if(pIParentNode)
	{
		CArticulationList* pArtList = dynamic_cast<CArticulationList*>(pIParentNode);
		if(pArtList)
		{
			bConditionOK = pArtList->IsConditionOK();
		}

		pIParentNode->Release();
	}

	if(bConditionOK)
	{
		return m_pComponent->GetArticulationImageIndex(pnFirstImage);
	}
	else
	{
		return m_pComponent->GetArticulationGrayedImageIndex(pnFirstImage);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetComponent

HRESULT CArticulation::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetRootNode

HRESULT CArticulation::GetDocRootNode( IDMUSProdNode** ppIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIRootNode )
	{
		m_pIRootNode->AddRef();
		*ppIRootNode = m_pIRootNode;
		return S_OK;
	}

	*ppIRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::SetRootNode

HRESULT CArticulation::SetDocRootNode( IDMUSProdNode* pIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( pIRootNode != NULL );

	m_pIRootNode = pIRootNode;
//	m_pIRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetParentNode

HRESULT CArticulation::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pIParentNode)
	{
		m_pIParentNode->AddRef();
		*ppIParentNode = m_pIParentNode;
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::SetParentNode

HRESULT CArticulation::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetNodeId

HRESULT CArticulation::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ArticulationNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetNodeName

HRESULT CArticulation::GetNodeName(BSTR* pbstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pbstrName);

	CString cs = "Articulation";
    *pbstrName = cs.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetNodeNameMaxLength

HRESULT CArticulation::GetNodeNameMaxLength(short* pnMaxLength)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnMaxLength);
	
	*pnMaxLength = -1;	// Can't edit Articulation name.

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::ValidateNodeName

HRESULT CArticulation::ValidateNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Just free bstrName; can't rename an Articulation
	::SysFreeString(bstrName);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::SetNodeName

HRESULT CArticulation::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	::SysFreeString( bstrName );
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetEditorClsId

HRESULT CArticulation::GetEditorClsId(CLSID* pClsId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pClsId);

	if(m_pInstrument)
	{
		return(m_pInstrument->GetEditorClsId(pClsId));
	}
	else
	{
		ASSERT(m_pRegion);
		ASSERT(m_pRegion->m_pInstrument);
		return(m_pRegion->m_pInstrument->GetEditorClsId(pClsId));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetEditorTitle

HRESULT CArticulation::GetEditorTitle(BSTR* pbstrTitle)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pInstrument)
	{
		return(m_pInstrument->GetEditorTitle(pbstrTitle));
	}
	else
	{
		ASSERT(m_pRegion);
		ASSERT(m_pRegion->m_pInstrument);
		return(m_pRegion->m_pInstrument->GetEditorTitle(pbstrTitle));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetEditorWindow

HRESULT CArticulation::GetEditorWindow(HWND* hWndEditor)
{
	HRESULT hr = S_OK;
	*hWndEditor = NULL;

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pInstrument)
	{
		if ( m_bDeletingArticulation )
			*hWndEditor = NULL;
		else
			hr = m_pInstrument->GetEditorWindow(hWndEditor);
	}
	else
	{
		if ( (m_pRegion && m_pRegion->m_bDeletingRegion) || m_bDeletingArticulation )
			*hWndEditor = NULL;
		else if(m_pRegion && m_pRegion->m_pInstrument)
		{
			hr = m_pRegion->m_pInstrument->GetEditorWindow(hWndEditor);
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::SetEditorWindow

HRESULT CArticulation::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pInstrument)
	{
		return(m_pInstrument->SetEditorWindow(hWndEditor));
	}
	else
	{
		ASSERT(m_pRegion);
		if(m_pRegion == NULL)
			return E_FAIL;

		ASSERT(m_pRegion->m_pInstrument);
		if(m_pRegion->m_pInstrument == NULL)
			return E_FAIL;

		return(m_pRegion->m_pInstrument->SetEditorWindow(hWndEditor));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::UseOpenCloseImages

HRESULT CArticulation::UseOpenCloseImages(BOOL* pfUseOpenCloseImages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pfUseOpenCloseImages);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetRightClickMenuId

HRESULT CArticulation::GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMenuId);
	ASSERT(phInstance);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_ARTICULATION_NODE_RMENU;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::OnRightClickMenuInit

HRESULT CArticulation::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// if all regions do not have local art. gray the delete menu.
	if(CanDelete() != S_OK)
	{
		CMenu menu;
 		if( menu.Attach(hMenu) )
		{
			menu.EnableMenuItem( IDM_DELETE, (MF_GRAYED | MF_BYCOMMAND) );
			menu.Detach();
		}
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::OnRightClickMenuSelect

HRESULT CArticulation::OnRightClickMenuSelect(long lCommandId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	HRESULT hr = E_FAIL;
	
	switch( lCommandId )
	{
		case IDM_OPEN:
		{
			if(SUCCEEDED(m_pComponent->m_pIFramework->OpenEditor(this)))
			{
				hr = S_OK;
				if(m_pInstrument)
				{
					m_pInstrument->SetCurrentArticulation(this);
				}

				else if(m_pRegion)
				{
					ASSERT(m_pRegion->m_pInstrument);
					if(m_pRegion->m_pInstrument)
						return E_FAIL;
					
					m_pRegion->SetCurrentArticulation(this);
				}
				else
				{
					// No owner for this articulation??
					ASSERT(1);
				}
			}
			
			break;
		}
		
		case IDM_CUT:
			hr = E_NOTIMPL;			
			break;

		case IDM_COPY:
			hr = E_NOTIMPL;
			break;

		case IDM_PASTE:
			hr = E_NOTIMPL;
			break;

		case IDM_DELETE:
		{
			m_bDeletingArticulation = true;
			hr = DeleteNode(TRUE);
			break;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::DeleteChildNode

HRESULT CArticulation::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_FAIL;	// Not implemented.
}


/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::InsertChildNode

HRESULT CArticulation::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_FAIL;	// Not implemented.
}


/////////////////////////////////////////////////////////////////////////////
// CArticulation IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CArticulation IPersist::GetClassID

HRESULT CArticulation::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
  
	ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::DeleteNode

HRESULT CArticulation::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	IDMUSProdNode* pIParentNode;

	if(SUCCEEDED(GetParentNode(&pIParentNode)))
	{
		CInstrument* pInstrument = NULL;
		if(m_pInstrument)
		{
			pInstrument = m_pInstrument;
		}
		else if(m_pRegion && m_pRegion->m_pInstrument)
		{
			pInstrument = m_pRegion->m_pInstrument;
		}

		if(pInstrument)
		{
			if(FAILED(pInstrument->SaveStateForUndo(IDS_UNDO_DELETE_ARTICULATION)))
			{
				return E_FAIL;
			}
		}
		
		m_bDeletingArticulation = true;
 		HRESULT hr = pIParentNode->DeleteChildNode((IDMUSProdNode *)this, fPromptUser);
		pIParentNode->Release();

		if(pInstrument)
		{
			pInstrument->RefreshRegion();
		}

		return hr;
	}
	
	return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetFirstChild

HRESULT CArticulation::GetFirstChild(IDMUSProdNode** ppIFirstChildNode)
{
	// An Articulation does not have any children
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*ppIFirstChildNode = NULL;
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetNextChild

HRESULT CArticulation::GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode)
{
	// An Articulation does not have any children
	
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetNodeListInfo

HRESULT CArticulation::GetNodeListInfo(DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pListInfo);
	
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::OnNodeSelChanged

HRESULT CArticulation::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CInstrument* pInstrument;

	if(m_pInstrument)
	{
		pInstrument = m_pInstrument;
	}
	else
	{
		pInstrument = m_pRegion->m_pInstrument;	
	}

	if(fSelected)
	{
		#ifdef _DEBUG
			ValidateParent();
		#endif

		
		if(m_pInstrument)
		{
			m_pInstrument->SetCurrentArticulation(this);
		}
		else if(m_pRegion)
		{
			m_pRegion->SetCurrentArticulation(this);
		}
		
		if(pInstrument)
		{
			pInstrument->m_pComponent->m_pIConductor->SetActiveTransport(pInstrument, BS_NO_AUTO_UPDATE | BS_PLAY_ENABLED);
		}

	}	
	else
	{
		pInstrument->m_pComponent->m_pIConductor->TransportStopped(pInstrument);
		pInstrument->TurnOffMidiNotes();
		pInstrument->m_pComponent->m_pIConductor->SetBtnStates(pInstrument,BS_NO_AUTO_UPDATE);
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IDMUSProdNode::CreateDataObject
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IDMUSProdNode::CanCut
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::CanCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IDMUSProdNode::CanCopy
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::CanCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IDMUSProdNode::CanDelete
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::CanDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // If this is a global articulation, and
    // all regions in the instrument have articulations,
    // we should be able to delete the global articulation.
	// If its local, we should allow delete only if we 
	// have a global articulation

    bool bLocalArticulation = true;
	if(!m_pRegion && m_pInstrument) // if not an articulation of a region
	{
        // If we have multiple instrument articulations we should be able to delete this one
        if(m_pInstrument->GetArticulationCount() > 1)
		{
            return S_OK;
        }

		CRegion* pRegion = m_pInstrument->m_Regions.GetHead();
		ASSERT(pRegion);
        // walk thru region list to see if all regions have local articulations
        for(; pRegion && bLocalArticulation; pRegion = pRegion->GetNext())
        {
			if(pRegion->GetArticulationCount() == 0) 
			{
                bLocalArticulation = false;
				break;
            }
        }
	}
	else
	{
		CInstrument* pInstrument = m_pRegion->GetInstrument();
		ASSERT(pInstrument);
		if(pInstrument == NULL)
		{
			return S_FALSE;
		}

		if(m_pRegion->GetArticulationCount() > 1)
		{
			return S_OK;
		}
		else if(pInstrument->GetArticulationCount() == 0)
		{
			return S_FALSE;
		}
		
		return S_OK;
	}

	return bLocalArticulation ? S_OK : E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IDMUSProdNode::CanDeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IDMUSProdNode::CanPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IDMUSProdNode::PasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IDMUSProdNode::CanChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
											  BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IDMUSProdNode::ChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}


/////////////////////////////////////////////////////////////////////////////
// CArticulation IDMUSProdNode::GetObject

HRESULT CArticulation::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation Additional functions

/////////////////////////////////////////////////////////////////////////////
// CArticulation::Save
HRESULT CArticulation::Save(IDMUSProdRIFFStream* pIRiffStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	HRESULT hr = S_OK;			// Return code
	DWORD cb = 0;

	MMCKINFO ck;
    CONNECTIONLIST ConHeader;
	
	IStream* pIStream = NULL;
	pIStream = pIRiffStream->GetStream();
	if(pIStream == NULL)
	{
		return E_OUTOFMEMORY;
	}

	ck.ckid = FOURCC_ART2;
	if(m_bDLS1)
	{
		ck.ckid = FOURCC_ART1;
	}

    hr = pIRiffStream->CreateChunk(&ck, 0);
    
	if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }
	
	UINT nConnections = 0;
	CreateConnectionList(nConnections);

    ConHeader.cConnections = nConnections;
    ConHeader.cbSize = sizeof(ConHeader);
    hr = pIStream->Write((LPSTR) &ConHeader, sizeof(CONNECTIONLIST), &cb);	
    if (FAILED(hr) || cb != sizeof(CONNECTIONLIST))
    {
		pIStream->Release();
        return (hr);
    }
    hr = pIStream->Write((LPSTR) &m_arrConnections, sizeof(CONNECTION) * nConnections, &cb);	
    if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }

    if (FAILED(pIRiffStream->Ascend(&ck, 0)))
    {
		pIStream->Release();
        return (E_FAIL);
    }

	// Save unknown chunks 
    //m_UnknownChunk.Save(pIRiffStream);


	pIStream->Release();
    return (hr);
}

/////////////////////////////////////////////////////////////////////////////
// CArticulation::Load

HRESULT CArticulation::Load( IDMUSProdRIFFStream* pIRiffStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IStream*		pIStream = NULL;
	DWORD			cb;
    CONNECTIONLIST	ConChunk;
    CONNECTION		Connection;
    DWORD			dwIndex;
    HRESULT			hr = S_OK;

	ASSERT( m_pComponent != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    hr = pIStream->Read( &ConChunk, sizeof(ConChunk), &cb );
    if( FAILED(hr) )
	{
		pIStream->Release();
		return hr;
	}
	
    for (dwIndex = 0; dwIndex < ConChunk.cConnections; dwIndex++)
    {
		hr = pIStream->Read( &Connection, sizeof(CONNECTION), &cb );
		if( FAILED(hr))
		{
			pIStream->Release();
			return hr;
		}
        switch (Connection.usSource)
        {
			case CONN_SRC_NONE :
			{
				switch (Connection.usDestination)
				{
					// modulator LFO params
					case CONN_DST_LFO_FREQUENCY :
					{
						m_ArticParams.m_LFO.m_pcFrequency =	(PCENT) Connection.lScale;
						break;
					}
					case CONN_DST_LFO_STARTDELAY :
					{
						m_ArticParams.m_LFO.m_tcDelay =	(TCENT) Connection.lScale;
						break;
					}
					
					// Vibrato LFO params
					case CONN_DST_VIB_FREQUENCY :
					{
						m_ArticParams.m_LFO.m_pcFrequencyVibrato =	(PCENT) Connection.lScale;
						break;
					}
					case CONN_DST_VIB_STARTDELAY :
					{
						m_ArticParams.m_LFO.m_tcDelayVibrato =	(TCENT) Connection.lScale;
						break;
					}


					case CONN_DST_EG1_DELAYTIME :
					{
						m_ArticParams.m_VolEG.m_tcDelay = (TCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG1_ATTACKTIME :
					{
						m_ArticParams.m_VolEG.m_tcAttack = (TCENT) Connection.lScale;
						break;
					}
					
					case CONN_DST_EG1_HOLDTIME :
					{
						m_ArticParams.m_VolEG.m_tcHold = (TCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG1_DECAYTIME :
					{
						m_ArticParams.m_VolEG.m_tcDecay = (TCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG1_SUSTAINLEVEL :
					{
						m_ArticParams.m_VolEG.m_ptSustain = (PERCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG1_RELEASETIME :
					{
						m_ArticParams.m_VolEG.m_tcRelease = (TCENT) Connection.lScale; 
						break;
					}

					case CONN_DST_EG1_SHUTDOWNTIME :
					{
						m_ArticParams.m_VolEG.m_tcShutdownTime = (TCENT) Connection.lScale; 
						break;
					}

					case CONN_DST_EG2_DELAYTIME :
					{
						m_ArticParams.m_PitchEG.m_tcDelay = (TCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG2_ATTACKTIME :
					{
						m_ArticParams.m_PitchEG.m_tcAttack = (TCENT) Connection.lScale;
						break;
					}
					
					case CONN_DST_EG2_HOLDTIME :
					{
						m_ArticParams.m_PitchEG.m_tcHold = (TCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG2_DECAYTIME :
					{
						m_ArticParams.m_PitchEG.m_tcDecay = (TCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG2_SUSTAINLEVEL :
					{
						m_ArticParams.m_PitchEG.m_ptSustain = (PERCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG2_RELEASETIME :
					{
						m_ArticParams.m_PitchEG.m_tcRelease = (TCENT) Connection.lScale; 
						break;
					}

					case CONN_DST_PAN :
					{
						m_ArticParams.m_Misc.m_ptDefaultPan = (PERCENT) Connection.lScale;
						break;
					}

					case CONN_DST_FILTER_CUTOFF :
					{
						m_ArticParams.m_FilterParams.m_pcInitialFc = (PCENT) Connection.lScale;
						break;
					}

					case CONN_DST_FILTER_Q :
					{
						m_ArticParams.m_FilterParams.m_gcInitialQ = (GCENT) Connection.lScale;
						break;
					}
				}
				break;
			}
			case CONN_SRC_LFO :
			{
				switch (Connection.usControl)
				{
					case CONN_SRC_NONE :
					{
						switch (Connection.usDestination)
						{
							case CONN_DST_ATTENUATION :
							{
								m_ArticParams.m_LFO.m_gcVolumeScale = (GCENT) Connection.lScale; 
                                if(m_ArticParams.m_LFO.m_gcVolumeScale < 0)
                                {
                                    // Change the sign
                                    m_ArticParams.m_LFO.m_gcVolumeScale = (-m_ArticParams.m_LFO.m_gcVolumeScale);
                                }

								break;
							}

							case CONN_DST_PITCH :
							{
								m_ArticParams.m_LFO.m_pcPitchScale = (PCENT) Connection.lScale; 
								break;
							}

							case CONN_DST_FILTER_CUTOFF :
							{
								m_ArticParams.m_FilterParams.m_pcModLFOToFc = (PCENT) Connection.lScale;
								break;
							}
						}
						break;
					}
					case CONN_SRC_CC1 :
					{
						switch (Connection.usDestination)
						{
							case CONN_DST_ATTENUATION :
							{
								m_ArticParams.m_LFO.m_gcMWToVolume = (GCENT) Connection.lScale; 
								break;
							}

							case CONN_DST_PITCH :
							{
								m_ArticParams.m_LFO.m_pcMWToPitch = (PCENT) Connection.lScale; 
								break;
							}

							case CONN_DST_FILTER_CUTOFF :
							{
								m_ArticParams.m_FilterParams.m_pcModLFOCC1ToFc = (PCENT) Connection.lScale;
								break;
							}
						}
						break;
					}

					case CONN_SRC_CHANNELPRESSURE :
					{
						switch(Connection.usDestination)
						{
							case CONN_DST_GAIN :
							{
								m_ArticParams.m_LFO.m_gcChanPressToGain = (GCENT) Connection.lScale;
								break;
							}

							case CONN_DST_PITCH :
							{
								m_ArticParams.m_LFO.m_pcChanPressToPitch = (PCENT) Connection.lScale;
								break;
							}

							case CONN_DST_FILTER_CUTOFF :
							{
								m_ArticParams.m_LFO.m_pcChanPressToFc = (PCENT) Connection.lScale;
								break;
							}
						}
						
						break;
					}

				}
				break;
			}
			case CONN_SRC_VIBRATO :
			{
				switch(Connection.usControl)
				{
					case CONN_SRC_NONE :
					{
						switch(Connection.usDestination)
						{
							case CONN_DST_PITCH:
							{
								m_ArticParams.m_LFO.m_pcPitchScaleVibrato = (PCENT) Connection.lScale;
								break;
							}
						}
						break;
					}

					case CONN_SRC_CC1 :
					{
						switch(Connection.usDestination)
						{	
							case CONN_DST_PITCH :
							{
								m_ArticParams.m_LFO.m_pcMWToPitchVibrato = (PCENT) Connection.lScale;
								break;
							}

						}
						break;
					}
					case CONN_SRC_CHANNELPRESSURE :
					{
						switch(Connection.usDestination)
						{
							case CONN_DST_PITCH :
							{
								m_ArticParams.m_LFO.m_pcChanPressToPitchVibrato = (PCENT) Connection.lScale;
								break;
							}
						}
						break;
					}

				}
				break;
			}
			case CONN_SRC_KEYONVELOCITY :
			{
				switch (Connection.usDestination)
				{
					case CONN_DST_EG1_ATTACKTIME :
					{
						m_ArticParams.m_VolEG.m_tcVel2Attack = (TCENT) Connection.lScale;
						break;
					}
					case CONN_DST_EG2_ATTACKTIME :
					{
						m_ArticParams.m_PitchEG.m_tcVel2Attack = (TCENT) Connection.lScale;
						break;
					}
					case CONN_DST_ATTENUATION :
					{
						break;
					}
					case CONN_DST_FILTER_CUTOFF :
					{
						m_ArticParams.m_FilterParams.m_pcVelocityToFc = (PCENT) Connection.lScale;
						break;
					}
				}
				break;
			}
			case CONN_SRC_KEYNUMBER :
			{
				switch (Connection.usDestination)
				{
					case CONN_DST_EG1_DECAYTIME :
					{
						m_ArticParams.m_VolEG.m_tcKey2Decay = (TCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG2_DECAYTIME :
					{
						m_ArticParams.m_PitchEG.m_tcKey2Decay = (TCENT) Connection.lScale;
						break;
					}
					
					case CONN_DST_EG1_HOLDTIME :
					{
						m_ArticParams.m_VolEG.m_tcKey2Hold = (TCENT) Connection.lScale;
						break;
					}

					case CONN_DST_EG2_HOLDTIME :
					{
						m_ArticParams.m_PitchEG.m_tcKey2Hold = (TCENT) Connection.lScale;
						break;
					}

					case CONN_DST_FILTER_CUTOFF :
					{
						m_ArticParams.m_FilterParams.m_pcKeyNumToFc = (PCENT) Connection.lScale;
						break;
					}
				}
				break;
			}
			case CONN_SRC_EG2 :
			{
				switch (Connection.usDestination)
				{
					case CONN_DST_PITCH :
					{
						m_ArticParams.m_PitchEG.m_pcRange = (PCENT) Connection.lScale; 
						break;
					}

					case CONN_DST_FILTER_CUTOFF :
					{
						m_ArticParams.m_FilterParams.m_pcEGToFc = (PCENT) Connection.lScale;
						break;
					}
				}
				
				break;
			}
		}
    }

	pIStream->Release();
    return hr;
}


#ifdef _DEBUG
void CArticulation::ValidateParent()
{
	if(m_pInstrument == NULL && m_pRegion == NULL)
	{
		// Problem; we should never get here if we do 
		// Articulation does not have a parent; not good it 
		// needs one.
		ASSERT(FALSE);
	}
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CArticulation IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IPersistStream::IsDirty
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::IsDirty()
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IPersistStream::GetSizeMax
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IPersistStream::Load
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::Load(IStream* pIStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ULONG ulBytesRead = 0;

	// DLS1 or DLS2?
	HRESULT hr = pIStream->Read((void *)&m_bDLS1, sizeof(BOOL), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(BOOL))
	{
		return E_FAIL;
	}


	ulBytesRead = 0;
	hr = pIStream->Read((void *)&m_ArticParams, sizeof(ArticParams), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(ArticParams))
	{
		return E_FAIL;
	}
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulation IPersistStream::Save
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulation::Save(IStream* pIStream, BOOL fClearDirty)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ULONG ulBytesWritten = 0;
	
	// Save DLS1 or DLS2
	HRESULT hr = pIStream->Write((void *)&m_bDLS1, sizeof(BOOL), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(BOOL))
	{
		return E_FAIL;
	}

	ulBytesWritten = 0;
	hr = pIStream->Write((void *)&m_ArticParams, sizeof(ArticParams), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(ArticParams))
	{
		return E_FAIL;
	}

	return hr;
}

HRESULT CArticulation::Write(void* pv, DWORD* pdwCurOffset, DWORD* pDMWOffsetTable, DWORD* pdwCurIndex, DWORD dwNextArtIndex)
{
	ASSERT(pv);
	ASSERT(pdwCurOffset);
	ASSERT(pDMWOffsetTable);
	ASSERT(pdwCurIndex);
	
	BOOL bNewFormat = FALSE;
	if(m_pInstrument)
	{
		bNewFormat = m_pInstrument->SupportsNewFormat();
	}
	else if(m_pRegion)
	{
		ASSERT(m_pRegion->m_pInstrument);
		if(m_pRegion->m_pInstrument)
		{
			bNewFormat = m_pRegion->m_pInstrument->SupportsNewFormat();
		}
	}

	HRESULT hr = S_OK;
	DWORD dwRelativeCurOffset = 0;
	ULONG *pulFirstExtCkIdx = NULL;

	UINT nConnections = 0;
	CreateConnectionList(nConnections);
	DWORD dwConnectionListSize = (nConnections * sizeof CONNECTION) + sizeof CONNECTIONLIST;

	if(bNewFormat)
    {     
    	DMUS_ARTICULATION2* pArt = (DMUS_ARTICULATION2*) pv;
        dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
	    
		(*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
        pArt->ulNextArtIdx = dwNextArtIndex;
        
		// Do we have any articulation data?
		if(dwConnectionListSize)
        {
            pDMWOffsetTable[*pdwCurIndex] = *pdwCurOffset;
		    pArt->ulArtIdx = (*pdwCurIndex)++;
            
			DWORD dwOffsetStart = *pdwCurOffset; 
			void* pvConnectionBuff = ((BYTE *)pv + dwRelativeCurOffset);

			CONNECTIONLIST* pList = (CONNECTIONLIST*) pvConnectionBuff;
			pList->cbSize = sizeof(CONNECTIONLIST);
			pList->cConnections = nConnections;

			CONNECTION* pConnection = (CONNECTION*) ((BYTE*) pvConnectionBuff + sizeof(CONNECTIONLIST));
			memcpy(pConnection, m_arrConnections, nConnections * sizeof(CONNECTION));
			
			*pdwCurOffset += dwConnectionListSize;
            dwRelativeCurOffset += (*pdwCurOffset - dwOffsetStart);	
        }
        else
	    {
		    pArt->ulArtIdx = 0;
	    }
    }
	else
	{

		DMUS_ARTICULATION* pArt = (DMUS_ARTICULATION *)pv;
		dwRelativeCurOffset = CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));
		(*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));

		if(dwConnectionListSize)
		{
			pDMWOffsetTable[*pdwCurIndex] = *pdwCurOffset;
			pArt->ulArt1Idx = (*pdwCurIndex)++;
			
			DMUS_ARTICPARAMS articParamsDLS1;
			GetLevel1Articulation(articParamsDLS1);

			CopyMemory(((BYTE *)pv + dwRelativeCurOffset), &articParamsDLS1, CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS)));
			dwRelativeCurOffset += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
			(*pdwCurOffset) += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
		}
		else
		{
			pArt->ulArt1Idx = 0;
		}
	}

	return hr;
}

DWORD CArticulation::Size()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	DWORD dwSize = 0;
	BOOL bNewFormat = FALSE;
	if(m_pInstrument)
	{
		bNewFormat = m_pInstrument->SupportsNewFormat();
	}
	else if(m_pRegion)
	{
		ASSERT(m_pRegion->m_pInstrument);
		if(m_pRegion->m_pInstrument)
			bNewFormat = m_pRegion->m_pInstrument->SupportsNewFormat();
	}


	if(bNewFormat)
	{
		dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION2));
	}
	else
	{
		dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICULATION));
	}

	UINT nConnections = 0;
	CreateConnectionList(nConnections);
	
	if(bNewFormat)
	{
		dwSize += nConnections * sizeof(CONNECTION) + sizeof(CONNECTIONLIST);
	}
	else
	{
		dwSize += CHUNK_ALIGN(sizeof(DMUS_ARTICPARAMS));
	}
	
	return dwSize;
}

DWORD CArticulation::Count()
{
	//return 1 + (m_bDLS1 ? TRUE : FALSE);
	return 2;
}

void CArticulation::CreateConnectionList(UINT& nConnections)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	nConnections = 0;

    // Connections for Modulator LFO
	if(notinrange(m_ArticParams.m_LFO.m_pcFrequency, FIVE_HERTZ, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_LFO_FREQUENCY,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_pcFrequency);
    }

	if(notinrange(m_ArticParams.m_LFO.m_tcDelay, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_LFO_STARTDELAY,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_tcDelay);
    }

	if(notinrange(m_ArticParams.m_LFO.m_gcVolumeScale, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_LFO,
					   CONN_SRC_NONE,
					   CONN_DST_ATTENUATION,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_gcVolumeScale);
    }
    
	if(notinrange(m_ArticParams.m_LFO.m_pcPitchScale,0,65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_LFO,
					   CONN_SRC_NONE,
					   CONN_DST_PITCH,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_pcPitchScale);
    }
    
	if(notinrange(m_ArticParams.m_LFO.m_gcMWToVolume, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_LFO,
					   CONN_SRC_CC1,
					   CONN_DST_ATTENUATION,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_gcMWToVolume);
    }
    
	if(notinrange(m_ArticParams.m_LFO.m_pcMWToPitch, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_LFO,
					   CONN_SRC_CC1,
					   CONN_DST_PITCH,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_pcMWToPitch);
    }

	if(notinrange(m_ArticParams.m_LFO.m_gcChanPressToGain, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_LFO,
					   CONN_SRC_CHANNELPRESSURE,
					   CONN_DST_GAIN,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_gcChanPressToGain);
    }

	if(notinrange(m_ArticParams.m_LFO.m_pcChanPressToPitch, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_LFO,
					   CONN_SRC_CHANNELPRESSURE,
					   CONN_DST_PITCH,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_pcChanPressToPitch);
    }

	if(notinrange(m_ArticParams.m_LFO.m_pcChanPressToFc, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_LFO,
					   CONN_SRC_CHANNELPRESSURE,
					   CONN_DST_FILTER_CUTOFF,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_pcChanPressToFc);
    }

	// Connections for Vibrato LFO
	if(notinrange(m_ArticParams.m_LFO.m_pcFrequencyVibrato, FIVE_HERTZ, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_VIB_FREQUENCY,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_pcFrequencyVibrato);
    }
    
	if(notinrange(m_ArticParams.m_LFO.m_tcDelayVibrato, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_VIB_STARTDELAY,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_tcDelayVibrato);
    }

	if(notinrange(m_ArticParams.m_LFO.m_pcPitchScaleVibrato,0,65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_VIBRATO,
					   CONN_SRC_NONE,
					   CONN_DST_PITCH,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_pcPitchScaleVibrato);
    }

	if(notinrange(m_ArticParams.m_LFO.m_pcMWToPitchVibrato, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_VIBRATO,
					   CONN_SRC_CC1,
					   CONN_DST_PITCH,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_pcMWToPitchVibrato);
    }

	if(notinrange(m_ArticParams.m_LFO.m_pcChanPressToPitchVibrato, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_VIBRATO,
					   CONN_SRC_CHANNELPRESSURE,
					   CONN_DST_PITCH,
					   CONN_TRN_NONE,
					   (DWORD)m_ArticParams.m_LFO.m_pcChanPressToPitchVibrato);
    }
	
	// Make connections for the Volume Envelope
	if(notinrange(m_ArticParams.m_VolEG.m_tcDelay, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG1_DELAYTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_VolEG.m_tcDelay);
    }
    

	if(notinrange(m_ArticParams.m_VolEG.m_tcAttack, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG1_ATTACKTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_VolEG.m_tcAttack);
    }

	if(notinrange(m_ArticParams.m_VolEG.m_tcHold, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG1_HOLDTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_VolEG.m_tcHold);
    }

	if(notinrange(m_ArticParams.m_VolEG.m_tcDecay, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG1_DECAYTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_VolEG.m_tcDecay);
    }
    
	if(notinrange(m_ArticParams.m_VolEG.m_ptSustain, 1000 << 16, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG1_SUSTAINLEVEL,
					   CONN_TRN_NONE,
					   m_ArticParams.m_VolEG.m_ptSustain);
    }
    
	if(notinrange(m_ArticParams.m_VolEG.m_tcRelease, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG1_RELEASETIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_VolEG.m_tcRelease);
    }
    
	if(notinrange(m_ArticParams.m_VolEG.m_tcVel2Attack, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_KEYONVELOCITY,
					   CONN_SRC_NONE,
					   CONN_DST_EG1_ATTACKTIME,
					   CONN_TRN_NONE,m_ArticParams.m_VolEG.m_tcVel2Attack);
    }
    
	if(notinrange(m_ArticParams.m_VolEG.m_tcKey2Decay, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_KEYNUMBER,
					   CONN_SRC_NONE,
		               CONN_DST_EG1_DECAYTIME,
					   CONN_TRN_NONE,m_ArticParams.m_VolEG.m_tcKey2Decay);
    }

	if(notinrange(m_ArticParams.m_VolEG.m_tcKey2Hold, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_KEYNUMBER,
					   CONN_SRC_NONE,
		               CONN_DST_EG1_HOLDTIME,
					   CONN_TRN_NONE,m_ArticParams.m_VolEG.m_tcKey2Hold);
    }
	
	if(notinrange(m_ArticParams.m_VolEG.m_tcShutdownTime, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
		               CONN_DST_EG1_SHUTDOWNTIME,
					   CONN_TRN_NONE,m_ArticParams.m_VolEG.m_tcShutdownTime);
    }

	if(notinrange(m_ArticParams.m_PitchEG.m_tcDelay, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG2_DELAYTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_PitchEG.m_tcDelay);
    }
    
	if(notinrange(m_ArticParams.m_PitchEG.m_tcAttack, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG2_ATTACKTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_PitchEG.m_tcAttack);
    }

	if(notinrange(m_ArticParams.m_PitchEG.m_tcHold, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG2_HOLDTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_PitchEG.m_tcHold);
    }
    
	if(notinrange(m_ArticParams.m_PitchEG.m_tcDecay, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG2_DECAYTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_PitchEG.m_tcDecay);
    }
    
	if(notinrange(m_ArticParams.m_PitchEG.m_ptSustain, 1000 << 16, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG2_SUSTAINLEVEL,
					   CONN_TRN_NONE,m_ArticParams.m_PitchEG.m_ptSustain);
    }
    
	if(notinrange(m_ArticParams.m_PitchEG.m_tcRelease, Mils2TimeCents(0), 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_EG2_RELEASETIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_PitchEG.m_tcRelease);
    }
    if(notinrange(m_ArticParams.m_PitchEG.m_tcVel2Attack, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_KEYONVELOCITY,
					   CONN_SRC_NONE,
					   CONN_DST_EG2_ATTACKTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_PitchEG.m_tcVel2Attack);
    }
    
	if(notinrange(m_ArticParams.m_PitchEG.m_tcKey2Decay, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_KEYNUMBER,
					   CONN_SRC_NONE,
					   CONN_DST_EG2_DECAYTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_PitchEG.m_tcKey2Decay);
    }

	if(notinrange(m_ArticParams.m_PitchEG.m_tcKey2Hold, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_KEYNUMBER,
					   CONN_SRC_NONE,
					   CONN_DST_EG2_HOLDTIME,
					   CONN_TRN_NONE,
					   m_ArticParams.m_PitchEG.m_tcKey2Hold);
    }

    if (notinrange(m_ArticParams.m_Misc.m_ptDefaultPan, 0, 65535))	
    {
		makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_PAN,
					   CONN_TRN_NONE,
					   m_ArticParams.m_Misc.m_ptDefaultPan);
    }

    if (notinrange(m_ArticParams.m_PitchEG.m_pcRange, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_EG2,
					   CONN_SRC_NONE,
					   CONN_DST_PITCH,
					   CONN_TRN_NONE,
					   m_ArticParams.m_PitchEG.m_pcRange);
    }

	// Filter parameters
	if (notinrange(m_ArticParams.m_FilterParams.m_pcInitialFc, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_FILTER_CUTOFF,
					   CONN_TRN_NONE,
					   m_ArticParams.m_FilterParams.m_pcInitialFc);
    }

	if (notinrange(m_ArticParams.m_FilterParams.m_gcInitialQ, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_NONE,
					   CONN_DST_FILTER_Q,
					   CONN_TRN_NONE,
					   m_ArticParams.m_FilterParams.m_gcInitialQ);
    }

	if (notinrange(m_ArticParams.m_FilterParams.m_pcModLFOToFc, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_LFO,
					   CONN_SRC_NONE,
					   CONN_DST_FILTER_CUTOFF,
					   CONN_TRN_NONE,
					   m_ArticParams.m_FilterParams.m_pcModLFOToFc);
    }

	if (notinrange(m_ArticParams.m_FilterParams.m_pcModLFOCC1ToFc, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_NONE,
					   CONN_SRC_CC1,
					   CONN_DST_FILTER_CUTOFF,
					   CONN_TRN_NONE,
					   m_ArticParams.m_FilterParams.m_pcModLFOCC1ToFc);
    }

	if (notinrange(m_ArticParams.m_FilterParams.m_pcEGToFc, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_EG2,
					   CONN_SRC_NONE,
					   CONN_DST_FILTER_CUTOFF,
					   CONN_TRN_NONE,
					   m_ArticParams.m_FilterParams.m_pcEGToFc);
    }

	if (notinrange(m_ArticParams.m_FilterParams.m_pcVelocityToFc, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_KEYONVELOCITY,
					   CONN_SRC_NONE,
					   CONN_DST_FILTER_CUTOFF,
					   CONN_TRN_NONE,
					   m_ArticParams.m_FilterParams.m_pcVelocityToFc);
    }

	if (notinrange(m_ArticParams.m_FilterParams.m_pcKeyNumToFc, 0, 65535))
    {
        makeconnection(&m_arrConnections[nConnections++],
					   CONN_SRC_KEYNUMBER,
					   CONN_SRC_NONE,
					   CONN_DST_FILTER_CUTOFF,
					   CONN_TRN_NONE,
					   m_ArticParams.m_FilterParams.m_pcKeyNumToFc);
    }

	ASSERT(nConnections <= 24);
}

void CArticulation::GetLevel1Articulation(DMUS_ARTICPARAMS& articParamsDLS1)
{
    ZeroMemory(&articParamsDLS1, sizeof(DMUS_ARTICPARAMS));

    articParamsDLS1.LFO.tcDelay = m_ArticParams.m_LFO.m_tcDelay;
    articParamsDLS1.LFO.pcFrequency = m_ArticParams.m_LFO.m_pcFrequency;
	articParamsDLS1.LFO.gcMWToVolume = m_ArticParams.m_LFO.m_gcMWToVolume;
	articParamsDLS1.LFO.gcVolumeScale = m_ArticParams.m_LFO.m_gcVolumeScale;
	articParamsDLS1.LFO.pcMWToPitch = m_ArticParams.m_LFO.m_pcMWToPitch;
	articParamsDLS1.LFO.pcPitchScale = m_ArticParams.m_LFO.m_pcPitchScale;
    
	articParamsDLS1.VolEG.tcAttack = m_ArticParams.m_VolEG.m_tcAttack;
    articParamsDLS1.VolEG.tcDecay = m_ArticParams.m_VolEG.m_tcDecay;
    articParamsDLS1.VolEG.ptSustain = m_ArticParams.m_VolEG.m_ptSustain;
    articParamsDLS1.VolEG.tcRelease = m_ArticParams.m_VolEG.m_tcRelease;
    articParamsDLS1.VolEG.tcVel2Attack = m_ArticParams.m_VolEG.m_tcVel2Attack;
    articParamsDLS1.VolEG.tcKey2Decay = m_ArticParams.m_VolEG.m_tcKey2Decay;
	
	articParamsDLS1.PitchEG.tcAttack = m_ArticParams.m_PitchEG.m_tcAttack;
    articParamsDLS1.PitchEG.tcDecay = m_ArticParams.m_PitchEG.m_tcDecay;
    articParamsDLS1.PitchEG.ptSustain = m_ArticParams.m_PitchEG.m_ptSustain;
    articParamsDLS1.PitchEG.tcRelease = m_ArticParams.m_PitchEG.m_tcRelease;
    articParamsDLS1.PitchEG.tcVel2Attack = m_ArticParams.m_PitchEG.m_tcVel2Attack;
    articParamsDLS1.PitchEG.tcKey2Decay = m_ArticParams.m_PitchEG.m_tcKey2Decay;
	articParamsDLS1.PitchEG.pcRange = m_ArticParams.m_PitchEG.m_pcRange;
    
	articParamsDLS1.Misc.ptDefaultPan = m_ArticParams.m_Misc.m_ptDefaultPan; 
}

void CArticulation::SetOwner(CInstrument* pInstrument)
{
	ASSERT(pInstrument);
	if(pInstrument)
	{
		m_pInstrument = pInstrument;
		m_pRegion = NULL;
	}
}

void CArticulation::SetOwner(CRegion* pRegion)
{
	ASSERT(pRegion);
	if(pRegion)
	{
		m_pRegion = pRegion;
		m_pInstrument = NULL;
	}
}

void* CArticulation::GetOwner(BOOL& bOwnerIsRegion)
{
	if(m_pInstrument)
	{
		bOwnerIsRegion = FALSE;
		return m_pInstrument;
	}
	else if(m_pRegion)
	{
		bOwnerIsRegion = TRUE;
		return m_pRegion;
	}

	// ERROR!!
	ASSERT(1);
	return NULL;
}

CInstrument* CArticulation::GetInstrument()
{
	if(m_pInstrument)
	{
		return m_pInstrument;
	}
	ASSERT(m_pRegion);
	if(m_pRegion)
	{
		return m_pRegion->GetInstrument();
	}

	return NULL;
}

void CArticulation::SetDLS1(BOOL bDLS1)
{
	m_bDLS1 = bDLS1;
    if(bDLS1)
    {
        m_ArticParams.m_FilterParams.m_pcInitialFc = 0x7FFFFFFF;
    }
}

BOOL CArticulation::IsDLS1()
{
	return m_bDLS1;
}

ArticParams* CArticulation::GetArticParams() 
{
	return(&m_ArticParams);
}


void CArticulation::SetDeleteFlag(bool bDeletingArt)
{
	m_bDeletingArticulation = bDeletingArt;
}


bool CArticulation::GetDeleteFlag()
{
	return m_bDeletingArticulation;
}


CRegion* CArticulation::GetRegion()
{
	return m_pRegion;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\AdpcmLoopWarnDlg.cpp ===
// AdpcmLoopWarnDlg.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "AdpcmLoopWarnDlg.h"
#include "DLSComponent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef DMP_XBOX

#define RESAMPLE_SIZE_CHANGE( dwNewSampleRate, dwOldSampleRate, dwOldSize ) ((__int64(dwNewSampleRate) * __int64(dwOldSize) + __int64(dwOldSampleRate)/2)/__int64(dwOldSampleRate))
#define SIZE_CHANGE_TO_RESAMPLE( dwNewSize, dwOldSize, dwOldSampleRate ) ((__int64(dwOldSampleRate) * __int64(dwNewSize) + __int64(dwOldSize)/2) / __int64(dwOldSize))

/////////////////////////////////////////////////////////////////////////////
// CAdpcmLoopWarnDlg dialog


CAdpcmLoopWarnDlg::CAdpcmLoopWarnDlg(CDLSComponent* pComponent, const DWORD dwSampleRate, const DWORD dwLoopStart, const DWORD dwLoopLength, CWnd* pParent /*=NULL*/)
	: CDialog(CAdpcmLoopWarnDlg::IDD, pParent)
{
	ASSERT( pComponent );
	m_pComponent = pComponent;

	m_dwOrigSampleRate = dwSampleRate;
	m_dwOrigLoopStart = dwLoopStart;
	m_dwOrigLoopLength = dwLoopLength;

	DWORD dwNewLoopSize = (dwLoopLength / 64) * 64 + 64;

	m_dwUpsampleSampleRate = DWORD(SIZE_CHANGE_TO_RESAMPLE( dwNewLoopSize, dwLoopLength, m_dwOrigSampleRate ));
	m_dwUpsampleLoopStart = DWORD(RESAMPLE_SIZE_CHANGE( m_dwUpsampleSampleRate, m_dwOrigSampleRate, m_dwOrigLoopStart ));
	m_dwUpsampleLoopLength = dwNewLoopSize;
	m_dwUpsampleInserted = m_dwUpsampleLoopStart % 64;
	if( m_dwUpsampleInserted )
	{
		m_dwUpsampleInserted = 64 - m_dwUpsampleInserted;
	}
	m_dwUpsampleLoopStart += m_dwUpsampleInserted;

	dwNewLoopSize = (dwLoopLength / 64) * 64;
	if( dwNewLoopSize == 0 )
	{
		m_dwDownsampleSampleRate = 0;
		m_dwDownsampleLoopStart = 0;
		m_dwDownsampleLoopLength = 0;
		m_dwDownsampleInserted = 0;
	}
	else
	{
		m_dwDownsampleSampleRate = DWORD(SIZE_CHANGE_TO_RESAMPLE( dwNewLoopSize, dwLoopLength, m_dwOrigSampleRate ));
		m_dwDownsampleLoopStart = DWORD(RESAMPLE_SIZE_CHANGE( m_dwDownsampleSampleRate, m_dwOrigSampleRate, m_dwOrigLoopStart ));
		m_dwDownsampleLoopLength = dwNewLoopSize;
		m_dwDownsampleInserted = m_dwDownsampleLoopStart % 64;
		if( m_dwDownsampleInserted )
		{
			m_dwDownsampleInserted = 64 - m_dwDownsampleInserted;
		}
		m_dwDownsampleLoopStart += m_dwDownsampleInserted;
	}

	m_xbChange = XBADPCM_UPSAMPLE;

	//{{AFX_DATA_INIT(CAdpcmLoopWarnDlg)
	//}}AFX_DATA_INIT
}


void CAdpcmLoopWarnDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAdpcmLoopWarnDlg)
	DDX_Control(pDX, IDC_CHECK_NOT_AGAIN, m_checkNotAgain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAdpcmLoopWarnDlg, CDialog)
	//{{AFX_MSG_MAP(CAdpcmLoopWarnDlg)
	ON_BN_CLICKED(IDC_CHECK_NOT_AGAIN, OnCheckNotAgain)
	ON_BN_DOUBLECLICKED(IDC_CHECK_NOT_AGAIN, OnDoubleclickedCheckNotAgain)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAdpcmLoopWarnDlg message handlers

void CAdpcmLoopWarnDlg::OnCheckNotAgain() 
{
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}

	int nCheck = m_checkNotAgain.GetCheck();
	m_pComponent->SetBadXboxLoopWarning(nCheck == 0 ? false : true);
}

void CAdpcmLoopWarnDlg::OnDoubleclickedCheckNotAgain() 
{
	OnCheckNotAgain();
}

BOOL CAdpcmLoopWarnDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	SetDlgItemInt( IDC_EDIT_ORIGINAL_RATE, m_dwOrigSampleRate, FALSE );
	SetDlgItemInt( IDC_EDIT_ORIGINAL_LOOP_START, m_dwOrigLoopStart, FALSE );
	SetDlgItemInt( IDC_EDIT_ORIGINAL_LOOP_END, m_dwOrigLoopStart + m_dwOrigLoopLength - 1, FALSE );
	SetDlgItemInt( IDC_EDIT_ORIGINAL_INSERTED, 0, FALSE );

	SetDlgItemInt( IDC_EDIT_UPSAMPLE_RATE, m_dwUpsampleSampleRate, FALSE );
	SetDlgItemInt( IDC_EDIT_UPSAMPLE_LOOP_START, m_dwUpsampleLoopStart, FALSE );
	SetDlgItemInt( IDC_EDIT_UPSAMPLE_LOOP_END, m_dwUpsampleLoopStart + m_dwUpsampleLoopLength - 1, FALSE );
	SetDlgItemInt( IDC_EDIT_UPSAMPLE_INSERTED, m_dwUpsampleInserted, FALSE );

	SetDlgItemInt( IDC_EDIT_DOWNSAMPLE_RATE, m_dwDownsampleSampleRate, FALSE );
	SetDlgItemInt( IDC_EDIT_DOWNSAMPLE_LOOP_START, m_dwDownsampleLoopStart, FALSE );
	SetDlgItemInt( IDC_EDIT_DOWNSAMPLE_LOOP_END, m_dwDownsampleLoopStart + m_dwDownsampleLoopLength - 1, FALSE );
	SetDlgItemInt( IDC_EDIT_DOWNSAMPLE_INSERTED, m_dwDownsampleInserted, FALSE );

	// If downsampling isn't an option
	if( m_dwDownsampleSampleRate == 0 )
	{
		// Disable the downsample button
		CWnd *pWnd = GetDlgItem( IDC_RADIO_DOWNSAMPLE );
		if( pWnd )
		{
			pWnd->EnableWindow( FALSE );
		}
	}

	CheckRadioButton( IDC_RADIO_UPSAMPLE, IDC_RADIO_ORIGINAL, IDC_RADIO_UPSAMPLE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAdpcmLoopWarnDlg::OnOK() 
{
	switch( GetCheckedRadioButton( IDC_RADIO_UPSAMPLE, IDC_RADIO_ORIGINAL ) )
	{
	case IDC_RADIO_UPSAMPLE:
		m_xbChange = XBADPCM_UPSAMPLE;
		break;
	case IDC_RADIO_DOWNSAMPLE:
		m_xbChange = XBADPCM_DOWNSAMPLE;
		break;
	case IDC_RADIO_ORIGINAL:
		m_xbChange = XBADPCM_ORIG;
		break;
	}

	CDialog::OnOK();
}
#endif //DMP_XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\AdpcmLoopWarnDlg.h ===
#if !defined(AFX_ADPCMLOOPWARNDLG_H__1C883E89_70C1_4235_95F7_D99E74525578__INCLUDED_)
#define AFX_ADPCMLOOPWARNDLG_H__1C883E89_70C1_4235_95F7_D99E74525578__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AdpcmLoopWarnDlg.h : header file
//

#ifdef DMP_XBOX

#include "resource.h"

class CDLSComponent;


typedef enum {
	XBADPCM_ORIG,
	XBADPCM_UPSAMPLE,
	XBADPCM_DOWNSAMPLE
} XBADPCM_CHANGE;

/////////////////////////////////////////////////////////////////////////////
// CAdpcmLoopWarnDlg dialog

class CAdpcmLoopWarnDlg : public CDialog
{
// Construction
public:
	CAdpcmLoopWarnDlg(CDLSComponent* pComponent, const DWORD dwSampleRate, const DWORD dwLoopStart, const DWORD dwLoopLength, CWnd* pParent = NULL);   // standard constructor

	DWORD m_dwOrigSampleRate;
	DWORD m_dwOrigLoopStart;
	DWORD m_dwOrigLoopLength;

	DWORD m_dwUpsampleSampleRate;
	DWORD m_dwUpsampleLoopStart;
	DWORD m_dwUpsampleLoopLength;
	DWORD m_dwUpsampleInserted;

	DWORD m_dwDownsampleSampleRate;
	DWORD m_dwDownsampleLoopStart;
	DWORD m_dwDownsampleLoopLength;
	DWORD m_dwDownsampleInserted;

	XBADPCM_CHANGE m_xbChange;

// Dialog Data
	//{{AFX_DATA(CAdpcmLoopWarnDlg)
	enum { IDD = IDD_ADPCM_LOOP_WARNING };
	CButton	m_checkNotAgain;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdpcmLoopWarnDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAdpcmLoopWarnDlg)
	afx_msg void OnCheckNotAgain();
	afx_msg void OnDoubleclickedCheckNotAgain();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CDLSComponent* m_pComponent;
};

#endif // DMP_XBOX

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADPCMLOOPWARNDLG_H__1C883E89_70C1_4235_95F7_D99E74525578__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\adsrenvelope.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "adsrenvelope.h"

/////////////////////////////////////////////////////////////////////////////
// CADSREnvelope

IMPLEMENT_DYNCREATE(CADSREnvelope, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CADSREnvelope properties

long CADSREnvelope::GetReleaseTime()
{
	long result;
	GetProperty(0x1, VT_I4, (void*)&result);
	return result;
}

void CADSREnvelope::SetReleaseTime(long propVal)
{
	SetProperty(0x1, VT_I4, propVal);
}

long CADSREnvelope::GetAttackTime()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CADSREnvelope::SetAttackTime(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

long CADSREnvelope::GetDecayTime()
{
	long result;
	GetProperty(0x3, VT_I4, (void*)&result);
	return result;
}

void CADSREnvelope::SetDecayTime(long propVal)
{
	SetProperty(0x3, VT_I4, propVal);
}

long CADSREnvelope::GetSustainLevel()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

void CADSREnvelope::SetSustainLevel(long propVal)
{
	SetProperty(0x4, VT_I4, propVal);
}


long CADSREnvelope::GetDelayTime()
{
	long result;
	GetProperty(0x5, VT_I4, (void*)&result);
	return result;
}

void CADSREnvelope::SetDelayTime(long propVal)
{
	SetProperty(0x5, VT_I4, propVal);
}


long CADSREnvelope::GetHoldTime()
{
	long result;
	GetProperty(0x6, VT_I4, (void*)&result);
	return result;
}

void CADSREnvelope::SetHoldTime(long propVal)
{
	SetProperty(0x6, VT_I4, propVal);
}

void CADSREnvelope::SetDLS1(BOOL bDLS1)
{
	static BYTE parms[] = VTS_BOOL;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms, bDLS1);
}


/////////////////////////////////////////////////////////////////////////////
// CADSREnvelope operations

void CADSREnvelope::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Articulation.h ===
#ifndef __ARTICULATION_H__
#define __ARTICULATION_H__

// Articulation.h : header file
//

#include "DLSComponent.h"
#include "DLSDocType.h"
#include "RiffStrm.h"
#include "DLSLoadSaveUtils.h"
#include "dls1.h"
#include "UnknownChunk.h"

#define TOTAL_CONNECTIONS	25

#define MAXADSRTIME		40000

#define DELAY_COLOR		RGB(0, 0, 0)		// Delay segment color
#define ATTACK_COLOR	RGB(255, 0, 0)		// Attack segment color
#define HOLD_COLOR		RGB(255, 0, 255)	// Hold segment color
#define DECAY_COLOR		RGB(0, 128, 64)		// Decay segment color
#define SUSTAIN_COLOR	RGB(0, 0, 0)		// Sustain segment color same as the delay color
#define RELEASE_COLOR	RGB(0, 0, 255)		// Release segment color

class CConditionalChunk;

class CArticulation : public AListItem, public IDMUSProdNode, public IPersistStream
{

public:
    CArticulation(CDLSComponent* pComponent, CInstrument* pInstrument);
	CArticulation(CDLSComponent* pComponent, CRegion* pRegion);

	~CArticulation();

	// AListItem Method
	CArticulation* GetNext();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnResourceId);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit(HMENU hMenu);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect(long lCommandId);

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode** ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo(DMUSProdListInfo* pListInfo);

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );
    // IDMUSProdNode : drag & drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );
    
	// IPersist functions
    STDMETHOD(GetClassID)(CLSID* pClsId);

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	//Additional functions
public:

	DWORD PrepareTags(DWORD dwTag);
    HRESULT Load(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT Save(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT Write(void* pv, DWORD* pdwCurrentOffset, DWORD* pDMWOffsetTable, DWORD* pdwCurIndex, DWORD dwNextArtIndex);
	ArticParams* GetArticParams();

	CInstrument*	GetInstrument();
	CRegion*		GetRegion();

	// General purpose accessors/mutators
	void*	GetOwner(BOOL& bOwnerIsRegion);
	void	SetOwner(CInstrument* pInstrument);
	void	SetOwner(CRegion* pRegion);

	BOOL	IsDLS1();
	void	SetDLS1(BOOL bDLS1);

	void	SetDeleteFlag(bool bDeletingArt);
	bool	GetDeleteFlag();

#ifdef _DEBUG
	// You want to call ValidateParent in debug mode every time you either 
	// reference m_pInstrument or m_pRegion.
	void ValidateParent(); 
#endif

protected:
	void InitDefaultArticParams();
	void CreateConnectionList(UINT& nConnections);
	void GetLevel1Articulation(DMUS_ARTICPARAMS& articParamsDLS1);

public:
	DWORD Count();
	DWORD Size();
	CDLSComponent*		m_pComponent;

private:
    DWORD				m_dwRef;
	IDMUSProdNode*		m_pIRootNode;
	IDMUSProdNode*		m_pIParentNode;

	CONNECTION			m_arrConnections[TOTAL_CONNECTIONS];
	
	CInstrument*		m_pInstrument;		// Instrument that owns this, or
    CRegion*			m_pRegion;			// Region that owns this.

    ArticParams			m_ArticParams;		// Articulation data.
	DWORD				m_dwEditTag;		// Tag for edit downloads.
	bool				m_bDeletingArticulation;
	BOOL				m_bDLS1;
	BOOL				m_bOwnerIsInstrument;
};

#endif // __ARTICULATION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ArticulationTabCtrl.cpp ===
// ArticulationTabCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "ArticulationTabCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CArticulationTabCtrl

CArticulationTabCtrl::CArticulationTabCtrl()
{
}

CArticulationTabCtrl::~CArticulationTabCtrl()
{
}


BEGIN_MESSAGE_MAP(CArticulationTabCtrl, CTabCtrl)
	//{{AFX_MSG_MAP(CArticulationTabCtrl)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArticulationTabCtrl message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ArticulationList.cpp ===
// ArticulationList.cpp : implementation file
//

#include "stdafx.h"
#include "DlsDefsPlus.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"

#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "ConditionalChunk.h"
#include "Articulation.h"
#include "ArticulationList.h"
#include "InstrumentCtl.h"
#include "InstrumentFVEditor.h"

#include "ArticulationListPropPageMgr.h"
#include "ArticulationListPropPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CArticulationList constructor/destructor

CArticulationList::CArticulationList(CDLSComponent* pComponent, CInstrument* pOwnerInstrument) :
m_dwRef(0),
m_pIRootNode(NULL),
m_pIParentNode(NULL),
m_pArticListPropPageMgr(NULL),
m_pDLSComponent(pComponent),
m_pInstrument(pOwnerInstrument),
m_pOwnerRegion(NULL),
m_pConditionalChunk(NULL),
m_bDLS1(FALSE),
m_bConditionOK(TRUE),
m_bOwnerIsInstrument(TRUE)
{
	AddRef();
	CArticulation* pArticulation = new CArticulation(pComponent, pOwnerInstrument);
	AddTail(pArticulation);

	if(m_pArticListPropPageMgr == NULL)
	{
		m_pArticListPropPageMgr = new CArticulationListPropPageMgr();
	}

	if(m_pConditionalChunk == NULL)
	{
		m_pConditionalChunk = new CConditionalChunk(m_pDLSComponent);
	}
}


CArticulationList::CArticulationList(CDLSComponent* pComponent, CRegion* pOwnerRegion) :
m_dwRef(0),
m_pIRootNode(NULL),
m_pIParentNode(NULL),
m_pArticListPropPageMgr(NULL),
m_pDLSComponent(pComponent),
m_pInstrument(NULL),
m_pOwnerRegion(pOwnerRegion),
m_pConditionalChunk(NULL),
m_bDLS1(FALSE),
m_bConditionOK(TRUE),
m_bOwnerIsInstrument(FALSE)
{
	AddRef();
	m_pInstrument = pOwnerRegion->GetInstrument();
	CArticulation* pArticulation = new CArticulation(pComponent, pOwnerRegion);
	AddTail(pArticulation);

	if(m_pArticListPropPageMgr == NULL)
	{
		m_pArticListPropPageMgr = new CArticulationListPropPageMgr();
	}
	
	if(m_pConditionalChunk == NULL)
	{
		m_pConditionalChunk = new CConditionalChunk(m_pDLSComponent);
	}
}

CArticulationList::~CArticulationList()
{

	// If we are in a Property Page Manager we need to remove ourselves before we go away
	IDMUSProdPropSheet *pIPropSheet;
	if(SUCCEEDED(m_pDLSComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**) &pIPropSheet)))
	{
		if(pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
		{
			pIPropSheet->RemovePageManagerByObject(this);
		}
		else
		{
			if(m_pArticListPropPageMgr)
			{
				m_pArticListPropPageMgr->RemoveObject(this);
			}
		}
		pIPropSheet->Release();
	}

	if(m_pArticListPropPageMgr)
	{
		DWORD dwRefCount = m_pArticListPropPageMgr->Release();
		if(dwRefCount == 0)
		{
			m_pArticListPropPageMgr = NULL;
		}
	}


	while(!IsEmpty())
	{
        CArticulation* pArticulation = RemoveHead();
        pArticulation->Release();
	}
	
	if(m_pConditionalChunk)
	{
		delete m_pConditionalChunk;
		m_pConditionalChunk = NULL;
	}

}

void CArticulationList::AddTail(CArticulation* pINode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pINode);
	
	AList::AddTail((AListItem*) pINode);
}

CArticulation* CArticulationList::GetHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return (CArticulation*) AList::GetHead();
}

CArticulation* CArticulationList::RemoveHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return (CArticulation*) AList::RemoveHead();
}

void CArticulationList::Remove(CArticulation* pINode) 
{ 
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pINode);
	
	AList::Remove((AListItem*) pINode);
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IUnknown implementation

HRESULT CArticulationList::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if(::IsEqualIID(riid, IID_IDMUSProdNode) || ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IPersistStream))
	{
		AddRef();
		*ppvObj = (IPersistStream*)this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IDMUSProdPropPageObject))
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CArticulationList::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CArticulationList::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetNodeImageIndex

HRESULT CArticulationList::GetNodeImageIndex(short* pnFirstImage)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnFirstImage);
	
	ASSERT(m_pDLSComponent != NULL);

	if(m_bConditionOK)
	{
		return(m_pDLSComponent->GetFolderImageIndex(pnFirstImage));
	}
	else
	{
		return(m_pDLSComponent->GetFolderGrayedImageIndex(pnFirstImage));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetComponent

HRESULT CArticulationList::GetComponent(IDMUSProdComponent** ppIComponent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(m_pDLSComponent != NULL);
	ASSERT(ppIComponent);

	return m_pDLSComponent->QueryInterface(IID_IDMUSProdComponent, (void**)ppIComponent);
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetRootNode

HRESULT CArticulationList::GetDocRootNode(IDMUSProdNode** ppIRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pIRootNode != NULL);

	m_pIRootNode->AddRef();
	*ppIRootNode = m_pIRootNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::SetRootNode

HRESULT CArticulationList::SetDocRootNode(IDMUSProdNode* pIRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIRootNode != NULL );

	m_pIRootNode = pIRootNode;
//	m_pIRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetParentNode

HRESULT CArticulationList::GetParentNode(IDMUSProdNode** ppIParentNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pIParentNode != NULL);

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::SetParentNode

HRESULT CArticulationList::SetParentNode(IDMUSProdNode* pIParentNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetNodeId

HRESULT CArticulationList::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_ArticulationFolderNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetNodeName

HRESULT CArticulationList::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pbstrName);

	CString strName;
	TCHAR achBuffer[BUFFER_128];

	if(::LoadString(theApp.m_hInstance, IDS_ARTICULATION_FOLDER_NAME, achBuffer, BUFFER_128))
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetNodeNameMaxLength

HRESULT CArticulationList::GetNodeNameMaxLength(short* pnMaxLength)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMaxLength);
	
	*pnMaxLength = -1; // Can't rename a Articulation folder

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::ValidateNodeName

HRESULT CArticulationList::ValidateNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Just free bstrName; can't rename Articulations folder
	::SysFreeString(bstrName);

	return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::SetNodeName

HRESULT CArticulationList::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't rename a Articulation folder
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetEditorClsId

HRESULT CArticulationList::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't edit a Articulation folder
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetEditorTitle

HRESULT CArticulationList::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't edit a Articulation folder
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetEditorWindow

HRESULT CArticulationList::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't edit a Articulation folder
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::SetEditorWindow

HRESULT CArticulationList::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't edit a Articulation folder
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::UseOpenCloseImages

HRESULT CArticulationList::UseOpenCloseImages(BOOL* pfUseOpenCloseImages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pfUseOpenCloseImages);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetRightClickMenuId

HRESULT CArticulationList::GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMenuId);
	ASSERT(phInstance);

	*phInstance = theApp.m_hInstance;
	*pnMenuId = IDM_ARTICULATIONLIST_NODE_RMENU;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::OnRightClickMenuInit

HRESULT CArticulationList::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL status = EnableMenuItem(hMenu, IDM_NEW_ARTICULATION, MF_BYCOMMAND | MF_ENABLED);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::OnRightClickMenuSelect

HRESULT CArticulationList::OnRightClickMenuSelect(long lCommandId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	switch(lCommandId)
	{
		case IDM_NEW_ARTICULATION:
		{
			if(m_pInstrument)
			{
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_INSERT_ARTICULATION)))
					return E_FAIL;
			}
			hr = InsertChildNode(NULL);
			break;
		}
		
		case IDM_PROPERTIES:
		{
			hr = OnShowProperties();
			break;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::DeleteChildNode

HRESULT CArticulationList::DeleteChildNode(IDMUSProdNode* pIChildNode, BOOL fPromptUser)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIChildNode != NULL);
	ASSERT(m_pDLSComponent != NULL);
	ASSERT(m_pDLSComponent->m_pIFramework != NULL);

	// Remove node from Project Tree
	if( m_pDLSComponent->m_pIFramework->RemoveNode(pIChildNode, fPromptUser) == S_FALSE )
	{
		return E_FAIL;
	}

	if(m_pInstrument)
	{
		if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_ARTICULATION_DELETE)))
		{
			// Out Of Memory!!! Do we need to add the node back to the tre???
			// Will it go through??
			return E_FAIL;
		}
	}

	// Remove from list
	Remove((CArticulation*)pIChildNode);
	pIChildNode->Release();

	// Set flag so we know to save file 
	if(m_pInstrument)
	{
		if(GetCount() == 0)
		{
			if(m_bOwnerIsInstrument == false)
			{
				ASSERT(m_pOwnerRegion);
				m_pOwnerRegion->SetCurrentArticulation(NULL);
			}
			else
			{
				m_pInstrument->SetFirstGlobaArtAsCurrent();
				m_pInstrument->CheckRegionsForLocalArts();
			}
		}

		m_pInstrument->m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::InsertChildNode

HRESULT CArticulationList::InsertChildNode(IDMUSProdNode* pIChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pDLSComponent);
	if(m_pDLSComponent == NULL)
	{
		return E_FAIL;
	}
	if(m_pInstrument == NULL)
	{
		return E_FAIL;
	}
	
	if(pIChildNode== NULL)
	{
		if(m_bOwnerIsInstrument)
		{
			pIChildNode = new CArticulation(m_pDLSComponent, m_pInstrument);
		}
		else
		{
			ASSERT(m_pOwnerRegion);
			pIChildNode = new CArticulation(m_pDLSComponent, m_pOwnerRegion);
		}

		if(pIChildNode == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}

	// Add to the articulation list
	AddTail((CArticulation*)pIChildNode);
	
	// Set root and parent node of ALL children
	theApp.SetNodePointers( pIChildNode, (IDMUSProdNode *)(m_pInstrument->m_pCollection), (IDMUSProdNode *)this );
	
	// Add node to Project Tree
	if(!SUCCEEDED(m_pDLSComponent->m_pIFramework->AddNode(pIChildNode, (IDMUSProdNode *)this)))
	{
		DeleteChildNode( pIChildNode, FALSE );
		return E_FAIL;
	}

	return S_OK;
} 

////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::DeleteNode

HRESULT CArticulationList::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if(m_pIParentNode)
	{
		HRESULT hr = m_pIParentNode->DeleteChildNode(this, fPromptUser);
		return hr;
	}

	return E_FAIL;
}

//////////////////////////////////////////////////////////////////////
//
//	CArticulationList IDMUSProdNode::GetFirstChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::GetFirstChild(IDMUSProdNode** ppIFirstChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppIFirstChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppIFirstChildNode = NULL;

	IDMUSProdNode* pINode = (IDMUSProdNode*) GetHead();

	if(pINode)
	{
		pINode->AddRef();
		*ppIFirstChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CArticulationList IDMUSProdNode::GetNextChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppINextChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppINextChildNode = NULL;

	if(pIChildNode == NULL)
	{
		return E_INVALIDARG;
	}

	IDMUSProdNode* pINode = (IDMUSProdNode*) ((CArticulation*) pIChildNode)->GetNext();

	if(pINode)
	{
		pINode->AddRef();
		*ppINextChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CArticulationList IDMUSProdNode::GetNodeListInfo
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::GetNodeListInfo(DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pListInfo);
	
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::OnNodeSelChanged

HRESULT CArticulationList::OnNodeSelChanged(BOOL fSelected)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IDMUSProdNode::CreateDataObject
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IDMUSProdNode::CanCut
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::CanCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IDMUSProdNode::CanCopy
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::CanCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IDMUSProdNode::CanDelete
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::CanDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IDMUSProdNode::CanDeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IDMUSProdNode::CanPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IDMUSProdNode::PasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IDMUSProdNode::CanChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												   BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IDMUSProdNode::ChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdNode::GetObject

HRESULT CArticulationList::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdPropPageObject::GetData

HRESULT CArticulationList::GetData(void** ppData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(ppData);

	*ppData = this;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdPropPageObject::SetData

HRESULT CArticulationList::SetData(void* pData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pData);

	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CArticulationList::OnRemoveFromPageManager(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IDMUSProdPropPageObject::OnShowProperties

HRESULT CArticulationList::OnShowProperties(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	ASSERT(m_pDLSComponent);
	ASSERT(m_pDLSComponent->m_pIFramework);

	// Show the Collection properties
	IDMUSProdPropSheet* pIPropSheet;

	hr = m_pDLSComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet);
	if(SUCCEEDED(hr))
	{
		hr = pIPropSheet->SetPageManager(m_pArticListPropPageMgr);
		
		if(SUCCEEDED(hr))
		{
			m_pArticListPropPageMgr->SetObject(this);
			pIPropSheet->SetActivePage(0); 
		}

		pIPropSheet->Show(TRUE);
		pIPropSheet->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CArticulationList IPersist::GetClassID

HRESULT CArticulationList::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
// CArticulationList IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IPersistStream::IsDirty
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::IsDirty()
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IPersistStream::GetSizeMax
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CArticulationList IPersistStream::Load
//
//////////////////////////////////////////////////////////////////////
HRESULT CArticulationList::Load(IStream* pIStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	DWORD cbRead = 0;

	// Read the number of articulations saved
	int nArtCount = 0;
	HRESULT hr = pIStream->Read((void*)&nArtCount, sizeof(int), &cbRead);
	if(FAILED(hr) || cbRead != sizeof(int))
	{
		return E_FAIL;
	}

	// Match up the number of saved articulations to those in hand
	int nExistentArts = GetCount();
	if(nExistentArts < nArtCount)
	{
		for(int nCount = 0; nCount < (nArtCount - nExistentArts); nCount++)
		{
			if(FAILED(hr = InsertChildNode(NULL)))
			{
				return hr;
			}
		}
	}
	else if(nExistentArts > nArtCount)
	{
		for(int nCount = 0; nCount < (nExistentArts - nArtCount); nCount++)
		{
			CArticulation* pArt = RemoveHead();
			ASSERT(pArt);
			if(pArt)
			{
				// Remove node from Project Tree
				pArt->SetDeleteFlag(true);
				if(m_pDLSComponent->m_pIFramework->RemoveNode(pArt, FALSE) == S_FALSE )
				{
					return E_FAIL;
				}
				pArt->Release();
			}
		}
	}

	// Now load into the articulations
	CArticulation* pArt = GetHead();
	while(pArt)
	{
		if(FAILED(hr = pArt->Load(pIStream)))
		{
			return hr;
		}

		pArt = pArt->GetNext();
	}

	return S_OK;
}

HRESULT CArticulationList::Save(IStream* pIStream, BOOL fCLearDirty)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Save the number of artculations in the list
	int nArtCount = GetCount();

	DWORD cbCount = 0;
	HRESULT hr = pIStream->Write((void*)&nArtCount, sizeof(int), &cbCount);
	if(FAILED(hr) || cbCount != sizeof(int)) 
	{
		return E_FAIL;
	}

	// Save the Articulations now
	CArticulation* pArt = GetHead();
	while(pArt)
	{
		if(FAILED(hr = pArt->Save(pIStream, FALSE)))
		{
			return hr;
		}

		pArt = pArt->GetNext();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationList::Load

HRESULT CArticulationList::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{    
	AFX_MANAGE_STATE(_afxModuleAddrThis);
		
	HRESULT hr = E_FAIL;
	
	MMCKINFO ck;
	ck.ckid = 0;
	ck.fccType = 0;

	// Delete all previous articulations
	DeleteAllArticulations();

	while(pIRiffStream->Descend(&ck, pckMain, MMIO_FINDCHUNK) == 0)
	{
		switch(ck.ckid)
		{
			case FOURCC_CDL:
			{
				ASSERT(m_pConditionalChunk);
				if(m_pConditionalChunk == NULL)
				{
					return E_FAIL;
				}
				
				if(FAILED(hr = m_pConditionalChunk->Load(pIRiffStream, &ck)))
				{
					return hr;
				}

				break;
			}

			case FOURCC_ART2:
			case FOURCC_ART1:
			{
				BOOL bDLS1 = (ck.ckid == FOURCC_ART1) ? TRUE : FALSE;

				CArticulation* pArticulation = NULL;
				if(m_bOwnerIsInstrument)
				{
					pArticulation = new CArticulation(m_pDLSComponent, m_pInstrument);
				}
				else
				{
					ASSERT(m_pOwnerRegion);
					pArticulation = new CArticulation(m_pDLSComponent, m_pOwnerRegion);
				}

				if(pArticulation == NULL)
				{
					return E_OUTOFMEMORY;
				}

				pArticulation->SetDLS1(bDLS1);

				if(FAILED(hr = pArticulation->Load(pIRiffStream)))
				{
					delete pArticulation;
					return E_FAIL;
				}

				// Add it to the list
				AddTail(pArticulation);

				break;
			}
			
			case mmioFOURCC('e','d','i','t'):   // Ignore edits while loading.
			{
                break;
			}

            default:    
			{
                m_UnknownChunk.Load(pIRiffStream, &ck, FALSE);
                break;
			}
		}

        pIRiffStream->Ascend(&ck, 0);
		ck.ckid = 0;
		ck.fccType = 0;
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CArticulationList::Save

HRESULT CArticulationList::Save(IDMUSProdRIFFStream* pIRiffStream)
{
	// No articulations so don't do anything
	if(GetCount() == 0)
	{
		return S_OK;
	}

	HRESULT hr = E_FAIL;
	MMCKINFO ck;
	ck.fccType = FOURCC_LAR2;
	if(m_bDLS1 == TRUE)
	{
		ck.fccType = FOURCC_LART;
	}

	if(SUCCEEDED(hr = pIRiffStream->CreateChunk(&ck, MMIO_CREATELIST)))
	{
		// Save the conditional chunk first
		if(m_pConditionalChunk)
		{
			if(FAILED(m_pConditionalChunk->Save(pIRiffStream)))
			{
				return E_FAIL;
			}
		}

		// Now save all the articulations
		CArticulation* pArtic = GetHead();
		while(pArtic)
		{
			if(FAILED(hr = pArtic->Save(pIRiffStream)))
			{
				return hr;
			}

			pArtic = pArtic->GetNext();
		}

		pIRiffStream->Ascend(&ck, 0);
	}

	// Save the unknown chunks in the list
    m_UnknownChunk.Save(pIRiffStream);

	return hr;
}

void CArticulationList::SetOwner(CInstrument* pInstrument)
{
	ASSERT(pInstrument);
	if(pInstrument == NULL)
	{
		return;
	}

	m_pOwnerRegion = NULL;
	m_pInstrument = pInstrument;
	m_bOwnerIsInstrument = TRUE;

	CArticulation* pArtic = GetHead();
	while(pArtic)
	{
		pArtic->SetOwner(pInstrument);
		pArtic = pArtic->GetNext();
	}
}

void CArticulationList::SetOwner(CRegion* pRegion)
{
	ASSERT(pRegion);
	if(pRegion == NULL)
	{
		return;
	}

	m_pOwnerRegion = pRegion;
	m_pInstrument = pRegion->m_pInstrument;
	m_bOwnerIsInstrument = FALSE;

	CArticulation* pArtic = GetHead();
	while(pArtic)
	{
		pArtic->SetOwner(pRegion);
		pArtic = pArtic->GetNext();
	}
}


void CArticulationList::DeleteAllArticulations()
{
	while(!IsEmpty())
	{
		CArticulation* pArtic = GetHead();
		// This articulation might not be in the tree...
		// dummy instruments and first-time default articulations
		if(FAILED(pArtic->DeleteNode(FALSE)))
		{
			Remove(pArtic);
			delete pArtic;
		}
	}
}

void CArticulationList::SetDLS1(BOOL bDLS1)
{
	m_bDLS1 = bDLS1;
}

BOOL CArticulationList::IsDLS1()
{
	return m_bDLS1;
}

CConditionalChunk* CArticulationList::GetConditionalChunk()
{
	return m_pConditionalChunk;
}


CCollection* CArticulationList::GetCollection()
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return NULL;
	}

	return m_pInstrument->GetCollection();
}


HRESULT CArticulationList::SetCondition(const CString& sCondition)
{
	ASSERT(m_pConditionalChunk);
	if(m_pConditionalChunk == NULL)
	{
		return E_FAIL;
	}

	return m_pConditionalChunk->RegularToRPN(sCondition);
}


DWORD CArticulationList::Count()
{
	if(!m_bConditionOK)
	{
		return 0;
	}

	// Must have an instrument right?
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return 0;
	}

	BOOL bNewFormat = FALSE;
	if(m_pInstrument)
	{
		bNewFormat = m_pInstrument->SupportsNewFormat();
	}

	DWORD dwCount = m_UnknownChunk.GetCount();
	CArticulation* pArticulation = GetHead();
	while(pArticulation)
	{
		dwCount += pArticulation->Count();

		// If the new format for downoad is not supported then use only the first articulation
		if(!bNewFormat)
		{
			break;
		}
		pArticulation = pArticulation->GetNext();
	}

	return  dwCount;
}


DWORD CArticulationList::Size()
{
	if(!m_bConditionOK)
	{
		return 0;
	}

	// Must have an instrument right?
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return 0;
	}

	BOOL bNewFormat = FALSE;
	if(m_pInstrument)
	{
		bNewFormat = m_pInstrument->SupportsNewFormat();
	}


	// Go through all the articulations and find out the largest required size
	DWORD dwSize = 0;
	CArticulation* pArticulation = GetHead();
	while(pArticulation)
	{
		dwSize += pArticulation->Size();

		// If the new format for downoad is not supported then use only the first articulation
		if(!bNewFormat)
		{
			break;
		}
		pArticulation = pArticulation->GetNext();
	}

	// Calculate the space need for the extension chunks
	CUnknownChunkItem* pExtChk = m_UnknownChunk.GetHead();
	for(; pExtChk; pExtChk = (CUnknownChunkItem*)pExtChk->GetNext())
	{
		dwSize += CHUNK_ALIGN(pExtChk->Size());
	}


	return dwSize;
}


HRESULT CArticulationList::Write(void* pv, DWORD* pdwRelativeOffset, DWORD* pdwCurrentOffset, DWORD* pDMWOffsetTable, DWORD* pdwCurIndex)
{
	HRESULT hr = E_FAIL;

	// Must have an instrument right?
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return E_FAIL;
	}

	if(!m_bConditionOK)
	{
		return S_OK;
	}

    // No articulations to write
    if(GetCount() == 0)
    {
        return S_OK;
    }


	BOOL bNewFormat = FALSE;
	if(m_pInstrument)
	{
		bNewFormat = m_pInstrument->SupportsNewFormat();
	}

	// Write down all articulations in series...
	CArticulation* pArticulation = GetHead();
	while(pArticulation)
	{
		DWORD dwNextArtIndex = 0;
		CArticulation* pNextArt = pArticulation->GetNext();
		if(pNextArt && bNewFormat)
		{
			dwNextArtIndex = *pdwCurIndex + pArticulation->Count();
		}

		pDMWOffsetTable[(*pdwCurIndex)++] = *pdwCurrentOffset;
		// Store current position to calculate new dwRelativeCurOffset.
        DWORD dwOffsetStart = *pdwCurrentOffset; 


		if(FAILED(hr = pArticulation->Write((BYTE*)pv + *pdwRelativeOffset, pdwCurrentOffset, pDMWOffsetTable, pdwCurIndex, dwNextArtIndex)))
		{
			return E_FAIL;
		}

		if(!m_bOwnerIsInstrument)
		{
			*pdwRelativeOffset += (*pdwCurrentOffset - dwOffsetStart);
		}
		else
		{
			*pdwRelativeOffset = *pdwCurrentOffset;
		}

		pArticulation = pArticulation->GetNext();
	}

	// Write down the extension chunks...
	CUnknownChunkItem* pExtChk = m_UnknownChunk.GetHead();
	DWORD dwCountExtChk = m_UnknownChunk.GetCount();
	DWORD dwIndexNextExtChk = 0;
	
	for(; pExtChk && SUCCEEDED(hr); pExtChk = (CUnknownChunkItem*) pExtChk->GetNext())
	{
		if(dwCountExtChk == 1)
		{
			dwIndexNextExtChk = 0;
		}
		else
		{
			dwIndexNextExtChk = *pdwCurIndex + 1;
		}

		pDMWOffsetTable[*pdwCurIndex] = *pdwCurrentOffset;
		hr = pExtChk->Write(((BYTE *)pv + *pdwCurrentOffset), pdwCurrentOffset,	dwIndexNextExtChk);
		
		dwCountExtChk--;
		(*pdwCurIndex)++;
	}

	return hr;
}


void CArticulationList::OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode)
{
	m_bConditionOK = TRUE;

	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		m_bConditionOK = FALSE;
	}


	ASSERT(m_pDLSComponent);
	if(m_pDLSComponent == NULL)
	{
		m_bConditionOK = FALSE;
	}

	ASSERT(m_pDLSComponent->m_pIFramework);
	if(m_pDLSComponent->m_pIFramework == NULL)
	{
		m_bConditionOK = FALSE;
	}
	
	IDMUSProdFramework* pIFramework = m_pDLSComponent->m_pIFramework;
	ASSERT(m_pConditionalChunk);
	if(m_pConditionalChunk == NULL)
	{
		m_bConditionOK = FALSE;
	}

	// Need to evaluate the condition based on the configuration...something like...
	m_bConditionOK = m_pConditionalChunk->Evaluate(pCurrentConfig);

	// If this list is owned by a region, then give it a chance to revert to the 
	// global articulation in case no local articulation is going to be downloaded
	if(m_bOwnerIsInstrument == false)
	{
		ASSERT(m_pOwnerRegion);
		m_pOwnerRegion->CheckArtsAndSetInstrumentArt();
	}

	if(bRefreshNode)
	{
		CArticulation* pArt = GetHead();
		while(pArt)
		{
			pIFramework->RefreshNode(pArt);
			pArt = pArt->GetNext();
		}

		pIFramework->RefreshNode(this);
	}
}

BOOL CArticulationList::IsConditionOK()
{
	return m_bConditionOK;
}


void CArticulationList::CheckConfigAndRefreshNode()
{
	ASSERT(m_pConditionalChunk);
	if(m_pConditionalChunk == NULL)
	{
		m_bConditionOK = FALSE;
		return;
	}

	CSystemConfiguration*  pCurrentConfig = m_pDLSComponent->GetCurrentConfig();
	ASSERT(pCurrentConfig);

	OnConditionConfigChanged(pCurrentConfig, true);
	
	// If this list is owned by a region then ask the region to update for the change
	if(m_bOwnerIsInstrument == false)
	{
		m_pOwnerRegion->CheckArtsAndSetInstrumentArt();
	}

	if(m_pInstrument)
	{
		m_pInstrument->UpdateInstrument();
	}
}

void CArticulationList::SetConditionOK(BOOL bConditionOK, bool bRefreshNode)
{
	m_bConditionOK = bConditionOK;
	ASSERT(m_pDLSComponent);
	if(bRefreshNode && m_pDLSComponent)
	{
		// Refresh yourself
		IDMUSProdFramework* pIFramework = m_pDLSComponent->m_pIFramework;
		if(pIFramework)
		{
			// Refresh all articulation nodes
			CArticulation* pArt = GetHead();
			while(pArt)
			{
				pIFramework->RefreshNode(pArt);
				pArt = pArt->GetNext();
			}

			pIFramework->RefreshNode(this);
		}
	}
}

UINT CArticulationList::GetArticulationsUsed()
{
	// The articulation list doesn't get downloaded if the conditio is not met...
	if(m_bConditionOK)
	{
		return GetCount();
	}

	return 0;
}

CInstrument* CArticulationList::GetInstrument()
{
	return m_pInstrument;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ArticulationListPropPageMgr.h ===
//////////////////////////////////////////////////////////////////////
//
// ArticulationListPropPageMgr.h
//
//////////////////////////////////////////////////////////////////////

#ifndef __ARTICULATIONLISTPROPPAGEMGR_H
#define __ARTICULATIONLISTPROPPAGEMGR_H

#include "DllBasePropPageManager.h"

class CArticulationListPropPage;

//////////////////////////////////////////////////////////////////////
//  ArticulationListPropPageMgr

class CArticulationListPropPageMgr : public CDllBasePropPageManager 
{

public:
	CArticulationListPropPageMgr();
	virtual ~CArticulationListPropPageMgr();

    // IJazzPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Member variables
private:
	
	CArticulationListPropPage*	m_pArtListPage;
};

#endif // #ifndef __ARTICULATIONLISTPROPPAGEMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ArticulationList.h ===
#ifndef __ARTICULATIONLIST_H__
#define __ARTICULATIONLIST_H__

// ArticulationList.h : header file
//

#include "alist.h"
#include "RiffStrm.h"
#include "UnknownChunk.h"

class CRegion;
class CArticulation;
class CInstrument;
class CArticulationListPropPageMgr;
class CConditionalChunk;
class CSystemConfiguration;
class CCollection;

class CArticulationList : public AList, public IDMUSProdNode, public IDMUSProdPropPageObject, public IPersistStream
{
friend class CInstrument;
friend class CDLSComponent;

public:
    CArticulationList(CDLSComponent* pComponent, CInstrument* pOwner);
	CArticulationList(CDLSComponent* pComponent, CRegion* pOwner);

	~CArticulationList();

	//	AList overrides
    CArticulation* GetHead();
    CArticulation* RemoveHead();
	void Remove(CArticulation* pArticulation);
	void AddTail(CArticulation* pArticulation);

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    HRESULT STDMETHODCALLTYPE GetEditorClsId(CLSID* pclsid);
    HRESULT STDMETHODCALLTYPE GetEditorTitle(BSTR* pbstrTitle);
    HRESULT STDMETHODCALLTYPE GetEditorWindow(HWND* hWndEditor);
    HRESULT STDMETHODCALLTYPE SetEditorWindow(HWND hWndEditor);

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnResourceId);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit(HMENU hMenu);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect(long lCommandId);

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode** ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo(DMUSProdListInfo* pListInfo);

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );
    // IDMUSProdNode : drag & drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

	// IPersist functions
    STDMETHOD(GetClassID)(CLSID* pClsId);

	// IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	// IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();
	HRESULT STDMETHODCALLTYPE OnShowProperties();

	// Additional functions.
public:
	
	HRESULT	Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	HRESULT Save(IDMUSProdRIFFStream* pIRiffStream);

	DWORD	Count();
	DWORD	Size();
	HRESULT Write(void* pv, DWORD* pdwRelativeCurOffset, DWORD* pdwCurrentOffset, DWORD* pDMWOffsetTable, DWORD* pdwCurIndex);

	void	SetDLS1(BOOL bDLS1);
	BOOL	IsDLS1();
	void	SetOwner(CInstrument* pInstrument);
	void	SetOwner(CRegion* pRegion);

	void				CheckConfigAndRefreshNode();
	void				OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode = true);
	HRESULT				SetCondition(const CString& sCondition);
	BOOL				IsConditionOK();
	void				SetConditionOK(BOOL bConditionOK = TRUE, bool bRefreshNode = true);
	CConditionalChunk*	GetConditionalChunk();
	UINT				GetArticulationsUsed();	// Returns the number of arts actually OK to download

	CCollection*		GetCollection();	// The collection this articulation list belongs to...
	CInstrument*		GetInstrument();	// The instrument this list belongs to...

private:
	void	DeleteAllArticulations();
	
	
private:

    DWORD			m_dwRef;
	IDMUSProdNode*	m_pIRootNode;
	IDMUSProdNode*	m_pIParentNode;

	CDLSComponent*	m_pDLSComponent;	
	CInstrument*	m_pInstrument;

	CRegion*		m_pOwnerRegion;			

	BOOL			m_bDLS1;
	BOOL			m_bOwnerIsInstrument;

	BOOL			m_bConditionOK;

	CConditionalChunk* m_pConditionalChunk;
	CUnknownChunk      m_UnknownChunk;

	CArticulationListPropPageMgr* m_pArticListPropPageMgr;
};

#endif // __ARTICULATIONLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ArticulationTabCtrl.h ===
#if !defined(AFX_ARTICULATIONTABCTRL_H__7DC83682_E8A7_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_ARTICULATIONTABCTRL_H__7DC83682_E8A7_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ArticulationTabCtrl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CArticulationTabCtrl window

class CArticulationTabCtrl : public CTabCtrl
{
// Construction
public:
	CArticulationTabCtrl();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CArticulationTabCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CArticulationTabCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CArticulationTabCtrl)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARTICULATIONTABCTRL_H__7DC83682_E8A7_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ArticulationListPropPage.h ===
#if !defined(AFX_ARTICULATIONLISTPROPPAGE_H__0DE09698_933A_4187_A3FF_156620DE483A__INCLUDED_)
#define AFX_ARTICULATIONLISTPROPPAGE_H__0DE09698_933A_4187_A3FF_156620DE483A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ArticulationListPropPage.h : header file
//

#include "resource.h"

class CArticulationList;

/////////////////////////////////////////////////////////////////////////////
// CArticulationListPropPage dialog

class CArticulationListPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CArticulationListPropPage)

// Construction
public:
	CArticulationListPropPage();
	~CArticulationListPropPage();

	void SetObject(CArticulationList* pArtList){m_pArtList = pArtList;}

// Dialog Data
	//{{AFX_DATA(CArticulationListPropPage)
	enum { IDD = IDD_ARTLIST_PROP_PAGE };
	CButton	m_DLS1Check;
	CButton	m_EditButton;
	CComboBox	m_ConditionCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CArticulationListPropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CArticulationListPropPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnConditionEditButton();
	afx_msg void OnSelchangeArtlistConditionCombo();
	afx_msg void OnDropdownArtlistConditionCombo();
	afx_msg void OnDls1Check();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void EnableControls(BOOL bEnable = TRUE);
	void InitConditionsCombo();

private:
	CArticulationList* m_pArtList;
	BOOL m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARTICULATIONLISTPROPPAGE_H__0DE09698_933A_4187_A3FF_156620DE483A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ArticulationListPropPageMgr.cpp ===
//////////////////////////////////////////////////////////////////////
//
// ArticulationListPropPageMgr.cpp : implementation file
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Collection.h"
#include "ArticulationListPropPage.h"
#include "ArticulationListPropPageMgr.h"
#include "ArticulationList.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// CArticulationListPropPageMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CArticulationListPropPageMgr::CArticulationListPropPageMgr() : m_pArtListPage(NULL)
{
}

CArticulationListPropPageMgr::~CArticulationListPropPageMgr()
{
	if(m_pArtListPage)
	{
		delete m_pArtListPage;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationListPropPageMgr IJazzPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CArticulationListPropPageMgr IJazzPropPageManager::GetPropertySheetTitle

HRESULT CArticulationListPropPageMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pbstrTitle);
	ASSERT(pfAddPropertiesText);

	*pfAddPropertiesText = TRUE;

	CArticulationList* pArtList = NULL;

	if(m_pIPropPageObject && (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pArtList))))
	{
		BSTR bstrArtListName;
		pArtList->GetNodeName(&bstrArtListName);
		CString sArtListName = bstrArtListName;
		SysFreeString(bstrArtListName);

		CString sTitle;
		sTitle.LoadString(IDS_ARTICULATION_FOLDER_NAME);
		sTitle = sArtListName + " " + sTitle;
		*pbstrTitle = sTitle.AllocSysString();
	}
	else
	{
		CString strTitle;
		strTitle.LoadString(IDS_ARTICULATION_FOLDER_NAME);
		*pbstrTitle = strTitle.AllocSysString();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationListPropPageMgr IJazzPropPageManager::GetPropertySheetPages

HRESULT CArticulationListPropPageMgr::GetPropertySheetPages(IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add General tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(m_pArtListPage == NULL)
	{
		m_pArtListPage = new CArticulationListPropPage();
	}

	if(m_pArtListPage)
	{
		hPage = ::CreatePropertySheetPage((LPPROPSHEETPAGE)&m_pArtListPage->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages; 

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationListPropPageMgr IJazzPropPageManager::RefreshData

HRESULT CArticulationListPropPageMgr::RefreshData(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CArticulationList* pArtList = NULL;
	
	if(m_pIPropPageObject == NULL)
	{
		pArtList = NULL;
	}
	else if(FAILED(m_pIPropPageObject->GetData((void **)&pArtList)))
	{
		return E_FAIL;
	}

	m_pArtListPage->SetObject(pArtList);

	if(m_pIPropSheet)
	{
		m_pIPropSheet->RefreshTitle();
	}

	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ArticulationListPropPage.cpp ===
// ArticulationListPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "ArticulationListPropPageMgr.h"
#include "ArticulationListPropPage.h"
#include "ArticulationList.h"
#include "Articulation.h"
#include "ConditionalChunk.h"
#include "Collection.h"
#include "ConditionEditor.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CArticulationListPropPage property page

IMPLEMENT_DYNCREATE(CArticulationListPropPage, CPropertyPage)

CArticulationListPropPage::CArticulationListPropPage() : CPropertyPage(CArticulationListPropPage::IDD), m_pArtList(NULL)
{
	//{{AFX_DATA_INIT(CArticulationListPropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CArticulationListPropPage::~CArticulationListPropPage()
{
}

void CArticulationListPropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CArticulationListPropPage)
	DDX_Control(pDX, IDC_DLS1_CHECK, m_DLS1Check);
	DDX_Control(pDX, IDC_CONDITION_EDIT_BUTTON, m_EditButton);
	DDX_Control(pDX, IDC_ARTLIST_CONDITION_COMBO, m_ConditionCombo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CArticulationListPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CArticulationListPropPage)
	ON_BN_CLICKED(IDC_CONDITION_EDIT_BUTTON, OnConditionEditButton)
	ON_CBN_SELCHANGE(IDC_ARTLIST_CONDITION_COMBO, OnSelchangeArtlistConditionCombo)
	ON_CBN_DROPDOWN(IDC_ARTLIST_CONDITION_COMBO, OnDropdownArtlistConditionCombo)
	ON_BN_CLICKED(IDC_DLS1_CHECK, OnDls1Check)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArticulationListPropPage message handlers

BOOL CArticulationListPropPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CArticulationListPropPage::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pArtList == NULL)
	{
		EnableControls(FALSE);
		return CPropertyPage::OnSetActive();
	}

	EnableControls();
	InitConditionsCombo();

	m_DLS1Check.SetCheck(m_pArtList->IsDLS1());
	
	return CPropertyPage::OnSetActive();
}


void CArticulationListPropPage::EnableControls(BOOL bEnable)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CWnd* pCtrl = GetDlgItem(IDC_ARTLIST_CONDITION_COMBO);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bEnable);
	}

	pCtrl = GetDlgItem(IDC_CONDITION_EDIT_BUTTON);
	if(pCtrl)
	{
#ifndef DMP_XBOX
		pCtrl->EnableWindow(bEnable);
#else
		pCtrl->EnableWindow(FALSE);
#endif
	}

#ifdef DMP_XBOX
	pCtrl = GetDlgItem(IDC_ARTLIST_CONDITION_COMBO);
	if(pCtrl)
	{
		pCtrl->EnableWindow(FALSE);
	}
	pCtrl = GetDlgItem(IDC_ARTLIST_CONDITION_STATIC);
	if(pCtrl)
	{
		pCtrl->EnableWindow(FALSE);
	}
#endif // DMP_XBOX

	pCtrl = GetDlgItem(IDC_DLS1_CHECK);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bEnable);
	}
}

void CArticulationListPropPage::InitConditionsCombo()
{
	if(m_pArtList == NULL)
	{
		return;
	}

	m_ConditionCombo.ResetContent();

	CString sNone;
	sNone.LoadString(IDS_NONE);
	if(m_ConditionCombo.FindStringExact(0, sNone) == CB_ERR)
	{
		m_ConditionCombo.AddString(sNone);
	}

	CCollection* pCollection = m_pArtList->GetCollection();
	ASSERT(pCollection);
	CPtrList lstConditions;
	pCollection->GetListOfConditions(&lstConditions);

	POSITION position = lstConditions.GetHeadPosition();
	while(position)
	{
		CConditionalChunk* pCondition = (CConditionalChunk*)lstConditions.GetNext(position);
		ASSERT(pCondition);
		if(pCondition)
		{
			CString sConditionName = pCondition->GetName();
			if(m_ConditionCombo.FindStringExact(0, sConditionName) == CB_ERR)
			{
				m_ConditionCombo.AddString(sConditionName);
			}
		}
	}

	// Now set the condition for this articulation list
	CConditionalChunk* pConditionalChunk = m_pArtList->GetConditionalChunk();
	ASSERT(pConditionalChunk);
	if(pConditionalChunk)
	{
		CString sCurrentConditionName = pConditionalChunk->GetName();
		m_ConditionCombo.SelectString(0, sCurrentConditionName);
	}
}

void CArticulationListPropPage::OnConditionEditButton() 
{
	ASSERT(m_pArtList);
	if(m_pArtList == NULL)
	{
		EnableControls(FALSE);
		return;
	}

	CDLSComponent* pComponent = NULL;
	m_pArtList->GetComponent((IDMUSProdComponent**)&pComponent);
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		EnableControls(FALSE);
		return;
	}

	CConditionalChunk* pConditionalChunk = m_pArtList->GetConditionalChunk();
	ASSERT(pConditionalChunk);
	if(pConditionalChunk == NULL)
	{
		EnableControls(FALSE);
		return;
	}

	CInstrument* pInstrument = m_pArtList->GetInstrument();
	ASSERT(pInstrument);
	if(pInstrument == NULL)
	{
		return;
	}

	CConditionEditor conditionEditor(this, pComponent, pConditionalChunk, pInstrument);
	if(conditionEditor.DoModal() == IDOK)
	{
		// Add the new condition to the presets list
		InitConditionsCombo();
	}

	m_pArtList->CheckConfigAndRefreshNode();
}

void CArticulationListPropPage::OnSelchangeArtlistConditionCombo() 
{
	ASSERT(m_pArtList);
	if(m_pArtList == NULL)
	{
		return;
	}

	CString sCondition;
	m_ConditionCombo.GetWindowText(sCondition);
	if(FAILED(m_pArtList->SetCondition(sCondition)))
	{
		CString sNone;
		sNone.LoadString(IDS_NONE);
		UINT nConditionIndex = m_ConditionCombo.FindStringExact(0, sCondition);
		m_ConditionCombo.DeleteString(nConditionIndex);
		m_ConditionCombo.SelectString(0, sNone);
	}

	m_pArtList->CheckConfigAndRefreshNode();
}


void CArticulationListPropPage::OnDropdownArtlistConditionCombo() 
{
	InitConditionsCombo();
}

void CArticulationListPropPage::OnDls1Check() 
{
	if(m_pArtList == NULL)
	{
		return;
	}
	
	BOOL bDLS1 = m_DLS1Check.GetCheck();
	m_pArtList->SetDLS1(bDLS1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionExtraPropPg.cpp ===
//
// CollectionExtraPropPg.cpp : implementation file
//

#include "stdafx.h"
#include "Collection.h"
#include "CollectionPropPgMgr.h"
#include "CollectionExtraPropPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCollectionExtraPropPg property page

IMPLEMENT_DYNCREATE(CCollectionExtraPropPg, CPropertyPage)

CCollectionExtraPropPg::CCollectionExtraPropPg() : CPropertyPage(CCollectionExtraPropPg::IDD), m_pCollection(NULL)
{
	//{{AFX_DATA_INIT(CCollectionExtraPropPg)
	m_dwArticCount = 0;
	m_dwInstCount = 0;
	m_dwRegionCount = 0;
	m_dwSampleCount = 0;
	m_dwWaveCount = 0;
	//}}AFX_DATA_INIT

	m_fNeedToDetach = FALSE;
}

CCollectionExtraPropPg::~CCollectionExtraPropPg()
{
}

void CCollectionExtraPropPg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCollectionExtraPropPg)
	DDX_Text(pDX, IDC_ARTIC_COUNT, m_dwArticCount);
	DDX_Text(pDX, IDC_INST_COUNT, m_dwInstCount);
	DDX_Text(pDX, IDC_REGION_COUNT, m_dwRegionCount);
	DDX_Text(pDX, IDC_SAMPLE_COUNT, m_dwSampleCount);
	DDX_Text(pDX, IDC_WAVE_COUNT, m_dwWaveCount);
	DDV_MinMaxDWord(pDX, m_dwWaveCount, 0, 1000000000);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCollectionExtraPropPg, CPropertyPage)
	//{{AFX_MSG_MAP(CCollectionExtraPropPg)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCollectionExtraPropPg message handlers

void CCollectionExtraPropPg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

int CCollectionExtraPropPg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.

	if(!FromHandlePermanent(m_hWnd))
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

BOOL CCollectionExtraPropPg::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pCollection == NULL)
	{
		EnableControls(FALSE);
		CCollectionPropPgMgr::m_dwLastSelPage = COLLECTION_EXTRA_PAGE;
		return CPropertyPage::OnSetActive();
	}
	
	EnableControls(TRUE);
	
	m_dwSampleCount = m_pCollection->SampleCount();
	m_dwArticCount = m_pCollection->ArticulationCount();
	m_dwInstCount = m_pCollection->InstrumentCount();
	m_dwWaveCount = m_pCollection->WaveCount();
	m_dwRegionCount = m_pCollection->RegionCount();

	UpdateData(FALSE);

	CCollectionPropPgMgr::m_dwLastSelPage = COLLECTION_EXTRA_PAGE;
	return CPropertyPage::OnSetActive();
}

void CCollectionExtraPropPg::EnableControls(BOOL fEnable) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CWnd * pCtrl = GetDlgItem(IDC_SAMPLE_COUNT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_REGION_COUNT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_WAVE_COUNT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_INST_COUNT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_ARTIC_COUNT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionExtraPropPg.h ===
#if !defined(AFX_COLLECTIONEXTRAPROPPG_H__6E263AA4_ECD6_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_COLLECTIONEXTRAPROPPG_H__6E263AA4_ECD6_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CollectionExtraPropPg.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CCollectionExtraPropPg dialog

class CCollectionExtraPropPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CCollectionExtraPropPg)

// Construction
public:
	CCollectionExtraPropPg();
	~CCollectionExtraPropPg();

	void SetObject(CCollection* pCollection) {m_pCollection = pCollection;}

	void EnableControls(BOOL fEnable);

// Dialog Data
	//{{AFX_DATA(CCollectionExtraPropPg)
	enum { IDD = IDD_COLLECTION_EXTRA_PROP_PAGE };
	DWORD	m_dwArticCount;
	DWORD	m_dwInstCount;
	DWORD	m_dwRegionCount;
	DWORD	m_dwSampleCount;
	DWORD	m_dwWaveCount;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCollectionExtraPropPg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCollectionExtraPropPg)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CCollection* m_pCollection;	
	BOOL m_fNeedToDetach;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COLLECTIONEXTRAPROPPG_H__6E263AA4_ECD6_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Collection.cpp ===
//
// Collection.cpp : implementation file
//

#include "stdafx.h"
#include "DlsDefsPlus.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"

#include "Collection.h"
#include "Articulation.h"
#include "WaveNode.h"
#include "Wave.h"
#include "WaveDataManager.h"
#include "StereoWave.h"
#include "MonoWave.h"

#include "WaveCtl.h"
#include "InstrumentCtl.h"
#include "Instrument.h"
#include "region.h"
#include "resource.h"
#include "stream.h"

#include "DLSLoadSaveUtils.h"
#include "resource.h"

#include "CollectionPropPgMgr.h"
#include "CollectionPropPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


BOOL CCollection::m_bNoMIDIPort = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CCollection constructor/destructor

//////////////////////////////////////////////////////////////////////
//
//	CCollection::CCollection()
//
//////////////////////////////////////////////////////////////////////
CCollection::CCollection( CDLSComponent* pComponent )
{
	ASSERT( pComponent != NULL );

    m_lRef = 0;
	AddRef();

	m_pComponent = pComponent;
	m_pComponent->AddRef();

	m_pIDMCollection = NULL;

	m_pCollectionPropPgMgr = NULL;
	m_pIRootNode = NULL;
	m_pIParentNode = NULL;

    m_bIsDirty = FALSE;

	m_Instruments.m_pDLSComponent = pComponent;
	m_Waves.m_pDLSComponent = pComponent;

	m_Instruments.m_pCollection = this;
	m_Waves.m_pCollection = this;

	if(m_pCollectionPropPgMgr == NULL)
	{
		m_pCollectionPropPgMgr = new CCollectionPropPgMgr();
	}
	else
	{
		m_pCollectionPropPgMgr->AddRef();
	}

	// If no output port, warn the user
	if(m_pComponent->m_lstDLSPortDownload.IsEmpty())
	{
		if(m_bNoMIDIPort == FALSE)
		{
			AfxMessageBox(IDS_ERR_NO_PORT, MB_OK | MB_ICONEXCLAMATION);
		}
		
		m_bNoMIDIPort = TRUE;
	}
	else
	{
		m_bNoMIDIPort = FALSE;
	}


// J3 we need to make sure I initialize this to its proper default values 
// Currently I am using the values used by SynthAuthor
	m_rVersion.dwVersionMS = 1 << 16;
	m_rVersion.dwVersionLS = 1;
	m_fPatchResolution = 0;
	CoCreateGuid(&m_Guid);
}

CCollection::~CCollection()
{
	//Unload the waves and instruments before we die...
	Unload();

	// If we are in a Property Page Manager we need to remove ourselves before we go away
	IDMUSProdPropSheet *pIPropSheet;
	if(SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**) &pIPropSheet)))
	{
		if(pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
		{
			pIPropSheet->RemovePageManagerByObject(this);
		}
		else
		{
			if(m_pCollectionPropPgMgr)
			{
				m_pCollectionPropPgMgr->RemoveObject(this);
			}
		}
		pIPropSheet->Release();
	}

	if(m_pCollectionPropPgMgr)
	{
		DWORD refCount = m_pCollectionPropPgMgr->Release();
		if(refCount == 0)
		{
			m_pCollectionPropPgMgr = NULL;
		}
	}

	if( m_pComponent )
	{
		m_pComponent->Release();
	}

	ReleaseDMCollection();
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IUnknown implementation

//////////////////////////////////////////////////////////////////////
//
//	CCollection::QueryInterface
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersist) )
    {
        AddRef();
        *ppvObj = (IPersist *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        AddRef();
        *ppvObj = (IPersistStream *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IDMUSProdNotifySink))
    {
        AddRef();
        *ppvObj = (IDMUSProdNotifySink*)this;
        return S_OK;
    }


    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////
//
//	CCollection::AddRef
//
//////////////////////////////////////////////////////////////////////
ULONG CCollection::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return InterlockedIncrement( &m_lRef);
}

//////////////////////////////////////////////////////////////////////
//
//	CCollection::Release
//
//////////////////////////////////////////////////////////////////////
ULONG CCollection::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_lRef != 0 );

	InterlockedDecrement( &m_lRef ); 

    if( m_lRef == 0 )
    {
        delete this;
        return 0;
    }
	AfxOleUnlockApp();
    return m_lRef;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdNode implementation

//////////////////////////////////////////////////////////////////////
//
//	CCollection IDMUSProdNode::GetNodeImageIndex	
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetNodeImageIndex(short* pnFirstImage)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnFirstImage);

	ASSERT(m_pComponent != NULL);

	return(m_pComponent->GetCollectionImageIndex(pnFirstImage));
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetComponent
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetDocRootNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetDocRootNode( IDMUSProdNode** ppIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIRootNode )
	{
		m_pIRootNode->AddRef();
		*ppIRootNode = m_pIRootNode;
		return S_OK;
	}

	*ppIRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::SetDocRootNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::SetDocRootNode( IDMUSProdNode* pIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( pIRootNode != NULL );

	m_pIRootNode = pIRootNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetParentNode
//
//  Returns S_OK if there is a parent node - ppIParentnode then points
//  to the parent node. Else it will return failure and ppIParentNode
//  will be NULL
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(ppIParentNode);

	if(ppIParentNode == NULL)
	{
		return E_POINTER;
	}

// J3 This is the only one who can have a parent node of NULL
//	ASSERT( m_pIParentNode != NULL );

	// If there is a parent, set the pointer to point to it
    // and return ok else set it to null and return failure.
	if(m_pIParentNode)
	{		
    	*ppIParentNode = m_pIParentNode;
		m_pIParentNode->AddRef();
    	return S_OK;
	}
    else
    {
        *ppIParentNode = NULL;
        return E_FAIL;
    }
	
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::SetParentNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_pIParentNode = pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetNodeId
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_CollectionNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetNodeName
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetNodeName(BSTR* pbstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pbstrName);

    *pbstrName = m_Info.m_csName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetNodeNameMaxLength
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetNodeNameMaxLength(short* pnMaxLength)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnMaxLength);

	*pnMaxLength = BUFFER_256;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::ValidateNodeName
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::ValidateNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;

	strName = bstrName;
	
	::SysFreeString(bstrName);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::SetNodeName
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString strName = bstrName;
	::SysFreeString( bstrName );

	m_Info.m_csName = strName;

	// Set flag so we know to save file 
	SetDirtyFlag();

	if(m_pCollectionPropPgMgr)
	{
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
			{
				m_pCollectionPropPgMgr->RefreshData();
				m_pCollectionPropPgMgr->m_pCollectionPage->OnSetActive();
			}

			RELEASE(pIPropSheet);
		}
	}

	// Notify All the waves and instruments that the collection name has changed
	// so they can change it in the transport drop-down
	CWaveNode* pWaveNode = m_Waves.GetHead();
	for ( ; pWaveNode != NULL; pWaveNode = pWaveNode->GetNext())
	{
		pWaveNode->SetTransportName();
	}

	CInstrument* pInstrument = m_Instruments.GetHead();
	for( ; pInstrument != NULL; pInstrument = pInstrument->GetNext())
	{
		if(pInstrument->m_pInstrumentCtrl)
			pInstrument->m_pInstrumentCtrl->SetTransportName();
	}

	if(m_pComponent->m_pIFramework)
		m_pComponent->m_pIFramework->NotifyNodes(this, COLLECTION_NameChange, NULL);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetEditorClsId
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetEditorClsId(CLSID* pClsId)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetEditorTitle
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetEditorTitle(BSTR* pbstrTitle)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetEditorWindow
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetEditorWindow(HWND* hWndEditor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::SetEditorWindow
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::SetEditorWindow(HWND hWndEditor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::UseOpenCloseImages
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::UseOpenCloseImages(BOOL* pfUseOpenCloseImages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pfUseOpenCloseImages);
	
	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::GetRightClickMenuId
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMenuId);
	ASSERT(phInstance);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_COLLECTION_NODE_RMENU;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::OnRightClickMenuInit
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

#ifdef DMP_XBOX
	::EnableMenuItem( hMenu, IDM_IMPORT_CONFIGS, MF_GRAYED | MF_BYCOMMAND );
	::EnableMenuItem( hMenu, IDM_EXPORT_CONFIGS, MF_GRAYED | MF_BYCOMMAND );
#endif

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::OnRightClickMenuSelect
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	HRESULT hr = E_FAIL;
	
	switch( lCommandId )
	{
		case IDM_RENAME:
		{
			if(SUCCEEDED(m_pComponent->m_pIFramework->EditNodeLabel((IDMUSProdNode *)this)))
			{
				hr = S_OK;
			}
			break;
		}
		
		case IDM_PROPERTIES:
		{
			if(SUCCEEDED(OnShowProperties()))
			{
				hr = S_OK;
			}
			break;
		}

		case IDM_VERIFY_DLS1:
		{
			if(!VerifyDLS())
			{
				AfxMessageBox(IDS_NOT_DLS1);
			}
			else
			{
				AfxMessageBox(IDS_IS_DLS1);
			}

			hr = S_OK;
			break;
		}
		
		case IDM_EXPORT_CONFIGS:
		{
			BSTR bstrFilePath = NULL;
			if(SUCCEEDED(m_pComponent->m_pIFramework->GetNodeFileName(this, &bstrFilePath)))
			{
				CString sFilePath = bstrFilePath;
				SysFreeString(bstrFilePath);
				
				// Take out the filename we need just the path
				int nLength = sFilePath.GetLength();
				int nLastSlash = sFilePath.ReverseFind('\\');
				sFilePath = sFilePath.Left(nLastSlash);
	
				// Export to [Path]\Producer.POL - policy file
				m_pComponent->ExportConfigurations(sFilePath);
			}

			break;
		}

		case IDM_IMPORT_CONFIGS:
		{
			BSTR bstrFilePath = NULL;
			if(SUCCEEDED(m_pComponent->m_pIFramework->GetNodeFileName(this, &bstrFilePath)))
			{
				CString sFilePath = bstrFilePath;
				SysFreeString(bstrFilePath);
				
				// Take out the filename we need just the path
				int nLength = sFilePath.GetLength();
				int nLastSlash = sFilePath.ReverseFind('\\');
				sFilePath = sFilePath.Left(nLastSlash);
	
				// Import [Path]\Producer.POL - policy file
				m_pComponent->ImportConfigurations(sFilePath);
			}

			break;
		}

	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::DeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_FAIL;	// Cannot delete folders under Collection
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::InsertChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_FAIL;	// Cannot insert additional folders under Collection
}

////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::DeleteNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::DeleteNode( BOOL fPromptUser )
{
	ASSERT(m_pComponent != NULL);
	if (NULL == m_pComponent)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
	ASSERT(NULL != pIFramework);
	if (NULL == pIFramework)
	{
		return E_UNEXPECTED;
	}

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	IDMUSProdNode* pIParentNode;

	if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			pIParentNode->Release();
			return hr;		
		}
	}

	// We need to close out all the open file handles
	CWaveNode* pWaveNode = m_Waves.GetHead();
	while(pWaveNode)
	{
		if(pWaveNode->GetFileName() == m_sFileName)
		{
			CWave* pWave = pWaveNode->GetWave();
			ASSERT(pWave);
			if(FAILED(pWave->CloseSourceHandler()))
			{
				return E_FAIL;
			}
		}
		pWaveNode = pWaveNode->GetNext();
	}

	// Remove from Project Tree
	if(m_pComponent->m_pIFramework->RemoveNode(this, fPromptUser) == S_FALSE)
	{
		// The user canselled the delete, so we need to attach waves
		// back to their original source file handlers.
		CWaveNode* pWaveNode = m_Waves.GetHead();
		while(pWaveNode)
		{
			if(pWaveNode->GetFileName() == m_sFileName)
			{
				CWave* pWave = pWaveNode->GetWave();
				ASSERT(pWave);
				if(FAILED(pWave->OnSourceRenamed(m_sFileName)))
				{
					return E_FAIL;
				}
			}
			pWaveNode = pWaveNode->GetNext();
		}
		return E_FAIL;	
	}

	// Unregister all the waves from the transport
	m_Waves.UnRegisterWavesFromTransport();

	// Ask the wave nodes to release their dummy instruments
	m_Waves.ReleaseWaveNodeDummyInstruments();
	
	// Remove from Component DLS list...and call a release as well...
	m_pComponent->DeleteFromCollectionList(this);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CCollection IDMUSProdNode::GetFirstChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetFirstChild(IDMUSProdNode** ppIFirstChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppIFirstChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppIFirstChildNode = NULL;

	IDMUSProdNode* pINode = static_cast<IDMUSProdNode*>(&m_Instruments);

	if(pINode)
	{
		pINode->AddRef();
		*ppIFirstChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CCollection IDMUSProdNode::GetNextChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppINextChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppINextChildNode = NULL;

	if(pIChildNode == NULL)
	{
		return E_INVALIDARG;
	}

	IDMUSProdNode* pINode = static_cast<IDMUSProdNode*>(&m_Waves);

	if(pINode && pINode != pIChildNode)
	{
		pINode->AddRef();
		*ppINextChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CCollection IDMUSProdNode::GetNodeListInfo
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetNodeListInfo(DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pListInfo == NULL )
	{
		return E_POINTER;
	}

	CString strDescriptor;

    pListInfo->bstrName = m_Info.m_csName.AllocSysString();
    pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_Guid, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::OnNodeSelChanged
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::CreateDataObject
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT( m_pComponent != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

    // Save collection into stream
	HRESULT hr = E_FAIL;
	if( SUCCEEDED ( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
        {
            // Place the format in the CDllJazzdataobject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfCollection, pIStream ) ) )
			{
				hr = S_OK;
			}
		}
		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( m_pComponent->m_pIFramework->SaveClipFormat( m_pComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// Collection nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			pIStream->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::CanCut
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::CanCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return CanDelete();

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::CanCopy
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::CanCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    //return E_NOTIMPL;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::CanDelete
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::CanDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::CanDeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::CanPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

    if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}
	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
    
    HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfInstrument)))
        hr = S_OK;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfWave )))
        hr = S_OK;
	
    pDataObject->Release();

    return hr;

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::PasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if(SUCCEEDED(pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfInstrument)))
    {
		hr = m_Instruments.PasteCF_INSTRUMENT(pDataObject, pIDataObject);
		pDataObject->Release();
		return hr;
    }

    if(SUCCEEDED(pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfWave)))
    {
		hr = m_Waves.PasteCF_WAVE(pDataObject, pIDataObject);
		pDataObject->Release();
		return hr;
    }

	pDataObject->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::CanChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										    BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;   

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNode::ChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdNode::GetObject

HRESULT CCollection::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_UNEXPECTED;
	}
	
	// Must be asking for an interface to a CLSID_DirectMusic object
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusic ) )
	{
		if( m_pComponent->m_pIDirectMusic )
		{
			return m_pComponent->m_pIDirectMusic->QueryInterface( riid, ppvObject );
		}
	}
	
	if(::IsEqualCLSID(rclsid, CLSID_DirectMusicCollection))
	{
		 if(m_pIDMCollection == NULL)
		 {
			 if(FAILED(CreateDMCollection()))
			 {
				 *ppvObject = NULL;
				 return E_FAIL;
			 }
		 }

		 // AddRef it before passing it on....
		 m_pIDMCollection->AddRef();
		 *ppvObject = m_pIDMCollection;
		 return S_OK;
	}

	*ppvObject = NULL;
	return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNotifySink Implementation
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
// CCollection IDMUSProdNotifySink::OnUpdate
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CCollection::OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, void* pvData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pIDocRootNode);
	if(pIDocRootNode == NULL)
	{
		return E_POINTER;
	}

	if(pIDocRootNode != m_pIRootNode)
	{
		return E_NOTIMPL;
	}


	if(::IsEqualGUID( guidUpdateType, FRAMEWORK_BeforeFileSave))
	{
		ASSERT(pvData);
		if(pvData == NULL)
		{
			return E_POINTER;
		}

		WCHAR* pwszFileName = (WCHAR*)pvData;
		CString sFileName = pwszFileName;

		if(m_sFileName != sFileName)
		{
			return S_OK;
		}

		// Go through all wavenodes in the collection and close out the source handlers
		// Then rename the collection and reset the source handlers to point to and read 
		// from the renamed temporary collection file...
		CWaveNode* pWaveNode = m_Waves.GetHead();
		while(pWaveNode)
		{
			if(pWaveNode->IsSourceInTempFile() == FALSE && pWaveNode->GetFileName() == m_sFileName)
			{
				CWave* pWave = pWaveNode->GetWave();
				ASSERT(pWave);
				if(FAILED(pWave->CloseSourceHandler()))
				{
					return E_FAIL;
				}
			}

			pWaveNode = pWaveNode->GetNext();
		}

		// Get a temp file name
		char szTempPath[MAX_PATH];
		DWORD dwSuccess = GetTempPath(MAX_PATH, szTempPath);
		CString sTempPath = szTempPath;

		CString sPrefix = "DMP";
		CString sExt = "tmp";
		char szTempName[MAX_PATH];

		if(FAILED(CWaveDataManager::CreateUniqueTempFile(sPrefix, sExt, m_sTempName)))
		{
			GetTempFileName(sTempPath, sPrefix, 0, szTempName);
			m_sTempName = szTempName;
		}

		// We will create a new file when we rename
		DeleteFile(m_sTempName);

		try
		{
			CFile::Rename(sFileName, m_sTempName);
		}
		catch(CFileException e)
		{
			return E_FAIL;
		}

		pWaveNode = m_Waves.GetHead();
		while(pWaveNode)
		{
			if(pWaveNode->IsSourceInTempFile() == FALSE && pWaveNode->GetFileName() == m_sFileName)
			{
				CWave* pWave = pWaveNode->GetWave();
				ASSERT(pWave);

				if(FAILED(pWave->OnSourceRenamed(m_sTempName)))
				{
					return E_FAIL;
				}
			}
			pWaveNode = pWaveNode->GetNext();
		}
		
		return S_OK;
	}
	
	if(::IsEqualGUID( guidUpdateType, FRAMEWORK_AfterFileSave))
	{
		ASSERT(pvData);
		if(pvData == NULL)
		{
			return E_POINTER;
		}

		WCHAR* pwszFileName = (WCHAR*)pvData;
		CString sFileName = pwszFileName;

		if(m_sFileName != sFileName)
		{
			return S_OK;
		}

		CWaveNode* pWaveNode = m_Waves.GetHead();
		while(pWaveNode)
		{
			CWave* pWave = pWaveNode->GetWave();
			ASSERT(pWave);
			if(FAILED(pWave->CleanupAfterSave(sFileName)))
			{
				return E_FAIL;
			}
			pWaveNode = pWaveNode->GetNext();
		}

		// Delete the temp file created before the save
		DeleteFile(m_sTempName);

		return S_OK;
	}

	if(::IsEqualGUID( guidUpdateType, FRAMEWORK_BeforeFileNameChange))
	{
		// Go through all wavenodes in the collection and close out the source handlers
		// Then rename the collection and reset the source handlers to point to and read 
		// from the renamed temporary collection file...
		CWaveNode* pWaveNode = m_Waves.GetHead();
		while(pWaveNode)
		{
			if(pWaveNode->IsSourceInTempFile() == FALSE && pWaveNode->GetFileName() == m_sFileName)
			{
				CWave* pWave = pWaveNode->GetWave();
				ASSERT(pWave);
				if(FAILED(pWave->CloseSourceHandler()))
				{
					return E_FAIL;
				}
			}
 
			pWaveNode = pWaveNode->GetNext();
		}


		return S_OK;
	}

	if(::IsEqualGUID( guidUpdateType, FRAMEWORK_AbortFileNameChange))
	{
		CWaveNode* pWaveNode = m_Waves.GetHead();
		while(pWaveNode)
		{
			if(pWaveNode->GetFileName() == m_sFileName)
			{
				CWave* pWave = pWaveNode->GetWave();
				ASSERT(pWave);

				if(FAILED(pWave->OnSourceRenamed(m_sTempName)))
				{
					return E_FAIL;
				}
			}
			pWaveNode = pWaveNode->GetNext();
		}

		return S_OK;
	}

	if(::IsEqualGUID(guidUpdateType, FRAMEWORK_FileNameChange))
	{
		ASSERT(m_pComponent->m_pIFramework);
		if(m_pComponent->m_pIFramework == NULL)
		{
			return E_FAIL;
		}

		// Ge the new file name for the node
		BSTR bstrNodeFileName;
		if(FAILED(m_pComponent->m_pIFramework->GetNodeFileName((IDMUSProdNode*)this, &bstrNodeFileName)))
		{
			return E_FAIL;
		}

		CString sFileName = bstrNodeFileName;
		::SysFreeString(bstrNodeFileName);

		// Are we already looking at the same file?
		if(m_sFileName == sFileName)
		{
			return S_OK;
		}
		
		CWaveNode* pWaveNode = m_Waves.GetHead();
		while(pWaveNode)
		{
			// Keep the name with the wave node...
			pWaveNode->SetFileName(sFileName);
			CWave* pWave = pWaveNode->GetWave();
			ASSERT(pWave);

			EnterCriticalSection(&pWaveNode->m_CriticalSection);
			if(FAILED(pWave->FileNameChanged(sFileName)))
			{
				LeaveCriticalSection(&pWaveNode->m_CriticalSection);
				return E_FAIL;
			}
			
			LeaveCriticalSection(&pWaveNode->m_CriticalSection);

			pWaveNode = pWaveNode->GetNext();
		}

		m_sFileName = sFileName;

		return S_OK;
	}


	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollection IPersist implementation

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IPersist::GetClassID
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollection IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IPersistStream::IsDirty
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return m_bIsDirty ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IPersistStream::Load
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::Load( IStream* pIStream )
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr;

    ASSERT( pIStream != NULL );

    hr = AllocRIFFStream( pIStream, &pIRiffStream );

    if( SUCCEEDED( hr ) )
    {
        ckMain.fccType = FOURCC_DLS;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = Load( pIRiffStream, &ckMain );
			m_bIsDirty = FALSE;
			if(SUCCEEDED(hr))
			{
				m_pComponent->DeleteFromFailedCollectionGUIDs(m_Guid);
				//VerifyDLS();
			}
        }
		else
		{
			hr = E_FAIL;
		}

        pIRiffStream->Release();
    }

	if(FAILED(hr))
	{
		m_pComponent->AddToFailedCollectionGUIDs(m_Guid);
	}


    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollection IPersistStream::Save
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::Save(IStream* pIStream, BOOL fClearDirty)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    HRESULT hr;

    hr = E_FAIL;

    if(SUCCEEDED(AllocRIFFStream(pIStream, &pIRiffStream)))
    {
		if(SUCCEEDED(Save(pIRiffStream, true)))
        {
			if(fClearDirty)
			{
				ClearDirtyFlag();
			}
			hr = S_OK;
		}
		pIRiffStream->Release();
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection IPersistStream::GetSizeMax
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollection::Save
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollection::Save( const char* strFileName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);		
	HRESULT	hr = S_OK;
    IStream*	pStream = NULL;
	IDMUSProdRIFFStream*	pRiffStream = NULL;

	hr = AllocStreamToFile( &pStream, strFileName, 0 );
	if( SUCCEEDED(hr) )
	{
	    hr = AllocRIFFStream( pStream, &pRiffStream );
	    if (SUCCEEDED(hr))
	    {
            hr = Save(pRiffStream, TRUE);
			pRiffStream->Release();
        }
		pStream->Release();
    }
	return hr;
}

//////////////////////////////////////////////////////////////////////
//
// CCollection::ResolveConnections()
//
//////////////////////////////////////////////////////////////////////
void CCollection::ResolveConnections()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);			

    SetWaveIDs();
    
	CPtrList waveList;			// list of mono waves
	if(FAILED(m_Waves.GetListOfMonoWaves(&waveList)))
		return;

	CInstrument* pInstrument = m_Instruments.GetHead();
    for( ; pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        CRegion* pRegion = pInstrument->m_Regions.GetHead();
        for ( ; pRegion != NULL; pRegion = pRegion->GetNext())
        	{
        	CWave* pWave = NULL; // wave we'll assign to the region

			// skip this instrument if its waves are already assigned
        	if (pRegion->m_pWave != NULL)
				{
			#ifdef _DEBUG
				// verify that all other regions in the instrument have waves assigned
				while ((pRegion = pRegion->GetNext()) != NULL)
					ASSERT(pRegion->m_pWave != NULL);
			#endif
				break;
				}

			POSITION position = waveList.GetHeadPosition();
            while (position)
            	{
				CMonoWave* pMonoWave = (CMonoWave*)waveList.GetNext(position);
				ASSERT(pMonoWave);
                if (pRegion->m_rWaveLink.ulTableIndex == pMonoWave->GetWaveID())
                	{
                    pWave = pMonoWave;
                    break;
	                }
    	        }
			
			// If no wave was found for this region we assign the first wave
			if (pWave == NULL  && !waveList.IsEmpty()) 
				{
				pWave = (CWave*)waveList.GetHead();
				ASSERT(pWave);
				}

			// if there are regions further in the list with the same ID, merge them with this one
			pRegion->MergeNextRegions(pWave);

			// finally, assign wave to region
			if (pWave)
				{
                pRegion->m_pWave = pWave;
                pRegion->m_rWaveLink.ulTableIndex = pWave->GetWaveID();
				pRegion->GetName();
                pWave->GetNode()->AddRef();
				}
    	    }
		}
}

/////////////////////////////////////////////////////////////////////////////
// CCollection Additional functions


/////////////////////////////////////////////////////////////////////////////
// CCollection::SetWaveIDs

void CCollection::SetWaveIDs()
{
    DWORD dwID = 0;
	CPtrList waveList;

	if(FAILED(m_Waves.GetListOfMonoWaves(&waveList)))
		return;

	if(waveList.IsEmpty())
		return;

	// assign IDs to mono waves, starting at 0, as required by DLS spec
	POSITION position = waveList.GetHeadPosition();
	while(position)
		{
		CMonoWave* pMonoWave = (CMonoWave*)waveList.GetNext(position);
		ASSERT(pMonoWave);

		pMonoWave->SetWaveID(dwID++);
		}

	waveList.RemoveAll();
	if(FAILED(m_Waves.GetListOfWaves(&waveList)))
		return;

	// assign IDs to all other waves, to facilitate internal save & load
	position = waveList.GetHeadPosition();
	while(position)
		{
		CWave* pWave = (CWave*)waveList.GetNext(position);
		ASSERT(pWave);

		if (pWave->GetChannelCount() > 1)
			pWave->SetWaveID(dwID++);
		}
}

/////////////////////////////////////////////////////////////////////////////
// CCollection::PrepareConnections

void CCollection::PrepareConnections()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);		
 
	SetWaveIDs();

	CInstrument *pInstrument = m_Instruments.GetHead();
    for ( ; pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        CRegion *pRegion = pInstrument->m_Regions.GetHead();
        for ( ; pRegion != NULL; pRegion = pRegion->GetNext())
        {
            if (pRegion->m_pWave != NULL)
            {
				pRegion->m_rWaveLink.ulTableIndex = pRegion->m_pWave->GetWaveID();
            }
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CCollection::Save

HRESULT CCollection::Save(IDMUSProdRIFFStream* pIRiffStream, BOOL fFullSave)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIRiffStream);

    IStream* pIStream = pIRiffStream->GetStream();

	ASSERT(pIStream);

	HRESULT			hr = S_OK;			// Return code
	MMCKINFO		ckMain;
	MMCKINFO		ck;
    MMCKINFO        dck;
	DWORD			cb;
	CInstrument *	pInstrument;
	CWaveNode*		pWaveNode = NULL;
    CWave*			pWave = NULL;

    SetWaveIDs();

	ckMain.fccType = mmioFOURCC('D','L','S',' ');
	hr = pIRiffStream->CreateChunk(&ckMain, MMIO_CREATERIFF);
    if (FAILED(hr))
	{
		pIStream->Release();
        return (hr);
    }

    ck.ckid = FOURCC_DLID ;
    hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }

	if (m_Guid != GUID_NULL)
	{
		hr = pIStream->Write((LPSTR) &m_Guid, sizeof(GUID), &cb);	
		if (FAILED(hr) || cb != sizeof(GUID))
		{
			pIStream->Release();
			return (hr);
		}
	}

	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
    {
		pIStream->Release();
        return (E_FAIL);
    }

    ck.ckid = FOURCC_COLH ;
    hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }

    m_rDLSHeader.cInstruments = m_Instruments.GetCount();

    hr = pIStream->Write((LPSTR) &m_rDLSHeader, sizeof(DLSHEADER), &cb);	
    if (FAILED(hr) || cb != sizeof(DLSHEADER))
    {
		pIStream->Release();
        return (hr);
    }
    
	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
    {
		pIStream->Release();
        return (E_FAIL);
    }
    
	ck.ckid = FOURCC_VERS ;
    hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }
    hr = pIStream->Write((LPSTR) &m_rVersion, sizeof(DLSVERSION), &cb);	
    if (FAILED(hr) || cb != sizeof(DLSVERSION))
    {
		pIStream->Release();
        return (hr);
    }
    if (FAILED(pIRiffStream->Ascend(&ck, 0)))
    {
		pIStream->Release();
        return (E_FAIL);
    }

	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return (E_FAIL);
	}

	dck.fccType = FOURCC_LINS ;
	hr = pIRiffStream->CreateChunk(&dck,MMIO_CREATELIST);
	if (FAILED(hr))
	{
		pIStream->Release();
		return (hr);
	}

	PrepareConnections();
	pInstrument = m_Instruments.GetHead();
	for ( ; pInstrument; pInstrument = pInstrument->GetNext())
	{
		hr = pInstrument->Save(pIRiffStream, TRUE);
		if (FAILED(hr)) 
		{
			pIStream->Release();
			return(hr);
		}
	}

	pIRiffStream->Ascend(&dck, 0);
	if (fFullSave)
	{
		ck.ckid = FOURCC_PTBL ;
		hr = pIRiffStream->CreateChunk(&ck, 0);
		if (FAILED(hr))
		{
			pIStream->Release();
			return (hr);
		}

		POOLTABLE table;
		table.cbSize = sizeof(POOLTABLE);
		
		// Get the list of all mono waves
		CPtrList waveList;
		if(FAILED(m_Waves.GetListOfMonoWaves(&waveList)))
		{
			pIStream->Release();
			return E_OUTOFMEMORY;
		}

		table.cCues = waveList.GetCount();
		hr = pIStream->Write((LPSTR) &table,sizeof(POOLTABLE), &cb);	
		if (FAILED(hr) || cb != sizeof(POOLTABLE))
		{
			pIStream->Release();
			return (hr);
		}

		unsigned long ulTablePos;
		unsigned long ulPoolEnd;
		unsigned long ulWaveStart;

		ulTablePos = GetFilePos(pIStream);

		POSITION position = waveList.GetHeadPosition();
		while(position)
		{
			POOLCUE cue;
			cue.ulOffset = 0;
			hr = pIStream->Write((LPSTR) &cue,sizeof(POOLCUE), &cb);	
			if (FAILED(hr) || cb != sizeof(POOLCUE))
			{
				pIStream->Release();
				return (hr);
			}
			waveList.GetNext(position);
		}

		if (FAILED(pIRiffStream->Ascend(&ck, 0)))
		{
			pIStream->Release();
			return (E_FAIL);
		}

		dck.fccType = FOURCC_WVPL ;
		hr = pIRiffStream->CreateChunk(&dck,MMIO_CREATELIST);
		if (FAILED(hr))
		{
			pIStream->Release();
			return (hr);
		}
		ulWaveStart = GetFilePos(pIStream);
		pWaveNode = m_Waves.GetHead();
		for ( ; pWaveNode; pWaveNode = pWaveNode->GetNext())
		{
			CWave* pWave = pWaveNode->GetWave();
			ASSERT(pWave);

			hr = pWave->Save(pIRiffStream, MMIO_CREATELIST, TRUE);
			if (FAILED(hr)) 
			{
				pIStream->Release();
				return(hr);
			}
		}

		pIRiffStream->Ascend(&dck, 0);
		ulPoolEnd = GetFilePos(pIStream);
		SetFilePos(pIStream, ulTablePos);

		position = waveList.GetHeadPosition();
		while(position)
		{
			CMonoWave* pWave = (CMonoWave*)waveList.GetNext(position);
			ASSERT(pWave);
			
			POOLCUE cue;
			
			if(pWave)
			{
				cue.ulOffset = pWave->GetWavePoolOffset() - ulWaveStart;
				hr = pIStream->Write((LPSTR) &cue, sizeof(POOLCUE), &cb);	
				if (FAILED(hr) || cb != sizeof(POOLCUE))
				{
					pIStream->Release();
					return (hr);
				}
			}
		}

		SetFilePos(pIStream, ulPoolEnd);
		m_Info.Save(pIRiffStream);
        m_UnknownChunk.Save(pIRiffStream);
	}
    pIRiffStream->Ascend(&ckMain, 0);
	pIStream->Release();
    return (hr);
}

/////////////////////////////////////////////////////////////////////////////
// CCollection::Download
HRESULT CCollection::Download()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT	hr = S_OK;
	
	if(m_pComponent->m_lstDLSPortDownload.IsEmpty())
	{
		return E_FAIL;
	}

	if(m_pComponent->IsAutoDownloadOkay() == FALSE)
	{
		// Okay not to download anything if preference set that way
		return S_OK;
	}
	

	POSITION position = m_pComponent->m_lstDLSPortDownload.GetHeadPosition();
	while(position)
	{
		IDirectMusicPortDownload* pIDMPortDownload = m_pComponent->m_lstDLSPortDownload.GetNext(position);

		CWaveNode* pWaveNode = m_Waves.GetHead();
		for ( ; pWaveNode != NULL; pWaveNode = pWaveNode->GetNext())
		{
			hr = pWaveNode->DM_Init(pIDMPortDownload);
			if (SUCCEEDED(hr))
			{
				hr = pWaveNode->Download(pIDMPortDownload);
				if ( !SUCCEEDED(hr) )
				{
					if(hr & (DMUS_E_INSUFFICIENTBUFFER | DMUS_E_BUFFERNOTSET | DMUS_E_BUFFERNOTAVAILABLE))
					{
						/*CString sPortName;
						m_pComponent->GetPortName(pIDMPortDownload, sPortName);
						CString sErrorMessage;
						sErrorMessage.Format(IDS_ERR_FAILEDBUFFER,sPortName);
						AfxMessageBox(sErrorMessage);*/

						// ashtat - BUGBUG!! Needs a better message - see Manbugs:33331
						AfxMessageBox(IDS_ERR_DOWNLOAD_DLS_CONFIG);
						break;
					}
					AfxMessageBox(IDS_ERR_INIT_DOWNLOAD,MB_OK | MB_ICONEXCLAMATION);
				}
			}
			else if(hr & E_OUTOFMEMORY)
			{
				AfxMessageBox(IDS_ERR_WAVE_DOWNLOAD_FAILED, MB_OK | MB_ICONEXCLAMATION);

				// Does it make sense to keep trying to download the rest of the 
				// waves instead of breaking out of this loop? What if there isn't
				// sufficient memory to download a huge wave but other smaller 
				// waves can still be downloaded, right? 
				// Also should we continue to try and download the instruments once 
				// this has failed?? The user will not be able to hear anything in the 
				// instruments that refer to waves that haven't been downloaded
				break;
			}
		}

		CInstrument* pInstrument = m_Instruments.GetHead();
		for( ; pInstrument != NULL; pInstrument = pInstrument->GetNext())
		{
			hr = pInstrument->DM_Init(pIDMPortDownload);
			if (SUCCEEDED(hr))
			{
				hr = pInstrument->Download(pIDMPortDownload);
				if ( !SUCCEEDED(hr) )
				{
					if(hr & (DMUS_E_INSUFFICIENTBUFFER | DMUS_E_BUFFERNOTSET | DMUS_E_BUFFERNOTAVAILABLE))
					{
						/*CString sPortName;
						m_pComponent->GetPortName(pIDMPortDownload, sPortName);
						CString sErrorMessage;
						sErrorMessage.Format(IDS_ERR_FAILEDBUFFER,sPortName);
						AfxMessageBox(sErrorMessage);*/
						// ashtat - BUGBUG!! Needs a better message - see Manbugs:33331
						
						AfxMessageBox(IDS_ERR_DOWNLOAD_DLS_CONFIG);
						break;
					}
					AfxMessageBox(IDS_ERR_INIT_DOWNLOAD,MB_OK | MB_ICONEXCLAMATION);
				}
				else if(hr & E_OUTOFMEMORY)
				{
					AfxMessageBox(IDS_ERR_INST_DOWNLOAD_FAILED, MB_OK | MB_ICONEXCLAMATION);

					// It does make sense to NOT download anymore instruments 
					// once we run out memory since most instruments will 
					// require approximately same memory (though the size will 
					// vary depending on the number of regions and articulations 
					// but not as much as it will for waves right?).
					break;

				}

				pInstrument->UpdatePatch();
			}
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
// CCollection::Unload - "Undownloads" all the wavs and instruments from the port
void CCollection::Unload()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pComponent->m_lstDLSPortDownload.IsEmpty())
		return;

	POSITION position = m_pComponent->m_lstDLSPortDownload.GetHeadPosition();
	while(position)
	{
		IDirectMusicPortDownload* pIDMPortDownload = m_pComponent->m_lstDLSPortDownload.GetNext(position);		
		ASSERT(pIDMPortDownload);

		// ALWAYS unload instruments BEFORE waves 
		CInstrument* pInstrument = m_Instruments.GetHead();
		for( ; pInstrument != NULL; pInstrument = pInstrument->GetNext())
		{
			pInstrument->Stop(true);
			pInstrument->Unload(pIDMPortDownload);
		}
		
		CWaveNode* pWaveNode = m_Waves.GetHead();
		for ( ; pWaveNode != NULL; pWaveNode = pWaveNode->GetNext())
		{
			// Stop the wave if it's playing 
			pWaveNode->Stop(true);
			pWaveNode->Unload(pIDMPortDownload);
		}
	}
}



//////////////////////////////////////////////////////////////////////////////
// CCollection::Load

HRESULT CCollection::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	ASSERT( theApp.m_hKeyProgressBar == NULL );	// Should not happen!
	if( theApp.m_hKeyProgressBar )				// Just in case....
	{
		m_pComponent->m_pIFramework->EndProgressBar( theApp.m_hKeyProgressBar );
		theApp.m_hKeyProgressBar = NULL;
	}

	// Start the progress bar
	CString strPrompt = _T( "Loading Collection  " );
	BSTR bstrPrompt = strPrompt.AllocSysString();
	m_pComponent->m_pIFramework->StartProgressBar(0, 100, bstrPrompt, &theApp.m_hKeyProgressBar);
	m_pComponent->m_pIFramework->SetProgressBarPos( theApp.m_hKeyProgressBar, 0 );
	theApp.m_dwProgressBarIncrement = pckMain->cksize / 100;
	theApp.m_dwProgressBarIncrement = theApp.m_dwProgressBarIncrement == 0 ? 1 : theApp.m_dwProgressBarIncrement;
	theApp.m_dwProgressBarTotalBytes = pckMain->cksize; 
	theApp.m_dwProgressBarRemainingBytes = pckMain->cksize; 

	CSystemConfiguration* pConfig = NULL;
	
	IStream* pIStream;
	MMCKINFO ck;
	DWORD cb;
	DWORD cSize;
    HRESULT hr = S_OK;

	ASSERT(pIRiffStream != NULL);
	ASSERT(pckMain != NULL);
	ASSERT(m_pComponent != NULL);

    pIStream = pIRiffStream->GetStream();
	
	ASSERT(pIStream != NULL);

	ck.ckid = 0;
	ck.fccType = 0;
    while(pIRiffStream->Descend( &ck, pckMain, 0 ) == 0)
	{
		switch(ck.ckid)
		{
			case FOURCC_EDIT:
			case FOURCC_MSYN:
				break;
			case FOURCC_COLH :
            {
				if(ck.cksize < sizeof(DLSHEADER))
				{
					cSize = ck.cksize;
				}
				else
				{
					cSize = sizeof(DLSHEADER);
				}
				hr = pIStream->Read( &m_rDLSHeader, cSize, &cb );
			}
			
			if( FAILED(hr) || cb != cSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			break;
		
			case FOURCC_VERS :
			{
				if( ck.cksize < sizeof(DLSVERSION) )
				{
					cSize = ck.cksize;
				}
				else
				{
					cSize = sizeof(DLSVERSION);
				}

				hr = pIStream->Read( &m_rVersion, cSize, &cb );
			}
			
			if( FAILED(hr) || cb != cSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
			
			break;

			case FOURCC_DLID:
				hr = pIStream->Read( &m_Guid, sizeof(GUID), &cb );
				if( FAILED(hr) || cb != sizeof(GUID))
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case FOURCC_LIST:
			switch (ck.fccType)
			{
				case FOURCC_LINS :
				{
					DWORD dwOrigRemainingBytes = theApp.m_dwProgressBarRemainingBytes;
					if(FAILED(hr = m_Instruments.Load(pIRiffStream,&ck)))
					{
						goto ON_ERROR;
					}
					theApp.m_dwProgressBarRemainingBytes = dwOrigRemainingBytes;	
					break;
				}

				case mmioFOURCC('I','N','F','O') :
					m_Info.Load(pIRiffStream,&ck);
					break;

				case FOURCC_WVPL :
                case mmioFOURCC('d','w','p','l') :
				{
					DWORD dwOrigRemainingBytes = theApp.m_dwProgressBarRemainingBytes;
					if(FAILED(m_Waves.Load(pIRiffStream,&ck)))
					{
						// We will refuse to load the collection if every single wave failed to load.
						// Could happen with collections that have waves compressed in unknown formats...
						if(m_Waves.GetCount() == 0)
						{
							// Could not load the waves in this collection. They may be using an unknown compression.
							// Please make sure the proper codec is installed on your computer, or uncompress the
							// waves in this DLS collection before loading it into DirectMusic Producer. 
							AfxMessageBox(IDS_ERR_COLLECTION_NO_WAVES);
							hr = E_FAIL;
							goto ON_ERROR;
						}

						// Could not load some waves in this collection. They will be removed from the designtime file.
						// These waves may have been using an unknown compression. Please make sure the proper codec
						// is installed on your computer, or uncompress these waves before loading them into DirectMusic Producer.
						AfxMessageBox(IDS_ERR_COLLECTION_WAVE_LOAD);
					}
					theApp.m_dwProgressBarRemainingBytes = dwOrigRemainingBytes;	
					break;
				}

                default:
                    m_UnknownChunk.Load(pIRiffStream, &ck, TRUE);
                    break;
			}
			break;

            case FOURCC_PTBL:
                break;

            default:
                m_UnknownChunk.Load(pIRiffStream, &ck, FALSE);
                break;
        }

		theApp.m_dwProgressBarRemainingBytes -= ck.cksize;
		m_pComponent->m_pIFramework->SetProgressBarPos( theApp.m_hKeyProgressBar,
					(theApp.m_dwProgressBarTotalBytes - theApp.m_dwProgressBarRemainingBytes) / theApp.m_dwProgressBarIncrement );

        pIRiffStream->Ascend( &ck, 0 );
    }

	ResolveConnections();

	// Setup for the current config
	pConfig = m_pComponent->GetCurrentConfig();
	if(pConfig)
	{
		OnConditionConfigChanged(pConfig, false);
	}

	// Check to make sure that the Framework has not set this flag to
	// FALSE. Which means that the collection will be loaded later on 
	// FileOpen().
	if (TRUE == m_pComponent->IsCollectionDownloadOK())
	{
		if(FAILED(Download()))
		{
			// Don't throw up the error-message if the MIDI button is toggled off
			if(m_pComponent->FindCollectionGUID(m_Guid) == NULL && m_bNoMIDIPort == FALSE)
			{
				AfxMessageBox(IDS_ERR_DOWNLOAD);
			}

			m_pComponent->AddToFailedCollectionGUIDs(m_Guid);
			hr = S_FALSE;
		}

		if(FAILED(hr) == FALSE)
		{
			m_pComponent->AddToCollectionList(this);
			m_Waves.RegisterWavesWithTransport();
		}
	}


ON_ERROR:
	pIStream->Release();
	m_pComponent->m_pIFramework->EndProgressBar( theApp.m_hKeyProgressBar );
	theApp.m_hKeyProgressBar = NULL;
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCollection::SampleCount

DWORD CCollection::SampleCount()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);		
    CWaveNode* pWaveNode = m_Waves.GetHead();
    DWORD dwCount = 0;
    for( ; pWaveNode != NULL; pWaveNode = pWaveNode->GetNext())
    {
		CWave* pWave = pWaveNode->GetWave();
		ASSERT(pWave);
		
        dwCount += pWave->GetWaveLength();
    }
    return dwCount;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection::ArticulationCount

DWORD CCollection::ArticulationCount()
{
    CInstrument *pInstrument = m_Instruments.GetHead();
    DWORD dwCount = 0;
    for ( ; pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
		CRegion *pRegion = pInstrument->m_Regions.GetHead();
		for ( ; pRegion != NULL; pRegion = pRegion->GetNext())
		{
			if (pRegion->m_pArticulation)
			{
				dwCount++;
			}
		}
		
		dwCount += pInstrument->GetArticulationCount();
    }
    return dwCount;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection::RegionCount

DWORD CCollection::RegionCount()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);		    
	CInstrument *pInstrument = m_Instruments.GetHead();
    DWORD dwCount = 0;
    for ( ; pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        dwCount += pInstrument->m_Regions.GetCount();
    }
    return dwCount;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection::InstrumentCount

DWORD CCollection::InstrumentCount()

{
    CInstrument *pInstrument = m_Instruments.GetHead();
    DWORD dwCount = 0;
    for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
    {
        dwCount++;
    }
    return dwCount;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection::WaveCount

DWORD CCollection::WaveCount()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);		    
	
	CWaveNode* pWaveNode = m_Waves.GetHead();
    DWORD dwCount = 0;
    for (;pWaveNode != NULL; pWaveNode = pWaveNode->GetNext())
    {
        dwCount++;
    }
    return dwCount;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection::WaveNodeCount

DWORD CCollection::WaveNodeCount()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return m_Waves.GetCount();
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject::GetData

HRESULT CCollection::GetData(void** ppData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(ppData);

	*ppData = this;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject::SetData

HRESULT CCollection::SetData(void* pData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pData);

	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CCollection::OnRemoveFromPageManager(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject::OnShowProperties

HRESULT CCollection::OnShowProperties(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	// Show the Collection properties
	IDMUSProdPropSheet* pIPropSheet;

	hr = m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet);
	if(SUCCEEDED(hr))
	{
		int nLastPage = CCollectionPropPgMgr::m_dwLastSelPage;
		hr = pIPropSheet->SetPageManager(m_pCollectionPropPgMgr);
		
		if(SUCCEEDED(hr))
		{
			m_pCollectionPropPgMgr->SetObject(this);
			pIPropSheet->SetActivePage(short(nLastPage)); 
		}

		pIPropSheet->Show(TRUE);
		pIPropSheet->Release();
	}

	return hr;
}

bool CCollection::IsWaveReferenced(CWave *pWave, IDMUSProdNode** ppReferenceNode)
{
	CInstrument*	pInstr;
	CRegion*		pRegion;

	pInstr = m_Instruments.GetHead();
	while (pInstr)
		{
		pRegion = pInstr->m_Regions.GetHead();
		while ( pRegion )
			{
			if (pWave->IsReferencedBy(pRegion->m_pWave))
				{
				*ppReferenceNode = pInstr;
				return true;
				}

			pRegion = pRegion->GetNext();
			}
		pInstr = pInstr->GetNext();
		}
	return false;
}

void CCollection::ValidateInstrumentPatches()
{
	CInstrument*	pInstrument = m_Instruments.GetHead();
	while (pInstrument)
	{
		if( !pInstrument->ValidatePatch() )
		{
			m_pComponent->NotifyDummyInstruments();
			pInstrument->UpdateInstrument();
			pInstrument->UpdatePatch();
		}
		pInstrument = pInstrument->GetNext();
	}
	m_fPatchResolution = 0;
}

BOOL CCollection::VerifyDLS()
{
    CInstrument* pInstrument = m_Instruments.GetHead();
    for (;pInstrument;pInstrument = pInstrument->GetNext())
    {
        CInstrument* pScan = pInstrument->GetNext();
        
		for (;pScan;pScan = pScan->GetNext())
        {
            if (pInstrument->m_rInstHeader.Locale.ulInstrument == pScan->m_rInstHeader.Locale.ulInstrument)
            {
                if (pInstrument->m_rInstHeader.Locale.ulBank == pScan->m_rInstHeader.Locale.ulBank)
                {
					CString sErrorMessage;
					CString sContinuePrompt;
					sContinuePrompt.LoadString(IDS_CONTINUE_VERIFYDLS);
					sErrorMessage.Format(IDS_ERR_INST_SAME_ADDRESS,	pInstrument->m_csName,pScan->m_csName);
					sErrorMessage = m_Info.m_csName + ":" + sErrorMessage + "\n" + sContinuePrompt;
					if(IDCANCEL == AfxMessageBox(sErrorMessage, MB_OKCANCEL | MB_ICONEXCLAMATION,0))
						return FALSE;
                }
            }
        }

        if (!pInstrument->VerifyDLS()) 
			return FALSE;
    }

	return TRUE;
}

CCollectionInstruments* CCollection::GetInstruments()
{
	return &m_Instruments;
}

HRESULT CCollection::GetObjectDescriptor( void* pObjectDesc )
{
	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	// Set values in DMUS_OBJECTDESC structure
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &m_Guid, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicCollection, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = m_rVersion.dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = m_rVersion.dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, m_Info.m_csName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


HRESULT CCollection::GetListOfConditions(CPtrList* pConditionList)
{
	ASSERT(pConditionList);
	if(pConditionList == NULL)
		return E_POINTER;

	
	CInstrument* pInstrument = m_Instruments.GetHead();
	while(pInstrument)
	{
		if(FAILED(pInstrument->GetListOfConditions(pConditionList)))
		{
			return E_FAIL;
		}

		pInstrument = pInstrument->GetNext();
	}

	return S_OK;
}

void CCollection::OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode)
{
	ASSERT(pCurrentConfig);
	if(pCurrentConfig == NULL)
	{
		return;
	}

	// Notify all instruments
	CInstrument* pInstrument = m_Instruments.GetHead();
	while(pInstrument)
	{
		pInstrument->OnConditionConfigChanged(pCurrentConfig, bRefreshNode);
		pInstrument = pInstrument->GetNext();
	}
}

void CCollection::SetNodeFileName(CString sFileName)
{
	ASSERT(sFileName.IsEmpty() == FALSE);
	m_sFileName = sFileName;
}

CString	CCollection::GetNodeFileName()
{
	// If the collection name is empty then goto the framework to get the owner's filename
	// This might be a wavenode in an embedded collection
	if(m_sFileName.IsEmpty())
	{
		ASSERT(m_pComponent);
		ASSERT(m_pComponent->m_pIFramework);
		IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
		BSTR bstrFileName;
		if(FAILED(pIFramework->GetNodeFileName(this, &bstrFileName)))
		{
			return "";
		}
		
		m_sFileName = bstrFileName;
		::SysFreeString(bstrFileName);
	}
	
	return m_sFileName;
}

HRESULT CCollection::FindWaveNodeByGUID(GUID guidNode, CWaveNode** ppWaveNode)
{
	ASSERT(ppWaveNode);
	if(ppWaveNode == NULL)
	{
		return E_POINTER;
	}

	CWaveNode* pNode = m_Waves.GetHead();
	while(pNode)
	{
		GUID guid = pNode->GetGUID();

		if(IsEqualGUID(guid, guidNode))
		{
			*ppWaveNode = pNode;
			return S_OK;
		}

		pNode = pNode->GetNext();
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollection::GetGUID

void CCollection::GetGUID( GUID* pguidCollection )
{
	if( pguidCollection )
	{
		*pguidCollection = m_Guid;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCollection::SetGUID

void CCollection::SetGUID( GUID guidCollection )
{
	m_Guid = guidCollection;
	SetDirtyFlag();

	// Notify connected nodes that Collection GUID has changed
	m_pComponent->m_pIFramework->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}


//////////////////////////////////////////////////////////////////////////////
// CCollection::CreateDMCollection
HRESULT CCollection::CreateDMCollection()
{
	ASSERT(m_pIDMCollection == NULL);
	if(m_pIDMCollection)
	{
		return E_UNEXPECTED;
	}

	if(FAILED(::CoCreateInstance(CLSID_DirectMusicCollection, NULL, CLSCTX_INPROC, IID_IDirectMusicCollection, (void**)&m_pIDMCollection)))
	{
		return E_FAIL;
	}

	// Just making sure....
	ASSERT(m_pIDMCollection);
	if(FAILED(SyncDMCollection()))
	{
		return E_FAIL;
	}
	
	return S_OK;
}


HRESULT CCollection::SyncDMCollection()
{
	ASSERT(m_pIDMCollection);
	if(m_pIDMCollection == NULL)
	{
		return E_FAIL;
	}
	
	// No need to load the DirectMusicObject if we're already downloaded
	if(m_pComponent->IsAutoDownloadOkay() == TRUE)
	{
		return S_FALSE;
	}

	IPersistStream* pIPersistStream = NULL;
	if(FAILED(m_pIDMCollection->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream)))
	{
		m_pIDMCollection->Release();
		m_pIDMCollection = NULL;
		return E_FAIL;
	}

	IStream* pIStream = NULL;
	if(FAILED(m_pComponent->m_pIFramework->AllocMemoryStream(FT_RUNTIME, GUID_CurrentVersion, &pIStream)))
	{
		pIPersistStream->Release();
		m_pIDMCollection->Release();
		m_pIDMCollection = NULL;
		return E_FAIL;
	}

	if(FAILED(Save(pIStream, FALSE)))
	{
		pIStream->Release();
		pIPersistStream->Release();
		m_pIDMCollection->Release();
		m_pIDMCollection = NULL;
	}

	// Seek back to the start of the stream
	StreamSeek( pIStream, 0, STREAM_SEEK_SET );


	if(FAILED(pIPersistStream->Load(pIStream)))
	{
		pIStream->Release();
		pIPersistStream->Release();
		m_pIDMCollection->Release();
		m_pIDMCollection = NULL;

		return E_FAIL;
	}

	pIStream->Release();
	pIPersistStream->Release();

	return S_OK;
}


void CCollection::ReleaseDMCollection()
{
	if(m_pIDMCollection)
	{
		m_pIDMCollection->Release();
		m_pIDMCollection = NULL;
	}
}

void CCollection::SetDirtyFlag() 
{
	m_bIsDirty = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionInstruments.cpp ===
// CollectionInstruments.cpp : implementation file
//

#include "stdafx.h"
#include "DlsDefsPlus.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "Articulation.h"
#include "WaveNode.h"
#include "wave.h"
#include "MonoWave.h"
#include "StereoWave.h"

// Comment out the below line to make the IDM_NEW_INSTRUMENT command dump the instrument list
// to C:\collection.txt before it inserts a new instrument
// #define DUMP_INSTRUMENTS_ON_NEW_INSTRUMENT 1

#ifdef DUMP_INSTRUMENTS_ON_NEW_INSTRUMENT
#include <fstream.h>
#endif // DUMP_INSTRUMENTS_ON_NEW_INSTRUMENT

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments constructor/destructor

CCollectionInstruments::CCollectionInstruments() :
m_dwRef(0),
m_pIRootNode(NULL),
m_pIParentNode(NULL),
m_pDLSComponent(NULL),
m_pCollection(NULL)
{
	AddRef();
}

CCollectionInstruments::~CCollectionInstruments()
{
	while(!IsEmpty())
	{
        CInstrument *pInstrument = RemoveHead();
        pInstrument->Release();
	}
}

void CCollectionInstruments::AddTail(CInstrument *pINode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pINode);

	AList::AddTail((AListItem *) pINode);
}

CInstrument *CCollectionInstruments::GetHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return (CInstrument *) AList::GetHead();
}

CInstrument *CCollectionInstruments::RemoveHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return (CInstrument *) AList::RemoveHead();
}

void CCollectionInstruments::Remove(CInstrument *pINode) 
{ 
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pINode);
	
	AList::Remove((AListItem *) pINode);
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IUnknown implementation

HRESULT CCollectionInstruments::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CCollectionInstruments::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CCollectionInstruments::Release()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetNodeImageIndex

HRESULT CCollectionInstruments::GetNodeImageIndex(short* pnFirstImage)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnFirstImage);

	ASSERT(m_pDLSComponent != NULL);

	return(m_pDLSComponent->GetFolderImageIndex(pnFirstImage));
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetComponent

HRESULT CCollectionInstruments::GetComponent(IDMUSProdComponent** ppIComponent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(m_pDLSComponent != NULL);
	
	ASSERT(ppIComponent);
	
	return m_pDLSComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetRootNode

HRESULT CCollectionInstruments::GetDocRootNode(IDMUSProdNode** ppIRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIRootNode )
	{
		m_pIRootNode->AddRef();
		*ppIRootNode = m_pIRootNode;
		return S_OK;
	}

	*ppIRootNode = NULL;
	return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::SetRootNode

HRESULT CCollectionInstruments::SetDocRootNode(IDMUSProdNode* pIRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pIRootNode != NULL);

	m_pIRootNode = pIRootNode;
//	m_pIRootNode->AddRef();		intentionally missing

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetParentNode

HRESULT CCollectionInstruments::GetParentNode(IDMUSProdNode** ppIParentNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(m_pIParentNode != NULL);

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::SetParentNode

HRESULT CCollectionInstruments::SetParentNode(IDMUSProdNode* pIParentNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetNodeId

HRESULT CCollectionInstruments::GetNodeId(GUID* pguid)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pguid);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_InstrumentFolderNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetNodeName

HRESULT CCollectionInstruments::GetNodeName(BSTR* pbstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pbstrName);

	CString strName;
	TCHAR achBuffer[BUFFER_128];

	if(::LoadString(theApp.m_hInstance, IDS_INSTRUMENT_FOLDER_NAME, achBuffer, BUFFER_128))
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetNodeNameMaxLength

HRESULT CCollectionInstruments::GetNodeNameMaxLength(short* pnMaxLength)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnMaxLength);

	*pnMaxLength = -1;	// Can't rename a Instrument folder

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::ValidateNodeName

HRESULT CCollectionInstruments::ValidateNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Just free bstrName; can't rename Instruments folder
	::SysFreeString(bstrName);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::SetNodeName

HRESULT CCollectionInstruments::SetNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Just free bStrName; can't rename a Instrument folder	
	::SysFreeString( bstrName );

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetEditorClsId

HRESULT CCollectionInstruments::GetEditorClsId(CLSID* pClsId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Instrument folder
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetEditorTitle

HRESULT CCollectionInstruments::GetEditorTitle(BSTR* pbstrTitle)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return E_NOTIMPL;	// Can't edit a Instrument folder
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetEditorWindow

HRESULT CCollectionInstruments::GetEditorWindow(HWND* hWndEditor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return E_NOTIMPL;	// Can't edit a Instrument folder
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::SetEditorWindow

HRESULT CCollectionInstruments::SetEditorWindow(HWND hWndEditor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Instrument folder
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::UseOpenCloseImages

HRESULT CCollectionInstruments::UseOpenCloseImages(BOOL* pfUseOpenCloseImages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pfUseOpenCloseImages);
	
	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetRightClickMenuId

HRESULT CCollectionInstruments::GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMenuId);
	ASSERT(phInstance);
	
	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_INSTRUMENTS_NODE_RMENU;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::OnRightClickMenuInit

HRESULT CCollectionInstruments::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CMenu menu;
	
	if( menu.Attach(hMenu) )
	{
		// See if we need to disable the Paste menu item...
		IDataObject* pIDataObject;
		BOOL fWillSetReference;

		menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

		if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
		{
			if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
			{
				menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
			}
			
			pIDataObject->Release();
		}

		menu.Detach();
	}


	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::OnRightClickMenuSelect

HRESULT CCollectionInstruments::OnRightClickMenuSelect(long lCommandId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	HRESULT hr = E_FAIL;

	switch(lCommandId)
	{
		case IDM_NEW_INSTRUMENT:
		{
#ifdef DUMP_INSTRUMENTS_ON_NEW_INSTRUMENT
			if( m_pCollection )
			{
				ofstream oFile;
				oFile.open("c:\\collection.txt", ios::out );
				if( oFile.is_open() )
				{
					CInstrument *pInstrument = m_pCollection->m_Instruments.GetHead();
					while( pInstrument )
					{
						CString strName;
						pInstrument->GetName( strName );

						CString strInstrument;
						strInstrument.Format("%s\t%d\t%d\t%d\t%d\n", strName, (pInstrument->m_rInstHeader.Locale.ulBank >> 31), (pInstrument->m_rInstHeader.Locale.ulBank >> 8) & 0x7F, pInstrument->m_rInstHeader.Locale.ulBank & 0x7F, pInstrument->m_rInstHeader.Locale.ulInstrument);

						oFile << strInstrument;

						pInstrument = pInstrument->GetNext();
					}
					oFile.close();
				}
			}
#endif // DUMP_INSTRUMENTS_ON_NEW_INSTRUMENT

			hr = InsertChildNode(NULL);
			if(m_pCollection)
			{
				m_pCollection->ValidateInstrumentPatches();
				RefreshAllNodes();
			}
			break;
		}

		case IDM_PASTE:
		{
			IDataObject* pIDataObject = NULL;
			BOOL fWillSetReference = FALSE;
			if(SUCCEEDED(::OleGetClipboard( &pIDataObject)))
			{
				if(CanPasteFromData(pIDataObject, &fWillSetReference) == S_OK)
				{
					PasteFromData(pIDataObject);
				}
				
				RELEASE(pIDataObject);
			}
			break;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::DeleteChildNode

HRESULT CCollectionInstruments::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT( pIChildNode != NULL );
	ASSERT( m_pDLSComponent != NULL );
	ASSERT( m_pDLSComponent->m_pIFramework != NULL );

	// Remove node from Project Tree
	if( m_pDLSComponent->m_pIFramework->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Remove from list
	Remove((CInstrument *)pIChildNode);
	pIChildNode->Release();

	// Set flag so we know to save file 
	m_pCollection->SetDirtyFlag();

	m_pDLSComponent->m_pIFramework->NotifyNodes(m_pCollection, INSTRUMENT_Deleted, NULL);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::InsertChildNode

HRESULT CCollectionInstruments::InsertChildNode(IDMUSProdNode* pIChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pDLSComponent != NULL);
	ASSERT(m_pDLSComponent->m_pIFramework != NULL);
	ASSERT(m_pCollection != NULL);

	if(m_pCollection->m_Waves.GetHead() == NULL) // This is not an empty collection
	{
		AfxMessageBox(IDS_INVALID_INSERT_INSTRUMENT);
		return E_FAIL;
	}

	BYTE	bMSB(0), bLSB(0), bPatch(0);
	HRESULT	hr;
	
	if(pIChildNode == NULL)
	{
		pIChildNode = new CInstrument(m_pDLSComponent);
		
		if( pIChildNode == NULL )
		{
			return E_OUTOFMEMORY;
		}
		
		// Get a new unique patch
		m_pDLSComponent->GetNextValidPatch(0,&bMSB, &bLSB, &bPatch);
		((CInstrument*)pIChildNode)->m_rInstHeader.Locale.ulBank = MAKE_BANK(0, bMSB, bLSB);
		((CInstrument*)pIChildNode)->m_rInstHeader.Locale.ulInstrument = bPatch;

		// Create a single default region
		// It will be inserted in tree when the instrument gets inserted
		CRegion* pRegion = new CRegion(m_pDLSComponent);
		if(pRegion)
		{
			CWave* pFirstWave = m_pCollection->m_Waves.GetFirstWave();

            // Add a wave to the region. 
			pRegion->SetInitialWave(pFirstWave);

			// We're using the wave node now
			pFirstWave->GetNode()->AddRef();

			((CInstrument*)pIChildNode)->m_Regions.AddTail(pRegion);
			pRegion->m_pInstrument = ((CInstrument*)pIChildNode);
		}
		else
		{
			goto LDeleteChildAndFail;
		}
		//Download to synth
		POSITION position = m_pDLSComponent->m_lstDLSPortDownload.GetHeadPosition();
		while(position)
		{
			IDirectMusicPortDownload* pIDMPortDownload = m_pDLSComponent->m_lstDLSPortDownload.GetNext(position);
			ASSERT(pIDMPortDownload);

			hr = ((CInstrument *)pIChildNode)->DM_Init(pIDMPortDownload);
			if (SUCCEEDED(hr))
			{
				hr = ((CInstrument *)pIChildNode)->Download(pIDMPortDownload);
				if ( !SUCCEEDED(hr) )
				{
					AfxMessageBox(IDS_ERR_INIT_DOWNLOAD,MB_OK | MB_ICONEXCLAMATION);
				}
			}
			else
			{
				if(hr == E_OUTOFMEMORY)
				{
					delete ((CInstrument*)pIChildNode)->m_Regions.RemoveHead();
					goto LDeleteChildAndFail;
				}
				return hr;
			}
		}
	}
	else
	{
		pIChildNode->AddRef();
	}

	((CInstrument *)pIChildNode)->m_pCollection = m_pCollection;

	// add to Instrument list
	AddTail( (CInstrument *) pIChildNode );

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pIChildNode, (IDMUSProdNode *)m_pCollection, (IDMUSProdNode *)this );

	// Add node to Project Tree
	if( !SUCCEEDED ( m_pDLSComponent->m_pIFramework->AddNode(pIChildNode, (IDMUSProdNode *)this) ) )
	{
		DeleteChildNode( pIChildNode, FALSE );
		return E_FAIL;
	}

	// Set flag so we know to save file 
	m_pCollection->SetDirtyFlag();
	
	return S_OK;

LDeleteChildAndFail:
	pIChildNode->Release();
	return E_OUTOFMEMORY;
}

////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::DeleteNode

HRESULT CCollectionInstruments::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
//
//	CCollectionInstruments IDMUSProdNode::GetFirstChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::GetFirstChild(IDMUSProdNode** ppIFirstChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppIFirstChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppIFirstChildNode = NULL;

	IDMUSProdNode* pINode = (IDMUSProdNode*) GetHead();

	if(pINode)
	{
		pINode->AddRef();
		*ppIFirstChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CCollectionInstruments IDMUSProdNode::GetNextChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppINextChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppINextChildNode = NULL;

	if(pIChildNode == NULL)
	{
		return E_INVALIDARG;
	}

	IDMUSProdNode* pINode = (IDMUSProdNode*) ((CInstrument *)pIChildNode)->GetNext();

	if(pINode)
	{
		pINode->AddRef();
		*ppINextChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CCollectionInstruments IDMUSProdNode::GetNodeListInfo
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::GetNodeListInfo(DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pListInfo);
	
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::OnNodeSelChanged

HRESULT CCollectionInstruments::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments IDMUSProdNode::CreateDataObject
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments IDMUSProdNode::CanCut
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::CanCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments IDMUSProdNode::CanCopy
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::CanCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments IDMUSProdNode::CanDelete
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::CanDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments IDMUSProdNode::CanDeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments IDMUSProdNode::CanPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_pDLSComponent->m_cfInstrument )) )
    {
        hr = S_OK;
    }

    pDataObject->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments IDMUSProdNode::PasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_pDLSComponent->m_cfInstrument) ) )
	{
		
		// Handle CF_WAVE format
		hr = PasteCF_INSTRUMENT( pDataObject, pIDataObject);
	}

    pDataObject->Release();

	// Check for patch conflicts after pasting the data
	if(SUCCEEDED(hr) && m_pCollection)
	{
		m_pCollection->ValidateInstrumentPatches();
		RefreshAllNodes();

		// This could be an instrument that's referenced by a band
		m_pDLSComponent->m_pIFramework->NotifyNodes(m_pCollection, INSTRUMENT_NameChange, NULL);

	}

    return hr;


}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments IDMUSProdNode::CanChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
													   BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments IDMUSProdNode::ChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return PasteFromData(pIDataObject);

}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments IDMUSProdNode::GetObject

HRESULT CCollectionInstruments::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollectionInstruments PasteCF_INSTRUMENT
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionInstruments::PasteCF_INSTRUMENT( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject)
{
	ASSERT(m_pDLSComponent);
	if(m_pDLSComponent == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdFramework* pIFramework = m_pDLSComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return E_UNEXPECTED;
	}

	IStream* pStream = NULL;
	HRESULT hr = E_FAIL;
	bool bCopyWaves = true;
	LONG lOriginalWaveCount = m_pCollection->m_Waves.GetCount();
	
	
	UINT nUserConfirmation = AfxMessageBox(IDS_WAVE_COPY_CONFIRMATION, MB_YESNOCANCEL);    

	if(nUserConfirmation == IDNO)
	{
		if(lOriginalWaveCount == 0)
		{
			AfxMessageBox(IDS_NO_WAVES_WARNING);
			return E_FAIL;
		}

		bCopyWaves = false;
	}
	else if(nUserConfirmation == IDCANCEL)
	{
		return E_FAIL;
	}
		

    if (SUCCEEDED(pDataObject->AttemptRead(pIDataObject,  m_pDLSComponent->m_cfInstrument, &pStream )))
    {
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new Instrument
		IDMUSProdNode* pINode = new CInstrument(m_pDLSComponent);
	    if( pINode == NULL )
	    {
	        return E_OUTOFMEMORY;
	    }
            
        IDMUSProdRIFFStream* pRiffStream = NULL;
        MMCKINFO ckMain;
        CInstrument* pInstrument = (CInstrument*)pINode;
        //alloc a riffstream
        hr = AllocRIFFStream(pStream, &pRiffStream);                
        if (SUCCEEDED(hr))
        {
            ckMain.fccType = FOURCC_INS;
            if( pRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
            {
                hr = pInstrument->Load(pRiffStream, &ckMain );
            }

			pRiffStream->Ascend( &ckMain, 0 );
		
			// Get a new unique patch
			BYTE bMSB(0), bLSB(0), bPatch(0);
			bool bDrums = (F_INSTRUMENT_DRUMS & pInstrument->m_rInstHeader.Locale.ulBank) != 0;
			m_pDLSComponent->GetNextValidPatch(bDrums,&bMSB, &bLSB, &bPatch);
			pInstrument->m_rInstHeader.Locale.ulBank = MAKE_BANK(bDrums, bMSB, bLSB);
			pInstrument->m_rInstHeader.Locale.ulInstrument = bPatch;

            // Add to the collection
            ((CInstrument*)pINode)->m_pCollection = m_pCollection;

            // add to the instrument list
            AddTail(pInstrument);
			
			if(bCopyWaves)
			{
				m_pCollection->m_Waves.PasteWaves(pRiffStream);
				m_pCollection->SetWaveIDs();

				CPtrList waveList;
				if(FAILED(m_pCollection->m_Waves.GetListOfMonoWaves(&waveList)))
				{
					pStream->Release();
					DeleteChildNode( pINode, FALSE );
					return E_OUTOFMEMORY;
				}

				CRegion* pRegion = pInstrument->m_Regions.GetHead();
				for ( ; pRegion != NULL; pRegion = pRegion->GetNext())
				{
					POSITION position = waveList.GetHeadPosition();
					while(position)
					{
						CWave* pWave = (CWave*) waveList.GetNext(position);
						ASSERT(pWave);

						// Set the wavelinks for copied regions and waves
						if(pWave->m_dwPreviousRegionLinkID == pRegion->m_rWaveLink.ulTableIndex)
						{
							// merge regions with same saved ID (different parts of mono waves)
							pRegion->MergeNextRegions(pWave);
						
							pRegion->m_rWaveLink.ulTableIndex = pWave->GetWaveID();
							pRegion->m_pWave = pWave;
							pWave->GetNode()->AddRef();
							pRegion->GetName();
							break;
						}
					}
				}
			}

			m_pCollection->ResolveConnections();

			// Set root and parent node of ALL children
            theApp.SetNodePointers( pINode, (IDMUSProdNode *)m_pCollection, (IDMUSProdNode *)this );

            // Add node to Project Tree
            if( !SUCCEEDED ( pIFramework->AddNode(pINode, (IDMUSProdNode *)this) ) )
            {
				pStream->Release();
	            DeleteChildNode( pINode, FALSE );
	            return E_FAIL;
            }

			pRiffStream->Release();

            // Set flag so we know to save file 
            m_pCollection->SetDirtyFlag();
			
			POSITION position = m_pDLSComponent->m_lstDLSPortDownload.GetHeadPosition();
			while(position)
			{
				IDirectMusicPortDownload* pIDMPortDownload = m_pDLSComponent->m_lstDLSPortDownload.GetNext(position);
				ASSERT(pIDMPortDownload);

				if ( pIDMPortDownload && SUCCEEDED(((CInstrument*)pINode)->DM_Init(pIDMPortDownload)) )
				{
					((CInstrument*)pINode)->Download(pIDMPortDownload);
				}
				else
				{
					pStream->Release();
					DeleteChildNode(pINode, FALSE);
					return E_FAIL;
				}

			}
            
			pStream->Release();
			pIFramework->SetSelectedNode(pINode);

        } // succeeded(hr)
		else
		{
			pStream->Release();
			pINode->Release();
			return E_FAIL;
		}
    }
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionInstruments::Load

HRESULT CCollectionInstruments::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{    
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	IStream* pIStream;
	MMCKINFO ck;
    HRESULT	hr = S_OK;

	ASSERT(m_pDLSComponent != NULL);
	ASSERT(pIRiffStream);
	ASSERT(pckMain);

    pIStream = pIRiffStream->GetStream();

	ASSERT(pIStream != NULL);

	ck.ckid = 0;
	ck.fccType = 0;
    while(pIRiffStream->Descend(&ck, pckMain, 0) == 0)
	{
		switch(ck.ckid) 
		{
			case FOURCC_LIST:
				switch(ck.fccType)
				{
					case FOURCC_INS :
						CInstrument *pInstrument = new CInstrument(m_pDLSComponent);
						if(pInstrument != NULL)
						{
							pInstrument->m_pCollection = m_pCollection;//for patch validation
							hr = pInstrument->Load(pIRiffStream, &ck);
							if( SUCCEEDED(hr) )
							{
								AddTail( pInstrument );
								pInstrument->m_pCollection = m_pCollection;
							}
							else
							{
								pInstrument->Release();
								pIStream->Release();
								return hr;
							}
						}
					break;
				}
			
			break;
		}

		theApp.m_dwProgressBarRemainingBytes -= ck.cksize;
		m_pDLSComponent->m_pIFramework->SetProgressBarPos( theApp.m_hKeyProgressBar,
					(theApp.m_dwProgressBarTotalBytes - theApp.m_dwProgressBarRemainingBytes) / theApp.m_dwProgressBarIncrement );

        pIRiffStream->Ascend(&ck, 0);
		ck.ckid = 0;
		ck.fccType = 0;
	}
	pIStream->Release();
	return hr;
}


void CCollectionInstruments::RefreshAllNodes()
{
	ASSERT(m_pDLSComponent->m_pIFramework);
	if(m_pDLSComponent->m_pIFramework == NULL)
		return;

	CInstrument* pInstrument = GetHead();
    for( ; pInstrument != NULL; pInstrument = pInstrument->GetNext())
	{
		m_pDLSComponent->m_pIFramework->RefreshNode(pInstrument);
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Collection.h ===
#ifndef __COLLECTION_H__
#define __COLLECTION_H__


// Collection.h : header file
//
/*
#define UPDATE_COLLECTION	1
#define UPDATE_INSTRUMENT	2
#define UPDATE_ARTICULATION	3
#define UPDATE_REGION		4
#define UPDATE_WAVE			5
#define UPDATE_ALL			6
*/
#include "DLSComponent.h"
#include "DLSDocType.h"
#include "RiffStrm.h"
#include "CollectionInstruments.h"
#include "CollectionWaves.h"
#include "Info.h"
#include "DLS1.h"
#include "alist.h"
#include "unknownchunk.h"

class CCollectionPropPgMgr;


struct BInstr  
{
	UINT      nStringId;
	BYTE      bPatch;
	BYTE      bMSB;
	BYTE      bLSB;
	CString  *pstrName;
};

class AllocatedPortBufferPair
{

public:
	// Constructor
	AllocatedPortBufferPair(IDirectMusicPortDownload* pDownloadPort, IDirectMusicDownload* pAllocatedBuffer)
	{
		ASSERT(pDownloadPort);
		ASSERT(pAllocatedBuffer);

		m_pDownloadPort = pDownloadPort;
		m_pAllocatedBuffer = pAllocatedBuffer;
        m_dwDMID = 0;
	}

	// Destructor
	~AllocatedPortBufferPair()
	{
		m_pDownloadPort = NULL;
		m_pAllocatedBuffer = NULL;
	}

    void SetDMID(DWORD dwID)
    {
        m_dwDMID = dwID;
    }

    DWORD GetDMID()
    {
        return m_dwDMID;
    }

	IDirectMusicPortDownload*	m_pDownloadPort;            // what port is this allocated for?
	IDirectMusicDownload*		m_pAllocatedBuffer;		    // Where is the allocated buffer?
    DWORD                       m_dwDMID;                   // What's the download ID for this port?
};


class CCollection : public AListItem, public IDMUSProdNode, public IPersistStream, 
					public IDMUSProdPropPageObject, public IDMUSProdNotifySink
{
friend class CCollectionPropPg;
friend class CCollectionInstruments;
friend class CCollectionWaves;
friend class CWave;
friend class CMonoWave;
friend class CInstrumentCtrl;
friend class CWaveCtrl;
friend class CInstrument;
friend class CInstrumentRegions;
friend class CArticulation;
friend class CRegion;
friend class CDLSComponent;
friend class CInstrumentFVEditor;
friend class CWavePropPg;
friend class CCollectionRef;
friend class CPatchConflictDlg;
friend class CUserPatchConflictDlg;
public:
    CCollection( CDLSComponent* pComponent );
	~CCollection();
    CCollection * GetNext() {return(CCollection *)AListItem::GetNext();};


    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnResourceId);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit(HMENU hMenu);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect(long lCommandId);

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode** ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo(DMUSProdListInfo* pListInfo);
	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );
    // IDMUSProdNode;drag & drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

	// IDMUSProdNotifySink method
	STDMETHOD(OnUpdate)(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData);
    
	// IPersist functions
    STDMETHOD(GetClassID)(CLSID* pClsId);

	// IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();
	HRESULT STDMETHODCALLTYPE OnShowProperties();

	//Additional functions
public:
	void SetDirtyFlag();

	DWORD   SampleCount();
	DWORD	RegionCount();
	DWORD	ArticulationCount();
	DWORD	WaveCount();
	DWORD	WaveNodeCount();
	DWORD	InstrumentCount();

	CCollectionInstruments* GetInstruments();
	HRESULT GetListOfConditions(CPtrList* pConditionList);
	void	OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode = true);

    HRESULT Load(IStream* pIStream, DWORD dwSize);
    HRESULT Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	HRESULT GetObjectDescriptor( void* pObjectDesc );

	void	SetNodeFileName(CString sFileName);
	CString	GetNodeFileName();
	HRESULT FindWaveNodeByGUID(GUID guidNode, CWaveNode** ppWaveNode);

	void	GetGUID( GUID* pguidCollection );
	void	SetGUID( GUID guidCollection );

	HRESULT SyncDMCollection();
	void	ReleaseDMCollection();

protected:
	void ClearDirtyFlag() {m_bIsDirty = false;}
    void ResolveConnections();
    void SetWaveIDs();
	void PrepareConnections();
	
private:
	HRESULT Download();	// Downloads collection to synth
	void Unload();		// Unloads a collection from the synth
	
	HRESULT Save(IDMUSProdRIFFStream* pIRiffStream, BOOL fFullSave);
	HRESULT Save( const char* strFileName);

	HRESULT CreateDMCollection();

public:
	
	DWORD m_fPatchResolution;
	void  ValidateInstrumentPatches();
	BOOL  VerifyDLS();
	bool  IsWaveReferenced(CWave* pWave, IDMUSProdNode** ppReferenceNode);

	CDLSComponent*				m_pComponent;

private:

	IDirectMusicCollection8*	m_pIDMCollection;

	CString						m_sFileName;

	CCollectionInstruments		m_Instruments;
	CCollectionWaves			m_Waves;
    CUnknownChunk				m_UnknownChunk;
    
	long						m_lRef;
	IDMUSProdNode*				m_pIRootNode;
	IDMUSProdNode*				m_pIParentNode;

	CString						m_sTempName;		// Temp name used while saving etc.

	//	Data for DLS file...
	CInfo						m_Info;
	DLSHEADER					m_rDLSHeader;
	DLSVERSION					m_rVersion;

	CCollectionPropPgMgr*		m_pCollectionPropPgMgr;
	BOOL						m_bIsDirty;
	GUID						m_Guid;

	static BOOL					m_bNoMIDIPort;
};	

#endif // __COLLECTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionPropPg.cpp ===
// CollectionPropPg.cpp : implementation file
//

#include "stdafx.h"
#include "Collection.h"
#include "CollectionPropPgMgr.h"
#include "CollectionPropPg.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPg property page

IMPLEMENT_DYNCREATE(CCollectionPropPg, CPropertyPage)

CCollectionPropPg::CCollectionPropPg() : CPropertyPage(CCollectionPropPg::IDD), m_pCollection(NULL)
{
	//{{AFX_DATA_INIT(CCollectionPropPg)
	m_csComment = _T("");
	m_csCopyright = _T("");
	m_csEngineer = _T("");
	m_csName = _T("");
	m_csSubject = _T("");
	m_dwVersion1 = 0;
	m_dwVersion2 = 0;
	m_dwVersion3 = 0;
	m_dwVersion4 = 0;
	//}}AFX_DATA_INIT

	m_fNeedToDetach = FALSE;
}

CCollectionPropPg::~CCollectionPropPg()
{
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPg::EnableControls

void CCollectionPropPg::EnableControls(BOOL fEnable) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CWnd * pCtrl = GetDlgItem(IDC_NAME);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_SUBJECT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_ENGINEER);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_COPYRIGHT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_VER_1);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_VER_2);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_VER_3);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_VER_4);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_COMMENT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}
}

void CCollectionPropPg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCollectionPropPg)
	DDX_Text(pDX, IDC_COMMENT, m_csComment);
	DDX_Text(pDX, IDC_COPYRIGHT, m_csCopyright);
	DDX_Text(pDX, IDC_ENGINEER, m_csEngineer);
	DDX_Text(pDX, IDC_NAME, m_csName);
	DDX_Text(pDX, IDC_SUBJECT, m_csSubject);
	DDX_Text(pDX, IDC_VER_1, m_dwVersion1);
	DDV_MinMaxDWord(pDX, m_dwVersion1, 0, 65535);
	DDX_Text(pDX, IDC_VER_2, m_dwVersion2);
	DDV_MinMaxDWord(pDX, m_dwVersion2, 0, 65535);
	DDX_Text(pDX, IDC_VER_3, m_dwVersion3);
	DDV_MinMaxDWord(pDX, m_dwVersion3, 0, 65535);
	DDX_Text(pDX, IDC_VER_4, m_dwVersion4);
	DDV_MinMaxDWord(pDX, m_dwVersion4, 0, 65535);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCollectionPropPg, CPropertyPage)
	//{{AFX_MSG_MAP(CCollectionPropPg)
	ON_EN_CHANGE(IDC_COMMENT, OnChangeComment)
	ON_EN_CHANGE(IDC_COPYRIGHT, OnChangeCopyright)
	ON_EN_CHANGE(IDC_ENGINEER, OnChangeEngineer)
	ON_EN_CHANGE(IDC_NAME, OnChangeName)
	ON_EN_CHANGE(IDC_SUBJECT, OnChangeSubject)
	ON_EN_CHANGE(IDC_VER_1, OnChangeVer1)
	ON_EN_CHANGE(IDC_VER_2, OnChangeVer2)
	ON_EN_CHANGE(IDC_VER_3, OnChangeVer3)
	ON_EN_CHANGE(IDC_VER_4, OnChangeVer4)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillfocusName)
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPg message handlers

BOOL CCollectionPropPg::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pCollection == NULL)
	{
		EnableControls(FALSE);
		CCollectionPropPgMgr::m_dwLastSelPage = COLLECTION_PROP_PAGE;
		return CPropertyPage::OnSetActive();
	}
	
	EnableControls(TRUE);
	
	m_csName = m_pCollection->m_Info.m_csName;
	m_csCopyright = m_pCollection->m_Info.m_csCopyright;
	m_csEngineer = m_pCollection->m_Info.m_csEngineer;
	m_csSubject = m_pCollection->m_Info.m_csSubject;
	m_csComment = m_pCollection->m_Info.m_csComment;
	m_dwVersion1 = HIWORD(m_pCollection->m_rVersion.dwVersionMS);
	m_dwVersion2 = LOWORD(m_pCollection->m_rVersion.dwVersionMS);
	m_dwVersion3 = HIWORD(m_pCollection->m_rVersion.dwVersionLS);
	m_dwVersion4 = LOWORD(m_pCollection->m_rVersion.dwVersionLS);
	
	CCollectionPropPgMgr::m_dwLastSelPage = COLLECTION_PROP_PAGE;
	return CPropertyPage::OnSetActive();
}

void CCollectionPropPg::OnChangeComment() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{	
		if(m_pCollection->m_Info.m_csComment != m_csComment)
		{
			m_pCollection->m_Info.m_csComment = m_csComment;
			m_pCollection->SetDirtyFlag();
		}
	}
}

void CCollectionPropPg::OnChangeCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pCollection->m_Info.m_csCopyright != m_csCopyright)
		{
			m_pCollection->m_Info.m_csCopyright = m_csCopyright;
			m_pCollection->SetDirtyFlag();
		}
	}
}

void CCollectionPropPg::OnChangeEngineer() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pCollection->m_Info.m_csEngineer != m_csEngineer)
		{
			m_pCollection->m_Info.m_csEngineer = m_csEngineer;
			m_pCollection->SetDirtyFlag();
		}
	}
}

void CCollectionPropPg::OnChangeName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pCollection->m_Info.m_csName != m_csName)
		{
			m_pCollection->m_Info.m_csName = m_csName;
			
			BSTR bstrName = m_pCollection->m_Info.m_csName.AllocSysString();
			m_pCollection->SetNodeName(bstrName);
			m_pCollection->m_pComponent->m_pIFramework->RefreshNode(m_pCollection);			
			
			m_pCollection->SetDirtyFlag();
		}
	}
}

void CCollectionPropPg::OnChangeSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pCollection->m_Info.m_csSubject != m_csSubject)
		{
			m_pCollection->m_Info.m_csSubject = m_csSubject;
			m_pCollection->SetDirtyFlag();
		}
	}
}

void CCollectionPropPg::OnChangeVer1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pCollection->m_rVersion.dwVersionMS != ((m_dwVersion1 << 16) | m_dwVersion2))
		{
			m_pCollection->m_rVersion.dwVersionMS = (m_dwVersion1 << 16) | m_dwVersion2;
			m_pCollection->SetDirtyFlag();
		}
	}
}

void CCollectionPropPg::OnChangeVer2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pCollection->m_rVersion.dwVersionMS != ((m_dwVersion1 << 16) | m_dwVersion2))
		{
			m_pCollection->m_rVersion.dwVersionMS = (m_dwVersion1 << 16) | m_dwVersion2;
			m_pCollection->SetDirtyFlag();
		}
	}
}

void CCollectionPropPg::OnChangeVer3() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pCollection->m_rVersion.dwVersionLS != ((m_dwVersion3 << 16) | m_dwVersion4))
		{
			m_pCollection->m_rVersion.dwVersionLS = (m_dwVersion3 << 16) | m_dwVersion4;
			m_pCollection->SetDirtyFlag();
		}
	}
}

void CCollectionPropPg::OnChangeVer4() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pCollection->m_rVersion.dwVersionLS != ((m_dwVersion3 << 16) | m_dwVersion4))
		{
			m_pCollection->m_rVersion.dwVersionLS = (m_dwVersion3 << 16) | m_dwVersion4;
			m_pCollection->SetDirtyFlag();
		}
	}
}

void CCollectionPropPg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd != NULL )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

int CCollectionPropPg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.

	if(!FromHandlePermanent(m_hWnd))
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );

		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

void CCollectionPropPg::OnKillfocusName() 
{
//	IDMUSProdPropSheet* pIPropSheet;
//	if(SUCCEEDED(m_pCollection->m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
//	{
		// Refresh title
//		pIPropSheet->RefreshTitleByObject(m_pCollection);
//		pIPropSheet->Release();
//	}
}

void CCollectionPropPg::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pCollection )
	{
		CGuidDlg dlg;
		memcpy( &dlg.m_guid, &m_pCollection->m_Guid, sizeof(GUID) );
		if( dlg.DoModal() == IDOK )
		{
			//m_pCollection->m_pUndoMgr->SaveState( m_pCollection, theApp.m_hInstance, IDS_UNDO_STYLE_GUID );
			memcpy( &m_pCollection->m_Guid, &dlg.m_guid, sizeof(GUID) );
			m_pCollection->SetDirtyFlag();

			// Notify connected nodes that DLS Collection GUID has changed
			m_pCollection->m_pComponent->m_pIFramework->NotifyNodes( m_pCollection, DOCROOT_GuidChange, NULL );
		}
	}
}

BOOL CCollectionPropPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	CWnd* pCtrl = GetDlgItem(IDC_COMMENT);
	if(pCtrl)
		((CEdit*)pCtrl)->SetLimitText(COMMENT_TEXT_LIMIT);

	
	return FALSE;  // return TRUE unless you set the focus to a control
				   // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionPropPg.h ===
#if !defined(AFX_COLLECTIONPROPPG_H__5342FA63_E1AB_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_COLLECTIONPROPPG_H__5342FA63_E1AB_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CollectionPropPg.h : header file
//

#include "resource.h"

const int COMMENT_TEXT_LIMIT = 1024;

class CCollection;

/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPg dialog
class CCollectionPropPg : public CPropertyPage
{
	friend class CInstrument;
	
	DECLARE_DYNCREATE(CCollectionPropPg)

// Construction
public:
	CCollectionPropPg();
	~CCollectionPropPg();
	
	void SetObject(CCollection* pCollection) {m_pCollection = pCollection;}

	void EnableControls(BOOL fEnable);

// Dialog Data
	//{{AFX_DATA(CCollectionPropPg)
	enum { IDD = IDD_COLLECTION_PROP_PAGE };
	CString	m_csComment;
	CString	m_csCopyright;
	CString	m_csEngineer;
	CString	m_csName;
	CString	m_csSubject;
	DWORD	m_dwVersion1;
	DWORD	m_dwVersion2;
	DWORD	m_dwVersion3;
	DWORD	m_dwVersion4;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCollectionPropPg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCollectionPropPg)
	afx_msg void OnChangeComment();
	afx_msg void OnChangeCopyright();
	afx_msg void OnChangeEngineer();
	afx_msg void OnChangeName();
	afx_msg void OnChangeSubject();
	afx_msg void OnChangeVer1();
	afx_msg void OnChangeVer2();
	afx_msg void OnChangeVer3();
	afx_msg void OnChangeVer4();
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnKillfocusName();
	afx_msg void OnEditGuid();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CCollection* m_pCollection;	
	BOOL m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COLLECTIONPROPPG_H__5342FA63_E1AB_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionInstruments.h ===
#ifndef __COLLECTIONINSTRUMENTS_H__
#define __COLLECTIONINSTRUMENTS_H__

// CollectionInstruments.h : header file
//

#include "alist.h"
#include "DllJazzDataObject.h"

class CCollection;
class CInstrument;

class CCollectionInstruments : public AList, public IDMUSProdNode
{
friend class CCollection;
friend class CDLSComponent;

public:
    CCollectionInstruments();
	~CCollectionInstruments();

	//	AList overrides
    CInstrument *GetHead();
    CInstrument *RemoveHead();
	void Remove(CInstrument *pInstrument);
	void AddTail(CInstrument *pInstrument);

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnResourceId);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit(HMENU hMenu);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect(long lCommandId);

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode** ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo(DMUSProdListInfo* pListInfo);

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

    // IDMUSProdNode: drag & drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

	//		Additional functions.

	HRESULT Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	HRESULT PasteCF_INSTRUMENT( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject);

	void	RefreshAllNodes();

private:
    DWORD				m_dwRef;
	IDMUSProdNode*		m_pIRootNode;
	IDMUSProdNode*		m_pIParentNode;

	CDLSComponent*	 m_pDLSComponent;
	CCollection*	 m_pCollection;
};

#endif // __COLLECTIONINSTRUMENTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionPropPgMgr.h ===
//////////////////////////////////////////////////////////////////////
//
// CollectionPropPgMgr.h
//
//////////////////////////////////////////////////////////////////////

#ifndef COLLECTIONPROPPGMGR_H
#define COLLECTIONPROPPGMGR_H

#include "DllBasePropPageManager.h"

#define COLLECTION_PROP_PAGE			0
#define COLLECTION_EXTRA_PAGE			1

class CCollectionPropPg;
class CCollectionExtraPropPg;

//////////////////////////////////////////////////////////////////////
//  CollectionPropPgMgr

class CCollectionPropPgMgr : public CDllBasePropPageManager 
{
	friend class CCollection;

public:
	CCollectionPropPgMgr();
	virtual ~CCollectionPropPgMgr();

    // IJazzPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();

public:
	
	// Keeps track of the last selected property sheet
	static DWORD m_dwLastSelPage;


	// Member variables
private:
	
	CCollectionPropPg*		m_pCollectionPage;
	CCollectionExtraPropPg*	m_pCollectionExtraPage;
};

#endif // #ifndef COLLECTIONPROPPGMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionWaves.cpp ===
// CollectionWaves.cpp : implementation file
//

#include "stdafx.h"
#include "cderr.h"
#include "DlsDefsPlus.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "Collection.h"
#include "Region.h"
#include "WaveNode.h"
#include "WaveDataManager.h"
#include "Wave.h"
#include "MonoWave.h"
#include "StereoWave.h"
#include "Instrument.h"
#include "resource.h"
#include "stream.h"
#include "InstrumentFVEditor.h"
#ifdef DMP_XBOX
#include "AdpcmLoopWarnDlg.h"
#endif // DMP_XBOX

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves constructor/destructor

CCollectionWaves::CCollectionWaves()
{
    m_dwRef = 1;
	m_pCollection = NULL;
	m_pDLSComponent = NULL;
	m_pIRootNode = NULL;
	m_pIParentNode = NULL;
}

CCollectionWaves::~CCollectionWaves()
{
	while (!IsEmpty())
	{
        CWaveNode* pWaveNode = RemoveHead();
        pWaveNode->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves AList overrides


CWaveNode* CCollectionWaves::GetHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return(CWaveNode*)AList::GetHead();
}

CWaveNode* CCollectionWaves::RemoveHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return(CWaveNode*) AList::RemoveHead();
}

void CCollectionWaves::Remove(CWaveNode* pINode) 
{ 
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AList::Remove((AListItem*) pINode);
}

void CCollectionWaves::AddTail(CWaveNode* pINode) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AList::AddTail((AListItem*) pINode);
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IUnknown implementation

HRESULT CCollectionWaves::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);    
	
	if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }
	else if(::IsEqualIID(riid, IID_IDMUSProdNodeDrop))
	{
		AddRef();
		*ppvObj = (IDMUSProdNodeDrop*)this;
		return S_OK;
	}

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CCollectionWaves::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CCollectionWaves::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    
	ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetNodeImageIndex

HRESULT CCollectionWaves::GetNodeImageIndex(short* pnFirstImage)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnFirstImage);
	
	ASSERT(m_pDLSComponent != NULL);

	return(m_pDLSComponent->GetFolderImageIndex(pnFirstImage));
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetComponent

HRESULT CCollectionWaves::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pDLSComponent != NULL );

	return m_pDLSComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetRootNode

HRESULT CCollectionWaves::GetDocRootNode( IDMUSProdNode** ppIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIRootNode )
	{
		m_pIRootNode->AddRef();
		*ppIRootNode = m_pIRootNode;
		return S_OK;
	}

	*ppIRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::SetRootNode

HRESULT CCollectionWaves::SetDocRootNode( IDMUSProdNode* pIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT( pIRootNode != NULL );

	m_pIRootNode = pIRootNode;
//	m_pIRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetParentNode

HRESULT CCollectionWaves::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::SetParentNode

HRESULT CCollectionWaves::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetNodeId

HRESULT CCollectionWaves::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_WaveFolderNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetNodeName

HRESULT CCollectionWaves::GetNodeName(BSTR* pbstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CString strName;
	TCHAR achBuffer[BUFFER_128];

	if(::LoadString(theApp.m_hInstance, IDS_WAVE_FOLDER_NAME, achBuffer, BUFFER_128))
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetNodeNameMaxLength

HRESULT CCollectionWaves::GetNodeNameMaxLength(short* pnMaxLength)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnMaxLength);

	*pnMaxLength = -1; // Can't rename a Waves folder

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::ValidateNodeName

HRESULT CCollectionWaves::ValidateNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Just free bstrName; can't rename Waves folder
	::SysFreeString(bstrName);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::SetNodeName

HRESULT CCollectionWaves::SetNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// Just free bstrName; can't rename a Waves folder
	::SysFreeString(bstrName);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetEditorClsId

HRESULT CCollectionWaves::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetEditorTitle

HRESULT CCollectionWaves::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetEditorWindow

HRESULT CCollectionWaves::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::SetEditorWindow

HRESULT CCollectionWaves::SetEditorWindow( HWND hWndEditor )
{
	return E_NOTIMPL;	// Can't edit a Pattern folder
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::UseOpenCloseImages

HRESULT CCollectionWaves::UseOpenCloseImages(BOOL* pfUseOpenCloseImages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pfUseOpenCloseImages);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetRightClickMenuId

HRESULT CCollectionWaves::GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMenuId);
	ASSERT(phInstance);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_WAVES_NODE_RMENU;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::OnRightClickMenuInit

HRESULT CCollectionWaves::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::OnRightClickMenuSelect

HRESULT CCollectionWaves::OnRightClickMenuSelect(long lCommandId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	switch(lCommandId)
	{
		case IDM_NEW_WAVE:
			hr = InsertChildNode(NULL);
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::DeleteChildNode

HRESULT CCollectionWaves::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIChildNode);
	if(pIChildNode == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pDLSComponent);
	if(m_pDLSComponent == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdFramework* pIFramework = m_pDLSComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return E_UNEXPECTED;
	}

	if(GetCount() == 1)
	{
		// Check if there's any instrument with just one region that's refering to this wave
		CInstrument* pInstrument = m_pCollection->m_Instruments.GetHead();
		while(pInstrument)
		{
			CInstrumentRegions* pInstRegions = pInstrument->GetRegions();
			if(pInstRegions->GetCount() == 1)
			{
				return E_FAIL;
			}
			
			pInstrument = pInstrument->GetNext();
		}
	}

	// Remove node from Project Tree
	if( m_pDLSComponent->m_pIFramework->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Set flag so we know to save file 
	m_pCollection->SetDirtyFlag();

	CWaveNode* pWaveNode = dynamic_cast<CWaveNode*>(pIChildNode);
	ASSERT(pWaveNode);

	
	// Release the dummy instrument
	CWave* pWave = pWaveNode->GetWave();
	ASSERT(pWave);
	if(pWave)
	{
		pWave->ReleaseDummyInstruments();
	}

	// Go through all the instruments and release the wavenode that may be referenced...
	CInstrument* pInstrument = m_pCollection->m_Instruments.GetHead();
	while(pInstrument) 
    {
		CInstrumentRegions* pInstRegions = pInstrument->GetRegions();
		ASSERT(pInstRegions);
		CRegion* pRegion = pInstRegions->GetHead();
		while(pRegion)
		{
			if(pRegion->GetWaveNode() == pWaveNode)
			{
				CWaveNode* pNewNode = pWaveNode->GetNext();
				if(pNewNode == NULL)
				{
					pNewNode = (CWaveNode*)pWaveNode->GetPrev(NULL);
				}

				ASSERT(pNewNode);
				pRegion->SetWave(pNewNode->GetWave());

				pIFramework->RefreshNode(pRegion);
			}

			pRegion = pRegion->GetNext();
		}

		pInstrument = pInstrument->GetNext();
	}

	// Remove from list
	Remove(pWaveNode);
	pIChildNode->Release();

	NotifyInstrumentsWavesChanged();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::InsertChildNode

HRESULT CCollectionWaves::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pDLSComponent != NULL );
	ASSERT( m_pDLSComponent->m_pIFramework != NULL );
	ASSERT( m_pCollection != NULL );

	if( pIChildNode == NULL )
	{
        // Put up a file open dilaog.
        CHAR szFilter[39] = "Wave Files (*.wav;*.wvp)|*.wav;*.wvp||";
		CFileDialog FileDlg(TRUE, "WAV", NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, szFilter, NULL);
		
		CString sFileNames;
		FileDlg.m_ofn.lpstrFile = sFileNames.GetBuffer(2048);
		FileDlg.m_ofn.nMaxFile = 2048; // Max filename buffer size for NT 4.0

		CString sDialogTitle;
		sDialogTitle.LoadString(IDS_INSERT_COLLECTION_WAVE_TITLE);
		FileDlg.m_ofn.lpstrTitle = sDialogTitle;

        if(FileDlg.DoModal() == IDOK)
        {
            // Openfilename succeeded.
			POSITION position = FileDlg.GetStartPosition();

			while(position)
			{
				CString sFileName = FileDlg.GetNextPathName(position);
				if(FAILED(InsertWaveFile(sFileName)))
				{
					CString sErrorMessage;
					sErrorMessage.Format( IDS_ERR_FAILED_WAVE_INSERT, sFileName);
					AfxMessageBox(sErrorMessage);
				}
			}
        }
        else
		{
			if(CommDlgExtendedError() == FNERR_BUFFERTOOSMALL)
				AfxMessageBox(IDS_ERR_TOOMANY_WAVE_FILES);

			return S_OK;
		}
    }
	else
	{
		pIChildNode->AddRef();
		if(AddToCollection(pIChildNode))
		{
			return S_OK;
		}
	}
	
	return E_FAIL;

}


HRESULT CCollectionWaves::InsertWaveFile(CString sFileName, CWaveNode** ppInsertedWave)
{
	IStream* pStream = NULL;
	HRESULT hr = S_OK;

    ASSERT(m_pDLSComponent);
    if(m_pDLSComponent == NULL)
    {
        return E_UNEXPECTED;
    }

    IDMUSProdConductor* pIConductor = m_pDLSComponent->m_pIConductor;
    if(pIConductor == NULL)
    {
        return E_UNEXPECTED;
    }

	// turn on wait cursor
	CWaitCursor waitCursor;
	
	// Create a stream from this filename.
	if(SUCCEEDED(AllocStreamFromFile(&pStream, sFileName.GetBuffer(0), 0)))
	{
		CWaveNode* pIChildNode = NULL;
		if(SUCCEEDED(hr = CWaveNode::CreateWaveNode(m_pDLSComponent, pStream, sFileName, &pIChildNode, this, true)))
		{
			CWave* pWave = pIChildNode->GetWave();
			ASSERT(pWave);

            pIChildNode->SetSourceInTempFile(TRUE);

			CString sWaveName = pWave->GetName();

			if (sWaveName.IsEmpty())
			{
				int nDirectoryPathLength = sFileName.ReverseFind(TCHAR('\\')) + 1;
				int nExtractionLength = sFileName.GetLength() - nDirectoryPathLength;
				
				// Take out the Directory Path									
				CString sName = sFileName.Right(nExtractionLength);

				// Take out the .ext appendage
				sName = sName.Left(nExtractionLength - 4);
				pWave->SetName(sName);
			}

			pWave->SetCollection(m_pCollection);

			if(FAILED(pIChildNode->InitAndDownload()))
			{
				pIChildNode->Release();
				if(pStream)
				{
					pStream->Release();
				}

				return E_FAIL;
			}

			if(!AddToCollection(pIChildNode))
			{
				if(pStream)
				{
					pStream->Release();
				}

				return E_FAIL;
			}

			// Register it with the transport
			pIChildNode->RegisterWithTransport();
            pIConductor->SetActiveTransport(pIChildNode, BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE);

            if(ppInsertedWave != NULL)
			{
				*ppInsertedWave = (CWaveNode*)pIChildNode;
			}
		}
		
		if(pStream)
		{
			pStream->Release();
		}
	}
	else
		hr = E_FAIL;

	return hr;
}



BOOL CCollectionWaves::AddToCollection(IDMUSProdNode* pIChildNode)
{
	 // Add to the collection
	CWave* pWave = ((CWaveNode*)pIChildNode)->GetWave(); 
	ASSERT(pWave);
	if(pWave == NULL)
		return FALSE;

	/*
#ifdef DMP_XBOX
	if( pWave->IsLooped()
	&&	pWave->m_bCompressed
	&&	pWave->GetCompressionFormatTag() == XBOXADPCM_FORMAT_TAG )
	{
		WLOOP waveLoop = pWave->GetWLOOP();
		if( (waveLoop.ulStart % 64) != 0
		||	(waveLoop.ulLength % 64) != 0 )
		{
			if( !m_pDLSComponent->IsNoShowBadXboxLoopWarning() )
			{
				CAdpcmLoopWarnDlg* pAdpcmLoopWarnDlg = new CAdpcmLoopWarnDlg(m_pDLSComponent, pWave->m_rWaveformat.nSamplesPerSec, waveLoop.ulStart, waveLoop.ulLength, 0);
				int nRes = pAdpcmLoopWarnDlg->DoModal();
				delete pAdpcmLoopWarnDlg;
				if( IDOK == nRes )
				{
					// Modify the loop points
					waveLoop.ulStart = 64 * ((waveLoop.ulStart + 32) / 64);
					waveLoop.ulLength = 64 * ((waveLoop.ulLength + 32) / 64);
					pWave->SetLoop( waveLoop.ulStart, waveLoop.ulStart + waveLoop.ulLength );
				}
			}
		}
	}
#endif // DMP_XBOX
	*/


	pWave->SetCollection(m_pCollection);

	// add to CollectionWaves list
	AddTail((CWaveNode*)pIChildNode);

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pIChildNode, (IDMUSProdNode *)m_pCollection, (IDMUSProdNode*)this );

	// Add node to Project Tree
	if( !SUCCEEDED ( m_pDLSComponent->m_pIFramework->AddNode(pIChildNode, (IDMUSProdNode*)this) ) )
	{
		DeleteChildNode( pIChildNode, FALSE );
		return FALSE;
	}

	// Set flag so we know to save file 
	m_pCollection->SetDirtyFlag();

	// Set the IDs for the newly added wave
	m_pCollection->SetWaveIDs();

	// Tell the instruments that the waves have changed
	NotifyInstrumentsWavesChanged();

	return TRUE;
}



////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::DeleteNode

HRESULT CCollectionWaves::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIParentNode;

	if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			pIParentNode->Release();
			return hr;		
		}
	}

	return E_FAIL;
}


//////////////////////////////////////////////////////////////////////
//
//	CCollectionWaves IDMUSProdNode::GetFirstChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::GetFirstChild(IDMUSProdNode** ppIFirstChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppIFirstChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppIFirstChildNode = NULL;

	IDMUSProdNode* pINode = (IDMUSProdNode*) GetHead();

	if(pINode)
	{
		pINode->AddRef();
		*ppIFirstChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CCollectionWaves IDMUSProdNode::GetNextChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppINextChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppINextChildNode = NULL;

	if(pIChildNode == NULL)
	{
		return E_INVALIDARG;
	}

	IDMUSProdNode* pINode = (IDMUSProdNode*) ((CWaveNode*) pIChildNode)->GetNext();

	if(pINode)
	{
		pINode->AddRef();
		*ppINextChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CCollectionWaves IDMUSProdNode::GetNodeListInfo
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::GetNodeListInfo(DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pListInfo);
	
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::OnNodeSelChanged

HRESULT CCollectionWaves::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves IDMUSProdNode::CreateDataObject
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves IDMUSProdNode::CanCut
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::CanCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves IDMUSProdNode::CanCopy
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::CanCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves IDMUSProdNode::CanDelete
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::CanDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves IDMUSProdNode::CanDeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;   // no children pass up this message but we say ok anyway

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves IDMUSProdNode::CanPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;

	if(SUCCEEDED(pDataObject->IsClipFormatAvailable( pIDataObject, m_pDLSComponent->m_cfInstrument)))
        hr = S_OK;

	if(SUCCEEDED(pDataObject->IsClipFormatAvailable( pIDataObject, m_pDLSComponent->m_cfWave)))
        hr = S_OK;

	pDataObject->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves IDMUSProdNode::PasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_pDLSComponent->m_cfInstrument ) ) )
	{
		// Handle CF_INSTRUMENT format
		if(m_pCollection)
			hr = m_pCollection->m_Instruments.PasteCF_INSTRUMENT( pDataObject, pIDataObject);
		pDataObject->Release();
		return hr;
	}

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_pDLSComponent->m_cfWave ) ) )
	{
		// Handle CF_WAVE format
		hr = PasteCF_WAVE( pDataObject, pIDataObject);
		pDataObject->Release();
		return hr;
	}

	pDataObject->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves IDMUSProdNode::CanChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												 BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;   //children (waves) handle this themselves

}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves IDMUSProdNode::ChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return PasteFromData(pIDataObject);

}

/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves IDMUSProdNode::GetObject

HRESULT CCollectionWaves::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
//
// Implementation of IDMUSProdNodeDrop methods
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::OnDropFiles(HANDLE handleDropInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HDROP hDropInfo = (HDROP)handleDropInfo;

	UINT nFiles = ::DragQueryFile(hDropInfo, (UINT)-1, NULL, 0);

	CWinApp* pApp = AfxGetApp();
	ASSERT(pApp != NULL);
	for (UINT iFile = 0; iFile < nFiles; iFile++)
	{
		TCHAR szFileName[_MAX_PATH];
		::DragQueryFile(hDropInfo, iFile, szFileName, _MAX_PATH);
		if(FAILED(InsertWaveFile(szFileName)))
		{
			CString sErrorMessage;
			sErrorMessage.Format(IDS_ERR_FAILED_WAVE_INSERT, szFileName);
			AfxMessageBox(sErrorMessage);
		}
	}
	::DragFinish(hDropInfo);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CCollectionWaves PasteCF_WAVE
//
//////////////////////////////////////////////////////////////////////
HRESULT CCollectionWaves::PasteCF_WAVE( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject)
{
	IStream* pStream;
	HRESULT hr = E_FAIL;

    if (SUCCEEDED(pDataObject->AttemptRead(pIDataObject,  m_pDLSComponent->m_cfWave, &pStream )))
    {
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		IDMUSProdRIFFStream* pIRiffStream = NULL;
		if(FAILED(AllocRIFFStream(pStream, &pIRiffStream)))
		{
			return E_FAIL;
		}
		
		hr = PasteWaves(pIRiffStream);

		pIRiffStream->Release();
		pStream->Release();
    }
	return hr;
}
/////////////////////////////////////////////////////////////////////////////
// CCollectionWaves::Load

HRESULT CCollectionWaves::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	IStream*		pIStream;
	MMCKINFO		ck;
    HRESULT			hr = S_OK;

	ASSERT( m_pDLSComponent != NULL );
	
    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	ck.ckid = 0;
	ck.fccType = 0;
    int count = 0;
	while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0)
	{
		switch (ck.ckid) {
		case FOURCC_LIST :
			switch (ck.fccType)
			{
				case mmioFOURCC('W','A','V','E') :
			    case mmioFOURCC('w','a','v','e') :
				{
					CWaveNode* pWaveNode = NULL;
					if(SUCCEEDED(CWaveNode::CreateWaveNode(m_pDLSComponent, this, pIRiffStream, &ck, &pWaveNode)))
					{
						if(IsNodeInCollection(pWaveNode) == FALSE)
						{
							AddTail(pWaveNode);
							pWaveNode->SetCollection(m_pCollection);
							
						}
					}
					else
					{
						pIStream->Release();
						return E_FAIL;
					}
					break;
				}
			}
		}

		theApp.m_dwProgressBarRemainingBytes -= ck.cksize;
		m_pDLSComponent->m_pIFramework->SetProgressBarPos( theApp.m_hKeyProgressBar,
					(theApp.m_dwProgressBarTotalBytes - theApp.m_dwProgressBarRemainingBytes) / theApp.m_dwProgressBarIncrement );

		pIRiffStream->Ascend( &ck, 0 );
		ck.ckid = 0;
		ck.fccType = 0;
	}
	pIStream->Release();
	return hr;
}

HRESULT CCollectionWaves::PasteWaves(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	MMCKINFO ckMain;
	ckMain.ckid = FOURCC_DRAG;
	ckMain.fccType = 0;
	while(pIRiffStream->Descend(&ckMain, NULL, MMIO_FINDCHUNK) == 0 )
	{
		CWaveNode* pWaveNode = NULL;
		
		char szTempPath[MAX_PATH];
		GetTempPath(MAX_PATH, szTempPath);
		char szTempFileName[MAX_PATH];

		CString sTempFileName = "";
		CString sPrefix = "DMP";
		CString sExt = "tmp";
		if(FAILED(CWaveDataManager::CreateUniqueTempFile(sPrefix, sExt, sTempFileName)))
		{
			GetTempFileName(szTempPath, sPrefix, 0, szTempFileName);
			sTempFileName = szTempFileName;
		}

		// Delete the temp file
		DeleteFile(szTempFileName);

		DWORD dwPosition = StreamTell(pIStream);
		StreamSeek(pIStream, (dwPosition - 8), STREAM_SEEK_SET);

		// Ascend happens in the called method
		if(FAILED(CWaveNode::CreateWaveNode(m_pDLSComponent, pIStream, sTempFileName, &pWaveNode, this, true)))
		{
			pIStream->Release();
			return E_FAIL;
		}

		// NOTENOTE!! Ascends take care of the stream pointer....so we don't need this anymore
		// Take it out when fully tested....
		/*StreamSeek(pIStream, dwPosition, STREAM_SEEK_SET);*/

		// Add to the collection
		pWaveNode->SetCollection(m_pCollection);

		if(FAILED(pWaveNode->InitAndDownload()))
		{
			pIStream->Release();
			pWaveNode->Release();
			return E_FAIL;
		}

		// Add to Wave list
		AddTail(pWaveNode);

		// Set root and parent node of ALL children
		theApp.SetNodePointers( pWaveNode, (IDMUSProdNode *)m_pCollection, (IDMUSProdNode *)this);

		// Add node to Project Tree
		if(FAILED(m_pDLSComponent->m_pIFramework->AddNode(pWaveNode, (IDMUSProdNode*)this)))
		{	
			pIStream->Release();
			DeleteChildNode( pWaveNode, FALSE );
			return E_FAIL;
		}

		// Register it with the transport
		pWaveNode->RegisterWithTransport();
	}

	// Set flag so we know to save file 
	m_pCollection->SetDirtyFlag();

	// set the wave IDs
	m_pCollection->SetWaveIDs();

	// Tell the instruments to update their editors
	NotifyInstrumentsWavesChanged();

	pIStream->Release();

	return S_OK;

}

void CCollectionWaves::NotifyInstrumentsWavesChanged()
{
	CInstrument * pInstrument = m_pCollection->m_Instruments.GetHead();
	while (pInstrument) // for all instruments go thru all regions
    {
        CInstrumentFVEditor* pInstrumentEditor = pInstrument->GetInstrumentEditor();
        if(pInstrumentEditor)
        {
			pInstrumentEditor->DeleteAndSetupWavesForCurrentRegion();
        }

		pInstrument = pInstrument->GetNext();
    }
}

void CCollectionWaves::ReplaceWave(CWaveNode* pWaveNode, CString sWaveFileName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pWaveNode);
	ASSERT(!sWaveFileName.IsEmpty());
	if(pWaveNode== NULL || sWaveFileName.IsEmpty())
    {
		return;
    }

    ASSERT(m_pDLSComponent);
    if(m_pDLSComponent == NULL)
    {
        return;
    }

    IDMUSProdFramework* pIFramework = m_pDLSComponent->m_pIFramework;
    ASSERT(pIFramework);
    if(pIFramework == NULL)
    {
        return;
    }

	// Are you sure you want to replace this file?
	if(AfxMessageBox(IDS_CONFIRM_REPLACE_WAVE, MB_YESNO) == IDNO)
		return;
	
	CWaveNode* pNewWaveNode = NULL;
	if(FAILED(InsertWaveFile(sWaveFileName, &pNewWaveNode)) || pNewWaveNode == NULL)
		return;

	CWave* pOldWave = pWaveNode->GetWave();
	ASSERT(pOldWave);

	CWave* pNewWave = pNewWaveNode->GetWave();
	ASSERT(pNewWave);

	CMonoWave* pLeftChannelWave;
	CMonoWave* pRightChannelWave;
	
	CMonoWave* pOldLeftChannelWave;
	CMonoWave* pOldRightChannelWave;

	bool bOldStereo = pOldWave->IsStereo();
	if (bOldStereo)
	{
		pOldLeftChannelWave = ((CStereoWave*)pOldWave)->GetLeftChannel();
		pOldRightChannelWave = ((CStereoWave*)pOldWave)->GetRightChannel();
	}
#ifdef _DEBUG
	else
		pOldLeftChannelWave = pOldRightChannelWave = (CMonoWave *)0xDEAD;
#endif

	bool bStereo = pNewWave->IsStereo();
	if (bStereo)
	{
		pLeftChannelWave = ((CStereoWave*)pNewWave)->GetLeftChannel();
		pRightChannelWave = ((CStereoWave*)pNewWave)->GetRightChannel();
	}
#ifdef _DEBUG
	else
		pLeftChannelWave = pRightChannelWave = (CMonoWave *)0xDEAD;
#endif

	// Update all regions that reference this wave
	CInstrument* pInstrument = m_pCollection->m_Instruments.GetHead();
	while (pInstrument) // for all instruments go thru all regions
    {
        CRegion* pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
			// figure out what wave to replace with, if any
			CWave *pReplaceWave = NULL;
			if (pRegion->m_pWave == pOldWave)
				pReplaceWave = pNewWave; // replace with new, irrespective of number of channels in new wave
			else if (bOldStereo)
				{
				// if left channel, replace with new mono, or left channel if stereo
				if (pRegion->m_pWave == pOldLeftChannelWave)
					pReplaceWave = bStereo ? pLeftChannelWave : pNewWave;

				// if right channel, replace with new mono, or right channel if stereo
				if (pRegion->m_pWave == pOldRightChannelWave)
					pReplaceWave = bStereo ? pRightChannelWave : pNewWave;
				}

            if (pReplaceWave != NULL)
				{
				pRegion->SetWave(pReplaceWave);
                pRegion->GetName();
                pIFramework->RefreshNode(pRegion);
				pInstrument->RefreshUI(true);
				}
			
			pRegion = pRegion->GetNext();
        }
		
		pInstrument = pInstrument->GetNext();
    }
    
    // Unregister the wave from the transport
    pWaveNode->UnRegisterFromTransport();

	// Now delete the original wave
	DeleteChildNode((IDMUSProdNode*)pWaveNode, FALSE);

	// Mark the collection as dirty so we get the save prompt
	m_pCollection->SetDirtyFlag();
}

HRESULT CCollectionWaves::GetListOfMonoWaves(CPtrList* pWaveList)
{
	ASSERT(pWaveList);
	if(pWaveList == NULL)
		return E_POINTER;

	CWaveNode* pWaveNode = GetHead();
	while(pWaveNode)
	{
		CWave* pWave = pWaveNode->GetWave();
		ASSERT(pWave);
		if(pWave->IsStereo())
		{
			CStereoWave* pStereoWave = (CStereoWave*)pWave;
			pWaveList->AddTail(pStereoWave->GetLeftChannel());
			pWaveList->AddTail(pStereoWave->GetRightChannel());
		}
		else
		{
			pWaveList->AddTail((CMonoWave*)pWave);
		}

		pWaveNode = pWaveNode->GetNext();
	}

	return S_OK;
}

HRESULT CCollectionWaves::GetListOfWaves(CPtrList* pWaveList)
{
	ASSERT(pWaveList);
	if(pWaveList == NULL)
		return E_POINTER;

	CWaveNode* pWaveNode = GetHead();
	while(pWaveNode)
	{
		CWave* pWave = pWaveNode->GetWave();
		ASSERT(pWave);
		if(pWave)
		{
			pWaveList->AddTail((CWave*)pWave);
		}

		pWaveNode = pWaveNode->GetNext();
	}

	return S_OK;
}

/* Returns wave pointed to by first node, NULL if none */
CWave*	CCollectionWaves::GetFirstWave()
{
	CWaveNode* pWaveNode = GetHead();
	if (!pWaveNode)
		return NULL;

	CWave* pWave = pWaveNode->GetWave();
	ASSERT(pWave);
	return pWave;
}

BOOL CCollectionWaves::IsNodeInCollection(CWaveNode* pWaveNode)
{
	CWaveNode* pNode = GetHead();
	
	while(pNode)
	{

		if(pWaveNode == pNode)
			return TRUE;
		
		pNode = pNode->GetNext();
	}

	return FALSE;
}

CCollection* CCollectionWaves::GetCollection()
{
	return m_pCollection;
}

void CCollectionWaves::ReleaseWaveNodeDummyInstruments()
{
	CWaveNode* pWaveNode = GetHead();
	while(pWaveNode)
	{
		CWave* pWave = pWaveNode->GetWave();
		ASSERT(pWave);
		if(pWave)
		{
			pWave->ReleaseDummyInstruments();
		}

		pWaveNode = pWaveNode->GetNext();
	}
}

void CCollectionWaves::UnRegisterWavesFromTransport()
{
	ASSERT(m_pDLSComponent);
	if(m_pDLSComponent == NULL)
	{
		return;
	}

	IDMUSProdConductor* pIConductor = m_pDLSComponent->m_pIConductor;
	ASSERT(pIConductor);
	if(pIConductor == NULL)
	{
		return;
	}

	CWaveNode* pWaveNode = GetHead();
	while(pWaveNode)
	{
		pWaveNode->UnRegisterFromTransport();
		pWaveNode = pWaveNode->GetNext();
	}
}

void CCollectionWaves::RegisterWavesWithTransport()
{
	ASSERT(m_pDLSComponent);
	if(m_pDLSComponent == NULL)
	{
		return;
	}

	IDMUSProdConductor* pIConductor = m_pDLSComponent->m_pIConductor;
	ASSERT(pIConductor);
	if(pIConductor == NULL)
	{
		return;
	}

	CWaveNode* pWaveNode = GetHead();
	while(pWaveNode)
	{
		pWaveNode->RegisterWithTransport();
		pWaveNode = pWaveNode->GetNext();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionPropPgMgr.cpp ===
//////////////////////////////////////////////////////////////////////
//
// CollectionPropPgMgr.cpp : implementation file
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CollectionPropPgMgr.h"
#include "CollectionPropPg.h"
#include "CollectionExtraPropPg.h"
#include "Collection.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


DWORD CCollectionPropPgMgr::m_dwLastSelPage = 0;

//////////////////////////////////////////////////////////////////////
// CCollectionPropPgMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCollectionPropPgMgr::CCollectionPropPgMgr() : m_pCollectionPage(NULL), m_pCollectionExtraPage(NULL)
{
}

CCollectionPropPgMgr::~CCollectionPropPgMgr()
{
	if(m_pCollectionPage)
		delete m_pCollectionPage;

	if(m_pCollectionExtraPage)
		delete m_pCollectionExtraPage;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPgMgr IJazzPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPgMgr IJazzPropPageManager::GetPropertySheetTitle

HRESULT CCollectionPropPgMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pbstrTitle);
	ASSERT(pfAddPropertiesText);

	*pfAddPropertiesText = TRUE;

	CCollection* pCollection;

	if(m_pIPropPageObject && (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pCollection))))
	{
		BSTR bstrCollectionName;
		pCollection->GetNodeName(&bstrCollectionName);
		CString sCollectionName = bstrCollectionName;
		SysFreeString(bstrCollectionName);

		CString sTitle;
		sTitle.LoadString(IDS_COLLECTION_TEXT);
		sTitle = sCollectionName + " " + sTitle;
		*pbstrTitle = sTitle.AllocSysString();
	}
	else
	{
		CString strTitle;
		strTitle.LoadString(IDS_COLLECTION_TEXT);
		*pbstrTitle = strTitle.AllocSysString();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPgMgr IJazzPropPageManager::GetPropertySheetPages

HRESULT CCollectionPropPgMgr::GetPropertySheetPages(IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add General tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(m_pCollectionPage == NULL)
		m_pCollectionPage = new CCollectionPropPg();

	if(m_pCollectionPage)
	{
		hPage = ::CreatePropertySheetPage((LPPROPSHEETPAGE)&m_pCollectionPage->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	if(m_pCollectionExtraPage == NULL)
		m_pCollectionExtraPage = new CCollectionExtraPropPg();

	if(m_pCollectionExtraPage)
	{
		hPage = ::CreatePropertySheetPage((LPPROPSHEETPAGE)&m_pCollectionExtraPage->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages; 

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPgMgr IJazzPropPageManager::RefreshData

HRESULT CCollectionPropPgMgr::RefreshData(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCollection* pCollection = NULL;
	
	if(m_pIPropPageObject == NULL)
	{
		pCollection = NULL;
	}
	else if(FAILED(m_pIPropPageObject->GetData((void **)&pCollection)))
	{
		return E_FAIL;
	}

	m_pCollectionPage->SetObject(pCollection);
	m_pCollectionExtraPage->SetObject(pCollection);

	if(m_pIPropSheet)
		m_pIPropSheet->RefreshTitle();

	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionRef.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//	CollectionRef.cpp
//	DLS Collection Reference node implementation
//	Created 3/17/98 Eric Whitcombe
//
///////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "CollectionRef.h"
#include "Instrument.h"
#include "Region.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef constructor/destructor

CCollectionRef::CCollectionRef(CDLSComponent* pComponent)
{
    m_dwRef = 0;
	AddRef();

	m_pComponent = pComponent;
	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pCollection = NULL;
}

CCollectionRef::~CCollectionRef()
{
	RELEASE( m_pCollection );
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IUnknown implementation

HRESULT CCollectionRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }
    if( ::IsEqualIID(riid, IID_IDLSQueryInstruments) )
    {
        AddRef();
        *ppvObj = (IDLSQueryInstruments *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CCollectionRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CCollectionRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetNodeImageIndex

HRESULT CCollectionRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent);

	return( m_pComponent->GetCollectionRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetFirstChild

HRESULT CCollectionRef::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;	// CollectionRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetNextChild

HRESULT CCollectionRef::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;	// CollectionRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetComponent

HRESULT CCollectionRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent );//IsBadReadPtr?

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetDocRootNode

HRESULT CCollectionRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::SetDocRootNode

HRESULT CCollectionRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetParentNode

HRESULT CCollectionRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::SetParentNode

HRESULT CCollectionRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetNodeId

HRESULT CCollectionRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_CollectionRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetNodeName

HRESULT CCollectionRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pCollection == NULL )
	{
		TCHAR achNoStyle[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_COLLECTION, achNoStyle, MID_BUFFER );
		CString strNoStyle = achNoStyle;
		*pbstrName = strNoStyle.AllocSysString();
		return S_OK;
	}

    return m_pCollection->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CCollectionRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a CollectionRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::ValidateNodeName

HRESULT CCollectionRef::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a CollectionRef node
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::SetNodeName

HRESULT CCollectionRef::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a CollectionRef node
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetNodeListInfo

HRESULT CCollectionRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pCollection == NULL )
	{
		return E_FAIL;
	}

    return m_pCollection->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetEditorClsId

HRESULT CCollectionRef::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetEditorTitle

HRESULT CCollectionRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetEditorWindow

HRESULT CCollectionRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::SetEditorWindow

HRESULT CCollectionRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::UseOpenCloseImages

HRESULT CCollectionRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetRightClickMenuId

HRESULT CCollectionRef::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
	//I'm not sure what behavior we want a collection reference node to have
	/*
	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_CollectionRef_NODE_RMENU;

	return S_OK;
	*/
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CCollectionRef::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CCollectionRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pCollection )
			{
				return m_pCollection->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::DeleteChildNode

HRESULT CCollectionRef::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// CollectionRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::InsertChildNode

HRESULT CCollectionRef::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// CollectionRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::DeleteNode

HRESULT CCollectionRef::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_FAIL;		// Cannot delete CollectionRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::OnNodeSelChanged

HRESULT CCollectionRef::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::CreateDataObject

HRESULT CCollectionRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pCollection )
	{
		// Let Collection create data object
		return m_pCollection->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::CanCut

HRESULT CCollectionRef::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::CanCopy

HRESULT CCollectionRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pCollection )
	{
		return S_OK;	// Will copy the Collection
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::CanDelete

HRESULT CCollectionRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::CanDeleteChildNode

HRESULT CCollectionRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;	// Style Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::CanPasteFromData

HRESULT CCollectionRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Style
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfWave );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Style
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pCollection )
	{
		// Let Style decide what can be dropped
		return m_pCollection->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::PasteFromData

HRESULT CCollectionRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Style
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfWave );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of Style
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pCollection )
	{
		// Let Style handle paste
		return m_pCollection->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::CanChildPasteFromData

HRESULT CCollectionRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;			// Style Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::ChildPasteFromData

HRESULT CCollectionRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;			// Style Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdNode::GetObject

HRESULT CCollectionRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CCollectionRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CCollectionRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pCollection )
	{
		m_pCollection->AddRef();
		*ppIDocRootNode = m_pCollection;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CCollectionRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a Collection Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_CollectionNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pCollection );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pCollection = (CCollection *)pIDocRootNode;
		m_pCollection->AddRef();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDLSQueryInstruments interface routines.


HRESULT CCollectionRef::ResetInstrumentList()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_dwInstrumentIndex = 0;
	return S_OK;
}

BOOL CCollectionRef::GetNextInstrument(BYTE *pbMSB, 
									  BYTE *pbLSB, 
									  BYTE *pbPC,
									  BOOL *pfDrums, 
									  signed char *pszName, 
									  DWORD dwMaxLen )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CInstrument *pInstrument = (CInstrument *) m_pCollection->m_Instruments.GetItem(m_dwInstrumentIndex);
	if (pInstrument != NULL)
	{
		m_dwInstrumentIndex++;
		*pbMSB = (BYTE) ((pInstrument->m_rInstHeader.Locale.ulBank >> 8) & 0x7F);
		*pbLSB = (BYTE) (pInstrument->m_rInstHeader.Locale.ulBank & 0x7F);
		*pfDrums = ((pInstrument->m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS) != 0);
		*pbPC = (BYTE) pInstrument->m_rInstHeader.Locale.ulInstrument;
		strncpy((char *) pszName,pInstrument->m_Info.m_csName,dwMaxLen );
		return TRUE;
	}
	return FALSE;
}

BOOL CCollectionRef::GetInstrumentName(  BYTE bMSB, 
									  BYTE bLSB, 
									  BYTE bPC, 
									  BOOL fDrums, 
									  signed char *pszName, 
									  DWORD dwMaxLen )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BYTE bIMSB, bILSB, bIPC;
	BOOL fIDrums;

	CInstrument *pInstrument = m_pCollection->m_Instruments.GetHead();
	for (;pInstrument;pInstrument = pInstrument->GetNext())
	{
		bIMSB = (BYTE) ((pInstrument->m_rInstHeader.Locale.ulBank >> 8) & 0x7F);
		bILSB = (BYTE) (pInstrument->m_rInstHeader.Locale.ulBank & 0x7F);
		fIDrums = ((pInstrument->m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS) != 0);
		bIPC = (BYTE) pInstrument->m_rInstHeader.Locale.ulInstrument;
		if ((bMSB == bIMSB) && (bLSB == bILSB) && (bPC == bIPC) && (fDrums == fIDrums))
		{
			strncpy((char *)pszName,pInstrument->m_Info.m_csName,dwMaxLen );
			return TRUE;
		}
	}
	return FALSE;
}

HRESULT	CCollectionRef::GetObjectDescriptor(DWORD dwDescSize,
											void *pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( dwDescSize < sizeof(DMUS_OBJECTDESC) )
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	memset( pDMObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	pDMObjectDesc->dwSize = sizeof(DMUS_OBJECTDESC);
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	memcpy( &pDMObjectDesc->guidObject, &m_pCollection->m_Guid, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicCollection, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = m_pCollection->m_rVersion.dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = m_pCollection->m_rVersion.dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, m_pCollection->m_Info.m_csName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );
	//MultiByteToWideChar( CP_ACP, 0, m_pCollection->m_Info.m_csName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );
	//MultiByteToWideChar( CP_ACP, 0, m_pCollection->m_Info.m_csName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}

HRESULT CCollectionRef::GetRegionWaveName(  BYTE bMSB, 
											BYTE bLSB, 
											BYTE bPC, 
											BOOL fDrums, 
											BYTE bMIDINote, 
											BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

	BYTE bIMSB, bILSB, bIPC;
	BOOL fIDrums;

	CInstrument *pInstrument = m_pCollection->m_Instruments.GetHead();

	for( ;  pInstrument ;  pInstrument = pInstrument->GetNext() )
	{
		bIMSB = (BYTE) ((pInstrument->m_rInstHeader.Locale.ulBank >> 8) & 0x7F);
		bILSB = (BYTE) (pInstrument->m_rInstHeader.Locale.ulBank & 0x7F);
		fIDrums = ((pInstrument->m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS) != 0);
		bIPC = (BYTE) pInstrument->m_rInstHeader.Locale.ulInstrument;
		
		if(bMSB == bIMSB && bLSB == bILSB && bPC == bIPC && fDrums == fIDrums)
		{
			CInstrumentRegions* pRegions = pInstrument->GetRegions();
			if(pRegions)
			{
				short nNumberOfLayers = short(pRegions->GetNumberOfLayers());
				CPtrList lstRegions;
				if(SUCCEEDED(pRegions->FindRegionsForNote(bMIDINote, &lstRegions)))
				{
					CString strWaveNames;
					for(int nLayer = 0; nLayer < nNumberOfLayers; nLayer++)
					{
						POSITION position = lstRegions.GetHeadPosition();
						while(position)
						{
							CRegion* pRegion = (CRegion*)lstRegions.GetNext(position);
							if(pRegion && pRegion->GetLayer() == nLayer)
							{
								CString strNextWaveName = pRegion->GetWaveName();
								if (!strNextWaveName.IsEmpty())
								{
									if(strWaveNames.IsEmpty() == FALSE)
									{
										strWaveNames += ",";
									}

									strWaveNames += strNextWaveName;
								}
							}
						}
					}

					*pbstrName = strWaveNames.AllocSysString();
					return S_OK;
				}
			}

			return E_FAIL;
		}
	}

	return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionRef Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionRef.h ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//	CollectionRef.h
//	DLS Collection Reference node declaration
//	Created 3/17/98 Eric Whitcombe
//
///////////////////////////////////////////////////////////////////////////////////////////
#ifndef __COLLECTION_REF__
#define __COLLECTION_REF__

#include "DLSDesignerDLL.h"
#include "DLSComponent.h"
#include "Collection.h"

class CCollectionRef : public IDMUSProdNode, public IDMUSProdReferenceNode,
					   public IDLSQueryInstruments
{
public:
	CCollectionRef(CDLSComponent* pComponent);
	~CCollectionRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	// IDLSQueryInstruments functions
	HRESULT STDMETHODCALLTYPE ResetInstrumentList();
	

	BOOL	STDMETHODCALLTYPE GetNextInstrument(BYTE *pbMSB, 
												BYTE *pbLSB, 
												BYTE *pcPC, 
												BOOL *pfDrums, 
												signed char *pszName, 
												DWORD dwMaxLen);
	
	BOOL	STDMETHODCALLTYPE GetInstrumentName(BYTE bMSB, 
												BYTE bLSB, 
												BYTE cPC, 
												BOOL fDrums, 
												signed char *pszName, 
												DWORD dwMaxLen);

	HRESULT	STDMETHODCALLTYPE GetObjectDescriptor(DWORD dwDescSize,
												  void *pObjectDesc);

	HRESULT	STDMETHODCALLTYPE GetRegionWaveName(BYTE bMSB, 
												BYTE bLSB, 
												BYTE bPC, 
												BOOL fDrums, 
												BYTE bMIDINote, 
												BSTR* pbstrName);
public:
	CCollection*			m_pCollection;//the referenced collection

private:
	DWORD					m_dwInstrumentIndex;
    DWORD					m_dwRef;
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*		    m_pIParentNode;
	CDLSComponent*			m_pComponent;
};

#endif // __COLLECTION_REF__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ConditionalChunk.cpp ===
#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "DLSComponent.h"
#include "dls2.h"
#include "ConditionalChunk.h"
#include "NameUnknownQueryDialog.h"

Opcode CConditionalChunk::m_arrOpcodes[MAX_OPERATORS] = 
					{Opcode(DLS_CDL_AND, BITWISE_AND), Opcode(DLS_CDL_OR, BITWISE_OR), Opcode(DLS_CDL_XOR, BITWISE_XOR), Opcode(DLS_CDL_ADD, ADDITIVE), 
					Opcode(DLS_CDL_SUBTRACT, ADDITIVE), Opcode(DLS_CDL_MULTIPLY, MULTIPLICATIVE), Opcode(DLS_CDL_DIVIDE, MULTIPLICATIVE), Opcode(DLS_CDL_LOGICAL_AND, LOGICAL_AND), 
					Opcode(DLS_CDL_LOGICAL_OR, LOGICAL_OR), Opcode(DLS_CDL_LT, RELATIONAL), Opcode(DLS_CDL_LE, RELATIONAL), Opcode(DLS_CDL_GT, RELATIONAL), 
					Opcode(DLS_CDL_GE, RELATIONAL), Opcode(DLS_CDL_EQ, EQUALITY), Opcode(DLS_CDL_NOT, UNARY, TRUE), Opcode(DLS_CDL_QUERYSUPPORTED, UNARY, TRUE)};


CConditionalChunk::CConditionalChunk(CDLSComponent* pComponent): m_pComponent(pComponent), 
m_pExpressionTreeRoot(NULL), 
m_dwRef(0),
m_dwQueriesInParseTree(0),
m_dwQueriesInExpression(0),
m_dwOpsInExpression(0),
m_dwOpsInParseTree(0),
m_bIsDirty(FALSE)
{
	ASSERT(pComponent);
	InitOpcodeStrings();
}

void CConditionalChunk::InitOpcodeStrings()
{
	for(int nIndex = 0; nIndex < MAX_OPERATORS; nIndex++)
	{
		m_arrOpcodes[nIndex].m_sSymbol.LoadString(IDS_OPCODE_BITWISE_AND + nIndex);
		m_arrOpcodes[nIndex].m_sHelpString.LoadString(IDS_OPCODE_HELP_BITWISE_AND + nIndex);
	}
}


CConditionalChunk::~CConditionalChunk()
{
	DeleteExpressionTree();
	DeleteOperationsList();
}


HRESULT CConditionalChunk::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
		return E_FAIL;

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
		return E_POINTER;

	ASSERT(pckMain);
	if(pckMain == NULL)
		return E_POINTER;

	// Delete the previous list
	DeleteOperationsList();

	IStream* pIStream = pIRiffStream->GetStream();
	if(pIStream == NULL)
		return E_OUTOFMEMORY;

	HRESULT hr = E_FAIL;

	DWORD dwBytesRead = 0;
	while(dwBytesRead < pckMain->cksize)
	{
		Operation* pOperation = NULL;
		// Read the Operation.opcode
		DWORD cb = 0;
		USHORT usOpcode;
		hr = pIStream->Read(&usOpcode, sizeof(USHORT), &cb);
		if(FAILED(hr) || cb != sizeof(USHORT))
		{
			pIStream->Release();
			return hr;
		}
		
		dwBytesRead += cb;

		pOperation = new Operation;
		if(pOperation == NULL)
		{
			return E_OUTOFMEMORY;
		}
		pOperation->m_usOpcode = usOpcode;

		if(usOpcode == DLS_CDL_QUERY || usOpcode == DLS_CDL_QUERYSUPPORTED)
		{
			GUID guidQuery;
			hr = pIStream->Read(&guidQuery, sizeof(GUID), &cb);
			if(FAILED(hr) || cb != sizeof(GUID))
			{
				pIStream->Release();
				return hr;
			}

			CString sQueryName;
			if(m_pComponent->IsAPresetQuery(guidQuery, sQueryName) == FALSE)
			{
				CNameUnknownQueryDialog nameQueryDlg(NULL, m_pComponent);
				nameQueryDlg.SetQueryGUID(guidQuery);

				while(nameQueryDlg.DoModal() != IDOK);
				CString sQueryName = nameQueryDlg.GetQueryName();
				CDLSQuery* pDLSQuery = new CDLSQuery(guidQuery, sQueryName);
				ASSERT(pDLSQuery);
				m_pComponent->WriteQueryToRegistryAndAddToList(pDLSQuery);
			}
			
			dwBytesRead += cb;
			pOperation->m_guidDLSQuery = guidQuery;
		}
		else if(usOpcode == DLS_CDL_CONST)
		{
			ULONG ulConstant = 0;
			hr = pIStream->Read(&ulConstant, sizeof(ULONG), &cb);
			if(FAILED(hr) || cb != sizeof(ULONG))
			{
				pIStream->Release();
				return hr;
			}
			
			dwBytesRead += cb;
			pOperation->m_ulConstant = ulConstant;
		}

		m_lstOperations.AddTail(pOperation);
	}

	pIStream->Release();

	// Build the expression tree and get the regular expression form
	m_sRegularExpression = RPNToRegular();

	return hr;
}

HRESULT CConditionalChunk::Save(IDMUSProdRIFFStream* pIRiffStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
		return E_FAIL;

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
		return E_POINTER;

	if(m_lstOperations.GetCount() == 0)
		return S_OK;

	IStream* pIStream = pIRiffStream->GetStream();
	if(pIStream == NULL)
		return E_OUTOFMEMORY;

	HRESULT hr = E_FAIL;
	MMCKINFO ck;
	ck.ckid = FOURCC_CDL;
	ck.cksize = GetChunkSize();
	hr = pIRiffStream->CreateChunk(&ck, 0);
	if(FAILED(hr))
	{
		pIStream->Release();
		return E_FAIL;
	}

	POSITION position = m_lstOperations.GetHeadPosition();
	while(position)
	{
		Operation* pOperation = (Operation*) m_lstOperations.GetNext(position);
		ASSERT(pOperation);
		if(pOperation)
		{
			DWORD cb = 0;
			USHORT usOpcode = pOperation->m_usOpcode;
			hr = pIStream->Write((LPSTR)&usOpcode, sizeof(USHORT), &cb);
			if(FAILED(hr) || cb != sizeof(USHORT))
			{
				pIStream->Release();
				return E_FAIL;
			}

			if(usOpcode == DLS_CDL_QUERY || usOpcode == DLS_CDL_QUERYSUPPORTED)
			{
				hr = pIStream->Write((LPSTR)&(pOperation->m_guidDLSQuery), sizeof(GUID), &cb);
				if(FAILED(hr) || cb != sizeof(GUID))
				{
					pIStream->Release();
					return E_FAIL;
				}
			}
			else if(usOpcode == DLS_CDL_CONST)
			{
				hr = pIStream->Write((LPSTR)&(pOperation->m_ulConstant), sizeof(ULONG), &cb);
				if(FAILED(hr) || cb != sizeof(ULONG))
				{
					pIStream->Release();
					return E_FAIL;
				}
			}
		}
	}

	pIStream->Release();

	return S_OK;
}

void CConditionalChunk::DeleteExpressionTree()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pExpressionTreeRoot == NULL)
		return;
	
	DeleteTreeNode(m_pExpressionTreeRoot);
	m_pExpressionTreeRoot = NULL;
}

void CConditionalChunk::DeleteTreeNode(CExpressionTreeNode* pNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(pNode == NULL)
		return;

	DeleteTreeNode(pNode->m_pLeft);
	pNode->m_pLeft = NULL;

	DeleteTreeNode(pNode->m_pRight);
	pNode->m_pRight = NULL;

	if(pNode->m_pLeft == NULL && pNode->m_pRight == NULL)
	{
		delete pNode;
		pNode = NULL;
	}

}



void CConditionalChunk::DeleteOperationsList()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	while(!m_lstOperations.IsEmpty())
	{
		Operation* pOperation = (Operation*) m_lstOperations.RemoveHead();
		if(pOperation)
		{
			delete pOperation;
		}
	}
}


HRESULT CConditionalChunk::RegularToRPN(CString sRegularExpression)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = E_FAIL;
	
	CString sNone;
	sNone.LoadString(IDS_NONE);

	// No condition?
	if(sRegularExpression.IsEmpty() || sRegularExpression == sNone)
	{
		DeleteOperationsList();
		DeleteExpressionTree();
		m_sRegularExpression = "";
		return S_OK;
	}

	// Remove all unwanted characters from both ends of the string
	sRegularExpression.TrimLeft();
	sRegularExpression.TrimRight();

	if(SUCCEEDED(hr = CheckForSyntax(sRegularExpression)))
	{
		m_sRegularExpression = sRegularExpression;
		hr = ConvertToRPN(sRegularExpression);
		if(FAILED(hr) || m_dwQueriesInParseTree != m_dwQueriesInExpression || m_dwOpsInExpression != m_dwOpsInParseTree)
		{
			DeleteOperationsList();
			DeleteExpressionTree();

			CString sErrorMessage;
			sErrorMessage.LoadString(IDS_MALFORMED_EXPRESSION);
			AfxMessageBox(sErrorMessage);
			return E_FAIL;
		}

	}

	return hr;
}

HRESULT	CConditionalChunk::ConvertToRPN(CString& sRegularExpression)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(sRegularExpression.IsEmpty())
		return E_FAIL;

	if(m_pExpressionTreeRoot)
	{
		DeleteExpressionTree();
	}

	m_pExpressionTreeRoot = BuildExpressionTree(sRegularExpression);
	
	// Do the postorder traversal and get the RPN form
	if(m_pExpressionTreeRoot)
	{
		CString sRPNForm;
		DeleteOperationsList();
		BOOL bError = FALSE;
		m_dwQueriesInParseTree = 0;
		m_dwOpsInParseTree = 0;
		TraversePostorder(m_pExpressionTreeRoot, sRPNForm, bError);
		if(bError == TRUE)
		{
			DeleteOperationsList();
			DeleteExpressionTree();

			/*CString sErrorMessage;
			sErrorMessage.LoadString(IDS_MALFORMED_EXPRESSION);
			AfxMessageBox(sErrorMessage);*/
			return E_FAIL;
		}


		CString sRegularForm;
		TraverseInorder(m_pExpressionTreeRoot, sRegularForm);
		m_sRegularExpression = sRegularForm;
		
		return S_OK;
	}
	
	return E_FAIL;
}

// Traverses the expression tree in postorder adding the tokens to the list of operations
void CConditionalChunk::TraversePostorder(CExpressionTreeNode* pNode, CString& sRPNForm, BOOL& bError)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(bError != FALSE)
		return;

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
		return;

	if(pNode == NULL)
		return;

	TraversePostorder(pNode->m_pLeft, sRPNForm, bError);
	TraversePostorder(pNode->m_pRight, sRPNForm, bError);
	
	if(!bError)
	{
		if(pNode->m_bNodeType == QUERY)
		{
			CString sQueryName;
			if(m_pComponent->IsAPresetQuery(pNode->m_guidQuery, sQueryName))
			{
				sRPNForm += sQueryName;
				m_dwQueriesInParseTree++;
			}
		}
		else if(pNode->m_bNodeType == CONSTANT)
		{
			CString sConstant;
			sConstant.Format("%d", pNode->m_ulConstant);
			sRPNForm += sConstant;
			m_dwOpsInParseTree++;
		}
		else if(pNode->m_bNodeType == OPCODE)
		{
			sRPNForm += pNode->m_Opcode.m_sSymbol;

			if(pNode->m_pRight == NULL)
			{
				bError = TRUE;
			}
			if(pNode->m_Opcode.m_bUnary && pNode->m_pLeft != NULL)
			{
				bError = TRUE;
			}
			else if(!pNode->m_Opcode.m_bUnary && pNode->m_pLeft == NULL)
			{
				bError = TRUE;
			}

			m_dwOpsInParseTree++;
		}
		else
		{
			bError = TRUE;
		}

		AddToOperationsList(pNode);
	}
}


void CConditionalChunk::TraverseInorder(CExpressionTreeNode* pNode, CString& sRegularForm)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
		return;

	if(pNode == NULL)
		return;

	if(pNode->m_bNodeType == OPCODE)
	{
		sRegularForm += "(";
	}

	TraverseInorder(pNode->m_pLeft, sRegularForm);
	
	if(pNode->m_bNodeType == QUERY)
	{
		CString sQueryName;
		if(m_pComponent->IsAPresetQuery(pNode->m_guidQuery, sQueryName))
		{
			sRegularForm += sQueryName;
		}
	}

	if(pNode->m_bNodeType == CONSTANT)
	{
		CString sConstant;
		sConstant.Format("%d", pNode->m_ulConstant);
		sRegularForm += sConstant;
	}

	if(pNode->m_bNodeType == OPCODE)
	{
		CString sOperator = " " + pNode->m_Opcode.m_sSymbol;
		if(!(pNode->m_Opcode.m_bUnary))
		{
			sOperator += " ";
		}

		sRegularForm += sOperator;
	}

	TraverseInorder(pNode->m_pRight, sRegularForm);

	if(pNode->m_bNodeType == OPCODE)
	{
		sRegularForm = sRegularForm + ")";
	}
}


void CConditionalChunk::AddToOperationsList(CExpressionTreeNode* pNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(pNode == NULL)
		return;

	Operation* pOperation = new Operation;
	
	if(pNode->m_bNodeType == OPCODE)
	{
		pOperation->m_usOpcode = USHORT(pNode->m_Opcode.m_nOpcode);
	}
	if(pNode->m_bNodeType == CONSTANT)
	{
		pOperation->m_usOpcode = DLS_CDL_CONST;
		pOperation->m_ulConstant = pNode->m_ulConstant;
	}
	if(pNode->m_bNodeType == QUERY)
	{
		pOperation->m_usOpcode = DLS_CDL_QUERY;
		pOperation->m_guidDLSQuery = pNode->m_guidQuery;
	}

	m_lstOperations.AddTail(pOperation);
}

CExpressionTreeNode* CConditionalChunk::BuildExpressionTree(CString sRegularExpression)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(sRegularExpression.IsEmpty())
		return NULL;

	// Trim the whitespaces from both ends of the expression
	sRegularExpression.TrimLeft();
	sRegularExpression.TrimRight();

	// Find the operator of the lowest precedence
	int nStartIndex = 0;
	int nEndIndex = 0;
	int nDepthLow = 0;
	CString	sOperator = GetNextOperator(sRegularExpression, nStartIndex, nEndIndex, nDepthLow);
	int nOffset = nEndIndex;
	Opcode opcodeLow;
	if(IsAnOpcode(sOperator, opcodeLow))
	{
		while(!sOperator.IsEmpty())
		{
			nStartIndex = nEndIndex;
			int nDepth = 0;
			sOperator = GetNextOperator(sRegularExpression, nStartIndex, nEndIndex, nDepth);

			Opcode opcode;
			if(IsAnOpcode(sOperator, opcode))
			{
				if(((opcode.m_nPrecedence < opcodeLow.m_nPrecedence) && nDepth <= nDepthLow) || nDepth < nDepthLow)
				{
					nDepthLow = nDepth;
					opcodeLow = opcode;
					nOffset = nEndIndex;
				}
			}
		}
		
		CExpressionTreeNode* pNode = new CExpressionTreeNode(opcodeLow);
		
		// Parse the left and right sides of the expression
		if(opcodeLow.m_bUnary)
		{
			pNode->m_pLeft = NULL;
		}
		else
		{
			pNode->m_pLeft = BuildExpressionTree(sRegularExpression.Left(nOffset - opcodeLow.m_sSymbol.GetLength()));
		}
		
		pNode->m_pRight = BuildExpressionTree(sRegularExpression.Right(sRegularExpression.GetLength() - nOffset));
		return pNode;
	}

	nStartIndex = 0;
	nEndIndex = 0;
	ULONG ulConstant = 0;
	CString sOperand = GetNextOperand(sRegularExpression, nStartIndex, nEndIndex);
	GUID guidQuery;
	if(m_pComponent->IsAPresetQuery(sOperand, guidQuery))
	{
		CExpressionTreeNode* pNode = new CExpressionTreeNode(guidQuery);
		return pNode;
	}
	else if(IsConstant(sOperand, ulConstant))
	{
		CExpressionTreeNode* pNode = new CExpressionTreeNode(ulConstant);
		return pNode;
	}

	return NULL;
}


HRESULT CConditionalChunk::CheckForSyntax(CString sRegularExpression)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = E_FAIL;
	
    // Reset the count for queries and opcodes
    m_dwOpsInExpression = 0;
    m_dwQueriesInExpression = 0;

	if(FAILED(hr = MatchBrackets(sRegularExpression)))
		return hr;

	if(FAILED(hr = VerifyAllQueries(sRegularExpression)))
		return hr;

	if(FAILED(hr = VerifyAllOpcodes(sRegularExpression)))
		return hr;

	return hr;
}

HRESULT CConditionalChunk::MatchBrackets(CString sRegularExpression)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	int nCount = 0;
	int nLength = sRegularExpression.GetLength();
	for(int nIndex = 0; nIndex < nLength; nIndex++)
	{
		if(sRegularExpression.GetAt(nIndex) == '(')
			nCount++;
		else if(sRegularExpression.GetAt(nIndex) == ')')
			nCount--;
	}

	if(nCount != 0)
	{
		CString sMissingParen = ")";
		if(nCount < 0)
		{
			sMissingParen = "(";
		}

		CString sErrorMessage;
		sErrorMessage.Format(IDS_ERR_MATCHING_PARENTHESIS_FORMAT, sMissingParen);
		AfxMessageBox(sErrorMessage);
		return E_FAIL;
	}

	return S_OK;
}


HRESULT CConditionalChunk::VerifyAllQueries(CString sRegularExpression)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}

    // Go through the expression and check for invalid Queries
	int nTokenStartIndex = 0;
	int nTokenEndIndex = 0;

	int nLength = sRegularExpression.GetLength();
	for(int nIndex = nTokenEndIndex; nIndex < nLength; nIndex++)
	{
		char cCheckedChar = sRegularExpression.GetAt(nIndex);
		if(isalnum(cCheckedChar) && nTokenStartIndex == nTokenEndIndex)
		{
			nTokenStartIndex = nIndex;
			nTokenEndIndex = nTokenStartIndex + 1; 
		}

		if((!isalnum(cCheckedChar) && nTokenStartIndex != nTokenEndIndex) || nIndex + 1 == nLength)
		{
			if(nIndex + 1 == nLength && isalnum(cCheckedChar))
			{
				nIndex = nLength;
			}

			nTokenEndIndex = nIndex;
			
			CString sToken = sRegularExpression.Mid(nTokenStartIndex, abs(nTokenEndIndex - nTokenStartIndex));
			sToken.TrimLeft();
			sToken.TrimRight();
			GUID guidQuery;
			if(sToken != ")" && sToken != "(")
			{
				if(m_pComponent->IsAPresetQuery(sToken, guidQuery) == FALSE)
				{
					ULONG ulConstant = 0;
					Opcode opcodeType;
					if(IsConstant(sToken, ulConstant) == FALSE && IsAnOpcode(sToken, opcodeType) == FALSE)
					{
						CString sErrorMessage;
						sErrorMessage.Format(IDS_ERR_UNKNOWN_QUERY, sToken);
						AfxMessageBox(sErrorMessage);
						return E_FAIL;
					}
					else
					{
						m_dwOpsInExpression++;
					}
				}
				else
				{
					m_dwQueriesInExpression++;
				}
			}
			
			nTokenStartIndex = nTokenEndIndex;
			nIndex = nTokenStartIndex;
		}
	}

	return S_OK;
}



HRESULT CConditionalChunk::VerifyAllOpcodes(CString sRegularExpression)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Go through the expression and check for invalid Queries
	int nTokenStartIndex = 0;
	int nTokenEndIndex = 0;

	int nLength = sRegularExpression.GetLength();
	for(int nIndex = nTokenEndIndex; nIndex < nLength; nIndex++)
	{
		char cTemp = sRegularExpression.GetAt(nIndex);
		if(!isalnum(cTemp) && (cTemp != ')' && cTemp != '(' && cTemp != ' ') && nTokenStartIndex == nTokenEndIndex)
		{
			nTokenStartIndex = nIndex;
		}

		if((isalnum(cTemp) || cTemp == ')' || cTemp == '(' || cTemp == ' ') && nTokenStartIndex != nTokenEndIndex)
		{
			nTokenEndIndex = nIndex;
			CString sToken = sRegularExpression.Mid(nTokenStartIndex, abs(nTokenEndIndex - nTokenStartIndex));
			Opcode opcodeType;
			if(IsAnOpcode(sToken, opcodeType) == FALSE)
			{
				CString sErrorMessage;
				sErrorMessage.Format(IDS_ERR_UNKNOWN_OPERATOR, sToken);
				AfxMessageBox(sErrorMessage);
				return E_FAIL;
			}
			else
			{
				m_dwOpsInExpression++;
			}
			
			nTokenStartIndex = ++nTokenEndIndex;
			nIndex = nTokenStartIndex;
		}
	}

	return S_OK;

}



BOOL CConditionalChunk::IsAnOpcode(const CString sToken, Opcode& opcodeType)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	for(int nIndex = 0; nIndex < MAX_OPERATORS; nIndex++)
	{
		if(m_arrOpcodes[nIndex].m_sSymbol == sToken)
		{
			opcodeType = m_arrOpcodes[nIndex];
			return TRUE;
		}
	}

	return FALSE;
}


BOOL CConditionalChunk::IsAnOpcode(const Operation* pOperation, Opcode& opcodeType)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(pOperation == NULL)
	{
		return FALSE;
	}

	if(pOperation->m_usOpcode == DLS_CDL_QUERY || pOperation->m_usOpcode == DLS_CDL_CONST)  
	{
		return FALSE;
	}

	for(int nIndex = 0; nIndex < MAX_OPERATORS; nIndex++)
	{
		if(m_arrOpcodes[nIndex].m_nOpcode == pOperation->m_usOpcode)
		{
			opcodeType = m_arrOpcodes[nIndex];
			return TRUE;
		}
	}

	return FALSE;
}

CString CConditionalChunk::RPNToRegular()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pExpressionTreeRoot)
	{
		DeleteExpressionTree();
	}

	if(m_lstOperations.GetCount() == 0)
		return "";

	POSITION position = m_lstOperations.GetTailPosition();
	Operation* pOperation = (Operation*) m_lstOperations.GetPrev(position);;
	m_pExpressionTreeRoot = BuildExpressionTree(pOperation, position);

	if(m_pExpressionTreeRoot)
	{
		CString sRegularForm;
		TraverseInorder(m_pExpressionTreeRoot, sRegularForm);
		return sRegularForm;
	}

	return "";
}


CExpressionTreeNode* CConditionalChunk::BuildExpressionTree(Operation* pOperation, POSITION& position)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(pOperation == NULL)
	{
		return NULL;
	}

	// If this is an operator
	Opcode opcode;
	if(IsAnOpcode(pOperation, opcode))
	{
		CExpressionTreeNode* pNode = new CExpressionTreeNode(opcode);
		
		// Special case for query supported operator
		if(opcode.m_nOpcode == DLS_CDL_QUERYSUPPORTED)
		{
			pNode->m_pLeft = NULL;
			CExpressionTreeNode* pQueryNode = new CExpressionTreeNode(pOperation->m_guidDLSQuery);
			pQueryNode->m_pLeft = NULL;
			pQueryNode->m_pRight = NULL;

			pNode->m_pRight = pQueryNode;

			return pNode;
		}

		if(position)
		{
			Operation* pPrevOperation = (Operation*) m_lstOperations.GetPrev(position);
			pNode->m_pRight = BuildExpressionTree(pPrevOperation, position);
			if(position)
			{
				pNode->m_pLeft = NULL;
				if(!opcode.m_bUnary)
				{
					pPrevOperation = (Operation*) m_lstOperations.GetPrev(position);
					pNode->m_pLeft = BuildExpressionTree(pPrevOperation, position);
				}
			}
		}

		return pNode;
	}

	if(pOperation->m_usOpcode == DLS_CDL_QUERY)
	{
		CExpressionTreeNode* pNode = new CExpressionTreeNode(pOperation->m_guidDLSQuery);
		return pNode;
	}

	if(pOperation->m_usOpcode == DLS_CDL_CONST)
	{
		CExpressionTreeNode* pNode = new CExpressionTreeNode(pOperation->m_ulConstant);
		return pNode;
	}

	return NULL;
}


BOOL CConditionalChunk::IsConstant(CString sToken, ULONG& ulValue)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	int nLength = sToken.GetLength();
	for(int nIndex = 0; nIndex < nLength; nIndex++)
	{
		if(!isalnum(sToken[nIndex]) || isalpha(sToken[nIndex]))
		{
			ulValue = 0;
			return FALSE;
		}
	}

	ulValue = atoi((LPCSTR)sToken);
	return TRUE;
}

CString CConditionalChunk::GetNextToken(CString sExpression, int nStartIndex, int& nEndIndex)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(sExpression.IsEmpty())
	{
		return sExpression;
	}
	
	// Trim the whitespaces
	sExpression.TrimLeft();
	sExpression.TrimRight();

	int nLength = sExpression.GetLength();

	// skip white spaces and brackets
	while(nStartIndex < nLength && (sExpression[nStartIndex] == ' ' || sExpression[nStartIndex] == '(' || sExpression[nStartIndex] == ')'))
	{
		nStartIndex++;
	}

	if(nStartIndex >= nLength)
	{
		return "";
	}

	// If the first character is not alphanumeric then it must be an operator?
	if(!isalnum(sExpression[nStartIndex]))
	{
		for(int nIndex = nStartIndex; nIndex < nLength; nIndex++)
		{
			if(isalnum(sExpression[nIndex]) || sExpression[nIndex] == ' ' || sExpression[nIndex] == '(' || sExpression[nIndex] == ')')
			{
				break;
			}
		}
		
		nEndIndex = nIndex;

		return sExpression.Mid(nStartIndex, abs(nEndIndex - nStartIndex));
	}
	
	// This could either be a query or a constant 
	for(int nIndex = nStartIndex; nIndex < nLength; nIndex++)
	{
		if(!isalnum(sExpression[nIndex]) || sExpression[nIndex] == ' ' || sExpression[nIndex] == '(' || sExpression[nIndex] == ')')
		{
			break;
		}
	}
	
	nEndIndex = nIndex;

	return sExpression.Mid(nStartIndex, abs(nEndIndex - nStartIndex));
}


CString CConditionalChunk::GetNextOperator(CString sExpression, int nStartIndex, int& nEndIndex, int& nDepth)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString sToken = GetNextToken(sExpression, nStartIndex, nEndIndex);
	while(!sToken.IsEmpty())
	{
		nStartIndex = nEndIndex;
		Opcode opcode;
		if(IsAnOpcode(sToken, opcode))
		{
			// Calculate depth
			int nLength = sExpression.GetLength();
			for(int nIndex = nEndIndex - 1; (nIndex >= 0 && nIndex < nLength); nIndex--)
			{
				if(sExpression[nIndex] == '(')
				{
					nDepth++;
				}
				if(sExpression[nIndex] == ')')
				{
					nDepth--;
				}
			}

			return sToken;
		}

		sToken = GetNextToken(sExpression, nStartIndex, nEndIndex);
	}

	return sToken;
}

CString CConditionalChunk::GetNextOperand(CString sExpression, int nStartIndex, int& nEndIndex)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
		return "";

	CString sToken = GetNextToken(sExpression, nStartIndex, nEndIndex);
	while(!sToken.IsEmpty())
	{
		nStartIndex = nEndIndex;
		GUID guidQuery;
		ULONG ulConstant = 0;
		if(m_pComponent->IsAPresetQuery(sToken, guidQuery) || IsConstant(sToken, ulConstant))
			return sToken;

		sToken = GetNextToken(sExpression, nStartIndex, nEndIndex);
	}

	return sToken;
}


CString CConditionalChunk::GetCondition()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return m_sRegularExpression;
}

DWORD CConditionalChunk::GetChunkSize()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	DWORD dwSize = 0;
	POSITION position = m_lstOperations.GetHeadPosition();
	while(position)
	{
		Operation* pOperation = (Operation*) m_lstOperations.GetNext(position);
		ASSERT(pOperation);
		if(pOperation)
		{
			USHORT usOpcode = pOperation->m_usOpcode; 
			dwSize += sizeof(usOpcode);
			
			if(usOpcode == DLS_CDL_QUERY || usOpcode == DLS_CDL_QUERYSUPPORTED)
			{
				dwSize += sizeof(GUID);
			}
			else if(usOpcode == DLS_CDL_CONST)
			{
				dwSize += sizeof(ULONG);
			}
		}
	}

	return dwSize;
}

CString CConditionalChunk::GetName()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString sNone;
	sNone.LoadString(IDS_NONE);

	if(m_sRegularExpression.IsEmpty())
		return sNone;

	return m_sRegularExpression;
}


BOOL CConditionalChunk::Evaluate(CSystemConfiguration* pConfig)
{
	ASSERT(pConfig);
	if(pConfig == NULL)
	{
		return FALSE;
	}

	// There's no condition set
	if(m_sRegularExpression.IsEmpty())
	{
		return TRUE;
	}

	BOOL bResult = (BOOL) EvaluateCondition(m_pExpressionTreeRoot, pConfig);
	return bResult;
}

DWORD CConditionalChunk::EvaluateCondition(CExpressionTreeNode* pNode, CSystemConfiguration* pConfig)
{
	if(pNode == NULL)
	{
		return 0;
	}

	if(pConfig == NULL)
	{
		return 0;
	}

	DWORD dwLeft = FALSE;
	DWORD dwRight = FALSE;

	switch(pNode->m_bNodeType)
	{
		case CONSTANT:
		{
			return pNode->m_ulConstant;
		}
		
		case QUERY:
		{
			DWORD dwValue = 0;
			pConfig->GetValueForQuery(pNode->m_guidQuery, dwValue);
			return dwValue;
		}
		case OPCODE:
		{
			// Are we trying to see if this query is supported?
			if(pNode->m_Opcode.m_nOpcode == DLS_CDL_QUERYSUPPORTED)
			{	
				DWORD dwValue = 0;
				GUID guidQuery = pNode->m_pRight->m_guidQuery;
				HRESULT hr = pConfig->GetValueForQuery(guidQuery, dwValue);
				if(FAILED(hr))
				{
					return FALSE;
				}
				else
				{
					return TRUE;
				}
			}
			// Else evaluate both sides for a binary operator
			else
			{
				if(!pNode->m_Opcode.m_bUnary)
				{
					
					dwLeft = EvaluateCondition(pNode->m_pLeft, pConfig);
				}
				dwRight = EvaluateCondition(pNode->m_pRight, pConfig);
			}

			return Operate(pNode->m_Opcode, dwLeft, dwRight);
		}
	}

	return 0;
}

DWORD CConditionalChunk::Operate(Opcode opcode, DWORD dwLeft, DWORD dwRight)
{
	switch(opcode.m_nOpcode)
	{
		// Bitwise AND
		case DLS_CDL_AND:
		{
			return (dwLeft & dwRight);
		}

		// Bitwise OR
		case DLS_CDL_OR:
		{
			return (dwLeft | dwRight);
		}

		case DLS_CDL_XOR:
		{
			return (dwLeft ^ dwRight);
		}

		case DLS_CDL_ADD:
		{
			return (dwLeft + dwRight);
		}   	  

		case DLS_CDL_SUBTRACT:
		{
			return (dwLeft - dwRight);
		}   	

		case DLS_CDL_MULTIPLY:
		{
			return (dwLeft * dwRight);
		}

		case DLS_CDL_DIVIDE:
		{
			if(dwRight == 0)
			{
				// Divide by Zero Error!!
				return 0;
			}
			
			return (dwLeft / dwRight);
		}		  

		case DLS_CDL_LOGICAL_AND:
		{
			return (dwLeft && dwRight);
		}	  

		case DLS_CDL_LOGICAL_OR:
		{
			return (dwLeft || dwRight);
		}	

		case DLS_CDL_LT:
		{
			return (dwLeft < dwRight);
		}			  

		case DLS_CDL_LE:
		{
			return (dwLeft <= dwRight);
		}
		
		case DLS_CDL_GT:
		{
			return (dwLeft > dwRight);
		}	    	

		case DLS_CDL_GE:
		{
			return (dwLeft >= dwRight);
		}

		case DLS_CDL_EQ:
		{
			return (dwLeft == dwRight);
		}

		case DLS_CDL_NOT:
		{
			// Any non-zero value is TRUE so return 0 for it's negation
			return ((dwLeft == 0) ? 1 : 0);
		}

		default:
		{
			// Default is always failure
			return 0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ConditionalChunk.h ===
#ifndef __CONDITIONALCHUNK_H__
#define __CONDITIONALCHUNK_H__

#include <afxtempl.h>
#include "DLSComponent.h"
#include "RiffStrm.h"

#define MAX_OPERATORS	16

// Precedences for Opcodes
#define UNARY			0xFF
#define MULTIPLICATIVE	UNARY >> 1
#define ADDITIVE		UNARY >> 2
#define RELATIONAL		UNARY >> 3
#define EQUALITY		UNARY >> 4
#define BITWISE_AND		UNARY >> 5
#define BITWISE_XOR		UNARY >> 6
#define BITWISE_OR		UNARY >> 7
#define LOGICAL_AND		UNARY >> 8
#define LOGICAL_OR		UNARY >> 9

#define	OPCODE			0x01
#define QUERY			OPCODE << 1
#define CONSTANT		OPCODE << 2

class Opcode
{

public:
	Opcode(UINT nOpcode = 0, UINT nPrecedence = 0, BOOL bUnary = FALSE)
	{
		m_nOpcode = nOpcode;
		m_nPrecedence = nPrecedence;
		m_bUnary = bUnary;
		m_bRightToLeft = FALSE;

		// Associativity for Unary operator is from right to left
		if(bUnary)
		{
			m_bRightToLeft = TRUE;
		}
	};


public:

	CString m_sSymbol;			
	CString m_sHelpString;
	UINT	m_nOpcode;
	UINT	m_nPrecedence;
	BOOL	m_bRightToLeft;	// Associativity for the opcode
	BOOL	m_bUnary;
};

class CDLSQuery;

class CExpressionTreeNode
{

public:
	CExpressionTreeNode(Opcode& opcode)
	{
		m_pLeft = NULL;
		m_pRight = NULL;

		m_Opcode = opcode;
		m_bNodeType = OPCODE;
	};

	CExpressionTreeNode(GUID guidQuery)
	{
		m_pLeft = NULL;
		m_pRight = NULL;

		m_guidQuery = guidQuery;
		m_bNodeType = QUERY;
	};

	CExpressionTreeNode(ULONG ulConstant)
	{
		m_pLeft = NULL;
		m_pRight = NULL;
		
		m_ulConstant = ulConstant;
		m_bNodeType= CONSTANT;
	}


	CExpressionTreeNode* m_pLeft;	// LHS of the expression
	CExpressionTreeNode* m_pRight;	// RHS of the expression

	Opcode	m_Opcode;
	GUID	m_guidQuery;
	BOOL	m_bNodeType;
	ULONG	m_ulConstant;
};

struct Operation
{
	USHORT m_usOpcode;
	GUID   m_guidDLSQuery;
	ULONG  m_ulConstant;
};


class CSystemConfiguration;

class CConditionalChunk
{

public:
	CConditionalChunk(CDLSComponent* pComponent);
	~CConditionalChunk();

	HRESULT Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
    HRESULT Save(IDMUSProdRIFFStream* pIRiffStream);

	HRESULT Load(IStream* pIStream);
	HRESULT	Save(IStream* pIStream);					// Used only for undo/Redo

	void	InitOpcodeStrings();
	HRESULT RegularToRPN(CString sRegularExpression);	// Parses the regular expression and saves it in the list of operations in the RPN format
	CString RPNToRegular();								// Goes through the operations list and constructs a regular expression			
	CString GetCondition();
	CString GetName();

	BOOL	Evaluate(CSystemConfiguration* pConfig);	// Evaluates the expression based on the passed configuration

public:
	static Opcode m_arrOpcodes[MAX_OPERATORS];				// The array of opcodes 
	
// Methods
private:
	
	CString GetNextToken(CString sExpression, int nStartIndex, int& nEndIndex);

	HRESULT CheckForSyntax(CString sRegularExpression);
	HRESULT MatchBrackets(CString sRegularExpression);
	HRESULT VerifyAllQueries(CString sRegularExpression);
	HRESULT VerifyAllOpcodes(CString sRegularExpression);
	BOOL	IsAnOpcode(const CString sToken, Opcode& opcodeType);
	BOOL	IsAnOpcode(const Operation* pOperation, Opcode& opcodeType);
	BOOL	IsConstant(CString sToken, ULONG& nConstant);
	
	HRESULT	ConvertToRPN(CString& sRegularExpression);
	CExpressionTreeNode* BuildExpressionTree(CString sRegularExpression);
	CExpressionTreeNode* BuildExpressionTree(Operation* pOperation, POSITION& position);
	CString GetNextOperator(CString sExpression, int nStartIndex, int& nEndindex, int& nDepth);
	CString GetNextOperand(CString sExpression, int nStartIndex, int& nEndIndex);

	void	TraversePostorder(CExpressionTreeNode* pNode, CString& sRPNForm, BOOL& bError);
	void	TraverseInorder(CExpressionTreeNode* pNode, CString& sRegularForm);
	void	AddToOperationsList(CExpressionTreeNode* pNode);

	void	DeleteOperationsList();
	void	DeleteExpressionTree();
	void	DeleteTreeNode(CExpressionTreeNode* pNode);

	DWORD	GetChunkSize();

	DWORD	EvaluateCondition(CExpressionTreeNode* pNode, CSystemConfiguration* pConfig);
	DWORD	Operate(Opcode opcode, DWORD dwLeft = 0, DWORD dwRight = 0);

	HRESULT	CountQueriesAndOpcodesInTree(DWORD& dwQueries, DWORD& dwOpcodes);

// Attributes
private:
	DWORD			m_dwRef;
	BOOL			m_bIsDirty;
	CDLSComponent*	m_pComponent;
	CString			m_sName;								// Friendly name for the condition
	CString			m_sRegularExpression;

	DWORD			m_dwQueriesInExpression;				// Number of queries in the expression; used in error checking after the parse tree is built
	DWORD			m_dwOpsInExpression;					// Number of operators/constants in the expression; used in error checking after the parse tree is built
	DWORD			m_dwQueriesInParseTree;
	DWORD			m_dwOpsInParseTree;
	
	CExpressionTreeNode* m_pExpressionTreeRoot;				// Pointer to the expression tree
	CTypedPtrList<CPtrList, Operation*> m_lstOperations;	// List of operations in the chunk

};


#endif //__CONDITIONALCHUNK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ConditionConfigEditor.cpp ===
// ConditionConfigEditor.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "DLSComponent.h"
#include "conditionconfigeditor.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConditionConfigEditor dialog


CConditionConfigEditor::CConditionConfigEditor(CWnd* pParent /*=NULL*/, CDLSComponent* pComponent)
	: CDialog(CConditionConfigEditor::IDD, pParent), m_pComponent(pComponent)
{
	ASSERT(pComponent);

	//{{AFX_DATA_INIT(CConditionConfigEditor)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CConditionConfigEditor::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConditionConfigEditor)
	DDX_Control(pDX, IDOK, m_OKButton);
	DDX_Control(pDX, IDC_VALUE_EDIT, m_ValueEdit);
	DDX_Control(pDX, IDC_QUERY_LIST, m_QueryList);
	DDX_Control(pDX, IDC_HELP_STATIC, m_HelpStatic);
	DDX_Control(pDX, IDC_CONFIG_NAME_EDIT, m_ConfigNameEdit);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConditionConfigEditor, CDialog)
	//{{AFX_MSG_MAP(CConditionConfigEditor)
	ON_EN_KILLFOCUS(IDC_CONFIG_NAME_EDIT, OnKillfocusConfigNameEdit)
	ON_EN_KILLFOCUS(IDC_VALUE_EDIT, OnKillfocusValueEdit)
	ON_LBN_SELCHANGE(IDC_QUERY_LIST, OnSelchangeQueryList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Helpers
void CConditionConfigEditor::SetConfig(CSystemConfiguration* pConfig)
{
	ASSERT(pConfig);
	m_pConfig = pConfig;
}

void CConditionConfigEditor::InitQueryList()
{
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}

	ASSERT(m_pConfig);
	if(m_pConfig == NULL)
	{
		return;
	}

	m_QueryList.ResetContent();

	// Add all the queries
	const CPtrList& lstDLSQueries = m_pComponent->GetListOfQueries();
	POSITION position = lstDLSQueries.GetHeadPosition();
	while(position)
	{
		CDLSQuery* pDLSQuery = (CDLSQuery*)lstDLSQueries.GetNext(position);
		ASSERT(pDLSQuery);
		if(pDLSQuery)
		{
			DWORD dwValue = 0;
			CString sQueryName = pDLSQuery->GetName();
			if(SUCCEEDED(m_pConfig->GetValueForQuery(pDLSQuery, dwValue)))
			{
				CString sValue;
				sValue.Format(" = %d", dwValue);
				sQueryName += sValue;
			}

			int nIndex = m_QueryList.AddString(sQueryName);
			if(nIndex != LB_ERR)
			{
				m_QueryList.SetItemDataPtr(nIndex, pDLSQuery);
			}
		}
	}
}



/////////////////////////////////////////////////////////////////////////////
// CConditionConfigEditor message handlers

BOOL CConditionConfigEditor::OnInitDialog() 
{
	CDialog::OnInitDialog();
	ASSERT(m_pConfig);

	// Set the note
	CString sHelpText;
	sHelpText.LoadString(IDS_CONDITION_CONFIG_QUERYVALUENOTE);
	m_HelpStatic.SetWindowText(sHelpText);

	// Add the DLS Queries to the list box and set the strings to 
	// show the values if we have any values set for any of the queries
	InitQueryList();

	// Set the name of the configuration
	m_ConfigNameEdit.SetWindowText(m_pConfig->GetName());

	if(m_pConfig->IsDefault())
	{
		EnableControls(FALSE);
	}
	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CConditionConfigEditor::OnKillfocusConfigNameEdit() 
{
	CString sConfigName;
	m_ConfigNameEdit.GetWindowText(sConfigName);
	
	sConfigName.TrimLeft();
	sConfigName.TrimRight();

	if(sConfigName.IsEmpty())
	{
		return;
	}

	CSystemConfiguration* pConfig = m_pComponent->GetConfiguration(sConfigName);
	if(pConfig && pConfig != m_pConfig)
	{
		m_ConfigNameEdit.SetWindowText(m_pConfig->GetName());
		// Can't have multiple configs with the same name
		AfxMessageBox(IDS_ERR_CONFIG_NAME_CONFLICT);
		return;
	}

	m_pConfig->SetName(sConfigName);
}

void CConditionConfigEditor::OnOK() 
{
	ASSERT(m_pConfig);
	if(m_pConfig == NULL)
	{
		return;
	}

	// Make sure the name's updated
	OnKillfocusConfigNameEdit(); 

	CString sConfigName = m_pConfig->GetName();

	sConfigName.TrimLeft();
	sConfigName.TrimRight();

	if(sConfigName.IsEmpty())
	{
		// Can't have a config without a name
		AfxMessageBox(IDS_ERR_CONFIG_NO_NAME);
		return;
	}

	CDialog::OnOK();
}


void CConditionConfigEditor::OnKillfocusValueEdit() 
{
	CString sValue;
	m_ValueEdit.GetWindowText(sValue);

	int nIndex = m_QueryList.GetCurSel();
	if(nIndex != LB_ERR)
	{
		CDLSQuery* pQuery = (CDLSQuery*)m_QueryList.GetItemDataPtr(nIndex);
		ASSERT(pQuery);

		if(pQuery)
		{
			if(!sValue.IsEmpty())
			{
				DWORD dwValue = atoi(sValue);
				if(FAILED(m_pConfig->SetValueForQuery(pQuery, dwValue)))
				{
					// Adda Query-Value pair to the config
					CQueryValuePair* pQueryValuePair = new CQueryValuePair(pQuery, dwValue);
					if(pQueryValuePair)
					{
						m_pConfig->AddQueryValue(pQueryValuePair);
					}
				}
			}
			else
			{
				// Delete the query from the config
				m_pConfig->RemoveQueryValuePair(pQuery->GetGUID());
			}

			InitQueryList();
		}
	}
}


void CConditionConfigEditor::OnSelchangeQueryList() 
{
	int nIndex = m_QueryList.GetCurSel();
	if(nIndex != LB_ERR)
	{
		CDLSQuery* pQuery = (CDLSQuery*)m_QueryList.GetItemDataPtr(nIndex);
		ASSERT(pQuery);
		if(pQuery)
		{
			CString sValue = "";
			DWORD dwValue = 0;
			if(SUCCEEDED(m_pConfig->GetValueForQuery(pQuery, dwValue)))
			{
				sValue.Format("%d", dwValue);
				m_ValueEdit.SetWindowText(sValue);
			}
			else
			{
				// Clear the edit
				m_ValueEdit.SetWindowText(sValue);
			}
		}
	}
}


void CConditionConfigEditor::EnableControls(BOOL bEnable)
{
	m_ValueEdit.EnableWindow(bEnable);
	m_ConfigNameEdit.EnableWindow(bEnable);
	m_OKButton.EnableWindow(bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\conditionconfigeditor.h ===
#if !defined(AFX_CONDITIONCONFIGEDITOR_H__6D512B1A_8D27_47AE_99F8_618F3CB61B71__INCLUDED_)
#define AFX_CONDITIONCONFIGEDITOR_H__6D512B1A_8D27_47AE_99F8_618F3CB61B71__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// conditionconfigeditor.h : header file
//

#include "resource.h"

class CDLSComponent;
class CSystemConfiguration;

/////////////////////////////////////////////////////////////////////////////
// CConditionConfigEditor dialog

class CConditionConfigEditor : public CDialog
{
// Construction
public:
	CConditionConfigEditor(CWnd* pParent = NULL, CDLSComponent* pComponent = NULL);   // standard constructor

public:
	void SetConfig(CSystemConfiguration* pConfig);

private:
	void InitQueryList();
	void EnableControls(BOOL bEnable = TRUE);

private:
	CDLSComponent*			m_pComponent;
	CSystemConfiguration*	m_pConfig;

// Dialog Data
	//{{AFX_DATA(CConditionConfigEditor)
	enum { IDD = IDD_CONDITION_CONFIG_EDITOR };
	CButton	m_OKButton;
	CEdit	m_ValueEdit;
	CListBox	m_QueryList;
	CStatic	m_HelpStatic;
	CEdit	m_ConfigNameEdit;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConditionConfigEditor)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConditionConfigEditor)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusConfigNameEdit();
	virtual void OnOK();
	afx_msg void OnKillfocusValueEdit();
	afx_msg void OnSelchangeQueryList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONDITIONCONFIGEDITOR_H__6D512B1A_8D27_47AE_99F8_618F3CB61B71__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\CollectionWaves.h ===
#ifndef __COLLECTIONWAVES_H__
#define __COLLECTIONWAVES_H__

// CollectionWaves.h : header file
//

#include "alist.h"
#include "DllJazzDataObject.h"

class CCollection;
class CWaveNode;
class CWave;

class CCollectionWaves : public AList, public IDMUSProdNode, public IDMUSProdNodeDrop
{
friend class CCollection;
friend class CDLSComponent;

public:
    CCollectionWaves();
	~CCollectionWaves();

	//	AList overrides
    CWaveNode* GetHead();
    CWaveNode* RemoveHead();
	void Remove(CWaveNode* pWave);
	void AddTail(CWaveNode* pWave);

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnResourceId);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit(HMENU hMenu);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect(long lCommandId);

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode** ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo(DMUSProdListInfo* pListInfo);

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );
    // IDMUSProdNode : drag & drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

	// IDMUSProdNodeDrop : interface that handles special drag-drop cases for this node
	HRESULT STDMETHODCALLTYPE OnDropFiles(HANDLE hDropInfo);

	//		Additional functions.
	HRESULT Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	HRESULT PasteCF_WAVE( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject);
	HRESULT PasteWaves( IDMUSProdRIFFStream* pRiffStream);

	HRESULT InsertWaveFile(CString sFileName, CWaveNode** ppInsertedWave = NULL);
	BOOL	AddToCollection(IDMUSProdNode* pIChildNode);

	void	NotifyInstrumentsWavesChanged();						// Goes through the instrument list and asks the instrument editor to update 
	void	ReplaceWave(CWaveNode* pWave, CString sWaveFileName);	// Replaces pWave wherever it's referenced with the sWaveFileName pWave is deleted
	HRESULT	GetListOfMonoWaves(CPtrList* pWaveList);				// Goes through the list of nodes and collects the mono waves (even the individual channels of a stereo wave) and returns the list
	HRESULT	GetListOfWaves(CPtrList* pWaveList);					// Goes through the list of nodes and collects the mono and stereo waves
	CWave*	GetFirstWave();											// Returns wave pointed to by first node, NULL if none
	BOOL	IsNodeInCollection(CWaveNode* pWaveNode);				// Returns TRUE if the the node is already in the collection

	CCollection*	GetCollection();

	void	ReleaseWaveNodeDummyInstruments();
	void	UnRegisterWavesFromTransport();
	void	RegisterWavesWithTransport();

private:
    DWORD				m_dwRef;
	CDLSComponent*		m_pDLSComponent;
	IDMUSProdNode*		m_pIRootNode;
	IDMUSProdNode*		m_pIParentNode;

	CCollection*	 m_pCollection;
};

#endif // __COLLECTIONWAVES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\conditionconfigtoolbar.h ===
#if !defined(AFX_CONDITIONCONFIGTOOLBAR_H__789EFBE2_AC84_44D9_B1DF_20FE23EC4112__INCLUDED_)
#define AFX_CONDITIONCONFIGTOOLBAR_H__789EFBE2_AC84_44D9_B1DF_20FE23EC4112__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// conditionconfigtoolbar.h : header file
//

#include "DMUSProd.h"

/////////////////////////////////////////////////////////////////////////////
// CConditionConfigToolbar window

class CDLSComponent;
class CSystemConfiguration;

class CConditionConfigToolbar : public CToolBarCtrl, public IDMUSProdToolBar
{

	// Construction
public:
	CConditionConfigToolbar(CDLSComponent* pComponent = NULL);

	// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();


	// IDMUSProdToolBar methods
	HRESULT STDMETHODCALLTYPE GetInfo(HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle);
	HRESULT STDMETHODCALLTYPE GetMenuText(BSTR* pbstrText);
	HRESULT STDMETHODCALLTYPE GetMenuHelpText(BSTR* pbstrHelpText);
	HRESULT STDMETHODCALLTYPE Initialize(HWND hWndToolBar);

	// Methods to deal with setting up conditions in the combo
	void	RefreshConfigCombo(CPtrList* pListOfConditions);
	void	OnSelchangeCombo();
	void	OnAddButtonClicked();
	void	OnDeleteButtonClicked();
	void	OnEditButtonClicked();
	
	CSystemConfiguration* GetCurrentConfig();
	void SetCurrentConfig(CSystemConfiguration* pConfig);


// Attributes
public:

private:
	CDLSComponent* m_pComponent;

	CFont		m_font;
	CComboBox	m_ConfigsCombo;
	DWORD		m_dwRef;
	
	CMenu*		m_pPopupMenu;
	
	CSystemConfiguration*	m_pCurrentConfig;	

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConditionConfigToolbar)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CConditionConfigToolbar();

	// Generated message map functions
protected:
	//{{AFX_MSG(CConditionConfigToolbar)
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONDITIONCONFIGTOOLBAR_H__789EFBE2_AC84_44D9_B1DF_20FE23EC4112__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\conditionconfigtoolbar.cpp ===
// conditionconfigtoolbar.cpp : implementation file
//

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "dlsdesigner.h"
#include "resource.h"
#include "conditionconfigtoolbar.h"
#include "ConditionConfigEditor.h"
#include "ConditionalChunk.h"
#include "DLSComponent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConditionConfigToolbar

CConditionConfigToolbar::CConditionConfigToolbar(CDLSComponent* pComponent) : CToolBarCtrl(),
m_dwRef(0), 
m_pComponent(pComponent),
m_pCurrentConfig(NULL)
{
	ASSERT(pComponent);
	m_pPopupMenu = new CMenu();
}

CConditionConfigToolbar::~CConditionConfigToolbar()
{
	m_pCurrentConfig = NULL;
	delete m_pPopupMenu;
}


BEGIN_MESSAGE_MAP(CConditionConfigToolbar, CToolBarCtrl)
	//{{AFX_MSG_MAP(CConditionConfigToolbar)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



// IUnknown implementation
HRESULT CConditionConfigToolbar::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if(::IsEqualIID(riid, IID_IDMUSProdToolBar) || ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = (IDMUSProdToolBar*)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CConditionConfigToolbar::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CConditionConfigToolbar::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

// IDMUSProdToolbar methods
HRESULT CConditionConfigToolbar::GetInfo(HWND* phWndOwner, HINSTANCE* phInstance, UINT* pnResourceId, BSTR* pbstrTitle)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( (phWndOwner == NULL)
	||	(phInstance == NULL)
	||	(pnResourceId == NULL)
	||	(pbstrTitle == NULL) )
	{
		return E_POINTER;
	}

	*phWndOwner = m_hWnd;
	*phInstance = theApp.m_hInstance;
	*pnResourceId = (UINT)-1;  // We are going to build the toolbar from scratch

	CString strTitle;
	strTitle.LoadString(IDS_CONDITION_CONFIG_TOOLBAR_TITLE);
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}

HRESULT CConditionConfigToolbar::GetMenuText(BSTR* pbstrText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( pbstrText == NULL )
	{
		return E_POINTER;
	}

	CString strText;
	strText.LoadString(IDS_CONDITION_CONFIG_TOOLBAR_MENUTEXT);
	*pbstrText = strText.AllocSysString();
	
	return S_OK;
}

HRESULT CConditionConfigToolbar::GetMenuHelpText(BSTR* pbstrHelpText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( pbstrHelpText == NULL )
	{
		return E_POINTER;
	}

	CString strHelpText;
	strHelpText.LoadString(IDS_CONDITION_CONFIG_TOOLBAR_HELP);
	*pbstrHelpText = strHelpText.AllocSysString();

	return S_OK;
}

HRESULT CConditionConfigToolbar::Initialize(HWND hWndToolBar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if(hWndToolBar == NULL)
	{
		return E_INVALIDARG;
	}

	CToolBarCtrl* pToolBarCtrl = new CToolBarCtrl;
	if(pToolBarCtrl == NULL)
	{
		return E_OUTOFMEMORY;
	}

	pToolBarCtrl->Attach(hWndToolBar);
	pToolBarCtrl->AddBitmap(2, IDB_CONDITION_CONFIG_TOOLBAR);

	CClientDC* pDC = new CClientDC(pToolBarCtrl);

	int nHeight = -((pDC->GetDeviceCaps(LOGPIXELSY) * 8) / 72);

	CString strFontName;
	if( strFontName.LoadString(IDS_TOOLBAR_FONT ) == 0)
	{
		strFontName = CString("MS Sans Serif");
	}
	m_font.CreateFont(nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0, 
		DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
		DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, strFontName);

	CFont* pOldFont = pDC->SelectObject( &m_font );

	TEXTMETRIC tm;
	pDC->GetTextMetrics( &tm );
	int cxChar = 30 * (tm.tmAveCharWidth);
	int cyChar = 10 * (tm.tmHeight + tm.tmExternalLeading);

	pDC->SelectObject( pOldFont );
	delete pDC;


	TBBUTTON button1;
	button1.dwData = 0;
	button1.iString = NULL;
	button1.iBitmap = cxChar;	// Width
	button1.idCommand = IDC_CONDITION_CONFIG_COMBO;
	button1.fsState = TBSTATE_ENABLED;
	button1.fsStyle = TBSTYLE_SEP;
	pToolBarCtrl->InsertButton(0, &button1);

	CRect rect;
	pToolBarCtrl->GetItemRect( 0, &rect );
	rect.bottom = rect.top + cyChar;

	if(!m_ConfigsCombo.Create(WS_CHILD | WS_VISIBLE | WS_VSCROLL | CBS_DROPDOWNLIST | CBS_HASSTRINGS |  CBS_SORT, 
							rect, pToolBarCtrl, IDC_CONDITION_CONFIG_COMBO))
	{
		return E_FAIL;
	}

	CString sNone;
	sNone.LoadString(IDS_NONE);
	m_ConfigsCombo.SetFont(&m_font);
	m_ConfigsCombo.AddString(sNone);
	m_ConfigsCombo.SelectString(0, sNone);

	// The Add button
	TBBUTTON button2;
	button2.dwData = 0;
	button2.iString = NULL;
	button2.iBitmap = 0;
	button2.idCommand = IDC_CONDITION_CONFIG_ADD_BUTTON;
	button2.fsState = TBSTATE_ENABLED;
	button2.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton( 1, &button2 );

	pToolBarCtrl->GetItemRect(1, &rect);
	rect.bottom = rect.top + (long)(1.8 * (cyChar / 10));

	// The Delete button
	TBBUTTON button3;
	button3.dwData = 0;
	button3.iString = NULL;
	button3.iBitmap = 1;	
	button3.idCommand = IDC_CONDITION_CONFIG_DELETE_BUTTON;
	button3.fsState = TBSTATE_ENABLED;
	button3.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton(2, &button3);

	pToolBarCtrl->GetItemRect(2, &rect);
	rect.bottom = rect.top + (long)(1.8 * (cyChar / 10));


	// The Edit button
	TBBUTTON button4;
	button4.dwData = 0;
	button4.iString = NULL;
	button4.iBitmap = 2;
	button4.idCommand = IDC_CONDITION_CONFIG_EDIT_BUTTON;
	button4.fsState = TBSTATE_ENABLED;
	button4.fsStyle = TBSTYLE_BUTTON;
	pToolBarCtrl->InsertButton(3, &button4);

	pToolBarCtrl->GetItemRect(3, &rect);
	rect.bottom = rect.top + (long)(1.8 * (cyChar / 10));

	if( pToolBarCtrl )
	{
		pToolBarCtrl->Detach();
		delete pToolBarCtrl;
	}

	m_pPopupMenu->LoadMenu(IDM_CONFIG_TOOLBAR_RMENU);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CConditionConfigToolbar message handlers

void CConditionConfigToolbar::RefreshConfigCombo(CPtrList* pConfigList)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	int nCurSel = m_ConfigsCombo.GetCurSel();
	m_ConfigsCombo.ResetContent();

	ASSERT(pConfigList);
	if(pConfigList == NULL)
	{
		return;
	}

	POSITION position = pConfigList->GetHeadPosition();
	while(position)
	{
		CSystemConfiguration* pConfig = (CSystemConfiguration*) pConfigList->GetNext(position);
		if(pConfig)
		{
			CString sConfigName = pConfig->GetName();
			if(m_ConfigsCombo.FindStringExact(0, sConfigName) == CB_ERR)
			{
				int nIndex = m_ConfigsCombo.AddString(sConfigName);
				if(nIndex != CB_ERR)
				{
					m_ConfigsCombo.SetItemDataPtr(nIndex, pConfig);
				}
			}
		}
	}

	m_ConfigsCombo.SetCurSel(nCurSel);
}


void CConditionConfigToolbar::OnSelchangeCombo()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}

	int nIndex = m_ConfigsCombo.GetCurSel();
	if(nIndex != CB_ERR)
	{
		CSystemConfiguration* pConfig = (CSystemConfiguration*)m_ConfigsCombo.GetItemDataPtr(nIndex);
		ASSERT(pConfig);
		if(pConfig)
		{
			m_pCurrentConfig = pConfig;
			m_pComponent->OnConditionConfigChanged(m_pCurrentConfig, true);
		}
	}

	return;
}


void CConditionConfigToolbar::OnAddButtonClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}

	CSystemConfiguration* pConfig = new CSystemConfiguration();
	CConditionConfigEditor configEditor(NULL, m_pComponent);
	configEditor.SetConfig(pConfig);
	if(configEditor.DoModal() == IDOK)
	{
		m_pComponent->AddConfiguration(pConfig);
		m_pComponent->RefreshConfigToolbar();
		SetCurrentConfig(pConfig);
	}
	else
	{
		delete pConfig;
	}
}


void CConditionConfigToolbar::OnDeleteButtonClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}
	
	CString sNone;
	sNone.LoadString(IDS_NONE);
	CString sConfigName;
	m_ConfigsCombo.GetWindowText(sConfigName);
	if(sConfigName == sNone)
	{
		return;
	}

	int nIndex = m_ConfigsCombo.GetCurSel();
	if(nIndex != CB_ERR)
	{
		CSystemConfiguration* pConfig = (CSystemConfiguration*)m_ConfigsCombo.GetItemDataPtr(nIndex);
		ASSERT(pConfig);
		if(pConfig == NULL)
		{
			return;
		}

		if(pConfig->IsDefault())
		{
			AfxMessageBox(IDS_ERR_DEFAULT_CONFIG_DELETE);
			return;
		}

		m_ConfigsCombo.DeleteString(nIndex);
		m_pComponent->DeleteConfiguration(pConfig);

		// Set the first config as the current config
		m_ConfigsCombo.SetCurSel(0);
		m_pCurrentConfig = (CSystemConfiguration*) m_ConfigsCombo.GetItemDataPtr(0);
		ASSERT(m_pCurrentConfig);
		m_pComponent->OnConditionConfigChanged(m_pCurrentConfig, true);
	}
}



void CConditionConfigToolbar::OnEditButtonClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}

	ASSERT(m_pCurrentConfig);
	if(m_pCurrentConfig == NULL)
	{
		return;
	}

	CString sNone;
	sNone.LoadString(IDS_NONE);
	if(m_pCurrentConfig->GetName() == sNone)
	{
		return;
	}

	CConditionConfigEditor configEditor(NULL, m_pComponent);
	configEditor.SetConfig(m_pCurrentConfig);
	if(configEditor.DoModal() == IDOK)
	{
		m_pComponent->RefreshConfigToolbar();
	}
}


BOOL CConditionConfigToolbar::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	// If this is a control
	if(lParam != 0)
	{
		WORD wID = LOWORD(wParam);
		WORD wCommand = HIWORD(wParam);
		if(wID == IDC_CONDITION_CONFIG_COMBO && wCommand == CBN_SELCHANGE)
		{
			OnSelchangeCombo();
			return TRUE;
		}

		if(wID == IDC_CONDITION_CONFIG_ADD_BUTTON && wCommand == BN_CLICKED)
		{
			OnAddButtonClicked();
			return TRUE;
		}

		
		if(wID == IDC_CONDITION_CONFIG_DELETE_BUTTON && wCommand == BN_CLICKED)
		{
			OnDeleteButtonClicked();
			return TRUE;
		}


		if(wID == IDC_CONDITION_CONFIG_EDIT_BUTTON && wCommand == BN_CLICKED)
		{
			OnEditButtonClicked();
			return TRUE;
		}
	}

	return CToolBarCtrl::OnCommand(wParam, lParam);
}

CSystemConfiguration* CConditionConfigToolbar::GetCurrentConfig()
{
	return m_pCurrentConfig;
}



void CConditionConfigToolbar::SetCurrentConfig(CSystemConfiguration* pConfig)
{
	// We might be specifically setting the current config to NULL
	// when the configurations get deleted in the component
	if(pConfig)
	{
		CString sConfigName = pConfig->GetName();
		int nIndex = m_ConfigsCombo.FindStringExact(0, sConfigName);
		if(nIndex != CB_ERR)
		{
			m_ConfigsCombo.SelectString(0, sConfigName);
			m_pCurrentConfig = (CSystemConfiguration*)m_ConfigsCombo.GetItemDataPtr(nIndex);
		}
	}
	else
	{
		m_pCurrentConfig = NULL;
	}
}

void CConditionConfigToolbar::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	if(m_pPopupMenu)
	{
		CMenu* pPopupMenu = m_pPopupMenu->GetSubMenu(0);
		pPopupMenu->TrackPopupMenu(TPM_RIGHTBUTTON, point.x, point.y, this, NULL);	
	}
}

BOOL CConditionConfigToolbar::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	/*NMHDR* pnmhdr = (NMHDR*)lParam;
	if(pnmhdr->code == NM_RCLICK)
	{
		POINT point;
		GetCursorPos(&point);
		OnContextMenu(this, point);
	}*/
	
	return CToolBarCtrl::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ConditionEditor.h ===
#if !defined(AFX_CONDITIONEDITOR_H__C1589783_EB68_4B7B_84A9_F587596DB4CC__INCLUDED_)
#define AFX_CONDITIONEDITOR_H__C1589783_EB68_4B7B_84A9_F587596DB4CC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Resource.h"
#include "Region.h"
#include "Instrument.h"
#include "SCriptEdit.h"

// ConditionEditor.h : header file
//
class CDLSComponent;
class CScriptEdit;

/////////////////////////////////////////////////////////////////////////////
// CConditionEditor dialog

class CConditionEditor : public CDialog
{
// Construction
public:
	CConditionEditor(CWnd* pParent = NULL, CDLSComponent* pComponent = NULL, CConditionalChunk* pConditionalChunk = NULL, CInstrument* pInstrument = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConditionEditor)
	enum { IDD = IDD_CONDITION_EDITOR };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConditionEditor)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

public:
	void ShowPopupMenu(CWnd* pWnd, CPoint point);

private:
	void WriteToExpression(WORD wID);

private:
	CDLSComponent*		m_pComponent;
	CConditionalChunk*	m_pConditionalChunk;
	CScriptEdit			m_ScriptEdit;
	CInstrument*		m_pInstrument;


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConditionEditor)
	virtual void OnOK();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONDITIONEDITOR_H__C1589783_EB68_4B7B_84A9_F587596DB4CC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ConditionEditor.cpp ===
// ConditionEditor.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "ConditionEditor.h"
#include "ConditionalChunk.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConditionEditor dialog


CConditionEditor::CConditionEditor(CWnd* pParent /*=NULL*/, CDLSComponent* pComponent, CConditionalChunk* pConditionalChunk, CInstrument* pInstrument)
	: CDialog(CConditionEditor::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConditionEditor)
	//}}AFX_DATA_INIT

	ASSERT(pComponent);
	m_pComponent = pComponent;
	m_pInstrument = pInstrument;
	m_pConditionalChunk = pConditionalChunk;
}


void CConditionEditor::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConditionEditor)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConditionEditor, CDialog)
	//{{AFX_MSG_MAP(CConditionEditor)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConditionEditor message handlers

void CConditionEditor::OnOK() 
{
	CString sExpression;
	m_ScriptEdit.GetWindowText(sExpression);

	if(m_pConditionalChunk)
	{
		CString sOldExpression = m_pConditionalChunk->GetCondition();
		if(FAILED(m_pConditionalChunk->RegularToRPN(sExpression)))
		{
			m_pConditionalChunk->RegularToRPN(sOldExpression);
			return;
		}
		
		// Set the old expression so we can save the undo state correctly....
		m_pConditionalChunk->RegularToRPN(sOldExpression);
		if(m_pInstrument)
		{
			m_pInstrument->SaveStateForUndo(IDS_UNDO_CONDITION);
		}

		// Set the new expression....
		m_pConditionalChunk->RegularToRPN(sExpression);

		CDialog::OnOK();
	}
}


BOOL CConditionEditor::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Subclass the edit control
	m_ScriptEdit.SubclassDlgItem(IDC_SCRIPT_EDIT, this);
	m_ScriptEdit.SetEditor(this);
	
	if(m_pConditionalChunk)
	{
		CString sCondition = m_pConditionalChunk->GetCondition();
		int nLength = sCondition.GetLength();
		m_ScriptEdit.SetWindowText(sCondition);	
		m_ScriptEdit.SetSel(nLength, nLength);
	}
	else
	{
		m_ScriptEdit.EnableWindow(FALSE);
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CConditionEditor::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	ShowPopupMenu(pWnd, point);
}


void CConditionEditor::ShowPopupMenu(CWnd* pWnd, CPoint point)
{
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
		return;

	// should this happen?
	if(pWnd == NULL)
		return;
	
	CMenu popupMenu;
	if(popupMenu.CreatePopupMenu() == FALSE)
	{
		return;
	}

	CString sQueriesPopupMenu;
	sQueriesPopupMenu.LoadString(IDS_QUERIES);
	CMenu menuQueries;
	if(menuQueries.CreatePopupMenu() == FALSE)
	{
		return;
	}

	CString sOperatorsPopupMenu;
	sOperatorsPopupMenu.LoadString(IDS_OPERATORS);
	CMenu menuOperators;
	if(menuOperators.CreatePopupMenu() == FALSE)
	{
		return;
	}

	// Get the list of queries	
	const CPtrList& lstDLSQueries = m_pComponent->GetListOfQueries();
	if(lstDLSQueries.IsEmpty())
	{
		return;
	}

	int nID = 0;
	POSITION position = lstDLSQueries.GetHeadPosition();
	while(position)
	{
		CDLSQuery* pDLSQuery = (CDLSQuery*) lstDLSQueries.GetNext(position);
		ASSERT(pDLSQuery);
		if(pDLSQuery)
		{
			menuQueries.AppendMenu(MF_STRING, nID++, pDLSQuery->GetName());
		}

	}

	// Add the operators
	for(int nIndex = 0; nIndex < MAX_OPERATORS; nIndex++)
	{
		Opcode opcode = CConditionalChunk::m_arrOpcodes[nIndex];
		CString sSymbol = opcode.m_sSymbol;
		
		// Add escape sequences for '&' characters
		sSymbol.Replace("&", "&&");

		CString sHelpString = opcode.m_sHelpString;
		CString sMenuItem = sSymbol + "\t" + sHelpString;

		menuOperators.AppendMenu(MF_STRING, nID++, sMenuItem);
	}

	popupMenu.AppendMenu(MF_POPUP | MF_STRING, (UINT) menuQueries.m_hMenu, sQueriesPopupMenu);
	popupMenu.AppendMenu(MF_POPUP | MF_STRING, (UINT) menuOperators.m_hMenu, sOperatorsPopupMenu);

	popupMenu.TrackPopupMenu(TPM_RIGHTBUTTON, point.x, point.y, this);

	menuQueries.Detach();
	menuOperators.Detach();

}

BOOL CConditionEditor::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	// This command is from the menu
	if(HIWORD(wParam) == 0 && lParam == 0)
	{
		WORD wID = LOWORD(wParam);
		WriteToExpression(wID);		
		
		return TRUE;
	}
	
	return CDialog::OnCommand(wParam, lParam);
}


void CConditionEditor::WriteToExpression(WORD wID)
{
	const CPtrList& lstDLSQueries = m_pComponent->GetListOfQueries();
	if(lstDLSQueries.IsEmpty())
	{
		return;
	}

	CString sCurrentExpression;
	m_ScriptEdit.GetWindowText(sCurrentExpression);
	sCurrentExpression += " ";

	// Try the queries first
	if(wID < lstDLSQueries.GetCount())
	{
		int nID = 0;
		POSITION position = lstDLSQueries.GetHeadPosition();
		while(position)
		{
			CDLSQuery* pDLSQuery = (CDLSQuery*) lstDLSQueries.GetNext(position);
			if(nID == wID)
			{
				m_ScriptEdit.ReplaceSel(" " + pDLSQuery->GetName());
				return;
			}
			nID++;
		}
	}
	else
	{
		int nOperatorIndex = wID - lstDLSQueries.GetCount();
		if( nOperatorIndex >= 0 && nOperatorIndex <= MAX_OPERATORS)
		{
			Opcode opcode = CConditionalChunk::m_arrOpcodes[nOperatorIndex];
			m_ScriptEdit.ReplaceSel(" " + opcode.m_sSymbol);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DlsDefsPlus.h ===
// DlsDefsPlus.h : header file
//

#ifndef DLSDEFSPLUS_H
#define DLSDEFSPLUS_H

#define BUFFER_64	64
#define BUFFER_128	128
#define BUFFER_256	256

#define DLS_ACTION_EDIT_ARTICULATION	1
#define DLS_ACTION_EDIT_REGION			2
#define DLS_ACTION_SELECT_REGION		3

#define MSB_MASK (0x00007F00)
#define LSB_MASK (0x0000007F)

#define MAKE_BANK(DRUM, MSB, LSB) ( ((DWORD) ((DRUM) == 0 ? 0 : 0x80000000))  | ((DWORD)(BYTE)(MSB) << 8) | (DWORD)(LSB))
#define MSB(ulBank) (((ulBank) & MSB_MASK) >> 8)
#define LSB(ulBank) ((ulBank) & LSB_MASK)

#define DLS_ERR_FIRST					((HRESULT)0x80040100L) //(OLE_E_LAST + 1)

#define SC_PATCH_DUP_GM					(0x00000001)		// patch number in GM set
#define SC_PATCH_DUP_COLLECTION			(0x00000002)		// duplicate patch in collection
#define SC_PATCH_DUP_SYNTH				(0x00000008)		// duplicate patch in other collection
#define SC_NO_VALID_PATCHES				(0x00000010)		// All patches taken


#define	DLS_PATCH_DUP_GM				(DLS_ERR_FIRST | SC_PATCH_DUP_GM)
#define DLS_PATCH_DUP_COLLECTION		(DLS_ERR_FIRST | SC_PATCH_DUP_COLLECTION)
#define DLS_PATCH_DUP_GM_AND_COLLECTION	(DLS_ERR_FIRST | SC_PATCH_DUP_GM | SC_PATCH_DUP_COLLECTION)
#define DLS_PATCH_DUP_SYNTH				(DLS_ERR_FIRST | SC_PATCH_DUP_SYNTH)
#define DLS_PATCH_DUP_GM_AND_SYNTH		(DLS_ERR_FIRST | SC_PATCH_DUP_GM | SC_PATCH_DUP_SYNTH)
#define DLS_PATCH_DUP_ALL				(DLS_ERR_FIRST | SC_PATCH_DUP_GM | SC_PATCH_DUP_COLLECTION | SC_PATCH_DUP_SYNTH)
#define DLS_NO_VALID_PATCHES			(DLS_ERR_FIRST | SC_NO_VALID_PATCHES) 

#define	DLS_DLG_FIX_ALL					0x00000010
#define DLS_DLG_IGNORE_ALL_GM			0x00000020
#define DLS_DLG_IGNORE_ALL_COLLECTION	0x00000040
#define DLS_DLG_IGNORE_ALL_SYNTH		0x00000080

#define SC_BAD_INST_HEADER				(0x00000200)
#define DLS_1_INST_HEADER_SIZE			(12)

#define	DEFAULT_VELOCITY				127
#define WAVE_PREVIEW_VELOCITY			DEFAULT_VELOCITY
#define INSTR_PREVIEW_VELOCITY			DEFAULT_VELOCITY

//Legacy chunks these should be recognized and promptly ignored in Loading code
#define FOURCC_EDIT	mmioFOURCC('e','d','i','t')
#define FOURCC_MSYN mmioFOURCC('m','s','y','n')


#endif // #ifndef DLSDEFSPLUS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSComponent.h ===
#ifndef __DLSCOMPONENT_H__
#define __DLSCOMPONENT_H__

// DLSComponent.h : header file
//

#include "DLSDesigner.h"
#include "alist.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "Conductor.h"
#include <afxtempl.h>

#define PCHANNEL_GROUP_DLS	137
#define PCHANNEL_DLS		(PCHANNEL_GROUP_DLS * 16)
#define PCHANNEL_DLS_DRUM	(PCHANNEL_GROUP_DLS * 16 + 9)

class CCollection;
class CJazzDataObject;
class CInstrument;
class CWaveNode;
class CConditionConfigToolbar;


/////////////////////////////////////////////////////////////////////////////
// Defined DLS Synth supported qeries that can be used to setup conditions in 
// the conditional chunks for regions and articulations

class CDLSQuery
{
public:
	CDLSQuery(GUID guidDLSQuery, CString sName)
	{
		m_Guid = guidDLSQuery;
		m_sName = sName;
	};

	CString GetName()
	{
		return m_sName;
	}

	GUID GetGUID()
	{
		return m_Guid;
	}

private:
	GUID	m_Guid;
	CString m_sName;

};


//////////////////////////////////////////////////////////////////////
// This class keeps the value for a DLS query as defined by the author
class CQueryValuePair
{

public:

	CQueryValuePair(CDLSQuery* pDLSQuery, DWORD dwValue);
	~CQueryValuePair();

public:
	
	CDLSQuery*	GetQuery();
	DWORD		GetValue();
	void		SetValue(DWORD dwValue);

private:
	
	CDLSQuery*	m_pDLSQuery;	// The query for which a value has been set
	DWORD		m_dwValue;		// The value for a query; any non-zero value is TRUE for boolean queries
};


//////////////////////////////////////////////////////////
// Named set of values mapping to queries....
// 
class CSystemConfiguration
{

public:

	CSystemConfiguration(bool bDefaultConfig = false);
	~CSystemConfiguration();

public:

	CString GetName();
	void	SetName(CString sConfigName);
	bool	IsDefault();

	// Operations on list of QueryValue list
	HRESULT	GetValueForQuery(CDLSQuery* pDLSQuery, DWORD& dwValue);
	HRESULT	GetValueForQuery(GUID guidQuery, DWORD& dwValue);
	HRESULT SetValueForQuery(CDLSQuery* pDLSQuery, DWORD dwValue);
	HRESULT AddQueryValue(CQueryValuePair* pQueryValuePair);
	HRESULT RemoveQueryValuePair(CQueryValuePair* pQueryValuePair);
	HRESULT RemoveQueryValuePair(GUID guidQuery);

	CPtrList& GetQueryValueList();

private:
	CQueryValuePair* GetQueryValuePair(CDLSQuery* pDLSQuery);

private:
	bool m_bDefaultConfig;
	CString		m_sName;		// Name for the configuration, this is used in the dropdown in the toolbar
	CTypedPtrList<CPtrList, CQueryValuePair*> m_lstQueryValues;
	
};

/////////////////////////////////////////////////////////////////////
// Keeps the guids for a collection so failure on load can be checked
class CCollectionGUIDItem
{
public:
	// Constructor
	CCollectionGUIDItem(GUID collectionGUID)
	{
		m_CollectionGUID = collectionGUID;
	};


	GUID m_CollectionGUID;
};

/////////////////////////////////////////////////////////////////////
// List of collections
class CCollectionList : public AList
{
	friend class CDLSComponent;
	friend class CDLSDocType;
	friend class CCollection;

	
	//	AList overrides
    CCollection *GetHead();
	CCollection *GetItem(LONG lIndex);
    CCollection *RemoveHead();
	void Remove(CCollection *pINode);
	void AddTail(CCollection *pINode);
};

/////////////////////////////////////////////////////////////////////////
// DLS component class

class CDLSComponent : public IDMUSProdComponent, IDMUSProdPortNotify, IDMUSProdDLSNotify, IDMUSProdNotifySink, IDLSReferenceLoadNotify, IDMUSProdRIFFExt
{
public:
    CDLSComponent();
	~CDLSComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize(IDMUSProdFramework* pIFramework, 
										 BSTR* pbstrErrMsg);

	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode);
	HRESULT STDMETHODCALLTYPE CleanUp(void);
    HRESULT STDMETHODCALLTYPE GetName(BSTR* pbstrName);
	HRESULT STDMETHODCALLTYPE OnActivateApp(BOOL fActivate);

	// IDMUSProdPortNotify methods
	HRESULT STDMETHODCALLTYPE OnOutputPortsChanged(void);
	HRESULT STDMETHODCALLTYPE OnOutputPortsRemoved(void);

	// IDMUSProdDLSNotify methods
	HRESULT STDMETHODCALLTYPE OnDownloadCustomDLS(BOOL fDownloadCustomDLS);
	HRESULT STDMETHODCALLTYPE OnDownloadGM(BOOL fDownloadGM);

	// IDMUSProdNotifySink methods
	HRESULT STDMETHODCALLTYPE OnUpdate(IDMUSProdNode *pIDocRootNode, GUID guidUpdateType, void *pData);

	// IDLSReferenceLoadNotify methods
	HRESULT STDMETHODCALLTYPE MarkLoadStart(void);
	HRESULT STDMETHODCALLTYPE MarkLoadEnd(void);

	// IDMUSProdRIFFExt methods
	HRESULT STDMETHODCALLTYPE LoadRIFFChunk(IStream* pIStream, IDMUSProdNode** ppITopNode);



    // Additional functions
public:
    HRESULT STDMETHODCALLTYPE GetCollectionImageIndex(short* pnNbrFirstImage);
	HRESULT STDMETHODCALLTYPE GetCollectionRefImageIndex(short* pnNbrFirstImage);
    HRESULT STDMETHODCALLTYPE GetInstrumentImageIndex(short* pnNbrFirstImage);
    HRESULT STDMETHODCALLTYPE GetArticulationImageIndex(short* pnNbrFirstImage);
	HRESULT STDMETHODCALLTYPE GetArticulationGrayedImageIndex( short* pnFirstImage);
    HRESULT STDMETHODCALLTYPE GetRegionImageIndex(short* pnNbrFirstImage);
	HRESULT STDMETHODCALLTYPE GetRegionGrayedImageIndex( short* pnFirstImage);
    HRESULT STDMETHODCALLTYPE GetWaveImageIndex(short* pnNbrFirstImage);
	HRESULT STDMETHODCALLTYPE GetStereoWaveImageIndex(short* pnNbrFirstImage);
	HRESULT STDMETHODCALLTYPE GetWaveRefImageIndex( short* pnNbrFirstImage );
	HRESULT STDMETHODCALLTYPE GetStereoWaveRefImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFolderImageIndex(short* pnNbrFirstImage);
	HRESULT STDMETHODCALLTYPE GetFolderGrayedImageIndex(short* pnNbrFirstImage);


private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists(void);
	DWORD	GetCollectionWithName(char *nName);
	void	ReleaseAll();

public:
	HRESULT	GetAppendValueForPort(IDirectMusicPortDownload* pPortDownload, DWORD* pdwAppendValue);
	HRESULT IsValidDummyPatch(CInstrument* pValidateInstrument, ULONG ulBank, ULONG ulInstrument);
	HRESULT GetNextValidDummyPatch(CInstrument* pDummy, BYTE* pWMSB, BYTE* pWLSB, BYTE* pWPatch);
	void	NotifyDummyInstruments();
	bool	IsGM(DWORD dwBank, DWORD dwInstrument);

	HRESULT GetNextValidPatch(DWORD dwDrum, BYTE* pWMSB, BYTE* pWLSB, BYTE* pWPatch);
	HRESULT IsValidPatch(CInstrument* pValidateInstrument, ULONG ulBank, ULONG ulInstrument, CCollection* pLoadingCollection, CInstrument** ppInstrumentCollision);
	HRESULT PlayMIDIEvent(BYTE bStatus, BYTE bData1, BYTE bData2, DWORD dwTime, bool bIsDrum);

	void	SetSnapToZero(BOOL bSnapToZero);	// Sets the snaptozero option in the registry
	BOOL	IsSnapToZero();						// Is SnapToZero Set?
	BOOL	IsInReferenceLoad();				// Is the framework trying to load any file?
	void	GetPortName(IDirectMusicPortDownload* pIDMDownloadPort, CString& sPortName); 

	// Methods to deal with downloading/unloading collections and waves
	void	UnloadAllCollections();
	void	DownloadAllCollections();
	void	UnloadAllWaves();
	void	UnloadWave(CWaveNode* pWaveNode);
	void	DownloadAllWaves();
	BOOL	IsAutoDownloadOkay();
	BOOL	IsCollectionDownloadOK();


	// Methods to handle the FAILED collection GUIDs list
	void				 AddToFailedCollectionGUIDs(GUID collectionGUID);		// Adds to the FAILED list
	void				 DeleteFromFailedCollectionGUIDs(GUID collectionGUID);	// Deletes from the FAILED list
	CCollectionGUIDItem* FindCollectionGUID(GUID srearchGUID);					// Looks for a GUID and returns the item if found
	void				 DeleteGUIDList();										// Delete the list
	
	// Methods to deal with collection nodes
	void	AddToCollectionList(CCollection* pCollection);
	void	DeleteFromCollectionList(CCollection* pCollection);
	bool	IsInCollectionList(CCollection* pCollection);

	// Methods to deal with wavenodes
	void	AddToWaveNodesList(CWaveNode* pWaveNode);
	void	DeleteFromWaveNodesList(CWaveNode* pWaveNode);
	bool	IsInWaveNodesList(CWaveNode* pWaveNode);
	bool	IsInWaveNodesList(GUID guidFile);
	HRESULT GetListOfWaves(CPtrList* pWaveList);
	BOOL	IsLongLoopsOK();
	void	SetLongLoopOK(BOOL bLongLoopOK);

	// Methods to deal with Queries
	void	DeleteQueryList();					// Delete the list of preset queries
	BOOL	IsAPresetQuery(const GUID guidQuery, CString& sQueryname);
	BOOL	IsAPresetQuery(const CString sQueryName, GUID& guidQuery);
	const	CPtrList& GetListOfQueries();
	CDLSQuery* GetDLSQuery(const GUID& guidQuery);
	void	WriteQueryToRegistryAndAddToList(CDLSQuery* pDLSQuery);
	
	// Methods to deal with configurations
	void	DeleteConfigList();
	void	RefreshConfigToolbar();
	void	OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode = true);
	void	DeleteConfiguration(CSystemConfiguration* pConfig);
	void	AddConfiguration(CSystemConfiguration* pConfig);
	void	WriteConfigToRegistry(CSystemConfiguration* pConfig);
	void	UpdateConfigsInRegistry();
	void	LoadConfigurations();
	void	ExportConfigurations(CString sPath); 
	void	ImportConfigurations(CString sPath);

	// Methods to deal with failed codecs
	void	AddToFailedCodecs(DWORD dwCodec);
	BOOL	IsInFailedCodecs(DWORD dwCodec);
	void	RemoveFromFailedCodecs(DWORD dwCodec);
	void	ClearFailedCodecs();

	// Accessors/Mutators for configurations
	CSystemConfiguration*	GetCurrentConfig();
	CSystemConfiguration*	GetConfiguration(CString sConfigName);		

	// Accessors/mutators for patch conflict dialog show/no-show flags
	void	SetCollectionPatchConflict(bool bShow);
	bool	IsNoShowCollectionPatchConflict();

	void	SetUserPatchConflict(bool bShow);
	bool	IsNoShowUserPatchConflict();

#ifdef DMP_XBOX
	void	SetBadXboxLoopWarning(bool bShow);
	bool	IsNoShowBadXboxLoopWarning();
#endif // DMP_XBOX

	IDirectMusic*					m_pIDirectMusic;
	IDirectMusicPerformance8*		m_pIPerformance;
	IDirectMusicPort*				m_pISynthPort;
	IDirectMusicAudioPath*			m_pIAudioPath;
	
	CTypedPtrList<CPtrList, IDirectMusicPortDownload *> m_lstDLSPortDownload;
	
	GUID							m_SynthGUID;
	IDMUSProdConductor*				m_pIConductor;	
	IDMUSProdFramework*				m_pIFramework;
	CJazzDataObject*				m_pCopyDataObject;

	short			m_nNextDLS;			// Appended to name of new Style
	short			m_nNextWave;
    
	// Clipboard formats
	UINT			m_cfProducerFile;	// CF_DMUSPROD_FILE clipboard format
    UINT			m_cfCollection;		// CF_COLLECTION
    UINT			m_cfWave;			// CF_WAVE
	UINT			m_cfInstrument;		// CF_INSTRUMENT

private:
	HRESULT	OpenPort();
	HRESULT	UpdateDLSPortList();
	HRESULT UpdateDLSDownloads();
	void	InitSnapToZero();
	void	InitQueryList();
	void	WriteQueryToRegistry(const GUID& guidQuery, CString sQueryName);
	void	WriteQueryToRegistry(const GUID& guidQuery, UINT nNameID);
	void	WriteToRegistry(TCHAR* pszValueName, UINT nValueType,					// Writes the passed DWORD under the  szValueName subkey in the registry 	 
							BYTE* pbValue, DWORD cbData, TCHAR* pszSubPath = NULL); // (Uses pszSubPath to create additional folders if necessary)

	void	CreateDefaultConfigs();
	
	CSystemConfiguration* GetConfigForPort(IDirectMusicPortDownload* pPort);
	HRESULT	ReadFromRegistry(TCHAR* pszValueName, DWORD* pdwType, DWORD* pdwDataSize, BYTE* pbData, TCHAR* pszSubPath = NULL);  
	BOOL	SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege);

	HRESULT ValidateWaveDummyInstruments(CPtrList* pWaveList, CInstrument* pValidateInstrument, ULONG ulBank, ULONG ulInstrument);
								

    DWORD			m_dwRef;

	CConditionConfigToolbar* m_pConditionConfigToolbar;

	IDMUSProdDocType8*  m_pIDLSDocType8;
	IDMUSProdDocType8*  m_pIWaveDocType8;
	CCollectionList		m_CollectionList;

	BOOL	m_bInCleanup;
	BOOL	m_bInReferencedLoad;
	BOOL	m_bAutoDownloadDLS;
	short	m_nFirstCollectionImage;
	short	m_nFirstCollectionRefImage;
	short	m_nFirstInstrumentImage;
	short	m_nFirstArticulationImage;
	short	m_nFirstArticulationGrayedImage;
	short	m_nFirstRegionImage;
	short	m_nFirstRegionGrayedImage;
	short	m_nFirstWaveImage;
	short	m_nFirstStereoWaveImage;
	short	m_nFirstWaveRefImage;
	short	m_nFirstStereoWaveRefImage;
	short	m_nFirstFolderImage;
	short	m_nFirstFolderGrayedImage ;
	BYTE	m_bDummyMSB;
	BYTE	m_bDummyLSB;
	BYTE	m_bDummyPatch;
	BOOL	m_bSnapToZero;
	bool	m_bShowGetFormatErrorMessage;
	bool	m_bNoShowCollectionPatchConflict;
	bool	m_bNoShowUserPatchConflict;
#ifdef DMP_XBOX
	bool	m_bNoShowBadXboxLoopWarning;
#endif // DMP_XBOX
	BOOL	m_bLongLoopOK;
	BOOL	m_bDownloadCollection;


	//	The next variable is used to maintain the IDLSQueryInstruments interface...
	DWORD	m_dwInstrumentIndex;

	// The list of GUIDs of collections that failed to load in referenced load condition
	// The referenced load is marked and unmarked by the framework when a file is opened
	// The referenced load will be marked for simple collection open as well............
	CTypedPtrList<CPtrList, CCollectionGUIDItem*>	m_lstFailedCollectionGUIDs;

	CList<DWORD, DWORD>		m_lstFailedCodecs;

	// This is the list of wavenodes that are NOT in a collection
	CTypedPtrList<CPtrList, CWaveNode*>	m_lstWaveNodes;

	// This is the list of preset queries that we support for conditional chunks
	CTypedPtrList<CPtrList, CDLSQuery*> m_lstDLSQueries;

	// This is the list of defined configurations for conditional testing
	CTypedPtrList<CPtrList, CSystemConfiguration*> m_lstConfigurations;

	// This is the list of default configurations...<none> and ActivePorts
	CTypedPtrList<CPtrList, CSystemConfiguration*> m_lstDefaultConfigs;
};

#endif // __DLSCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSComponent.cpp ===
// DLSComponent.cpp : implementation file
//

#include "stdafx.h"
#include "shlwapi.h"

#include "DlsDefsPlus.h"
#include "DLSDesignerDLL.h"
#include "Collection.h"
#include "Instrument.h"
#include "DLSDocType.h"
#include "WaveDocType.h"
#include "DLSComponent.h"
#include "AList.h"
#include "JazzDataObject.h"
#include "CollectionRef.h"
#include "WaveNode.h"
#include "Wave.h"
#include "WaveRefNode.h"
#include "MonoWave.h"
#include "StereoWave.h"
#include "Conductor.h"
#include "ConditionConfigToolbar.h"

#include <Process.h>
#include <dmksctrl.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/* HACKHACK
The DLS Designer now creates its own DMUS_APATH_DYNAMIC_STEREO audio path to play events on.
It eventually should copy the performance's default audio path.
*/

CWnd* CreateParentWindow( void )
{
	CWnd* pWndParent = new CWnd;
	if( pWndParent )
	{
		if( !pWndParent->CreateEx(0, AfxRegisterWndClass(0), NULL, WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL) )
		{
			delete pWndParent;
			pWndParent = NULL;
		}
	}
	return pWndParent;
}
/////////////////////////////////////////////////////////////////////////////
// CQueryValuePair Implmentation
CQueryValuePair::CQueryValuePair(CDLSQuery* pDLSQuery, DWORD dwValue) : 
m_pDLSQuery(pDLSQuery), m_dwValue(dwValue)
{
	ASSERT(pDLSQuery);
}

CQueryValuePair::~CQueryValuePair()
{
	m_pDLSQuery = NULL;
	m_dwValue = 0;
}

CDLSQuery* CQueryValuePair::GetQuery()
{
	ASSERT(m_pDLSQuery);
	return m_pDLSQuery;
}

DWORD CQueryValuePair::GetValue()
{
	ASSERT(m_pDLSQuery);
	return m_dwValue;
}

void CQueryValuePair::SetValue(DWORD dwValue)
{
	m_dwValue = dwValue;
}

/////////////////////////////////////////////////////////////////////////////
// CSystemConfiguration Implementation

CSystemConfiguration::CSystemConfiguration(bool bDefaultConfig) : m_bDefaultConfig(bDefaultConfig)
{
}

CSystemConfiguration::~CSystemConfiguration()
{
	// Delete the list
	while(!m_lstQueryValues.IsEmpty())
	{
		delete m_lstQueryValues.RemoveHead();
	}
}

CString CSystemConfiguration::GetName()
{
	return m_sName;
}

void CSystemConfiguration::SetName(CString sName)
{
	m_sName = sName;
}

bool CSystemConfiguration::IsDefault()
{
	return m_bDefaultConfig;
}

HRESULT	CSystemConfiguration::GetValueForQuery(CDLSQuery* pDLSQuery, DWORD& dwValue)
{
	ASSERT(pDLSQuery);
	if(pDLSQuery == NULL)
	{
		return E_POINTER;
	}

	return GetValueForQuery(pDLSQuery->GetGUID(), dwValue);
}



HRESULT	CSystemConfiguration::GetValueForQuery(GUID guidQuery, DWORD& dwValue)
{
	dwValue = 0;

	POSITION position = m_lstQueryValues.GetHeadPosition();
	while(position)
	{
		CQueryValuePair* pQueryValuePair = (CQueryValuePair*) m_lstQueryValues.GetNext(position);
		ASSERT(pQueryValuePair);
		if(pQueryValuePair)
		{
			CDLSQuery* pQuery = pQueryValuePair->GetQuery();
			ASSERT(pQuery);
			if(pQuery && ::IsEqualIID(pQuery->GetGUID(), guidQuery))
			{
				dwValue = pQueryValuePair->GetValue();
				return S_OK;
			}
		}
	}

	return E_FAIL;
}


HRESULT CSystemConfiguration::SetValueForQuery(CDLSQuery* pDLSQuery, DWORD dwValue)
{
	ASSERT(pDLSQuery);
	if(pDLSQuery == NULL)
	{
		return E_POINTER;
	}

	CQueryValuePair* pQueryValuePair = GetQueryValuePair(pDLSQuery);
	if(pQueryValuePair)
	{
		pQueryValuePair->SetValue(dwValue);
		return S_OK;
	}

	return E_FAIL;
}


CQueryValuePair* CSystemConfiguration::GetQueryValuePair(CDLSQuery* pDLSQuery)
{
	ASSERT(pDLSQuery);
	if(pDLSQuery == NULL)
	{
		return NULL;
	}

	POSITION position = m_lstQueryValues.GetHeadPosition();
	while(position)
	{
		CQueryValuePair* pQueryValuePair = (CQueryValuePair*) m_lstQueryValues.GetNext(position);
		ASSERT(pQueryValuePair);
		CDLSQuery* pQueryInPair = pQueryValuePair->GetQuery();
		if(pQueryInPair == pDLSQuery)
		{
			return pQueryValuePair;
		}
	}

	return NULL;
}


HRESULT CSystemConfiguration::AddQueryValue(CQueryValuePair* pQueryValuePair)
{
	ASSERT(pQueryValuePair);
	if(pQueryValuePair == NULL)
	{
		return E_POINTER;
	}

	m_lstQueryValues.AddTail(pQueryValuePair);
	return S_OK;
}


HRESULT CSystemConfiguration::RemoveQueryValuePair(CQueryValuePair* pQueryValuePair)
{
	ASSERT(pQueryValuePair);
	if(pQueryValuePair == NULL)
	{
		return E_POINTER;
	}

	POSITION position = m_lstQueryValues.Find(pQueryValuePair);
	if(position)
	{
		m_lstQueryValues.RemoveAt(position);
		return S_OK;
	}

	return E_FAIL;
}

HRESULT CSystemConfiguration::RemoveQueryValuePair(GUID guidQuery)
{
	POSITION position = m_lstQueryValues.GetHeadPosition();
	while(position)
	{
		// Keep the position; we might need it to remove it from the list
		POSITION oldPosition = position;

		CQueryValuePair* pQueryValuePair = (CQueryValuePair*) m_lstQueryValues.GetNext(position);
		ASSERT(pQueryValuePair);
		if(pQueryValuePair)
		{
			CDLSQuery* pDLSQuery = pQueryValuePair->GetQuery();
			ASSERT(pDLSQuery);
			if(pDLSQuery && ::IsEqualIID(pDLSQuery->GetGUID(), guidQuery))
			{
				m_lstQueryValues.RemoveAt(oldPosition);
				delete pQueryValuePair;
				return S_OK;
			}
		}
	}

	return E_FAIL;
}

CPtrList& CSystemConfiguration::GetQueryValueList()
{
	return m_lstQueryValues;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent constructor/destructor

CDLSComponent::CDLSComponent() :
m_pCopyDataObject(NULL),
m_bInReferencedLoad(FALSE),
m_bShowGetFormatErrorMessage(true),
m_bNoShowCollectionPatchConflict(false),
m_bNoShowUserPatchConflict(false),
#ifdef DMP_XBOX
m_bNoShowBadXboxLoopWarning(false),
#endif // DMP_XBOX
m_bLongLoopOK(FALSE),
m_bInCleanup(FALSE),
m_bDownloadCollection(TRUE)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    m_dwRef = 0;
	
	m_pIFramework = NULL;
	m_pIConductor = NULL;

	m_pIDirectMusic = NULL;

	m_pIPerformance = NULL;
	m_pISynthPort = NULL;
	m_pIAudioPath = NULL;

	m_pIDLSDocType8 = NULL;
	m_pIWaveDocType8 = NULL;

	m_pConditionConfigToolbar = NULL;

	m_nFirstCollectionImage = 0;
	m_nFirstInstrumentImage = 0;
	m_nFirstArticulationImage = 0;
	m_nFirstArticulationGrayedImage = 0;
	m_nFirstRegionImage = 0;
	m_nFirstRegionGrayedImage = 0;
	m_nFirstWaveImage = 0;
	m_nFirstStereoWaveImage = 0;
	m_nFirstWaveRefImage = 0;
	m_nFirstStereoWaveRefImage = 0;
	m_nFirstFolderImage = 0;
	m_nFirstFolderGrayedImage = 0;

	m_nNextDLS = 0;
	m_nNextWave = 0;

	m_dwInstrumentIndex = 0;

    m_cfCollection = 0;
    m_cfWave = 0;
	m_cfInstrument = 0;

	m_bDummyMSB = 0x7F;
	m_bDummyLSB = 0x7F;
	m_bDummyPatch = 0x7F;

	// Initialize m_bSnapToZero with the value in the registry
	InitSnapToZero();
}

CDLSComponent::~CDLSComponent()
{
	ReleaseAll();
}

void CDLSComponent::ReleaseAll( void )
{
	TCHAR szValueName[MAX_PATH];
	_tcscpy(szValueName, _T("SnapToZero"));
	WriteToRegistry(szValueName, REG_DWORD, (BYTE*)(&m_bSnapToZero), sizeof(BOOL));

	CleanUp();

	if( m_pIFramework )
	{
		if(m_pConditionConfigToolbar)
		{
			if( ::IsWindow(m_pConditionConfigToolbar->m_hWnd) )
			{
				m_pConditionConfigToolbar->DestroyWindow();
			}

			m_pIFramework->RemoveToolBar(m_pConditionConfigToolbar);
		}

		m_pIFramework->Release();
		m_pIFramework = NULL;
	}

	if( m_pIDLSDocType8 )
	{
		m_pIDLSDocType8->Release();
		m_pIDLSDocType8 = NULL;
	}

	if( m_pIWaveDocType8 )
	{
		m_pIWaveDocType8->Release();
		m_pIWaveDocType8 = NULL;
	}

	while( !m_lstDLSPortDownload.IsEmpty() )
	{
		m_lstDLSPortDownload.RemoveHead()->Release();
	}

	if( m_pIAudioPath )
	{
		m_pIAudioPath->Release();
		m_pIAudioPath = NULL;
	}
	if( m_pISynthPort )
	{
		m_pISynthPort->Release();
		m_pISynthPort= NULL;
	}
	if (m_pIPerformance) 
	{
		m_pIPerformance->Release();
		m_pIPerformance = NULL;
	}
	if( m_pIDirectMusic )
	{
		m_pIDirectMusic->Release();
		m_pIDirectMusic = NULL;
	}
	if( m_pIConductor )
	{
		m_pIConductor->Release();
		m_pIConductor = NULL;
	}

	// Update the configs in the registry before we get destroyed
	UpdateConfigsInRegistry();

	DeleteGUIDList();
	DeleteQueryList();
	DeleteConfigList();
}

void CDLSComponent::WriteToRegistry(TCHAR* pszValueName, UINT nValueType, BYTE* pbValue, DWORD cbData, TCHAR* pszSubPath)
{
	TCHAR szComponentPath[MAX_PATH];
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\DLSDesigner\\"));

	if(pszSubPath != NULL)
	{
		_tcscat(szComponentPath, pszSubPath);
	}
	
	HKEY	hkeyOpen;
	LPDWORD	lpdwDisposition = NULL;
	if(::RegCreateKeyEx(HKEY_CURRENT_USER, 
						szComponentPath, 
						0, 
						0,
						REG_OPTION_NON_VOLATILE, 
						KEY_ALL_ACCESS, 
						NULL, &hkeyOpen, 
						lpdwDisposition) == ERROR_SUCCESS)
	{
		if(RegSetValueEx(hkeyOpen, pszValueName, 0, nValueType, pbValue, cbData) != ERROR_SUCCESS)
		{
			TRACE("CDLSComponent::WriteToRegistry() - Registry Set Value FAILED!!");
		}

		::RegCloseKey(hkeyOpen);
	}
}


void CDLSComponent::WriteQueryToRegistry(const GUID& guidQuery, UINT nNameID)
{
	CString sKeyName;
	sKeyName.LoadString(nNameID);
	WriteQueryToRegistry(guidQuery, sKeyName);
}


void CDLSComponent::WriteQueryToRegistry(const GUID& guidQuery, CString sKeyName)
{
	LPOLESTR psz;
	if( SUCCEEDED( ::StringFromIID(guidQuery, &psz) ) )
	{
		TCHAR szGuid[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		WriteToRegistry(szGuid, REG_SZ, (BYTE*)((LPCSTR)sKeyName), (_tcslen(sKeyName) + 1), "Queries\\");
	}

}



void CCollectionList::AddTail(CCollection *pINode) 
{ 
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AList::AddTail((AListItem *) pINode);
}

CCollection *CCollectionList::GetItem(LONG lIndex) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	return (CCollection *)AList::GetItem(lIndex);
}

CCollection *CCollectionList::GetHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	return (CCollection *)AList::GetHead();
}

CCollection *CCollectionList::RemoveHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	return (CCollection *) AList::RemoveHead();
}

void CCollectionList::Remove(CCollection *pINode) 
{ 
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AList::Remove((AListItem *) pINode);
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IUnknown implementation

HRESULT CDLSComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    if(::IsEqualIID(riid, IID_IDMUSProdComponent) ||
	   ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = (IDMUSProdComponent*) this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IDMUSProdPortNotify))
    {
        AddRef();
        *ppvObj = (IDMUSProdPortNotify*) this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IDMUSProdDLSNotify))
    {
        AddRef();
        *ppvObj = (IDMUSProdDLSNotify*) this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IDMUSProdNotifySink))
    {
        AddRef();
        *ppvObj = (IDMUSProdNotifySink*) this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IDLSReferenceLoadNotify))
    {
        AddRef();
        *ppvObj = (IDLSReferenceLoadNotify*) this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IDMUSProdRIFFExt))
	{
		AddRef();
		*ppvObj = (IDMUSProdRIFFExt*) this;
		return S_OK;
	}

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CDLSComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CDLSComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDMUSProdComponent::Initialize

HRESULT CDLSComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate arguments
	ASSERT(pIFramework);
	ASSERT(pbstrErrMsg);
	
	IDMUSProdComponent* pIComponent = NULL;
	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework )		// already initialized
	{
		return S_OK;
	}

	theApp.SetFramework(pIFramework);
	m_pIFramework = pIFramework;
	m_pIFramework->AddRef();


	// Get IConductor and IAAEngine interface pointers 
	if( !SUCCEEDED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  !SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor ) ) )
	{
		ReleaseAll();
		if( pIComponent )
		{
			pIComponent->Release();
		}
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	OpenPort();

	if(m_pISynthPort)
	{
		if(FAILED(UpdateDLSPortList()))
		{
			m_pISynthPort->Release();
			m_pISynthPort = NULL;
		}

	}

	// Get the download status for the DLS downloads
	IDMUSProdConductor8* pIConductor8 = NULL;
	if(FAILED(m_pIConductor->QueryInterface(IID_IDMUSProdConductor8, (void**)&pIConductor8)))
	{
		m_pISynthPort->Release();
		m_pISynthPort = NULL;
		return E_FAIL;
	}

	if(FAILED(pIConductor8->GetDownloadCustomDLSStatus(&m_bAutoDownloadDLS)))
	{
		m_bAutoDownloadDLS = TRUE;
	}

	pIConductor8->Release();


	pIComponent->Release();

	// Register applicable doc types with the Framework 
	m_pIDLSDocType8 = new CDLSDocType( this );
    if( m_pIDLSDocType8 == NULL )
    {
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
        return E_OUTOFMEMORY;
    }

	m_pIDLSDocType8->AddRef();
	
	if( !SUCCEEDED ( pIFramework->AddDocType(m_pIDLSDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	m_pIWaveDocType8 = new CWaveDocType(this);
	if(m_pIWaveDocType8 == NULL)
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
        return E_OUTOFMEMORY;
    }

	m_pIWaveDocType8->AddRef();
	
	if( !SUCCEEDED ( pIFramework->AddDocType(m_pIWaveDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Add applicable images to the Project Tree control's image list 
	if( !SUCCEEDED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

    // Register the clipboard formats.
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
    m_cfCollection = ::RegisterClipboardFormat( CF_DLS_COLLECTION );
	m_cfWave = ::RegisterClipboardFormat( CF_DLS_WAVE );
	m_cfInstrument = ::RegisterClipboardFormat( CF_DLS_INSTRUMENT );
    if (m_cfCollection == 0 || m_cfWave == 0 || m_cfProducerFile == 0 || m_cfInstrument == 0)
    {
		ReleaseAll();
        //return FALSE;
		return E_FAIL;
    }

	// Tell Framework that the CF_DLS_COLLECTION format can be used to create a .dls
	CString strExt = _T(".dlp");
	BSTR bstrExt = strExt.AllocSysString();
	if( !SUCCEEDED ( pIFramework->RegisterClipFormatForFile(m_cfCollection, bstrExt) ) )
	{
		ReleaseAll();
		return E_FAIL;
	}

	// Tell Framework that the CF_DLS_WAVE format can be used to create a .wav
	strExt = _T(".wvp");
	bstrExt = strExt.AllocSysString();
	if( !SUCCEEDED ( pIFramework->RegisterClipFormatForFile(m_cfWave, bstrExt) ) )
	{
		ReleaseAll();
		return E_FAIL;
	}

#ifndef DMP_XBOX
	// Register the default DLS Queries (Supported by DMusic) if they aren't already in the registry
	WriteQueryToRegistry(DLSID_GMInHardware, IDS_QUERY_GMINHARDWARE);
	WriteQueryToRegistry(DLSID_GSInHardware, IDS_QUERY_GSINHARDWARE);
	WriteQueryToRegistry(DLSID_XGInHardware, IDS_QUERY_XGINHARDWARE);
	WriteQueryToRegistry(DLSID_SupportsDLS1, IDS_QUERY_SUPPORTSDLS1);
	WriteQueryToRegistry(DLSID_SupportsDLS2, IDS_QUERY_SUPPORTSDLS2);
	WriteQueryToRegistry(DLSID_SampleMemorySize, IDS_QUERY_SAMPLEMEMORYSIZE);
	WriteQueryToRegistry(DLSID_ManufacturersID, IDS_QUERY_MANUFACTURERSID);
	WriteQueryToRegistry(DLSID_ProductID, IDS_QUERY_PRODUCTID);
	WriteQueryToRegistry(DLSID_SamplePlaybackRate, IDS_QUERY_SAMPLEPLAYBACKRATE);

	InitQueryList();

	m_pConditionConfigToolbar = new CConditionConfigToolbar(this);
	if(m_pConditionConfigToolbar)
	{
		CWnd* pParentWnd = CreateParentWindow();
		if(pParentWnd == NULL)
		{
			delete m_pConditionConfigToolbar;
			m_pConditionConfigToolbar = NULL;
		}
		else
		{
			CRect rect(0, 0, 0, 0);
			if(m_pConditionConfigToolbar->Create(WS_CHILD, rect, pParentWnd, IDC_CONDITION_CONFIG_TOOLBAR) == 0)
			{
				pParentWnd->DestroyWindow();
				delete m_pConditionConfigToolbar;
				m_pConditionConfigToolbar = NULL;
			}
			else
			{
				HRESULT hr = pIFramework->AddToolBar(m_pConditionConfigToolbar);
				//  IDMUSProdFramework::AddToolBar reassigns parent so it is ok to destroy pWndParent
				if(pParentWnd->GetSafeHwnd())
				{
					pParentWnd->DestroyWindow();
				}
				delete pParentWnd;
				pParentWnd = NULL;

				if(FAILED(hr))
				{
					// Clean up
					if(m_pConditionConfigToolbar->m_hWnd)
					{
						m_pConditionConfigToolbar->DestroyWindow();
					}
					delete m_pConditionConfigToolbar;
					m_pConditionConfigToolbar = NULL;
				}
				else
				{
					// Load up saved configs from the registry
					LoadConfigurations();
					
					// Create the default configurations for active ports
					CreateDefaultConfigs();

					// Succeeded
					RefreshConfigToolbar();

					// Set the first config as current
					CSystemConfiguration* pConfig = (CSystemConfiguration*) m_lstConfigurations.GetHead();
					ASSERT(pConfig);
					m_pConditionConfigToolbar->SetCurrentConfig(pConfig);
				}
			}

		}
	}
#endif //DMP_XBOX
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDMUSProdComponent::CleanUp

HRESULT CDLSComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_bInCleanup = TRUE;

	if(m_pCopyDataObject)
	{
		if(S_OK == OleIsCurrentClipboard(m_pCopyDataObject))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
	
	CCollection *pCollection;

	while( !m_CollectionList.IsEmpty() )
	{
		pCollection = m_CollectionList.RemoveHead();
		pCollection->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDMUSProdComponent::GetName

HRESULT CDLSComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString strName;
	TCHAR achBuffer[BUFFER_128];

	if(::LoadString(theApp.m_hInstance, IDS_DLS_COMPONENT_NAME, achBuffer, BUFFER_128))
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDMUSProdComponent::CreateReferenceNode

HRESULT CDLSComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( IsEqualGUID ( guidRefNodeId, GUID_CollectionRefNode ) ) 
	{
		// Create RefNode
		CCollectionRef* pCollectionRef = new CCollectionRef(this);
		if( pCollectionRef == NULL )
		{
			return E_OUTOFMEMORY ;
		}

		*ppIRefNode = (IDMUSProdNode *)pCollectionRef;

		return S_OK;
	}
	else if( IsEqualGUID ( guidRefNodeId, GUID_WaveRefNode ) ) 
	{
		// Create RefNode
		CWaveRefNode* pWaveRefNode = new CWaveRefNode(this);
		if( pWaveRefNode == NULL )
		{
			return E_OUTOFMEMORY ;
		}

		*ppIRefNode = (IDMUSProdNode *)pWaveRefNode;

		return S_OK;
	}

	return E_INVALIDARG;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDMUSProdComponent::OnActivateApp

HRESULT CDLSComponent::OnActivateApp(BOOL fActivate)
{
	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDMUSProdPortNotify Implementation

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::OnOutputPortsRemoved
HRESULT CDLSComponent::OnOutputPortsRemoved(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// ...first unloaad all the downloaded collections from the port...
	CCollection* pCollection = m_CollectionList.GetHead();
	while (pCollection)
	{
		pCollection->Unload();
		pCollection = pCollection->GetNext();
	}

	// Now unload all the tand alone waves
	POSITION position = m_lstWaveNodes.GetHeadPosition();
	while(position)
	{
		CWaveNode* pWaveNode = (CWaveNode*)m_lstWaveNodes.GetNext(position);
		ASSERT(pWaveNode);
		if(pWaveNode && pWaveNode->IsInACollection() == false)
		{
			pWaveNode->UnloadFromAllPorts();
		}
	}


	while( !m_lstDLSPortDownload.IsEmpty() )
	{
		m_lstDLSPortDownload.RemoveHead()->Release();
	}
	
	if(m_pISynthPort)
	{
		m_pISynthPort->Release();
		m_pISynthPort = NULL;
	}

	if(m_pIAudioPath)
	{
		m_pIAudioPath->Release();
		m_pIAudioPath = NULL;
	}


	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::OnOutputPortsChanged
HRESULT CDLSComponent::OnOutputPortsChanged(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !m_pIConductor ) 
	{
		return S_FALSE;
	}

	// Release the current output ports
	OnOutputPortsRemoved();

	// Create our own private audio path (if necessary)
	if( m_pIAudioPath == NULL )
	{
		// TODO: Replace with code that duplicates the default performance audio path (Needs API work)
		if( FAILED( m_pIPerformance->CreateStandardAudioPath( DMUS_APATH_DYNAMIC_STEREO, 10, TRUE, &m_pIAudioPath ) ) )
		{
			// Only warn the user if we have any collections open
			if( !m_CollectionList.IsEmpty() )
			{
				AfxMessageBox(IDS_ERR_NO_PORT, MB_OK | MB_ICONEXCLAMATION);
			}

			return S_OK;
		}
	}

	// Now, see what PChannel 0 really maps to
	DWORD dwOutputPChannel;
	HRESULT hr = m_pIAudioPath->ConvertPChannel( 0, &dwOutputPChannel );
	if( FAILED( hr ) )
	{
		// Only warn the user if we have any collections open
		if( !m_CollectionList.IsEmpty() )
		{
			AfxMessageBox(IDS_ERR_NO_PORT, MB_OK | MB_ICONEXCLAMATION);
		}

		return S_OK;
	}

	// Now, see what synth the audio path is using
	if( FAILED( m_pIPerformance->PChannelInfo( dwOutputPChannel, &m_pISynthPort, NULL, NULL ) ) )
	{
		// Only warn the user if we have any collections open
		if( !m_CollectionList.IsEmpty() )
		{
			AfxMessageBox(IDS_ERR_NO_PORT, MB_OK | MB_ICONEXCLAMATION);
		}

		return S_OK;
	}

	if(FAILED(UpdateDLSPortList()))
	{
		m_pISynthPort->Release();
		m_pISynthPort = NULL;
		return E_FAIL;
	}

	// If the downloadport list is not empty then...
	if(!m_lstDLSPortDownload.IsEmpty())
	{
		// ...download all the opened collections to the port...
		CCollection* pCollection = m_CollectionList.GetHead();
		while (pCollection)
		{
			if(FAILED(pCollection->Download()))
			{
				return E_FAIL;
			}

			pCollection = pCollection->GetNext();
		}

		// Now download all the standalone waves
		POSITION position = m_lstWaveNodes.GetHeadPosition();
		while(position)
		{
			CWaveNode* pWaveNode = (CWaveNode*)m_lstWaveNodes.GetNext(position);
			ASSERT(pWaveNode);
			if(pWaveNode && pWaveNode->IsInACollection() == false)
			{
				if(FAILED(pWaveNode->InitAndDownload()))
				{
					return E_FAIL;
				}
			}
		}

	}

	CreateDefaultConfigs();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDMUSProdDLSNotify Implementation

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::OnDownloadCustomDLS 

HRESULT CDLSComponent::OnDownloadCustomDLS(BOOL fDownloadCustomDLS)
{
	m_bAutoDownloadDLS = fDownloadCustomDLS;

	return UpdateDLSDownloads();
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::OnDownloadGM

HRESULT CDLSComponent::OnDownloadGM(BOOL fDownloadGM)
{
	// Conductor takes care of downloading the GM set
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::OnUpdate

HRESULT CDLSComponent::OnUpdate(IDMUSProdNode *pIDocRootNode, GUID guidUpdateType, void *pData)
{
	// GUID_DownloadOnLoadRIFFChunk
	if (IsEqualGUID(GUID_DownloadOnLoadRIFFChunk, guidUpdateType))
	{
		// pData should not be NULL if we are passed GUID_DownloadOnLoadRIFFChunk.
		ASSERT(NULL != pData);
		if(NULL == pData)
		{
			return E_INVALIDARG;
		}

		m_bDownloadCollection = *(BOOL*)pData;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDLSReferenceLoadNotify implementation

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::MarkLoadStart()

HRESULT CDLSComponent::MarkLoadStart()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_bInReferencedLoad = TRUE;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::MarkLoadEnd()

HRESULT CDLSComponent::MarkLoadEnd()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_bInReferencedLoad = FALSE;
	DeleteGUIDList();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent IDMUSProdRIFFExt Implementation

////////////////////////////////////////////////////////////////////////////
// CDLSComponent::LoadRIFFChunk

HRESULT CDLSComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppITopNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	if( ppITopNode == NULL )
	{
		return E_POINTER;
	}
	*ppITopNode = NULL;

	// Create a RIFF stream
	IDMUSProdRIFFStream* pIRiffStream;
    if( FAILED ( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return E_FAIL;
	}

	// Store the stream position
	DWORD dwPos = StreamTell( pIStream );

	HRESULT hr = E_FAIL;

    // DLS Collections
	MMCKINFO ckMain;
	ckMain.fccType = FOURCC_DLS;
    if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
    {
		StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		CCollection* pCollection = new CCollection( this );
		if( pCollection )
		{
			if( SUCCEEDED ( pCollection->Load( pIStream ) ) )
			{
				*ppITopNode = (IDMUSProdNode *)pCollection;
				hr = S_OK;
			}
			else
			{
				pCollection->Release();
			}
			// Reset download collection flag so that we download the 
			// next time if flag was not set to FALSE in the OnUpdate() call.
			m_bDownloadCollection = TRUE;
		}
    }
	else
	{
		CString sFileName;
		IDMUSProdPersistInfo* pIJazzPersistInfo;
		if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)))
		{
			BSTR bstrFileName;
			pIJazzPersistInfo->GetFileName(&bstrFileName);
			sFileName = bstrFileName;
			::SysFreeString(bstrFileName);
			pIJazzPersistInfo->Release();
		}

		// Waves
		StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		ckMain.fccType = mmioFOURCC('W', 'A', 'V', 'E');
		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

			CWaveNode* pWaveNode = NULL;
			if(SUCCEEDED(CWaveNode::CreateWaveNode(this, pIStream, sFileName, &pWaveNode, NULL, false)))
			{
				// Download the wave to all the ports
				if(FAILED(pWaveNode->InitAndDownload()))
				{
					pWaveNode->Release();
					pWaveNode = NULL;
					return E_FAIL;
				}

				*ppITopNode = pWaveNode;
				
				// Register it with the transport
				pWaveNode->RegisterWithTransport();

				hr = S_OK;
			}
		}
	}

    pIRiffStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent additional functions

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::AddNodeImageLists

HRESULT CDLSComponent::AddNodeImageLists( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CImageList lstImages;
	HICON hIcon;

	// Create image list for Collection nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_COLLECTION) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_COLLECTION_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstCollectionImage ) ) )
	{
		return E_FAIL;
	}

	// Create image list for Collection Reference nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_COLLECTION_REF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_COLLECTION_REF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstCollectionRefImage ) ) )
	{
		return E_FAIL;
	}
	
	// Create image list for Instrument nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_INSTRUMENT) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_INSTRUMENT_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstInstrumentImage ) ) )
	{
		return E_FAIL;
	}
	
	// Create image list for Articulation nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_ARTICULATION) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_ARTICULATION_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstArticulationImage ) ) )
	{
		return E_FAIL;
	}

	// Create image list for grayed out Articulation nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_ARTICULATION_GRAY) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_ARTICULATION_GRAY_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstArticulationGrayedImage ) ) )
	{
		return E_FAIL;
	}

	// Create image list for Region nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_REGION) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_REGION_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstRegionImage ) ) )
	{
		return E_FAIL;
	}

	// Create the grayed out region node images
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_REGION_GRAY) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_REGION_GRAY_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstRegionGrayedImage ) ) )
	{
		return E_FAIL;
	}

	// Create image list for Wave nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_WAVE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_WAVE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstWaveImage ) ) )
	{
		return E_FAIL;
	}

	// Create image list for Wave nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_WAVE_STEREO) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_WAVE_STEREO_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstStereoWaveImage ) ) )
	{
		return E_FAIL;
	}


	// Create image list of generic folder images
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstFolderImage ) ) )
	{
		return E_FAIL;
	}

	// Create image list of grayed out generic folder images
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_GRAY) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_GRAY_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstFolderGrayedImage ) ) )
	{
		return E_FAIL;
	}



	// Create image list for WaveRef nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_WAVE_REF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_WAVE_REF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstWaveRefImage ) ) )
	{
		return E_FAIL;
	}

	// Create image list for WaveRef nodes
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_WAVE_STEREO_REF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_WAVE_STEREO_REF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( !SUCCEEDED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstStereoWaveRefImage ) ) )
	{
		return E_FAIL;
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetCollectionImageIndex

HRESULT CDLSComponent::GetCollectionImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstCollectionImage;
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetCollectionRefImageIndex

HRESULT CDLSComponent::GetCollectionRefImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstCollectionRefImage;
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetArticulationImageIndex

HRESULT CDLSComponent::GetArticulationImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstArticulationImage;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetArticulationGrayedImageIndex

HRESULT CDLSComponent::GetArticulationGrayedImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstArticulationGrayedImage;
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetRegionImageIndex

HRESULT CDLSComponent::GetRegionImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstRegionImage;
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetRegionGrayedImageIndex

HRESULT CDLSComponent::GetRegionGrayedImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstRegionGrayedImage;
	
	return S_OK;
}


////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetWaveImageIndex

HRESULT CDLSComponent::GetWaveImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstWaveImage;
	
	return S_OK;
}


////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetStereoWaveImageIndex

HRESULT CDLSComponent::GetStereoWaveImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstStereoWaveImage;
	
	return S_OK;
}


////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetWaveRefImageIndex

HRESULT CDLSComponent::GetWaveRefImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstWaveRefImage;
	
	return S_OK;
}


////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetStereoWaveRefImageIndex

HRESULT CDLSComponent::GetStereoWaveRefImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstStereoWaveRefImage;
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetInstrumentImageIndex

HRESULT CDLSComponent::GetInstrumentImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstInstrumentImage;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetFolderImageIndex

HRESULT CDLSComponent::GetFolderImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstFolderImage;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::GetFolderImageIndex

HRESULT CDLSComponent::GetFolderGrayedImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pnFirstImage = m_nFirstFolderGrayedImage;
	
	return S_OK;
}


HRESULT CDLSComponent::OpenPort()
{
	HRESULT hr = E_FAIL;

	hr = m_pIFramework->GetSharedObject(CLSID_DirectMusic,IID_IDirectMusic,(void**) &m_pIDirectMusic);
	if (FAILED(hr))
	{
		AfxMessageBox(IDS_ERR_DM_FROM_FRAMEWORK,MB_OK | MB_ICONEXCLAMATION);
		return E_FAIL;
	}

	hr = m_pIConductor->GetPerformanceEngine( (IUnknown**)&m_pIPerformance );
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}


	// Create our own private audio path (if necessary)
	if( m_pIAudioPath == NULL )
	{
		// TODO: Replace with code that duplicates the default performance audio path (Needs API work)
		if( FAILED( m_pIPerformance->CreateStandardAudioPath( DMUS_APATH_DYNAMIC_STEREO, 10, TRUE, &m_pIAudioPath ) ) )
		{
			// Only warn the user if we have any collections open
			if( !m_CollectionList.IsEmpty() )
			{
				AfxMessageBox(IDS_ERR_NO_PORT, MB_OK | MB_ICONEXCLAMATION);
			}

			return S_OK;
		}
	}

	// Now, see what PChannel 0 really maps to
	DWORD dwOutputPChannel;
	hr = m_pIAudioPath->ConvertPChannel( 0, &dwOutputPChannel );
	if( FAILED( hr ) )
	{
		// Only warn the user if we have any collections open
		if( !m_CollectionList.IsEmpty() )
		{
			AfxMessageBox(IDS_ERR_NO_PORT, MB_OK | MB_ICONEXCLAMATION);
		}

		return S_OK;
	}

	// Now, see what synth the audio path is using
	if( FAILED( m_pIPerformance->PChannelInfo( dwOutputPChannel, &m_pISynthPort, NULL, NULL ) ) )
	{
		// Only warn the user if we have any collections open
		if( !m_CollectionList.IsEmpty() )
		{
			AfxMessageBox(IDS_ERR_NO_PORT, MB_OK | MB_ICONEXCLAMATION);
		}

		return S_OK;
	}

	return hr;
}

HRESULT CDLSComponent::GetAppendValueForPort(IDirectMusicPortDownload *pPortDownload, DWORD* pdwAppendValue)
{
	if( pPortDownload == NULL )
		return E_POINTER;

	DWORD dwSamples = 0;
	WAVEFORMATEX waveFormat;
	
	// Fill the memory with invalid values so we can check 
	// if the structure was filled successfully by the synth
	FillMemory(&waveFormat, sizeof(waveFormat), 0xFF);

	DWORD dwFormatSize = sizeof(WAVEFORMATEX);
	DWORD dwBufferSize = 0;
	
	IDirectMusicPort* pIDirecMusicPort = NULL;
	if(FAILED(pPortDownload->QueryInterface(IID_IDirectMusicPort, (void**)&pIDirecMusicPort)))
	{
		return E_FAIL;
	}

	if(FAILED(pPortDownload->GetAppend(&dwSamples)) /*|| 
	   FAILED(pIDirecMusicPort->GetFormat(&waveFormat, &dwFormatSize, &dwBufferSize))||
	   waveFormat.wBitsPerSample == 0xFFFF*/)
	{
		pIDirecMusicPort->Release();
		*pdwAppendValue = 0;

		// When a collection is referenced in a segment this 
		// error message can come up thousands of times so we 
		// keep a flag to check if message this has been shown before
		if(m_bShowGetFormatErrorMessage)
			AfxMessageBox(IDS_ERR_GETFORMAT);
		
		m_bShowGetFormatErrorMessage = false;

		return E_FAIL;
	}
	pIDirecMusicPort->Release();

	// HACK HACK HACK!!! Temporary workaround a DMusic bug!!
	waveFormat.wBitsPerSample = 16;

	// Get the bytes
	*pdwAppendValue = (dwSamples * waveFormat.wBitsPerSample)/8; 

	// Reset the GetFormat error flag
	m_bShowGetFormatErrorMessage = true;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSComponent::UpdateDLSPortList

HRESULT CDLSComponent::UpdateDLSPortList( void )
{
	// Initialize hr to an error code.  If we find a DownloadPort, we will set it to S_OK
	HRESULT hr = E_FAIL;

	// Empty the existing m_lstDLSPortDownload
	while( !m_lstDLSPortDownload.IsEmpty() )
	{
		m_lstDLSPortDownload.RemoveHead()->Release();
	}

	bool fAddedDLSSynthPort = false;

	// Ensure m_pIPerformance is set
	ASSERT( m_pIPerformance );
	if( m_pIPerformance )
	{
		// Get a pointer to the default audio path
		IDirectMusicAudioPath *pDMAudioPath;
		if( SUCCEEDED( m_pIPerformance->GetDefaultAudioPath( &pDMAudioPath ) ) )
		{
			// Iterate through the default AudioPath's ports
			IDirectMusicPort *pDMPort;
			DMUS_PORTCAPS dmPortCaps;
			DWORD dwIndex = 0;
			while( S_OK == pDMAudioPath->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0, GUID_All_Objects, dwIndex, IID_IDirectMusicPort, (void **)&pDMPort ) )
			{
				// Verify we have a valid port pointer
				ASSERT( pDMPort );

				// Initialize the DMUS_PORTCAPS structure
				dmPortCaps.dwSize = sizeof(DMUS_PORTCAPS);

				// Try and get the capabilities of this port, and check if it supports DLS
				if( SUCCEEDED( pDMPort->GetCaps( &dmPortCaps ) )
				&&	(dmPortCaps.dwFlags & DMUS_PC_DLS) )
				{
					// Check if we can download to the port
					IDirectMusicPortDownload *pPortDownload = NULL;
					if( SUCCEEDED( pDMPort->QueryInterface( IID_IDirectMusicPortDownload, (void **)&pPortDownload ) ) )
					{
						if( pDMPort == m_pISynthPort )
						{
							fAddedDLSSynthPort = true;
						}

						// Port supports DLS - add it to our list
						m_lstDLSPortDownload.AddHead( pPortDownload );

						// Found a port - set hr to a Success code
						hr = S_OK;
					}
				}

				// Release the port
				pDMPort->Release();

				// Go on to the next port in the audio path
				dwIndex++;
			}

			// Release the Audiopath
			pDMAudioPath->Release();
		}
	}

	if( !fAddedDLSSynthPort )
	{
		// Initialize the DMUS_PORTCAPS structure
		DMUS_PORTCAPS dmPortCaps;
		dmPortCaps.dwSize = sizeof(DMUS_PORTCAPS);

		// Try and get the capabilities of this port, and check if it supports DLS
		if( SUCCEEDED( m_pISynthPort->GetCaps( &dmPortCaps ) )
		&&	(dmPortCaps.dwFlags & DMUS_PC_DLS) )
		{
			// Check if we can download to the port
			IDirectMusicPortDownload *pPortDownload = NULL;
			if( SUCCEEDED( m_pISynthPort->QueryInterface( IID_IDirectMusicPortDownload, (void **)&pPortDownload ) ) )
			{
				// Port supports DLS - add it to our list
				m_lstDLSPortDownload.AddHead( pPortDownload );

				// Found a port - set hr to a Success code
				hr = S_OK;
			}
		}
	}

	return hr;
}

HRESULT CDLSComponent::IsValidPatch(CInstrument* pValidateInstrument, 
									ULONG ulBank, 
									ULONG ulInstrument, 
									CCollection* pLoadingCollection, 
									CInstrument** ppInstrumentCollision)
{
	bool						bValid=true;
	HRESULT						hr = DLS_ERR_FIRST;
	
	*ppInstrumentCollision = NULL;
	
	// First check if is GM/GS
	if ( IsGM(ulBank, ulInstrument) )
	{
		hr |= SC_PATCH_DUP_GM;
	}

	CCollection* pCollection = m_CollectionList.GetHead();
	while (pCollection && bValid)
	{
		CInstrument* pInstrument = pCollection->m_Instruments.GetHead();
		while(pInstrument) // for each instrument
		{	//compare
			if (pInstrument != pValidateInstrument
				&&(pInstrument->m_rInstHeader.Locale.ulBank & 0x80007F7F) == (ulBank & 0x80007F7F)
			    &&(pInstrument->m_rInstHeader.Locale.ulInstrument & 0x0000007F) == (ulInstrument & 0x00007F7F) )
			{
				// If pLoadingCollection was passed in we need to validate across collections
				// so don't set bValid = false just yet.
				if (!pLoadingCollection)
					bValid = false;
				*ppInstrumentCollision = pInstrument;
				if ( pCollection == pLoadingCollection )
				{
					hr |= SC_PATCH_DUP_COLLECTION;
				}
				else
				{
					hr |= SC_PATCH_DUP_SYNTH;
				}
				//to limit the search: once we establish that both types of collision exist we can stop
				if ( (hr & (SC_PATCH_DUP_COLLECTION | SC_PATCH_DUP_SYNTH)) == (SC_PATCH_DUP_COLLECTION | SC_PATCH_DUP_SYNTH) ) 
				{
					bValid = false;
				}
				break;
			}
			pInstrument = pInstrument->GetNext();
		}
		pCollection =  pCollection->GetNext();
	}
	if (DLS_ERR_FIRST == hr)
		hr = S_OK;
	return hr;
}

HRESULT CDLSComponent::GetNextValidPatch(DWORD dwDrum, BYTE* pWMSB, BYTE* pWLSB, BYTE* pWPatch)
{
	ASSERT(pWMSB != NULL);
	ASSERT(pWLSB != NULL);
	ASSERT(pWPatch != NULL);

	UINT	uMSB, uLSB, uPatch;
	int		x, y, z; //counters
	HRESULT		hr;
	CInstrument*				pDummy;
	bool						bFound = false;

	uMSB = *pWMSB;

	for (x = 0; x < 128; x++)
	{
		for (y = 0, uLSB = *pWLSB; y < 128; y++)
		{
			for (z = 0, uPatch = *pWPatch; z < 128; z++)
			{
				hr = IsValidPatch(NULL, MAKE_BANK(dwDrum, uMSB + x, uLSB + y), uPatch + z , NULL, &pDummy);
				if (SUCCEEDED(hr))
				{
					*pWMSB = uMSB + x;
					*pWLSB = uLSB + y;
					*pWPatch = uPatch + z;
					return S_OK;
				}
				else
				{
					if ((uPatch + z) == 127)
					{
						uPatch = (UINT) -z - 1;
					}
				}
			}
			if ((uLSB + y) == 127)
			{
				uLSB = (UINT)  -y - 1;
			}
		}
		if ((uMSB + x) == 127)
		{
			uMSB = (UINT) -x - 1;
		}
	}
	return E_FAIL;
}

bool CDLSComponent::IsGM(DWORD dwBank, DWORD dwInstrument)
{
	BYTE	bMSB, bLSB, bPatch;

	bMSB = (BYTE) ((dwBank & 0x00007F00) >> 8);
	bLSB = (BYTE) (dwBank & 0x0000007F);
	bPatch = (BYTE) (dwInstrument & 0x0000007F);
	
	if (bLSB != 0) return false;

	if ( (bMSB == 0) ) // && (bLSB == 0) 
	{
		if ((dwBank & 0x80000000)) //Drum Kit
		{
			if ((bPatch == 0x0)  ||
				(bPatch == 0x08) ||
				(bPatch == 0x10) ||
				(bPatch == 0x18) ||
				(bPatch == 0x19) ||
				(bPatch == 0x20) ||
				(bPatch == 0x28) ||
				(bPatch == 0x30) || 
				(bPatch == 0x38) )
			{
				return  true;
			}
			else
				return false;
		}
		else return true;//is GM
	}
	// check for GS
	switch (bMSB)
	{
		case 6:
		case 7:
			if (bPatch == 0x7D) return true;
			break;
		case 24:
			if ((bPatch == 0x04) || (bPatch == 0x06)) return true;
			break;
		case 9:
			if ((bPatch == 0x0E) || (bPatch == 0x76) || (bPatch == 0x7D)) return true;
			break;
		case 2:
			if ( (bPatch == 0x66) || (bPatch == 0x78) || ((bPatch > 0x79)&&(bPatch < 0x80) )) return true;
			break;
		case 3:
			if ((bPatch > 0x79) && (bPatch < 0x80)) return true;
			break;
		case 4:
		case 5:
			if ( (bPatch == 0x7A) || ((bPatch > 0x7B)&&(bPatch < 0x7F) )) return true;
			break;
		case 32:
			if ((bPatch == 0x10) ||
				(bPatch == 0x11) ||
				(bPatch == 0x18) ||
				(bPatch == 0x34) ) return true;
			break;
		case 1:
			if ((bPatch == 0x26) ||
				(bPatch == 0x39) ||
				(bPatch == 0x3C) ||
				(bPatch == 0x50) ||
				(bPatch == 0x51) ||
				(bPatch == 0x62) ||
				(bPatch == 0x66) ||
				(bPatch == 0x68) ||
				((bPatch > 0x77) && (bPatch < 0x80))) return true;
				break;
		case 16:
			switch (bPatch)
			{
				case 0x00:
					return true;
					break;
				case 0x04:
					return true;
					break;
				case 0x05:
					return true;
					break;
				case 0x06:
					return true;
					break;
				case 0x10:
					return true;
					break;
				case 0x13:
					return true;
					break;
				case 0x18:
					return true;
					break;
				case 0x19:
					return true;
					break;
				case 0x1C:
					return true;
					break;
				case 0x27:
					return true;
					break;
				case 0x3E:
					return true;
					break;
				case 0x3F:
					return true;
					break;
				default:
					return false;
			}
			break;
		case 8:
			if ((bPatch < 0x07) || ((bPatch == 0x7D)))
			{
				return true;
			}
			else if ((bPatch > 0x3F) && (bPatch < 0x50))
			{
				return false;
			}
			else if ((bPatch > 0x4F) && (bPatch < 0x72)  )
			{
				if ((bPatch == 0x50) || 
					(bPatch == 0x51) ||
					(bPatch == 0x6B))
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x1F) && (bPatch < 0x40))
			{
				if ((bPatch > 0x25) && (bPatch < 0x29) ||
					(bPatch > 0x3C)  ||
					(bPatch == 0x30) || 
					(bPatch == 0x32) )
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x0A) && (bPatch < 0x12) && 
				     (bPatch != 0x0D) && (bPatch != 0x0F))
			{
				return true;
			}
			else if ((bPatch > 0x0F) && (bPatch < 0x20))
			{
				if (bPatch > 0x17)
				{
					return true;
				}
				else if ( (bPatch == 0x13) || (bPatch == 0x15) )
					return true;
				else
					return false;
			}
			break;
		default:
			return false;
	}
	return false;
}

void CDLSComponent::NotifyDummyInstruments()
{
	CCollection* pCollection = m_CollectionList.GetHead();
	while (pCollection)
	{
		CWaveNode* pWaveNode = pCollection->m_Waves.GetHead();
		while(pWaveNode)
		{
			CWave* pWave = pWaveNode->GetWave();
			ASSERT(pWave);
			if (pWave)
			{
				pWave->ValidateDummyPatch();
			}
			pWaveNode = pWaveNode->GetNext();
		}
		pCollection = pCollection->GetNext();
	}
}

HRESULT CDLSComponent::GetNextValidDummyPatch(CInstrument* pDummy, BYTE* pWMSB, BYTE* pWLSB, BYTE* pWPatch)
{
	ASSERT(pWMSB != NULL);
	ASSERT(pWLSB != NULL);
	ASSERT(pWPatch != NULL);

	UINT	uMSB, uLSB, uPatch;
	int		x, y, z; //counters
	HRESULT		hr;
	bool						bFound = false;

	uMSB = m_bDummyMSB;

	for (x = 0; x < 128; x++)
	{
		for (y = 0, uLSB = m_bDummyLSB; y < 128; y++)
		{
			for (z = 0, uPatch = m_bDummyPatch; z < 128; z++)
			{
				hr = IsValidDummyPatch(pDummy, MAKE_BANK(0, uMSB - x, uLSB - y), uPatch - z);
				if (SUCCEEDED(hr))
				{
					m_bDummyMSB = *pWMSB = uMSB - x;
					m_bDummyLSB = *pWLSB = uLSB - y;
					*pWPatch = uPatch - z;
					return S_OK;
				}
				else
				{
					if ((uPatch - z) == 0)
					{
						uPatch = (UINT) 126 + z;
					}
				}
			}
			if ((uLSB + y) == 0)
			{
				uLSB = (UINT)  126 + z;
			}
		}
		if ((uMSB + x) == 0)
		{
			uMSB = (UINT) 126 + z;
		}
	}
	return E_FAIL;
}

HRESULT CDLSComponent::IsValidDummyPatch(CInstrument* pValidateInstrument, ULONG ulBank, ULONG ulInstrument)
{
	CInstrument* pDummy = NULL;
	CWaveNode* pWaveNode = NULL;

	HRESULT hr = IsValidPatch(pValidateInstrument, ulBank, ulInstrument, NULL, &pDummy);
	if (!SUCCEEDED(hr))
	{
		return E_FAIL;
	}

	// Get the mono waves for the independent waves as well
	CPtrList wavesInProject;
	if(FAILED(GetListOfWaves(&wavesInProject)))
	{
		return E_FAIL;
	}

	if(!m_CollectionList.IsEmpty())
	{
		CCollection* pCollection = m_CollectionList.GetHead();
		while (pCollection)
		{
			CPtrList wavesInCollection;
			if(FAILED(pCollection->m_Waves.GetListOfWaves(&wavesInCollection)))
			{
				return E_FAIL;
			}

			// Merge the two lists
			CPtrList waveList;
			waveList.AddTail(&wavesInProject);
			waveList.AddTail(&wavesInCollection);
			
			if(FAILED(ValidateWaveDummyInstruments(&waveList, pValidateInstrument, ulBank, ulInstrument)))
			{
				return E_FAIL;
			}

			waveList.RemoveAll();

			pCollection = pCollection->GetNext();
		}
	}
	else
	{
		if(FAILED(ValidateWaveDummyInstruments(&wavesInProject, pValidateInstrument, ulBank, ulInstrument)))
		{
			return E_FAIL;
		}
	}

	return S_OK;
}

HRESULT CDLSComponent::ValidateWaveDummyInstruments(CPtrList* pWaveList, CInstrument* pValidateInstrument, ULONG ulBank, ULONG ulInstrument)
{
	ASSERT(pValidateInstrument);
	if(pValidateInstrument == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pWaveList);
	if(pWaveList == NULL)
	{
		return E_POINTER;
	}

	POSITION position = pWaveList->GetHeadPosition();
	while(position)
	{
		CMonoWave* pWave = (CMonoWave*) pWaveList->GetNext(position);
		if(pWave)
		{
			CInstrument* pDummy = pWave->GetDummyInstrument();
			if (pDummy && pDummy != pValidateInstrument)
			{
				if( (pDummy->m_rInstHeader.Locale.ulBank & 0x80007F7F) == (ulBank & 0x80007F7F)
					&& (pDummy->m_rInstHeader.Locale.ulInstrument & 0x0000007F) == (ulInstrument & 0x00007F7F) )
				{
					return E_FAIL;
				}
			}	
		}
	}

	return S_OK;
}


// A version of PlayMIDIEvent that lets you specifiy the PChannel.
// needed so that auditioning stuff with the DLS designer won't interfere
// with the rest of producer.
HRESULT CDLSComponent::PlayMIDIEvent(BYTE bStatus, BYTE bData1, BYTE bData2, DWORD dwTime, bool bIsDrum)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// We're in the process of shutting down and performance has probably gone away...
	// Don't do anything now...
	if(m_bInCleanup)
	{
		return S_OK;
	}

	ASSERT( m_pIPerformance != NULL );
	ASSERT( m_pIAudioPath != NULL );
	if( (m_pIPerformance == NULL)
	||	(m_pIAudioPath == NULL) )
	{
		return E_UNEXPECTED;
	}

	HRESULT hr;
	DMUS_PMSG *pPipelineEvent = NULL;

	DMUS_MIDI_PMSG *pDMMidiEvent = NULL;
	hr = m_pIPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG**)&pDMMidiEvent );
	if ( FAILED(hr) )
	{
		return hr;
	}
	memset( pDMMidiEvent, 0, sizeof(DMUS_MIDI_PMSG) );

	pDMMidiEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
	pDMMidiEvent->bStatus = bStatus;
	pDMMidiEvent->bByte1 = bData1;
	pDMMidiEvent->bByte2 = bData2;
	if ( dwTime == 0 )
	{
		//pDMMidiEvent->m_rtTime = 0;
	}
	else
	{
		REFERENCE_TIME rtNow;
		m_pIPerformance->GetLatencyTime( &rtNow );
		pDMMidiEvent->rtTime = dwTime * 10000 + rtNow;
	}
	pDMMidiEvent->dwFlags = DMUS_PMSGF_REFTIME;
	pDMMidiEvent->dwPChannel = bIsDrum ? 9 : 0;
	pDMMidiEvent->dwVirtualTrackID = 1;
	pDMMidiEvent->dwType = DMUS_PMSGT_MIDI;
	pPipelineEvent = (DMUS_PMSG*) pDMMidiEvent;

	IDirectMusicGraph* pGraph;
	if( SUCCEEDED( m_pIAudioPath->QueryInterface( IID_IDirectMusicGraph, (void **)&pGraph ) ) )
	{
		pGraph->StampPMsg( pPipelineEvent );
		pGraph->Release();
	}

	return m_pIPerformance->SendPMsg( pPipelineEvent );
}


// Applies the SnapToZero selection for all the waves
void CDLSComponent::SetSnapToZero(BOOL bSnapToZero)
{
	m_bSnapToZero = bSnapToZero;
}


BOOL CDLSComponent::IsSnapToZero()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return m_bSnapToZero;
}


void CDLSComponent::InitSnapToZero()
{
	m_bSnapToZero = TRUE;
	DWORD dwType = 0;
	DWORD dwSize = 0;
	CString sValueName = "SnapToZero";
	ReadFromRegistry((TCHAR*)((LPCSTR)sValueName), &dwType, &dwSize, (BYTE*)&m_bSnapToZero);
}

HRESULT	CDLSComponent::ReadFromRegistry(TCHAR* pszValueName, DWORD* pdwType, DWORD* pdwDataSize, BYTE* pbData, TCHAR* pszSubPath)
{
	ASSERT(pbData);
	if(pbData == NULL)
	{
		return E_FAIL;
	}

	TCHAR szComponentPath[MAX_PATH];
	TCHAR szValueName[MAX_PATH];
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\DLSDesigner\\"));
	if(pszSubPath != NULL)
	{
		_tcscat(szComponentPath, pszSubPath);
	}
	
	HRESULT hr = E_FAIL;
	HKEY	hkeyOpen;
	if(::RegOpenKeyEx(HKEY_CURRENT_USER, szComponentPath, 0, KEY_READ, &hkeyOpen) == ERROR_SUCCESS)
	{
		if(::RegQueryValueEx(hkeyOpen, szValueName, 0, pdwType, pbData, pdwDataSize) == ERROR_SUCCESS)
		{
			hr = S_OK;
		}

		::RegCloseKey(hkeyOpen);
	}

	return hr;
}


void CDLSComponent::InitQueryList()
{
	// Delete all previous queries if there are any...
	while(!m_lstDLSQueries.IsEmpty())
	{
		delete m_lstDLSQueries.RemoveHead();
	}

	TCHAR szComponentPath[MAX_PATH];
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\DLSDesigner\\Queries\\"));

	HKEY	hkeyOpen;
	TCHAR	szGuid[100];
	DWORD	dwSize = sizeof(TCHAR) * 100;
	DWORD	dwIndex = 0;
	TCHAR	szQueryName[MAX_PATH];
	DWORD	dwType = 0;
	DWORD	dwDataSize = MAX_PATH;
	
	if(::RegOpenKeyEx(HKEY_CURRENT_USER, szComponentPath, 0, KEY_READ, &hkeyOpen) == ERROR_SUCCESS)
	{
		while(::RegEnumValue(hkeyOpen, dwIndex, szGuid, &dwSize, NULL, &dwType, (BYTE*)(szQueryName), &dwDataSize) != ERROR_NO_MORE_ITEMS)
		{
			GUID guidQuery;
			WCHAR szWChar[100];
			ZeroMemory( szWChar, 100 * sizeof( WCHAR ) );
			::MultiByteToWideChar( CP_ACP, 0, szGuid, -1, szWChar, 100 );
			if(SUCCEEDED(::IIDFromString(szWChar, &guidQuery)))
			{
				CDLSQuery* pDLSQuery = new CDLSQuery(guidQuery, szQueryName);
				if(pDLSQuery)
				{
					m_lstDLSQueries.AddTail(pDLSQuery);
				}
			}
			
			dwIndex++;
			dwSize = sizeof(TCHAR) * 100;
			dwDataSize = MAX_PATH;
		}

		::RegCloseKey(hkeyOpen);
	}
	
	
}


BOOL CDLSComponent::IsInReferenceLoad()
{
	return m_bInReferencedLoad;
}


void CDLSComponent::AddToFailedCollectionGUIDs(GUID collectionGUID)
{
	// Search to see if we already have this GUID in the list; don't add it again if it does
	if(FindCollectionGUID(collectionGUID) == NULL)
	{
		CCollectionGUIDItem* pGUIDItem = new CCollectionGUIDItem(collectionGUID);
		m_lstFailedCollectionGUIDs.AddTail(pGUIDItem);
	}
}

void CDLSComponent::DeleteFromFailedCollectionGUIDs(GUID collectionGUID)
{
	POSITION position = m_lstFailedCollectionGUIDs.GetHeadPosition();
	while(position)
	{
		POSITION oldPosition = position;
		CCollectionGUIDItem* pGUIDItem = (CCollectionGUIDItem*) m_lstFailedCollectionGUIDs.GetNext(position);
		ASSERT(pGUIDItem);
		if(::IsEqualGUID(pGUIDItem->m_CollectionGUID, collectionGUID))
		{
			m_lstFailedCollectionGUIDs.RemoveAt(oldPosition);
			delete pGUIDItem;
		}
	}
}

CCollectionGUIDItem* CDLSComponent::FindCollectionGUID(GUID searchGUID)
{
	
	POSITION position = m_lstFailedCollectionGUIDs.GetHeadPosition();
	while(position)
	{
		CCollectionGUIDItem* pGUIDItem = (CCollectionGUIDItem*) m_lstFailedCollectionGUIDs.GetNext(position);
		ASSERT(pGUIDItem);
		if(::IsEqualGUID(pGUIDItem->m_CollectionGUID, searchGUID))
			return pGUIDItem;
	}

	return NULL;
}

void CDLSComponent::DeleteGUIDList()
{
	while(!m_lstFailedCollectionGUIDs.IsEmpty())
	{
		CCollectionGUIDItem* pGUIDItem = (CCollectionGUIDItem*) m_lstFailedCollectionGUIDs.RemoveHead();
		if(pGUIDItem)
		{
			delete pGUIDItem;
		}
	}
}

void CDLSComponent::DeleteQueryList()
{
	while(!m_lstDLSQueries.IsEmpty())
	{
		CDLSQuery* pDLSQuery = (CDLSQuery*) m_lstDLSQueries.RemoveHead();
		if(pDLSQuery)
		{
			delete pDLSQuery;
		}
	}
}


void CDLSComponent::DeleteConfigList()
{
	while(!m_lstConfigurations.IsEmpty())
	{
		delete m_lstConfigurations.RemoveHead();
	}
}

void CDLSComponent::GetPortName(IDirectMusicPortDownload* pIDMDownloadPort, CString& sPortName)
{
	sPortName = "Unknown";
	ASSERT(pIDMDownloadPort);
	if(pIDMDownloadPort == NULL)
		return;

	DMUS_PORTCAPS portCaps;
	ZeroMemory(&portCaps, sizeof(DMUS_PORTCAPS));
	portCaps.dwSize = sizeof(DMUS_PORTCAPS);

	IDirectMusicPort* pIDMPort = NULL;
	if(SUCCEEDED(pIDMDownloadPort->QueryInterface(IID_IDirectMusicPort, (void**) &pIDMPort)))
	{
		if(SUCCEEDED(pIDMPort->GetCaps(&portCaps)))
		{
			sPortName = portCaps.wszDescription;
		}
		pIDMPort->Release();
	}
	return;
}

void CDLSComponent::AddToCollectionList(CCollection* pCollection)
{
	ASSERT(pCollection);
	if(pCollection == NULL)
		return;

	// Check first if this node is already in the list
	if(IsInCollectionList(pCollection) == true)
		return;

	// Get the Collection's GUID
	GUID guidCollection;
	pCollection->GetGUID( &guidCollection );

	// Prevent duplicate GUIDs
	GUID guidCollectionList;
	CCollection* pCollectionInList = m_CollectionList.GetHead();
	while(pCollectionInList)
	{
		pCollectionInList->GetGUID( &guidCollectionList );
		if( ::IsEqualGUID( guidCollectionList, guidCollection ) )
		{
			::CoCreateGuid( &guidCollection );
			pCollection->SetGUID( guidCollection );
			break;
		}
		pCollectionInList = pCollectionInList->GetNext();
	}

	// Add it to the list
	pCollection->AddRef();
	m_CollectionList.AddTail(pCollection);
}

void CDLSComponent::DeleteFromCollectionList(CCollection* pCollection)
{
	ASSERT(pCollection);
	if(pCollection == NULL)
		return;

	// Remove this collection from the list if it's in there...
	if(IsInCollectionList(pCollection) == true)
	{
		m_CollectionList.Remove(pCollection);
		pCollection->Release();
	}
}

bool CDLSComponent::IsInCollectionList(CCollection* pCollection)
{
	ASSERT(pCollection);
	if(pCollection == NULL)
		return false;

	CCollection* pCollectionInList = m_CollectionList.GetHead();
	while(pCollectionInList)
	{
		if(pCollectionInList == pCollection)
		{
			return true;
		}

		pCollectionInList = pCollectionInList->GetNext();
	}

	return false;
}

void CDLSComponent::AddToWaveNodesList(CWaveNode* pWaveNode)
{
	ASSERT(pWaveNode);
	if(pWaveNode == NULL)
		return;

	// Check first if this node is already in the list
	if(IsInWaveNodesList(pWaveNode) == true)
		return;

	GUID guid = pWaveNode->GetFileGUID();
	pWaveNode->SetFileGUID(guid);

	// AddRef the node
	pWaveNode->AddRef();

	// Add it to the list
	m_lstWaveNodes.AddTail(pWaveNode);
}


void CDLSComponent::DeleteFromWaveNodesList(CWaveNode* pWaveNode)
{
	ASSERT(pWaveNode);
	if(pWaveNode == NULL)
		return;

	POSITION position = m_lstWaveNodes.GetHeadPosition();
	while(position)
	{
		POSITION nodePosition = position;
		CWaveNode* pWaveNodeInList = (CWaveNode*) m_lstWaveNodes.GetNext(position);
		ASSERT(pWaveNodeInList);
		if(pWaveNodeInList == pWaveNode)
		{
			m_lstWaveNodes.RemoveAt(nodePosition);
			pWaveNode->Release();
			return;
		}
	}

	// We didn't find the node?
	return;
}


bool CDLSComponent::IsInWaveNodesList(CWaveNode* pWaveNode)
{
	ASSERT(pWaveNode);
	if(pWaveNode == NULL)
		return false;

	POSITION position = m_lstWaveNodes.GetHeadPosition();
	while(position)
	{
		CWaveNode* pWaveNodeInList = (CWaveNode*) m_lstWaveNodes.GetNext(position);
		ASSERT(pWaveNodeInList);
		if(pWaveNodeInList == pWaveNode)
		{
			return true;
		}
	}

	return false;
}


bool CDLSComponent::IsInWaveNodesList(GUID guidFile)
{
	POSITION position = m_lstWaveNodes.GetHeadPosition();
	while(position)
	{
		CWaveNode* pWaveNodeInList = (CWaveNode*) m_lstWaveNodes.GetNext(position);
		ASSERT(pWaveNodeInList);
		if(pWaveNodeInList)
		{
			if(::IsEqualGUID(pWaveNodeInList->GetFileGUID(), guidFile))
			{
				return true;
			}
		}
	}

	return false;

}

HRESULT CDLSComponent::GetListOfWaves(CPtrList* pWaveList)
{
	ASSERT(pWaveList);
	if(pWaveList == NULL)
		return E_POINTER;

	POSITION position = m_lstWaveNodes.GetHeadPosition();
	while(position)
	{
		CWaveNode* pWaveNode = (CWaveNode*) m_lstWaveNodes.GetNext(position);
		ASSERT(pWaveNode);
		if(pWaveNode)
		{
			CWave* pWave = pWaveNode->GetWave();
			ASSERT(pWave);
			if(pWave)
			{
				pWaveList->AddTail(pWave);
			}
		}
	}

	return S_OK;
}



BOOL CDLSComponent::IsAPresetQuery(const CString sQueryName, GUID& guidQuery)
{
	POSITION position = m_lstDLSQueries.GetHeadPosition();
	while(position)
	{
		CDLSQuery* pQuery = (CDLSQuery*) m_lstDLSQueries.GetNext(position);
		if(pQuery)
		{
			if(sQueryName.CompareNoCase(pQuery->GetName()) == 0)
			{
				guidQuery = pQuery->GetGUID();
				return TRUE;
			}
		}
	}

	return FALSE;
}

BOOL CDLSComponent::IsAPresetQuery(const GUID guidQuery, CString& sQueryName )
{
	POSITION position = m_lstDLSQueries.GetHeadPosition();
	while(position)
	{
		CDLSQuery* pQuery = (CDLSQuery*) m_lstDLSQueries.GetNext(position);
		if(pQuery)
		{
			if(::IsEqualIID(pQuery->GetGUID(), guidQuery))
			{
				sQueryName = pQuery->GetName();
				return TRUE;
			}
		}
	}

	return FALSE;
}

const CPtrList& CDLSComponent::GetListOfQueries()
{
	return m_lstDLSQueries;
}

CDLSQuery* CDLSComponent::GetDLSQuery(const GUID& guidQuery)
{
	POSITION position = m_lstDLSQueries.GetHeadPosition();
	while(position)
	{
		CDLSQuery* pQuery = (CDLSQuery*) m_lstDLSQueries.GetNext(position);
		if(pQuery)
		{
			if(::IsEqualIID(pQuery->GetGUID(), guidQuery))
			{
				return pQuery;
			}
		}
	}

	return NULL;
}

void CDLSComponent::WriteQueryToRegistryAndAddToList(CDLSQuery* pDLSQuery)
{
	ASSERT(pDLSQuery);
	if(pDLSQuery == NULL)
		return;

	WriteQueryToRegistry(pDLSQuery->GetGUID(), pDLSQuery->GetName());
	m_lstDLSQueries.AddTail(pDLSQuery);
}


void CDLSComponent::RefreshConfigToolbar()
{
	if(m_pConditionConfigToolbar)
	{
		m_pConditionConfigToolbar->RefreshConfigCombo(&m_lstConfigurations);
	}
}

void CDLSComponent::OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode)
{
	ASSERT(pCurrentConfig);
	if(pCurrentConfig == NULL)
	{
		return;
	}

	CCollection* pCollection = m_CollectionList.GetHead();
	while(pCollection)
	{
		pCollection->OnConditionConfigChanged(pCurrentConfig, bRefreshNode);
		pCollection = pCollection->GetNext();
	}
}

CSystemConfiguration* CDLSComponent::GetCurrentConfig()
{
//	ASSERT(m_pConditionConfigToolbar);
	if(m_pConditionConfigToolbar)
	{
		return m_pConditionConfigToolbar->GetCurrentConfig();
	}

	return NULL;
}



CSystemConfiguration* CDLSComponent::GetConfiguration(CString sConfigName)
{
	// Should never be empty...
	// We should create a configuration called "<None>" which has all values set to 0
	// and it always lives in the list till we die....
	if(m_lstConfigurations.IsEmpty())
	{
		return NULL;
	}

	POSITION position = m_lstConfigurations.GetHeadPosition();
	while(position)
	{
		CSystemConfiguration* pConfig = (CSystemConfiguration*) m_lstConfigurations.GetNext(position);
		ASSERT(pConfig);
		if(pConfig->GetName().CompareNoCase(sConfigName) == 0)
		{
			return pConfig;
		}
	}

	return NULL;
}

void CDLSComponent::DeleteConfiguration(CSystemConfiguration* pConfig)
{
	ASSERT(pConfig);
	if(pConfig == NULL || m_lstConfigurations.IsEmpty())
	{
		return;
	}
	
	POSITION position = m_lstConfigurations.Find(pConfig);
	if(position)
	{
		m_lstConfigurations.RemoveAt(position);
		delete pConfig;
	}
	
	UpdateConfigsInRegistry();
}

void CDLSComponent::AddConfiguration(CSystemConfiguration* pConfig)
{
	ASSERT(pConfig);
	if(pConfig == NULL)
	{
		return;
	}

	m_lstConfigurations.AddTail(pConfig);
	UpdateConfigsInRegistry();
}

void CDLSComponent::WriteConfigToRegistry(CSystemConfiguration* pConfig)
{
	ASSERT(pConfig);
	if(pConfig == NULL)
	{
		return;
	}

	// Create a key with the config name
	CString sSubPath = "Configs\\" + pConfig->GetName() + "\\";

	// Write all the query value pairs
	CPtrList& lstQueryValue = pConfig->GetQueryValueList();
	POSITION position = lstQueryValue.GetHeadPosition();
	while(position)
	{
		CQueryValuePair* pQueryValue = (CQueryValuePair*)lstQueryValue.GetNext(position);
		ASSERT(pQueryValue);
		if(pQueryValue)
		{
			CDLSQuery* pQuery = pQueryValue->GetQuery();
			ASSERT(pQuery);
			DWORD dwValue = pQueryValue->GetValue();
			GUID guidQuery = pQuery->GetGUID();
			LPOLESTR psz;
			if( SUCCEEDED( ::StringFromIID(guidQuery, &psz) ) )
			{
				TCHAR szGuid[100];
				WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
				CoTaskMemFree( psz );

				WriteToRegistry(szGuid, REG_DWORD, (BYTE*)(&dwValue), sizeof(DWORD), sSubPath.GetBuffer(0));
			}
		}
	}
}


void CDLSComponent::UpdateConfigsInRegistry()
{
	TCHAR szConfigsPath[MAX_PATH];
	_tcscpy( szConfigsPath, _T("Software\\Microsoft\\DMUSProducer\\DLSDesigner\\Configs\\"));

	HKEY hkeyOpen;
	if(::RegOpenKeyEx(HKEY_CURRENT_USER, szConfigsPath, 0, KEY_ALL_ACCESS, &hkeyOpen) == ERROR_SUCCESS)
	{
		if(SHDeleteKey(hkeyOpen, 0) != ERROR_SUCCESS)
		{
			::RegCloseKey(hkeyOpen);
			return;
		}
	}

	POSITION position = m_lstConfigurations.GetHeadPosition();
	while(position)
	{
		CSystemConfiguration* pConfig = (CSystemConfiguration*)m_lstConfigurations.GetNext(position);
		ASSERT(pConfig);
		if(pConfig && pConfig->IsDefault() == false)
		{
			WriteConfigToRegistry(pConfig);
		}
	}

	::RegCloseKey(hkeyOpen);
}

void CDLSComponent::LoadConfigurations()
{
	// Can't have configs when no queries defined
	ASSERT(m_lstDLSQueries.IsEmpty() == FALSE);

	// Delete all previous configurations if there are any....
	while(!m_lstConfigurations.IsEmpty())
	{
		delete m_lstConfigurations.RemoveHead();
	}

	if(m_pConditionConfigToolbar)
	{
		m_pConditionConfigToolbar->SetCurrentConfig(NULL);
	}

	TCHAR szComponentPath[MAX_PATH];
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\DLSDesigner\\Configs\\"));

	HKEY	hkeyOpen;

	DWORD	dwKeyIndex = 0;
	DWORD	dwValueIndex = 0;

	TCHAR	szKeyName[MAX_PATH];
	DWORD	dwKeySize = MAX_PATH;
	
	if(::RegOpenKeyEx(HKEY_CURRENT_USER, szComponentPath, 0, KEY_READ, &hkeyOpen) == ERROR_SUCCESS)
	{
		FILETIME fileTime;

		while(::RegEnumKeyEx(hkeyOpen, dwKeyIndex++, szKeyName, &dwKeySize, 0, NULL, NULL, &fileTime) != ERROR_NO_MORE_ITEMS)
		{
			HKEY hkeySubkey;
			if(::RegOpenKeyEx(hkeyOpen, szKeyName, 0, KEY_READ, &hkeySubkey) == ERROR_SUCCESS)
			{
				TCHAR	szGuid[100];
				DWORD	dwSize = sizeof(TCHAR) * 100;
				DWORD	dwValue = 0;
				DWORD	dwValueSize = sizeof(DWORD);
				DWORD	dwType = REG_DWORD;
				DWORD	dwIndex = 0;

				CSystemConfiguration* pConfig = new CSystemConfiguration();
				ASSERT(pConfig);
				if(pConfig == NULL)
				{
					// Out of memory!!
					::RegCloseKey(hkeySubkey);
					::RegCloseKey(hkeyOpen);
					return;
				}

				pConfig->SetName(szKeyName);
				m_lstConfigurations.AddTail(pConfig);

				while(::RegEnumValue(hkeySubkey, dwIndex++, szGuid, &dwSize, NULL, &dwType, (BYTE*)(&dwValue), &dwValueSize) != ERROR_NO_MORE_ITEMS)
				{
					GUID guidQuery;
					WCHAR szWChar[100];
					ZeroMemory(szWChar, 100 * sizeof( WCHAR ));
					::MultiByteToWideChar( CP_ACP, 0, szGuid, -1, szWChar, 100 );

					if(SUCCEEDED(::IIDFromString(szWChar, &guidQuery)))
					{
						CDLSQuery* pQuery = GetDLSQuery(guidQuery);
						if(pQuery)
						{	
							CQueryValuePair* pQueryValue = new CQueryValuePair(pQuery, dwValue);
							ASSERT(pQueryValue);
							if(pQueryValue)
							{
								pConfig->AddQueryValue(pQueryValue);
							}
						}
					}

					dwSize = sizeof(TCHAR) * 100;
					dwValueSize = sizeof(DWORD);
					dwValue = 0;
				}

				dwKeySize = MAX_PATH;
				::RegCloseKey(hkeySubkey);
			}
		}

		::RegCloseKey(hkeyOpen);
	}
}


void CDLSComponent::CreateDefaultConfigs()
{
	// Delete previous configs
	while(!m_lstDefaultConfigs.IsEmpty())
	{
		CSystemConfiguration* pConfig = m_lstDefaultConfigs.RemoveHead();
		ASSERT(pConfig);
		POSITION position = m_lstConfigurations.Find(pConfig);
		if(position)
		{
			m_lstConfigurations.RemoveAt(position);
			delete pConfig;
		}
	}
	
	// Add a None config
	CSystemConfiguration* pConfig = new CSystemConfiguration(true);
	if(pConfig)
	{
		CString sNone;
		sNone.LoadString(IDS_NONE);
		pConfig->SetName(sNone);
		m_lstConfigurations.AddTail(pConfig);
	}


	POSITION position = m_lstDLSPortDownload.GetHeadPosition();
	while(position)
	{
		IDirectMusicPortDownload* pPort = (IDirectMusicPortDownload*)m_lstDLSPortDownload.GetNext(position);
		ASSERT(pPort);
		if(pPort)
		{
			CSystemConfiguration* pConfig = GetConfigForPort(pPort);
			if(pConfig)
			{
				m_lstDefaultConfigs.AddTail(pConfig);
			}
		}
	}

	m_lstConfigurations.AddHead(&m_lstDefaultConfigs);

	// Refresh the toolbar
	RefreshConfigToolbar();
}

CSystemConfiguration* CDLSComponent::GetConfigForPort(IDirectMusicPortDownload* pPort)
{
	ASSERT(pPort);
	if(pPort == NULL)
	{
		return NULL;
	}

	// Query for the IKsControl interface
	IKsControl* pIControl = NULL;
	if(FAILED(pPort->QueryInterface(IID_IKsControl, (void**)&pIControl)))
	{
		return NULL;
	}

	// Get the port name
	IDirectMusicPort* pDMPort = NULL;
	if(FAILED(pPort->QueryInterface(IID_IDirectMusicPort, (void**)&pDMPort)))
	{
		pPort->Release();
		return NULL;
	}

	DMUS_PORTCAPS portCaps;
	ZeroMemory(&portCaps, sizeof(DMUS_PORTCAPS));
	portCaps.dwSize = sizeof(DMUS_PORTCAPS);
	pDMPort->GetCaps(&portCaps);
	CString sPortName = portCaps.wszDescription;

	// Go through all the DLS queries and make a configuration
	CSystemConfiguration* pConfig = new CSystemConfiguration(true);
	pConfig->SetName(sPortName);
	
	POSITION position = m_lstDLSQueries.GetHeadPosition();
	while(position)
	{
		CDLSQuery* pQuery = (CDLSQuery*) m_lstDLSQueries.GetNext(position);
		ASSERT(pQuery);
		if(pQuery)
		{
			DWORD cb = 0;
			DWORD dwFlags = 0;

			KSPROPERTY ksp;
			ksp.Set = pQuery->GetGUID();
			ksp.Id = 0;
			ksp.Flags = KSPROPERTY_TYPE_GET;

			HRESULT hr = pIControl->KsProperty(&ksp, sizeof(ksp), &dwFlags, sizeof(dwFlags), &cb);
			if(SUCCEEDED(hr) || (cb >= sizeof(dwFlags)))
			{
				CQueryValuePair* pQueryValue = new CQueryValuePair(pQuery, (BOOL)dwFlags);
				if(pQueryValue)
				{
					pConfig->AddQueryValue(pQueryValue);
				}
			}
		}
	}

	pDMPort->Release();
	pIControl->Release();

	return pConfig;
}


void CDLSComponent::ExportConfigurations(CString sPath)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString sConfigFileName;
	sConfigFileName.LoadString(IDS_CONFIG_REG);
	
	// Append the name to the path
	sConfigFileName = sPath + "\\" + sConfigFileName;

	TCHAR szComponentPath[MAX_PATH];
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\DLSDesigner\\"));

	HKEY hkeyOpen;
	if(::RegOpenKeyEx(HKEY_CURRENT_USER, szComponentPath, 0, KEY_ALL_ACCESS, &hkeyOpen) == ERROR_SUCCESS)
	{
		HANDLE hProcess = GetCurrentProcess();
		if(hProcess)
		{
			HANDLE hAccessToken;
			if(OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hAccessToken))
			{
				if(SetPrivilege(hAccessToken, SE_BACKUP_NAME, TRUE))
				{
					// Check if the file exists and if it does, delete it so we can save the new one
					DeleteFile(sConfigFileName);

					LONG lResult = ::RegSaveKey(hkeyOpen, sConfigFileName, NULL);
					if(lResult == ERROR_SUCCESS)
					{
						AfxMessageBox(IDS_CONFIG_EXPORT_SUCCESS);
						BSTR bstrFileName = sConfigFileName.AllocSysString();
						ASSERT(m_pIFramework);
						if(m_pIFramework)
						{
							m_pIFramework->ShowFile(bstrFileName);
						}
					}
					else
					{
						CString sErrorMessage;
						sErrorMessage.LoadString(IDS_CONFIG_EXPORT_FAILURE);
						LPVOID lpvError;
						FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM , NULL, lResult, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpvError, 0, NULL);
						CString sDetails;
						sDetails.Format("\n%s", (LPCSTR)lpvError);
						sErrorMessage += sDetails;

						AfxMessageBox(sErrorMessage);
					}

					SetPrivilege(hAccessToken, SE_BACKUP_NAME, FALSE);
				}
			}

			TRACE("OpenThreadToken Failed...error: %u\n", GetLastError()); 
		}

		::RegCloseKey(hkeyOpen);
	}
	else
	{
		AfxMessageBox(IDS_CONFIG_EXPORT_FAILURE);
	}
}


void CDLSComponent::ImportConfigurations(CString sPath)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString sConfigFileName;
	sConfigFileName.LoadString(IDS_CONFIG_REG);
	
	// Append the name to the path
	sConfigFileName = sPath + "\\" + sConfigFileName;

	TCHAR szComponentPath[MAX_PATH];
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\DLSDesigner\\"));

	HKEY	hkeyOpen;
	LPDWORD	lpdwDisposition = NULL;
	if(::RegCreateKeyEx(HKEY_CURRENT_USER, szComponentPath, 0, 0, REG_OPTION_NON_VOLATILE, 
						KEY_ALL_ACCESS, NULL, &hkeyOpen, lpdwDisposition) == ERROR_SUCCESS)
	{
		HANDLE hProcess = GetCurrentProcess();
		if(hProcess)
		{
			HANDLE hAccessToken;
			if(OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hAccessToken))
			{
				if(SetPrivilege(hAccessToken, SE_RESTORE_NAME, TRUE))
				{
					LONG lResult = ::RegRestoreKey(hkeyOpen, sConfigFileName, NULL);
					
					if(lResult == ERROR_SUCCESS)
					{
						// Update the queries
						InitQueryList();

						// Update the configurations
						LoadConfigurations();

						// Recreate the default configs for ports
						CreateDefaultConfigs();

						// Set the first config as selected
						CSystemConfiguration* pConfig = (CSystemConfiguration*)m_lstConfigurations.GetHead();
						m_pConditionConfigToolbar->SetCurrentConfig(pConfig);

						// Refresh the toolbar
						RefreshConfigToolbar();

						AfxMessageBox(IDS_CONFIG_IMPORT_SUCCESS);
					}
					else
					{
						CString sErrorMessage;
						sErrorMessage.LoadString(IDS_CONFIG_IMPORT_FAILURE);
						LPVOID lpvError;
						FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM , NULL, lResult, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpvError, 0, NULL);
						CString sDetails;
						sDetails.Format("\n%s", (LPCSTR)lpvError);
						sErrorMessage += sDetails;

						AfxMessageBox(sErrorMessage);
					}

					SetPrivilege(hAccessToken, SE_RESTORE_NAME, FALSE);
				}
			}
		}
		
		::RegCloseKey(hkeyOpen);
	}
	else
	{
		AfxMessageBox(IDS_CONFIG_IMPORT_FAILURE);
	}

}


BOOL CDLSComponent::SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) 
{
	LUID luid;
	if(!LookupPrivilegeValue(NULL, lpszPrivilege, &luid)) 
	{      
		TRACE("LookupPrivilegeValue error: %u\n", GetLastError()); 
		return FALSE; 
	}

	TOKEN_PRIVILEGES tp;
	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	
	if(bEnablePrivilege)
	{
		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	}
	else
	{
		tp.Privileges[0].Attributes = 0;
	}

	// Enable the privilege or disable all privileges.
	AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL);
 
	// Call GetLastError to determine whether the function succeeded.
	if(GetLastError() != ERROR_SUCCESS) 
	{ 
		TRACE("AdjustTokenPrivileges failed: %u\n", GetLastError()); 
		return FALSE; 
	} 

	return TRUE;
}

HRESULT CDLSComponent::UpdateDLSDownloads()
{
	UnloadAllCollections();
	UnloadAllWaves();
	if(m_bAutoDownloadDLS)
	{
		DownloadAllWaves();
		DownloadAllCollections();
	}

	return S_OK;
}


void CDLSComponent::UnloadAllCollections()
{
	ASSERT(m_pIFramework);
	if(m_pIFramework == NULL)
	{
		return;
	}

	CCollection* pCollection = m_CollectionList.GetHead();
	while(pCollection)
	{
		pCollection->Unload();
		pCollection->ReleaseDMCollection();

		IDMUSProdNode* pIDocRootNode = NULL;
		if(FAILED(pCollection->GetDocRootNode(&pIDocRootNode)))
		{
			return;
		}

		m_pIFramework->NotifyNodes(pIDocRootNode, GUID_DMCollectionResync, NULL);
		pIDocRootNode->Release();
		
		pCollection = pCollection->GetNext();
	}
}

void CDLSComponent::DownloadAllCollections()
{
	CCollection* pCollection = m_CollectionList.GetHead();
	while(pCollection)
	{
		pCollection->Download();
		pCollection = pCollection->GetNext();
	}

}

void CDLSComponent::UnloadAllWaves()
{
	POSITION position = m_lstWaveNodes.GetHeadPosition();
	while(position)
	{
		CWaveNode* pWaveNode = (CWaveNode*) m_lstWaveNodes.GetNext(position);
		ASSERT(pWaveNode);
		if(pWaveNode)
		{
			pWaveNode->UnloadFromAllPorts();
		}
	}
}

void CDLSComponent::DownloadAllWaves()
{
	POSITION position = m_lstWaveNodes.GetHeadPosition();
	while(position)
	{
		CWaveNode* pWaveNode = (CWaveNode*) m_lstWaveNodes.GetNext(position);
		ASSERT(pWaveNode);
		if(pWaveNode)
		{
			pWaveNode->InitAndDownload();
		}
	}
}

BOOL CDLSComponent::IsAutoDownloadOkay()
{
	return m_bAutoDownloadDLS;
}

BOOL CDLSComponent::IsCollectionDownloadOK()
{
	return m_bDownloadCollection;
}


void CDLSComponent::SetCollectionPatchConflict(bool bShow)
{
	m_bNoShowCollectionPatchConflict = bShow;
}

bool CDLSComponent::IsNoShowCollectionPatchConflict()
{
	return m_bNoShowCollectionPatchConflict;
}

void CDLSComponent::SetUserPatchConflict(bool bShow)
{
	m_bNoShowUserPatchConflict = bShow;
}

bool CDLSComponent::IsNoShowUserPatchConflict()
{
	return m_bNoShowUserPatchConflict;
}

#ifdef DMP_XBOX
void CDLSComponent::SetBadXboxLoopWarning(bool bShow)
{
	m_bNoShowBadXboxLoopWarning = bShow;
}

bool CDLSComponent::IsNoShowBadXboxLoopWarning()
{
	return m_bNoShowBadXboxLoopWarning;
}
#endif // DMP_XBOX

BOOL CDLSComponent::IsLongLoopsOK()
{
	return m_bLongLoopOK;
}

void CDLSComponent::SetLongLoopOK(BOOL bLongLoopOK)
{
	m_bLongLoopOK = bLongLoopOK;
}


void CDLSComponent::AddToFailedCodecs(DWORD dwCodec)
{
	if(IsInFailedCodecs(dwCodec) == FALSE)
	{
		m_lstFailedCodecs.AddTail(dwCodec);
	}
}

BOOL CDLSComponent::IsInFailedCodecs(DWORD dwCodec)
{
	POSITION position = m_lstFailedCodecs.GetHeadPosition();
	while(position)
	{
		DWORD dwFailedCodec = m_lstFailedCodecs.GetNext(position);
		if(dwFailedCodec == dwCodec)
		{
			return TRUE;
		}
	}

	return FALSE;
}

void CDLSComponent::RemoveFromFailedCodecs(DWORD dwCodec)
{
	if(IsInFailedCodecs(dwCodec))
	{
		POSITION position = m_lstFailedCodecs.Find(dwCodec);
		m_lstFailedCodecs.RemoveAt(position);
	}
}

void CDLSComponent::ClearFailedCodecs()
{
	while(m_lstFailedCodecs.IsEmpty() == FALSE)
	{
		m_lstFailedCodecs.RemoveHead();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSDesignerDLL.cpp ===
// DLSDesigner.cpp : Implementation of CDLSDesignerApp and DLL registration.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "DLSComponent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CDLSDesignerApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xbc964e83, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CDLSDesignerApp::InitInstance - DLL initialization

BOOL CDLSDesignerApp::InitInstance()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxEnableControlContainer();
	BOOL bInit = COleControlModule::InitInstance();
	
	if (bInit)
	{
		m_pFramework = NULL;
	}

	m_pClipboardObject = NULL;
	m_pIClipboardDataObject = NULL;
	m_hKeyProgressBar = NULL;

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CDLSDesignerApp::ExitInstance - DLL termination

int CDLSDesignerApp::ExitInstance()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CDLSDesignerApp::GetHelpFileName

BOOL CDLSDesignerApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CBandEditorApp::PutDataInClipboard

BOOL CDLSDesignerApp::PutDataInClipboard( IDataObject* pIDataObject, void* pObject )
{
	if( pIDataObject )
	{
		if( ::OleSetClipboard( pIDataObject ) == S_OK )
		{
			if( m_pIClipboardDataObject )
			{
				m_pIClipboardDataObject->Release();
				m_pIClipboardDataObject = NULL;
			}

			m_pIClipboardDataObject = pIDataObject;
			m_pIClipboardDataObject->AddRef();

			m_pClipboardObject = pObject;

			return TRUE;
		}
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CBandEditorApp::FlushClipboard

void CDLSDesignerApp::FlushClipboard( void* pClipboardObject )
{
	if( m_pClipboardObject == pClipboardObject )
	{
		ASSERT( m_pIClipboardDataObject != NULL );

		if( ::OleIsCurrentClipboard( m_pIClipboardDataObject ) == S_OK )
		{
			::OleFlushClipboard();
		}

		if( m_pIClipboardDataObject )
		{
			m_pIClipboardDataObject->Release();
			m_pIClipboardDataObject = NULL;
		}

		m_pClipboardObject = NULL;
	}
}



////////////////////////////////////////////////////////////////////////////
// CDLSDesignerApp::SetNodePointers  (used by all components)

void CDLSDesignerApp::SetNodePointers(IDMUSProdNode* pINode, IDMUSProdNode* pIRootNode, IDMUSProdNode* pIParentNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdNode* pIChild;

	ASSERT( pINode != NULL );
	ASSERT( pIRootNode != NULL );

	pINode->SetDocRootNode( pIRootNode );    
	pINode->SetParentNode( pIParentNode );    

	HRESULT hr = pINode->GetFirstChild(&pIChild);

	while(SUCCEEDED(hr)  &&  pIChild)
	{
		IDMUSProdNode* pINextChild;
		
		SetNodePointers(pIChild, pIRootNode, pINode);

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		
		pIChild->Release();
		pIChild = pINextChild;
	}
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

void CDLSDesignerApp::SetFramework(IDMUSProdFramework * pFramework)

{
	m_pFramework = pFramework;
}


IDMUSProdFramework *CDLSDesignerApp::GetFramework()

{
	return m_pFramework;
}

/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DirectMusic Producer components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz1;
    LPOLESTR psz2;
    LPOLESTR psz3;
    LPOLESTR psz4;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
	TCHAR	 szInProcServer32[SMALL_BUFFER];
	TCHAR	 szThreadingModel[SMALL_BUFFER];
	TCHAR	 szApartment[SMALL_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
	TCHAR	 szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    TCHAR    szGuid2[MID_BUFFER];
    TCHAR    szGuid3[MID_BUFFER];
    TCHAR    szGuid4[MID_BUFFER];
    CString  strName;
    TCHAR    szComponentPath[MAX_BUFFER];
	TCHAR	 szSkip[SMALL_BUFFER];
	DWORD    dwSkip = 0;
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szInProcServer32, _T("InProcServer32") );
	_tcscpy( szThreadingModel, _T("ThreadingModel") );
	_tcscpy( szApartment, _T("Apartment") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szSkip, _T("Skip") );
	
// Register DLS Designer Component
    if( SUCCEEDED( StringFromIID(CLSID_Wave, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_DLS_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_Instrument, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_DLS_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_DLSComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_DLS_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, szSkip, &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_CollectionNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_CollectionRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DLSComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicCollection, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_COLLECTION_OBJECT_TEXT );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_WaveNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_WaveRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DLSComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectSoundWave, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_WAVE_OBJECT_TEXT );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR    szGuid[MID_BUFFER];
	
	if( SUCCEEDED( StringFromIID(CLSID_Wave, &psz) ) )
    {
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	if( SUCCEEDED( StringFromIID(CLSID_Instrument, &psz) ) )
    {
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	if( SUCCEEDED( StringFromIID(CLSID_DLSComponent, &psz) ) )
    {
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("CLSID\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_CollectionNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_WaveNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
		AFX_MANAGE_STATE(_afxModuleAddrThis);
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
		AFX_MANAGE_STATE(_afxModuleAddrThis);
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
		AFX_MANAGE_STATE(_afxModuleAddrThis);
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
            AfxOleLockApp();
        }
        else
        {
            AfxOleUnlockApp();
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
    return hrReturn; \
}

CREATE_INSTANCE( CDLSComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_DLSComponent) )
	{
        pfunc = CDLSComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    
    else if( IsEqualCLSID(rclsid, CLSID_Collection)
//		 ||  IsEqualCLSID(rclsid, CLSID_CollectionPropPage)
		 ||  IsEqualCLSID(rclsid, CLSID_Instrument)
//		 ||  IsEqualCLSID(rclsid, CLSID_InstrumentPropPage)
		 ||  IsEqualCLSID(rclsid, CLSID_Region)
//		 ||  IsEqualCLSID(rclsid, CLSID_RegionPropPage)
		 ||  IsEqualCLSID(rclsid, CLSID_Wave)
//		 ||  IsEqualCLSID(rclsid, CLSID_WavePropPage)
		 ||  IsEqualCLSID(rclsid, CLSID_Articulation)
//		 ||  IsEqualCLSID(rclsid, CLSID_ArticulationPropPage) 
		)
	{
		AFX_MANAGE_STATE( AfxGetStaticModuleState() );
		AfxDllGetClassObject( rclsid, riid, ppv );
		if( *ppv == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSDesignerDLL.h ===
#if !defined(AFX_DLSDESIGNER_H__BC964E9C_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_DLSDESIGNER_H__BC964E9C_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// DLSDesigner.h : main header file for DLSDESIGNER.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"		// main symbols
#include "DMUSProd.h"
#include "Conductor.h"		// Conductor interface and CLSID

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256
#define TOOLBAR_HEIGHT	29
#define WM_MYPROPVERB	WM_USER+1267 

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#ifndef CHUNK_ALIGN
#define SIZE_ALIGN	sizeof(BYTE *)
#define CHUNK_ALIGN(x) (((x) + SIZE_ALIGN - 1) & ~(SIZE_ALIGN - 1))
#endif

extern const CLSID CLSID_CollectionPropPage;
extern const CLSID CLSID_InstrumentPropPage;
extern const CLSID CLSID_RegionPropPage;
extern const CLSID CLSID_WavePropPage;
extern const CLSID CLSID_ArticulationPropPage;

/////////////////////////////////////////////////////////////////////////////
// CDLSDesignerApp : See DLSDesigner.cpp for implementation.

class CDLSDesignerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetRootNode( IDMUSProdNode* pNode, IDMUSProdNode* pRootNode );
	void SetNodePointers( IDMUSProdNode* pNode, IDMUSProdNode* pRootNode, IDMUSProdNode* pParentNode );
	void SetFramework(IDMUSProdFramework * pFramework);
	IDMUSProdFramework *GetFramework();

	BOOL PutDataInClipboard( IDataObject* pIDataObject, void* pClipboardObject );
	void FlushClipboard( void* pClipboardObject );


private:
	IDataObject*	m_pIClipboardDataObject;	// Data copied into clipboard
	void*			m_pClipboardObject;			// Object responsible for data copied into clipboard

public:	
	HANDLE			m_hKeyProgressBar;			// Used to manage Framework's progress bar
	DWORD			m_dwProgressBarIncrement;	
	DWORD			m_dwProgressBarTotalBytes;
	DWORD			m_dwProgressBarRemainingBytes;

	IDMUSProdFramework* m_pFramework;
};

extern CDLSDesignerApp NEAR theApp;

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLSDESIGNER_H__BC964E9C_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSEdit.cpp ===
// DLSEdit.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "DLSEdit.h"
#include "InstrumentCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDLSEdit

CDLSEdit::CDLSEdit(CInstrumentCtrl* pParent)
{
	m_ParentCtrl = pParent;
}

CDLSEdit::~CDLSEdit()
{
}


BEGIN_MESSAGE_MAP(CDLSEdit, CEdit)
	//{{AFX_MSG_MAP(CDLSEdit)
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDLSEdit message handlers

void CDLSEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if (nChar == 32) // Space bar
    {
		m_ParentCtrl->OnKeyDown(nChar, nRepCnt, nFlags);
	}	
	else
	{
		CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
	}
}

void CDLSEdit::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if (nChar == 32) // Space bar
    {
		m_ParentCtrl->OnKeyUp(nChar, nRepCnt, nFlags);
	}	
	else
	{
		CEdit::OnKeyUp(nChar, nRepCnt, nFlags);
	}
}

void CDLSEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if (nChar != 32)
	{
		CEdit::OnChar(nChar, nRepCnt, nFlags);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSDocType.cpp ===
// DLSDocType.cpp : implementation file
//

#include "stdafx.h"

#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "DLSDocType.h"
#include "Collection.h"
#include "riffstrm.h"
#include "dls1.h"
#include <mmsystem.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType constructor/destructor

CDLSDocType::CDLSDocType()
{
    ASSERT(1);
}

CDLSDocType::CDLSDocType(CDLSComponent* pComponent)
{
	ASSERT(pComponent != NULL);

    m_dwRef = 0;

	m_pComponent = pComponent;
//	m_pComponent->AddRef() intentionally missing
}

CDLSDocType::~CDLSDocType()
{
}

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType IUnknown implementation

HRESULT CDLSDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
	||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CDLSDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CDLSDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType::GetResourceId

HRESULT CDLSDocType::GetResourceId(HINSTANCE* phInstance, UINT* pnResourceId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_DLS_DOCTYPE;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType::DoesExtensionMatch

HRESULT CDLSDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_DLS_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType::DoesIdMatch

HRESULT CDLSDocType::DoesIdMatch(REFGUID rguid)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if(::IsEqualGUID(rguid, GUID_CollectionNode))
	{
		return S_OK;
	}

	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType::AllocNode

HRESULT STDMETHODCALLTYPE CDLSDocType::AllocNode(REFGUID rguid, IDMUSProdNode** ppINode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent != NULL);

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_CollectionNode) == FALSE )
	{
		return E_INVALIDARG;
	}

	// Create a new Collection 
	CCollection* pCollection = new CCollection( m_pComponent );
	if( pCollection == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppINode = (IDMUSProdNode *)pCollection;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSDocType:::OnFileNew

HRESULT CDLSDocType::OnFileNew(IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
							   IDMUSProdNode** ppRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	IDMUSProdNode* pIDLSNode;

	HRESULT hr = E_FAIL;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	*ppRootNode = NULL;

	// Create a new DLS 
	hr = AllocNode( GUID_CollectionNode, &pIDLSNode );
	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pIDLSNode, pIDLSNode, NULL);
		
		// Insert the DLS node into the Project Tree		
		hr = m_pComponent->m_pIFramework->AddNode(pIDLSNode, NULL); 

		if(SUCCEEDED(hr))
		{
			// This call addrefs the collection as well...
			m_pComponent->AddToCollectionList((CCollection *)pIDLSNode);

			*ppRootNode = pIDLSNode;

			// Set flag so we know to save file 
            ((CCollection *)pIDLSNode)->SetDirtyFlag();

			return S_OK;
		}

		pIDLSNode->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSDocType::OnFileOpen

HRESULT CDLSDocType::OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
								IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CCollection* pCollection;
	CString strFileName;
	HRESULT hr;

	ASSERT( m_pComponent != NULL );

	*ppRootNode = NULL;

	// Create a new DLS 
	pCollection = new CCollection( m_pComponent );
	if( pCollection == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	m_pComponent->m_nNextDLS--;

	// Keep the filename with the node
	CString sFilePath;
	IDMUSProdPersistInfo* pIJazzPersistInfo;
	if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)))
	{
		BSTR bstrFileName;
		pIJazzPersistInfo->GetFileName(&bstrFileName);
		sFilePath = bstrFileName;
		SysFreeString(bstrFileName);
		pIJazzPersistInfo->Release();
	}

	pCollection->SetNodeFileName(sFilePath);

	// Load the DLS file
	
	{ // Used to scope CWaitCusor
		CWaitCursor();
	
		hr = pCollection->Load( pIStream );

		if( !SUCCEEDED ( hr ) )
		{
			pCollection->Release();
			return hr;
		}
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pCollection, pCollection, NULL);
		
	// Insert the DLS node into the Project Tree
	hr = m_pComponent->m_pIFramework->AddNode(pCollection, NULL);

	if(SUCCEEDED(hr))
	{
		// This method addrefs the collection as well...
		m_pComponent->AddToCollectionList(pCollection);
		
		*ppRootNode = pCollection;
		pCollection->ValidateInstrumentPatches();
		return S_OK;
	}
	
	pCollection->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType::IsFileTypeExtension

HRESULT CDLSDocType::IsFileTypeExtension(FileType ftFileType, BSTR bstrExt)    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString(bstrExt);

	strExt.MakeLower();

	switch(ftFileType)
	{
		case FT_DESIGN:
			if(strExt == _T(".dlp"))
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if(strExt == _T(".dls"))
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType IDMUSProdDocType::OnFileSave

HRESULT CDLSDocType::OnFileSave(IStream* pIStream, IDMUSProdNode* pIDocRootNode)
{
	// If this method returns E_NOTIMPL the IDMUSProdFramework does the right thing
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType IDMUSProdDocType::GetListInfo

HRESULT CDLSDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdRIFFStream* pIRiffStream = NULL;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwByteCount;
	void*	pString;
	CString csName;
	HRESULT hr = S_OK;

    ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	if( SUCCEEDED ( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = FOURCC_DLS;
		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			ck.fccType = mmioFOURCC('I','N','F','O') ;
			if ( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST) == 0 )
			{
				ck.ckid = mmioFOURCC('I','N','A','M');
				if ( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK) == 0 )
				{
					pString = new char[ck.cksize];
					if (pString)
					{
						pIStream->Read(pString, ck.cksize, &dwByteCount);
						csName = (char*) pString;
						delete pString;
						pListInfo->bstrName = csName.AllocSysString();
						hr = S_OK;
					}
					else
					{
						//"new" failed
						hr = E_OUTOFMEMORY;
					}
				}
				else
				{
					hr = E_FAIL;
					// name chunk not in info list
				}
			}
			else
			{
				hr = E_FAIL;
				//Info list not found
			}
		}
		else
		{
			hr = E_FAIL;
			// DLS RIFF not found
		}
	}
	else
	{
		hr = E_FAIL;
		// AllocRiffStream failed
	}

	if( pIRiffStream )
	{
		pIRiffStream->Release();
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSDocType::GetObjectDescriptorFromNode

HRESULT CDLSDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Collection Node
	CCollection* pCollection;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_CollectionNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pCollection = (CCollection *)pIDocRootNode;

	return pCollection->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CDLSDocType::GetObjectRiffId

HRESULT CDLSDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Collection Node
	if( IsEqualGUID ( guidNodeId, GUID_CollectionNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = FOURCC_DLS;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CDLSDocType::GetObjectExt

HRESULT CDLSDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Collection Node
	if( IsEqualGUID ( guidNodeId, GUID_CollectionNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".dlp";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".dls";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}

/////////////////////////////////////////////////////////////////////////////
// CDLSDocType additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSEdit.h ===
#if !defined(AFX_DLSEDIT_H__8A0E5E80_EAB6_11D1_B987_006097B01078__INCLUDED_)
#define AFX_DLSEDIT_H__8A0E5E80_EAB6_11D1_B987_006097B01078__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DLSEdit.h : header file
//

class CInstrumentCtrl;

/////////////////////////////////////////////////////////////////////////////
// CDLSEdit window

class CDLSEdit : public CEdit
{
// Construction
public:
	CDLSEdit(CInstrumentCtrl* pParent);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDLSEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CDLSEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CDLSEdit)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
private:
	CInstrumentCtrl* m_ParentCtrl;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLSEDIT_H__8A0E5E80_EAB6_11D1_B987_006097B01078__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSDocType.h ===
#ifndef __DLSDOCTYPE_H__
#define __DLSDOCTYPE_H__

// CDLSDocType.h : header file
//

class CDLSComponent;

class CDLSDocType : public IDMUSProdDocType8
{
public:
    CDLSDocType(CDLSComponent* pComponent);
	~CDLSDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDLSDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId(HINSTANCE* phInstance, UINT* pnResourceId);
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch(BSTR bstrExt);
    HRESULT STDMETHODCALLTYPE DoesIdMatch(REFGUID rguid);
    HRESULT STDMETHODCALLTYPE AllocNode(REFGUID rguid, IDMUSProdNode** ppINode);

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
	HRESULT STDMETHODCALLTYPE OnFileSave(IStream* pIStream, IDMUSProdNode* pIDocRootNode);
    HRESULT STDMETHODCALLTYPE IsFileTypeExtension(FileType ftFileType, BSTR bstrExt);   
	HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );	

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

	// Additional functions

private:
    CDLSDocType();

private:
    DWORD				m_dwRef;
	CDLSComponent*		m_pComponent;
};

#endif // __DLSDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSStatic.cpp ===
#include "stdafx.h"
#include "DLSStatic.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CDLSStatic::CDLSStatic(UINT nID, CString csTitle, CRect rcPosition, LOGFONT* plfTextFont):
m_nID(nID), m_csTitle(csTitle), m_rcPosition(rcPosition), m_bSelected(FALSE)
{
	ASSERT(plfTextFont);
	m_plfTextFont = plfTextFont;
	
	m_clrText = ::GetSysColor(COLOR_WINDOWTEXT);
	m_clrBackground = ::GetSysColor(COLOR_BTNFACE);
	m_clrSelectedText = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
	m_clrSelectedBackground = ::GetSysColor(COLOR_HIGHLIGHT);

	m_nTextAlignment = DT_LEFT;

	m_pParentWnd = NULL;
}

CDLSStatic::~CDLSStatic()
{
	if(m_plfTextFont)
	{
		delete m_plfTextFont;
		m_plfTextFont = NULL;
	}

	m_pParentWnd = NULL;
}



// The passed CWnd* pStaticWnd must point to a "Static" control...else this method will fail...
HRESULT CDLSStatic::CreateControl(CWnd* pParentWnd, CWnd* pStaticWnd, CDLSStatic** ppDLSStatic)
{
	if(pParentWnd == NULL)
	{
		return E_FAIL;
	}
	
	if(pStaticWnd == NULL)
	{
		return E_FAIL;
	}

	UINT nID = pStaticWnd->GetDlgCtrlID();

	CStatic* pStatic = (CStatic*)pParentWnd->GetDlgItem(nID);
	ASSERT(pStatic);
	if(pStatic == NULL)
	{
		return E_FAIL;
	}
	
	// We want to add statics without bitmaps
	if(pStatic->GetBitmap() == NULL)
	{
		// What are the parent's screen co-ordinates?
		CRect rcParent;
		pParentWnd->GetWindowRect(&rcParent);

		CRect clientRect;
		pStaticWnd->GetClientRect(&clientRect);

		// Calculate the relative position of the control in the parent window...
		CRect rcWindow;
		pStaticWnd->GetWindowRect(&rcWindow);
		rcWindow.left = rcWindow.left - rcParent.left;
		rcWindow.top = rcWindow.top - rcParent.top;
		rcWindow.right= rcWindow.left + clientRect.Width();
		rcWindow.bottom = rcWindow.top + clientRect.Height();

		// What's the display text?
		CString sText;
		pStaticWnd->GetWindowText(sText);

		// Setup the FONT you want to display the text in...
		LOGFONT* pLogFont = NULL;
		CFont* pStaticFont = pStaticWnd->GetFont();
		if(pStaticFont)
		{
			pLogFont = new LOGFONT;
			pStaticFont->GetLogFont(pLogFont);
		}

		// wha tis the alignment specified in the resource file?
		UINT nTextAlign = DT_LEFT;
		LONG lStyle = GetWindowLong(pStaticWnd->m_hWnd, GWL_STYLE);
		if(lStyle & SS_RIGHT)
			nTextAlign = DT_RIGHT;
		else if(lStyle & SS_CENTER) 
			nTextAlign = DT_CENTER;
			
		CDLSStatic* pDLSStatic = new CDLSStatic(nID, sText, rcWindow, pLogFont);
		if(pDLSStatic == NULL)
		{
			return E_OUTOFMEMORY;
		}

		pDLSStatic->m_pParentWnd = pParentWnd;

		pDLSStatic->SetTextAlign(nTextAlign);
		*ppDLSStatic = pDLSStatic;
		return S_OK;
	}

	return E_FAIL;
}


UINT CDLSStatic::GetID()
{
	return m_nID;
}

CRect CDLSStatic::GetPosition()
{
	return m_rcPosition;
}

CString CDLSStatic::GetText()
{
	return m_csTitle;
}

void CDLSStatic::SetText(CString sText)
{
	m_csTitle = sText;
}

void CDLSStatic::OnDraw(CDC* pDC)
{

	ASSERT(pDC);
	if(pDC == NULL)
		return;

	CFont textFont;
	CFont* pOldFont = NULL;
	if(m_plfTextFont)
	{
		textFont.CreateFontIndirect(m_plfTextFont);
		pOldFont = pDC->SelectObject(&textFont);
	}

	COLORREF clrText = m_clrText;
	COLORREF clrBackground = m_clrBackground;

	if(m_bSelected == TRUE)
	{
		clrText = m_clrSelectedText;
		clrBackground = m_clrSelectedBackground;
	}

	COLORREF clrOldBk = pDC->SetBkColor(clrBackground);
	COLORREF clrOldText = pDC->SetTextColor(clrText);
	
	pDC->DrawText(m_csTitle, &m_rcPosition, DT_SINGLELINE | m_nTextAlignment);

	if(clrOldBk != 0x80000000)
		pDC->SetBkColor(clrOldBk);

	if(clrOldText != 0x80000000)
		pDC->SetTextColor(clrOldText);

	if(pOldFont)
	{
		pDC->SelectObject(pOldFont);
		textFont.DeleteObject();
	}

}


void CDLSStatic::SetTextColor(COLORREF clrText)
{
	m_clrText = clrText;
}


void CDLSStatic::SetBackgroundColor(COLORREF clrBckgnd)
{
	m_clrBackground = clrBckgnd;
}

void CDLSStatic::SetTextAlign(UINT nTextAlign)
{
	m_nTextAlignment = nTextAlign;
}


void CDLSStatic::UnderlineText(BOOL bUnderline)
{
	ASSERT(m_plfTextFont);
	if(m_plfTextFont == NULL)
		return;

	m_plfTextFont->lfUnderline = BYTE(bUnderline);
}

void CDLSStatic::SetSelected(BOOL bSelection)
{
	m_bSelected = bSelection;
}

BOOL CDLSStatic::IsSelected()
{
	return m_bSelected;
}

BOOL CDLSStatic::IsPointInControl(CPoint ptCheck)
{
	return m_rcPosition.PtInRect(ptCheck);
}

void CDLSStatic::Invalidate(CDC* pDC)
{
	ASSERT(pDC);
	if(pDC == NULL)
	{
		return;
	}
	
	m_pParentWnd->InvalidateRect(m_rcPosition);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DLSStatic.h ===
#ifndef __DLSTATIC_H__
#define __DLSTATIC_H__

class CDLSStatic
{

public:
	CDLSStatic(UINT nID, CString csTitle, CRect rcPosition, LOGFONT* plfTextFont);
	~CDLSStatic();
	
	static HRESULT CreateControl(CWnd* pParentWnd, CWnd* pStaticWnd, CDLSStatic** ppDLSStatic);

public:

	void		OnDraw(CDC* pDC);
	
	UINT		GetID();								// The resource ID for this static control
	CRect		GetPosition();							// The position in the container
	CString		GetText();								// Display text
	LOGFONT*	GetLogFont();							// The LOGFONT struct keeps track of how to display the text

	void		SetText(CString sText);					// New text for the control
	void		SetTextColor(COLORREF clrText);			// Color of the text
	void		SetBackgroundColor(COLORREF clrBckgnd); // Background color for the control
	void		SetTextAlign(UINT nTextAlign);			// Text alignment is DT_LEFT by default
	void		UnderlineText(BOOL bUnderline = TRUE);	// Turn underline option on/off
	void		SetSelected(BOOL bSelection = TRUE);	// Marks the static as selected
	BOOL		IsSelected();							// Is this control selected currently?
	BOOL		IsPointInControl(CPoint ptCheck);		// Checks if the given point lies inside the controls boundaries
	void		Invalidate(CDC* pDC);					// Invalidates the control

private:

	UINT		m_nID;
	CString		m_csTitle;
	CRect		m_rcPosition;
	LOGFONT*	m_plfTextFont;
	COLORREF	m_clrText;
	COLORREF	m_clrBackground;
	COLORREF	m_clrSelectedText;
	COLORREF	m_clrSelectedBackground;
	UINT		m_nTextAlignment;
	BOOL		m_bSelected;
	CWnd*		m_pParentWnd;
};

#endif // __DLSTATIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\FilterDialog.cpp ===
// FilterDialog.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "filterdialog.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "Articulation.h"
#include "DLSStatic.h"
#include "InstrumentFVEditor.h"
#include "DlsDefsPlus.h"
#include "UndoMan.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFilterDialog dialog


CFilterDialog::CFilterDialog(CArticulation* pArticulation):
CDialog(), CSliderCollection(7),
m_pArticParams(pArticulation->GetArticParams()),
m_pCollection(NULL), m_pmsInitialFc(NULL)
{
	m_pArticulation = pArticulation;

#ifdef _DEBUG	
	pArticulation->ValidateParent();
#endif

	CInstrument* pInstrument = pArticulation->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pArticulation->GetRegion();
		ASSERT(pRegion);
		if(pRegion)
		{
			pInstrument = pRegion->GetInstrument();
			ASSERT(pInstrument);
			m_pCollection = pInstrument->m_pCollection;
		}
	}

	CSliderCollection::Init(this);

	//{{AFX_DATA_INIT(CFilterDialog)
	//}}AFX_DATA_INIT
}


void CFilterDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFilterDialog)
	DDX_Control(pDX, IDC_ENABLE_FILTER, m_EnableFilterCheck);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFilterDialog, CDialog)
	//{{AFX_MSG_MAP(CFilterDialog)
	ON_WM_HSCROLL()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_ENABLE_FILTER, OnEnableFilter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFilterDialog message handlers

void CFilterDialog::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pArticParams);
	if(m_pArticParams == NULL)
	{
		return;
	}

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}

BOOL CFilterDialog::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CDialog::OnInitDialog();
	
	m_FilterParams = m_pArticParams->m_FilterParams;
	InitSliders();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFilterDialog::InitSliders()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_FilterParams.m_pcInitialFc == 0x7FFFFFFF)
	{
		m_EnableFilterCheck.SetCheck(FALSE);
		EnableSliders(FALSE);
	}
	else
	{
		// Enable the filter controls
		m_EnableFilterCheck.SetCheck(TRUE);
		EnableSliders(TRUE);
	}

	if (m_pmsInitialFc)
		{
		m_pmsInitialFc->SetValue(this, m_FilterParams.m_pcInitialFc);
		m_pmsInitialQ->SetValue(this, m_FilterParams.m_gcInitialQ);
		m_pmsLFOToFc->SetValue(this, m_FilterParams.m_pcModLFOToFc);
		m_pmsLFOCC1ToFc->SetValue(this, m_FilterParams.m_pcModLFOCC1ToFc);
		m_pmsEG2ToFc->SetValue(this, m_FilterParams.m_pcEGToFc);
		m_pmsKeyVelToFc->SetValue(this, m_FilterParams.m_pcVelocityToFc);
		m_pmsKeyNumToFc->SetValue(this, m_FilterParams.m_pcKeyNumToFc);
		}
	else
		{
		m_pmsInitialFc = Insert(
			IDC_FILTER_INITIALFC,
			IDC_FILTER_DINITIALFC,
			IDC_FILTER_DINITIALFC_SPIN,
			MYSLIDER_FILTERABSPITCH,
			0x7FFFFFFF,
			IDS_UNDO_INITIAL_FC,
			&m_FilterParams.m_pcInitialFc);

		m_pmsInitialQ = Insert(
			IDC_FILTER_INITIALQ,
			IDC_FILTER_DINITIALQ,
			IDC_FILTER_DINITIALQ_SPIN,
			MYSLIDER_FILTERGAIN,
			0,
			IDS_UNDO_INITIAL_Q,
			&m_FilterParams.m_gcInitialQ);

		m_pmsLFOToFc = Insert(
			IDC_FILTER_LFOTOFC,
			IDC_FILTER_DLFOTOFC,
			IDC_FILTER_DLFOTOFC_SPIN,
			MYSLIDER_FILTERPITCHCENTS,
			0,
			IDS_UNDO_LFO_TO_FC,
			&m_FilterParams.m_pcModLFOToFc);

		m_pmsLFOCC1ToFc = Insert(
			IDC_FILTER_CC1TOFC,
			IDC_FILTER_DCC1TOFC,
			IDC_FILTER_DCC1TOFC_SPIN,
			MYSLIDER_FILTERPITCHCENTS,
			0,
			IDS_UNDO_LFOCC1_TO_FC,
			&m_FilterParams.m_pcModLFOCC1ToFc);

		m_pmsEG2ToFc = Insert(
			IDC_FILTER_ENV2TOFC,
			IDC_FILTER_DENV2TOFC,
			IDC_FILTER_DENV2TOFC_SPIN,
			MYSLIDER_FILTERPITCHCENTS,
			0,
			IDS_UNDO_EG2_TO_FC,
			&m_FilterParams.m_pcEGToFc);

		m_pmsKeyVelToFc = Insert(
			IDC_FILTER_VELTOFC,
			IDC_FILTER_DVELTOFC,
			IDC_FILTER_DVELTOFC_SPIN,
			MYSLIDER_FILTERPITCHCENTS,
			0,
			IDS_UNDO_KEYVEL_TO_FC,
			&m_FilterParams.m_pcVelocityToFc);

		m_pmsKeyNumToFc = Insert(
			IDC_FILTER_KEYNUMTOFC,
			IDC_FILTER_DKEYNUMTOFC,
			IDC_FILTER_DKEYNUMTOFC_SPIN,
			MYSLIDER_FILTERPITCHCENTS,
			0,
			IDS_UNDO_KEYNUM_TO_FC,
			&m_FilterParams.m_pcKeyNumToFc);
			}

	BOOL bDLS1  = m_pArticulation->IsDLS1();
	EnableDLS2Controls(!bDLS1);
}

HRESULT CFilterDialog::SaveUndoState(UINT uStringRes)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CInstrumentFVEditor* pParent = (CInstrumentFVEditor*) GetParent();
	ASSERT(pParent);

	if(pParent && pParent->m_pInstrument)
	{
		if(FAILED(pParent->m_pInstrument->SaveStateForUndo(uStringRes)))
			return E_FAIL;
	}
	else
		return E_FAIL;

	return S_OK;
}

void CFilterDialog::UpdateArticulation(CArticulation* pNewArt)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pNewArt);
	if(pNewArt == NULL)
	{
		return;
	}

	m_pArticParams = pNewArt->GetArticParams();
	m_pArticulation = pNewArt;

#ifdef _DEBUG	
	pNewArt->ValidateParent();
#endif

	CInstrument* pInstrument = pNewArt->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pNewArt->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		m_pCollection = pInstrument->m_pCollection;
	}

	m_FilterParams = m_pArticParams->m_FilterParams;
	InitSliders();
}

void CFilterDialog::CollectStatics()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}
	
	CWnd* pChild = GetWindow(GW_CHILD);
	while(pChild)
	{
		char szClassName[MAX_PATH];
		::GetClassName(pChild->m_hWnd, szClassName, MAX_PATH);
		
		// Add it to the list if it's a "Static"
		if(strcmp(szClassName,"Static") == 0)
		{
			CDLSStatic* pDLSStatic = NULL;
			if(SUCCEEDED(CDLSStatic::CreateControl(this, pChild, &pDLSStatic)))
				m_lstStatics.AddTail(pDLSStatic);
		}

		pChild = pChild->GetNextWindow();
	}

	// Destroy the actual static controls now
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		CWnd* pWnd = GetDlgItem(pStatic->GetID());
		if(pWnd)
		{
			pWnd->DestroyWindow();
		}
	}
}


void CFilterDialog::OnDestroy() 
{
	CDialog::OnDestroy();

	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}
}

void CFilterDialog::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		pStatic->OnDraw(&dc);
	}
}

void CFilterDialog::OnEnableFilter() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pArticulation);
	if(m_pArticulation == NULL)
	{
		return;
	}

	int nState = m_EnableFilterCheck.GetCheck();
	if(nState == 0)
	{
		EnableSliders(FALSE);
		m_FilterParams.m_pcInitialFc = 0x7FFFFFFF;
	}
	else
	{
		EnableSliders(TRUE);
		m_FilterParams.m_pcInitialFc = m_pmsInitialFc->GetValue();
	}

	// Update the articulation
	UpdateInstrument();
}


void CFilterDialog::EnableDLS2Controls(BOOL bEnable)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_EnableFilterCheck.EnableWindow(bEnable);
	int nCheck = m_EnableFilterCheck.GetCheck();
	if(nCheck && bEnable)
	{	
		EnableSliders(TRUE);
	}
	else
	{
		EnableSliders(FALSE);
	}
}


void CFilterDialog::EnableSliders(BOOL bEnable)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// enable/disable only if controls have been created
	if (m_pmsInitialFc == NULL)
		return;

	m_pmsInitialFc->EnableControl(this, bEnable != 0);
	m_pmsInitialQ->EnableControl(this, bEnable != 0);
	m_pmsLFOToFc->EnableControl(this, bEnable != 0);
	m_pmsLFOCC1ToFc->EnableControl(this, bEnable != 0);
	m_pmsEG2ToFc->EnableControl(this, bEnable != 0);
	m_pmsKeyVelToFc->EnableControl(this, bEnable != 0);
	m_pmsKeyNumToFc->EnableControl(this, bEnable != 0);
}

BOOL CFilterDialog::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CDialog::OnCommand(wParam, lParam);
}

BOOL CFilterDialog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT lResult;
	if (CSliderCollection::OnNotify(wParam, lParam, &lResult))
		return lResult;
	
	return CDialog::OnNotify(wParam, lParam, pResult);
}

void CFilterDialog::UpdateInstrument()
{
	m_pArticParams->m_FilterParams = m_FilterParams;
	CInstrument* pInstrument = m_pArticulation->GetInstrument();
	if(pInstrument)
	{
		pInstrument->UpdateInstrument();
		if(pInstrument->m_pCollection)
		{
			pInstrument->m_pCollection->SetDirtyFlag();
		}
	}
	else if (m_pArticulation->GetRegion())
	{
		CRegion* pRegion = m_pArticulation->GetRegion();
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		if(pInstrument)
		{
			pInstrument->UpdateInstrument();
			if(pInstrument->m_pCollection)
			{
				pInstrument->m_pCollection->SetDirtyFlag();
			}
		}
	}
}

bool CFilterDialog::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			if (SUCCEEDED(SaveUndoState(pms->GetUndoStringID())))
				return true;
			UpdateArticulation(m_pArticulation);
			return false;

		case dwmscupdfEnd:
			UpdateInstrument();
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\DMSynthError.h ===
//      Error.h

#define RA_E_FIRST				(OLE_E_FIRST + 5000)

#define E_BADWAVE		        (RA_E_FIRST + 1)    // Bad wave chunk
#define E_NOTPCM		        (RA_E_FIRST + 2)    // Not PCM data in wave
#define E_NOTMONO		        (RA_E_FIRST + 3)    // Wave not MONO
#define E_BADARTICULATION       (RA_E_FIRST + 4)    // Bad articulation chunk
#define E_BADREGION		        (RA_E_FIRST + 5)    // Bad region chunk
#define E_BADWAVELINK	        (RA_E_FIRST + 6)    // Bad link from region to wave
#define E_BADINSTRUMENT	        (RA_E_FIRST + 7)    // Bad instrument chunk
#define E_NOARTICULATION        (RA_E_FIRST + 8)    // No articulation found in region
#define E_NOWAVE		        (RA_E_FIRST + 9)    // No wave found for region.
#define E_BADCOLLECTION	        (RA_E_FIRST + 10)   // Bad collection chunk.
#define E_NOLOADER   	        (RA_E_FIRST + 11)   // No IRALoader interface 
#define E_NOLOCK		        (RA_E_FIRST + 12)   // Unable to lock a region.
#define E_TOOBUSY		        (RA_E_FIRST + 13)   // RActive to busy to fully follow command.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\filterdialog.h ===
#if !defined(AFX_FILTERDIALOG_H__83A2C55F_3E61_4504_AA8C_7D052F440A6F__INCLUDED_)
#define AFX_FILTERDIALOG_H__83A2C55F_3E61_4504_AA8C_7D052F440A6F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// filterdialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFilterDialog dialog
#include "resource.h"
#include "myslider.h"
#include "DLSLoadSaveUtils.h"

class CArticulation;
class CCollection;

class CFilterDialog : public CDialog, CSliderCollection
{
// Construction
public:
	
	CFilterDialog(CArticulation* pArticulation);  

public:
	void UpdateArticulation(CArticulation* pNewArt);

// Dialog Data
	//{{AFX_DATA(CFilterDialog)
	enum { IDD = IDD_FILTER_PAGE };
	CButton	m_EnableFilterCheck;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFilterDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

	// CSliderCollection overrides
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);
	
// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFilterDialog)
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnEnableFilter();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	HRESULT	SaveUndoState(UINT uStringRes);
	void	CollectStatics();
	void	InitSliders();
	void	EnableSliders(BOOL bEnable = TRUE); 
	void	EnableDLS2Controls(BOOL bEnable = TRUE);	// All controls are actually DLS2 in this case
	void	UpdateInstrument();

	CPtrList		m_lstStatics;	// List of static controls in the dialog

	CCollection*	m_pCollection;	
	ArticParams*	m_pArticParams;
	FilterParams	m_FilterParams;
	CArticulation*	m_pArticulation;

	MySlider*	m_pmsInitialFc;				// also used to test initialization of all sliders
	MySlider*	m_pmsInitialQ;
	MySlider*	m_pmsLFOToFc;
	MySlider*	m_pmsLFOCC1ToFc;
	MySlider*	m_pmsEG2ToFc;
	MySlider*	m_pmsKeyVelToFc;
	MySlider*	m_pmsKeyNumToFc;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILTERDIALOG_H__83A2C55F_3E61_4504_AA8C_7D052F440A6F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\GuidDlg.cpp ===
// GuidDlg.cpp : implementation file
//

#include "stdafx.h"
#include "guiddlg.h"
#include "dmusici.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGuidDlg dialog


CGuidDlg::CGuidDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGuidDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGuidDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CGuidDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGuidDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_EDIT_GUID, m_editGuid);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGuidDlg, CDialog)
	//{{AFX_MSG_MAP(CGuidDlg)
	ON_BN_CLICKED(IDC_NEW_GUID, OnNewGuid)
	ON_EN_KILLFOCUS(IDC_EDIT_GUID, OnKillfocusEditGuid)
	ON_EN_UPDATE(IDC_EDIT_GUID, OnUpdateEditGuid)
	ON_BN_CLICKED(IDC_GM_GUID, OnGmGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGuidDlg message handlers

BOOL CGuidDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	LPOLESTR psz;
	if( SUCCEEDED( ::StringFromIID(m_guid, &psz) ) )
    {
		TCHAR szGuid[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		m_editGuid.SetWindowText( szGuid );
	}
	
	memcpy( &m_guidOriginal, &m_guid, sizeof( GUID ) );

	m_btnOK.EnableWindow( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGuidDlg::OnNewGuid() 
{
	if( SUCCEEDED( ::CoCreateGuid( &m_guid ) ) )
	{
		LPOLESTR psz;
		if( SUCCEEDED( ::StringFromIID(m_guid, &psz) ) )
		{
			TCHAR szGuid[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			m_editGuid.SetWindowText( szGuid );

			m_btnOK.EnableWindow( TRUE );
		}
	}
}

void CGuidDlg::OnKillfocusEditGuid() 
{
}

void CGuidDlg::OnCancel() 
{
	memcpy( &m_guid, &m_guidOriginal, sizeof( GUID ) );
	
	CDialog::OnCancel();
}

void CGuidDlg::OnOK() 
{
	CString strText;
	m_editGuid.GetWindowText( strText );

	WCHAR szWChar[100];
	ZeroMemory( szWChar, 100 * sizeof( WCHAR ) );
	::MultiByteToWideChar( CP_ACP, 0, strText, -1, szWChar, 100 );
	if( SUCCEEDED( ::IIDFromString( szWChar, &m_guid ) ) )
	{
		CDialog::OnOK();
	}
#ifdef _DEBUG
	else
	{
		TRACE("CGuidDlg::OnOK: Edit box doesn't contain a valid GUID.\n");
		ASSERT( FALSE );
	}
#endif
}

void CGuidDlg::OnUpdateEditGuid() 
{
	CString strText;
	m_editGuid.GetWindowText( strText );

	GUID guid;

	WCHAR szWChar[100];
	HRESULT hr;
	hr = ::MultiByteToWideChar( CP_ACP, 0, strText, -1, szWChar, 100 );
	hr = ::IIDFromString( szWChar, &guid );
	if( SUCCEEDED( hr ) )
	{
		if( memcmp( &guid, &m_guidOriginal, sizeof(GUID) ) != 0 )
		{
			m_btnOK.EnableWindow( TRUE );
		}
		else
		{
			m_btnOK.EnableWindow( FALSE );
		}
	}
	else
	{
		m_btnOK.EnableWindow( FALSE );
	}
}

void CGuidDlg::OnGmGuid() 
{
	LPOLESTR psz;
	if( SUCCEEDED( ::StringFromIID(GUID_DefaultGMCollection, &psz) ) )
	{
		TCHAR szGuid[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		m_editGuid.SetWindowText( szGuid );

		m_btnOK.EnableWindow( TRUE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\guiddlg.h ===
#if !defined(AFX_GUIDDLG_H__F2B9A029_63AF_11D2_8918_00C04FBF8D15__INCLUDED_)
#define AFX_GUIDDLG_H__F2B9A029_63AF_11D2_8918_00C04FBF8D15__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// guiddlg.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CGuidDlg dialog

class CGuidDlg : public CDialog
{
// Construction
public:
	CGuidDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGuidDlg)
	enum { IDD = IDD_DLG_GUID };
	CButton	m_btnOK;
	CEdit	m_editGuid;
	//}}AFX_DATA

	GUID m_guid;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGuidDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	GUID m_guidOriginal;

	// Generated message map functions
	//{{AFX_MSG(CGuidDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnNewGuid();
	afx_msg void OnKillfocusEditGuid();
	virtual void OnCancel();
	virtual void OnOK();
	afx_msg void OnUpdateEditGuid();
	afx_msg void OnGmGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GUIDDLG_H__F2B9A029_63AF_11D2_8918_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Guids.cpp ===
//////////////////////////////////////////////////////////////////////
//
//	Guids.cpp
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <initguid.h>
#include <dmksctrl.h>
#include "WaveTimelineDraw.h"
#include "WaveTrackDownload.h"
#include "mmsystem.h"
#include "DSoundP.h"
#include "DLSDesigner.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dls2.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\GMStrings.cpp ===
// Always keep the correct count in this 
const DWORD dwabiGSInstruments = 226;
BInstr abiGS[] = 
{
	IDS_PGM000,  0x00,  0, 0, NULL,  // Piano
	IDS_PGM008,  0x00,  8, 0, NULL,
	IDS_PGM0016, 0x00, 16, 0, NULL,
	IDS_PGM010,  0x01,  0, 0, NULL,
	IDS_PGM018,  0x01,  8, 0, NULL,
	IDS_PGM020,  0x02,  0, 0, NULL,
	IDS_PGM028,  0x02,  8, 0, NULL,
	IDS_PGM030,  0x03,  0, 0, NULL,
	IDS_PGM038,  0x03,  8, 0, NULL,
	IDS_PGM040,  0x04,  0, 0, NULL,
	IDS_PGM048,  0x04,  8, 0, NULL,
	IDS_PGM0416, 0x04, 16, 0, NULL,
	IDS_PGM0424, 0x04, 24, 0, NULL,
	IDS_PGM050,  0x05,  0, 0, NULL,
	IDS_PGM058,  0x05,  8, 0, NULL,
	IDS_PGM0516, 0x05, 16, 0, NULL,
	IDS_PGM060,  0x06,  0, 0, NULL,
	IDS_PGM068,  0x06,  8, 0, NULL,
	IDS_PGM0616, 0x06, 16, 0, NULL,
	IDS_PGM0624, 0x06, 24, 0, NULL,
	IDS_PGM070,  0x07,  0, 0, NULL,

	IDS_PGM080,  0x08,  0, 0, NULL,  // Chrom. Perc.
	IDS_PGM090,  0x09,  0, 0, NULL,
	IDS_PGM0A0,  0x0A,  0, 0, NULL,
	IDS_PGM0B0,  0x0B,  0, 0, NULL,
	IDS_PGM0B8,  0x0B,  8, 0, NULL,
	IDS_PGM0C0,  0x0C,  0, 0, NULL,
	IDS_PGM0C8,  0x0C,  8, 0, NULL,
	IDS_PGM0D0,  0x0D,  0, 0, NULL,
	IDS_PGM0E0,  0x0E,  0, 0, NULL,
	IDS_PGM0E8,  0x0E,  8, 0, NULL,
	IDS_PGM0E9,  0x0E,  9, 0, NULL,
	IDS_PGM0F0,  0x0F,  0, 0, NULL,

	IDS_PGM100,  0x10,  0, 0, NULL,  // Organ
	IDS_PGM108,  0x10,  8, 0, NULL,
	IDS_PGM1016, 0x10, 16, 0, NULL,
	IDS_PGM1032, 0x10, 32, 0, NULL,
	IDS_PGM110,  0x11,  0, 0, NULL,
	IDS_PGM118,  0x11,  8, 0, NULL,
	IDS_PGM1132, 0x11, 32, 0, NULL,
	IDS_PGM120,  0x12,  0, 0, NULL,
	IDS_PGM130,  0x13,  0, 0, NULL,
	IDS_PGM138,  0x13,  8, 0, NULL,
	IDS_PGM1316, 0x13, 16, 0, NULL,
	IDS_PGM140,  0x14,  0, 0, NULL,
	IDS_PGM150,  0x15,  0, 0, NULL,
	IDS_PGM158,  0x15,  8, 0, NULL,
	IDS_PGM160,  0x16,  0, 0, NULL,
	IDS_PGM170,  0x17,  0, 0, NULL,

	IDS_PGM180,  0x18,  0, 0, NULL,  // Guitar
	IDS_PGM188,  0x18,  8, 0, NULL,
	IDS_PGM1816, 0x18, 16, 0, NULL,
	IDS_PGM1832, 0x18, 32, 0, NULL,
	IDS_PGM190,  0x19,  0, 0, NULL,
	IDS_PGM198,  0x19,  8, 0, NULL,
	IDS_PGM1916, 0x19, 16, 0, NULL,
	IDS_PGM1A0,  0x1A,  0, 0, NULL,
	IDS_PGM1A8,  0x1A,  8, 0, NULL,
	IDS_PGM1B0,  0x1B,  0, 0, NULL,
	IDS_PGM1B8,  0x1B,  8, 0, NULL,
	IDS_PGM1C0,  0x1C,  0, 0, NULL,
	IDS_PGM1C8,  0x1C,  8, 0, NULL,
	IDS_PGM1C16, 0x1C, 16, 0, NULL,
	IDS_PGM1D0,  0x1D,  0, 0, NULL,
	IDS_PGM1E0,  0x1E,  0, 0, NULL,
	IDS_PGM1E8,  0x1E,  8, 0, NULL,
	IDS_PGM1F0,  0x1F,  0, 0, NULL,
	IDS_PGM1F8,  0x1F,  8, 0, NULL,

	IDS_PGM200,  0x20,  0, 0, NULL,  // Bass
	IDS_PGM210,  0x21,  0, 0, NULL,
	IDS_PGM220,  0x22,  0, 0, NULL,
	IDS_PGM230,  0x23,  0, 0, NULL,
	IDS_PGM240,  0x24,  0, 0, NULL,
	IDS_PGM250,  0x25,  0, 0, NULL,
	IDS_PGM260,  0x26,  0, 0, NULL,
	IDS_PGM261,  0x26,  1, 0, NULL,
	IDS_PGM268,  0x26,  8, 0, NULL,
	IDS_PGM270,  0x27,  0, 0, NULL,
	IDS_PGM278,  0x27,  8, 0, NULL,
	IDS_PGM2716, 0x27, 16, 0, NULL,

	IDS_PGM280,  0x28,  0, 0, NULL,  // Orchestral
	IDS_PGM288,  0x28,  8, 0, NULL,
	IDS_PGM290,  0x29,  0, 0, NULL,
	IDS_PGM2A0,  0x2A,  0, 0, NULL,
	IDS_PGM2B0,  0x2B,  0, 0, NULL,
	IDS_PGM2C0,  0x2C,  0, 0, NULL,
	IDS_PGM2D0,  0x2D,  0, 0, NULL,
	IDS_PGM2E0,  0x2E,  0, 0, NULL,
	IDS_PGM2F0,  0x2F,  0, 0, NULL,

	IDS_PGM300,  0x30,  0, 0, NULL,  // Ensemble
	IDS_PGM308,  0x30,  8, 0, NULL,
	IDS_PGM310,  0x31,  0, 0, NULL,
	IDS_PGM320,  0x32,  0, 0, NULL,
	IDS_PGM328,  0x32,  8, 0, NULL,
	IDS_PGM330,  0x33,  0, 0, NULL,
	IDS_PGM340,  0x34,  0, 0, NULL,
	IDS_PGM3432, 0x34, 32, 0, NULL,
	IDS_PGM350,  0x35,  0, 0, NULL,
	IDS_PGM360,  0x36,  0, 0, NULL,
	IDS_PGM370,  0x37,  0, 0, NULL,

	IDS_PGM380,  0x38,  0, 0, NULL,  // Brass
	IDS_PGM390,  0x39,  0, 0, NULL,
	IDS_PGM391,  0x39,  1, 0, NULL,
	IDS_PGM3A0,  0x3A,  0, 0, NULL,
	IDS_PGM3B0,  0x3B,  0, 0, NULL,
	IDS_PGM3C0,  0x3C,  0, 0, NULL,
	IDS_PGM3C1,  0x3C,  1, 0, NULL,
	IDS_PGM3D0,  0x3D,  0, 0, NULL,
	IDS_PGM3D8,  0x3D,  8, 0, NULL,
	IDS_PGM3E0,  0x3E,  0, 0, NULL,
	IDS_PGM3E8,  0x3E,  8, 0, NULL,
	IDS_PGM3E16, 0x3E, 16, 0, NULL,
	IDS_PGM3F0,  0x3F,  0, 0, NULL,
	IDS_PGM3F8,  0x3F,  8, 0, NULL,
	IDS_PGM3F16, 0x3F, 16, 0, NULL,

	IDS_PGM400,  0x40,  0, 0, NULL,  // Reed
	IDS_PGM410,  0x41,  0, 0, NULL,
	IDS_PGM420,  0x42,  0, 0, NULL,
	IDS_PGM430,  0x43,  0, 0, NULL,
	IDS_PGM440,  0x44,  0, 0, NULL,
	IDS_PGM450,  0x45,  0, 0, NULL,
	IDS_PGM460,  0x46,  0, 0, NULL,
	IDS_PGM470,  0x47,  0, 0, NULL,

	IDS_PGM480,  0x48,  0, 0, NULL,  // Pipe
	IDS_PGM490,  0x49,  0, 0, NULL,
	IDS_PGM4A0,  0x4A,  0, 0, NULL,
	IDS_PGM4B0,  0x4B,  0, 0, NULL,
	IDS_PGM4C0,  0x4C,  0, 0, NULL,
	IDS_PGM4D0,  0x4D,  0, 0, NULL,
	IDS_PGM4E0,  0x4E,  0, 0, NULL,
	IDS_PGM4F0,  0x4F,  0, 0, NULL,

	IDS_PGM500,  0x50,  0, 0, NULL,  // Synth Lead
	IDS_PGM501,  0x50,  1, 0, NULL,
	IDS_PGM508,  0x50,  8, 0, NULL,
	IDS_PGM510,  0x51,  0, 0, NULL,
	IDS_PGM511,  0x51,  1, 0, NULL,
	IDS_PGM518,  0x51,  8, 0, NULL,
	IDS_PGM520,  0x52,  0, 0, NULL,
	IDS_PGM530,  0x53,  0, 0, NULL,
	IDS_PGM540,  0x54,  0, 0, NULL,
	IDS_PGM550,  0x55,  0, 0, NULL,
	IDS_PGM560,  0x56,  0, 0, NULL,
	IDS_PGM570,  0x57,  0, 0, NULL,

	IDS_PGM580,  0x58,  0, 0, NULL,  // Synth Pad
	IDS_PGM590,  0x59,  0, 0, NULL,
	IDS_PGM5A0,  0x5A,  0, 0, NULL,
	IDS_PGM5B0,  0x5B,  0, 0, NULL,
	IDS_PGM5C0,  0x5C,  0, 0, NULL,
	IDS_PGM5D0,  0x5D,  0, 0, NULL,
	IDS_PGM5E0,  0x5E,  0, 0, NULL,
	IDS_PGM5F0,  0x5F,  0, 0, NULL,

	IDS_PGM600,  0x60,  0, 0, NULL,  // Synth SFX
	IDS_PGM610,  0x61,  0, 0, NULL,
	IDS_PGM620,  0x62,  0, 0, NULL,
	IDS_PGM621,  0x62,  1, 0, NULL,
	IDS_PGM630,  0x63,  0, 0, NULL,
	IDS_PGM640,  0x64,  0, 0, NULL,
	IDS_PGM650,  0x65,  0, 0, NULL,
	IDS_PGM660,  0x66,  0, 0, NULL,
	IDS_PGM661,  0x66,  1, 0, NULL,
	IDS_PGM662,  0x66,  2, 0, NULL,
	IDS_PGM670,  0x67,  0, 0, NULL,

	IDS_PGM680,  0x68,  0, 0, NULL,  // Ethnic Misc.
	IDS_PGM681,  0x68,  1, 0, NULL,
	IDS_PGM690,  0x69,  0, 0, NULL,
	IDS_PGM6A0,  0x6A,  0, 0, NULL,
	IDS_PGM6B0,  0x6B,  0, 0, NULL,
	IDS_PGM6B8,  0x6B,  8, 0, NULL,
	IDS_PGM6C0,  0x6C,  0, 0, NULL,
	IDS_PGM6D0,  0x6D,  0, 0, NULL,
	IDS_PGM6E0,  0x6E,  0, 0, NULL,
	IDS_PGM6F0,  0x6F,  0, 0, NULL,

	IDS_PGM700,  0x70,  0, 0, NULL,  // Percussive
	IDS_PGM710,  0x71,  0, 0, NULL,
	IDS_PGM720,  0x72,  0, 0, NULL,
	IDS_PGM730,  0x73,  0, 0, NULL,
	IDS_PGM738,  0x73,  8, 0, NULL,
	IDS_PGM740,  0x74,  0, 0, NULL,
	IDS_PGM748,  0x74,  8, 0, NULL,
	IDS_PGM750,  0x75,  0, 0, NULL,
	IDS_PGM758,  0x75,  8, 0, NULL,
	IDS_PGM760,  0x76,  0, 0, NULL,
	IDS_PGM768,  0x76,  8, 0, NULL,
	IDS_PGM769,  0x76,  9, 0, NULL,
	IDS_PGM770,  0x76,  0, 0, NULL,

	IDS_PGM780,  0x78,  0, 0, NULL,  // SFX
	IDS_PGM781,  0x78,  1, 0, NULL,
	IDS_PGM782,  0x78,  2, 0, NULL,
	IDS_PGM790,  0x79,  0, 0, NULL,
	IDS_PGM791,  0x79,  1, 0, NULL,
	IDS_PGM7A0,  0x7A,  0, 0, NULL,
	IDS_PGM7A1,  0x7A,  1, 0, NULL,
	IDS_PGM7A2,  0x7A,  2, 0, NULL,
	IDS_PGM7A3,  0x7A,  3, 0, NULL,
	IDS_PGM7A4,  0x7A,  4, 0, NULL,
	IDS_PGM7A5,  0x7A,  5, 0, NULL,
	IDS_PGM7B0,  0x7B,  0, 0, NULL,
	IDS_PGM7B1,  0x7B,  1, 0, NULL,
	IDS_PGM7B2,  0x7B,  2, 0, NULL,
	IDS_PGM7B3,  0x7B,  3, 0, NULL,
	IDS_PGM7C0,  0x7C,  0, 0, NULL,
	IDS_PGM7C1,  0x7C,  1, 0, NULL,
	IDS_PGM7C2,  0x7C,  2, 0, NULL,
	IDS_PGM7C3,  0x7C,  3, 0, NULL,
	IDS_PGM7C4,  0x7C,  4, 0, NULL,
	IDS_PGM7C5,  0x7C,  5, 0, NULL,
	IDS_PGM7D0,  0x7D,  0, 0, NULL,
	IDS_PGM7D1,  0x7D,  1, 0, NULL,
	IDS_PGM7D2,  0x7D,  2, 0, NULL,
	IDS_PGM7D3,  0x7D,  3, 0, NULL,
	IDS_PGM7D4,  0x7D,  4, 0, NULL,
	IDS_PGM7D5,  0x7D,  5, 0, NULL,
	IDS_PGM7D6,  0x7D,  6, 0, NULL,
	IDS_PGM7D7,  0x7D,  7, 0, NULL,
	IDS_PGM7D8,  0x7D,  8, 0, NULL,
	IDS_PGM7D9,  0x7D,  9, 0, NULL,
	IDS_PGM7E0,  0x7E,  0, 0, NULL,
	IDS_PGM7E1,  0x7E,  1, 0, NULL,
	IDS_PGM7E2,  0x7E,  2, 0, NULL,
	IDS_PGM7E3,  0x7E,  3, 0, NULL,
	IDS_PGM7E4,  0x7E,  4, 0, NULL,
	IDS_PGM7E5,  0x7E,  5, 0, NULL,
	IDS_PGM7F0,  0x7F,  0, 0, NULL,
	IDS_PGM7F1,  0x7F,  1, 0, NULL,
	IDS_PGM7F2,  0x7F,  2, 0, NULL,
	IDS_PGM7F3,  0x7F,  3, 0, NULL,

	IDS_PGMEND,     0,  0, 0, NULL   // end of instrument list
};

// Always keep the correct count in this 
const DWORD dwabiDrums = 9;
BInstr abiDrums[] = {
	IDS_DRM000,  0x00,  0, 0, NULL,
	IDS_DRM080,  0x08,  0, 0, NULL,
	IDS_DRM100,  0x10,  0, 0, NULL,
	IDS_DRM180,  0x18,  0, 0, NULL,
	IDS_DRM190,  0x19,  0, 0, NULL,
	IDS_DRM200,  0x20,  0, 0, NULL,
	IDS_DRM280,  0x28,  0, 0, NULL,
	IDS_DRM300,  0x30,  0, 0, NULL,
	IDS_DRM380,  0x38,  0, 0, NULL,

	IDS_PGMEND,     0,  0, 0, NULL   // end of drums list
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InsertSilenceDlg.cpp ===
// InsertSilenceDlg.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "InsertSilenceDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInsertSilenceDlg dialog


CInsertSilenceDlg::CInsertSilenceDlg(DWORD dwSampleRate, CWnd* pParent /*=NULL*/)
	: CDialog(CInsertSilenceDlg::IDD, pParent)
{
	m_dwSampleRate = dwSampleRate;
	m_dwSampleLength = dwSampleRate / 2;
	m_dwSecondLength = 0;
	m_dwMillisecondLength = 500;

	//{{AFX_DATA_INIT(CInsertSilenceDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CInsertSilenceDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInsertSilenceDlg)
	DDX_Control(pDX, IDC_EDIT_SECONDS, m_editSeconds);
	DDX_Control(pDX, IDC_EDIT_SAMPLES, m_editSamples);
	DDX_Control(pDX, IDC_EDIT_MILLISECONDS, m_editMilliseconds);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInsertSilenceDlg, CDialog)
	//{{AFX_MSG_MAP(CInsertSilenceDlg)
	ON_EN_KILLFOCUS(IDC_EDIT_SAMPLES, OnKillfocusEditSamples)
	ON_EN_KILLFOCUS(IDC_EDIT_MILLISECONDS, OnKillfocusEditMilliseconds)
	ON_EN_KILLFOCUS(IDC_EDIT_SECONDS, OnKillfocusEditSeconds)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInsertSilenceDlg message handlers

BOOL CInsertSilenceDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	m_editMilliseconds.LimitText(3);

	SetDlgItemInt( IDC_EDIT_SAMPLES, m_dwSampleLength, FALSE );
	SetDlgItemInt( IDC_EDIT_MILLISECONDS, m_dwMillisecondLength, FALSE );
	SetDlgItemInt( IDC_EDIT_SECONDS, m_dwSecondLength, FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CInsertSilenceDlg::OnKillfocusEditSamples() 
{
	BOOL fSucceeded = FALSE;
	DWORD dwSamples = GetDlgItemInt( IDC_EDIT_SAMPLES, &fSucceeded, FALSE );
	if( !fSucceeded || dwSamples == m_dwSampleLength )
	{
		SetDlgItemInt( IDC_EDIT_SAMPLES, m_dwSampleLength, FALSE );
	}
	else
	{
		// Ensure we're at least one sample long
		dwSamples = max( dwSamples, 1 );

		m_dwSampleLength = dwSamples;
		m_dwSecondLength = dwSamples / m_dwSampleRate;
		m_dwMillisecondLength = ((dwSamples - m_dwSecondLength * m_dwSampleRate) * 1000 + m_dwSampleRate / 2 ) / m_dwSampleRate;

		SetDlgItemInt( IDC_EDIT_MILLISECONDS, m_dwMillisecondLength, FALSE );
		SetDlgItemInt( IDC_EDIT_SECONDS, m_dwSecondLength, FALSE );
		SetDlgItemInt( IDC_EDIT_SAMPLES, m_dwSampleLength, FALSE );
	}
}

void CInsertSilenceDlg::OnKillfocusEditMilliseconds() 
{
	BOOL fSucceeded = FALSE;
	DWORD dwMilliseconds = GetDlgItemInt( IDC_EDIT_MILLISECONDS, &fSucceeded, FALSE );
	if( !fSucceeded || dwMilliseconds == m_dwMillisecondLength )
	{
		SetDlgItemInt( IDC_EDIT_MILLISECONDS, m_dwMillisecondLength, FALSE );
	}
	else
	{
		// Ensure we're at least one millisecond long
		if( m_dwSecondLength == 0 )
		{
			dwMilliseconds = max( dwMilliseconds, 1 );
		}

		m_dwMillisecondLength = dwMilliseconds;
		m_dwSampleLength = ((m_dwMillisecondLength + m_dwSecondLength * 1000) * m_dwSampleRate + 500) / 1000;

		SetDlgItemInt( IDC_EDIT_MILLISECONDS, m_dwMillisecondLength, FALSE );
		SetDlgItemInt( IDC_EDIT_SECONDS, m_dwSecondLength, FALSE );
		SetDlgItemInt( IDC_EDIT_SAMPLES, m_dwSampleLength, FALSE );
	}
}

void CInsertSilenceDlg::OnKillfocusEditSeconds() 
{
	BOOL fSucceeded = FALSE;
	DWORD dwSeconds = GetDlgItemInt( IDC_EDIT_SECONDS, &fSucceeded, FALSE );
	if( !fSucceeded || dwSeconds == m_dwSecondLength )
	{
		SetDlgItemInt( IDC_EDIT_SECONDS, m_dwSecondLength, FALSE );
	}
	else
	{
		// Ensure we're at least one millisecond long
		if( dwSeconds == 0 && m_dwMillisecondLength == 0 )
		{
			m_dwMillisecondLength = 1;
		}

		m_dwSecondLength = dwSeconds;
		m_dwSampleLength = ((m_dwMillisecondLength + m_dwSecondLength * 1000) * m_dwSampleRate + 500) / 1000;

		SetDlgItemInt( IDC_EDIT_MILLISECONDS, m_dwMillisecondLength, FALSE );
		SetDlgItemInt( IDC_EDIT_SECONDS, m_dwSecondLength, FALSE );
		SetDlgItemInt( IDC_EDIT_SAMPLES, m_dwSampleLength, FALSE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InsertSilenceDlg.h ===
#if !defined(AFX_INSERTSILENCEDLG_H__C2999478_1FBB_4E79_8624_B3B7A390A499__INCLUDED_)
#define AFX_INSERTSILENCEDLG_H__C2999478_1FBB_4E79_8624_B3B7A390A499__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// InsertSilenceDlg.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CInsertSilenceDlg dialog

class CInsertSilenceDlg : public CDialog
{
// Construction
public:
	CInsertSilenceDlg(DWORD dwSampleRate, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CInsertSilenceDlg)
	enum { IDD = IDD_INSERT_SILENCE };
	CEdit	m_editSeconds;
	CEdit	m_editSamples;
	CEdit	m_editMilliseconds;
	//}}AFX_DATA

	DWORD GetSampleLength() { return m_dwSampleLength; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInsertSilenceDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CInsertSilenceDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusEditSamples();
	afx_msg void OnKillfocusEditMilliseconds();
	afx_msg void OnKillfocusEditSeconds();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	DWORD	m_dwSampleRate;
	DWORD	m_dwSampleLength;
	DWORD	m_dwSecondLength;
	DWORD	m_dwMillisecondLength;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INSERTSILENCEDLG_H__C2999478_1FBB_4E79_8624_B3B7A390A499__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Instrument.cpp ===
// Instrument.cpp : implementation file
//

#include "stdafx.h"
#include "DlsDefsPlus.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "Collection.h"
#include "Instrument.h"
#include "region.h"
#include "ArticulationList.h"
#include "Articulation.h"
#include "Wave.h"
#include "WaveNode.h"
#include "MonoWave.h"
#include "UndoMan.h"
#include "InstrumentFVEditor.h"
#include "InstrumentPropPgMgr.h"
#include "InstrumentPropPg.h"
#include "resource.h"
#include "JazzDataObject.h"
#include "InstrumentCtl.h"
#include "PatchConflictDlg.h"

#include <dmksctrl.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CInstrument constructor/destructor

CInstrument::CInstrument(CDLSComponent* pComponent) : 

m_nMIDINote(60), 
m_pCollection(NULL),
m_pInstrumentCtrl(NULL),
m_pIRootNode(NULL),
m_pIParentNode(NULL),
m_hWndEditor(NULL),
m_pInstrumentPropPgMgr(NULL),
m_hStopEvent(0),
m_dwDLSize(0),
m_bNewFormat(FALSE),
m_pCurArticulation(NULL),
m_bAuditionMode(AUDITION_MULTIPLE)
{
	ASSERT(pComponent != NULL);

    m_dwRef = 0;
	AddRef();

	m_pComponent = pComponent;
	m_pComponent->AddRef();

	m_Regions.m_pDLSComponent = pComponent;
	m_Regions.m_pInstrument = this;

    m_rInstHeader.Locale.ulBank = 0;
    m_rInstHeader.Locale.ulInstrument = 0;
    m_rInstHeader.cRegions = 0;

	if(m_pInstrumentPropPgMgr == NULL)
	{
		m_pInstrumentPropPgMgr = new CInstrumentPropPgMgr();
	}
	else
	{
		m_pInstrumentPropPgMgr->AddRef();
	}

	GetName();
	memset(m_cMidiNoteOns,0,128 * sizeof(int));

	m_hStopEvent = ::CreateEvent(NULL, TRUE, FALSE, "Oneshot Timeout");

	// Create the Undo Manager
	m_pUndoMgr = new CUndoMan;
	::CoCreateGuid(&m_guidUndoStream);

	CreateDefaultGlobalArticulation();
}

CInstrument::~CInstrument()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	::CloseHandle(m_hStopEvent);

	// If we are in a Property Page Manager we need to remove ourselves before we go away
	IDMUSProdPropSheet *pIPropSheet;
	if(SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**) &pIPropSheet)))
	{
		if(pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
		{
			pIPropSheet->RemovePageManagerByObject(this);
		}
		else
		{
			if(m_pInstrumentPropPgMgr)
			{
				m_pInstrumentPropPgMgr->RemoveObject(this);
			}
		}
		pIPropSheet->Release();
	}

	if(m_pInstrumentPropPgMgr)
	{
		DWORD refCount = m_pInstrumentPropPgMgr->Release();
		if(refCount == 0)
			m_pInstrumentPropPgMgr = NULL;
	}

	while(!m_lstArticulationLists.IsEmpty())
	{
		CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.RemoveHead();
		pArticList->Release();
	}

	if (!m_lstAllocatedBuffers.IsEmpty())
	{
		POSITION position = m_pComponent->m_lstDLSPortDownload.GetHeadPosition();
		while(position)
		{
			IDirectMusicPortDownload* pIDMPortDownload = m_pComponent->m_lstDLSPortDownload.GetNext(position);
			ASSERT(pIDMPortDownload);
			Unload(pIDMPortDownload);
		}
	}

	if(m_pComponent)
	{
		if(m_pComponent->Release() == 0)
			m_pComponent = NULL;
	}

	theApp.FlushClipboard( this );

	delete m_pUndoMgr;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IUnknown implementation

HRESULT CInstrument::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersist) )
    {
        AddRef();
        *ppvObj = (IPersist *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        AddRef();
        *ppvObj = (IPersistStream *)this;
        return S_OK;
    }

	if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CInstrument::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CInstrument::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetNodeImageIndex

HRESULT CInstrument::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnFirstImage);
	
	ASSERT(m_pComponent != NULL);

	return(m_pComponent->GetInstrumentImageIndex(pnFirstImage));
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetComponent

HRESULT CInstrument::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetRootNode

HRESULT CInstrument::GetDocRootNode( IDMUSProdNode** ppIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIRootNode )
	{
		m_pIRootNode->AddRef();
		*ppIRootNode = m_pIRootNode;
		return S_OK;
	}

	*ppIRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::SetRootNode

HRESULT CInstrument::SetDocRootNode( IDMUSProdNode* pIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIRootNode != NULL );

	m_pIRootNode = pIRootNode;
//	m_pIRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetParentNode

HRESULT CInstrument::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::SetParentNode

HRESULT CInstrument::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetNodeId

HRESULT CInstrument::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_InstrumentNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetNodeName

HRESULT CInstrument::GetNodeName(BSTR* pbstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pbstrName);

    // Creates the instrument name and stores it in m_csName
	GetName();
	*pbstrName = m_csName.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetNodeNameMaxLength

HRESULT CInstrument::GetNodeNameMaxLength(short* pnMaxLength)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnMaxLength);
	
	*pnMaxLength = BUFFER_256;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::ValidateNodeName

HRESULT CInstrument::ValidateNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;

	strName = bstrName;
	
	::SysFreeString(bstrName);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::SetNodeName

HRESULT CInstrument::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName = bstrName;
	::SysFreeString( bstrName );

	m_Info.m_csName = strName;

	// Set flag so we know to save file 
 	m_pCollection->SetDirtyFlag();

	if(m_pInstrumentPropPgMgr)
	{
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
			{
				m_pInstrumentPropPgMgr->RefreshData();
				m_pInstrumentPropPgMgr->m_pInstrumentPage->OnSetActive();
			}
			
			RELEASE(pIPropSheet);
		}
	} 
	
	// Change the name in the transport
	if(m_pInstrumentCtrl)
			m_pInstrumentCtrl->SetTransportName();

	if(m_pComponent->m_pIFramework)
		m_pComponent->m_pIFramework->NotifyNodes(m_pCollection, INSTRUMENT_NameChange, NULL);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetEditorClsId

HRESULT CInstrument::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pClsId = CLSID_Instrument;
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetEditorTitle

HRESULT CInstrument::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strTitle;

	strTitle = _T("Instrument: ");
	strTitle += m_csName;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetEditorWindow

HRESULT CInstrument::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::SetEditorWindow

HRESULT CInstrument::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::UseOpenCloseImages

HRESULT CInstrument::UseOpenCloseImages(BOOL* pfUseOpenCloseImages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pfUseOpenCloseImages);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetRightClickMenuId

HRESULT CInstrument::GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMenuId);
	ASSERT(phInstance);

	if(phInstance == NULL
	|| pnMenuId == NULL)
	{
		return E_POINTER;
	}

	*phInstance = theApp.m_hInstance;
	*pnMenuId = IDM_INSTRUMENT_NODE_RMENU;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::OnRightClickMenuInit

HRESULT CInstrument::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // If there is a global articulation, disable the insert articulation
    // menuitem
    /* (m_pArticulation)
    {
        CMenu menu;
 	    if( menu.Attach(hMenu) )
        {
			menu.EnableMenuItem( IDM_INSERT_ART, (MF_GRAYED | MF_BYCOMMAND) );
        }
        menu.Detach();
    }*/
   
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::OnRightClickMenuSelect

HRESULT CInstrument::OnRightClickMenuSelect(long lCommandId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	HRESULT hr = E_FAIL;
	IDMUSProdNode* pIParentNode;
	
	switch( lCommandId )
	{
		case IDM_OPEN:
		{
			if(SUCCEEDED(m_pComponent->m_pIFramework->OpenEditor(this)))
			{
				hr = S_OK;
			}
			break;
		}

		case IDM_INSERT_ART_LIST:
		{
			SaveStateForUndo(IDS_UNDO_INSERT_ARTLIST);
			InsertChildNode(NULL);			
			hr = S_OK;
			break;
		}

		case IDM_CUT:
		{
			if(CanCut() == S_OK)
			{
				IDataObject* pIDataObject = NULL;
				if(SUCCEEDED(CreateDataObject(&pIDataObject)))
				{
					if(theApp.PutDataInClipboard( pIDataObject, this))
					{
						DeleteNode(FALSE);
						if(m_pComponent->m_pIFramework)
							m_pComponent->m_pIFramework->NotifyNodes(m_pCollection, INSTRUMENT_Deleted, NULL);
						hr = S_OK;
					}
					pIDataObject->Release();
					pIDataObject = NULL;
				}
			}
			break;
		}

		case IDM_COPY:
		{
			if(CanCopy() == S_OK)
			{
				IDataObject* pIDataObject = NULL;
				if(SUCCEEDED(CreateDataObject(&pIDataObject)))
				{
					if(theApp.PutDataInClipboard( pIDataObject, this))
					{
						hr = S_OK;
					}
					pIDataObject->Release();
					pIDataObject = NULL;
				}
			}
			break;
		}

		case IDM_DELETE:
		{
			if(SUCCEEDED(GetParentNode(&pIParentNode)))
			{
				if(SUCCEEDED(pIParentNode->DeleteChildNode((IDMUSProdNode *)this, TRUE)))
				{
					hr = S_OK;				
				}
				pIParentNode->Release();
			}
			break;
		}

		case IDM_RENAME:
		{
			if(SUCCEEDED(m_pComponent->m_pIFramework->EditNodeLabel((IDMUSProdNode *)this)))
			{
				hr = S_OK;
			}
			break;
		}
		
		case IDM_PROPERTIES:
		{
			if(SUCCEEDED(OnShowProperties()))
			{
				hr = S_OK;
			}
			break;
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::DeleteChildNode

HRESULT CInstrument::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIChildNode != NULL);
	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	bool bIsSafeToDelete = true;

	UINT nGlobalArts = GetArticulationCount();

	CRegion* pRegion = m_Regions.GetHead();
	if(nGlobalArts == 0)
	{
		// Before we can delete the Global Articulation we want to make sure that
		// each Region has its own articulation
		ASSERT(pRegion);
		for(; pRegion && bIsSafeToDelete; pRegion = pRegion->GetNext())
		{
			if(pRegion->GetArticulationCount() == 0)
			{
				bIsSafeToDelete = false;
			}
		}
	}

	// Remove node from Project Tree
	if(!bIsSafeToDelete || m_pComponent->m_pIFramework->RemoveNode(pIChildNode, fPromptUser) == S_FALSE)
	{
		return E_FAIL;
	}

	// Remove it from the list of articulation lists 
	POSITION position = m_lstArticulationLists.Find(dynamic_cast<CArticulationList*>(pIChildNode));
	if(position)
	{
		m_lstArticulationLists.RemoveAt(position);
	}

	pIChildNode->Release();
	
	m_pCurArticulation = NULL;
	SetFirstGlobaArtAsCurrent();

	// Set flag so we know to save file 
	m_pCollection->SetDirtyFlag();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::InsertChildNode

HRESULT CInstrument::InsertChildNode(IDMUSProdNode* pIChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);
	
	if(pIChildNode == NULL)
	{
		pIChildNode = new CArticulationList(m_pComponent, this);

		if(pIChildNode == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		pIChildNode->AddRef();
	}

	m_lstArticulationLists.AddTail((CArticulationList*)pIChildNode);
	m_pCurArticulation = ((CArticulationList*)pIChildNode)->GetHead();
	
	// Set root and parent node of ALL children
	theApp.SetNodePointers(pIChildNode, (IDMUSProdNode *)m_pCollection, (IDMUSProdNode *)this);

	// Add node to Project Tree
	if(!SUCCEEDED(m_pComponent->m_pIFramework->AddNode(pIChildNode, (IDMUSProdNode *)this)))
	{
		DeleteChildNode(pIChildNode, FALSE);
		return E_FAIL;
	}

	// Set flag to indicate the DLS collection now needs to be saved
	m_pCollection->SetDirtyFlag();

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::DeleteNode

HRESULT CInstrument::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIParentNode;

	if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			pIParentNode->Release();
			return hr;		
		}
	}
	return E_FAIL;
}

//////////////////////////////////////////////////////////////////////
//
//	CInstrument IDMUSProdNode::GetFirstChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::GetFirstChild(IDMUSProdNode** ppIFirstChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppIFirstChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppIFirstChildNode = NULL;

	IDMUSProdNode* pINode = static_cast<IDMUSProdNode*>(&m_Regions);

	if(pINode)
	{
		pINode->AddRef();
		*ppIFirstChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CInstrument IDMUSProdNode::GetNextChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppINextChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppINextChildNode = NULL;

	if(pIChildNode == NULL)
	{
		return E_INVALIDARG;
	}

	IDMUSProdNode* pINode = NULL;

	POSITION position = NULL;
	CArticulationList* pArticList = dynamic_cast<CArticulationList*>(pIChildNode);
	if(pArticList)
	{
		position = m_lstArticulationLists.Find(pArticList);
	}
	
	if(pIChildNode == dynamic_cast<IDMUSProdNode*>(&m_Regions))
	{
		if(!m_lstArticulationLists.IsEmpty())
		{
			pINode = dynamic_cast<IDMUSProdNode*>(m_lstArticulationLists.GetHead());
		}
	}
	else if(position)		
	{
		CArticulationList* pPassedArticList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
		if(position)
		{
			pArticList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
			pINode = dynamic_cast<IDMUSProdNode*>(pArticList);
		}
	}

	if(pINode)
	{
		pINode->AddRef();
		*ppINextChildNode = pINode;
	}
	else
	{
		*ppINextChildNode = NULL;
	}
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CInstrument IDMUSProdNode::GetNodeListInfo
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::GetNodeListInfo(DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pListInfo);
	
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::OnNodeSelChanged

HRESULT CInstrument::OnNodeSelChanged(BOOL fSelected)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = S_OK;
	
	TurnOffMidiNotes();
	if(m_pInstrumentCtrl)
	{
		m_pInstrumentCtrl->TurnOffMidiNotes();
	}

	if(fSelected)
	{
		ASSERT(m_pComponent != NULL);
		ASSERT(m_pComponent->m_pIFramework != NULL);
		if(m_pInstrumentCtrl)
		{
			m_pInstrumentCtrl->SetTransportName();
			m_pComponent->m_pIConductor->SetActiveTransport(this, BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE);
			UpdatePatch();
		}
	}	
	/*else
	{
		TRACE("Instrument Control: OnNodeSel - NOTSELECTED\n");
		
		m_pComponent->m_pIConductor->TransportStopped(this);
		m_pComponent->m_pIConductor->SetBtnStates(this, BS_NO_AUTO_UPDATE);
	}*/
	return hr; 
}



/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IDMUSProdNode::CreateDataObject
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;
	// Save Instrument into stream
	HRESULT hr = E_FAIL;
	if( SUCCEEDED ( m_pComponent->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		//if( SUCCEEDED (Save( pIStream, FALSE ) ) )
		IDMUSProdRIFFStream* pRiffStream = NULL;

		hr = AllocRIFFStream(pIStream, &pRiffStream);                
		if (SUCCEEDED(hr))
		{
			hr = Save(pRiffStream, TRUE);  //fullsave is true.
		}

		// Place CF_INSTRUMENT into CDllJazzDataObject
		if( SUCCEEDED ( pDataObject->AddClipFormat(m_pComponent->m_cfInstrument, pIStream ) ) )
		{
			hr = S_OK;
		}
	
		// We also need to copy all the waves...
		// m_bDragCopy flag helps in not copying multiple copies of a wave referenced by multiple regions
		CRegion* pRegion = m_Regions.GetHead();
		for ( ; pRegion; pRegion = pRegion->GetNext())
		{
			if(pRegion->m_pWave == NULL)
			{
				continue;
			}

			CWaveNode* pWaveNode = pRegion->GetWaveNode();
			ASSERT(pWaveNode);
			if(pWaveNode && pWaveNode->GetDragCopy() == false)
			{
				if(FAILED(pWaveNode->WriteDragChunkToStream(pRiffStream)))
				{
					pIStream->Release();
					pRiffStream->Release();
					return E_FAIL;
				}
			}
		}

		// Clear the dragCopy flags now...
		pRegion = m_Regions.GetHead();
		for ( ; pRegion; pRegion = pRegion->GetNext())
		{
			CWaveNode* pWaveNode = pRegion->GetWaveNode();
			ASSERT(pWaveNode);
			if(pWaveNode)
			{
				pWaveNode->SetDragCopy(false);
			}
		}


		// Place CF_WAVE into CDllJazzDataObject
		if( SUCCEEDED ( pDataObject->AddClipFormat(m_pComponent->m_cfWave, pIStream ) ) )
		{
			hr = S_OK;
		}

		if (pRiffStream)
		{
			pRiffStream->Release();
		}
		


		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IDMUSProdNode::CanCut
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::CanCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IDMUSProdNode::CanCopy
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::CanCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IDMUSProdNode::CanDelete
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::CanDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IDMUSProdNode::CanDeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IDMUSProdNode::CanPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfInstrument)))
    {
        hr = S_OK;
    }

    pDataObject->Release();

    return hr;

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IDMUSProdNode::PasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Pass it to the parent to paste.
    ASSERT(m_pIParentNode != NULL);
	return m_pIParentNode->ChildPasteFromData( pIDataObject, this );

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IDMUSProdNode::CanChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										    BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IDMUSProdNode::ChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdNode::GetObject

HRESULT CInstrument::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdPropPageObject::GetData

HRESULT CInstrument::GetData(void** ppData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(ppData);
	*ppData = this;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdPropPageObject::SetData

HRESULT CInstrument::SetData(void* pData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CInstrument::OnRemoveFromPageManager(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject::OnShowProperties

HRESULT CInstrument::OnShowProperties(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	// Show the Collection properties
	IDMUSProdPropSheet* pIPropSheet;

	hr = m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet);
	if(SUCCEEDED(hr))
	{
		hr = pIPropSheet->SetPageManager(m_pInstrumentPropPgMgr);
		
		if(SUCCEEDED(hr))
		{
			m_pInstrumentPropPgMgr->SetObject(this);
			pIPropSheet->SetActivePage( 0 ); 
		}

		pIPropSheet->Show(TRUE);
		pIPropSheet->Release();
	}

	return hr;
}

UINT AFX_CDECL StopResetFunction(LPVOID pParam)
{
	StopResetTimeEvent* resetTimeEvent = (StopResetTimeEvent*) pParam;
	
	WaitForSingleObject(resetTimeEvent->pInstrument->m_hStopEvent, resetTimeEvent->lWaitTime);

	resetTimeEvent->pInstrument->Stop( TRUE );
	TRACE("Killing update thread\n");
	::AfxEndThread(0);

	return 0;
}



// =================================================================================
// IDMUSProdTransport methods
// =================================================================================
HRESULT CInstrument::Play(BOOL /*fPlayFromStart*/)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	ResetEvent(m_hStopEvent);
	bool bOneShot = true;

	// Return failure if we don't have a valid port to play the instrument
	if(m_pComponent->m_lstDLSPortDownload.IsEmpty())
	{
		AfxMessageBox(IDS_ERR_NO_PORT, MB_OK | MB_ICONEXCLAMATION);
		return E_FAIL;
	}

    HRESULT hr = S_OK;
	if (m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_pWave == NULL)
	{
		return hr;
	}
    
	int nRootNote = m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_rWSMP.usUnityNote;
	
	// Check if the note we're playing belongs to the region or not
	// If not then change it to the nearest note in the region
	if(m_nMIDINote < m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_rRgnHeader.RangeKey.usLow)
	{
		m_nMIDINote = m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_rRgnHeader.RangeKey.usLow;
	}
	else if(m_nMIDINote > m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_rRgnHeader.RangeKey.usHigh)
	{
		m_nMIDINote = m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_rRgnHeader.RangeKey.usHigh;
	}

	// This is the number of semitones the note is shifted by
	// If the playing note is higher then the time to play the wave will go down by
	// 1.059463094359 for each semitone....
	long lPitchShift = m_nMIDINote - nRootNote ;
	int nShiftDirection = 1;
	if(lPitchShift != 0)
	{
		nShiftDirection = lPitchShift/abs(lPitchShift);
	}

	// 1.059463094359 is 12th root of 2; 0.9438743126817 is 1/12th root of 2
	// If the pitch is shifted up then we have to divide by 12th root of 2
	// If the pitch is shifted down then we have to divide by 12th root of 2
	float fTimeShiftFactor = (float)(nShiftDirection < 0 ? 1.059463094359 : 0.9438743126817);

	m_cMidiNoteOns[m_nMIDINote]++;
    hr = m_pComponent->PlayMIDIEvent(MIDI_NOTEON,
										(BYTE)m_nMIDINote,
										DEFAULT_VELOCITY, 
										5, // Give enough time for the UpdatePatch to apply
										IsDrum());   
    if (SUCCEEDED(hr))
    {
		if( (m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_bOverrideWaveMoreSettings &&
		     m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_rWSMP.cSampleLoops) ||	
			 (m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_pWave->GetNumberOfLoops()) )
		{	// we're looping. Enable the Stop button.
			bOneShot = false;
		}
		if(bOneShot)
		{
			CWave* pPlayingWave = m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_pWave;

			m_ResetCallBackParams.lWaitTime = (long) ((DWORD)1000*((float)pPlayingWave->m_dwWaveLength / pPlayingWave->m_rWaveformat.nSamplesPerSec));
			for(int nSemiTones = 0; nSemiTones < abs(lPitchShift); nSemiTones++)
				m_ResetCallBackParams.lWaitTime = (long) (m_ResetCallBackParams.lWaitTime * fTimeShiftFactor);

			
			m_ResetCallBackParams.pInstrument = this;

			CWinThread* pUpdateThread = ::AfxBeginThread(StopResetFunction, &m_ResetCallBackParams);
			pUpdateThread->m_bAutoDelete = TRUE;
		}

		m_pComponent->m_pIConductor->SetBtnStates(this, BS_PLAY_CHECKED | BS_STOP_ENABLED | BS_NO_AUTO_UPDATE);
    }
    return hr;
}



HRESULT CInstrument::Stop( BOOL /*fStopImmediate*/ )
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	SetEvent(m_hStopEvent);
    HRESULT hr = S_OK;
    {
       hr = m_pComponent->PlayMIDIEvent(MIDI_NOTEOFF,
										(BYTE)m_nMIDINote,
										DEFAULT_VELOCITY,
             							6,
										IsDrum());
       if (SUCCEEDED(hr))
       {
            m_pComponent->m_pIConductor->SetBtnStates(this, BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE);
			if (m_cMidiNoteOns[m_nMIDINote] > 0)
				m_cMidiNoteOns[m_nMIDINote]--;
       }
    }
    return S_OK;
}

HRESULT CInstrument::Transition ( )
{
    return E_NOTIMPL;
}

HRESULT CInstrument::Record( BOOL fPressed )
{
	return E_NOTIMPL;
}

HRESULT CInstrument::GetName(BSTR* pbstrName)
{
	return E_NOTIMPL;
}

HRESULT CInstrument::TrackCursor( BOOL fTrackCursor )
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument Additional functions

/////////////////////////////////////////////////////////////////////////////
// CInstrument::Save

HRESULT CInstrument::Save(IDMUSProdRIFFStream* pIRiffStream, bool fFullSave)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT			hr = S_OK;			// Return code
    MMCKINFO		ick;
    MMCKINFO		ck;
	DWORD			cb;
    CRegion *        pRegion;

	IStream*		pIStream;
	pIStream = pIRiffStream->GetStream();

    ick.fccType = FOURCC_INS ;
    hr = pIRiffStream->CreateChunk(&ick,MMIO_CREATELIST);
    if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }

    ck.ckid = FOURCC_INSH ;
    hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }
	m_rInstHeader.cRegions = m_Regions.GetChannelCount();
	hr = pIStream->Write((LPSTR) &m_rInstHeader,sizeof(INSTHEADER), &cb);	
	if (FAILED(hr) || cb != sizeof(INSTHEADER))
	{
		pIStream->Release();
		return (hr);
	}
	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return (E_FAIL);
	}
	ck.fccType = FOURCC_LRGN ;
	hr = pIRiffStream->CreateChunk(&ck,MMIO_CREATELIST);
	if (FAILED(hr))
	{
		pIStream->Release();
		return (hr);
	}
	pRegion = m_Regions.GetHead();
	USHORT usRegionSaved = 1;
	for ( ; pRegion; pRegion = pRegion->GetNext())
	{
		hr = pRegion->Save(pIRiffStream, fFullSave, usRegionSaved++);
		if (FAILED(hr)) 
		{
			pIStream->Release();
			return(hr);
		}
	}
	pIRiffStream->Ascend(&ck, 0);

	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
		ASSERT(pArticList);
		if(pArticList)
		{
			hr = pArticList->Save(pIRiffStream);
			if (FAILED(hr)) 
			{
				pIStream->Release();
				return(hr);
			}
		}
	}

    m_Info.Save(pIRiffStream);
    
    //save unknown chunks
    m_UnknownChunk.Save(pIRiffStream);

    pIRiffStream->Ascend(&ick, 0);
	pIStream->Release();
    return (hr);
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument::Load

HRESULT CInstrument::Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IStream* pIStream = NULL;
	MMCKINFO ck;
	DWORD cb = 0;
	DWORD cSize = 0;
    HRESULT	hr = S_OK;

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Remove all previous regions
	DeleteAllRegions();
	// Remove all previous articulation lists
	DeleteArticulationLists();

	ck.ckid = 0;
	ck.fccType = 0;
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_INSH :
			{
			    if ( ck.cksize < sizeof(INSTHEADER) )
				{
					cSize = ck.cksize;
					if (ck.cksize < DLS_1_INST_HEADER_SIZE)
					{
						//To Do: message box
						//pIStream->Release();
						//return E_FAIL;
					}
				}
				else
				{
					cSize = sizeof(INSTHEADER);
				}
				hr = pIStream->Read( &m_rInstHeader, cSize, &cb );
                if( FAILED(hr) || cb != cSize )
				{
					pIStream->Release();
					return (hr);
				}
				break;
			}
			case FOURCC_LIST :
			{
				switch (ck.fccType)
				{
					case FOURCC_LRGN :
						if(FAILED(hr = m_Regions.Load(pIRiffStream,&ck)))
						{
							pIStream->Release();
							return hr;
						}
						break;
                    case mmioFOURCC('I','N','F','O') :
                        m_Info.Load(pIRiffStream,&ck);
                        break;

					case FOURCC_LART :
					case FOURCC_LAR2 :
                    {
						BOOL bDLS1 = FALSE;
						if(ck.fccType == FOURCC_LART)
						{
							bDLS1 = TRUE;
						}

						CArticulationList* pArticList = new CArticulationList(m_pComponent, this);
						if(pArticList)
						{
							pArticList->SetDLS1(bDLS1);
							
							hr = pArticList->Load(pIRiffStream, &ck);
							if(FAILED(hr))
							{
								delete pArticList;
								pIStream->Release();
								return hr;
							}
							m_lstArticulationLists.AddTail(pArticList);
						}
						else
						{
							pIStream->Release();
							return E_OUTOFMEMORY;
						}
			
                    }
					break;

                    default:
                        m_UnknownChunk.Load(pIRiffStream, &ck, TRUE);
                        break;
				}
				break;
			}

            case mmioFOURCC('e','d','i','t'): // Ignore edits while loading.
                break;

            default:
                m_UnknownChunk.Load(pIRiffStream, &ck, FALSE);
                break;

		}

        pIRiffStream->Ascend( &ck, 0 );
    }
	
	pIStream->Release();

	SetFirstGlobaArtAsCurrent();

	if (m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS)
		m_Regions.SetDrumArticulation();

	m_Regions.ValidateUIA();

    return hr;
}

// Sets the first global articulation as the current articulation
// If there're no global articulations we look for the first region level articulation
void CInstrument::SetFirstGlobaArtAsCurrent()
{
	// Set the very first articulation as the current articulation for this instrument
	// We might not have any global articulations in which case we need to find the first one at the regions level
	if(m_lstArticulationLists.GetCount() != 0)
	{
		CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.GetHead();
		ASSERT(pArticList);
		if(pArticList)
		{
			CArticulation* pArticulation = pArticList->GetHead();
			m_pCurArticulation = pArticulation;
			if(m_pCurArticulation && m_pInstrumentCtrl)
			{
				CInstrumentFVEditor* pEditor = m_pInstrumentCtrl->m_pInstrumentEditor;
				ASSERT(pEditor);
				if(pEditor)
				{
					pEditor->SetCurArticulation(pArticulation);
				}
			}
		}
	}
	else if(m_Regions.GetCount() > 0)
	{
		m_pCurArticulation = NULL;
		if(NoArtForEveryRegion())
		{
			CreateDefaultGlobalArticulation();
			ASSERT(m_pCurArticulation);
			if(m_pCurArticulation && m_pInstrumentCtrl)
			{
				m_pInstrumentCtrl->m_pInstrumentEditor->SetCurArticulation(m_pCurArticulation);
			}
		}
		else
		{
			CRegion* pRegion = m_Regions.GetHead();
			ASSERT(pRegion);
			pRegion->SetCurrentArtInEditor();
		}
	}
	else
	{
		CreateDefaultGlobalArticulation();
		ASSERT(m_pCurArticulation);
		if(m_pCurArticulation && m_pInstrumentCtrl)
		{
			m_pInstrumentCtrl->m_pInstrumentEditor->SetCurArticulation(m_pCurArticulation);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CInstrument::GetMaxVolume

GCENT CInstrument::GetMaxVolume()
{
	CRegion* pRegion;
	GCENT gcMax = -9600 << 16;
    
	pRegion = m_Regions.GetHead();
    for( ; pRegion != NULL; pRegion = pRegion->GetNext())
    {
		if(pRegion->m_rWSMP.lAttenuation > gcMax)
		{
			gcMax = pRegion->m_rWSMP.lAttenuation;
		}
	}

	return gcMax;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument::UpdatePatch

void CInstrument::UpdatePatch()
{
	DWORD       dwMIDIBank;
	WORD		nMIDIPatch;

	nMIDIPatch = (WORD) m_rInstHeader.Locale.ulInstrument;
    dwMIDIBank = m_rInstHeader.Locale.ulBank;

	m_pComponent->PlayMIDIEvent(MIDI_CCHANGE,CC_BANKSELECTH,(BYTE)((dwMIDIBank >> 8) & 0x7F),0, IsDrum());
    m_pComponent->PlayMIDIEvent(MIDI_CCHANGE,CC_BANKSELECTL,(BYTE)(dwMIDIBank & 0x7F),1, IsDrum());
    m_pComponent->PlayMIDIEvent(MIDI_PCHANGE,nMIDIPatch & 0x7F,0,2, IsDrum());
	m_pComponent->PlayMIDIEvent(MIDI_CCHANGE,CC_VOLUME,100,3, IsDrum());
	m_pComponent->PlayMIDIEvent(MIDI_CCHANGE,CC_EXPRESSION,127,4, IsDrum());
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument::UpdateInstrument

HRESULT CInstrument::UpdateInstrument()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	HRESULT hr = S_OK;

	if(m_pComponent->m_lstDLSPortDownload.IsEmpty())
		return E_FAIL;

	POSITION position = m_pComponent->m_lstDLSPortDownload.GetHeadPosition();
	while(position)
	{
		IDirectMusicPortDownload* pIDMPortDownload = m_pComponent->m_lstDLSPortDownload.GetNext(position);
		ASSERT(pIDMPortDownload);

        // Keep the old download ID
        if(FAILED(GetDMIDForPort(pIDMPortDownload, &m_dwId)))
        {
            return E_FAIL;
        }

		// Unload the old instrument
		if(FAILED(Unload(pIDMPortDownload)))
			return E_FAIL;

		// Compute the new buffer size
		hr = Size(m_dwDLSize);
		if (m_dwDLSize)
		{
			// Add prepend and append amount to download buffer size
			DWORD dwAppendValue = 0;
			if(FAILED(m_pComponent->GetAppendValueForPort(pIDMPortDownload, &dwAppendValue)))
				return E_FAIL;

			m_dwDLSize += dwAppendValue;

			// Allocate a download buffer
			IDirectMusicDownload* pIDMDownload;
			hr = pIDMPortDownload->AllocateBuffer(m_dwDLSize, &pIDMDownload);
			if (!SUCCEEDED(hr))
			{
				AfxMessageBox(IDS_ERR_UPDATE_ALLOC,MB_OK | MB_ICONEXCLAMATION);
				return hr;
			}
			
			// Add to the list of allocated buffers
			AllocatedPortBufferPair* pAllocatedBuffer = new AllocatedPortBufferPair(pIDMPortDownload, pIDMDownload);
			if(pAllocatedBuffer == NULL)
				return E_OUTOFMEMORY;

            pAllocatedBuffer->SetDMID(m_dwId);

			m_lstAllocatedBuffers.AddTail(pAllocatedBuffer);

			hr = Download(pIDMPortDownload);
			if (!SUCCEEDED(hr))
			{
				// Remove the added buffer
				if(pAllocatedBuffer)
					RemoveFromAllocatedBufferList(pAllocatedBuffer);

				AfxMessageBox(IDS_ERR_UPDATE_DOWNLOAD, MB_OK | MB_ICONEXCLAMATION);
			}
		}
		else
		{
	#ifdef _DEBUG
			AfxMessageBox(IDS_ERR_ZERO_SIZE_INS, MB_OK | MB_ICONEXCLAMATION);
	#endif
			hr = E_FAIL;
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument::GetName

void CInstrument::GetName()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CString		csFormatStr;
	CString		csDrumKitStr;
	char* pszTemp;
	DWORD	dwSize;

	csDrumKitStr.LoadString(IDS_DRUM_KIT_SUFFIX);
	m_Info.m_csName.TrimRight();
    if(m_Info.m_csName.IsEmpty() || m_Info.m_csName == "")
    {
		pszTemp = new char[BUFFER_128];
		csFormatStr.LoadString(IDS_BLANK_INST_NAME_FORMAT);
        sprintf(pszTemp,csFormatStr,
			    (m_rInstHeader.Locale.ulBank >> 8) & 0x7F,
				m_rInstHeader.Locale.ulBank & 0x7F,
				m_rInstHeader.Locale.ulInstrument);
    }
    else
    {
		csFormatStr.LoadString(IDS_INST_NAME_FORMAT);
		int nSeparatorIndex  = m_Info.m_csName.Find(_T(":"));
		if(nSeparatorIndex != -1)
			m_Info.m_csName = m_Info.m_csName.Left(nSeparatorIndex);
		dwSize = m_Info.m_csName.GetLength() + csFormatStr.GetLength() + csDrumKitStr.GetLength() + 3;
		pszTemp = new char[dwSize];
		
        sprintf(pszTemp,csFormatStr,(LPCTSTR)m_Info.m_csName,
                (m_rInstHeader.Locale.ulBank >> 8) & 0x7F,
                m_rInstHeader.Locale.ulBank & 0x7F,
                m_rInstHeader.Locale.ulInstrument);
    }
    
	if(F_INSTRUMENT_DRUMS & m_rInstHeader.Locale.ulBank)
    {
        strcat(pszTemp,": Drum Kit");
    }

	m_csName = pszTemp;
	delete pszTemp;
}

void CInstrument::GetName(CString& sName)
{
	sName = m_Info.m_csName;
}
/////////////////////////////////////////////////////////////////////////////
// CInstrument IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CInstrument IPersist::GetClassID

HRESULT CInstrument::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IPersistStream::IsDirty
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::IsDirty()
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IPersistStream::GetSizeMax
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IPersistStream::Load
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::Load(IStream* pIStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ULONG ulBytesRead = 0;

	UINT nLayers = 4;
	HRESULT hr = pIStream->Read((void *)&nLayers, sizeof(UINT), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(UINT)) 
	{
		return E_FAIL; 
	}

	m_Regions.SetNumberOfLayers(nLayers);
	
	// Check the number of articulation lists in the stream
	int nArtListCount = 0;
	hr = pIStream->Read((void *)&nArtListCount, sizeof(int), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(int)) 
	{
		return E_FAIL; 
	}

	int nExistentArtLists = m_lstArticulationLists.GetCount();
	if(nArtListCount < nExistentArtLists)
	{
		for(int nCount = 0; nCount < (nExistentArtLists	- nArtListCount); nCount++)
		{
			CArticulationList* pArtList = (CArticulationList*)m_lstArticulationLists.RemoveHead();
			ASSERT(pArtList);
			CArticulation* pArt = (CArticulation*) pArtList->GetHead();
			while(pArt)
			{
				pArt->SetDeleteFlag(true);
				pArt = pArt->GetNext();
			}

			m_pComponent->m_pIFramework->RemoveNode(pArtList, FALSE);
			pArtList->Release();
		}
	}
	else if(nArtListCount > nExistentArtLists)
	{
		for(int nCount = 0; nCount < (nArtListCount - nExistentArtLists); nCount++)
		{
			InsertChildNode(NULL);
		}
	}

	// Now load up all Articulation lists
	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArtList = (CArticulationList*)m_lstArticulationLists.GetNext(position);
		ASSERT(pArtList);
		if(pArtList)
		{
			if(FAILED(hr = pArtList->Load(pIStream)))
			{
				return E_FAIL;
			}
		}
	}


	// Read the region selection values
	int nStartNote = 0;
	hr = pIStream->Read((void *)&nStartNote, sizeof(int), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(int)) 
	{
		return E_FAIL; 
	}

	int nLayer = 0;
	hr = pIStream->Read((void *)&nLayer, sizeof(int), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(int)) 
	{
		return E_FAIL; 
	}

	// Read the instrument header
	hr = pIStream->Read((void *)&m_rInstHeader, sizeof(INSTHEADER), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(INSTHEADER))
	{
		return E_FAIL; 
	}

	// Manage loading the regions
	int nRegionCount = m_rInstHeader.cRegions;
	int nExistentRegions = m_Regions.GetCount();
	if(nRegionCount < nExistentRegions)
	{
		for(int nCount = 0; nCount < (nExistentRegions - nRegionCount); nCount++)
		{
			CRegion* pRegion = m_Regions.GetHead();
			if(pRegion == NULL)
			{
				break;
			}

			IDMUSProdNode* pParentNode = NULL;
			pRegion->GetParentNode(&pParentNode);
			if(pParentNode)
			{
				pRegion->m_bDeletingRegion = true;
				// Delete the region nodes
				m_Regions.m_pDLSComponent->m_pIFramework->RemoveNode(pRegion, false);

				CInstrumentFVEditor* pIE = GetInstrumentEditor();
				if(pIE)
				{
					pIE->m_RegionKeyBoard.DeleteRegion(short(pRegion->GetLayer()), pRegion->m_rRgnHeader.RangeKey.usLow);
					pIE->SendRegionChange();
				}
				// Remove from list
				m_Regions.Remove(pRegion);
				pRegion->Release();

				pParentNode->Release();
			}
		}
	}

	CRegion* pRgn = m_Regions.GetHead();
	for(; nRegionCount > 0 ; pRgn = pRgn->GetNext(), nRegionCount--)
	{
		if(pRgn == NULL)
		{
			pRgn = new CRegion(m_Regions.m_pDLSComponent);
			pRgn->m_pInstrument = this;
			m_Regions.InsertRegion((IDMUSProdNode*)pRgn, pRgn->GetLayer(), pRgn->m_rRgnHeader.RangeKey.usLow, pRgn->m_rRgnHeader.RangeKey.usHigh);
		}
		// Get pRgn IPersistStream interface pointer
		IPersistStream* pIPStream = NULL;
		if(SUCCEEDED(pRgn->QueryInterface(IID_IPersistStream, (void **) &pIPStream)))
		{
			hr = pIPStream->Load(pIStream);
			pIPStream->Release();
			if(FAILED(hr)) 
			{
				return E_FAIL;
			}
		}
		else
		{
			return E_FAIL; 
		}

		m_pComponent->m_pIFramework->RefreshNode(pRgn);
	}

	// This checks if a region was deleted last and 
	// if this comes through the undo then selects that region as the current region
	CRegion* pRegion = m_Regions.GetHead();
	for(; pRegion; pRegion = pRegion->GetNext())
	{
		if(pRegion->m_bLastDeleted)
		{
			nStartNote = pRegion->m_rRgnHeader.RangeKey.usLow;
			nLayer = pRegion->GetLayer();
			GetInstrumentEditor()->m_pCurRegion = NULL;
			pRegion->m_bLastDeleted = false;
			break;
		}
	}

	if(nStartNote >= 0 && nLayer >= 0 && GetInstrumentEditor() && !IsPropertyPageShowing())
		GetInstrumentEditor()->OnRegionSelectedChangedRegionRegionkeyboard(short(nLayer), short(nStartNote));

	if(!LoadString(pIStream, m_Info.m_csName))
		return false;

	if(!LoadString(pIStream, m_Info.m_csSubject))
		return false;

	if(!LoadString(pIStream, m_Info.m_csEngineer))
		return false;

	if(!LoadString(pIStream, m_Info.m_csCopyright))
		return false;

	if(!LoadString(pIStream, m_Info.m_csComment))
		return false;

	return S_OK;
}

bool CInstrument::LoadString(IStream* pIStream, CString& sData)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
		return false;


	HRESULT hr = E_FAIL;
	DWORD	cb = 0;
	int		nStringLength = 0;
	CString sTempData; 

	hr = pIStream->Read((void*)&nStringLength, sizeof(int), &cb);
	if(FAILED(hr) || cb != sizeof(int))
		return false;

	char* szTempDataBuffer = sTempData.GetBufferSetLength(nStringLength);
	hr = pIStream->Read((void*)szTempDataBuffer, nStringLength, &cb);
	if(FAILED(hr) || cb != (DWORD)nStringLength)
		return false;

	sTempData.ReleaseBuffer(nStringLength);
	sData = sTempData;

	return true;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrument IPersistStream::Save
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrument::Save(IStream* pIStream, BOOL fClearDirty)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ULONG ulBytesWritten = 0;

	// Save the number of layers
	UINT nLayers = m_Regions.GetNumberOfLayers();
	HRESULT hr = pIStream->Write((void*)&nLayers, sizeof(UINT), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(UINT)) 
	{
		return E_FAIL;
	}
	

	// If there is no global articulation we have to note that on the  stream
	int nCount = GetArticulationCount() ? 1 : 0;
	int nArtListCount = m_lstArticulationLists.GetCount();
	hr = pIStream->Write((void*)&nArtListCount, sizeof(int), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(int)) 
	{
		return E_FAIL;
	}

	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArtList = (CArticulationList*)m_lstArticulationLists.GetNext(position);
		if(pArtList)
		{
			if(FAILED(hr = pArtList->Save(pIStream, FALSE)))
			{
				return E_FAIL;
			}
		}
	}

	// Save the region that's currently selected so we can select it back on undo/redo
	int nStartNote = -1;
	int nLayer = -1;
	if(GetInstrumentEditor() && GetInstrumentEditor()->m_pCurRegion)
	{
		nStartNote = GetInstrumentEditor()->m_pCurRegion->m_rRgnHeader.RangeKey.usLow;
		nLayer = GetInstrumentEditor()->m_pCurRegion->GetLayer();
	}

	hr = pIStream->Write((void *)&nStartNote, sizeof(int), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(int)) 
	{
		return E_FAIL;
	}

	hr = pIStream->Write((void *)&nLayer, sizeof(int), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(int)) 
	{
		return E_FAIL;
	}


	m_rInstHeader.cRegions = m_Regions.GetCount();
	hr = pIStream->Write((void *)&m_rInstHeader, sizeof(INSTHEADER),&ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(INSTHEADER)) 
	{
		return E_FAIL; 
	}

	for(CRegion* pRgn = m_Regions.GetHead(); pRgn; pRgn = pRgn->GetNext())
	{
		IPersistStream* pIPStream = NULL;
		if(SUCCEEDED(pRgn->QueryInterface(IID_IPersistStream, (void **) &pIPStream)))
		{
			hr = pIPStream->Save(pIStream, fClearDirty);
			pIPStream->Release();
			if (FAILED(hr)) 
			{
				return E_FAIL; 
			}
		}
		else
		{
			return (E_FAIL);  
		}
	}

	if(!SaveString(pIStream, m_Info.m_csName))
	{
		return E_FAIL;
	}

	if(!SaveString(pIStream, m_Info.m_csSubject))
	{
		return E_FAIL;
	}

	if(!SaveString(pIStream, m_Info.m_csEngineer))
	{
		return E_FAIL;
	}

	if(!SaveString(pIStream, m_Info.m_csCopyright))
	{
		return E_FAIL;
	}

	if(!SaveString(pIStream, m_Info.m_csComment))
	{
		return E_FAIL;
	}

	return S_OK;
}


bool CInstrument::SaveString(IStream* pIStream, CString sData)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
		return false;

	DWORD	cb = 0;
	HRESULT hr = E_FAIL;
	int nStringLength = sData.GetLength() + 1;

	hr = pIStream->Write((void*) &nStringLength, sizeof(int), &cb);
	if(FAILED(hr) || cb != sizeof(int))
		return false;

	hr = pIStream->Write((void*)sData.GetBuffer(0), nStringLength, &cb);
	if(FAILED(hr) || cb != (DWORD)nStringLength)
		return false;
	
	return true;
}

void CInstrument::TurnOffMidiNotes()
{
	HRESULT hr;
	int i;

	for (i = 0; i < 128; i++)
	{
		if ( m_cMidiNoteOns[i] )
		{
			while ( m_cMidiNoteOns[i] )
			{
				hr = m_pComponent->PlayMIDIEvent(MIDI_NOTEOFF,
												BYTE(i),
												DEFAULT_VELOCITY,
             									0,
												IsDrum());
				m_cMidiNoteOns[i]--;
				if ( FAILED(hr) )
					break;
			}
		}
	}
}

HRESULT CInstrument::Write(void* pvoid, IDirectMusicPortDownload* pIDMPortDownLoad)
{
	ASSERT(pvoid);
    if(pvoid == NULL)
    {
        return E_POINTER;
    }

    ASSERT(pIDMPortDownLoad);
    if(pIDMPortDownLoad == NULL)
    {
        return E_POINTER;
    }

	DWORD dwCurIndex = 0;	// Used to determine what index to store offset in Offset Table
	DWORD dwCurOffset = 0;	// Offset relative to beginning of passed in memory

	HRESULT hr = S_OK;

	__try
	{
		// Write DMUS_DOWNLOADINFO		
		DMUS_DOWNLOADINFO* pDLInfo = (DMUS_DOWNLOADINFO *) pvoid;

		if(m_bNewFormat)
		{
			pDLInfo->dwDLType = DMUS_DOWNLOADINFO_INSTRUMENT2;
		}
		else
		{
			pDLInfo->dwDLType = DMUS_DOWNLOADINFO_INSTRUMENT;
		}

        if(FAILED(GetDMIDForPort(pIDMPortDownLoad, &m_dwId)))
        {
            return E_FAIL;
        }

		pDLInfo->dwDLId = m_dwId;
		pDLInfo->dwNumOffsetTableEntries = (m_cbSizeOffsetTable/sizeof(DWORD));
		pDLInfo->cbSize = m_dwDLSize;

		dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

		DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvoid) + dwCurOffset);

		// Increament pass the DMUS_OFFSETTABLE structure; we will fill the other members in later
		dwCurOffset += m_cbSizeOffsetTable;

		// First entry in ulOffsetTable is the first data chunk
		pDMOffsetTable->ulOffsetTable[0] = dwCurOffset;
		
		dwCurIndex = 1;
		
		// Write Instrument MIDI address
		DMUS_INSTRUMENT* pDMInstrument = (DMUS_INSTRUMENT*)(((BYTE *)pvoid) + dwCurOffset);
        pDMInstrument->ulFlags = 0;

		// Put data into format that is expected by synth
		pDMInstrument->ulPatch = ((m_rInstHeader.Locale.ulBank & 0x00007F7F) << 8) | (m_rInstHeader.Locale.ulInstrument) | (m_rInstHeader.Locale.ulBank & 0x80000000);

		dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));

		// Write regions
		pDMInstrument->ulFirstRegionIdx = 0;
		CRegion* pRegion = m_Regions.GetHead();
			
		// Make sure the next chunk can also be downloaded.
        while (pRegion && (pRegion->Count() == 0))
            pRegion = pRegion->GetNext();

		LONG iChannel = 0;
		while (pRegion)
			{
			LONG cChannels = pRegion->GetChannelCount();
			ASSERT(cChannels >= 1); // channel count not supported

			CRegion *pNextRegion;
			DWORD dwIndexNextRegion;
			LONG iNextChannel;
			if (iChannel+1 == cChannels)
				{
				iNextChannel = 0;
				pNextRegion = pRegion->GetNext();

				// Make sure the next chunk can also be downloaded.
				while (pNextRegion && (pNextRegion->Count() == 0))
					pNextRegion = pNextRegion->GetNext();
				}
			else
				{
				iNextChannel = iChannel + 1;
				pNextRegion = pRegion;
				}

			dwIndexNextRegion = pNextRegion ? dwCurIndex + pRegion->Count() : 0;

			if(pDMInstrument->ulFirstRegionIdx == 0)
				pDMInstrument->ulFirstRegionIdx = dwCurIndex;

			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
		
			hr = pRegion->Write(((BYTE *)pvoid + dwCurOffset),
								iChannel,
								&dwCurOffset,
								pDMOffsetTable->ulOffsetTable,
								&dwCurIndex,
								dwIndexNextRegion,
                                pIDMPortDownLoad);
			if(FAILED(hr))
				break;

			iChannel = iNextChannel;
			pRegion = pNextRegion;
			}

		pDMInstrument->ulFirstExtCkIdx = 0;

		if(SUCCEEDED(hr))
		{
			DWORD	dwSize = 0;
			// Write copyright information
			if(!m_Info.m_csCopyright.IsEmpty())
			{
				dwSize = m_Info.m_csCopyright.GetLength() + 1;
				pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
				pDMInstrument->ulCopyrightIdx = dwCurIndex;
				CopyMemory((BYTE*)pvoid + dwCurOffset,m_Info.m_csCopyright.GetBuffer(0),dwSize);
				dwCurIndex++;
				m_Info.m_csCopyright.ReleaseBuffer();
			}
			// If instrument does not have one use collection's
			else if(m_pCollection && !m_pCollection->m_Info.m_csCopyright.IsEmpty())
			{
				dwSize = m_pCollection->m_Info.m_csCopyright.GetLength() + 1;
				pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
				pDMInstrument->ulCopyrightIdx = dwCurIndex;
				CopyMemory((BYTE*)pvoid + dwCurOffset,m_pCollection->m_Info.m_csCopyright.GetBuffer(0),dwSize);
				dwCurIndex++;
				m_pCollection->m_Info.m_csCopyright.ReleaseBuffer();
			}
			else
			{
				pDMInstrument->ulCopyrightIdx = 0;
			}
			dwCurOffset += dwSize;
		}
		if(SUCCEEDED(hr))
		{
			pDMInstrument->ulGlobalArtIdx = 0;
			UINT nArtCount = GetArticulationCount();
			if(nArtCount > 0)
			{
				POSITION position = m_lstArticulationLists.GetHeadPosition();
				while(position)
				{
					CArticulationList* pArtList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
					if(pArtList && pArtList->IsConditionOK() && pArtList->GetCount() > 0)
					{
						pDMInstrument->ulGlobalArtIdx = dwCurIndex;

						if(FAILED(hr = pArtList->Write((BYTE*) pvoid, &dwCurOffset, &dwCurOffset, pDMOffsetTable->ulOffsetTable, &dwCurIndex)))
						{
							break;
						}
					}
				}
			}
			else
			{
				pDMInstrument->ulGlobalArtIdx = 0;
			}
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		hr = E_UNEXPECTED;
	}
	if(FAILED(hr))
	{
		// If we fail we want to cleanup the contents of passed in buffer
		ZeroMemory(pvoid, m_dwDLSize);
	}
	return hr;
}

HRESULT CInstrument::Size(DWORD& dwSize)
{
	HRESULT hr = S_OK;
	DWORD dwOffsetCount = 0;
	DWORD dwCountExtChk = 0;
	DWORD dwCountRegion = 0;
	dwSize = 0;

	__try
	{
		//Calculate the space needed for DMUS_DOWNLOADINFO 
		dwSize += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

		// Calculate space needed for DMUS_INSTRUMENT
		dwSize += CHUNK_ALIGN(sizeof(DMUS_INSTRUMENT));
		dwOffsetCount++;

		// Calculate the space needed for Instrument's copyright
		if(!m_Info.m_csCopyright.IsEmpty())
		{
			dwSize += m_Info.m_csCopyright.GetLength() + 1; // add 1 for null
			dwOffsetCount++;
		}
		// If instrument does not have one use collection's
		else if(m_pCollection && !m_pCollection->m_Info.m_csCopyright.IsEmpty())
		{
			dwSize += m_pCollection->m_Info.m_csCopyright.GetLength() + 1; // add 1 for null
			dwOffsetCount++;
		}

		UINT nArtCount = GetArticulationCount();
		if(nArtCount > 0)
		{
			POSITION position = m_lstArticulationLists.GetHeadPosition();
			while(position)
			{
				CArticulationList* pArtList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
				if(pArtList)
				{
					dwSize += pArtList->Size();
					dwOffsetCount += pArtList->Count();
				}
			}
		}

		// Calculate the space needed for Instrument's regions 
		CRegion* pRegion = m_Regions.GetHead();
		for(; pRegion; pRegion = pRegion->GetNext())
		{
			LONG cChannels = pRegion->GetChannelCount();
			dwSize += pRegion->Size()*cChannels;
			dwOffsetCount += pRegion->Count()*cChannels;
			dwCountRegion += cChannels;
		}

		// Calculate the space needed for offset table
		m_cbSizeOffsetTable = CHUNK_ALIGN(dwOffsetCount * sizeof(ULONG));
		dwSize += m_cbSizeOffsetTable;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		dwSize = 0;
		hr = E_UNEXPECTED;
	}
	return hr;
}

HRESULT CInstrument::DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad)
{
	HRESULT	hr = E_FAIL;

	// Do nothing if we don't have a valid port to download to...
	if(pIDMPortDownLoad == NULL)
		return E_FAIL;

	m_bNewFormat = FALSE;
	IKsControl* pControl = NULL;
	// Query for IKsControl interface
    if(SUCCEEDED(pIDMPortDownLoad->QueryInterface(IID_IKsControl, (void**)&pControl))) 
    { 
		KSPROPERTY	ksp;
		DWORD dwFlags = 0;
		DWORD cb = 0;

		// Ask about GM 
		ksp.Set   = GUID_DMUS_PROP_INSTRUMENT2; 
		ksp.Id    = 0; 
		ksp.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
		HRESULT hr = pControl->KsProperty(&ksp, sizeof(ksp), &dwFlags, sizeof(dwFlags), &cb);
		if(SUCCEEDED(hr) || (cb >= sizeof(dwFlags)))
		{
			// Set is supported
			m_bNewFormat = (BOOL)(dwFlags & KSPROPERTY_TYPE_GET);
		}
		pControl->Release();
    }
    
	hr = Size(m_dwDLSize);
	if (m_dwDLSize)
	{
		// Add prepend and append amount to download buffer size
		DWORD dwAppendValue = 0;
		if(FAILED(m_pComponent->GetAppendValueForPort(pIDMPortDownLoad, &dwAppendValue)))
			return E_FAIL;
		
		m_dwDLSize += dwAppendValue;

		// Allocate a download buffer
		IDirectMusicDownload* pIDMDownload;
		hr = pIDMPortDownLoad->AllocateBuffer(m_dwDLSize, &pIDMDownload);
		if (!SUCCEEDED(hr))
		{
			AfxMessageBox(IDS_ERR_INSUFFICIENT_MEMORY, MB_OK | MB_ICONEXCLAMATION);
			return E_OUTOFMEMORY;
		}

		// Add to the list of allocated buffers
		AllocatedPortBufferPair* pAllocatedBuffer = GetAllocatedBufferForPort(pIDMPortDownLoad);
		if(pAllocatedBuffer == NULL)
		{
			pAllocatedBuffer = new AllocatedPortBufferPair(pIDMPortDownLoad, pIDMDownload);
			if(pAllocatedBuffer == NULL)
				return E_OUTOFMEMORY;

			m_lstAllocatedBuffers.AddTail(pAllocatedBuffer);
		}

		hr = pIDMPortDownLoad->GetDLId(&m_dwId,1);
		if (!SUCCEEDED(hr))
		{
			// Remove the added buffer
			if(pAllocatedBuffer)
				RemoveFromAllocatedBufferList(pAllocatedBuffer);

#ifdef _DEBUG
			AfxMessageBox(IDS_ERR_DM_ID, MB_OK | MB_ICONEXCLAMATION);
#endif
			return hr;
		}

        pAllocatedBuffer->SetDMID(m_dwId);
	}
	else //if (m_dwDLSize)
	{
#ifdef _DEBUG
		AfxMessageBox(IDS_ERR_ZERO_SIZE_INS, MB_OK | MB_ICONEXCLAMATION);
#endif
		hr = E_FAIL;
	}
	return hr;
}

HRESULT CInstrument::Download(IDirectMusicPortDownload* pIDMPortDownLoad)
{
	void*		pBuffer=NULL;
	DWORD		dwSize;
	HRESULT		hr = S_OK;

	// Do nothing if we don't have a valid port to download to...
	if(pIDMPortDownLoad == NULL)
		return E_FAIL;
	
	// Get the allocated buffer
	AllocatedPortBufferPair* pAllocatedBuffer = GetAllocatedBufferForPort(pIDMPortDownLoad);
	ASSERT(pAllocatedBuffer);
	if(pAllocatedBuffer == NULL)
		return E_FAIL;

	IDirectMusicDownload* pIDMDownload = pAllocatedBuffer->m_pAllocatedBuffer;
	
	// Fail if we haven't allocated a buffer for download
	if(pIDMDownload == NULL)
		return E_FAIL;

	hr = pIDMDownload->GetBuffer(&pBuffer,&dwSize);
	if ( !SUCCEEDED(hr) ||(pBuffer == NULL) || (dwSize < m_dwDLSize) )
	{
#ifdef _DEBUG
		AfxMessageBox(IDS_ERR_GET_DOWNLOAD_BUFFER, MB_OK | MB_ICONEXCLAMATION);
#endif
		return E_FAIL;
	}
	// Make sure we start writing pass the prepend portion of the download buffer
	if ( !SUCCEEDED(hr = Write(((BYTE *)pBuffer), pIDMPortDownLoad)))
	{
#ifdef _DEBUG
		AfxMessageBox(IDS_ERR_DOWNLOAD_WRITE, MB_OK | MB_ICONEXCLAMATION);
#endif
		return hr;
	}

	if ( !SUCCEEDED( hr = pIDMPortDownLoad->Download(pIDMDownload) ) )
	{
		UINT	iErrorStringResource;
		switch (hr)
		{
			case DMUS_E_BADWAVE:   // Bad wave chunk
				iErrorStringResource = IDS_ERR_BADWAVE;
				break;
			case DMUS_E_NOTPCM:    // Not PCM data in wave
				iErrorStringResource = IDS_ERR_NOTPCM;
				break;
			case DMUS_E_NOTMONO:	// Wave not MONO
				iErrorStringResource = IDS_ERR_NOTMONO;
				break;
			case DMUS_E_BADARTICULATION: // Bad articulation chunk
				iErrorStringResource = IDS_ERR_BADARTICULATION;
				break;
			case DMUS_E_BADWAVELINK:  // Bad link from region to wave
				iErrorStringResource = IDS_ERR_BADWAVELINK;
				break;
			case DMUS_E_BADINSTRUMENT:// Bad instrument chunk
				iErrorStringResource = IDS_ERR_BADINSTRUMENT;
				break;
			case DMUS_E_NOARTICULATION:// No articulation found in region
				iErrorStringResource = IDS_ERR_NOARTICULATION;
				break;
			case DMUS_E_BADOFFSETTABLE:
				iErrorStringResource = IDS_ERR_BADOFFSET;
				break;
			default:
				iErrorStringResource = IDS_ERR_DM_DOWNLOAD;
		}
#ifdef _DEBUG
		AfxMessageBox(iErrorStringResource, MB_OK | MB_ICONEXCLAMATION);
#endif
	}
	

	return hr;
}

bool CInstrument::ValidatePatch()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return true;
	}

	if(m_pComponent->IsNoShowCollectionPatchConflict())
	{
		return true;
	}

	CInstrument* pInstrumentCollision = NULL;
	BYTE		bMSB, bLSB, bPatch;
	DWORD		dwDrum;
	bool		bIgnore = false;

	ASSERT(m_pCollection);

	HRESULT hr = m_pComponent->IsValidPatch(this, m_rInstHeader.Locale.ulBank, m_rInstHeader.Locale.ulInstrument, m_pCollection, &pInstrumentCollision);
	if ( SUCCEEDED(hr) )
	{
		return true;
	}
	if ( m_pCollection->m_fPatchResolution == DLS_DLG_FIX_ALL)
	{//auto fix
		bMSB = (BYTE) ((m_rInstHeader.Locale.ulBank & 0x00007F00) >> 8);
		bLSB = (BYTE) (m_rInstHeader.Locale.ulBank & 0x0000007F);
		bPatch = (BYTE) (m_rInstHeader.Locale.ulInstrument & 0x0000007F);
		dwDrum =  m_rInstHeader.Locale.ulBank & 0x80000000;
		hr = m_pComponent->GetNextValidPatch(dwDrum, &bMSB, &bLSB, &bPatch);
		if (SUCCEEDED(hr))
		{
			m_rInstHeader.Locale.ulBank = MAKE_BANK(dwDrum, bMSB, bLSB);
			m_rInstHeader.Locale.ulInstrument = bPatch;
			return false;
		}
		return true;
	}
	if ( (hr & SC_PATCH_DUP_GM) && (m_pCollection->m_fPatchResolution & DLS_DLG_IGNORE_ALL_GM) )
	{
		hr &= ~SC_PATCH_DUP_GM;
	}
	if ( (hr & SC_PATCH_DUP_COLLECTION) && (m_pCollection->m_fPatchResolution & DLS_DLG_IGNORE_ALL_COLLECTION) )
	{
		hr &= ~SC_PATCH_DUP_COLLECTION;
	}
	if ( (hr & SC_PATCH_DUP_SYNTH) && (m_pCollection->m_fPatchResolution & DLS_DLG_IGNORE_ALL_SYNTH) )
	{
		hr &= ~SC_PATCH_DUP_SYNTH;
	}
	if (DLS_ERR_FIRST == hr)
	{
		return true;
	}
	CPatchConflictDlg* pConflictDlg = new CPatchConflictDlg(hr, pInstrumentCollision, m_pCollection, this);
	int retval = pConflictDlg->DoModal();
	delete pConflictDlg;

	switch (retval)
	{
		case IDOK:
			m_pCollection->SetDirtyFlag();
			return false;
			break;
		case ID_BTN_IGNORE:
			return true;
			break;
		case DLS_DLG_FIX_ALL:
			m_pCollection->m_fPatchResolution = DLS_DLG_FIX_ALL;
			m_pCollection->SetDirtyFlag();
			return false;
			break;
		default:
			m_pCollection->m_fPatchResolution |= retval;
			return true;
			break;
	}
}

HRESULT CInstrument::OnViewProperties()
{

	ASSERT(m_pComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( pIPropSheet->IsShowing() == S_OK )
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( this->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				if( SUCCEEDED ( pIPageObject->OnShowProperties() ) )
				{
					hr = S_OK;
				}

				pIPageObject->Release();
			}
		}
		else
		{
			hr = S_OK;
		}

		pIPropSheet->Release();
	}

	return hr;
}


BOOL CInstrument::VerifyDLS()
{
	UINT uMessageBoxOptions = MB_OKCANCEL | MB_ICONEXCLAMATION;
	BOOL bRet = TRUE;
	CString sCollectionName = m_pCollection->m_Info.m_csName + ":";
	CString sContinuePrompt;
	sContinuePrompt.LoadString(IDS_CONTINUE_VERIFYDLS);

	if(FAILED(CheckForOverlappedRegions()))
	{
		bRet = FALSE;
		CString sErrorMessage;
		sErrorMessage.Format(IDS_ERR_INST_OVERLAPPING_REGIONS, m_Info.m_csName);
		sErrorMessage = sCollectionName + sErrorMessage + "\n" + sContinuePrompt;
		if (IDCANCEL == AfxMessageBox(sErrorMessage, uMessageBoxOptions, 0))
			return bRet;
	}

    if(F_INSTRUMENT_DRUMS & m_rInstHeader.Locale.ulBank)
    {
        if (m_Regions.GetCount() > 128)
        {
			bRet = FALSE;
			CString sErrorMessage;
			sErrorMessage.Format(IDS_ERR_DRUMS_MORE_REGIONS, m_Info.m_csName, m_Regions.GetCount());
			sErrorMessage = sCollectionName + sErrorMessage + "\n" + sContinuePrompt;
			if(IDCANCEL == AfxMessageBox(sErrorMessage, uMessageBoxOptions, 0))
				return bRet;
        }
    }
    else
    {
        DWORD dwLocalA = 0;
        CRegion* pRegion = m_Regions.GetHead();
        for(;pRegion;pRegion = pRegion->GetNext())
        {
            if(pRegion->m_pArticulation != NULL)
                dwLocalA++;
        }

        if(dwLocalA > 0)
        {
			bRet = FALSE;
			CString sErrorMessage;
			sErrorMessage.Format(IDS_ERR_INVALID_NUMBER_ARTICULATIONS, m_Info.m_csName, dwLocalA);
			sErrorMessage = sCollectionName + sErrorMessage + "\n" + sContinuePrompt;
			if (IDCANCEL == AfxMessageBox(sErrorMessage, uMessageBoxOptions,0))
				return bRet;
        }

        if(m_Regions.IsEmpty() || GetDLS1RegionCount() == 0)
        {
			bRet = FALSE;
			CString sErrorMessage;
			sErrorMessage.Format(IDS_ERR_INST_NO_REGIONS, m_Info.m_csName);
			sErrorMessage = sCollectionName + sErrorMessage + "\n" + sContinuePrompt;
			if (IDCANCEL == AfxMessageBox(sErrorMessage, uMessageBoxOptions, 0))
				return bRet;
        }

        if(m_Regions.GetCount() > 16)
        {
			bRet = FALSE;
			CString sErrorMessage;
			sErrorMessage.Format(IDS_ERR_INST_INVALID_NUMBER_REGIONS, m_Info.m_csName, m_Regions.GetCount());
			sErrorMessage = sCollectionName + sErrorMessage + "\n" + sContinuePrompt;
			if(IDCANCEL == AfxMessageBox(sErrorMessage, uMessageBoxOptions, 0))
				return bRet;
        }
    }
    return bRet;
}

HRESULT CInstrument::CheckForOverlappedRegions()
{
	CRegion* pRegion = m_Regions.GetHead();
    for(;pRegion;pRegion = pRegion->GetNext())
    {
		CRegion* pCompare = pRegion->GetNext();
		for(;pCompare;pCompare = pCompare->GetNext())
		{
			if(((pCompare->m_rRgnHeader.RangeKey.usLow  <= pRegion->m_rRgnHeader.RangeKey.usHigh) &&
				(pCompare->m_rRgnHeader.RangeKey.usLow   >= pRegion->m_rRgnHeader.RangeKey.usLow)) ||
				((pCompare->m_rRgnHeader.RangeKey.usHigh <= pRegion->m_rRgnHeader.RangeKey.usHigh) &&
				(pCompare->m_rRgnHeader.RangeKey.usHigh  >= pRegion->m_rRgnHeader.RangeKey.usLow)) ||
				((pRegion->m_rRgnHeader.RangeKey.usLow	 <= pCompare->m_rRgnHeader.RangeKey.usHigh) &&
				(pRegion->m_rRgnHeader.RangeKey.usLow	 >= pCompare->m_rRgnHeader.RangeKey.usLow)) ||
				((pRegion->m_rRgnHeader.RangeKey.usHigh  <= pCompare->m_rRgnHeader.RangeKey.usHigh) &&
				(pRegion->m_rRgnHeader.RangeKey.usHigh	 >= pCompare->m_rRgnHeader.RangeKey.usLow)))
			{
				return E_FAIL;
			} 
		}
    }
	return S_OK;
}


DWORD CInstrument::GetDLS1RegionCount()
{
	DWORD dwRgnCnt = 0;
	CRegion* pRegion = m_Regions.GetHead();
	while(pRegion)
	{
		if(pRegion->GetLayer() == 0)
		{
			dwRgnCnt++;
		}

		pRegion = pRegion->GetNext();
	}

	return dwRgnCnt;
}

// Gets the region that contains the passed note
CRegion* CInstrument::GetRegion(int nNote)
{
	CRegion* pRegion = m_Regions.GetHead();
    for(;pRegion;pRegion = pRegion->GetNext())
    {
		if(pRegion->m_rRgnHeader.RangeKey.usLow <= nNote && pRegion->m_rRgnHeader.RangeKey.usHigh >= nNote)
			return pRegion;
	}

	return NULL;
}

// Updates the property page and refreshes the node
// Will not update the wavelink data if bWaveDataChanged is FALSE
void CInstrument::RefreshUI(bool bWaveDataChanged)
{
	// Refresh the Instrument's property page if it's showing
	if(IsPropertyPageShowing() == true)
	{
		m_pInstrumentPropPgMgr->RefreshData();
	}
		

	if(m_pComponent && m_pComponent->m_pIFramework)
	{
		m_pComponent->m_pIFramework->RefreshNode(this);
	}
		
	if(m_pInstrumentCtrl && m_pInstrumentCtrl->m_pInstrumentEditor)
	{
		// Keep the region that is currently selected so we can set it as selected back
		short nStartNote = m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->m_rRgnHeader.RangeKey.usLow;
		short nLayer = short(m_pInstrumentCtrl->m_pInstrumentEditor->m_pCurRegion->GetLayer());

		m_pInstrumentCtrl->m_pInstrumentEditor->m_RegionKeyBoard.DeleteAllRegions();
		m_pInstrumentCtrl->m_pInstrumentEditor->SetRKBMap();

		m_pInstrumentCtrl->m_pInstrumentEditor->m_RegionKeyBoard.SetCurrentRegion(nLayer, nStartNote);
		
		if(bWaveDataChanged)
		{
			m_pInstrumentCtrl->m_pInstrumentEditor->RegionWaveChanged();
		}

		m_pInstrumentCtrl->m_pInstrumentEditor->RefreshRegion();
		m_pInstrumentCtrl->m_pInstrumentEditor->SetupArticulation();
	}

	// Resort the region nodes
	if(m_pComponent && m_pComponent->m_pIFramework)
	{
		m_pComponent->m_pIFramework->SortChildNodes(&m_Regions);
	}
}


void CInstrument::RefreshRegion()
{
	if(m_pComponent && m_pComponent->m_pIFramework)
		m_pComponent->m_pIFramework->RefreshNode(this);

	if(GetInstrumentEditor())
		GetInstrumentEditor()->RefreshRegion();
}

CInstrumentFVEditor* CInstrument::GetInstrumentEditor()
{
	if(m_pInstrumentCtrl)
		return m_pInstrumentCtrl->m_pInstrumentEditor;

	return NULL;
}

HRESULT CInstrument::SaveStateForUndo(UINT uUndoTextID)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pUndoMgr);
	if(m_pUndoMgr == NULL)
	{
		return E_FAIL;
	}
	
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_POINTER;
	}

	IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return E_FAIL;
	}


	HRESULT hr = S_OK;
	CString	csMenuText;
 	csMenuText.LoadString(uUndoTextID);
	
	if(FAILED(hr = m_pUndoMgr->SaveState(this, csMenuText.GetBuffer(MENU_TEXT_SIZE))))
	{
		AfxMessageBox(IDS_ERR_INSUFFICIENT_MEMORY, MB_OK | MB_ICONEXCLAMATION);
		hr = E_FAIL;
	}

	
	return hr;
}

void CInstrument::PopUndoState()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pUndoMgr);
	if(m_pUndoMgr == NULL)
		return;

	m_pUndoMgr->DeleteState();
}

bool CInstrument::IsPropertyPageShowing()
{
	bool bPageIsUp = false;

	ASSERT(m_pComponent);
	IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
	ASSERT(pIFramework);

	if(pIFramework)
	{
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
			{
				bPageIsUp = true;
			}
			
			pIPropSheet->Release();
		}
	}

	return bPageIsUp;
}

HRESULT CInstrument::Unload(IDirectMusicPortDownload* pIDMPortDownLoad)
{
	HRESULT hr = E_FAIL;

	ASSERT(pIDMPortDownLoad);
	if(pIDMPortDownLoad == NULL)
	{
		return E_POINTER;
	}

	AllocatedPortBufferPair* pAllocatedBuffer = GetAllocatedBufferForPort(pIDMPortDownLoad);
	if(pAllocatedBuffer == NULL)
	{
		return E_FAIL;
	}

	if(pAllocatedBuffer->m_pAllocatedBuffer)
	{
		hr = pAllocatedBuffer->m_pDownloadPort->Unload(pAllocatedBuffer->m_pAllocatedBuffer);
	}

	RemoveFromAllocatedBufferList(pAllocatedBuffer);

	return hr;
}

AllocatedPortBufferPair* CInstrument::GetAllocatedBufferForPort(IDirectMusicPortDownload* pIDMPortDownLoad)
{
	ASSERT(pIDMPortDownLoad);
	if(pIDMPortDownLoad == NULL)
	{
		return NULL;
	}

	POSITION position = m_lstAllocatedBuffers.GetHeadPosition();
	while(position)
	{
		AllocatedPortBufferPair* pAllocatedBuffer = (AllocatedPortBufferPair*)m_lstAllocatedBuffers.GetNext(position);
		
		ASSERT(pAllocatedBuffer);
		if(pAllocatedBuffer->m_pDownloadPort == pIDMPortDownLoad)
		{
			return pAllocatedBuffer;
		}
	}

	return NULL;
}

void CInstrument::RemoveFromAllocatedBufferList(AllocatedPortBufferPair* pAllocatedBuffer)
{
	ASSERT(pAllocatedBuffer);
	if(pAllocatedBuffer == NULL)
	{
		return;
	}

	POSITION position = m_lstAllocatedBuffers.GetHeadPosition();

	while(position)
	{
		POSITION oldPosition = position;
		AllocatedPortBufferPair* pAllocatedBufferItem = (AllocatedPortBufferPair*)m_lstAllocatedBuffers.GetNext(position);
		if(pAllocatedBufferItem == pAllocatedBuffer)
		{
			m_lstAllocatedBuffers.RemoveAt(oldPosition);
			pAllocatedBufferItem->m_pAllocatedBuffer->Release();
			delete pAllocatedBufferItem;
			return;
		}
	}
}

CInstrumentRegions* CInstrument::GetRegions()
{
	return &m_Regions;
}

BOOL CInstrument::SupportsNewFormat()
{
	return m_bNewFormat;
}

UINT CInstrument::GetArticulationCount()
{
	UINT nGlobalArticulations = 0;

	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
		ASSERT(pArticList);
		if(pArticList)
		{
			nGlobalArticulations += pArticList->GetCount();
		}
	}

	return nGlobalArticulations;
}

CArticulation* CInstrument::GetCurrentArticulation()
{
	return m_pCurArticulation;
}

void CInstrument::CreateDefaultGlobalArticulation()
{
	CArticulationList* pArticList = new CArticulationList(m_pComponent, this);
	m_lstArticulationLists.AddTail(pArticList);
	m_pCurArticulation = (CArticulation*) pArticList->GetHead();
}

void CInstrument::DeleteAllRegions()
{
	while(!m_Regions.IsEmpty())
	{
		CRegion* pRegion = m_Regions.GetHead();
		if(FAILED(pRegion->DeleteNode(FALSE)))
		{
			m_Regions.Remove(pRegion);
			delete pRegion;
		}
	}
}

void CInstrument::DeleteArticulationLists()
{
	// Instrument's DeleteChildNode method will remove 
	// this from the list of articulation lists also 
	while(!m_lstArticulationLists.IsEmpty())
	{
		CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.GetHead();
		if(FAILED(pArticList->DeleteNode(FALSE)))
		{
			POSITION position = m_lstArticulationLists.Find(pArticList);
			if(position)
			{
				m_lstArticulationLists.RemoveAt(position);
			}
			delete pArticList;
		}
	}

	// The current articulation is already pfft! 
	m_pCurArticulation = NULL;
}

void CInstrument::SetCurrentArticulation(CArticulation* pArticulation)
{
	m_pCurArticulation = pArticulation;
	if(m_pCurArticulation && m_pInstrumentCtrl)
	{
		m_pInstrumentCtrl->m_pInstrumentEditor->SetCurArticulation(pArticulation);
	}

	UpdateInstrument();
}

HRESULT CInstrument::GetListOfConditions(CPtrList* pConditionList)
{
	ASSERT(pConditionList);
	if(pConditionList == NULL)
	{
		return E_POINTER;
	}
	
	// Get the conditions from all regions 
	CRegion* pRegion = m_Regions.GetHead();
	while(pRegion)
	{
		if(FAILED(pRegion->GetListOfConditions(pConditionList)))
		{
			return E_FAIL;
		}

		pRegion = pRegion->GetNext();
	}

	// ...and all articulation lists...
	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArticList = (CArticulationList*)m_lstArticulationLists.GetNext(position);
		ASSERT(pArticList);
		if(pArticList)
		{
			CConditionalChunk* pCondition = pArticList->GetConditionalChunk();
			if(pCondition)
			{
				pConditionList->AddTail(pCondition);
			}
		}
	}

	return S_OK;
}

CCollection* CInstrument::GetCollection()
{
	ASSERT(m_pCollection);
	return m_pCollection;
}

void CInstrument::OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode)
{
	ASSERT(pCurrentConfig);
	if(pCurrentConfig == NULL)
	{
		return;
	}

	CRegion* pRegion = m_Regions.GetHead();
	while(pRegion)
	{
		pRegion->OnConditionConfigChanged(pCurrentConfig, bRefreshNode);
		pRegion = pRegion->GetNext();
	}

	
	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArtList = (CArticulationList*)m_lstArticulationLists.GetNext(position);
		ASSERT(pArtList);
		if(pArtList)
		{
			pArtList->OnConditionConfigChanged(pCurrentConfig, bRefreshNode);
		}
	}
	
	if(m_pIParentNode)
	{
		UpdateInstrument();
	}

}


bool CInstrument::GetAuditionMode()
{
	return m_bAuditionMode;
}

void CInstrument::SetAuditionMode(bool bAuditionMode)
{
	m_bAuditionMode = bAuditionMode;
	UpdateInstrument();
}

void CInstrument::CheckRegionsForLocalArts()
{
	if(GetArticulationCount() >= 1)
	{
		return;
	}

	CRegion* pRegion = m_Regions.GetHead();
	while(pRegion)
	{
		UINT nArtCount = pRegion->GetArticulationCount();
		ASSERT(nArtCount);
		pRegion->ValidateUIA();
		pRegion = pRegion->GetNext();
	}
}

BOOL CInstrument::NoArtForEveryRegion()
{
	CRegion* pRegion = m_Regions.GetHead();
	while(pRegion)
	{
		if(pRegion->GetArticulationCount() == 0)
		{
			return TRUE;
		}
		pRegion = pRegion->GetNext();
	}

	return FALSE;
}

HRESULT CInstrument::GetDMIDForPort(IDirectMusicPortDownload* pIDMDownloadPort, DWORD* pdwDMID)
{
    ASSERT(pIDMDownloadPort);
    if(pIDMDownloadPort == NULL)
    {
        return E_POINTER;
    }

    ASSERT(pdwDMID);
    if(pdwDMID == NULL)
    {
        return E_POINTER;
    }

    POSITION position = m_lstAllocatedBuffers.GetHeadPosition();
    while(position)
    {
        AllocatedPortBufferPair* pBuffer = m_lstAllocatedBuffers.GetNext(position);
        ASSERT(pBuffer);
        if(pBuffer->m_pDownloadPort == pIDMDownloadPort)
        {
            *pdwDMID = pBuffer->GetDMID();
            return S_OK;
        }
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentFVEditor.cpp ===
// InstrumentFVEditor.cpp : implementation file
//

#include "stdafx.h"
#include "region.h"
#include "DMUSProd.h"
#include "DLSEdit.h"
#include "DLSDesignerDLL.h"
#include "DLSStatic.h"
#include "InstrumentFVEditor.h"
#include "ArticulationTabCtrl.h"
#include "Articulation.h"
#include "InstrumentCtl.h"
#include "Instrument.h"
#include "VibratoLFODialog.h"
#include "LFODialog.h"
#include "PitchDialog.h"
#include "VolDialog.h"
#include "FilterDialog.h"
#include "KeyBoardMap.h"
#include "UserPatchConflictDlg.h"
#include "WaveNode.h"
#include "Wave.h"
#include "MonoWave.h"
#include "StereoWave.h"
#include "ConditionEditor.h"
#include "JazzDataObject.h"
#include "DlsDefsPlus.h"
#include "DLSLoadSaveUtils.h"

#include "InstrumentPropPgMgr.h"
#include "RegionPropPgMgr.h"
#include "RegionPropPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int		CInstrumentFVEditor::m_nInstrumentEditors = 0;
CMenu*	CInstrumentFVEditor::m_pContextInstMenu = NULL;
CMenu*	CInstrumentFVEditor::m_pContextRegionMenu = NULL;
CMenu*	CInstrumentFVEditor::m_pContextArtMenu = NULL;

HICON	CInstrumentFVEditor::m_hInstrumentIcon = NULL;
HICON	CInstrumentFVEditor::m_hRegionIcon = NULL;

HANDLE	CInstrumentFVEditor::m_hAttack = NULL;
HANDLE	CInstrumentFVEditor::m_hDecay = NULL;
HANDLE	CInstrumentFVEditor::m_hDecay2 = NULL;
HANDLE	CInstrumentFVEditor::m_hSustain = NULL;
HANDLE	CInstrumentFVEditor::m_hRelease = NULL;
HANDLE	CInstrumentFVEditor::m_hRelease2 = NULL;

CBitmap	CInstrumentFVEditor::m_bmpAttack;
CBitmap	CInstrumentFVEditor::m_bmpDecay;
CBitmap	CInstrumentFVEditor::m_bmpDecay2;
CBitmap	CInstrumentFVEditor::m_bmpSustain;
CBitmap	CInstrumentFVEditor::m_bmpRelease;
CBitmap	CInstrumentFVEditor::m_bmpRelease2;


BOOL isValidNoteString(char * psz)
{
    int nlen = strlen(psz);

    if (nlen > 4)
        return false;

    _strupr(psz);


    for (int i = 0; i < nlen; i++)
    {
        switch (i)
        {
        case 0:
            {
                if (psz[0] >= 'A' && psz[0] <= 'G')
                    break;
                else
                    return false;
            }

        case 1:
            if (psz[i] == 'B' || psz[i] == '#' || (psz[i] >= '0'&& psz[i] <= '9'))
                break;
            else
                return false;

        case 2:
        case 3:
            if (psz[i] >= '0' && psz[i] <= '9')
                break;
            else
                return false;

        default:
            return false;
        } // switch
    }
    return true;
}

// =======================================================================

static char * g_szGroup[16] = { "No Group", "Group 1", "Group 2", "Group 3",
                            "Group 4", "Group 5", "Group 6", "Group 7",
                            "Group 8", "Group 9", "Group 10","Group 11",
                            "Group 12", "Group 13", "Group 14", "Group 15"};

/////////////////////////////////////////////////////////////////////////////
// CInstrumentFVEditor

IMPLEMENT_DYNCREATE(CInstrumentFVEditor, CFormView)

CInstrumentFVEditor::CInstrumentFVEditor(CInstrumentCtrl* parent)
	: CFormView(IDD), 
	  m_currSelTab(0),
	  m_nCurrentArticulationDlg(IDD_VOLUME_PAGE),
	  m_pArtDialog(NULL),
	  m_fInOnInitialUpdate(true),
	  m_pWave(NULL),
	  m_pWaves(NULL),
	  m_pCurRegion(NULL),
	  m_pCurArticulation(NULL),
	  m_dwCookie(0),
	  m_cfFormatArt(0),
	  m_cfFormatRegion(0),
	  m_nStartNoteForCurRegion(0),
	  m_nHasFocus(0),
	  m_bfTouched(0),
	  m_bTouchedByProgram(false),
	  m_bTouchedBySpinner(false),
	  m_dwIgnorePatchConflicts(0),
	  m_dwLowerNoteRange(0),
	  m_dwUpperNoteRange(0),
	  m_dwLowerVelocityRange(0),
	  m_dwUpperVelocityRange(127),
	  m_lUnityNote(0),
	  m_nClickVelocity(100),
	  m_usActiveLayer(1)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Incerement the editor refcount
	m_nInstrumentEditors++;

	m_cfFormatArt = RegisterClipboardFormat(CF_DLS_ARTICULATION);	
	m_cfFormatRegion = RegisterClipboardFormat(CF_DLS_REGION);	

	m_parent = parent;

	m_pInstrument = m_parent->GetInstrument();
	ASSERT(m_pInstrument);
	m_pInstrument->AddRef();
	
	m_pCollection = m_pInstrument->GetParentCollection();
	ASSERT(m_pCollection);
	m_pCollection->AddRef();

	m_pWaves = &(m_pCollection->m_Waves);
	ASSERT(m_pWaves);
	m_pWaves->AddRef();

	m_pComponent = m_pInstrument->m_pComponent;

	if(m_hInstrumentIcon == NULL)
		m_hInstrumentIcon = ::LoadIcon(theApp.m_hInstance, MAKEINTRESOURCE(IDI_INSTRUMENT));

	if(m_hRegionIcon == NULL)
		m_hRegionIcon = ::LoadIcon(theApp.m_hInstance, MAKEINTRESOURCE(IDI_REGION));

	// Load the bitmaps for the envelope params
	if(m_hAttack == NULL)
	{
		m_hAttack = LoadImage(theApp.m_hInstance, MAKEINTRESOURCE(IDB_ATTACK), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		ASSERT(m_hAttack);
		m_bmpAttack.Attach(m_hAttack);
	}

	if(m_hDecay == NULL)
	{
		m_hDecay = LoadImage(theApp.m_hInstance, MAKEINTRESOURCE(IDB_DECAY), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		ASSERT(m_hDecay);
		m_bmpDecay.Attach(m_hDecay);
	}

	if(m_hDecay2 == NULL)
	{
		m_hDecay2 = LoadImage(theApp.m_hInstance, MAKEINTRESOURCE(IDB_DECAY2), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		ASSERT(m_hDecay2);
		m_bmpDecay2.Attach(m_hDecay2);
	}

	if(m_hSustain == NULL)
	{
		m_hSustain = LoadImage(theApp.m_hInstance, MAKEINTRESOURCE(IDB_SUSTAIN), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		ASSERT(m_hSustain);
		m_bmpSustain.Attach(m_hSustain);
	}
	
	if(m_hRelease == NULL)
	{
		m_hRelease = LoadImage(theApp.m_hInstance, MAKEINTRESOURCE(IDB_RELEASE), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		ASSERT(m_hRelease);
		m_bmpRelease.Attach(m_hRelease);
	}
	
	if(m_hRelease2 == NULL)
	{
		m_hRelease2 = LoadImage(theApp.m_hInstance, MAKEINTRESOURCE(IDB_RELEASE2), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
		ASSERT(m_hRelease2);
		m_bmpRelease2.Attach(m_hRelease2);
	}


	//memset(m_Tabs, NULL, sizeof(m_Tabs));

	//{{AFX_DATA_INIT(CInstrumentFVEditor)
	m_wBank = 0;
	m_wBank2 = 0;
	m_wPatch = 0;
	m_fIsDrumKit = FALSE;
	m_fAllowOverlap = FALSE;
	m_fUseInstArt = FALSE;
	//}}AFX_DATA_INIT
}

CInstrumentFVEditor::~CInstrumentFVEditor()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Decrement the editor refcount
	m_nInstrumentEditors--;


	if(m_pInstrument)
	{
		m_pInstrument->Stop(true);
		m_pInstrument->TurnOffMidiNotes();
	}
	if(m_parent)
		m_parent->TurnOffMidiNotes();


	// Destroy the menu only if the last editor is destructing
	if(m_nInstrumentEditors <= 0)
	{
		if(m_pContextInstMenu)
		{
			delete m_pContextInstMenu;
			m_pContextInstMenu = NULL;
		}
		if(m_pContextRegionMenu)
		{
			delete m_pContextRegionMenu;
			m_pContextRegionMenu = NULL;
		}
		if(m_pContextArtMenu)
		{
			delete m_pContextArtMenu; 
			m_pContextArtMenu = NULL;
		}

		if(m_hInstrumentIcon)
		{
			::DestroyIcon(m_hInstrumentIcon);
			m_hInstrumentIcon = NULL;
		}

		if(m_hRegionIcon)
		{
			::DestroyIcon(m_hRegionIcon);
			m_hRegionIcon = NULL;
		}

		if(m_hAttack)
		{
			m_bmpAttack.Detach();
			DeleteObject(m_hAttack);
			m_hAttack = NULL;
		}
		
		if(m_hDecay)
		{
			m_bmpDecay.Detach();
			DeleteObject(m_hDecay);
			m_hDecay = NULL;
		}

		if(m_hDecay2)
		{
			m_bmpDecay2.Detach();
			DeleteObject(m_hDecay2);
			m_hDecay2 = NULL;
		}

		if(m_hSustain)
		{
			m_bmpSustain.Detach();
			DeleteObject(m_hSustain);
			m_hSustain = NULL;
		}

		if(m_hRelease)
		{
			m_bmpRelease.Detach();
			DeleteObject(m_hRelease);
			m_hRelease = NULL;
		}

		if(m_hRelease2)
		{
			m_bmpRelease2.Detach();
			DeleteObject(m_hRelease2);
			m_hRelease2 = NULL;
		}
	}

	CleanupArticluation();

	if(m_pWaves)
	{
		m_pWaves->Release();
	}

	if(m_pInstrument)
	{
		m_pInstrument->Release();
	}

	if(m_pCollection)
	{
		m_pCollection->Release();
	}

	if (m_pCurRegion) 
	{
		m_pCurRegion->m_pInstrumentFVEditor = NULL;
	}

	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}

}

void CInstrumentFVEditor::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInstrumentFVEditor)
	DDX_Control(pDX, IDC_RADIO_SOLO_LAYER, m_SoloLayerButton);
	DDX_Control(pDX, IDC_FILTER_BUTTON, m_FilterButton);
	DDX_Control(pDX, IDC_VIBLFO_BUTTON, m_VibLFOButton);
	DDX_Control(pDX, IDC_ART_DLS1_CHECK, m_ArtDLS1Check);
	DDX_Control(pDX, IDC_REGION_CONDITION_COMBO, m_RegionConditionCombo);
	DDX_Control(pDX, IDC_LAYER_SCROLLBAR, m_LayerScrollBar);
	DDX_Control(pDX, IDC_CLICK_VELOCITY_SPIN, m_ClickVelocitySpin);
	DDX_Control(pDX, IDC_CLICK_VELOCITY, m_ClickVelocityEdit);
	DDX_Control(pDX, IDC_REGION_VELOCITY_THRU_SPIN, m_VelocityHighRangeSpin);
	DDX_Control(pDX, IDC_REGION_VELOCITY_RANGE_SPIN, m_VelocityLowRangeSpin);
	DDX_Control(pDX, IDC_REGION_VELOCITY_EURANGE, m_VelocityHighRangeEdit);
	DDX_Control(pDX, IDC_REGION_VELOCITY_ELRANGE, m_VelocityLowRangeEdit);
	DDX_Control(pDX, IDC_VOLUME_BUTTON, m_VolumeButton);
	DDX_Control(pDX, IDC_LFO_BUTTON, m_LFOButton);
	DDX_Control(pDX, IDC_PITCH_BUTTON, m_PitchButton);
	DDX_Control(pDX, IDC_REGION_ROOT_NOTE, m_RootNoteEdit);
	DDX_Control(pDX, IDC_REGION_EURANGE, m_HighRangeEdit);
	DDX_Control(pDX, IDC_REGION_ELRANGE, m_LowRangeEdit);
	DDX_Control(pDX, IDC_REGION_THRU_SPIN, m_ThruSpin);
	DDX_Control(pDX, IDC_REGION_RANGE_SPIN, m_RangeSpin);
	DDX_Control(pDX, IDC_REGION_ROOT_NOTE_SPIN, m_RootNoteSpin);
	DDX_Control(pDX, IDC_INSTRUMENT_PATCH_SPIN, m_PatchSpin);
	DDX_Control(pDX, IDC_INSTRUMENT_BMSB_SPIN, m_MSBSpin);
	DDX_Control(pDX, IDC_INSTRUMENT_BLSB_SPIN, m_LSBSpin);
	DDX_Text(pDX, IDC_BANK, m_wBank);
	DDV_MinMaxUInt(pDX, m_wBank, 0, 127);
	DDX_Text(pDX, IDC_BANK2, m_wBank2);
	DDV_MinMaxUInt(pDX, m_wBank2, 0, 127);
	DDX_Text(pDX, IDC_PATCH, m_wPatch);
	DDV_MinMaxUInt(pDX, m_wPatch, 0, 127);
	DDX_Check(pDX, IDC_DRUMS, m_fIsDrumKit);
	DDX_Control(pDX, IDC_REGION_REGIONKEYBOARD, m_RegionKeyBoard);
	DDX_Check(pDX, IDC_REGION_OVERLAP, m_fAllowOverlap);
	DDX_Check(pDX, IDC_REGION_UIA, m_fUseInstArt);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CInstrumentFVEditor, CFormView)
	//{{AFX_MSG_MAP(CInstrumentFVEditor)
	ON_BN_CLICKED(IDC_DRUMS, OnDrums)
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_REGION_OVERLAP, OnRegionOverlap)
	ON_BN_CLICKED(IDC_REGION_UIA, OnRegionUia)
	ON_CBN_SELCHANGE(IDC_REGION_WAVELINK, OnSelchangeRegionWavelink)
	ON_WM_CONTEXTMENU()
	ON_WM_DESTROY()
	ON_COMMAND(ID_INST_ED_ARTICULATION_COPY, OnArticulationCopy)
	ON_COMMAND(ID_INST_ED_ARTICULATION_PASTE, OnArticulationPaste)
	ON_COMMAND(ID_INST_ED_ARTICULATION_DELETE, OnArticulationDelete)
	ON_COMMAND(ID_INST_ED_REGION_DELETE, OnRegionDelete)
	ON_COMMAND(IDM_INST_ED_INSTRUMENT_PROPERTIES, OnInstrumentProperties)
	ON_COMMAND(IDM_INST_ED_REGION_PROPERTIES, OnRegionProperties)
	ON_COMMAND(IDM_INST_ED_REGION_NEW_REGION, OnInstEdRegionNewRegion)
	ON_EN_KILLFOCUS(IDC_PATCH, OnKillfocusPatch)
	ON_EN_KILLFOCUS(IDC_BANK, OnKillfocusBank)
	ON_EN_KILLFOCUS(IDC_BANK2, OnKillfocusBank2)
	ON_CBN_SELCHANGE(IDC_REGION_GROUP, OnSelchangeRegionGroup)
	ON_EN_UPDATE(IDC_PATCH, OnUpdatePatch)
	ON_CBN_DROPDOWN(IDC_REGION_WAVELINK, OnDropdownRegionWavelink)
	ON_MESSAGE(DM_VALIDATE,OnValidate)
	ON_MESSAGE(DM_BRINGTOTOP,OnBringToTop)
	ON_MESSAGE(DM_UPDATE_VALUES,OnUpdateMIDIValues)
	ON_MESSAGE(DM_REGION_SELECT,OnMIDIRegionSelect)
	ON_EN_CHANGE(IDC_BANK, OnChangeBank)
	ON_EN_CHANGE(IDC_BANK2, OnChangeBank2) 
	ON_EN_CHANGE(IDC_PATCH, OnChangePatch)
	ON_EN_UPDATE(IDC_BANK, OnUpdateBank)
	ON_EN_UPDATE(IDC_BANK2, OnUpdateBank2)
	ON_NOTIFY(UDN_DELTAPOS, IDC_INSTRUMENT_BMSB_SPIN, OnDeltaPosMSBSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_INSTRUMENT_BLSB_SPIN, OnDeltaPosLSBSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_INSTRUMENT_PATCH_SPIN, OnDeltaPosPatchSpin)
	ON_EN_KILLFOCUS(IDC_REGION_ELRANGE, OnKillfocusRegionElrange)
	ON_EN_KILLFOCUS(IDC_REGION_EURANGE, OnKillfocusRegionEurange)
	ON_EN_KILLFOCUS(IDC_REGION_ROOT_NOTE, OnKillfocusRegionRootNote)
	ON_NOTIFY(UDN_DELTAPOS, IDC_REGION_ROOT_NOTE_SPIN, OnDeltaposRegionRootNoteSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_REGION_THRU_SPIN, OnDeltaposRegionThruSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_REGION_RANGE_SPIN, OnDeltaposRegionRangeSpin)
	ON_EN_SETFOCUS(IDC_REGION_ELRANGE, OnSetfocusRegionElrange)
	ON_EN_SETFOCUS(IDC_REGION_EURANGE, OnSetfocusRegionEurange)
	ON_EN_SETFOCUS(IDC_REGION_ROOT_NOTE, OnSetfocusRegionRootNote)
	ON_BN_CLICKED(IDC_PITCH_BUTTON, OnPitchButton)
	ON_BN_CLICKED(IDC_LFO_BUTTON, OnLfoButton)
	ON_BN_CLICKED(IDC_VOLUME_BUTTON, OnVolumeButton)
	ON_EN_KILLFOCUS(IDC_REGION_VELOCITY_ELRANGE, OnKillfocusRegionVelocityElrange)
	ON_EN_KILLFOCUS(IDC_REGION_VELOCITY_EURANGE, OnKillfocusRegionVelocityEurange)
	ON_EN_KILLFOCUS(IDC_CLICK_VELOCITY, OnKillfocusClickVelocity)
	ON_NOTIFY(UDN_DELTAPOS, IDC_REGION_VELOCITY_RANGE_SPIN, OnDeltaposRegionVelocityRangeSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_REGION_VELOCITY_THRU_SPIN, OnDeltaposRegionVelocityThruSpin)
	ON_WM_VSCROLL()
	ON_NOTIFY(UDN_DELTAPOS, IDC_CLICK_VELOCITY_SPIN, OnDeltaposClickVelocitySpin)
	ON_BN_CLICKED(IDC_CONDITION_EDIT_BUTTON, OnConditionEditButton)
	ON_CBN_SELCHANGE(IDC_REGION_CONDITION_COMBO, OnSelchangeRegionConditionCombo)
	ON_CBN_DROPDOWN(IDC_REGION_CONDITION_COMBO, OnDropdownRegionConditionCombo)
	ON_BN_CLICKED(IDC_ART_DLS1_CHECK, OnArtDls1Check)
	ON_BN_CLICKED(IDC_VIBLFO_BUTTON, OnViblfoButton)
	ON_BN_CLICKED(IDC_FILTER_BUTTON, OnFilterButton)
	ON_COMMAND(IDM_INST_ED_REGION_NEW_LAYER, OnInstEdRegionNewLayer)
	ON_COMMAND(ID_INST_ED_LAYER_DELETE, OnInstEdLayerDelete)
	ON_BN_CLICKED(IDC_RADIO_MULTIPLE_LAYERS, OnRadioMultipleLayers)
	ON_BN_CLICKED(IDC_RADIO_SOLO_LAYER, OnRadioSoloLayer)
	ON_BN_CLICKED(IDC_WAVE_EDIT_BUTTON, OnWaveEditButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInstrumentFVEditor diagnostics

#ifdef _DEBUG
void CInstrumentFVEditor::AssertValid() const
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CFormView::AssertValid();
}

void CInstrumentFVEditor::Dump(CDumpContext& dc) const
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CFormView::Dump(dc);
}
#endif //_DEBUG

HRESULT CInstrumentFVEditor::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if(::IsEqualIID(riid, IID_IDMUSProdMidiInCPt)
	|| ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = (IDMUSProdMidiInCPt *)this;
        return S_OK;
    }

    if(::IsEqualIID(riid, IID_IPersist))
    {
        AddRef();
        *ppvObj = (IPersist *)this;
        return S_OK;
    }

    if(::IsEqualIID(riid, IID_IPersistStream))
    {
        AddRef();
        *ppvObj = (IPersistStream *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CInstrumentFVEditor::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CInstrumentFVEditor::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(m_dwRef != 0);

	AfxOleUnlockApp();
    --m_dwRef;

    if(m_dwRef == 0)
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentFVEditor message handlers

int CInstrumentFVEditor::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pContextInstMenu == NULL)
	{
		m_pContextInstMenu = new CMenu();
		if(m_pContextInstMenu && m_pContextInstMenu->LoadMenu(IDM_INST_EDITOR_INSTRUMENT_RMENU) == 0)
		{
			delete m_pContextInstMenu;
			m_pContextInstMenu = NULL;
		}
	}

	if(m_pContextRegionMenu == NULL)
	{
		m_pContextRegionMenu = new CMenu();
		if(m_pContextRegionMenu && m_pContextRegionMenu->LoadMenu(IDM_INST_EDITOR_REGION_RMENU) == 0)
		{
			delete m_pContextRegionMenu;
			m_pContextRegionMenu = NULL;
		}
	}

	if(m_pContextArtMenu == NULL)
	{
		m_pContextArtMenu = new CMenu();
		if(m_pContextArtMenu && m_pContextArtMenu->LoadMenu(IDM_INST_EDITOR_ARTICULATION_RMENU) == 0)
		{
			delete m_pContextArtMenu;
			m_pContextArtMenu = NULL;
		}
	}

	if (CFormView::OnCreate(lpCreateStruct) == -1)
		return -1;

	RegisterMidi();
	if(m_pInstrument && m_pInstrument->m_pInstrumentCtrl)
		m_pInstrument->m_pInstrumentCtrl->SetTransportName();

	m_pComponent->m_pIConductor->RegisterTransport(m_pInstrument, 0);
	m_pComponent->m_pIConductor->SetActiveTransport(m_pInstrument, BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE);
	m_pInstrument->UpdatePatch();

	return 0;
}

void CInstrumentFVEditor::CollectStatics()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}

	CWnd* pChild = GetWindow(GW_CHILD);
	while(pChild)
	{
		char szClassName[MAX_PATH];
		::GetClassName(pChild->m_hWnd, szClassName, MAX_PATH);
		
		// Add it to the list if it's a "Static"
		if(strcmp(szClassName,"Static") == 0)
		{
			CDLSStatic* pDLSStatic = NULL;
			if(SUCCEEDED(CDLSStatic::CreateControl(this, pChild, &pDLSStatic)))
			{
				m_lstStatics.AddTail(pDLSStatic);
				
				// Special case for "DLS1" layer static
				if(pDLSStatic->GetID() == IDC_DLS1_STATIC)
				{
					int nFirstVisibleLayer = m_RegionKeyBoard.GetFirstVisibleLayer();
					if(nFirstVisibleLayer != 0)
					{
						pDLSStatic->SetTextColor(::GetSysColor(COLOR_BTNFACE));
					}
				}
			}
		}

		pChild = pChild->GetNextWindow();
	}

	// Destroy the actual static controls now
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		CWnd* pWnd = GetDlgItem(pStatic->GetID());
		if(pWnd)
		{
			pWnd->DestroyWindow();
		}
	}
}


void CInstrumentFVEditor::OnDestroy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CFormView::OnDestroy();

	// Delete the Undo Manager
	UnRegisterMidi();
	m_pInstrument->Stop(true);
	m_pInstrument->TurnOffMidiNotes();
	m_pComponent->m_pIConductor->UnRegisterTransport(m_pInstrument);
}

void CInstrumentFVEditor::OnInitialUpdate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_fInOnInitialUpdate = true;
	CFormView::OnInitialUpdate();

	// Fill up the region group combo
	CComboBox* pCombo = (CComboBox *)GetDlgItem(IDC_REGION_GROUP);
    if(pCombo)
    {
		pCombo->ResetContent();
        for (int i = 0; i < 16; i++)
        {
	        pCombo->AddString(g_szGroup[i]);
        }
    }
	// Set range for the velocity spin controls
	m_VelocityHighRangeSpin.SetRange(0, 127);
	m_VelocityLowRangeSpin.SetRange(0, 127);
	m_ClickVelocitySpin.SetRange(0, 127);
	CString sText;
	sText.Format("%d", m_nClickVelocity);
	m_ClickVelocityEdit.SetWindowText(sText);

	
	SetAttachedNode();
	SetupInstrument();
	
	SetupRegion();
	//SetLayerScrollInfo(0);
	
	SetupArticulation();


	// Setup the Articulation tab set
	/*TC_ITEM TabCtrlItem[3];
	CString		csLabelText;

	csLabelText.LoadString(IDS_VOL_TAB_LABEL);
	TabCtrlItem[0].mask = TCIF_TEXT;
	TabCtrlItem[0].pszText = csLabelText.GetBuffer(0);
    TabCtrlItem[0].cchTextMax = csLabelText.GetLength() + 1;    
	m_ArticulationTabCtrl.InsertItem(0, &TabCtrlItem[0]);

	csLabelText.LoadString(IDS_PITCH_TAB_LABEL);
	TabCtrlItem[1].mask = TCIF_TEXT;
	TabCtrlItem[1].pszText = csLabelText.GetBuffer(0);
    TabCtrlItem[1].cchTextMax = csLabelText.GetLength() + 1;    
	m_ArticulationTabCtrl.InsertItem(1, &TabCtrlItem[1]);	

	csLabelText.LoadString(IDS_LFO_TAB_LABEL);
	TabCtrlItem[2].mask = TCIF_TEXT;
	TabCtrlItem[2].pszText = csLabelText.GetBuffer(0);
    TabCtrlItem[2].cchTextMax = csLabelText.GetLength() + 1;    
	m_ArticulationTabCtrl.InsertItem(2, &TabCtrlItem[2]);*/	


	// Set the limit for all the edits
	CEdit* pEdit = (CEdit*) GetDlgItem(IDC_BANK);
	if(pEdit)
		pEdit->SetLimitText(3);
	pEdit = (CEdit*) GetDlgItem(IDC_BANK2);
	if(pEdit)
		pEdit->SetLimitText(3);
	pEdit = (CEdit*) GetDlgItem(IDC_PATCH);
	if(pEdit)
		pEdit->SetLimitText(3);

	SetAuditionRadioMode();

#ifdef DMP_XBOX
	CWnd *pWnd = GetDlgItem(IDC_CONDITION_EDIT_BUTTON);
	if( pWnd )
	{
		pWnd->EnableWindow(FALSE);
	}
	pWnd = GetDlgItem(IDC_REGION_CONDITION_COMBO);
	if( pWnd )
	{
		pWnd->EnableWindow(FALSE);
	}
	pWnd = GetDlgItem(IDC_STATIC_CONDITION);
	if( pWnd )
	{
		pWnd->EnableWindow(FALSE);
	}
#endif // DMP_XBOX

	m_fInOnInitialUpdate = false;
}

/*void CInstrumentFVEditor::OnSelchangeArticulationTab(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	*pResult = 0;
	int newSelTab = m_ArticulationTabCtrl.GetCurSel();

	ASSERT(newSelTab >= 0 && newSelTab <= 2);
	
	if(newSelTab == m_currSelTab)
	{
		return;
	}
	else
	{
		switch(newSelTab)
		{
			case 0:
				m_Tabs[0]->BringWindowToTop();
				m_Tabs[0]->ShowWindow(SW_SHOW);
				m_Tabs[m_currSelTab]->ShowWindow(SW_HIDE);
				m_currSelTab = 0;
				break;
			
			case 1:
				m_Tabs[1]->BringWindowToTop();
				m_Tabs[1]->ShowWindow(SW_SHOW);
				m_Tabs[m_currSelTab]->ShowWindow(SW_HIDE);
				m_currSelTab = 1;
				break;

			case 2:
				m_Tabs[2]->BringWindowToTop();
				m_Tabs[2]->ShowWindow(SW_SHOW);
				m_Tabs[m_currSelTab]->ShowWindow(SW_HIDE);
				m_currSelTab = 2;
				break;
			
			default:
				// Should never get here
				ASSERT(FALSE);
		}
	}
}*/

void CInstrumentFVEditor::SetAttachedNode()
{
	GUID guid;

	if ( m_parent->m_pAttachedNode )
	{
		m_parent->m_pAttachedNode->GetNodeId(&guid);
		if(guid == GUID_InstrumentNode)
		{
			CRegion* pRegion = m_pInstrument->m_Regions.GetHead();
			if(pRegion)
			{
				m_pCurRegion = pRegion;
			}
			if (m_pCurRegion)
			{
				if (m_pCurRegion->m_pArticulation)
				{
					m_pCurArticulation = m_pCurRegion->m_pArticulation;
				}
				else
				{
					m_pCurArticulation = m_pInstrument->GetCurrentArticulation();
				}
			}
			else if (m_pInstrument->GetCurrentArticulation())
			{
				m_pCurArticulation = m_pInstrument->GetCurrentArticulation();
			}
		}

		else if(guid == GUID_RegionNode)
		{
			m_pCurRegion = (CRegion*) m_parent->m_pAttachedNode;
			if (m_pCurRegion->m_pArticulation)
			{
				m_pCurArticulation = m_pCurRegion->m_pArticulation;
			}
			else
			{
				m_pCurArticulation = m_pInstrument->GetCurrentArticulation();
			}
		}
		else if(guid == GUID_ArticulationNode)
		{
			m_pCurArticulation = (CArticulation *)m_parent->m_pAttachedNode;
			
			// Determines that the Articulation has a valid parent
			// either an instrument or a region
		#ifdef _DEBUG
			m_pCurArticulation->ValidateParent();
		#endif 

			BOOL bArtOwnerIsRegion = FALSE;
			void* pArtOwner = m_pCurArticulation->GetOwner(bArtOwnerIsRegion);
			if(bArtOwnerIsRegion)
			{
				m_pCurRegion = static_cast<CRegion*>(pArtOwner);
				ASSERT(m_pCurRegion);
			}
			else
			{
				CRegion* pRegion = m_pInstrument->m_Regions.GetHead();
				if(pRegion)
				{
					m_pCurRegion = pRegion;
				}
			}
		}
		m_parent->m_pAttachedNode = NULL;
	}
}

void CInstrumentFVEditor::SetupInstrument()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	// Set spin control ranges
	m_PatchSpin.SetRange(0, 127);
	m_MSBSpin.SetRange(0, 127);
	m_LSBSpin.SetRange(0, 127);

	char text[INST_SETTINGS_MAX_TEXT];
	CWnd * pDisplay = NULL;

	m_wBank =  (m_pInstrument->m_rInstHeader.Locale.ulBank >> 8) & 0x7F;
	sprintf(text, "%d", m_wBank);
	pDisplay = GetDlgItem(IDC_BANK);	

	if(pDisplay)
	{
		pDisplay->SetWindowText(text);	
	}

	pDisplay = NULL;

	m_wBank2 = m_pInstrument->m_rInstHeader.Locale.ulBank & 0x7F;
	sprintf(text, "%d", m_wBank2);
	
	pDisplay = GetDlgItem(IDC_BANK2);
	if(pDisplay)
	{
		pDisplay->SetWindowText(text);	
	}

	pDisplay = NULL;
	
	m_fIsDrumKit = ((m_pInstrument->m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS) != 0);
	
	pDisplay = GetDlgItem(IDC_DRUMS);
	if(pDisplay)
	{
		((CButton*)pDisplay)->SetCheck(m_fIsDrumKit);
	}

	m_wPatch = m_pInstrument->m_rInstHeader.Locale.ulInstrument;
	sprintf(text, "%d", m_wPatch);	
	
	pDisplay = GetDlgItem(IDC_PATCH);		
	if(pDisplay)
	{
		pDisplay->SetWindowText(text);	
	}

	pDisplay = NULL;
	
	long volToDisplay = -(m_pInstrument->GetMaxVolume());	 
	volToDisplay >>= 16;
	
	if(volToDisplay / 10 == 0 && volToDisplay % 10 == 0)
		sprintf(text, "%02d.%01d", volToDisplay / 10, volToDisplay % 10);
	else
		sprintf(text, "-%02d.%01d", volToDisplay / 10, volToDisplay % 10);
	
	pDisplay = GetDlgItem(IDC_DMAXLEVEL);
	
	if(pDisplay)
	{
		pDisplay->SetWindowText(text);	
	}

	short nLayers = short(m_pInstrument->m_Regions.GetNumberOfLayers());
	m_RegionKeyBoard.SetNumberOfLayers(nLayers);
}

void CInstrumentFVEditor::SetupRegion()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Set spin control ranges
	m_RootNoteSpin.SetRange(0, 127);
	m_RangeSpin.SetRange(0, 127);
	m_ThruSpin.SetRange(0, 127);

	SetRKBMap();

	if (m_pCurRegion == NULL)
	{
		CRegion* pRegion = m_pInstrument->m_Regions.GetHead();
		if(pRegion)
		{
			SetCurRegion(pRegion);
		}
	}
	else
	{
		SetCurRegion(m_pCurRegion);
	}
	SendRegionChange();
}

void CInstrumentFVEditor::SetupArticulation()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	//ASSERT(m_Tabs[0] == NULL);

	UpdateUseInstArt();
	if(m_fUseInstArt)
	{
		SetArticulationStaticIcon(true);
	}
	else
	{
		SetArticulationStaticIcon(false);
	}

	if(m_nCurrentArticulationDlg == IDD_VOLUME_PAGE)
	{
		OnVolumeButton();
	}
	else if(m_nCurrentArticulationDlg == IDD_PITCH_PAGE)
	{
		OnPitchButton();
	}
	else if(m_nCurrentArticulationDlg == IDD_LFO_PAGE)
	{
		OnLfoButton();
	}
	else if(m_nCurrentArticulationDlg == IDD_VIBLFO_PAGE)
	{
		OnViblfoButton();
	}
	else if(m_nCurrentArticulationDlg == IDD_FILTER_PAGE)
	{
		OnFilterButton();
	}

	if(m_pCurArticulation)
	{
		BOOL bIsDLS1 = m_pCurArticulation->IsDLS1();
		m_ArtDLS1Check.SetCheck(bIsDLS1);
		m_VibLFOButton.EnableWindow(!bIsDLS1);
		m_FilterButton.EnableWindow(!bIsDLS1);
	}
}

void CInstrumentFVEditor::SetRKBMap()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    
	// Walk the region list initializing RegionMap

	for( CRegion * pRegion = m_pInstrument->m_Regions.GetHead(); pRegion; pRegion = pRegion->GetNext())
    {
		short nFirstNote = pRegion->m_rRgnHeader.RangeKey.usLow;
		short nLastNote = pRegion->m_rRgnHeader.RangeKey.usHigh;

		// The layer might be bumped up if there's a collision
		short nRegionLayer = short(pRegion->GetLayer());
		int nInsertionLayer = m_RegionKeyBoard.InsertRegion(nRegionLayer, nFirstNote, nLastNote, 0, 127, pRegion->GetWaveName());
		if(nInsertionLayer != nRegionLayer)
		{
			pRegion->SetLayer(nInsertionLayer);
		}

		m_RegionKeyBoard.SetRootNote(pRegion->m_rWSMP.usUnityNote);
	}
}


void CInstrumentFVEditor::CleanupArticluation()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pArtDialog)
	{
		m_pArtDialog->DestroyWindow();
		delete m_pArtDialog;
		m_pArtDialog = NULL;
	}
}

void CInstrumentFVEditor::SetCurArticulation(CArticulation* pArticulation)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pArticulation);
	if(pArticulation == NULL)
		return;
	
	m_pCurArticulation = pArticulation;
	SetArticulationStaticIcon(!(m_pCurRegion && m_pCurArticulation == m_pCurRegion->m_pArticulation));
	UpdateArticulationControls();
	UpdateUseInstArt();
}


void CInstrumentFVEditor::RefreshRegion()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if(m_pCurRegion)
	{
		SetCurRegion(m_pCurRegion);
	}
	if (m_pCurArticulation)
	{
		SetCurArticulation(m_pCurArticulation);
	}

	char text[INST_SETTINGS_MAX_TEXT];
	long volToDisplay = -(m_pInstrument->GetMaxVolume());	 
	volToDisplay >>= 16;
	if(volToDisplay / 10 == 0 && volToDisplay % 10 == 0)
		sprintf(text, "%02d.%01d", volToDisplay / 10, volToDisplay % 10);
	else
		sprintf(text, "-%02d.%01d", volToDisplay / 10, volToDisplay % 10);
	
	CWnd* pDisplay = GetDlgItem(IDC_DMAXLEVEL);
	
	if(pDisplay)
	{
		pDisplay->SetWindowText(text);	
	}

	m_pComponent->m_pIFramework->RefreshNode(m_pCurRegion);
}

void CInstrumentFVEditor::SetCurRegion(CRegion* pRegion)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pRegion);
	if(pRegion == NULL)
	{
		return;
	}

	CWnd * pDisplay = NULL;
	if (m_pCurRegion) 
	{
		m_pCurRegion->m_pInstrumentFVEditor = NULL;
	}
	m_pCurRegion = pRegion;
	m_pCurRegion->m_pInstrumentFVEditor = this;
	m_usActiveLayer = USHORT(pRegion->GetLayer());

	m_fInOnInitialUpdate = true;

	// Set the condition in the combo box
	// Init region conditions combo
	InitRegionConditionsCombo(m_pCurRegion);

	// Set the edit text
	char szWindowText[MAX_BUFFER];
	notetostring(m_pCurRegion->m_rRgnHeader.RangeKey.usLow, szWindowText);
	m_LowRangeEdit.SetWindowText(szWindowText);
	notetostring(m_pCurRegion->m_rRgnHeader.RangeKey.usHigh, szWindowText);
	m_HighRangeEdit.SetWindowText(szWindowText);
	
	m_dwLowerNoteRange = m_pCurRegion->m_rRgnHeader.RangeKey.usLow;
	m_dwUpperNoteRange = m_pCurRegion->m_rRgnHeader.RangeKey.usHigh;

	m_dwLowerVelocityRange = m_pCurRegion->m_rRgnHeader.RangeVelocity.usLow;
	m_dwUpperVelocityRange = m_pCurRegion->m_rRgnHeader.RangeVelocity.usHigh;
	
	CString sText;
	sText.Format("%d", m_dwLowerVelocityRange);
	m_VelocityLowRangeEdit.SetWindowText(sText);
	sText.Format("%d", m_dwUpperVelocityRange);
	m_VelocityHighRangeEdit.SetWindowText(sText);

	// Update spin control positions
	m_RangeSpin.SetPos(m_dwLowerNoteRange);
	m_ThruSpin.SetPos(m_dwUpperNoteRange);

	m_VelocityLowRangeSpin.SetPos(m_dwLowerVelocityRange);
	m_VelocityHighRangeSpin.SetPos(m_dwUpperVelocityRange);

	UpdateRootNote(m_pCurRegion->m_rWSMP.usUnityNote);
	pDisplay = NULL;
    m_fAllowOverlap = m_pCurRegion->m_rRgnHeader.fusOptions & F_RGN_OPTION_SELFNONEXCLUSIVE;

	pDisplay = GetDlgItem(IDC_REGION_OVERLAP);	
	if(pDisplay)
	{
		int state = m_fAllowOverlap ? 1 : 0;

		((CButton *)pDisplay)->SetCheck(state);
	}

	m_dwGroup = m_pCurRegion->m_rRgnHeader.usKeyGroup;
    //set the group
    CComboBox * pCombo = (CComboBox *)GetDlgItem(IDC_REGION_GROUP);
    if(pCombo)
    {
        pCombo->SetCurSel(m_dwGroup);
    }

	DeleteAndSetupWavesForCurrentRegion();

	int nLayer = m_pCurRegion->GetLayer();
	SetLayerScrollInfo(nLayer);

	UpdateUseInstArt();

	SendRegionChange();

	m_fInOnInitialUpdate = false;
}

BEGIN_EVENTSINK_MAP(CInstrumentFVEditor, CFormView)
    //{{AFX_EVENTSINK_MAP(CInstrumentFVEditor)
	ON_EVENT(CInstrumentFVEditor, IDC_REGION_REGIONKEYBOARD, 1 /* RegionSelectedChanged */, OnRegionSelectedChangedRegionRegionkeyboard, VTS_I2 VTS_I2)
	ON_EVENT(CInstrumentFVEditor, IDC_REGION_REGIONKEYBOARD, 2 /* NewRegion */, OnNewRegionRegionRegionkeyboard, VTS_I2 VTS_I4 VTS_I4)
	ON_EVENT(CInstrumentFVEditor, IDC_REGION_REGIONKEYBOARD, 3 /* RangeChanged */, OnRangeChangedRegionRegionkeyboard, VTS_I2 VTS_I4 VTS_I4)
	ON_EVENT(CInstrumentFVEditor, IDC_REGION_REGIONKEYBOARD, 4 /* NotePlayed */, OnNotePlayedRegionRegionkeyboard, VTS_I4 VTS_BOOL)
	ON_EVENT(CInstrumentFVEditor, IDC_REGION_REGIONKEYBOARD, 5 /* RegionMoved */, OnRegionMovedRegionRegionkeyboard, VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2)
	ON_EVENT(CInstrumentFVEditor, IDC_REGION_REGIONKEYBOARD, 6 /* RegionDeleted */, OnRegionDeletedRegionkeyboard, VTS_I2 VTS_I2)
	ON_EVENT(CInstrumentFVEditor, IDC_REGION_REGIONKEYBOARD, 7 /* ActiveLayerChanged */, OnActiveLayerChangedRegionRegionkeyboard, VTS_I2)
	ON_EVENT(CInstrumentFVEditor, IDC_REGION_REGIONKEYBOARD, 8 /* CopyRegion */, OnCopyRegionRegionkeyboard, VTS_I2 VTS_I2 VTS_I2 VTS_I2)
	ON_EVENT(CInstrumentFVEditor, IDC_REGION_REGIONKEYBOARD, 9 /* ScrollLayers */, OnScrollLayersRegionRegionkeyboard, VTS_BOOL)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CInstrumentFVEditor::OnDrums() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_fInOnInitialUpdate)
	{
		return;
	}

	BOOL bOldValue = m_fIsDrumKit;
	if(UpdateData(TRUE))
	{	
		CWnd* pWnd = GetFocus();

		ValidateFullPatch(((UINT*)(&m_fIsDrumKit)), bOldValue, IDC_DRUMS);

		m_pInstrument->RefreshUI(false);	

		if(pWnd)
		{
			pWnd->SetFocus();
		}

		if(FAILED(m_pInstrument->SaveStateForUndo(IDS_DRUM_UNDO_TEXT)))
		{
			// Out Of Memory??
			m_fIsDrumKit = bOldValue;
			UpdateData(FALSE);
			return;
		}

		Update_and_Download(0);//To Do: use code
		
		// Break the Collection reference in the referring bands
		if(m_pInstrument && m_pInstrument->m_pComponent && m_pInstrument->m_pComponent->m_pIFramework)
			m_pInstrument->m_pComponent->m_pIFramework->NotifyNodes(m_pInstrument->m_pCollection, INSTRUMENT_NameChange, NULL);
	}
}

void CInstrumentFVEditor::OnRegionSelectedChangedRegionRegionkeyboard(short nLayer, short nStartNote)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(nLayer == -1)
		return;
	
	CRegion* pRegion = FindRegionFromMap(nLayer, nStartNote);
	if(pRegion)
	{
		// Set the region node as selected
		// OnNodeSelChanged will set the proper current region
		if(m_pCurRegion != pRegion || m_pInstrument->m_Regions.GetCount() == 1)
		{
			if(m_pComponent->m_pIFramework)
				m_pComponent->m_pIFramework->SetSelectedNode(pRegion);
		}
		
		if(pRegion->m_pArticulation && !pRegion->m_bUseInstrumentArticulation)
		{
			SetCurArticulation(pRegion->m_pArticulation);
			SetArticulationStaticIcon(false);
		}
		else
		{
			SetCurArticulation(m_pInstrument->GetCurrentArticulation());	
			SetArticulationStaticIcon(true);
		}

		// Switch the property page if it's showing to show the properties of the current region
		RefreshCurrentRegionPropertyPage();
	}
}



void CInstrumentFVEditor::OnRegionOverlap() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_fInOnInitialUpdate)
	{
		return;
	}

	ASSERT(m_pCurRegion);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(FAILED(m_pInstrument->SaveStateForUndo(IDS_REGION_OVERLAP_UNDO_TEXT)))
		{
			m_fAllowOverlap = !m_fAllowOverlap;
			UpdateData(FALSE);
			return;
		}

		if(m_fAllowOverlap)
	    {			
			m_pCurRegion->m_rRgnHeader.fusOptions |= F_RGN_OPTION_SELFNONEXCLUSIVE;
		}
		else
		{
			m_pCurRegion->m_rRgnHeader.fusOptions &= ~F_RGN_OPTION_SELFNONEXCLUSIVE;
		}

		// Set flag so we know to save file 
		m_pCollection->SetDirtyFlag();
		
		m_pInstrument->UpdateInstrument();
	}
}

void CInstrumentFVEditor::OnRegionUia() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_fInOnInitialUpdate)
	{
		return;
	}
	/*ASSERT(m_pInstrument->GetCurrentArticulation() &&
		   m_pCurRegion->m_pArticulation);*/

	if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_USE_INSTRUMENT_ARTICULATION)))
		return;

	if (UpdateData(TRUE))
	{
		m_pCurRegion->m_bUseInstrumentArticulation = m_fUseInstArt;
		if(m_fUseInstArt)
		{
			m_pCurArticulation = m_pInstrument->GetCurrentArticulation();		
			SetArticulationStaticIcon(true);
		}
		else
		{
			m_pCurArticulation = m_pCurRegion->m_pArticulation;			
			SetArticulationStaticIcon(false);
		}
		SetCurArticulation(m_pCurArticulation);	
		m_pInstrument->UpdateInstrument();
		m_pCollection->SetDirtyFlag();
	}
}

LRESULT CInstrumentFVEditor::OnUpdateMIDIValues(UINT wParam, LONG lParam)
{
	switch(wParam)
	{
		case IDC_REGION_ELRANGE:
		{
			UpdateNoteRange((BYTE)lParam, m_dwUpperNoteRange, true);
			break;
		}
		case IDC_REGION_EURANGE:
		{
			UpdateNoteRange(m_dwLowerNoteRange, (BYTE)lParam, false);
			break;
		}
		case IDC_REGION_ROOT_NOTE:
		{
			UpdateRootNote((BYTE)lParam);
			break;
		}
		default:
			break;
	}

	return 0;
}

// =====================================================================
// OnMidiMsg
//  This is received when user hits a key in the midi keybd.
// RegisterMidi() should have been called for this to work.
// =====================================================================
HRESULT CInstrumentFVEditor::OnMidiMsg(REFERENCE_TIME dwTime, 
									   BYTE bStatus, 
									   BYTE bData1, 
									   BYTE bData2)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(m_pInstrument);
	if(m_pInstrument== NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pCurRegion);
	if(m_pCurRegion == NULL)
	{
		return E_UNEXPECTED;
	}
	
	CString csMenuText;
	BYTE nMsg = bStatus & 0xF0;

	if(nMsg == MIDI_NOTEON)
	{
		if(m_nHasFocus == IDC_REGION_ELRANGE)
		{
			if(m_pCurRegion->m_rRgnHeader.RangeKey.usLow != (WORD) bData1)
			{
				PostMessage(DM_UPDATE_VALUES, IDC_REGION_ELRANGE, bData1);
			}
		}
		else if(m_nHasFocus == IDC_REGION_EURANGE)
		{
			if(m_pCurRegion->m_rRgnHeader.RangeKey.usHigh != (WORD) bData1)
			{
				PostMessage(DM_UPDATE_VALUES, IDC_REGION_EURANGE, bData1);
			}
		}
		else if(m_nHasFocus == IDC_REGION_ROOT_NOTE)
		{
			if(m_pCurRegion->m_rWSMP.usUnityNote != (WORD) bData1)
			{
				PostMessage(DM_UPDATE_VALUES, IDC_REGION_ROOT_NOTE, bData1);
			}
		}
	}

	// Don't play anything if the note is not in the region range
	if(FindRegionFromMap(bData1) == NULL)
	{
		return S_OK;
	}

	CPtrList lstPlayingRegions;
	if(FAILED(m_pInstrument->m_Regions.FindPlayingRegions(bData1, bData2, &lstPlayingRegions)))
	{
		return E_FAIL;
	}

	int nPlayingRegions = lstPlayingRegions.GetCount();
	if(nPlayingRegions == 0)
	{
		return S_OK;
	}

    m_RegionKeyBoard.MidiEvent(bData1, nMsg, bData2);

	bool bAuditionMode = m_pInstrument->GetAuditionMode();
	if(nPlayingRegions == 1 && bAuditionMode == AUDITION_SOLO && (nMsg == MIDI_NOTEON || nMsg == MIDI_NOTEOFF))
	{
        CRegion* pRegion = (CRegion*) lstPlayingRegions.GetHead();
		ASSERT(pRegion);
		if(pRegion)
		{
			SendMessage(DM_REGION_SELECT, pRegion->GetLayer(), pRegion->m_rRgnHeader.RangeKey.usLow);
		}
	}

	// Note Off
	if(nMsg == MIDI_NOTEOFF)
	{
		if ( m_parent->m_nMIDINoteOns[bData1] > 0 )
		{
			m_parent->m_nMIDINoteOns[bData1]--;
		}
	}
	else if (nMsg == MIDI_NOTEON)
	{
		m_parent->m_nMIDINoteOns[bData1]++;
		m_pInstrument->UpdatePatch();
	}
	
	m_pComponent->PlayMIDIEvent(nMsg, bData1, bData2, 5, m_pInstrument->IsDrum());	
	return S_OK;
}

LRESULT CInstrumentFVEditor::OnMIDIRegionSelect(UINT wParam, LONG lParam)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	USHORT usLayer = (USHORT)wParam;
	USHORT usNote = (USHORT)lParam;

    m_RegionKeyBoard.SetCurrentRegion(usLayer, usNote); 
    OnRegionSelectedChangedRegionRegionkeyboard(usLayer, usNote);

	return 0;
}

void CInstrumentFVEditor::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Turn off all the notes that are playing 
	TurnOffMidiNotes();
	
	CPoint tempPoint = point;
	CPoint ptScrollOffset;

	ScreenToClient(&tempPoint);
	ptScrollOffset = GetDeviceScrollPosition();//take into account scrolling of this view
	tempPoint.x += ptScrollOffset.x;
	tempPoint.y += ptScrollOffset.y;

	CRect rcInstPopUp;
	GetControlPosition(IDC_STATIC_INSTRUMENTGROUP, rcInstPopUp);
	
	CRect rcRegionPopUp;
	GetControlPosition(IDC_STATIC_REGIONGROUP, rcRegionPopUp);
	
	CRect rcRegionKeyboardPopUp;
	GetControlPosition(IDC_REGION_REGIONKEYBOARD, rcRegionKeyboardPopUp);

	CRect rcArtPopUp;
	GetControlPosition(IDC_ARTICULATION_STATIC, rcArtPopUp);


	CMenu* pPopupMenu = NULL;
	
	if(rcInstPopUp.PtInRect(tempPoint))
	{
		// Don't do anything if we don't have a menu yet..
		if(m_pContextInstMenu && ::IsMenu(m_pContextInstMenu->m_hMenu) == 0)
			return;

		pPopupMenu =  m_pContextInstMenu->GetSubMenu(0);
	}
	else if(rcRegionPopUp.PtInRect(tempPoint) || rcRegionKeyboardPopUp.PtInRect(tempPoint))
	{
		// Don't do anything if we don't have a menu yet..
		if(m_pContextRegionMenu && ::IsMenu(m_pContextRegionMenu->m_hMenu) == 0)
			return;

		pPopupMenu =  m_pContextRegionMenu->GetSubMenu(0);

		pPopupMenu->EnableMenuItem(IDM_INST_ED_REGION_NEW_REGION, MF_BYCOMMAND | MF_ENABLED);

		if (1 < m_pInstrument->m_Regions.GetCount())//can't delete the only region
		{
			pPopupMenu->EnableMenuItem(ID_INST_ED_REGION_DELETE, MF_BYCOMMAND | MF_ENABLED);
		}
		else
		{
			pPopupMenu->EnableMenuItem(ID_INST_ED_REGION_DELETE, MF_BYCOMMAND | MF_GRAYED);
		}

		short nLayers = m_RegionKeyBoard.GetNumberOfLayers();
		if(nLayers > 4)
		{
			pPopupMenu->EnableMenuItem(ID_INST_ED_LAYER_DELETE, MF_BYCOMMAND | MF_ENABLED);
		}
		else
		{
			pPopupMenu->EnableMenuItem(ID_INST_ED_LAYER_DELETE, MF_BYCOMMAND | MF_GRAYED);
		}
	}
	else if(rcArtPopUp.PtInRect(tempPoint))
	{
		// Don't do anything if we don't have a menu yet..
		if(m_pContextArtMenu && ::IsMenu(m_pContextArtMenu->m_hMenu) == 0)
			return;

		pPopupMenu =  m_pContextArtMenu->GetSubMenu(0);
	}

    if (pPopupMenu)
    {
        // Check to see if paste should be enabled?
	    IDataObject* pIDataObject = NULL;
	    HRESULT hr = OleGetClipboard(&pIDataObject);
        if (SUCCEEDED(hr))
        {
	        CJazzDataObject* pDataObject = new CJazzDataObject();
	        if(pDataObject)
	        {    	
	            // This adds the format and sets the format to the object's current format.
	            if (SUCCEEDED( hr = pDataObject->AddClipFormat(m_cfFormatArt)))
                {    		
	                HRESULT hr = pDataObject->AttemptRead(pIDataObject);
                    if (SUCCEEDED(hr))
                    {
			            pPopupMenu->EnableMenuItem(ID_INST_ED_ARTICULATION_PASTE, MF_BYCOMMAND | MF_ENABLED);
                    }
                    else
                    {
			            pPopupMenu->EnableMenuItem(ID_INST_ED_ARTICULATION_PASTE, MF_BYCOMMAND | MF_GRAYED);
                    }
                    pDataObject->Release();
                }
            }
        pIDataObject->Release();
        }

		pPopupMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
								   point.x,
								   point.y,
								   this,
								   NULL);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CInstrumentFVEditor IPersist::GetClassID

HRESULT CInstrumentFVEditor::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );
    *pClsId = GUID_NULL;//memset( pClsId, 0, sizeof( CLSID ) );
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentFVEditor IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentFVEditor IPersistStream::IsDirty
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentFVEditor::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// I want to know if I am called
	ASSERT(FALSE);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentFVEditor IPersistStream::GetSizeMax
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentFVEditor::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// I want to know if I am called
	ASSERT(FALSE);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentFVEditor IPersistStream::Load
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentFVEditor::Load(IStream* pIStream)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( pIStream != NULL );
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentFVEditor IPersistStream::Save
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentFVEditor::Save(IStream* pIStream, BOOL fClearDirty)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

void CInstrumentFVEditor::OnInstrumentProperties() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_pInstrument->OnShowProperties();
}

void CInstrumentFVEditor::OnRegionProperties() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_pCurRegion->OnShowProperties();
}

void CInstrumentFVEditor::OnInstEdRegionNewRegion() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_REGION_INSERT)))
		return;
	HRESULT hr = m_pInstrument->m_Regions.InsertChildNode(NULL);
}

void CInstrumentFVEditor::OnNewRegionRegionRegionkeyboard(short nLayer, long lower, long upper) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_REGION_INSERT)))
		return;
	HRESULT hr = m_pInstrument->m_Regions.InsertRegion(NULL, nLayer, (USHORT) lower, (USHORT) upper, false);
	if(SUCCEEDED(hr))
	{
		SetLayerScrollInfo(nLayer);
	}
}

void CInstrumentFVEditor::OnRangeChangedRegionRegionkeyboard(short nLayer, long lower, long upper) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
		return;

	if(m_pCurRegion == NULL)
		return;

	if(FAILED(m_pInstrument->SaveStateForUndo(IDS_RANGE_UNDO_TEXT)))
		return;

	TurnOffMidiNotes();

	m_dwLowerNoteRange = lower;
	m_dwUpperNoteRange = upper;
	m_pCurRegion->m_rRgnHeader.RangeKey.usLow = (WORD) lower;
	m_pCurRegion->m_rRgnHeader.RangeKey.usHigh = (WORD) upper;
		
	m_bTouchedByProgram = false;
	m_RangeSpin.SetPos(lower);
	m_ThruSpin.SetPos(upper);

	RegionChangeCommonTasks();
	
	if(m_pInstrument)
		m_pComponent->m_pIFramework->SortChildNodes(&(m_pInstrument->m_Regions));

	if(m_pCurRegion && m_pCurRegion->m_pRegionPropPgMgr)
		m_pCurRegion->m_pRegionPropPgMgr->RefreshData();

}

void CInstrumentFVEditor::SendRegionChange()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pCurRegion);
	if(m_pCurRegion == NULL)
		return;

	m_RegionKeyBoard.SetCurrentRegion(short(m_pCurRegion->GetLayer()), m_pCurRegion->m_rRgnHeader.RangeKey.usLow);				
	m_RegionKeyBoard.SetRootNote((short)m_lUnityNote);
}

CRegion* CInstrumentFVEditor::FindRegionFromMap(short nLayer, short nStartNote)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pInstrument == NULL)
		return NULL; 

	return m_pInstrument->m_Regions.FindRegionFromMap(nLayer, nStartNote);
}

CRegion* CInstrumentFVEditor::FindRegionFromMap(int nNote)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pInstrument == NULL)
		return NULL; 

	return m_pInstrument->m_Regions.FindRegionFromMap(nNote);
}



void CInstrumentFVEditor::OnArticulationDelete() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
}

void CInstrumentFVEditor::OnRegionDelete() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Turn off all the notes to prevent hanging notes
	TurnOffMidiNotes();

	m_pCurRegion->m_bDeletingRegion = true;
	CRegion* pNextRegion = m_pCurRegion->GetNext();
	if(SUCCEEDED(m_pCurRegion->DeleteNode( TRUE )))
	{
		if(pNextRegion)
			SetCurRegion(pNextRegion);
		else
			SetCurRegion(m_pInstrument->m_Regions.GetHead());
	}
}

void CInstrumentFVEditor::OnArticulationCopy() 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = S_OK;

	IStream *pStream = NULL;
	CJazzDataObject *pDataObject = NULL;

	hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
	if(SUCCEEDED(hr))
	{
	    hr = m_pCurArticulation->Save(pStream, TRUE);
	    if(SUCCEEDED(hr))
	    {
	        pDataObject = new CJazzDataObject();
	        if(pDataObject)
	        {
    	        hr = pDataObject->Initialize(m_cfFormatArt, pStream);
		        if (SUCCEEDED(hr))
                {
	                IDataObject *pIDataObject = NULL;			            
    	            hr = pDataObject->QueryInterface(IID_IDataObject, (void **) &pIDataObject);
                    if (SUCCEEDED(hr))
                    {
                        hr = OleSetClipboard(pIDataObject);
                    }

                    if (pIDataObject)
                    {
                        pIDataObject->Release();
                    }
                }
                else    //initialize failed.
                {
                    pDataObject->Release();
                    // stream gets released before returning,
                }
            }
        }
    }

	if(m_pComponent->m_pCopyDataObject != NULL)
	{
		m_pComponent->m_pCopyDataObject->Release();
	}
	        
	m_pComponent->m_pCopyDataObject = pDataObject;

    if (pStream)
    {
	    pStream->Release();
    }
}

void CInstrumentFVEditor::OnArticulationPaste() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = S_OK;
	
	IDataObject* pIDataObject = NULL;
	CJazzDataObject* pDataObject = NULL;
	IStream* pStream = NULL;

	hr = OleGetClipboard(&pIDataObject);
	if(FAILED(hr))
	{
        goto Err;
		// J3 need to handle error properly		
	}

	pDataObject = new CJazzDataObject();
	if(pDataObject == NULL)
	{
		// J3 need to handle error properly		
		hr = E_OUTOFMEMORY;
        goto Err;
	}
	
	// This adds the format and sets the format to the object's current format.
	hr = pDataObject->AddClipFormat(m_cfFormatArt);
	
	ASSERT(SUCCEEDED(hr));
	
	hr = pDataObject->AttemptRead(pIDataObject);
	
	if(FAILED(hr))
	{
		hr = E_FAIL;
        goto Err;
	}
	
	hr = pDataObject->GetIStream(&pStream);
	
	if(hr != S_OK)
	{
		hr = E_FAIL;
        goto Err;
	}
	
	// Seek to the beginning of the stream
	LARGE_INTEGER	liStreamPos;
	liStreamPos.QuadPart = 0;

	hr = pStream->Seek(liStreamPos, STREAM_SEEK_SET, NULL);

	//ASSERT(SUCCEEDED(hr));
    if (SUCCEEDED(hr))
    {
	    m_pCurArticulation->Load(pStream);

		RefreshRegion();
    }
Err:
    if (pStream)
	    pStream->Release(); 

    if (pDataObject)
	    pDataObject->Release();

    if (pIDataObject)
	    pIDataObject->Release();
}

void CInstrumentFVEditor::RegisterMidi() 
{
	REGISTER_MIDI_IN(m_pComponent->m_pIConductor, m_dwCookie)		
}

void CInstrumentFVEditor::UnRegisterMidi()
{
	UNREGISTER_MIDI_IN(m_pComponent->m_pIConductor, m_dwCookie)
	m_dwCookie = 0;
}

bool CInstrumentFVEditor::IsMidiRegistered()
{
	if(m_dwCookie == 0)
		return false;
	else
		return true;
}


void CInstrumentFVEditor::OnSelchangeRegionGroup() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    CComboBox *pCombo = (CComboBox *) GetDlgItem(IDC_REGION_GROUP);
    if (pCombo != NULL)
    {
        int index = pCombo->GetCurSel();
		if (index != CB_ERR && m_pCurRegion)
        {
            m_dwGroup = index;
		    if(m_pCurRegion->m_rRgnHeader.usKeyGroup != (USHORT) m_dwGroup)
			{   //save undo image
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_KEY_GROUP_UNDO_TEXT)))
				{
					m_dwGroup = m_pCurRegion->m_rRgnHeader.usKeyGroup;
					pCombo->SetCurSel(m_dwGroup);
					return;
				}

			    m_pCurRegion->m_rRgnHeader.usKeyGroup = (USHORT) m_dwGroup;
			    // Set flag so we know to save file 
			    m_pCollection->SetDirtyFlag();
			    m_pInstrument->UpdateInstrument();
		    }
        }
    }
}

// =================================================================
// =================================================================
BOOL CInstrumentFVEditor::IsValidMidiNoteText(char * psz)
{
	return isValidNoteString(psz);
}

//EN_CHANGE Handlers to flag when the user has editted a value in an edit control
//Because a SetWindowText() on the edit control will generate an EN_CHANGE notification
//we isolate user input using flags.
void CInstrumentFVEditor::OnChangeBank() 
{	
	if ( !m_bTouchedByProgram && !m_fInOnInitialUpdate )
	{
		if (m_bTouchedBySpinner)
		{
			m_bTouchedBySpinner = false;
			return;
		}
		m_bfTouched |= fBANK;
	}
}

void CInstrumentFVEditor::OnChangeBank2() 
{
	if ( !m_bTouchedByProgram && !m_fInOnInitialUpdate )
	{
		if (m_bTouchedBySpinner)
		{
			m_bTouchedBySpinner = false;
			return;
		}
		m_bfTouched |= fBANK2;
	}
}

void CInstrumentFVEditor::OnChangePatch() 
{
	if ( !m_bTouchedByProgram && !m_fInOnInitialUpdate )
		m_bfTouched |= fPATCH;
}

void CInstrumentFVEditor::OnChangeLowerRange() 
{
	if ( !m_bTouchedByProgram && !m_fInOnInitialUpdate )
		m_bfTouched |= fLOWER_RANGE;
}

void CInstrumentFVEditor::OnChangeUpperRange() 
{
	if ( !m_bTouchedByProgram && !m_fInOnInitialUpdate )
		m_bfTouched |= fUPPER_RANGE;	
}

void CInstrumentFVEditor::OnChangeRootNote() 
{
	if ( !m_bTouchedByProgram && !m_fInOnInitialUpdate )
		m_bfTouched |= fROOT_NOTE;	
}
// End EN_CHANGE Handlers 
// ----------------------------------------------------------------------------------------

LRESULT CInstrumentFVEditor::OnValidate(UINT wParam,LONG lParam)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	switch (wParam)
	{
		case IDC_PATCH:
			ValidatePatch();
			break;
		case IDC_BANK:
			ValidateBank();
			break;
		case IDC_BANK2:
			ValidateBank2();
			break;
		default:
			break;
	}
	return (0);
}

void CInstrumentFVEditor::RegionChangeCommonTasks(bool bUpdateFramework)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pCurRegion);

	// Update RegionKeyBoard
	m_RegionKeyBoard.SetRootNote(m_pCurRegion->m_rWSMP.usUnityNote);
	if (bUpdateFramework)
	{
		// Update Project Tree
		m_pComponent->m_pIFramework->RefreshNode(m_pCurRegion);
	}

	// Recalculate note we will play when space bar is pressed
	m_pInstrument->m_nMIDINote = CalculateAuditionNote();
	// Set flag so we know to save file 
	m_pCollection->SetDirtyFlag();
	// Download changes to the Synth				
	m_pInstrument->UpdateInstrument();
	
	RefreshRegion();
}

void CInstrumentFVEditor::OnKillfocusBank() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	SendMessage(DM_VALIDATE,IDC_BANK);	
}

void CInstrumentFVEditor::ValidateBank()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	UINT uOldBank = m_wBank;

	if ( m_bfTouched & fBANK )
	{
		if(UpdateData(TRUE))
		{
			ValidateFullPatch(&m_wBank, uOldBank, IDC_BANK);
			if ( m_wBank != MSB(m_pInstrument->m_rInstHeader.Locale.ulBank) )
			{	
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_MSB_UNDO_TEXT)))
				{
					// Out Of Memory??
					m_bfTouched &= ~fBANK;
					m_wBank = uOldBank;
					UpdateData(FALSE);
					return;
				}
				Update_and_Download(0);

				// Break the Collection reference in the referring bands
				if(m_pInstrument && m_pInstrument->m_pComponent && m_pInstrument->m_pComponent->m_pIFramework)
					m_pInstrument->m_pComponent->m_pIFramework->NotifyNodes(m_pInstrument->m_pCollection, INSTRUMENT_NameChange, NULL);
			}
			m_bfTouched &= ~fBANK;
		}// if UpdateData
		else
		{
			m_wBank = uOldBank;
			UpdateData(FALSE);
			CString sMSBValue;
			CEdit* pMSBEdit = (CEdit*) GetDlgItem(IDC_BANK);
			if(pMSBEdit)
			{
				pMSBEdit->SetFocus();
				pMSBEdit->SetSel(0, -1);
				PostMessage(DM_BRINGTOTOP);
			}
		}

		// Refresh the Instrument's property page if it's showing
		if(m_pInstrument)
		{
			m_pInstrument->RefreshUI(false);
		}
	}
}


void CInstrumentFVEditor::OnUpdateBank() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	if (!m_MSBSpin)
		return;
	if (!m_bTouchedBySpinner)
	{
		return;
	}
	if(UpdateData(TRUE))
	{	
		if ( m_wBank != MSB(m_pInstrument->m_rInstHeader.Locale.ulBank) )
		{	
			if(FAILED(m_pInstrument->SaveStateForUndo(IDS_MSB_UNDO_TEXT)))
			{
				// Out Of Memory??
				m_wBank = MSB(m_pInstrument->m_rInstHeader.Locale.ulBank);
				UpdateData(FALSE);
				return;
			}

			Update_and_Download(0);

			// Break the Collection reference in the referring bands
			if(m_pInstrument && m_pInstrument->m_pComponent && m_pInstrument->m_pComponent->m_pIFramework)
				m_pInstrument->m_pComponent->m_pIFramework->NotifyNodes(m_pInstrument->m_pCollection, INSTRUMENT_NameChange, NULL);
		}

		// Refresh the Instrument's property page if it's showing
		if(m_pInstrument)
		{
			m_pInstrument->RefreshUI(false);
		}

	}
}

void CInstrumentFVEditor::OnKillfocusBank2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	SendMessage(DM_VALIDATE,IDC_BANK2);	
}

void CInstrumentFVEditor::ValidateBank2()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	UINT uOldBank2 = m_wBank2;

	if ( m_bfTouched & fBANK2 )
	{
		if(UpdateData(TRUE))
		{
			ValidateFullPatch(&m_wBank2, uOldBank2, IDC_BANK2);
			if ( m_wBank2 != LSB(m_pInstrument->m_rInstHeader.Locale.ulBank) )
			{	
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_LSB_UNDO_TEXT)))
				{
					m_bfTouched &= ~fBANK2;
					m_wBank2 = uOldBank2;
					UpdateData(FALSE);
					return;
				}
				Update_and_Download(0);

				// Break the Collection reference in the referring bands
				if(m_pInstrument && m_pInstrument->m_pComponent && m_pInstrument->m_pComponent->m_pIFramework)
					m_pInstrument->m_pComponent->m_pIFramework->NotifyNodes(m_pInstrument->m_pCollection, INSTRUMENT_NameChange, NULL);
			}
			m_bfTouched &= ~fBANK2;
		}
		else
		{
			m_wBank2 = uOldBank2;
			UpdateData(FALSE);

			CEdit* pLSBEdit = (CEdit*) GetDlgItem(IDC_BANK2);

			if(pLSBEdit)
			{
				pLSBEdit->SetFocus();
				pLSBEdit->SetSel(0, -1);
				PostMessage(DM_BRINGTOTOP);
			}

		}
		// Refresh the Instrument's property page if it's showing
		if(m_pInstrument)
		{
			m_pInstrument->RefreshUI(false);
		}

	} 
}

void CInstrumentFVEditor::OnUpdateBank2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	if (!m_LSBSpin)
		return;
	if (!m_bTouchedBySpinner)
	{
		return;
	}
	if(UpdateData(TRUE))
	{	
		if ( m_wBank2 != LSB(m_pInstrument->m_rInstHeader.Locale.ulBank) )
		{	
			if(FAILED(m_pInstrument->SaveStateForUndo(IDS_LSB_UNDO_TEXT)))
			{
				// Out Of Memory??
				m_wBank2 = LSB(m_pInstrument->m_rInstHeader.Locale.ulBank);
				UpdateData(FALSE);
				return;
			}
			Update_and_Download(0);
			
			// Break the Collection reference in the referring bands
			if(m_pInstrument && m_pInstrument->m_pComponent && m_pInstrument->m_pComponent->m_pIFramework)
				m_pInstrument->m_pComponent->m_pIFramework->NotifyNodes(m_pInstrument->m_pCollection, INSTRUMENT_NameChange, NULL);
		}
		
		// Refresh the Instrument's property page if it's showing
		if(m_pInstrument)
		{
			m_pInstrument->RefreshUI(false);
		}

	}
	

}

// =================================================================
// =================================================================
void CInstrumentFVEditor::OnUpdatePatch() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if (!m_bTouchedBySpinner)
	{
		return;
	}
    if ( !m_PatchSpin )
    {
		return;
	}
    ASSERT(m_pInstrument);
    if (UpdateData(TRUE))
    {
		if(m_pInstrument->m_rInstHeader.Locale.ulInstrument != m_wPatch)
        {
			if(FAILED(m_pInstrument->SaveStateForUndo(IDS_PATCH_UNDO_TEXT)))
			{
				m_wPatch = m_pInstrument->m_rInstHeader.Locale.ulInstrument;
				UpdateData(FALSE);
				return;
			}
			Update_and_Download(0);
			
			// Break the Collection reference in the referring bands
			if(m_pInstrument && m_pInstrument->m_pComponent && m_pInstrument->m_pComponent->m_pIFramework)
				m_pInstrument->m_pComponent->m_pIFramework->NotifyNodes(m_pInstrument->m_pCollection, INSTRUMENT_NameChange, NULL);

        }

		// Refresh the Instrument's property page if it's showing
		if(m_pInstrument)
		{
			m_pInstrument->RefreshUI(false);
		}
    }    
}

void CInstrumentFVEditor::OnKillfocusPatch() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	SendMessage(DM_VALIDATE,IDC_PATCH);	
}

void CInstrumentFVEditor::ValidatePatch()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if ( m_bfTouched & fPATCH )
	{
		UINT	uOldPatch = m_wPatch;
		if(UpdateData(TRUE))
		{
			ValidateFullPatch(&m_wPatch, uOldPatch, IDC_PATCH);
			if(m_pInstrument->m_rInstHeader.Locale.ulInstrument != m_wPatch)
			{
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_PATCH_UNDO_TEXT)))
				{
					m_wPatch = uOldPatch;
					UpdateData(FALSE);
					return;
				}
				Update_and_Download(0);
				
				// Break the Collection reference in the referring bands
				if(m_pInstrument && m_pInstrument->m_pComponent && m_pInstrument->m_pComponent->m_pIFramework)
					m_pInstrument->m_pComponent->m_pIFramework->NotifyNodes(m_pInstrument->m_pCollection, INSTRUMENT_NameChange, NULL);

			}
			m_bfTouched &= ~fPATCH;
		}
		else
		{
			m_wPatch = uOldPatch;
			UpdateData(FALSE);
			CEdit* pPatchEdit = (CEdit*) GetDlgItem(IDC_PATCH);

			if(pPatchEdit)
			{
				pPatchEdit->SetFocus();
				pPatchEdit->SetSel(0, -1);
				PostMessage(DM_BRINGTOTOP);
			}

		}

		// Refresh the Instrument's property page if it's showing
		if(m_pInstrument)
		{
			m_pInstrument->RefreshUI(false);
		}
	}
}

// =========================================================================
// Whenever we are dropped down, populate the list with all waves currently present.
// =========================================================================
void CInstrumentFVEditor::OnDropdownRegionWavelink() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (m_pCurRegion)
    {    
		DeleteAndSetupWavesForCurrentRegion();
	}
}


void CInstrumentFVEditor::OnSelchangeRegionWavelink() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	TurnOffMidiNotes();
    CComboBox *pCombo = (CComboBox*) GetDlgItem(IDC_REGION_WAVELINK);
    if (pCombo != NULL)
    {
        int index = pCombo->GetCurSel();
		if (index != CB_ERR)
		{
			CWave* pWave = (CWave*) pCombo->GetItemDataPtr(index);
			if (pWave != m_pWave)
			{
				if ( !m_fInOnInitialUpdate )
				{
					if(FAILED(m_pInstrument->SaveStateForUndo(IDS_WAVELINK_UNDO_TEXT)))
					{
						// Out Of Memory??
						int nItems = pCombo->GetCount();
						for(int nIndex = 0; nIndex < nItems; nIndex++)
						{
							CWave* pWave = (CWave*) pCombo->GetItemDataPtr(nIndex);
							if(pWave == m_pWave)
								break;
						}
						pCombo->SetCurSel(nIndex);

						return;
					}
				}

				// Remember the old root note
				USHORT nOldRoot = m_pCurRegion->m_rWSMP.usUnityNote;
				
				m_pCurRegion->SetWave(pWave);

				if(m_pCurRegion->m_bOverrideWaveRootNote)
					m_pCurRegion->m_rWSMP.usUnityNote = nOldRoot;
				
				UpdateRootNote(m_pCurRegion->m_rWSMP.usUnityNote);
				
				// if overrides were set turn them off for new wave
				m_pCurRegion->m_bOverrideWaveMoreSettings = false;
				m_pCurRegion->m_bOverrideWaveAttenuation = false;
				m_pCurRegion->m_bOverrideWaveFineTune = false;

				m_pInstrument->UpdateInstrument();
			}
		}
		// Update Project Tree
		m_pComponent->m_pIFramework->RefreshNode(m_pCurRegion);
	}
}

void CInstrumentFVEditor::UpdateUseInstArt()
{
	if(m_pCurRegion == NULL)
		return;

	if(m_pCurRegion->m_bUseInstrumentArticulation)
	{	
		if(m_pInstrument->GetCurrentArticulation())
		{
			m_fUseInstArt = true;
			m_pCurArticulation = m_pInstrument->GetCurrentArticulation();
		}
		else
		{
			m_pCurRegion->m_bUseInstrumentArticulation = m_fUseInstArt = false;
			m_pCurArticulation = m_pCurRegion->m_pArticulation;
		}
	}
	else
	{
		if ( m_pCurRegion->m_pArticulation )
		{
			m_fUseInstArt = false;
			m_pCurArticulation = m_pCurRegion->m_pArticulation;
		}
		else
		{
			m_pCurRegion->m_bUseInstrumentArticulation = m_fUseInstArt = true;
			m_pCurArticulation = m_pInstrument->GetCurrentArticulation();
		}
	}	

	CWnd* pDisplay = GetDlgItem(IDC_REGION_UIA);	

	if(pDisplay == NULL)
	{
		return;
	}
	
	if(m_pCurRegion->m_pArticulation == NULL || 
	   m_pInstrument->GetCurrentArticulation() == NULL)
	{
		pDisplay->EnableWindow(FALSE);
	}
	else
	{
		pDisplay->EnableWindow(TRUE);
	}
	((CButton *)pDisplay)->SetCheck(m_fUseInstArt);
}

WORD CInstrumentFVEditor::CalculateAuditionNote()
{
	if(m_pCurRegion == NULL)
		return 0;

	if (m_pCurRegion->m_bOverrideWaveRootNote)
		return (WORD) m_pCurRegion->m_rWSMP.usUnityNote;
	else
		if (m_pCurRegion->m_pWave)
			return (WORD) m_pCurRegion->m_pWave->GetUnityNote();
		else
			return 0;
}

void CInstrumentFVEditor::OnDeltaPosMSBSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int		iRealDelta = pNMUpDown->iDelta;
	int		iProposedPos = pNMUpDown->iPos + pNMUpDown->iDelta;
	BYTE	bNewMSB = (BYTE) m_wBank;
	HRESULT				hr;
	CInstrument*		pDummy;

	*pResult = 0;
	while((iProposedPos >= 0) && (iProposedPos < 128))
	{
		hr = m_pComponent->IsValidPatch(m_pInstrument, MAKE_BANK(m_fIsDrumKit, (bNewMSB + iRealDelta), m_wBank2), (ULONG)m_wPatch, NULL, &pDummy);
		if (SUCCEEDED(hr))
		{
			pNMUpDown->iDelta = iRealDelta;
			m_bTouchedBySpinner = true;
			return;
		}
		if (iRealDelta < 0)
		{
			iRealDelta--;
		}
		else
		{
			iRealDelta++;
		}
		iProposedPos = pNMUpDown->iPos + iRealDelta;
	}
	*pResult = 1;//non-zero allow no change
	// To Do: inform user?
}

void CInstrumentFVEditor::OnDeltaPosLSBSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int		iRealDelta = pNMUpDown->iDelta;
	int		iProposedPos = pNMUpDown->iPos + pNMUpDown->iDelta;
	BYTE	bNewLSB = (BYTE) m_wBank2;
	HRESULT				hr;
	CInstrument*		pDummy;

	*pResult = 0;
	while((iProposedPos >= 0) && (iProposedPos < 128))
	{
		hr = m_pComponent->IsValidPatch(m_pInstrument, MAKE_BANK(m_fIsDrumKit, m_wBank , bNewLSB + iRealDelta), (ULONG)m_wPatch, NULL, &pDummy);
		if (SUCCEEDED(hr))
		{
			pNMUpDown->iDelta = iRealDelta;
			m_bTouchedBySpinner = true;
			return;
		}
		if (iRealDelta < 0)
		{
			iRealDelta--;
		}
		else
		{
			iRealDelta++;
		}
		iProposedPos = pNMUpDown->iPos + iRealDelta;
	}
	*pResult = 1;//non-zero allow no change
	// To Do: inform user?
}

void CInstrumentFVEditor::OnDeltaPosPatchSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int		iRealDelta = pNMUpDown->iDelta;
	int		iProposedPos = pNMUpDown->iPos + pNMUpDown->iDelta;
	BYTE	bNewPatch = (BYTE) m_wPatch;
	HRESULT				hr;
	CInstrument*		pDummy;

	*pResult = 0;
	while((iProposedPos >= 0) && (iProposedPos < 128))
	{
		hr = m_pComponent->IsValidPatch(m_pInstrument, MAKE_BANK(m_fIsDrumKit, m_wBank , m_wBank2), (ULONG)(bNewPatch + iRealDelta), NULL, &pDummy);
		if (SUCCEEDED(hr))
		{
			pNMUpDown->iDelta = iRealDelta;
			m_bTouchedBySpinner = true;
			return;
		}
		if (iRealDelta < 0)
		{
			iRealDelta--;
		}
		else
		{
			iRealDelta++;
		}
		iProposedPos = pNMUpDown->iPos + iRealDelta;
	}
	*pResult = 1;//non-zero allow no change
	// To Do: inform user?
}

void CInstrumentFVEditor::Update_and_Download(UINT uCause)
{
	m_pInstrument->m_rInstHeader.Locale.ulBank = MAKE_BANK(m_fIsDrumKit, m_wBank, m_wBank2);
	m_pInstrument->m_rInstHeader.Locale.ulInstrument = m_wPatch;
	// Set flag so we know to save file
	m_pCollection->SetDirtyFlag();
	m_pInstrument->m_pComponent->m_pIFramework->RefreshNode(m_pInstrument);
	m_pInstrument->UpdateInstrument();
	m_pInstrument->UpdatePatch();
}

void CInstrumentFVEditor::ValidateFullPatch(UINT* pwValidationMember, UINT wOldValue, UINT uControlID)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pwValidationMember);
	if(pwValidationMember == NULL)
	{
		return;
	}

	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	CDLSComponent* pComponent = m_pInstrument->m_pComponent;
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return;
	}

	if(pComponent->IsNoShowUserPatchConflict() == true)
	{
		return;
	}

	CInstrument* pConflictIns = NULL;
	HRESULT			hr;

	hr = m_pComponent->IsValidPatch(m_pInstrument, MAKE_BANK(m_fIsDrumKit, m_wBank, m_wBank2), (ULONG) m_wPatch, m_pCollection, &pConflictIns);
	if ( SUCCEEDED(hr) )
	{
		return;
	}
	if ( (hr & SC_PATCH_DUP_GM) && (m_dwIgnorePatchConflicts & DLS_DLG_IGNORE_ALL_GM) )
	{
		hr &= ~SC_PATCH_DUP_GM;
	}
	if ( (hr & SC_PATCH_DUP_COLLECTION) && (m_dwIgnorePatchConflicts & DLS_DLG_IGNORE_ALL_COLLECTION) )
	{
		hr &= ~SC_PATCH_DUP_COLLECTION;
	}
	if ( (hr & SC_PATCH_DUP_SYNTH) && (m_dwIgnorePatchConflicts & DLS_DLG_IGNORE_ALL_SYNTH) )
	{
		hr &= ~SC_PATCH_DUP_SYNTH;
	}
	if (DLS_ERR_FIRST == hr)
	{
		return;
	}
	CWnd* pEdit;
	CUserPatchConflictDlg* pDlg = new CUserPatchConflictDlg(hr, MAKE_BANK(m_fIsDrumKit, m_wBank, m_wBank2), (ULONG) m_wPatch, pConflictIns);
	int retval = pDlg->DoModal();
	switch (retval)
	{
		case IDOK :
			{
				*pwValidationMember = wOldValue;
				UpdateData(FALSE);
				//setfocus
				pEdit = GetDlgItem(uControlID);
				if (pEdit)
				{
					pEdit->SetFocus();
					((CEdit*)pEdit)->SetSel(0,-1);
				}
				break;
			}

		case IDCANCEL:
			{
				//ignore
				break;
			}

		default:
			{
				//ignore & setflag
				m_dwIgnorePatchConflicts |= retval;
				break;
			}
	}
	delete pDlg;
}


void CInstrumentFVEditor::OnNotePlayedRegionRegionkeyboard(long nNote, BOOL bType) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pInstrument == NULL)
		return;

	// Don't play anything if the note is not in the region range
	if(FindRegionFromMap((int)nNote) == NULL)
		return;

	BYTE nMsg = MIDI_NOTEON;
	if(bType == FALSE)
		nMsg = MIDI_NOTEOFF;

	// Note Off
	if(nMsg == MIDI_NOTEOFF)
	{
		if ( m_parent->m_nMIDINoteOns[nNote] > 0 )
			m_parent->m_nMIDINoteOns[nNote]--;
	}
	else if (nMsg == MIDI_NOTEON)
	{
		if ( m_parent->m_nMIDINoteOns[nNote] > 0 )
			return;
	
		m_parent->m_nMIDINoteOns[nNote]++;
		m_pInstrument->UpdatePatch();          
	}
	m_pComponent->PlayMIDIEvent(nMsg, (BYTE)nNote, BYTE(m_nClickVelocity), 5, m_pInstrument->IsDrum());	
	m_RegionKeyBoard.MidiEvent((short)nNote, nMsg, short(m_nClickVelocity));
	
	// Refresh the property page for the region
	if(m_pCurRegion && m_pCurRegion->m_pRegionPropPgMgr)
	{
		m_pCurRegion->m_pRegionPropPgMgr->RefreshData();
	}

}
  

void CInstrumentFVEditor::OnRegionMovedRegionRegionkeyboard(short nOldLayer, short nOldStartNote, short nMovedLayer, short nMovedStartNote, short nMovedEndNote) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
		return;

	TurnOffMidiNotes();


	CRegion* pRegion = FindRegionFromMap(nOldLayer, nOldStartNote);
	// Must have the old region...if not we have a problem
	ASSERT(pRegion);
	// But let's not crash at least!
	if(pRegion == NULL)
		return;

	m_pCurRegion = pRegion;

	if(pRegion->m_rRgnHeader.RangeKey.usLow != nMovedStartNote || pRegion->GetLayer() != nMovedLayer)
	{
		m_pInstrument->SaveStateForUndo(IDS_UNDO_REGION_MOVE);
	}

	pRegion->SetLayer(nMovedLayer);
	m_dwLowerNoteRange = nMovedStartNote;
	m_dwUpperNoteRange = nMovedEndNote;
	
	pRegion->m_rRgnHeader.RangeKey.usLow = nMovedStartNote;
	pRegion->m_rRgnHeader.RangeKey.usHigh = nMovedEndNote;

	char szNote[5];
	CWnd * pDisplay = NULL;

	pDisplay = GetDlgItem(IDC_REGION_ELRANGE_TEXT);	
	if(pDisplay)
	{
		m_bTouchedByProgram = true;
		notetostring(nMovedStartNote, szNote);
		pDisplay->SetWindowText(szNote);
	}
	pDisplay = GetDlgItem(IDC_REGION_EURANGE_TEXT);	
	if(pDisplay)
	{
		m_bTouchedByProgram = true;
		notetostring(nMovedEndNote, szNote);
		pDisplay->SetWindowText(szNote);
	}

	m_bTouchedByProgram = false;
	m_ThruSpin.SetPos(nMovedEndNote);
	m_RangeSpin.SetPos(nMovedStartNote);
	
	RegionChangeCommonTasks();

	if(m_pInstrument)
		m_pComponent->m_pIFramework->SortChildNodes(&(m_pInstrument->m_Regions));

	if(m_pCurRegion && m_pCurRegion->m_pRegionPropPgMgr)
		m_pCurRegion->m_pRegionPropPgMgr->RefreshData();

}

void CInstrumentFVEditor::RegionWaveChanged()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);


	if(m_pCurRegion)
	{
		DeleteAndSetupWavesForCurrentRegion();
		m_lUnityNote = (long) m_pCurRegion->m_rWSMP.usUnityNote;
	}

	UpdateData(FALSE);
	UpdateRootNote(m_lUnityNote);
}

/* adds the given wave as an entry in the region wavelink dropdown */
void CInstrumentFVEditor::AddWaveToWaveLinkDropdown(CComboBox *pCombo, CWave *pWave)
{
	ASSERT(pWave);
	CString sWaveName = pWave->GetName();
	int index = pCombo->AddString(sWaveName);
    pCombo->SetItemDataPtr(index, pWave);
    if (pWave == m_pWave)
		pCombo->SetCurSel(index);
}

void CInstrumentFVEditor::DeleteAndSetupWavesForCurrentRegion()
{
	CComboBox* pCombo = (CComboBox *) GetDlgItem(IDC_REGION_WAVELINK);

	int nCountItem = pCombo->GetCount();

	pCombo->ResetContent();
	m_pWave = m_pCurRegion->m_pWave;
    
    if (pCombo != NULL && m_pWaves != NULL)
    {
		CPtrList waveList;
		if(FAILED(m_pWaves->GetListOfWaves(&waveList)))
			return;

		POSITION position = waveList.GetHeadPosition();
        while(position)
	        {
			CWave* pWave = (CWave*)waveList.GetNext(position);
			AddWaveToWaveLinkDropdown(pCombo, pWave);

            // if multichannel, add in entries for each channel as well
            LONG cChannels = pWave->GetChannelCount();
            if (cChannels > 1)
	            for (LONG iChannel = 0; iChannel < cChannels; iChannel++)
					AddWaveToWaveLinkDropdown(pCombo, pWave->GetChannel(iChannel));
	        }
    }

	if(pCombo->GetCurSel() == CB_ERR || pCombo->GetItemDataPtr(pCombo->GetCurSel()) == NULL)
	{
		pCombo->SetCurSel(0);
	}

	OnSelchangeRegionWavelink();
}

void CInstrumentFVEditor::OnRegionDeletedRegionkeyboard(short nLayer, short nStartNote) 
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
		return;

	TurnOffMidiNotes();

	if(m_pCurRegion)
	{
		if(m_pCurRegion->GetLayer() != nLayer && m_pCurRegion->m_rRgnHeader.RangeKey.usLow != nStartNote)
			return; // This is not the region we want to delete

		OnRegionDelete();
	}

}

void CInstrumentFVEditor::SetArticulationStaticIcon(bool bInstrumentLevel)
{
	CButton* pButton = (CButton*)GetDlgItem(IDC_ARTICULATION_STATIC);
	
	if(pButton)
	{
		if(bInstrumentLevel)
			//pButton->SetIcon(m_hInstrumentIcon, false);
			pButton->SetWindowText("Instrument Articulation");
		else
			//pButton->SetIcon(m_hRegionIcon, false);
			pButton->SetWindowText("Region Articulation");
	}
}

LRESULT CInstrumentFVEditor::OnBringToTop(UINT wParam, LONG lParam)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	HWND hwndEditor = NULL;
	m_pInstrument->GetEditorWindow(&hwndEditor);
	if(hwndEditor)
		::BringWindowToTop(hwndEditor);

	m_RegionKeyBoard.ReleaseMouseCapture();

	return 0;
}


void CInstrumentFVEditor::TurnOffMidiNotes()
{
	if(m_parent)
		m_parent->TurnOffMidiNotes();

	if(m_pInstrument)
	{
		m_pInstrument->Stop(true);
		m_pInstrument->TurnOffMidiNotes();
	}

	if(m_RegionKeyBoard.m_hWnd != 0)
		m_RegionKeyBoard.TurnOffMidiNotes();
}

void CInstrumentFVEditor::OnKillfocusRegionElrange() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_nHasFocus = 0;

	// Stop if we're playing 
	TurnOffMidiNotes();

	char szLowRange[MAX_BUFFER];
	m_LowRangeEdit.GetWindowText(szLowRange, MAX_BUFFER);

	int nLowRange = (int)m_dwLowerNoteRange;
	if(isalpha(szLowRange[0]))
	{
		if(IsValidMidiNoteText(szLowRange))
		{
			nLowRange = stringtonote(szLowRange);
		}
	}
	else
	{
		nLowRange = atoi(szLowRange);
	}
	
	UpdateNoteRange(nLowRange, m_dwUpperNoteRange, true);
}


void CInstrumentFVEditor::OnKillfocusRegionEurange() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_nHasFocus = 0;

	// Stop if we're playing 
	TurnOffMidiNotes();

	char szHighRange[MAX_BUFFER];
	m_HighRangeEdit.GetWindowText(szHighRange, MAX_BUFFER);

	int nHighRange = (int)m_dwUpperNoteRange;
	if(isalpha(szHighRange[0]))
	{
		if(IsValidMidiNoteText(szHighRange))
		{
			nHighRange = stringtonote(szHighRange);
		}
	}
	else
	{
		nHighRange = atoi(szHighRange);
	}
	
	UpdateNoteRange(m_dwLowerNoteRange, nHighRange, false);
}


void CInstrumentFVEditor::OnDeltaposRegionRangeSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(iDelta < 0)
		iDelta = -1;
	else if(iDelta > 0)
		iDelta = 1;
	else
		iDelta = 0;

	int nLowRange = iCurPos + iDelta;
	if(nLowRange >= 0 && nLowRange <= 127)
		UpdateNoteRange(nLowRange, m_dwUpperNoteRange, true);
	*pResult = 1;
}

void CInstrumentFVEditor::OnDeltaposRegionThruSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(iDelta < 0)
		iDelta = -1;
	else if(iDelta > 0)
		iDelta = 1;
	else
		iDelta = 0;

	int nHighRange = iCurPos + iDelta;
	if(nHighRange >= 0 && nHighRange <= 127)
		UpdateNoteRange(m_dwLowerNoteRange, nHighRange, false);
	*pResult = 1;
}

void CInstrumentFVEditor::UpdateNoteRange(DWORD dwLowRange, DWORD dwHighRange, bool bSettingLowRange)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pCurRegion);
	if(m_pCurRegion == NULL)
		return;

	// Validate both ranges
	// Always false
	//if(dwLowRange < 0)
	//	dwLowRange = 0;
	if(dwLowRange > 127)
		dwLowRange = 127;

	// Always false
	//if(dwHighRange < 0)
	//	dwHighRange = 0;
	if(dwHighRange > 127)
		dwHighRange = 127;

	DWORD dwCheckRange = dwHighRange;
	if(bSettingLowRange)
		dwCheckRange = dwLowRange;
	CRegion* pRegion = FindRegionFromMap(dwCheckRange);
	if(pRegion == NULL)
	{
		if(dwLowRange > dwHighRange || dwHighRange < dwLowRange)
		{
			dwHighRange = dwCheckRange;
			dwLowRange = dwCheckRange;
		}
	}

	BOOL bSuccess = m_RegionKeyBoard.SetRange((short)dwLowRange, (short)dwHighRange, (short)m_dwLowerVelocityRange, (short)m_dwUpperVelocityRange);
	if(bSuccess)
	{
		// Save the undo state if the values are different
		if(!m_fInOnInitialUpdate && (dwLowRange != m_dwLowerNoteRange || dwHighRange != m_dwUpperNoteRange))
		{
			if(FAILED(m_pInstrument->SaveStateForUndo(IDS_RANGE_UNDO_TEXT)))
			{
				// Out Of Memory??
				m_RegionKeyBoard.SetRange((short)m_dwLowerNoteRange, (short)m_dwUpperNoteRange, (short)m_dwLowerVelocityRange, (short)m_dwUpperVelocityRange);
				
				// Set the edit text
				char szWindowText[MAX_BUFFER];
				notetostring(m_dwLowerNoteRange, szWindowText);
				m_LowRangeEdit.SetWindowText(szWindowText);
				notetostring(m_dwUpperNoteRange, szWindowText);
				m_HighRangeEdit.SetWindowText(szWindowText);
				return;
			}
		}

		m_dwLowerNoteRange = dwLowRange;
		m_dwUpperNoteRange = dwHighRange;

		m_pCurRegion->m_rRgnHeader.RangeKey.usLow = (USHORT)dwLowRange;
		m_pCurRegion->m_rRgnHeader.RangeKey.usHigh = (USHORT)dwHighRange;

		// Set the edit text
		char szWindowText[MAX_BUFFER];
		notetostring(dwLowRange, szWindowText);
		m_LowRangeEdit.SetWindowText(szWindowText);
		notetostring(dwHighRange, szWindowText);
		m_HighRangeEdit.SetWindowText(szWindowText);

		// Update spin control positions
		m_RangeSpin.SetPos(dwLowRange);
		m_ThruSpin.SetPos(dwHighRange);
		
		if(!m_fInOnInitialUpdate)
			RegionChangeCommonTasks();
	}
			
	m_nStartNoteForCurRegion = m_pCurRegion->m_rRgnHeader.RangeKey.usLow;

	if(m_pCurRegion->m_pRegionPropPgMgr && !m_fInOnInitialUpdate)
		m_pCurRegion->m_pRegionPropPgMgr->RefreshData();
}

void CInstrumentFVEditor::OnKillfocusRegionRootNote() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_nHasFocus = 0;

	// Stop if we're playing 
	TurnOffMidiNotes();

	char szRootNote[MAX_BUFFER];
	m_RootNoteEdit.GetWindowText(szRootNote, MAX_BUFFER);
	
	int nRootNote = m_lUnityNote;
	if(isalpha(szRootNote[0]))
	{
		if(IsValidMidiNoteText(szRootNote))
		{
			nRootNote = stringtonote(szRootNote);
		}
	}
	else
	{
		nRootNote = atoi(szRootNote);
	}

	UpdateRootNote(nRootNote);
}

void CInstrumentFVEditor::OnDeltaposRegionRootNoteSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	
	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	int nRootNote = iCurPos + iDelta;
	UpdateRootNote(nRootNote);
	
	*pResult = 1;
}

// Sets the root note for both the root note edit and the spin control
void CInstrumentFVEditor::UpdateRootNote(int nRootNote)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pCurRegion);
	if(m_pCurRegion == NULL)
		return;

	if(nRootNote < 0)
		nRootNote = 0;
	else if(nRootNote > 127)
		nRootNote = 127;

	if(m_lUnityNote != nRootNote)
	{
		// Save the undo state
		if(!m_fInOnInitialUpdate)
		{
			if(FAILED(m_pInstrument->SaveStateForUndo(IDS_ROOT_UNDO_TEXT)))
			{
				char szRootNote[MAX_BUFFER];
				notetostring(m_lUnityNote, szRootNote);
				m_RootNoteEdit.SetWindowText(szRootNote);
				return;
			}
		}
	}

	m_lUnityNote = nRootNote;
	
	m_RootNoteSpin.SetPos(nRootNote);
	char szRootNote[MAX_BUFFER];
	notetostring(nRootNote, szRootNote);
	m_RootNoteEdit.SetWindowText(szRootNote);

	m_pCurRegion->m_rWSMP.usUnityNote = (USHORT)m_lUnityNote;

	SendRegionChange();
	m_pInstrument->m_nMIDINote = CalculateAuditionNote();
	m_RegionKeyBoard.SetRootNote((short)m_lUnityNote);
	
	// Check for the override root note flag 
	if (m_pCurRegion->m_rWSMP.usUnityNote != m_pCurRegion->m_pWave->GetUnityNote()) 
		m_pCurRegion->m_bOverrideWaveRootNote = true;

	m_pCollection->SetDirtyFlag();
	m_pInstrument->UpdateInstrument();

	if(m_pCurRegion->m_pRegionPropPgMgr && m_pCurRegion->m_pRegionPropPgMgr->m_pRegionPage)
    {
		if(!m_fInOnInitialUpdate)
			m_pCurRegion->m_pRegionPropPgMgr->SetObject(m_pCurRegion);

		CRegionPropPg * pPropPg = m_pCurRegion->m_pRegionPropPgMgr->m_pRegionPage;
        if (pPropPg->GetSafeHwnd())
        {
            // Check the override checkbox. 
			pPropPg->m_fActivateRootNote = m_pCurRegion->m_bOverrideWaveRootNote;
            if (m_pCurRegion->m_rWSMP.usUnityNote != m_pCurRegion->m_pWave->GetUnityNote()) 
			{
				CButton* pCheckBox = (CButton *) pPropPg->GetDlgItem(IDC_OWS_ACTIVE_ROOT_NOTE);
				if (pCheckBox)
				{
					pCheckBox->SetCheck(m_pCurRegion->m_bOverrideWaveRootNote);
				}
            }
			
            // Enable the rootnote box.
			if(m_pCurRegion->m_bOverrideWaveRootNote)
				pPropPg->EnableRootNote(true);
			else
				pPropPg->EnableRootNote(false);

            pPropPg->SetRootNote((BYTE)m_lUnityNote);
        }
	}
}

void CInstrumentFVEditor::OnSetfocusRegionElrange() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_nHasFocus = IDC_REGION_ELRANGE;
	m_LowRangeEdit.SetSel(0, -1);
}

void CInstrumentFVEditor::OnSetfocusRegionEurange() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_nHasFocus = IDC_REGION_EURANGE;
	m_HighRangeEdit.SetSel(0, -1);
}

void CInstrumentFVEditor::OnSetfocusRegionRootNote() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_nHasFocus = IDC_REGION_ROOT_NOTE;
	m_RootNoteEdit.SetSel(0, -1);
}

BOOL CInstrumentFVEditor::SendKeyToChildControl(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWnd* pWnd = GetDlgItem(IDC_DRUMS);
	if(nChar == VK_SPACE && GetFocus() == pWnd)
	{
		((CButton*)pWnd)->SetCheck(!m_fIsDrumKit);
		OnDrums();
		return TRUE;
	}

	pWnd = GetDlgItem(IDC_REGION_OVERLAP);
	if(nChar == VK_SPACE && GetFocus() == pWnd)
	{
		((CButton*)pWnd)->SetCheck(!m_fAllowOverlap);
		OnRegionOverlap();
		return TRUE;
	}

	pWnd = GetDlgItem(IDC_REGION_UIA);
	if(nChar == VK_SPACE && GetFocus() == pWnd)
	{
		((CButton*)pWnd)->SetCheck(!m_fUseInstArt);
		OnRegionUia();
		return TRUE;
	}

	return FALSE;
}

void CInstrumentFVEditor::OnDraw(CDC* pDC) 
{
	CFormView::OnDraw(pDC);

	CPen blackPen(PS_SOLID, 0, RGB(0, 0, 0));
	CPen* pOldPen = pDC->SelectObject(&blackPen);

	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		pStatic->OnDraw(pDC);
	}

	if(pOldPen)
		pDC->SelectObject(pOldPen);
}

CDLSStatic* CInstrumentFVEditor::GetStaticControl(UINT nID)
{
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		if(pStatic->GetID() == nID)
			return pStatic;
	}

	return NULL;
}

void CInstrumentFVEditor::OnPitchButton() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Are we already showing the Pitch dialog?
	if(m_pArtDialog && m_nCurrentArticulationDlg == IDD_PITCH_PAGE)
		return;

	// Kill the old dialog
	if(m_pArtDialog)
	{
		m_pArtDialog->DestroyWindow();
		delete m_pArtDialog;
		m_pArtDialog = NULL;
	}

	// Create the Pitch Envelope dialog and show it
	CPitchDialog* pPitchDialog = new CPitchDialog(m_pCurArticulation);
	pPitchDialog->Create(CPitchDialog::IDD, this);
	pPitchDialog->UpdateArticulation(m_pCurArticulation);
	
	CRect rcBounds;
	if(SUCCEEDED(GetArticulationBounds(rcBounds)))
		pPitchDialog->MoveWindow(&rcBounds);
	pPitchDialog->BringWindowToTop();
	pPitchDialog->ShowWindow(SW_SHOW);

	m_pArtDialog = (CDialog*) pPitchDialog;
	m_nCurrentArticulationDlg = IDD_PITCH_PAGE;

	m_PitchButton.SetCheck(1);
	m_VolumeButton.SetCheck(0);
	m_LFOButton.SetCheck(0);
	m_VibLFOButton.SetCheck(0);
	m_FilterButton.SetCheck(0);
}

void CInstrumentFVEditor::OnLfoButton() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Are we already showing the LFO dialog?
	if(m_pArtDialog && m_nCurrentArticulationDlg == IDD_LFO_PAGE)
		return;

	// Kill the old dialog
	if(m_pArtDialog)
	{
		m_pArtDialog->DestroyWindow();
		delete m_pArtDialog;
		m_pArtDialog = NULL;
	}

	// Create the Pitch Envelope dialog and show it
	CLFODialog* pLFODialog = new CLFODialog(m_pCurArticulation);
	pLFODialog->Create(CLFODialog::IDD, this);
	pLFODialog->UpdateArticulation(m_pCurArticulation);
	
	CRect rcBounds;
	if(SUCCEEDED(GetArticulationBounds(rcBounds)))
	{
		pLFODialog->MoveWindow(&rcBounds);
	}

	pLFODialog->BringWindowToTop();
	pLFODialog->ShowWindow(SW_SHOW);

	m_pArtDialog = (CDialog*) pLFODialog;
	m_nCurrentArticulationDlg = IDD_LFO_PAGE;
	
	m_LFOButton.SetCheck(1);
	m_VibLFOButton.SetCheck(0);
	m_PitchButton.SetCheck(0);
	m_VolumeButton.SetCheck(0);
	m_FilterButton.SetCheck(0);
}

void CInstrumentFVEditor::OnViblfoButton() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Are we already showing the LFO dialog?
	if(m_pArtDialog && m_nCurrentArticulationDlg == IDD_VIBLFO_PAGE)
		return;

	// Kill the old dialog
	if(m_pArtDialog)
	{
		m_pArtDialog->DestroyWindow();
		delete m_pArtDialog;
		m_pArtDialog = NULL;
	}

	// Create the Pitch Envelope dialog and show it
	CVibratoLFODialog* pVibratoLFODialog = new CVibratoLFODialog(m_pCurArticulation);
	pVibratoLFODialog->Create(CVibratoLFODialog::IDD, this);
	pVibratoLFODialog->UpdateArticulation(m_pCurArticulation);
	
	CRect rcBounds;
	if(SUCCEEDED(GetArticulationBounds(rcBounds)))
	{
		pVibratoLFODialog->MoveWindow(&rcBounds);
	}

	pVibratoLFODialog->BringWindowToTop();
	pVibratoLFODialog->ShowWindow(SW_SHOW);

	m_pArtDialog = (CDialog*) pVibratoLFODialog;
	m_nCurrentArticulationDlg = IDD_VIBLFO_PAGE;
	
	m_VibLFOButton.SetCheck(1);
	m_LFOButton.SetCheck(0);
	m_PitchButton.SetCheck(0);
	m_VolumeButton.SetCheck(0);
	m_FilterButton.SetCheck(0);
}

void CInstrumentFVEditor::OnVolumeButton() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Do we have a valid articulation
	if(m_pCurArticulation == NULL)
		return;

	// Are we already showing the Volume envelope?
	if(m_pArtDialog && m_nCurrentArticulationDlg == IDD_VOLUME_PAGE)
		return;

		// Kill the old dialog
	if(m_pArtDialog)
	{
		m_pArtDialog->DestroyWindow();
		delete m_pArtDialog;
		m_pArtDialog = NULL;
	}

	// Create the Pitch Envelope dialog and show it
	CVolDialog* pVolumeDialog = new CVolDialog(m_pCurArticulation);
	pVolumeDialog->Create(CVolDialog::IDD, this);
	pVolumeDialog->UpdateArticulation(m_pCurArticulation);
	
	CRect rcBounds;
	if(SUCCEEDED(GetArticulationBounds(rcBounds)))
		pVolumeDialog->MoveWindow(&rcBounds);

	pVolumeDialog->BringWindowToTop();
	pVolumeDialog->ShowWindow(SW_SHOW);

	m_pArtDialog = (CDialog*) pVolumeDialog;
	m_nCurrentArticulationDlg = IDD_VOLUME_PAGE;

	m_VolumeButton.SetCheck(1);
	m_PitchButton.SetCheck(0);
	m_LFOButton.SetCheck(0);
	m_VibLFOButton.SetCheck(0);
	m_FilterButton.SetCheck(0);
}


HRESULT CInstrumentFVEditor::GetArticulationBounds(CRect& rcBounds)
{
	CWnd* pArtBounds = GetDlgItem(IDC_ARTICULATION_STATIC);
	ASSERT(pArtBounds);
	if(pArtBounds == NULL)
		return E_FAIL;

	CRect rcEditor;
	GetWindowRect(&rcEditor);
	
	CRect rcArtBoundsScreenRect;
	pArtBounds->GetWindowRect(&rcArtBoundsScreenRect);

	pArtBounds->GetClientRect(&rcBounds);

	rcBounds.left = 10 + rcArtBoundsScreenRect.left - rcEditor.left;
	rcBounds.right = rcArtBoundsScreenRect.Width() - 0;
	rcBounds.top = 50 + rcArtBoundsScreenRect.top - rcEditor.top;
	rcBounds.bottom += rcBounds.top;

	return S_OK;
}

HRESULT CInstrumentFVEditor::GetControlPosition(UINT nID, CRect& rcPosition)
{
	CWnd* pWnd = GetDlgItem(nID);
	ASSERT(pWnd);
	if(pWnd == NULL)
		return E_FAIL;

	CRect rcEditor;
	GetWindowRect(&rcEditor);

	pWnd->GetWindowRect(&rcPosition);

	CRect rcClient;
	pWnd->GetClientRect(&rcClient);
	
	rcPosition.left -= rcEditor.left; 
	rcPosition.right = rcPosition.left + rcClient.Width();
	rcPosition.top -= rcEditor.top;
	rcPosition.bottom = rcPosition.top + rcClient.Height();

	return S_OK;
}


void CInstrumentFVEditor::OnKillfocusRegionVelocityElrange() 
{
	CString sVelocity;
	m_VelocityLowRangeEdit.GetWindowText(sVelocity);
	int nVelocity = atoi(sVelocity);
	UpdateVelocityRange(nVelocity, m_dwUpperVelocityRange, true);
}


void CInstrumentFVEditor::OnKillfocusRegionVelocityEurange() 
{
	CString sVelocity;
	m_VelocityHighRangeEdit.GetWindowText(sVelocity);
	int nVelocity = atoi(sVelocity);
	UpdateVelocityRange(m_dwLowerVelocityRange, nVelocity, false);
}


void CInstrumentFVEditor::OnKillfocusClickVelocity() 
{
	CString sVelocity;
	m_ClickVelocityEdit.GetWindowText(sVelocity);
	int nVelocity = atoi((LPCSTR)sVelocity);

	if(nVelocity < 0 || nVelocity > 127)
	{
		nVelocity = nVelocity < 0 ? 0 : nVelocity;
		nVelocity = nVelocity > 127 ? 127 : nVelocity;

		sVelocity.Format("%d", m_nClickVelocity);
		m_ClickVelocityEdit.SetWindowText(sVelocity);
	}

	m_nClickVelocity = nVelocity;
	m_ClickVelocitySpin.SetPos(nVelocity);
}


void CInstrumentFVEditor::UpdateVelocityRange(DWORD dwLowRange, DWORD dwHighRange, bool bSettingLowRange)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pCurRegion);
	if(m_pCurRegion == NULL)
		return;

	// Validate both ranges
	// Always false
	//if(dwLowRange < 0)
	//	dwLowRange = 0;
	if(dwLowRange > 127)
		dwLowRange = 127;

	// Always false
	//if(dwHighRange < 0)
	//	dwHighRange = 0;
	if(dwHighRange > 127)
		dwHighRange = 127;

	DWORD dwTemp = dwHighRange;
	if(bSettingLowRange)
		dwTemp = dwLowRange;

	if(dwLowRange > dwHighRange)
	{
		dwHighRange = dwTemp;
		dwLowRange = dwTemp;
	}

	BOOL bSuccess = m_RegionKeyBoard.SetRange((short)m_dwLowerNoteRange, (short)m_dwUpperNoteRange, (short)dwLowRange, (short)dwHighRange);
	if(bSuccess)
	{
		// Save the undo state if the values are different
		if(!m_fInOnInitialUpdate && (dwLowRange != m_dwLowerVelocityRange || dwHighRange != m_dwUpperVelocityRange))
		{
			if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_VELOCITY_RANGE_EDIT)))
			{
				// Out Of Memory??
				m_RegionKeyBoard.SetRange((short)m_dwLowerNoteRange, (short)m_dwUpperNoteRange, (short)dwLowRange, (short)dwHighRange);
				
				CString sText;
				sText.Format("%d", m_dwLowerVelocityRange);
				m_VelocityLowRangeEdit.SetWindowText(sText);
				sText.Format("%d", m_dwUpperVelocityRange);
				m_VelocityHighRangeEdit.SetWindowText(sText);
				return;
			}
		}

		m_dwLowerVelocityRange = dwLowRange;
		m_dwUpperVelocityRange = dwHighRange;

		m_pCurRegion->m_rRgnHeader.RangeVelocity.usLow = (USHORT)dwLowRange;
		m_pCurRegion->m_rRgnHeader.RangeVelocity.usHigh = (USHORT)dwHighRange;

		CString sText;
		sText.Format("%d", m_dwLowerVelocityRange);
		m_VelocityLowRangeEdit.SetWindowText(sText);
		sText.Format("%d", m_dwUpperVelocityRange);
		m_VelocityHighRangeEdit.SetWindowText(sText);

		// Update spin control positions
		m_VelocityLowRangeSpin.SetPos(dwLowRange);
		m_VelocityHighRangeSpin.SetPos(dwHighRange);
		
		if(!m_fInOnInitialUpdate)
			RegionChangeCommonTasks();
	}
}

void CInstrumentFVEditor::OnDeltaposRegionVelocityRangeSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(iDelta < 0)
		iDelta = -1;
	else if(iDelta > 0)
		iDelta = 1;
	else
		iDelta = 0;

	int nLowRange = iCurPos + iDelta;
	if(nLowRange >= 0 && nLowRange <= 127)
		UpdateVelocityRange(nLowRange, m_dwUpperVelocityRange, true);
	
	*pResult = 1;
}


void CInstrumentFVEditor::OnDeltaposRegionVelocityThruSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	
	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(iDelta < 0)
		iDelta = -1;
	else if(iDelta > 0)
		iDelta = 1;
	else
		iDelta = 0;

	int nHighRange = iCurPos + iDelta;
	if(nHighRange >= 0 && nHighRange <= 127)
		UpdateVelocityRange(m_dwLowerVelocityRange, nHighRange, false);
	
	*pResult = 1;
}


void CInstrumentFVEditor::OnScrollLayersRegionRegionkeyboard(BOOL bUp) 
{
	short nCurPos = short(m_LayerScrollBar.GetScrollPos());
	short nSBCode = bUp == TRUE ? SB_LINEUP : SB_LINEDOWN;
	int nFirstVisibleLayer = m_RegionKeyBoard.ScrollLayers(nSBCode, nCurPos);
	SetLayerScrollInfo(nFirstVisibleLayer);
}


void CInstrumentFVEditor::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	if(pScrollBar == &m_LayerScrollBar)
	{
		int nCurPos = nPos;
		int nFirstVisibleLayer = m_RegionKeyBoard.ScrollLayers(short(nSBCode), short(nPos));
		SetLayerScrollInfo(nFirstVisibleLayer);
		return;
	}

	
	CFormView::OnVScroll(nSBCode, nPos, pScrollBar);
}

void CInstrumentFVEditor::OnDeltaposClickVelocitySpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iCurPos = pNMUpDown->iPos;
	int iDelta = pNMUpDown->iDelta;

	if(iDelta < 0)
		iDelta = -1;
	else if(iDelta > 0)
		iDelta = 1;
	else
		iDelta = 0;

	m_nClickVelocity = iCurPos + iDelta;
	
	*pResult = 0;
}

CRegion* CInstrumentFVEditor::FindConflictingDLS1Region(USHORT usStartNote, USHORT usEndNote)
{
	// Check if the current region overlaps in range with any region
	CRegion* pRegion = m_pInstrument->m_Regions.GetHead();
	while(pRegion)
	{
		CRegion* pConflictingRegion = pRegion->IsOverlappingRegion(usStartNote, usEndNote);
		if(pConflictingRegion)
		{
			return pConflictingRegion;
		}

		pRegion = pRegion->GetNext();
	}

	return NULL;
}

USHORT CInstrumentFVEditor::GetActiveLayer()
{
	return m_usActiveLayer;
}

void CInstrumentFVEditor::OnActiveLayerChangedRegionRegionkeyboard(short nLayer) 
{
	m_usActiveLayer = nLayer;
	ASSERT(m_pInstrument);
	if(m_pInstrument)
	{
		m_pInstrument->UpdateInstrument();
	}
}

void CInstrumentFVEditor::SetLayerScrollInfo(int nFirstVisibleLayer)
{
	SCROLLINFO scrollInfo;
	scrollInfo.cbSize = sizeof(SCROLLINFO);
	short nLayers = m_RegionKeyBoard.GetNumberOfLayers();
	short nFirstLayerShown = m_RegionKeyBoard.GetFirstVisibleLayer();
	
	if(nFirstVisibleLayer < nFirstLayerShown)
	{
		m_RegionKeyBoard.SetFirstVisibleLayer(short(nFirstVisibleLayer));
	}
	else if(nFirstVisibleLayer >= nFirstLayerShown + 4)
	{
		if(nFirstVisibleLayer + 4 > nLayers)
		{
			nFirstVisibleLayer = nLayers - 4;
		}
		else
		{
			nFirstVisibleLayer = nFirstVisibleLayer - 4;
		}
		
		m_RegionKeyBoard.SetFirstVisibleLayer(short(nFirstVisibleLayer));
	}
	else
	{
		nFirstVisibleLayer = nFirstLayerShown;
	}

	if(nLayers > 4)
	{
		scrollInfo.nMax = nLayers;
		scrollInfo.nMin = 0;
		scrollInfo.nPage = 4;
		scrollInfo.nPos = 0;
		scrollInfo.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
		m_LayerScrollBar.SetScrollInfo(&scrollInfo);
		if(nFirstVisibleLayer == 0)
		{
			m_LayerScrollBar.SetScrollPos(nLayers);
		}
		else
		{
			m_LayerScrollBar.SetScrollPos(nLayers - (nFirstVisibleLayer + 4));
		}
	}
	else
	{
		m_LayerScrollBar.EnableScrollBar(ESB_DISABLE_BOTH);
	}

	// Enable/Disable "DLS1" static control based on the first visible layer
	CClientDC clientDC(this);
	CDLSStatic* pDLS1Static = GetStaticControl(IDC_DLS1_STATIC);
	if(pDLS1Static)
	{
		if(nFirstVisibleLayer != 0)
		{
			CString sLayerText;
			sLayerText.Format("%d", nFirstVisibleLayer);
			pDLS1Static->SetText(sLayerText);
		}
		else
		{
			pDLS1Static->SetText("DLS1");
		}
		
		pDLS1Static->Invalidate(&clientDC);
	}

	// Change the values on the layer statics
	CString sLayerText;
	sLayerText.Format("%d", nFirstVisibleLayer + 1);
	CDLSStatic* pStatic = GetStaticControl(IDC_STATIC_LAYER1);
	if(pStatic)
	{
		pStatic->SetText(sLayerText);
		pStatic->Invalidate(&clientDC);
	}

	sLayerText.Format("%d", nFirstVisibleLayer + 2);
	pStatic = GetStaticControl(IDC_STATIC_LAYER2);
	if(pStatic)
	{
		pStatic->SetText(sLayerText);
		pStatic->Invalidate(&clientDC);
	}

	sLayerText.Format("%d", nFirstVisibleLayer + 3);
	pStatic = GetStaticControl(IDC_STATIC_LAYER3);
	if(pStatic)
	{
		pStatic->SetText(sLayerText);
		pStatic->Invalidate(&clientDC);
	}

	//Invalidate();
}

void CInstrumentFVEditor::OnConditionEditButton() 
{
	ASSERT(m_pCurRegion);
	if(m_pCurRegion == NULL)
		return;

	if(m_pCurRegion->GetConditionalChunk() == NULL)
		return;

	CConditionEditor conditionEditor(this, m_pComponent, m_pCurRegion->m_pConditionalChunk, m_pInstrument);
	if(conditionEditor.DoModal() == IDOK)
	{
		// Add the new condition to the presets list
		InitRegionConditionsCombo(m_pCurRegion);

		// Check what the config is and decide on download
		m_pCurRegion->CheckConfigAndRefreshNode();
	}
}


void CInstrumentFVEditor::InitRegionConditionsCombo(CRegion* pRegion)
{
	if(m_pInstrument == NULL)
		return;

	ASSERT(pRegion);
	if(pRegion == NULL)
		return;

	m_RegionConditionCombo.ResetContent();

	CString sNone;
	sNone.LoadString(IDS_NONE);
	AddStringToCombo(m_RegionConditionCombo, sNone);

	CPtrList lstConditions;
	if(SUCCEEDED(m_pCollection->GetListOfConditions(&lstConditions)))
	{
		POSITION position = lstConditions.GetHeadPosition();
		while(position)
		{
			CConditionalChunk* pConditionalChunk = (CConditionalChunk*) lstConditions.GetNext(position);
			ASSERT(pConditionalChunk);
			if(pConditionalChunk)
			{
				AddStringToCombo(m_RegionConditionCombo, pConditionalChunk->GetName());
			}
		}
	}


	// Now look for the regions condition
	CConditionalChunk* pConditionalChunk = pRegion->GetConditionalChunk();
	ASSERT(pConditionalChunk);
	if(pConditionalChunk)
	{
		CString sConditionName = pConditionalChunk->GetName();
		m_RegionConditionCombo.SelectString(0, sConditionName);
	}
}


void CInstrumentFVEditor::AddStringToCombo(CComboBox& combo, CString& sString)
{
	if(combo.FindStringExact(0, sString) == CB_ERR)
	{
		combo.AddString(sString);
	}
}


void CInstrumentFVEditor::OnSelchangeRegionConditionCombo() 
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
		return;

	ASSERT(m_pCurRegion);
	if(m_pCurRegion == NULL)
		return;

	CString sCondition;
	m_RegionConditionCombo.GetWindowText(sCondition);

	if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_CONDITION)))
	{
		return;
	}

	m_pCurRegion->SetCondition(sCondition);
	m_pCurRegion->CheckConfigAndRefreshNode();

	m_pInstrument->UpdateInstrument();
}

void CInstrumentFVEditor::OnDropdownRegionConditionCombo() 
{
	if(m_pCurRegion)
	{
		InitRegionConditionsCombo(m_pCurRegion);
	}
}

void CInstrumentFVEditor::OnArtDls1Check()
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
		return;

	ASSERT(m_pCurArticulation);
	if(m_pCurArticulation == NULL)
		return;

	int nDLS1Check = m_ArtDLS1Check.GetCheck();
	if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_DLS1_CHECK)))
		return;

	m_pCurArticulation->SetDLS1((BOOL)nDLS1Check);
	UpdateArticulationControls();

    m_pInstrument->UpdateInstrument();
}

void CInstrumentFVEditor::OnFilterButton() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Are we already showing the LFO dialog?
	if(m_pArtDialog && m_nCurrentArticulationDlg == IDD_FILTER_PAGE)
	{
		return;
	}

	// Kill the old dialog
	if(m_pArtDialog)
	{
		m_pArtDialog->DestroyWindow();
		delete m_pArtDialog;
		m_pArtDialog = NULL;
	}

	// Create the Pitch Envelope dialog and show it
	CFilterDialog* pFilterDialog = new CFilterDialog(m_pCurArticulation);
	pFilterDialog->Create(CFilterDialog::IDD, this);
	pFilterDialog->UpdateArticulation(m_pCurArticulation);
	
	CRect rcBounds;
	if(SUCCEEDED(GetArticulationBounds(rcBounds)))
	{
		pFilterDialog->MoveWindow(&rcBounds);
	}

	pFilterDialog->BringWindowToTop();
	pFilterDialog->ShowWindow(SW_SHOW);

	m_pArtDialog = (CDialog*) pFilterDialog;
	m_nCurrentArticulationDlg = IDD_FILTER_PAGE;
	
	m_FilterButton.SetCheck(1);
	m_VibLFOButton.SetCheck(0);
	m_LFOButton.SetCheck(0);
	m_PitchButton.SetCheck(0);
	m_VolumeButton.SetCheck(0);
}

void CInstrumentFVEditor::OnInstEdRegionNewLayer() 
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_LAYER_INSERT)))
	{
		return;
	}

	UINT nOldNumberOfLayers = m_pInstrument->m_Regions.GetNumberOfLayers();

	// Go trhough the regions and bump the regions 
	// in the active layer and above up by one layer
	CRegion* pRegion = m_pInstrument->m_Regions.GetHead();
	while(pRegion)
	{
		USHORT usLayer = USHORT(pRegion->GetLayer());
		if(usLayer >= m_usActiveLayer)
		{
			pRegion->SetLayer(usLayer + 1);
		}

		pRegion = pRegion->GetNext();
	}

	m_pInstrument->m_Regions.SetNumberOfLayers(nOldNumberOfLayers + 1);
	m_RegionKeyBoard.AddNewLayer();
	
	int nFirstVisibleLayer = m_RegionKeyBoard.GetFirstVisibleLayer();

	SetLayerScrollInfo(nFirstVisibleLayer);
}

void CInstrumentFVEditor::OnInstEdLayerDelete() 
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	int nLayers = m_RegionKeyBoard.GetNumberOfLayers();
	if(nLayers <= 4)
	{
		AfxMessageBox(IDS_ERR_DELETE_DEFAULT_LAYER);
		return;
	}

	BOOL bLayerIsEmpty = m_pInstrument->m_Regions.IsLayerEmpty(m_usActiveLayer);
	if(bLayerIsEmpty)
	{
		if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_LAYER_DELETE)))
		{
			return;
		}

		m_pInstrument->m_Regions.SetNumberOfLayers(nLayers - 1);

		// Go trhough the regions and bump the regions 
		// in the active layer and above up by one layer
		CRegion* pRegion = m_pInstrument->m_Regions.GetHead();
		while(pRegion)
		{
			USHORT usLayer = USHORT(pRegion->GetLayer());
			if(usLayer >= m_usActiveLayer)
			{
				pRegion->SetLayer(usLayer - 1);
			}

			pRegion = pRegion->GetNext();
		}

		int nLayers = m_RegionKeyBoard.DeleteActiveLayer();
		if(m_usActiveLayer >= nLayers)
		{
			m_usActiveLayer = nLayers - 1;
			m_usActiveLayer = m_usActiveLayer <= 3 ? 0 : m_usActiveLayer;
		}

		m_RegionKeyBoard.SetCurrentLayer(m_usActiveLayer);
	
		// Figure out which is the first visible layer
		short nFirstLayerShown = m_RegionKeyBoard.GetFirstVisibleLayer();

		if(nLayers < nFirstLayerShown + 4)
		{
			SetLayerScrollInfo(nLayers - 4);
		}
		else  if(m_usActiveLayer > nFirstLayerShown + 4)
		{
			SetLayerScrollInfo(m_usActiveLayer - 4);
		}
	}
	else
	{
		AfxMessageBox(IDS_ERR_DELETE_NONEMPTY_LAYER);
	}
}

void CInstrumentFVEditor::OnRadioMultipleLayers() 
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	m_pInstrument->SetAuditionMode(AUDITION_MULTIPLE);
	m_RegionKeyBoard.SetAuditionMode(AUDITION_MULTIPLE);
	SetAuditionRadioMode();
}

void CInstrumentFVEditor::OnRadioSoloLayer() 
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	m_pInstrument->SetAuditionMode(AUDITION_SOLO);
	m_RegionKeyBoard.SetAuditionMode(AUDITION_SOLO);
	SetAuditionRadioMode();
}

void CInstrumentFVEditor::SetAuditionRadioMode()
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	bool bAuditionMode = m_pInstrument->GetAuditionMode();

	bool bSolo = bAuditionMode == AUDITION_SOLO == true ? true : false;
	bool bMultiple = bAuditionMode == AUDITION_MULTIPLE == true ? true : false;

	CButton* pButton = (CButton*)GetDlgItem(IDC_RADIO_MULTIPLE_LAYERS);
	if(pButton)
	{
		pButton->SetCheck(bMultiple);
	}
	
	pButton = (CButton*)GetDlgItem(IDC_RADIO_SOLO_LAYER);
	if(pButton)
	{
		pButton->SetCheck(bSolo);
	}

}

void CInstrumentFVEditor::OnCopyRegionRegionkeyboard(short nSourceLayer, short nSourceStartNote, short nCopyLayer, short nCopyStartNote) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_REGION_INSERT)))
	{
		return;
	}

	CRegion* pCopiedRegion;
	if(FAILED(m_pInstrument->m_Regions.CopyRegion(nSourceLayer, nSourceStartNote, nCopyLayer, nCopyStartNote, &pCopiedRegion)))
	{
		m_RegionKeyBoard.DeleteRegion(nCopyLayer, nCopyStartNote);
		return;
	}

	ASSERT(pCopiedRegion);
	if(pCopiedRegion)
	{
		m_RegionKeyBoard.SetRange(pCopiedRegion->m_rRgnHeader.RangeKey.usLow, pCopiedRegion->m_rRgnHeader.RangeKey.usHigh, pCopiedRegion->m_rRgnHeader.RangeVelocity.usLow, pCopiedRegion->m_rRgnHeader.RangeVelocity.usHigh);
		SetCurRegion(pCopiedRegion);
		SendRegionChange();
	}
}

void CInstrumentFVEditor::OnWaveEditButton() 
{
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}

	IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return;
	}

	if(m_pCurRegion == NULL)
	{
		return;
	}

	CWaveNode* pWaveNode = m_pCurRegion->GetWaveNode();
	ASSERT(pWaveNode);
	if(pWaveNode == NULL)
	{
		return;
	}

	pIFramework->OpenEditor(pWaveNode);
}


CWnd* CInstrumentFVEditor::GetRegionKeyboardWnd()
{
	return &m_RegionKeyBoard;
}

/* refreshes the property page for the current region, if selected and displayed */
void CInstrumentFVEditor::RefreshCurrentRegionPropertyPage()
{
	if(m_pCurRegion && m_pCurRegion->m_pRegionPropPgMgr)
	{
		IDMUSProdPropSheet* pIPropSheet = NULL;
		m_pCurRegion->m_pRegionPropPgMgr->RefreshData();
	
		if(SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropSheet->IsShowing() == S_OK )
				m_pCurRegion->OnShowProperties();

			RELEASE(pIPropSheet);
		}
	}
}

/* updates both shared and articulation dialog-specific controls to match m_pCurArticulation */
void CInstrumentFVEditor::UpdateArticulationControls()
{
	ASSERT(m_pCurArticulation);
	if (m_pCurArticulation == NULL)
		return;
	
	if (m_pArtDialog == NULL)
		return;

	// dialog-specific controls
	if(m_nCurrentArticulationDlg == IDD_VOLUME_PAGE)
	{
		((CVolDialog*)m_pArtDialog)->UpdateArticulation(m_pCurArticulation);
	}
	else if(m_nCurrentArticulationDlg == IDD_PITCH_PAGE)
	{
		((CPitchDialog*)m_pArtDialog)->UpdateArticulation(m_pCurArticulation);
	}
	else if(m_nCurrentArticulationDlg == IDD_LFO_PAGE)
	{
		((CLFODialog*)m_pArtDialog)->UpdateArticulation(m_pCurArticulation);
	}
	else if(m_nCurrentArticulationDlg == IDD_VIBLFO_PAGE)
	{
		((CVibratoLFODialog*)m_pArtDialog)->UpdateArticulation(m_pCurArticulation);
	}
	else if(m_nCurrentArticulationDlg == IDD_FILTER_PAGE)
	{
		((CFilterDialog*)m_pArtDialog)->UpdateArticulation(m_pCurArticulation);
	}

	// shared controls
	BOOL fDLS1 = m_pCurArticulation->IsDLS1();
	m_ArtDLS1Check.SetCheck(fDLS1);
	m_VibLFOButton.EnableWindow(!fDLS1);
	m_FilterButton.EnableWindow(!fDLS1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentCtl.cpp ===
// InstrumentCtl.cpp : Implementation of the CInstrumentCtrl ActiveX Control class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "Instrument.h"
#include "Articulation.h"
#include "Region.h"
#include "InstrumentFVEditor.h"
#include "InstrumentCtl.h"
#include "DLSLoadSaveUtils.h"
#include "DlsDefsPlus.h"
#include "UndoMan.h"
#include "AboutDlg.h"
#include "Collection.h"
#include "InstrumentPropPgMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int CInstrumentCtrl::m_nInstrumentCtrlRefCount = 0;
HMENU CInstrumentCtrl::m_hMenuInPlace = NULL;


IMPLEMENT_DYNCREATE(CInstrumentCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CInstrumentCtrl, COleControl)
	//{{AFX_MSG_MAP(CInstrumentCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_CHILDACTIVATE()
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	ON_WM_DESTROY()
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_WM_CHAR()
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CInstrumentCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CInstrumentCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CInstrumentCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CInstrumentCtrl, COleControl)
	//{{AFX_EVENT_MAP(CInstrumentCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl Interface map

BEGIN_INTERFACE_MAP(CInstrumentCtrl, COleControl)
	INTERFACE_PART(CInstrumentCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
	INTERFACE_PART(CInstrumentCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
/*
BEGIN_PROPPAGEIDS(CInstrumentCtrl, 1)
	//PROPPAGEID(CInstrumentPropPg::guid)
END_PROPPAGEIDS(CInstrumentCtrl)
*/

/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CInstrumentCtrl, "DLS Designer.InstrumentCtrl.1",
	0xbc964e8a, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CInstrumentCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DInstrument =
		{ 0xbc964e88, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DInstrumentEvents =
		{ 0xbc964e89, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwInstrumentOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE |
	OLEMISC_SIMPLEFRAME;

IMPLEMENT_OLECTLTYPE(CInstrumentCtrl, IDS_INSTRUMENT, _dwInstrumentOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::CInstrumentCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CInstrumentCtrl

BOOL CInstrumentCtrl::CInstrumentCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_INSTRUMENT,
			IDB_INSTRUMENT,
			afxRegApartmentThreading,
			_dwInstrumentOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::CInstrumentCtrl - Constructor

CInstrumentCtrl::CInstrumentCtrl() : 
m_pInstrument(NULL),
m_pAttachedNode(NULL)
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DInstrument, &IID_DInstrumentEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DInstrument;
	m_piidEvents = &IID_DInstrumentEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	EnableSimpleFrame();

	m_nInstrumentCtrlRefCount++;
	
	// J3 we need to do this better maybe a global class that contains m_nMIDINoteOns

	for(int i = 0; i < 128; i++)
	{
		m_nMIDINoteOns[i] = 0;
	}

	m_nLastSpacebarNote = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::~CInstrumentCtrl - Destructor

CInstrumentCtrl::~CInstrumentCtrl()
{
	m_nInstrumentCtrlRefCount--;
}


BOOL CInstrumentCtrl::PreTranslateMessage( MSG* pMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// This is to make sure menu shortcuts (<Alt-key>) get to the menu.
	if (  WM_SYSCHAR == pMsg->message )
	{
		return FALSE;
	}

	// If control key is down we have to exit or IsDialogMessage() will eat the frames accelerators
	if ( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
	{
		return FALSE;
	}

	// Change Enter key into Tab so we can use the Enter key to go to the next control	
	if ((WM_KEYDOWN == pMsg->message) && (VK_RETURN == pMsg->wParam))
		pMsg->wParam = VK_TAB;
	
	// Respond to spacebar with audition
	HWND hEditorHWnd;
	m_pInstrument->GetEditorWindow(&hEditorHWnd);
	CWnd* pParentWnd = CWnd::FromHandle(hEditorHWnd);
	if((WM_KEYDOWN == pMsg->message) && (VK_SPACE == pMsg->wParam) && pParentWnd->IsChild(CWnd::GetFocus())) 
	{
		OnKeyDown(VK_SPACE,0,0);
		return TRUE;
	}
	if((WM_KEYUP == pMsg->message) && (VK_SPACE == pMsg->wParam) && pParentWnd->IsChild(CWnd::GetFocus()))
	{
		OnKeyUp(VK_SPACE,0,0);
		return TRUE;
	}
	// This insures that the tabs are processed in the dialog template
	if(VK_TAB == pMsg->wParam)
	{
		if(IsDialogMessage(pMsg))
			return TRUE;
		else
			return FALSE;
	}
	else
		return COleControl::PreTranslateMessage(pMsg);
} 

/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CInstrumentCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CInstrumentCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CInstrumentCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CInstrumentCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::QueryInterface

STDMETHODIMP CInstrumentCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CInstrumentCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::AttachObjects implementation

HRESULT CInstrumentCtrl::XEditor::AttachObjects(IDMUSProdNode* pNode)
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pNode != NULL );

	HRESULT hr = S_OK;
	GUID guid;

	pNode->GetNodeId(&guid);
	
	pThis->m_pAttachedNode = pNode;
	if(guid == GUID_InstrumentNode)
	{
		pThis->m_pInstrument = (CInstrument *)pNode;
		(pThis->m_pInstrument)->AddRef();
		(pThis->m_pInstrument)->m_pInstrumentCtrl = pThis;
	}

	else if(guid == GUID_RegionNode)
	{
		CRegion* pRegion = (CRegion *)pNode;
		
		CInstrument* pInstrument = pRegion->m_pInstrument;
		
		pThis->m_pInstrument = pInstrument;
		(pThis->m_pInstrument)->AddRef();
		(pThis->m_pInstrument)->m_pInstrumentCtrl = pThis;
	}

	else if(guid == GUID_ArticulationNode)
	{
		CArticulation* pArt = (CArticulation *)pNode;
		
		// Determines that the Articulation has a valid parent
		// either an instrument or a region
#ifdef _DEBUG
		pArt->ValidateParent();
#endif 
		CInstrument* pInstrument = pArt->GetInstrument();
		if(pInstrument)
		{
			pThis->m_pInstrument = pInstrument;
			(pThis->m_pInstrument)->AddRef();
			(pThis->m_pInstrument)->m_pInstrumentCtrl = pThis;
		}
	}
	else
	{
		ASSERT(FALSE);			
		hr = E_FAIL;	
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::OnViewProperties implementation

HRESULT CInstrumentCtrl::XEditor::OnViewProperties()
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, Editor )
	ASSERT_VALID( pThis );
	
	return pThis->m_pInstrument->OnViewProperties();
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::OnInitMenuFilePrint

HRESULT CInstrumentCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::OnFilePrint

HRESULT CInstrumentCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CInstrumentCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::OnFilePrintPreview

HRESULT CInstrumentCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::OnF1Help implementation

HRESULT CInstrumentCtrl::XEditor::OnF1Help()
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, Editor )
	ASSERT_VALID( pThis );
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/DLSDesignerWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CInstrumentCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CInstrumentCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CInstrumentCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return (HRESULT) pThis->ExternalQueryInterface( &iid, ppvObj );
}

STDMETHODIMP CInstrumentCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CInstrumentCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CInstrumentCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	// Translate only if Instrument EDitor has the focus
	if(pThis->m_pInstrumentEditor)
	{
		CWnd* pWnd = pThis->GetFocus();
		if(pWnd == pThis->m_pInstrumentEditor || pThis->m_pInstrumentEditor->IsChild(pWnd))
		{
			if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
			{
				return S_OK;
			}
			else if (pThis->PreTranslateMessage(lpmsg))
			{
				return S_OK;
			}
		}
	}
	return S_FALSE;
}

STDMETHODIMP CInstrumentCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );
	TRACE("Frame Window Activate\n");
	if ( fActivate )
	{
		pThis->SetTransportName();
		pThis->m_pInstrument->m_pComponent->m_pIConductor->SetActiveTransport(pThis->m_pInstrument, BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE);

		if(pThis->m_pInstrumentEditor->IsMidiRegistered() == false)
			pThis->m_pInstrumentEditor->RegisterMidi();
	}
	else
	{
		pThis->m_pInstrument->m_pComponent->m_pIConductor->TransportStopped(pThis->m_pInstrument);
		pThis->m_pInstrumentEditor->UnRegisterMidi();
		pThis->m_pInstrumentEditor->TurnOffMidiNotes();

		pThis->m_pInstrument->Stop(true);
	}
	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CInstrumentCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
    METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );
	TRACE("Doc Window Activate\n");
	if ( fActivate )
	{
		pThis->SetTransportName();
		pThis->m_pInstrument->m_pComponent->m_pIConductor->SetActiveTransport(pThis->m_pInstrument, BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE);
		pThis->m_pInstrumentEditor->RegisterMidi();
		pThis->m_pInstrument->UpdatePatch();
		pThis->m_pInstrument->OnViewProperties();
		pThis->SetFocus();
	}
	else
	{
		pThis->m_pInstrument->m_pComponent->m_pIConductor->TransportStopped(pThis->m_pInstrument);
		pThis->m_pInstrumentEditor->UnRegisterMidi();
		pThis->m_pInstrumentEditor->TurnOffMidiNotes();
		pThis->m_pInstrument->Stop(true);
	}
	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CInstrumentCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}
	return S_OK;
}

STDMETHODIMP CInstrumentCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CInstrumentCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::OnDraw - Drawing function

void CInstrumentCtrl::OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::DoPropExchange - Persistence support

void CInstrumentCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::OnResetState - Reset control to default state

void CInstrumentCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::AboutBox - Display an "About" box to the user

void CInstrumentCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CAboutDlg dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl message handlers

int CInstrumentCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Load control's in-place menu
	if(m_hMenuInPlace == NULL)
		m_hMenuInPlace = ::LoadMenu(theApp.m_hInstance, MAKEINTRESOURCE(IDM_DLS_DESIGNER));

	// Create Collection's view
	m_pInstrumentEditor = new CInstrumentFVEditor(this);

	if( m_pInstrumentEditor == NULL )
	{
		return -1;
	}

	if(m_pInstrum