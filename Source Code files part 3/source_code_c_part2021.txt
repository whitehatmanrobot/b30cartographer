).Equals(b.GetValue(bstart + l * bdir)))
					return false;
			}
			return true;
		}

        public static bool SubArrayCompare(Array a, long astart, Array b, long bstart, long length)
		{
			return SubArrayCompare(a, astart, astart + length, b, bstart, bstart + length);
		}

        public static T[] GetSubArray<T>(T[] source, int index)
        {
            return GetSubArray(source, index, source.Length - index);
        }

        public static T[] GetSubArray<T>(T[] source, int index, int count)
        {
            T[] sub = new T[count];
            for (int i = 0; i < count; i++)
            {
                sub.SetValue(source.GetValue(index + i), i);
            }
            return sub;
        }

        public static T[] DeepClone<T>(T[] source)
        {
            T[] clone = new T[source.Length];
            source.CopyTo(clone, 0);
            return clone;
        }

        /// <summary>
        /// Reverses the bytes in the array
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public static T[] Reverse<T>(T[] source)
        {
            T[] clone = DeepClone(source);
            Array.Reverse(clone);
            return clone;
        }

        /// <summary>
        /// Implementation of the System.Comparison delegate for byte values
        /// </summary>
        /// <param name="left">First byte to compare</param>
        /// <param name="right">Second byte to compare</param>
        /// <returns>
        /// Less than 0: x is less than y.
        /// 0: x equals y.
        /// Greater than 0: x is greater than y.
        /// </returns>
        public static int ByteComparison(byte x, byte y)
        {
            if (x == y)
            {
                return 0;
            }
            else if (x > y)
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }

        /// <summary>
        /// searches an array for another array and returns the index of the start of the found block, or -1 if not found
        /// </summary>
        public static int SearchByteArray(byte []haystack, byte []needle, int startIndex)
        {
            for (int i=startIndex; i<haystack.Length-needle.Length+1; ++i)
            {
                if (haystack[i]==needle[0]) //first byte match, so try more
                {
                    bool match=true;
                    for (int n=1; n<needle.Length; ++n)
                    {
                        if (needle[n]!=haystack[i+n])
                        {
                            match=false;
                            break;
                        }
                    }

                    if (match==true) return i;
                }
            }
            return -1;
        }
	}

    /// <summary>
    /// Compares arrays of type T using a caller-provided System.Comparison<> delegate to 
    /// compare the elements of the arrays.  Does a naive 1-to-1 comparison against the
    /// elements (i.e. two arrays with the same elements but out of order will not compare
    /// as equivalent).
    /// Ascending order only for now.
    /// </summary>
    /// <typeparam name="T">Type of both array's elements</typeparam>
    public class ArrayComparer<T> : System.Collections.Generic.IComparer<Array>
    {
        private Comparison<T> _elementComparer;
        /// <summary>
        /// System.Comparison<> delegate used to compare two elements of type T
        /// </summary>
        public Comparison<T> ElementComparer
        {
            get
            {
                return _elementComparer;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentException("ElementComparer cannot be null");
                }
                _elementComparer = value;
            }
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="elementComparer">A System.Comparison delegate capable of comparing
        /// two values/objects of type T</param>
        public ArrayComparer(Comparison<T> elementComparer)
        {
            ElementComparer = elementComparer;
        }

        /// <summary>
        /// Compares two arrays
        /// </summary>
        /// <param name="left">First array to compare</param>
        /// <param name="right">Second array to compare</param>
        /// <returns>
        /// Less than 0: x is less than y.
        /// 0: x equals y.
        /// Greater than 0: x is greater than y.
        /// </returns>
        public int Compare(Array x, Array y)
        {
            // Compare array existences
            if (x == null && y == null)
            {
                return 0;
            }
            if (x != null && y == null)
            {
                return 1;
            }
            if (x == null && y != null)
            {
                return -1;
            }

            // Compare array lengths
            if (x.Length > y.Length)
            {
                return 1;
            }
            else if (x.Length < y.Length)
            {
                return -1;
            }

            // Compare elements
            for (int i = 0; i < x.Length; i++)
            {
                int comp = ElementComparer((T)x.GetValue(i), (T)y.GetValue(i));
                if (comp != 0)
                {
                    return comp;
                }
            }

            // The arrays are equivalent
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\StressSchedulerTPSControl.Designer.cs ===
namespace ServerTestFramework.Runner
{
    partial class StressSchedulerTPSControl
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.Windows.Forms.Label label1;
            System.Windows.Forms.Label label2;
            System.Windows.Forms.Label label3;
            System.Windows.Forms.Label label4;
            System.Windows.Forms.Label label5;
            System.Windows.Forms.Label label6;
            System.Windows.Forms.Panel panel1;
            System.Windows.Forms.Panel panel2;
            System.Windows.Forms.Label label7;
            System.Windows.Forms.Label label8;
            this.nudMaxThreads = new System.Windows.Forms.NumericUpDown();
            this.lblActiveThreads = new System.Windows.Forms.Label();
            this.chkSineWave = new System.Windows.Forms.CheckBox();
            this.lblSineWaveScale = new System.Windows.Forms.Label();
            this.trkSineWaveMagnitude = new System.Windows.Forms.TrackBar();
            this.trkSineWavePeriod = new System.Windows.Forms.TrackBar();
            this.trkSineWavePhase = new System.Windows.Forms.TrackBar();
            this.lblSineWaveMagnitude = new System.Windows.Forms.Label();
            this.lblSineWavePeriod = new System.Windows.Forms.Label();
            this.lblSineWavePhase = new System.Windows.Forms.Label();
            this.trkReservedThreads = new System.Windows.Forms.TrackBar();
            this.lblReservedThreads = new System.Windows.Forms.Label();
            this.lblScaleTPS = new System.Windows.Forms.Label();
            this.trkScaleTPS = new System.Windows.Forms.TrackBar();
            this.labThreadLifeDesc = new System.Windows.Forms.Label();
            this.nudThreadLife = new System.Windows.Forms.NumericUpDown();
            this.labRampDesc = new System.Windows.Forms.Label();
            this.nudRampTime = new System.Windows.Forms.NumericUpDown();
            this.labRampUnit = new System.Windows.Forms.Label();
            this.lblRampScale = new System.Windows.Forms.Label();
            this.labSleepDesc = new System.Windows.Forms.Label();
            this.nudSleepTime = new System.Windows.Forms.NumericUpDown();
            this.labDelayDesc = new System.Windows.Forms.Label();
            this.nudDelayTime = new System.Windows.Forms.NumericUpDown();
            label1 = new System.Windows.Forms.Label();
            label2 = new System.Windows.Forms.Label();
            label3 = new System.Windows.Forms.Label();
            label4 = new System.Windows.Forms.Label();
            label5 = new System.Windows.Forms.Label();
            label6 = new System.Windows.Forms.Label();
            panel1 = new System.Windows.Forms.Panel();
            panel2 = new System.Windows.Forms.Panel();
            label7 = new System.Windows.Forms.Label();
            label8 = new System.Windows.Forms.Label();
            ((System.ComponentModel.ISupportInitialize)(this.nudMaxThreads)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkSineWaveMagnitude)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkSineWavePeriod)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkSineWavePhase)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkReservedThreads)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkScaleTPS)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudThreadLife)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudRampTime)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudSleepTime)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudDelayTime)).BeginInit();
            this.SuspendLayout();
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new System.Drawing.Point(13, 0);
            label1.Name = "label1";
            label1.Size = new System.Drawing.Size(82, 13);
            label1.TabIndex = 0;
            label1.Text = "Active Threads:";
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Location = new System.Drawing.Point(13, 23);
            label2.Name = "label2";
            label2.Size = new System.Drawing.Size(72, 13);
            label2.TabIndex = 1;
            label2.Text = "Max Threads:";
            // 
            // label3
            // 
            label3.AutoSize = true;
            label3.Location = new System.Drawing.Point(10, 109);
            label3.Name = "label3";
            label3.Size = new System.Drawing.Size(74, 13);
            label3.TabIndex = 5;
            label3.Text = "Current Scale:";
            // 
            // label4
            // 
            label4.AutoSize = true;
            label4.Location = new System.Drawing.Point(19, 130);
            label4.Name = "label4";
            label4.Size = new System.Drawing.Size(28, 13);
            label4.TabIndex = 8;
            label4.Text = "Mag";
            // 
            // label5
            // 
            label5.AutoSize = true;
            label5.Location = new System.Drawing.Point(10, 152);
            label5.Name = "label5";
            label5.Size = new System.Drawing.Size(37, 13);
            label5.TabIndex = 9;
            label5.Text = "Period";
            // 
            // label6
            // 
            label6.AutoSize = true;
            label6.Location = new System.Drawing.Point(10, 174);
            label6.Name = "label6";
            label6.Size = new System.Drawing.Size(37, 13);
            label6.TabIndex = 10;
            label6.Text = "Phase";
            // 
            // panel1
            // 
            panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            panel1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            panel1.Enabled = false;
            panel1.Location = new System.Drawing.Point(3, 76);
            panel1.Name = "panel1";
            panel1.Size = new System.Drawing.Size(185, 1);
            panel1.TabIndex = 16;
            // 
            // panel2
            // 
            panel2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            panel2.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            panel2.Enabled = false;
            panel2.Location = new System.Drawing.Point(3, 204);
            panel2.Name = "panel2";
            panel2.Size = new System.Drawing.Size(185, 1);
            panel2.TabIndex = 17;
            // 
            // label7
            // 
            label7.AutoSize = true;
            label7.Location = new System.Drawing.Point(3, 217);
            label7.Name = "label7";
            label7.Size = new System.Drawing.Size(98, 13);
            label7.TabIndex = 18;
            label7.Text = "Reserved Threads:";
            // 
            // label8
            // 
            label8.AutoSize = true;
            label8.Location = new System.Drawing.Point(3, 265);
            label8.Name = "label8";
            label8.Size = new System.Drawing.Size(61, 13);
            label8.TabIndex = 21;
            label8.Text = "Scale TPS:";
            // 
            // nudMaxThreads
            // 
            this.nudMaxThreads.Location = new System.Drawing.Point(98, 20);
            this.nudMaxThreads.Maximum = new decimal(new int[] {
            600,
            0,
            0,
            0});
            this.nudMaxThreads.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.nudMaxThreads.Name = "nudMaxThreads";
            this.nudMaxThreads.Size = new System.Drawing.Size(57, 20);
            this.nudMaxThreads.TabIndex = 2;
            this.nudMaxThreads.Value = new decimal(new int[] {
            100,
            0,
            0,
            0});
            this.nudMaxThreads.ValueChanged += new System.EventHandler(this.nudMaxThreads_ValueChanged);
            // 
            // lblActiveThreads
            // 
            this.lblActiveThreads.AutoSize = true;
            this.lblActiveThreads.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblActiveThreads.Location = new System.Drawing.Point(95, 0);
            this.lblActiveThreads.Name = "lblActiveThreads";
            this.lblActiveThreads.Size = new System.Drawing.Size(10, 13);
            this.lblActiveThreads.TabIndex = 3;
            this.lblActiveThreads.Text = "-";
            // 
            // chkSineWave
            // 
            this.chkSineWave.AutoSize = true;
            this.chkSineWave.Location = new System.Drawing.Point(3, 89);
            this.chkSineWave.Name = "chkSineWave";
            this.chkSineWave.Size = new System.Drawing.Size(117, 17);
            this.chkSineWave.TabIndex = 4;
            this.chkSineWave.Text = "Sine Wave Scaling";
            this.chkSineWave.UseVisualStyleBackColor = true;
            this.chkSineWave.CheckedChanged += new System.EventHandler(this.chkSineWave_CheckedChanged);
            // 
            // lblSineWaveScale
            // 
            this.lblSineWaveScale.AutoSize = true;
            this.lblSineWaveScale.Location = new System.Drawing.Point(90, 109);
            this.lblSineWaveScale.Name = "lblSineWaveScale";
            this.lblSineWaveScale.Size = new System.Drawing.Size(10, 13);
            this.lblSineWaveScale.TabIndex = 6;
            this.lblSineWaveScale.Text = "-";
            // 
            // trkSineWaveMagnitude
            // 
            this.trkSineWaveMagnitude.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.trkSineWaveMagnitude.AutoSize = false;
            this.trkSineWaveMagnitude.LargeChange = 10;
            this.trkSineWaveMagnitude.Location = new System.Drawing.Point(53, 130);
            this.trkSineWaveMagnitude.Maximum = 100;
            this.trkSineWaveMagnitude.Name = "trkSineWaveMagnitude";
            this.trkSineWaveMagnitude.Size = new System.Drawing.Size(97, 15);
            this.trkSineWaveMagnitude.TabIndex = 7;
            this.trkSineWaveMagnitude.TickFrequency = 10;
            this.trkSineWaveMagnitude.Value = 50;
            this.trkSineWaveMagnitude.Scroll += new System.EventHandler(this.trkSineWaveMagnitude_Scroll);
            // 
            // trkSineWavePeriod
            // 
            this.trkSineWavePeriod.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.trkSineWavePeriod.AutoSize = false;
            this.trkSineWavePeriod.LargeChange = 1;
            this.trkSineWavePeriod.Location = new System.Drawing.Point(53, 152);
            this.trkSineWavePeriod.Maximum = 20;
            this.trkSineWavePeriod.Name = "trkSineWavePeriod";
            this.trkSineWavePeriod.Size = new System.Drawing.Size(97, 15);
            this.trkSineWavePeriod.TabIndex = 11;
            this.trkSineWavePeriod.Value = 20;
            this.trkSineWavePeriod.Scroll += new System.EventHandler(this.trkSineWavePeriod_Scroll);
            // 
            // trkSineWavePhase
            // 
            this.trkSineWavePhase.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.trkSineWavePhase.AutoSize = false;
            this.trkSineWavePhase.LargeChange = 1;
            this.trkSineWavePhase.Location = new System.Drawing.Point(53, 174);
            this.trkSineWavePhase.Maximum = 3;
            this.trkSineWavePhase.Name = "trkSineWavePhase";
            this.trkSineWavePhase.Size = new System.Drawing.Size(97, 15);
            this.trkSineWavePhase.TabIndex = 12;
            this.trkSineWavePhase.Value = 1;
            this.trkSineWavePhase.Scroll += new System.EventHandler(this.trkSineWavePhase_Scroll);
            // 
            // lblSineWaveMagnitude
            // 
            this.lblSineWaveMagnitude.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.lblSineWaveMagnitude.Location = new System.Drawing.Point(149, 130);
            this.lblSineWaveMagnitude.Name = "lblSineWaveMagnitude";
            this.lblSineWaveMagnitude.Size = new System.Drawing.Size(39, 13);
            this.lblSineWaveMagnitude.TabIndex = 13;
            this.lblSineWaveMagnitude.Text = "-";
            // 
            // lblSineWavePeriod
            // 
            this.lblSineWavePeriod.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.lblSineWavePeriod.Location = new System.Drawing.Point(149, 152);
            this.lblSineWavePeriod.Name = "lblSineWavePeriod";
            this.lblSineWavePeriod.Size = new System.Drawing.Size(39, 13);
            this.lblSineWavePeriod.TabIndex = 14;
            this.lblSineWavePeriod.Text = "-";
            // 
            // lblSineWavePhase
            // 
            this.lblSineWavePhase.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.lblSineWavePhase.Location = new System.Drawing.Point(149, 174);
            this.lblSineWavePhase.Name = "lblSineWavePhase";
            this.lblSineWavePhase.Size = new System.Drawing.Size(39, 13);
            this.lblSineWavePhase.TabIndex = 15;
            this.lblSineWavePhase.Text = "-";
            // 
            // trkReservedThreads
            // 
            this.trkReservedThreads.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.trkReservedThreads.AutoSize = false;
            this.trkReservedThreads.Location = new System.Drawing.Point(6, 233);
            this.trkReservedThreads.Maximum = 75;
            this.trkReservedThreads.Name = "trkReservedThreads";
            this.trkReservedThreads.Size = new System.Drawing.Size(182, 20);
            this.trkReservedThreads.TabIndex = 19;
            this.trkReservedThreads.TickFrequency = 5;
            this.trkReservedThreads.Value = 5;
            this.trkReservedThreads.Scroll += new System.EventHandler(this.trkReservedThreads_Scroll);
            // 
            // lblReservedThreads
            // 
            this.lblReservedThreads.AutoSize = true;
            this.lblReservedThreads.Location = new System.Drawing.Point(107, 217);
            this.lblReservedThreads.Name = "lblReservedThreads";
            this.lblReservedThreads.Size = new System.Drawing.Size(10, 13);
            this.lblReservedThreads.TabIndex = 20;
            this.lblReservedThreads.Text = "-";
            // 
            // lblScaleTPS
            // 
            this.lblScaleTPS.AutoSize = true;
            this.lblScaleTPS.Location = new System.Drawing.Point(70, 265);
            this.lblScaleTPS.Name = "lblScaleTPS";
            this.lblScaleTPS.Size = new System.Drawing.Size(10, 13);
            this.lblScaleTPS.TabIndex = 22;
            this.lblScaleTPS.Text = "-";
            // 
            // trkScaleTPS
            // 
            this.trkScaleTPS.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.trkScaleTPS.AutoSize = false;
            this.trkScaleTPS.LargeChange = 100;
            this.trkScaleTPS.Location = new System.Drawing.Point(6, 281);
            this.trkScaleTPS.Maximum = 1000;
            this.trkScaleTPS.Name = "trkScaleTPS";
            this.trkScaleTPS.Size = new System.Drawing.Size(182, 20);
            this.trkScaleTPS.TabIndex = 23;
            this.trkScaleTPS.TickFrequency = 100;
            this.trkScaleTPS.Value = 100;
            this.trkScaleTPS.Scroll += new System.EventHandler(this.trkScaleTPS_Scroll);
            // 
            // labThreadLifeDesc
            // 
            this.labThreadLifeDesc.AutoSize = true;
            this.labThreadLifeDesc.Location = new System.Drawing.Point(13, 49);
            this.labThreadLifeDesc.Name = "labThreadLifeDesc";
            this.labThreadLifeDesc.Size = new System.Drawing.Size(159, 13);
            this.labThreadLifeDesc.TabIndex = 24;
            this.labThreadLifeDesc.Text = "Thread Life:                            (s)";
            // 
            // nudThreadLife
            // 
            this.nudThreadLife.Location = new System.Drawing.Point(98, 47);
            this.nudThreadLife.Maximum = new decimal(new int[] {
            6000,
            0,
            0,
            0});
            this.nudThreadLife.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.nudThreadLife.Name = "nudThreadLife";
            this.nudThreadLife.Size = new System.Drawing.Size(57, 20);
            this.nudThreadLife.TabIndex = 25;
            this.nudThreadLife.Value = new decimal(new int[] {
            120,
            0,
            0,
            0});
            this.nudThreadLife.ValueChanged += new System.EventHandler(this.nudThreadLife_ValueChanged);
            // 
            // labRampDesc
            // 
            this.labRampDesc.AutoSize = true;
            this.labRampDesc.Location = new System.Drawing.Point(3, 315);
            this.labRampDesc.Name = "labRampDesc";
            this.labRampDesc.Size = new System.Drawing.Size(127, 13);
            this.labRampDesc.TabIndex = 26;
            this.labRampDesc.Text = "Ramp Up Time (on Start):";
            // 
            // nudRampTime
            // 
            this.nudRampTime.Location = new System.Drawing.Point(13, 333);
            this.nudRampTime.Maximum = new decimal(new int[] {
            6000,
            0,
            0,
            0});
            this.nudRampTime.Name = "nudRampTime";
            this.nudRampTime.Size = new System.Drawing.Size(61, 20);
            this.nudRampTime.TabIndex = 27;
            this.nudRampTime.Value = new decimal(new int[] {
            5,
            0,
            0,
            0});
            this.nudRampTime.ValueChanged += new System.EventHandler(this.nudRampTime_ValueChanged);
            // 
            // labRampUnit
            // 
            this.labRampUnit.AutoSize = true;
            this.labRampUnit.Location = new System.Drawing.Point(73, 335);
            this.labRampUnit.Name = "labRampUnit";
            this.labRampUnit.Size = new System.Drawing.Size(18, 13);
            this.labRampUnit.TabIndex = 28;
            this.labRampUnit.Text = "(s)";
            // 
            // lblRampScale
            // 
            this.lblRampScale.AutoSize = true;
            this.lblRampScale.Location = new System.Drawing.Point(136, 316);
            this.lblRampScale.Name = "lblRampScale";
            this.lblRampScale.Size = new System.Drawing.Size(10, 13);
            this.lblRampScale.TabIndex = 29;
            this.lblRampScale.Text = "-";
            // 
            // labSleepDesc
            // 
            this.labSleepDesc.AutoSize = true;
            this.labSleepDesc.Location = new System.Drawing.Point(3, 360);
            this.labSleepDesc.Name = "labSleepDesc";
            this.labSleepDesc.Size = new System.Drawing.Size(127, 13);
            this.labSleepDesc.TabIndex = 26;
            this.labSleepDesc.Text = "Sleep time (ms):";
            // 
            // nudSleepTime
            // 
            this.nudSleepTime.Location = new System.Drawing.Point(13, 378);
            this.nudSleepTime.Maximum = new decimal(new int[] {
            10000,
            0,
            0,
            0});
            this.nudSleepTime.Name = "nudSleepTime";
            this.nudSleepTime.Size = new System.Drawing.Size(81, 20);
            this.nudSleepTime.TabIndex = 27;
            this.nudSleepTime.Value = new decimal(new int[] {
            0,
            0,
            0,
            0});
            this.nudSleepTime.ValueChanged += new System.EventHandler(this.nudSleepTime_ValueChanged);
            // 
            // labDelayDesc
            // 
            this.labDelayDesc.AutoSize = true;
            this.labDelayDesc.Location = new System.Drawing.Point(3, 400);
            this.labDelayDesc.Name = "labDelayDesc";
            this.labDelayDesc.Size = new System.Drawing.Size(127, 13);
            this.labDelayDesc.TabIndex = 26;
            this.labDelayDesc.Text = "Delay Time (us):";
            // 
            // nudDelayTime
            // 
            this.nudDelayTime.Location = new System.Drawing.Point(13, 418);
            this.nudDelayTime.Maximum = new decimal(new int[] {
            10000000,
            0,
            0,
            0});
            this.nudDelayTime.Name = "nudDelayTime";
            this.nudDelayTime.Size = new System.Drawing.Size(81, 20);
            this.nudDelayTime.TabIndex = 27;
            this.nudDelayTime.Value = new decimal(new int[] {
            0,
            0,
            0,
            0});
            this.nudDelayTime.ValueChanged += new System.EventHandler(this.nudDelayTime_ValueChanged);
            // 
            // StressSchedulerTPSControl
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.AutoScroll = true;
            this.AutoScrollMinSize = new System.Drawing.Size(148, 275);
            this.Controls.Add(this.lblRampScale);
            this.Controls.Add(this.nudRampTime);
            this.Controls.Add(this.labRampDesc);
#if INSTRUMENTED_SCHEDULER
            this.Controls.Add(this.nudSleepTime);
            this.Controls.Add(this.labSleepDesc);
            this.Controls.Add(this.nudDelayTime);
            this.Controls.Add(this.labDelayDesc);
#endif
            this.Controls.Add(this.nudThreadLife);
            this.Controls.Add(this.labThreadLifeDesc);
            this.Controls.Add(this.trkScaleTPS);
            this.Controls.Add(this.lblScaleTPS);
            this.Controls.Add(label8);
            this.Controls.Add(this.lblReservedThreads);
            this.Controls.Add(this.trkReservedThreads);
            this.Controls.Add(label7);
            this.Controls.Add(panel2);
            this.Controls.Add(panel1);
            this.Controls.Add(this.lblSineWavePhase);
            this.Controls.Add(this.lblSineWavePeriod);
            this.Controls.Add(this.lblSineWaveMagnitude);
            this.Controls.Add(this.trkSineWavePhase);
            this.Controls.Add(this.trkSineWavePeriod);
            this.Controls.Add(label6);
            this.Controls.Add(label5);
            this.Controls.Add(label4);
            this.Controls.Add(this.trkSineWaveMagnitude);
            this.Controls.Add(this.lblSineWaveScale);
            this.Controls.Add(label3);
            this.Controls.Add(this.chkSineWave);
            this.Controls.Add(this.lblActiveThreads);
            this.Controls.Add(this.nudMaxThreads);
            this.Controls.Add(label2);
            this.Controls.Add(label1);
            this.Controls.Add(this.labRampUnit);
            this.Name = "StressSchedulerTPSControl";
            this.Size = new System.Drawing.Size(191, 378);
            ((System.ComponentModel.ISupportInitialize)(this.nudMaxThreads)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkSineWaveMagnitude)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkSineWavePeriod)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkSineWavePhase)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkReservedThreads)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.trkScaleTPS)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudThreadLife)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudRampTime)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudSleepTime)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.nudDelayTime)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.NumericUpDown nudMaxThreads;
        private System.Windows.Forms.Label lblActiveThreads;
        private System.Windows.Forms.CheckBox chkSineWave;
        private System.Windows.Forms.Label lblSineWaveScale;
        private System.Windows.Forms.TrackBar trkSineWaveMagnitude;
        private System.Windows.Forms.TrackBar trkSineWavePeriod;
        private System.Windows.Forms.TrackBar trkSineWavePhase;
        private System.Windows.Forms.Label lblSineWaveMagnitude;
        private System.Windows.Forms.Label lblSineWavePeriod;
        private System.Windows.Forms.Label lblSineWavePhase;
        private System.Windows.Forms.TrackBar trkReservedThreads;
        private System.Windows.Forms.Label lblReservedThreads;
        private System.Windows.Forms.Label lblScaleTPS;
        private System.Windows.Forms.TrackBar trkScaleTPS;
        private System.Windows.Forms.Label labThreadLifeDesc;
        private System.Windows.Forms.NumericUpDown nudThreadLife;
        private System.Windows.Forms.Label labRampDesc;
        private System.Windows.Forms.NumericUpDown nudRampTime;
        private System.Windows.Forms.Label labRampUnit;
        private System.Windows.Forms.Label lblRampScale;
        private System.Windows.Forms.Label labSleepDesc;
        private System.Windows.Forms.NumericUpDown nudSleepTime;
        private System.Windows.Forms.Label labDelayDesc;
        private System.Windows.Forms.NumericUpDown nudDelayTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\AssemblyUtilities.cs ===
using System;
using System.Reflection;

namespace ServerTestFramework.Utilities
{
    public class AssemblyUtils
    {
        public static bool DefaultToLoadingAssemblyDirectly=true;

        /// <summary> Uses DefaultToLoadingAssemblyDirectly to decide whether to load an assembly directly from a file like normal, or whether to load it into memory first to avoid a file lock. </summary>
        public static Assembly LoadAssemblyUsingDefaultMethod(string filename)
        {
            if (DefaultToLoadingAssemblyDirectly)
            {
                return Assembly.LoadFrom(filename);
            }
            else
            {
                return LoadAssemblyBytesAndReferences(filename);
            }
        }

        /// <summary> Loads the bytes for an assembly file then creates the assembly from that, so windows doesn't hold a lock on the file.  The referenced assemblies are then resolved like normal (which WILL lock those files).  The downside is this sometimes confuses debuggers. </summary>
        public static Assembly LoadAssemblyBytesAndReferences(string filename)
        {
            //grab the assembly and the debug symbol bytes
            byte []asmBytes=System.IO.File.ReadAllBytes(filename);
            byte []debugBytes=null;
            try
            {
                string ext=(new System.IO.FileInfo(filename)).Extension;
                if (ext.Length>0)
                {
                    string debugFilename=filename.Substring(0, filename.Length-ext.Length)+".pdb";
                    if (System.IO.File.Exists(debugFilename))
                    {
                        debugBytes=System.IO.File.ReadAllBytes(debugFilename);
                    }
                    else
                    {
                        CoreGlobal.RO.Warn(debugFilename+" does not exist to load symbols from.");
                    }
                }
            }
            catch (System.Exception e)
            {
                CoreGlobal.RO.Warn("Failed to load debug symbols for assembly "+filename+"\n"+e);
            }

            //load the assembly
            Assembly asm;
            if (debugBytes!=null)
            {
                asm=Assembly.Load(asmBytes, debugBytes);
            }
            else
            {
                asm=Assembly.Load(asmBytes);
            }

            //load any assemblies that it references normally (since this isn't automatic when an assembly is loaded from its bytes instead of from a file)
            foreach (AssemblyName refname in asm.GetReferencedAssemblies())
            {
                try
                {
                    Assembly.Load(refname);
                }
                catch (System.Exception e)
                {
                    CoreGlobal.RO.Warn("Unable to load assembly "+refname+" which is referenced by an assembly being loaded: "+filename+"\n"+e);
                }
            }

            return asm;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\TestResult.cs ===
using System;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// All stats-related variables and calculations for stress testing should go in this class.
    /// </summary>
    public class TestResult
    {
        public struct FailureTrace
        {
            public DateTime StartTime;
            public DateTime EndTime;
            public Exception Reason;
        }

        // Member vars
        private int             passed;
        private int             failed;
        private int             deadlocked;
        private int             skipped;
        private int             in_progress;
        private int             threads;
        private TimeSpan        elapsed;
        private DateTime        startTime;
        private DateTime        endTime;
        private bool            isInStartEndBlock=false; //has Start() been called, but not End() yet?
        private object          threadLock = new object();
        private string          name = "";

        private float           tps;
        private RunningAverage  avgShortTps;
        private RunningAverage  avgTps;
        private RunningAverage  avgTps120;
        private RunningAverage  avgPrivateTps;
        private RunningAverage  avgPass30;
        private RunningAverage  avgFail30;
        private int             lastTotal = 0;
        private int             lastSkipped = 0;
        private int             lastPassed = 0;
        private int             lastFailed = 0;
        private int             lastStucked = 0;
        private float           lastTime = 0;
        private float           targetTps = 0;

        private float           newMinLatency; //all latency values are in seconds of time
        private float           currentMinLatency;
        private float           newMaxLatency;
        private float           currentMaxLatency;
        private float           newTotalLatency;
        private int             newTotalLatencySamples;
        private float           currentAvgLatency;

        private int maxFailureTraces = 500;
        private List<FailureTrace> failureTraces = new List<FailureTrace>();

        // Accessors
        public int              Passed              {get {return passed;}}
        public int              Failed              {get {return failed;}}
        public int              Deadlocked          {get {return deadlocked;}}
        public int              Skipped             {get {return skipped;}}
        public int              InProgress          {get {return in_progress;}}
        public int              Threads             {get {return threads;}}
        public int              Total               {get {return passed + failed + deadlocked;}}
        public double           PassRate            {get { int tot = Total; return (tot == 0 ? 0.0 : (double) passed / Total); } }
        public DateTime         StartTime           {get {return startTime;}}
        public DateTime         EndTime             {get {return endTime;}}
        public TimeSpan         Elapsed             {get {return elapsed;}}
        public TimeSpan         ElapsedTime         {get {return DateTime.Now - startTime;}}
        public float            TotalTime           {get {return (float)(DateTime.Now - startTime).TotalSeconds;}}
        public string           Name                {get {return name;} set {name = value;}}
        public float            TargetTps           {get {return targetTps;} set {targetTps = value;}}

        public float            TotalTPS            { get { return ((float) Total / TotalTime); } }
        public float            TotalPrivateTPS     { get { return ((float) (Total + Skipped) / TotalTime); } }
        public float            TPS                 { get { return (tps); } }
        public float            RunningShortTPS     { get { return ((float) avgShortTps.Get()); } }
        public float            RunningTPS          { get { return ((float) avgTps.Get()); } }
        public float            RunningTPS120       { get { return ((float) avgTps120.Get()); } }
        public float            RunningPrivateTPS   { get { return ((float) avgPrivateTps.Get()); } }
        public float            RunningPasses30     { get { return ((float) avgPass30.Get()); } }
        public float            RunningFails30      { get { return ((float) avgFail30.Get()); } } //fail or stuck

        public float            MinLatencyMs        { get { return currentMinLatency*1000.0f; } }
        public float            AvgLatencyMs        { get { return currentAvgLatency*1000.0f; } }
        public float            MaxLatencyMs        { get { return currentMaxLatency*1000.0f; } }

        public IList<FailureTrace> FailureTraces    { get { lock (failureTraces) { return failureTraces.AsReadOnly(); } } }

        public TestResult() : this("<NoName>")
        {
        }

        public TestResult(string testName)
        {
            name = testName;
            Reset();
        }

        /// <summary>
        /// Start counting elapsed time.  The counter is stopped when End is called.  The Elapsed time is cumulative through Start/End pairs.
        /// </summary>
        public void Start()
        {
            startTime = DateTime.Now;
            isInStartEndBlock=true;
        }

        public void End()
        {
            endTime = DateTime.Now;

            //check that Start was actually called
            if (!isInStartEndBlock)
            {
                CoreGlobal.RO.Warn("TestResult.End() was called without a matching TestResult.Start(), time of run will be wrong");
                startTime = DateTime.Now;
            }

            //
            elapsed += endTime - startTime;
            isInStartEndBlock=false;
        }

        public void Reset()
        {
            passed=0;
            failed=0;
            deadlocked=0;
            skipped=0;
            in_progress=0;
            threads=0;
            elapsed=TimeSpan.Zero;
            startTime=DateTime.Now;
            endTime=startTime;
            isInStartEndBlock=false;
            tps=0;

            avgShortTps=new RunningAverage(5);
            avgTps=new RunningAverage(20);
            avgTps120=new RunningAverage(120);
            avgPrivateTps=new RunningAverage(20);
            avgPass30=new RunningAverage(30);
            avgFail30=new RunningAverage(30);

            lastTotal=0;
            lastSkipped=0;
            lastPassed=0;
            lastFailed=0;
            lastStucked=0;
            lastTime=0;
            targetTps=0;

            newMinLatency=0;
            currentMinLatency=0;
            newMaxLatency=0;
            currentMaxLatency=0;
            newTotalLatency=0;
            newTotalLatencySamples=0;
            currentAvgLatency=0;
        }

        public void Pass()
        {
            Interlocked.Increment(ref passed);
        }

        public void Fail()
        {
            Interlocked.Increment(ref failed);
        }

        public void FailTrace(DateTime start, DateTime end, Exception reason)
        {
            Fail();

            if (failureTraces.Count < maxFailureTraces)
            {
                lock (failureTraces)
                {
                    if (failureTraces.Count < maxFailureTraces)
                    {
                        FailureTrace trace;
                        trace.StartTime = start;
                        trace.EndTime = end;
                        trace.Reason = reason;
                        failureTraces.Add(trace);
                    }
                }
            }
        }

        public int MaxFailureTraces
        {
            get { return maxFailureTraces; }
            set
            {
                lock (failureTraces)
                {
                    maxFailureTraces = value;

                    if (failureTraces.Count > value)
                    {
                        failureTraces.RemoveRange(failureTraces.Count, failureTraces.Count - value);
                    }
                }
            }
        }

        public void UnFail() //for a test that failed on the first try, but succeeded later
        {
            Interlocked.Decrement(ref failed);
        }
        
        public void Deadlock()
        {
            Interlocked.Increment(ref deadlocked);
        }

        public void Skip()
        {
            Interlocked.Increment(ref skipped);
        }

        /// <summary>
        /// Increases the count of in progress test runs.
        /// </summary>
        public void BeginInProgress ()
        {
            Interlocked.Increment(ref in_progress);
        }

        /// <summary>
        /// Decreases the count of in progress test runs.
        /// </summary>
        public void EndInProgress ()
        {
            int init, calc;

            do
            {
                init = in_progress;

                if (init == 0)
                {
                    break;
                }
                else if (init < 0)
                {
                    calc = 0;
                }
                else
                {
                    calc = init - 1;
                }
            } while (init != Interlocked.CompareExchange(ref in_progress, calc, init));
        }

        public void AddThread()
        {
            Interlocked.Increment(ref threads);
        }

        public void SubtractThread()
        {
            Interlocked.Decrement(ref threads);
        }

        public void CountLatencyMeasure(float timeInSeconds)
        {
            //update min latency
            while (timeInSeconds<newMinLatency)
            {
                Interlocked.CompareExchange(ref newMinLatency, timeInSeconds, newMinLatency);
            }

            //update max latency
            while (timeInSeconds>newMaxLatency)
            {
                Interlocked.CompareExchange(ref newMaxLatency, timeInSeconds, newMaxLatency);
            }

            //update total latency
            while (true)
            {
                float curF=newTotalLatency;
                if (curF==Interlocked.CompareExchange(ref newTotalLatency, curF+timeInSeconds, curF))
                {
                    break;
                }
            }
            Interlocked.Increment(ref newTotalLatencySamples);
        }

        //This es expected to be called once per second (no more, no less)
        public void TakeSample()
        {
            lock (threadLock)
            {
                float secondsTotal = TotalTime - lastTime;

                if (secondsTotal > 0)
                {
                    int transactions = Total - lastTotal;
                    int totaltransactions = (Skipped - lastSkipped) + transactions;
                    tps = (float)transactions / secondsTotal;
                    float tpsTotal = (float)totaltransactions / secondsTotal;
                    int passes=Passed-lastPassed;
                    int fails=Failed-lastFailed;
                    int stucks=Deadlocked-lastStucked;

                    avgShortTps.Add(tps);
                    avgTps.Add(tps);
                    avgTps120.Add(tps);
                    avgPrivateTps.Add(tpsTotal);
                    avgPass30.Add(passes);
                    avgFail30.Add(fails+stucks);

                    lastTotal = Total;
                    lastSkipped = Skipped;
                    lastPassed = Passed;
                    lastFailed = Failed;
                    lastStucked=Deadlocked;
                    lastTime = TotalTime;

                    if (newMinLatency!=float.MaxValue)
                    {
                        currentMinLatency=newMinLatency;
                        newMinLatency=float.MaxValue;
                    }
                    if (newMaxLatency!=float.MinValue)
                    {
                        currentMaxLatency=newMaxLatency;
                        newMaxLatency=float.MinValue;
                    }
                    if (newTotalLatencySamples>0)
                    {
                        currentAvgLatency=newTotalLatency/newTotalLatencySamples;
                        newTotalLatency=0;
                        newTotalLatencySamples=0;
                    }
                }
            }
        }

        public string GetStatusLine()
        {
            TimeSpan elapsedSpan = ElapsedTime;
            string elapsedTime=
                elapsedSpan.Days.ToString()+"d"+
                elapsedSpan.Hours.ToString("D2")+":"+
                elapsedSpan.Minutes.ToString("D2")+":"+
                elapsedSpan.Seconds.ToString("D2");
            System.Text.StringBuilder sb = new System.Text.StringBuilder(1024);
            sb.Append("[" + Name + "]");
            sb.Append(" | Pass: " + Passed.ToString().PadLeft(7));
            sb.Append(" | Fail: " + Failed.ToString().PadLeft(4));
            sb.Append(" | Dead: " + Deadlocked.ToString().PadLeft(2));
            sb.Append(" | Skip: " + Skipped.ToString().PadLeft(3));
            sb.Append(" | Time: " + elapsedTime);
            sb.Append(" | Tps10: " + RunningTPS.ToString("F2").PadLeft(6));
            sb.Append(" | Rate: " + (PassRate*100).ToString("F1"));
            sb.Append(" | TpsPriv: " + RunningPrivateTPS.ToString("F2").PadLeft(6));
            return sb.ToString();
        }

        public string GetStatusHtmlRow()
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder(1024);
            sb.Append("<tr>\r\n");
            sb.Append("  <td>" + Name + "</td>\r\n");
            sb.Append("  <td>" + Total + "</td>\r\n");
            sb.Append("  <td>" + (PassRate*100).ToString("F1") + "</td>\r\n");
            sb.Append("  <td><font color=");
            if (this.RunningTPS >= TargetTps)
                sb.Append("green>");
            else
                sb.Append("red>");
            sb.Append(this.RunningTPS.ToString("f2")+"</font></td>\r\n");
            sb.Append("  <td>" + TargetTps.ToString("f2") + "</td>\r\n");
            sb.Append("  <td>" + this.RunningPrivateTPS.ToString("f2")+"</td>\r\n");
            sb.Append("</tr>\r\n");
            return sb.ToString();
        }

    }

    /// <summary>
    /// Represents a collection of TestResult objects and provides methods for calculating summary values
    /// </summary>
    public class TestResultCollection : CollectionBase, IEnumerable
    {
        private DateTime    startTime;
        private bool        bStarted = false;

        public TimeSpan     ElapsedTime { get { return DateTime.Now - startTime;}}

        /// <summary>
        /// Creates a new TestResult and adds it to the collection
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public TestResult CreateTestResult(string name)
        {
            if (!bStarted)
            {
                Start();
            }
                
            TestResult r = new TestResult(name);
            List.Add(r);
            return r;
        }

        /// <summary>
        /// Add existing TestResult to collection
        /// </summary>
        /// <param name="r"></param>
        public void AddTestResult(TestResult r)
        {
            if (!bStarted)
            {
                Start();
            }
            List.Add(r);
        }

        public void Start()
        {
            startTime = DateTime.Now;
            bStarted = true;
        }

        public int TotalPassed 
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Passed;
                }
                return v;
            }
        }
                
        public int TotalFailed
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Failed;
                }
                return v;
            }
        }
                
        public int TotalDeadlocked
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Deadlocked;
                }
                return v;
            }
        }
                        
        public int TotalSkipped
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Skipped;
                }
                return v;
            }
        }
                
        public int Total
        { 
            get 
            {
                int v = 0;
                foreach (TestResult r in List)
                {
                    v += r.Total;
                }
                return v;
            }
        }
                
        public float TotalPassRate
        { 
            get 
            {
                return (float)TotalPassed / Total;
            }
        }

        public float TotalTPS()
        {
            float v = 0;
            foreach (TestResult r in List)
            {
                v += r.TotalTPS;
            }
            return v;
        }

        public float TotalRunningTPS()
        {
            float v = 0;
            foreach (TestResult r in List)
            {
                v += r.RunningTPS;
            }
            return v;
        }

        // Does this make sense?
        public float TotalRunningPrivateTPS()
        {
            float v = 0;
            foreach (TestResult r in List)
            {
                v += r.RunningPrivateTPS;
            }
            return v;
        }

        public string GetStatusLine()
        {
            TimeSpan elapsedSpan = ElapsedTime;
            string elapsedTime=
                elapsedSpan.Days.ToString()+"d"+
                elapsedSpan.Hours.ToString("D2")+":"+
                elapsedSpan.Minutes.ToString("D2")+":"+
                elapsedSpan.Seconds.ToString("D2");
            string status = "Pass: " + TotalPassed.ToString().PadLeft(7)+
                " | Fail: " + TotalFailed.ToString().PadLeft(4)+
                " | Dead: " + TotalDeadlocked.ToString().PadLeft(2)+
                " | Skip: " + TotalSkipped.ToString().PadLeft(3)+
                " | Time: " + elapsedTime +
                " | Tps10: " + TotalRunningTPS().ToString("F2").PadLeft(6)+
                " | Rate: " + TotalPassRate.ToString("F1") +
                " | TpsPriv: " + TotalRunningPrivateTPS().ToString("F2").PadLeft(6);
            return status;
        }

        public string GetStatusHtmlTable_Summary()
        {
            TimeSpan elapsed = ElapsedTime;
            string shortElapsed=elapsed.Days+"."+elapsed.Hours+":"+elapsed.Minutes+":"+elapsed.Seconds;

            System.Text.StringBuilder sb = new System.Text.StringBuilder(1024);
            sb.Append("<p>Total Summary<br>\r\n");
            sb.Append("<table border=1 cellspacing=0 cellpadding=2>\r\n");
            sb.Append("<tr><td>Passed</td><td>"+TotalPassed+"</td></tr>\r\n");
            sb.Append("<tr><td>Failed</td><td>"+TotalFailed+"</td></tr>\r\n");
            sb.Append("<tr><td>Total transactions</td><td>"+Total+"</td></tr>\r\n");
            sb.Append("<tr><td>Time</td><td>"+shortElapsed+"</td></tr>\r\n");
            sb.Append("<tr><td>TPS</td><td>"+TotalRunningTPS().ToString("F2")+"</td></tr>\r\n");
            sb.Append("<tr><td>Pass rate</td><td>"+(TotalPassRate*100).ToString("F2")+"%</td></tr>\r\n");
            sb.Append("<tr><td>Private TPS</td><td>"+TotalRunningPrivateTPS().ToString("F2")+"</td></tr>\r\n");
            sb.Append("</table></p>\r\n");

            return sb.ToString();
        }

        public string GetStatusHtmlTable_Detail()
        {            
            double totalTargetTPS = 0;
            System.Text.StringBuilder sb = new System.Text.StringBuilder(1024);
            sb.Append("<p>Details<br>\r\n");
            sb.Append("<table border=1 cellspacing=0 cellpadding=2>\r\n");
            sb.Append("<tr><td>API name</td><td>Transactions</td><td>Pass rate</td><td>TPS</td><td>Target TPS</td><td>Private TPS</td></tr>\r\n");
            foreach (TestResult result in List)
            {
                totalTargetTPS += result.TargetTps;

                if (result.Total == 0)
                    continue; // If this API test has not been executed, I don't want it cluttering the result file

                sb.Append(result.GetStatusHtmlRow());
            }
            sb.Append("</table>\r\n");
            
            return sb.ToString();
        }
        
        public string GetStatusHtmlTable()
        {
            return GetStatusHtmlTable_Summary() + "\r\n" + GetStatusHtmlTable_Detail();
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\AsyncUtils.cs ===
using System;
using ServerTestFramework;

namespace ServerTestFramework.Utilities
{

namespace AsyncUtils
{
    // -- run a function many times in parallel (with an incrementing number supplied to each one)
    public delegate void PRFuncToCall(uint num, object obj);
    
    public class ParallelRunner
    {
        // -- main interface

        /// <summary>
        /// Starts a set of parallel function calls and waits for them to finish.
        /// Exceptions are rethrown on to caller if thrown on a thread.
        /// </summary>
        /// <param name="fToCall">the function to call</param>
        /// <param name="count">total number of calls to make (the value passed to your function is incremented each time starting from 0)</param>
        /// <param name="maxAtOnce">max number of threads to run at once</param>
        /// <param name="userData">any user-defined information to pass on (note that it is passed by referance, so all threads share the same copy)</param>
        /// <param name="threadDelay">Delay in ms between thread creations (default 0).  This is useful to prevent a ton of operations that start all at once from trying to hammer a network interface silmutaneously, which can cause packets to be dropped.</param>
        public static void Run(PRFuncToCall fToCall, uint count, uint maxAtOnce, object userData, uint threadDelay)
        {
            DoRun(fToCall, count, maxAtOnce, userData, null, threadDelay);
        }
        public static void Run(PRFuncToCall fToCall, uint count, uint maxAtOnce, object userData)
        {
            DoRun(fToCall, count, maxAtOnce, userData, null, 0);
        }

        /// <summary>
        /// Same as Run(), only returns immediately.  The returned Status object can be used to monitor the progress.
        /// If an exception occurs, it is stored in the status object.
        /// </summary>
        public static Status RunAsync(PRFuncToCall fToCall, uint count, uint maxAtOnce, object userData, uint threadDelay)
        {
            Status status=new Status(count);

            DoAsycnRun asr = new DoAsycnRun(fToCall, count, maxAtOnce, userData, status, threadDelay);
            System.Threading.Thread thread=ThreadMaker.CreateThread(asr.ThreadProc);
            thread.Start();
            return status;
        }
        public static Status RunAsync(PRFuncToCall fToCall, uint count, uint maxAtOnce, object userData)
        {
            return RunAsync(fToCall, count, maxAtOnce, userData, 0);
        }

        /// <summary>
        /// represents the status of an asynchronous run
        /// </summary>
        public class Status
        {
            //accessors
            public uint NumberFinished { get { return runsDone; } } //number of completed operations
            public uint NumberTotal { get { return runsTotal; } } //number of total operations to be done
            public bool WasError { get { return exc != null; } } //was there an error (exception) on one of the threads?
            public Exception GetError { get { return exc; } } //the exception that was thrown on a thread
            public bool IsStillRunning { get //returns true if test is still running, or if there was an error but not all threads have stopped yet
            {
                if (!WasError)
                {
                    return NumberFinished!=NumberTotal;
                }
                else
                {
                    for (uint i=0;i<threads.Length;++i)
                        if (threads[i]!=null && threads[i].IsAlive) return true;
                    return false;
                }
            }}


            //state
            internal volatile uint runsDone = 0,runsTotal = 0;
            internal volatile Exception exc = null;

            internal System.Threading.Thread []threads;

            //
            internal Status(uint total)
            {
                runsTotal = total;
            }
            internal void IncrementFinished()
            {
                lock (this)
                {
                    ++runsDone;
                }
            }
        };

        // -- internal stuff

        //perfroms the actual Run.
        private static void DoRun(PRFuncToCall fToCall, uint count, uint maxAtOnce, object sharedObj, Status status, uint threadDelay)
        {
            //...
            if (count==0 || maxAtOnce==0)
            {
                CoreGlobal.RO.Warn("ParallelRunner::DoRun - Invalid parameters provided.");
                return;
            }
            if (maxAtOnce>count) maxAtOnce=count;

            //CoreGlobal.RO.Info("ParallelRunner: Starting up to " + maxAtOnce + " threads at once to run " + count + " operations" + (status!=null?" asynchronously":"") + ", making at most 1 thread every " + threadDelay + "ms");

            //make them
            System.Threading.Thread []threads=new System.Threading.Thread[maxAtOnce];
            if (status!=null) status.threads=threads;
            ParallelRunner []pr=new ParallelRunner[maxAtOnce];

            System.Threading.AutoResetEvent are=new System.Threading.AutoResetEvent(true);

            //do them
            try
            {
                for (uint i=0; i<count; ++i)
                {
                    //find an empty thread slot
                    uint eslot=0;
                    bool foundFree=false;
                    do
                    {
                        for (uint n=0; n<maxAtOnce; ++n)
                        {
                            if (threads[n]==null)
                            {
                                eslot=n;
                                foundFree=true;
                                break;
                            }

                            if (!pr[n].isThreadAlive) //found a dead one
                            {
                                eslot=n;
                                foundFree=true;

                                if (CheckThreadException(threads,pr,status,n)) return;
                                break;
                            }
                        }
                        if (!foundFree) are.WaitOne();
                    } while (!foundFree);

                    //make another thread/runner
                    pr[eslot]=new ParallelRunner(fToCall,i,sharedObj,status,are);
                    threads[eslot]=ThreadMaker.CreateThread(pr[eslot].ThreadProc);
                    threads[eslot].Start();

                    if (threadDelay>0 && i<count-1)
                    {
                        System.Threading.Thread.Sleep((int)threadDelay);
                    }
                }

                //block until all are done
                uint numAlive;
                do
                {
                    numAlive=0;

                    for (uint i=0; i<maxAtOnce; ++i)
                    {
                        if (threads[i]!=null && pr[i].isThreadAlive) ++numAlive;

                        if (CheckThreadException(threads,pr,status,i)) return;
                    }

                    if (numAlive!=0) are.WaitOne();
                } while (numAlive!=0);
            }
            catch (System.Threading.ThreadAbortException) //if our thread is being prematurely aborted, abort all child threads too
            {
                for (uint i=0; i<maxAtOnce; ++i)
                {
                    if (threads[i]!=null)
                        threads[i].Abort();
                }

                //this type of exception is always rethrown automatically
            }

            //CoreGlobal.RO.Info("ParallelRunner: All operations done");
        }

        //checks for and deals with an exception report on a thread (will rethrow or return true to signal that the runner should end)
        private static bool CheckThreadException(System.Threading.Thread []threads, ParallelRunner []pr, Status status, uint indexToCheck)
        {
            if (pr[indexToCheck]!=null && pr[indexToCheck].wasException) //erp, was one
            {
                if (status!=null)
                    status.exc=pr[indexToCheck].exc;

                //wait on all threads to end
                //CoreGlobal.RO.Info("ParallelRunner: Waiting on all worker threads to end...");

                uint numAlive;
                do
                {
                    numAlive = 0;

                    for (uint i=0; i<threads.Length; ++i)
                    {
                        if (threads[i]!=null && threads[i].IsAlive) ++numAlive;
                    }
                    if (numAlive!=0) System.Threading.Thread.Sleep(10);
                } while (numAlive!=0);

                //throw or return that it should end
                //CoreGlobal.RO.Info("PalallelRunner: All worker threads stopped.");
                if (status!=null)
                    return true;
                else //note: stack trace will point to here rather than what the thread threw
                    throw new System.Exception("Worker thread threw an exception (see above for stack trace):\n" + pr[indexToCheck].exc.Message, pr[indexToCheck].exc);
            }
            else //all's well
                return false;
        }

        //(helper for RunAsync)
        private class DoAsycnRun
        {
            PRFuncToCall fToCallStored;
            uint countStored;
            uint maxAtOnceStored;
            object sharedObjStored;
            Status statusStored;
            uint threadDelay;

            public DoAsycnRun(PRFuncToCall fToCall, uint count, uint maxAtOnce, object sharedObj, Status status, uint threadDelayMS)
            {
                fToCallStored=fToCall;
                countStored=count;
                maxAtOnceStored=maxAtOnce;
                sharedObjStored=sharedObj;
                statusStored=status;
                threadDelay=threadDelayMS;
            }

            public void ThreadProc()
            {
                try
                {
                    //run the synchronous version
                    ParallelRunner.DoRun(fToCallStored, countStored, maxAtOnceStored, sharedObjStored, statusStored, threadDelay);
                }
                catch (System.Threading.ThreadAbortException)
                {
                    //this is normal in many cases... don't spew about it.  It will be rethrown automatically.
                }
                catch (Exception e)
                {
                    CoreGlobal.RO.Error("Caught Exception in ParallelRunner from a RunAsync call: " + e.Message);
                }
            }
        };

        //instance-specific data
        private PRFuncToCall funcToCall;
        private uint numToRun;
        private object sharedObj;

        private bool wasException;
        private Exception exc;

        Status overallStatus; //to tell it when one finishes

        System.Threading.AutoResetEvent are;
        public volatile bool isThreadAlive=true;

        //
        private ParallelRunner(PRFuncToCall ftc, uint num, object obj, Status stat, System.Threading.AutoResetEvent autoResetEvent)
        {
            funcToCall=ftc;
            numToRun=num;
            wasException=false;
            sharedObj=obj;
            overallStatus=stat;
            are=autoResetEvent;
        }

        //thread entry point
        private void ThreadProc()
        {
            try
            {
                funcToCall(numToRun, sharedObj);
                if (overallStatus!=null) overallStatus.IncrementFinished();
            }
            catch (System.Threading.ThreadAbortException)
            {
                //this is normal in many cases... don't spew about it.  It will be rethrown automatically.
            }
            catch (Exception e)
            {
                CoreGlobal.RO.Debug("Caught Exception in ParallelRunner callee(" + numToRun + "): " + e.Message+"\ncall stack of thread:\n"+e.StackTrace);
                exc=e;
                wasException=true;
            }
            finally
            {
                isThreadAlive=false;
                are.Set();
            }
        }
    };

} //namespace AsyncUtils

} //namespace ServerTestFramework.Utilities
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\DebugLogger.cs ===
using System;
using System.IO;

namespace ServerTestFramework.Utilities
{
	public class DebugLogger
	{
		static StreamWriter logSW = null;
		static object logLock = new object();
		public static void Log(string s)
		{
			lock (logLock)
			{
				if (logSW == null)
					logSW = new StreamWriter(File.Create(@"c:\stf-debug.txt"));
				logSW.WriteLine(s); 
				logSW.Flush();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\CommandLine.cs ===
using System;
using System.Text;
using System.Collections;

namespace ServerTestFramework.Runner
{
    public class CommandLine
    {
        public class Switch
        {
            public string Name;
            public string[] Params = null;

            public Switch(string name)
            {
                Name = name;
            }

            //deliminates a switch over ',' and returns each piece
            public string[] GetSubParams(uint paramNum)
            {
                if (Params==null || paramNum>Params.Length) return null;

                string param=Params[paramNum];

                //number of sub-params is 1+number of commas in string
                uint commaCount=0;
                foreach (char c in param)
                {
                    if (c==',') ++commaCount;
                }

                string []subParams=new string[commaCount+1];
                for (uint i=0;i<subParams.Length;++i)
                    subParams[i]="";

                //break out the chunks
                int chunkNum=0;
                string curChunk="";
                foreach (char c in param)
                {
                    if (c==',')
                    {
                        subParams[chunkNum++]=curChunk;
                        curChunk="";
                    }
                    else
                        curChunk+=c;
                }
                subParams[chunkNum]=curChunk;

                return subParams;
            }

            //deliminates a switch over ',' then deliminates that over '=' and returns both halves of the pair
            public System.Collections.Generic.KeyValuePair<string,string>[] GetSubParamPairs(uint paramNum)
            {
                //get subparams
                string []subParams=GetSubParams(paramNum);

                if (subParams==null || subParams.Length==0)
                {
                    return null;
                }

                //break those up
                System.Collections.Generic.KeyValuePair<string,string> []pairs=new System.Collections.Generic.KeyValuePair<string,string>[subParams.Length];
                for (uint i=0; i<subParams.Length; ++i)
                {
                    if (!subParams[i].Contains("=")) //non-pair
                    {
                        pairs[i]=new System.Collections.Generic.KeyValuePair<string,string>(subParams[i],null);
                    }
                    else //pair
                    {
                        //break into key and value
                        string spKey="",spValue="";
                        bool hitEq=false;
                        foreach (char c in subParams[i])
                        {
                            if (!hitEq)
                            {
                                if (c=='=')
                                    hitEq=true;
                                else
                                    spKey+=c;
                            }
                            else
                            {
                                spValue+=c;
                            }
                        }

                        //
                        pairs[i]=new System.Collections.Generic.KeyValuePair<string,string>(spKey,spValue);
                    }
                }

                //
                return pairs;
            }
        }

        public bool HasSwitch(string name)
        {
            return Switches[name] != null;
        }

        public Hashtable Switches = new Hashtable();
        public string[] Params = null;
    }

    public class CommandLineParser
    {
        public class SwitchType
        {
            public string Name;
            public int NumArgs;
            public string ParamDescription;
            public string Description;
            public bool UsageVisible = true;
            public bool Shortcut = false;

            public SwitchType(string name, int numArgs, string paramDescription, string description)
            {
                Name = name;
                NumArgs = numArgs;
                ParamDescription = paramDescription;
                Description = description;
            }
        }

        private Hashtable switchTypes = new Hashtable();
        public string Usage;
        public string Notes;


        public CommandLineParser(string usage, string notes)
        {
            Usage = usage;
            Notes = notes;
        }

        public void AddSwitch(string name, int numArgs, string paramDescription, string description)
        {
            switchTypes[name] = new SwitchType(name, numArgs, paramDescription, description);
        }

        public void AddSwitch(string name, string description)
        {
            AddSwitch(name, 0, null, description);
        }

        public void AddSwitch(string name, int numArgs, string paramDescription, string description, bool shortcut)
        {
            SwitchType st = new SwitchType(name, numArgs, paramDescription, description);
            st.Shortcut = true;
            switchTypes[name] = st;

            st = new SwitchType(name, numArgs, paramDescription, description);
            st.UsageVisible = false;
            switchTypes[name.Substring(0, 1)] = st;
        }

        public void AddSwitch(string name, string description, bool shortcut)
        {
            AddSwitch(name, 0, null, description, shortcut);
        }

        public void AddSwitch(SwitchType st)
        {
            switchTypes[st.Name] = st;
        }

        public CommandLine Parse(string[] commandLine)
        {
            SwitchType whichSwitch;
            CommandLine cl = new CommandLine();
            ArrayList paramList = new ArrayList();
            for (int i = 0; i < commandLine.Length; i++)
            {
                string argument = commandLine[i];

                if (argument.StartsWith("-") || argument.StartsWith("/"))
                {
                    string command;
                    int valueMarker = argument.IndexOf(":");

                    // switches with value markers are a special case, they may only
                    // have one parameter value
                    if(valueMarker > 0)
                    {
                        command = argument.Substring(1, valueMarker-1).ToLower();

                        if(valueMarker == argument.Length-1)
                        {
                            throw new Exception("0 length value passed after value marker for paramter '" + command + "'");
                        }

                        whichSwitch = (SwitchType)switchTypes[command];
                        if(null == whichSwitch)
                        {
                            throw new Exception("Switch '/" + command + "' unknown.");
                        }

                        // Create the single value parameter
                        string commandValue = argument.Substring(valueMarker + 1);

                        if (cl.Switches.ContainsKey(whichSwitch.Name))
                        {
                            CommandLine.Switch s = (CommandLine.Switch)cl.Switches[whichSwitch.Name];

                            // very inefficient, but minimally impacting codewise
                            string[] newParams = new string[s.Params.Length + 1];
                            Array.Copy(s.Params, newParams, s.Params.Length);
                            newParams[s.Params.Length] = commandValue;

                            s.Params = newParams;
                        }
                        else
                        {
                            CommandLine.Switch s = new CommandLine.Switch(whichSwitch.Name);

                            s.Params = new string[1] { commandValue };
                            cl.Switches[s.Name] = s;
                        }

                        continue;
                    }
                    else
                    {
                        command = argument.Substring(1).ToLower();
                    }


                    whichSwitch = (SwitchType)switchTypes[command];
                    if (whichSwitch == null)
                    {
                        throw new Exception("Switch '/" + command + "' unknown.");
                    }
                    else
                    {
                        CommandLine.Switch s = new CommandLine.Switch(whichSwitch.Name);

                        if (whichSwitch.NumArgs > 0)
                        {
                            ArrayList switchParamList = new ArrayList();
                            for (int j = 0; j < whichSwitch.NumArgs; j++)
                                switchParamList.Add(commandLine[++i].ToLower());
                            s.Params = (string[])switchParamList.ToArray(typeof(string));
                        }

                        cl.Switches[s.Name] = s;
                    }
                }
                else
                {
                    paramList.Add(argument.ToLower());
                }
            }

            cl.Params = (string[])paramList.ToArray(typeof(string));
            return cl;
        }

        public string GetUsageMessage()
        {
            StringBuilder buffer = new StringBuilder(256);

            buffer.Append("Usage:\n");
            buffer.Append("  " + Usage + "\n");
            buffer.Append("  Options include:\n");

            foreach (SwitchType st in switchTypes.Values)
            {
                if (!st.UsageVisible)
                {
                    continue;
                }

                string name = st.Shortcut ? "(" + st.Name.Substring(0, 1) + ")" + st.Name.Substring(1) : st.Name;

                if (st.ParamDescription == null)
                {
                    buffer.Append("    -" + name.PadRight(16, ' ') + (st.Description == null ? "" : st.Description));
                    buffer.Append("\n");
                }
                else
                {
                    buffer.Append("    -" + name + " " + st.ParamDescription + "\n");
                    if (st.Description != null)
                    {
                        buffer.Append("                    " + st.Description + "\n");
                    }
                }
            }

            buffer.Append("\n" + "   " + Notes); 

            return buffer.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\ConsoleReportDestination.cs ===
using System;

namespace ServerTestFramework.Utilities
{
    public class ConsoleReportDestination : Report.Destination
    {
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            string logLine=Report.FormatLogLine(date, level,path,message) + "\n";

            switch(level)
            {
                case Report.DEBUG:
                    ConsoleX.Write(CC.GRAY, logLine);
                    break;
                case Report.INFO:
                    ConsoleX.Write(CC.WHITE, logLine);
                    break;
                case Report.WARN:
                    ConsoleX.Error(CC.YELLOW, logLine);
                    break;
                case Report.ERROR:
                    ConsoleX.Error(CC.RED, logLine);
                    break;
                case Report.FATAL:
                    ConsoleX.Error(CC.PINK, logLine);
                    break;
                case Report.SUCCESS:
                    ConsoleX.Write(CC.GREEN, logLine);
                    break;
                default:
                    ConsoleX.Write(CC.PINK, logLine);
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\DataProvider.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
//using System.Runtime.Serialization;

namespace ServerTestFramework.Utilities
{
    public abstract class DataProvider
    {
        private Dictionary<string, string> m_dictValues = new Dictionary<string, string>();
        private Dictionary<string, WeightedValues> m_dictWeightedValues = new Dictionary<string, WeightedValues>();

        protected DataProvider(string xmlFileName)
        {
            // Open XML file
            XmlDocument doc = new XmlDocument();
            doc.Load(xmlFileName);

            // Insert each key/value pair into dictionary
            XmlNode root = doc.DocumentElement;

            foreach (XmlNode node in root.ChildNodes)
            {
                if (node.Name == "KVPair")
                {
                    string key = GetAttrValue(node, "key");
                    System.Diagnostics.Debug.WriteLine("key == " + key);
                    //string value = GetAttrValue(node, "value");
                    string value = node.InnerXml;
                    System.Diagnostics.Debug.WriteLine("value == " + value);
                    m_dictValues.Add(key, value);
                }

                if (node.Name == "WeightedValues")
                {
                    WeightedValues wvalues = WeightedValues.LoadFromXml(node);
                    System.Diagnostics.Debug.WriteLine("wvalues.key == " + wvalues.key);
                    m_dictWeightedValues.Add(wvalues.key, wvalues);
                }
            }
        }

        private string GetAttrValue(XmlNode node, string name)
        {
            XmlNode attr = node.Attributes.GetNamedItem(name);
            if (attr == null || attr.Value == null)
            {
                throw new Exception("DataProvider::GetAttrValue: attribute value may not be null");
            }
            return attr.Value;
        }

        protected string GetSingleValue(string key)
        {
            return m_dictValues[key];
        }

        protected object GetWeightedValue(string key)
        {
            return m_dictWeightedValues[key].GetWeightedValue();
        }

        // XML Serializing a Hashtable or generic Dictionary (from petes, CLR dev)
        public static void Serialize(TextWriter writer, IDictionary dictionary)
        {
            List<Entry> entries = new List<Entry>(dictionary.Count);
            foreach (object key in dictionary.Keys)
            {
                entries.Add(new Entry(key, dictionary[key]));
            }

            XmlSerializer serializer = new XmlSerializer(typeof(List<Entry>));
            serializer.Serialize(writer, entries);
        }

        public static void Deserialize(TextReader reader, IDictionary dictionary)
        {
            dictionary.Clear();
            XmlSerializer serializer = new XmlSerializer(typeof(List<Entry>));
            List<Entry> list = (List<Entry>)serializer.Deserialize(reader);

            foreach (Entry entry in list)
            {
                dictionary[entry.Key] = entry.Value;
            }
        }

        public class Entry
        {
            public object Key;
            public object Value;

            public Entry()
            {
            }

            public Entry(object key, object value)
            {
                Key = key;
                Value = value;
            }
        }
    }

    [XmlRoot("WeightedValues")]
    public class WeightedValues
    {
        public struct WeightedValue
        {
            public object Value;
            public float Weight;

            public WeightedValue(object value, float weight)
            {
                Value = value;
                Weight = weight;
            }
        }

        [XmlElement("key")]
        public string key = null;
        [XmlElement("WeightedValue")]
        public List<WeightedValue> dictWeightedValues = new List<WeightedValue>();
        [XmlElement("totalWeight")]
        public float totalWeight = 0;

        public WeightedValues()
        {
        }

        public WeightedValues(string key)
        {
            this.key = key;
        }

        static public WeightedValues LoadFromXml(XmlNode xmlNode)
        {
            StringReader reader = new StringReader(xmlNode.OuterXml);
            
            // Read it back out as Xml
            System.Xml.Serialization.XmlSerializer ser = new XmlSerializer(typeof(WeightedValues));
            return (WeightedValues)ser.Deserialize(reader);
        }

        public string ToXml()
        {
            // Write the Xml out to a memory stream
            System.Xml.Serialization.XmlSerializer ser = new XmlSerializer(typeof(WeightedValues));
            StringWriter writer = new StringWriter();

            // Remove empty xsd/xsi attribs from output
            XmlSerializerNamespaces xsn = new XmlSerializerNamespaces();
            xsn.Add(String.Empty, String.Empty);

            ser.Serialize(writer, this, xsn);

            return writer.ToString();
        }

        public void AddWeightedValue(object value, float weight)
        {
            dictWeightedValues.Add(new WeightedValue(value, weight));
            totalWeight += weight;
        }

        public object GetWeightedValue()
        {
            double randomValue = ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextDouble();
            float targetWeight = (float)(randomValue * totalWeight);
            float currentWeight = 0;

            foreach (WeightedValue weightedValue in dictWeightedValues)
            {
                currentWeight += weightedValue.Weight;
                if (currentWeight >= targetWeight)
                {
                    return weightedValue.Value;
                }
            }
            throw new Exception("Unexpected code point reach: currentWeight = " + currentWeight + "; targetWeight = " + targetWeight);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\Counters.cs ===
using System;
using System.Diagnostics;
using System.Collections;

namespace ServerTestFramework
{
    public class Counters
    {
        // Initialize
        static public void CreateCategory(string _categoryName, string[] counterNames)
        {
            Hashtable _counters     = null;
            
            if(_category.Contains(_categoryName))
            {
                _category.Remove(_categoryName);
            }

            _counters     = new Hashtable(counterNames.Length);
            _category.Add(_categoryName,_counters);
            
            

            // Delete previously created category
            Cleanup(_categoryName);
            
            // Create counter description datastructure
            CounterCreationDataCollection counterCollection = new CounterCreationDataCollection();
            for(int i=0; i < counterNames.Length; i++)
            {
                counterCollection.Add(new CounterCreationData(counterNames[i], counterNames[i], PerformanceCounterType.RateOfCountsPerSecond32));
            }

            // Create category
            PerformanceCounterCategory.Create(_categoryName, _categoryName, PerformanceCounterCategoryType.SingleInstance, counterCollection);

            // Now create the counters and store them in a hashtable for access by counter name
            for(int i=0; i < counterNames.Length; i++)
            {
                PerformanceCounter counter = new PerformanceCounter(_categoryName, counterNames[i], false);
                
                _counters.Add(counterNames[i].ToLower(), counter);
            }
        }

        static public void Increment(string categoryName,string counterName)
        {
            Hashtable _counters     = null;
            if(_category.Contains(categoryName))
            {
                _counters =(Hashtable)_category[categoryName];
            
                if (_counters.Contains(counterName.ToLower()))
                {
                    PerformanceCounter counter = (PerformanceCounter) _counters[counterName.ToLower()];
                    counter.Increment();
                }
                // OK if counter doesn't exist, we'll silently ignore it
            }
            // OK if category doesn't exist, silently ignore
            //else
            //    throw new System.Exception("Invalid category "+categoryName);

        }

        static public void Cleanup(string _categoryName)
        {
            if(PerformanceCounterCategory.Exists(_categoryName))
            {
                PerformanceCounterCategory.Delete(_categoryName);
            }
        }


       // static protected string    _categoryName = null; 
        static protected Hashtable  _category = Hashtable.Synchronized(new Hashtable());
       // static protected Hashtable _counters     = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\BaseApp.cs ===
using System;
using System.Xml;
using System.IO;
using System.Text;
using System.Collections;
using ServerTestFramework;

namespace ServerTestFramework.Runner
{
    public abstract class BaseApp
    {
        protected CommandLineParser _CommandLineParser;
        protected CommandLine       _CommandLine;

        protected bool              _RunCrashed = false;
        public    bool              RunCrashed
        {
            get {return _RunCrashed;}
        }

        protected BaseApp()
        { 
            _CommandLineParser = new CommandLineParser("BaseApp", "");
        }

        protected abstract void ShowError(string title, string message);
        protected abstract void ShowMessage(string title, string message);
        protected abstract void ConfigureCommandLine();
        protected abstract void BeginApplication(StfXmlDoc config);

        protected void Run(string []args)
        {
            // Allow subclass to configure usage
            ConfigureCommandLine();

            // Parse out all of the specified arguments
			try
			{
				_CommandLine = _CommandLineParser.Parse(args);
			}
			catch (Exception e)
			{
                _RunCrashed = true;

                if (e.Message != null && e.Message != "")
                {
                    ShowError("Command line argument error", e.Message);
                }

                ShowMessage("Usage", _CommandLineParser.GetUsageMessage());

                // Skip config loading and application start
                goto lbDone;
			}

            // Load and merge all config files and call into specific implementation to begin
            // the actual application
            StfXmlDoc config = LoadXmlConfigFromCommandLine(); 

            try
            {
                BeginApplication(config);
            }
            catch(Exception ex)
            {
                _RunCrashed = true;
                ShowError("Application Error", ex.ToString());
            }

lbDone:
            return;
        }
      
        private StfXmlDoc LoadXmlConfigFromCommandLine()
        {
            StfXmlDoc config = new StfXmlDoc();
            string []files = GetFilesFromCommandLine("xml");
            
            // First try to load the default XML file
            try 
            {
                config.Load(CoreGlobal.DefaultConfigFile);
            }
            catch(Exception)
            {
                // TODO: this may not require any type of warning
                // if STF is robust enough to function without
                // a defauilt config, often this is not the case 
                // Console.WriteLine("Couldn't load default stf XML configuration: " + Global.DefaultConfigFile + ", Reason: " + ex.Message);
            }

            foreach (string file in files)
            {
                if (file.EndsWith(".xml"))
                {
                    try
                    {
                        config.Merge(new StfXmlDoc(file), "/stf");
                    }
                    catch (XmlException ex)
                    {
                        ShowError("Could not load XML document", "File: " + file + "\nReason: " + ex.Message);
                    }
                }
            }

            return config;
        }

        protected string[] GetFilesFromCommandLine(string extension)
        {
            extension = extension.ToUpper();
            ArrayList files = new ArrayList();

            foreach (string arg in _CommandLine.Params)
            {
                string pathName = Path.GetDirectoryName(arg);
                if (pathName == "")
                {
                    pathName = ".";
                }

                string fileName = Path.GetFileName(arg);
                foreach (string file in Directory.GetFiles(pathName, fileName))
                {
                    if(file.ToUpper().EndsWith(extension))
                    {
                        files.Add(file);
                    }
                }
            }

            return (string[])files.ToArray(typeof(string));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\ConsoleX.cs ===
//////////////////////////////////////////////////////////
// 
// Copyright  Microsoft Corporation.  All rights reserved
// MSN Search
//
//  File:   ConsoleX.cs
//
//  Summary:  ConsoleX class - extends standard Console  with CRT kbhit() and getch() methods 
//            and provides colored console output.
//
//  Author: V.Pinich (VladiP)
//  10/23/2001
//	
//  11/02/2001  Special thanks to Keith Stutler and Yann Christensen for useful advices
//	06/??/2002	Removed warnings (aaronlie)
//	02/21/2003	Added SetConsoleScreenBufferSize (reljam)
//
//////////////////////////////////////////////////////////

/* usage example

namespace ConsoleXtest
{  
  	using System;
	

	class App
	{
		static void Main()
		{
			int   i = 1234;
			float f = 23.263f;
			char  c = ' ';

			ConsoleX.WriteLine(CC.YELLOW, " ConsoleX output examples\n");

			ConsoleX.WriteLine(" Simple output without {} brackets:   int: ", i, "  float: ", f);
			ConsoleX.WriteLine(CC.BLUE, " Simple colored output: ", CC.GREEN, " int: ",i, "  float: ", f);

			ConsoleX.Write(CC.WHITE, "\n Formatted output: ", CC.GREEN, "f= ", f.ToString("000.0"));
			ConsoleX.Write("   Inversed default color: ", CC.INV, "i= ", i, " 0x", i.ToString("x") );

			ConsoleX.Write( CC.WHITE, "\n\n Default ", CC.GREEN, "background ", CC.RED, "output \n"); 
			ConsoleX.Write( CC.ABS, CC.B_WHITE, CC.BGND, " White   ", CC.RED, "background ", CC.BLUE, "output \n"); 
			ConsoleX.Write( CC.ABS, (byte)(CC.B_GRAY | CC.WHITE), "       white on gray       \n"); 
			ConsoleX.Write( CC.ABS, (byte)(CC.B_GREEN | CC.GREEN),"       green bar           \n\n"); 
		
			byte OldColor = ConsoleX.Write("Set global color:\n", CC.ABS, (byte)(CC.B_BLUE|CC.GRAY), CC.GLOBAL, " Same call\n");
			ConsoleX.Write(" New call \n");
			ConsoleX.Write(CC.WHITE," Restoring old console color: ", CC.ABS, OldColor, CC.GLOBAL, " here it is !!\n");

			ConsoleX.WriteLine(CC.YELLOW, "\n kbhit() + getch() example, hit any key to loop, hit Esc to exit\n" );
		
			while (c != 27)
			{
				if (ConsoleX.kbhit())
				{
					c = ConsoleX.getch();
					ConsoleX.WriteLine(CC.GREEN,"Key: ", c, "  code: ", CC.WHITE, ((int)c).ToString("d") );
				}

				System.Threading.Thread.Sleep(200);
			}
		}
	}
}
*/ 

using System;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.InteropServices;  // Must have to gain access to Win32 API attributes.

namespace ServerTestFramework.Utilities
{
	/// <summary>
	/// <p>class ConsoleX: Extends standard Console  with kbhit() and getch() methods and colored output.</p>
	/// 
	/// <p>uses MSVCR70.DLL Runtime library for kbhit() and getch()</p>
	/// <p>uses kernel32.dll and Win32 Console API for colored output</p>
	///  
	/// contacts: VladiP
	/// </summary>
	/// <example>
	/// <code>
	/// // write colored output for arg list without brackets {},  see comments in CC class  for color output details
	/// ConsoleX.WriteLine(CC.BLUE, " Simple colored output: ", CC.GREEN, " int: ",i, "  float: ", f);
	/// ConsoleX.Write(CC.WHITE, "\n Formatted output: ", CC.GREEN, "f= ", f.ToString("000.0")); 
	/// 
	/// // kbhit example
	/// while (27 != c)
	/// {
	///		if (ConsoleX.kbhit())
	///		{
	///			c = ConsoleX.getch();
	///			ConsoleX.WriteLine(CC.GREEN,"Key: ", c, "  code: ", CC.WHITE, ((int)c).ToString("d") );
	///		}
	///	}
	/// </code>
	/// </example>
	/// 
	public class ConsoleX
	{
		const short STD_INPUT_HANDLE  = -10;
		const short STD_OUTPUT_HANDLE = -11;
		const short STD_ERROR_HANDLE  = -12;

		[DllImport("kernel32")]
		static extern int GetStdHandle(int hStdHandle);

		[DllImport("kernel32")]
		static extern int SetConsoleTextAttribute( int hConsole, ushort Attribute); 

		[DllImport("kernel32")]
		static extern int GetConsoleScreenBufferInfo( int hConsole, ref CONSOLE_SCREEN_BUFFER_INFO cbInfo ); 

		[DllImport("kernel32", CharSet=CharSet.Unicode, EntryPoint = "WriteConsoleW")]
		static extern int WriteConsole( int hConsole,
			String  pText,	int nTextLength, int nWritten, int nReserved);

		private static StreamWriter sw = null;
		public static void SetFile(string filename)
		{
			if (sw != null)
			{
				sw.Flush();
				sw.Close();
			}

			if (filename == null)
			{
				sw = null;
				return;
			}

			Match m = new Regex(@"^(.+)\\(.+)$").Match(filename);
			string pathName = ".";
			if (m.Success)
				pathName = m.Groups[1].Value;

			Directory.CreateDirectory(pathName);
			sw = File.CreateText(filename);
		}

		public static void SetConsoleTitle(string title)
		{
            Console.Title = title;
		}

		public static void PressAnyKey()
		{
			Console.Write("Press any key to continue...\r");
            Console.ReadKey(true);
			ClearLine();
		}

		public static void WriteSeparatorLine()
		{
            Console.WriteLine(new String('-', Console.BufferWidth - 1));
		}

		public static void WriteSeparatorLine(string title)
		{
			Console.Write(title+" ");
			Console.WriteLine(new String('=',Console.BufferWidth-title.Length-2));
		}
		
		public static void ClearLine()
		{
            int bw = 0;
            try
            {
                bw = Console.BufferWidth;
            }
            catch
            {
                // Just ignore the error and set it to zero, 
                // This just means we can't access the console (i.e. outputting to file)
                bw = 0;
            }

			if (bw == 0)
			{
				// This is debug output and we have to do the best we can...
				Console.Write("\n");
			}
			else
			{
				Console.Write("\r");
				Console.Write(new string(' ', bw-1));
				Console.Write("\r");
			}
		}

		public static void	SleepWithUserFeedback(int msecs) { SleepWithUserFeedback( msecs, "Waiting" ); }
		public static void	SleepWithUserFeedback(int msecs, string msg ) 
		{
			int updateTime=268;
			int totalWaitedTime=0;

			for (totalWaitedTime=0; totalWaitedTime<msecs; totalWaitedTime+=updateTime)
			{
				int percent=totalWaitedTime*100/msecs;
				WriteGuage(msg, percent);
				int timeToWait=Math.Min(msecs - updateTime, updateTime);
				System.Threading.Thread.Sleep(timeToWait);
			}

			ConsoleX.WriteLine();
		}
		
		public static void WriteGuage(string msg, int percent)
		{
			ClearLine();
			msg += " {0}% [";

			int blocks=9,i;
			for (i=0; i<(percent+blocks/2)/blocks; i++)
			{
				msg += "#";
			}
			for (; i<100/blocks; i++)
			{
				msg += ".";
			}
			msg += "]";
			Console.Write(msg,percent);
		}

		/// <summary>
		/// writes arg list to console, parameters with byte type will set color options for the next output items
		/// see comments in CC class  for color output details
		/// </summary>
		/// <param name="olist"> parameter list with optional byte type color modifiers </param>
		/// <returns> byte value - old default console color </returns>
		public static byte Write( params object[] olist )
        {
            return WriteHandle(STD_OUTPUT_HANDLE, olist);
        }

        public static byte Error( params object[] olist )
        {
            return WriteHandle(STD_ERROR_HANDLE, olist);
        }

        private static byte WriteHandle(short handle, object[] olist)
		{
			lock(typeof(ConsoleX))
			{
				CONSOLE_SCREEN_BUFFER_INFO cbInfo = new CONSOLE_SCREEN_BUFFER_INFO();		// Console information 
				int  hConsoleOut = GetStdHandle( handle );					    // Handle to the console 

				GetConsoleScreenBufferInfo( hConsoleOut,  ref cbInfo );

				byte colorDEF  =  (byte) cbInfo.wAttributes; 
				byte colorLAST =  colorDEF;
				byte colorMODE =  CC.DEF;								// default color mode - related to default color
				bool SetGlobal =  false;								// indicates color restoring on return 

				foreach(object o in olist)
				{
					if (o is Byte)		// use byte value for color change -- was: if(o.GetType().Equals(typeof(System.Byte)))
					{
						byte colorNEW = (byte) o;			
						if( CC.ABS == colorNEW )			// use absolute color
						{
							colorMODE = CC.ABS;
							continue;
						}
						else if ( CC.BGND == colorNEW )		// use previous background
						{
							colorMODE = CC.BGND;
							continue;
						}
						else if ( CC.GLOBAL == colorNEW )	// use current color as global 
						{
							SetGlobal = true;
							continue;
						}
						else if ( CC.DEF == colorNEW )		// use default console color
						{
							colorMODE = CC.DEF;
							colorNEW  = colorDEF;
						}
						else if ( CC.INV == colorNEW )
						{
							if (CC.DEF == colorMODE)
								colorNEW  = (byte) (colorDEF ^ 0xFF);    // for default we invert default color
							else
								colorNEW  = (byte) (colorLAST ^ 0xFF);   // for absolute we invert last color
						}
						else if ( CC.DEF == colorMODE )
						{
							colorNEW  = (byte) ( (colorDEF & 0xF0) | (colorNEW & 0x0F) );
						}
						else if ( CC.BGND == colorMODE )
							colorNEW  = (byte) ( (colorLAST & 0xF0) | (colorNEW & 0x0F) );

						colorLAST =  colorNEW;
						SetConsoleTextAttribute(hConsoleOut, colorNEW );
					}
					else
					{
                        if (handle==STD_ERROR_HANDLE)
                            Console.Error.Write("{0}", o);
                        else
						    Console.Write("{0}", o);

						if (sw != null)
							sw.Write("{0}", o);
					}
				}

				if (!SetGlobal)
					SetConsoleTextAttribute(hConsoleOut, cbInfo.wAttributes);		// restore old color

				return (byte)cbInfo.wAttributes;									// return old default color
			}
		}


		/// <summary>
		/// WriteLine: works as Write with new line at the end of parameter list
		/// </summary>
		/// <param name="olist"></param>
		/// <returns> byte value - old default console color </returns>
		public static byte WriteLine( params object[] olist )
		{
			byte ret;
			lock( typeof(ConsoleX) )	
			{
				ret = Write( olist );
				Console.Write("\n");
				if (sw != null)
					sw.WriteLine();
			}
			return ret;
		}

        public static byte ErrorLine( params object[] olist )
		{
			byte ret;
			lock( typeof(ConsoleX) )	
			{
				ret = Error( olist );
				Console.Error.Write("\n");
				if (sw != null)
					sw.WriteLine();
			}
			return ret;
		}

	}


	/// <summary>
	/// class CC - contains color constants to be used with ConsoleX output methods.
	/// Thanks to Keith Stutler (KeithSt) -- he suggested to put all constants into public class
	/// </summary>
	public class CC
	{
		public const byte DEF    = 0;				// use default console foreground and background colors for output
		public const byte ABS    = 0x8;				// use absolute coloring - not related to curent or default background
		public const byte INV    = 0x80;			// use inverted console color for output
		public const byte BGND   = 0x88;			// use current background for next output
		public const byte GLOBAL = 0xff;			// use current color or last color for this call as global console color

		public const byte F_BLUE      = 0x1;		//  text color contains blue.
		public const byte F_GREEN     = 0x2;		//  text color contains green.
		public const byte F_RED       = 0x4;		//  text color contains red.
		public const byte F_INTENSITY = 0x8;		//  text color is intensified.
		public const byte B_BLUE      = 0x10;		//  background color contains blue.
		public const byte B_GREEN     = 0x20;		//  background color contains green.
		public const byte B_RED       = 0x40;		//  background color contains red.
		public const byte B_INTENSITY = 0x80;		//  background color is intensified.
		public const byte B_GRAY      = 0x70;		//  background gray color.
		public const byte B_WHITE     = 0xF0;		//  background white color.

		public const byte BLUE    = F_INTENSITY | F_BLUE;				// 0x9
		public const byte GREEN   = F_INTENSITY | F_GREEN;				// 0xA
		public const byte RED     = F_INTENSITY | F_RED;				// 0xC

		public const byte YELLOW  = F_INTENSITY | F_RED   | F_GREEN;	
		public const byte PINK    = F_INTENSITY | F_RED   | F_BLUE;	
		public const byte AQUA    = F_INTENSITY | F_GREEN | F_BLUE;	
		public const byte GRAY    = 0x7;
		public const byte WHITE   = 0xF;

		public const byte DARK_BLUE    = F_BLUE;		// 0x1
		public const byte DARK_GREEN   = F_GREEN;		// 0x2
		public const byte DARK_RED     = F_RED;			// 0x4

		public const byte INFO    = GREEN;				// console color for info msgs
		public const byte ERROR   = RED;				// console color for error msgs
		public const byte WARNING = YELLOW;				// console color for warning msgs

		private CC() {}		// to prevent from instantiate the class
	}

	/// <summary>
	/// Win32 API struct
	/// </summary>

	struct COORD 
	{ 
		public short X; 
		public short Y; 

		public COORD(short _X, short _Y)
		{
			X = _X;
			Y = _Y;
		}
	}

	/// <summary>
	/// Win32 API struct
	/// </summary>
	struct SMALL_RECT 
	{
		public short Left; 
		public short Top; 
		public short Right; 
		public short Bottom; 

		public SMALL_RECT(short _Left, short _Top, short _Right, short _Bottom)
		{
			Left = _Left;
			Top = _Top;
			Right = _Right;
			Bottom = _Bottom;
		}

	} 

	/// <summary>
	/// Win32 API struct
	/// </summary>
	struct CONSOLE_SCREEN_BUFFER_INFO 
	{ 
		public COORD      dwSize; 
		public COORD      dwCursorPosition; 
		public ushort     wAttributes; 
		public SMALL_RECT srWindow; 
		public COORD      dwMaximumWindowSize; 
	} 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\ByteEncoding.cs ===
using System.Collections.Generic;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Encoding to just get the gosh dern bytes out of the string, and visa versa
    /// </summary>
    public class ByteEncoding : System.Text.Encoding
    {
        private static ByteEncoding _instance = null;

        public static ByteEncoding Instance
        {
            get
            {
                if (_instance != null)
                {
                    return _instance;
                }

                lock (typeof(ByteEncoding))
                {
                    if (_instance == null)
                    {
                        _instance = new ByteEncoding();
                    }
                }

                return _instance;
            }
        }

        public override string EncodingName { get { return "ByteEncoding"; } }

        #region GetBytes

        public override byte[] GetBytes (string s)
        {
            byte[] b = new byte[s.Length];
            GetBytes(s, 0, s.Length, b, 0);
            return b;
        }

        public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex)
        {
            for (int i = 0; i < charCount; ++i)
                bytes[byteIndex + i] = (byte) s[charIndex + i];
            return charCount;
        }

        public override byte[] GetBytes (char[] chars)
        {
            byte[] b = new byte[chars.Length];
            GetBytes(chars, 0, chars.Length, b, 0);
            return b;
        }

        public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
        {
            for (int i = 0; i < charCount; ++i)
                bytes[byteIndex + i] = (byte) chars[charIndex + i];
            return charCount;
        }

        #endregion

        #region GetString

        public override string GetString (byte[] bytes)
        {
            return GetString(bytes, 0, bytes.Length);
        }

        public override string GetString (byte[] bytes, int start, int length)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder(length);
            for (int i = 0; i < length; ++i)
                sb.Append((char) bytes[start + i]);
            return sb.ToString();
        }

        public string GetNullTerminatedString (byte[] bytes, int start, int length)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder(length);
            for (int i = 0; i < length; ++i)
            {
                byte b=bytes[start+i];
                if (b==0)
                    break;
                sb.Append((char)b);
            }
            return sb.ToString();
        }

        #endregion

        #region GetByteCount

        public override int GetByteCount (char[] chars, int index, int count)
        {
            return count;
        }

        public override int GetByteCount (string s)
        {
            return s.Length;
        }

        #endregion

        public override int GetCharCount (byte[] bytes, int index, int count)
        {
            throw new System.Exception("The method or operation is not implemented.");
        }

        public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
        {
            throw new System.Exception("The method or operation is not implemented.");
        }

        public override int GetMaxByteCount (int charCount)
        {
            throw new System.Exception("The method or operation is not implemented.");
        }

        public override int GetMaxCharCount (int byteCount)
        {
            throw new System.Exception("The method or operation is not implemented.");
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\DebugOutputReportDestination.cs ===
using System;
using System.Diagnostics;

namespace ServerTestFramework.Utilities
{
    public class DebugOutputReportDestination : InfiniteLifetimeMarshalByRefObject, Report.Destination
    {
        // Implemented from Report.Destination
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            string strLogLine = String.Format("[{0}] [{1}]: {2}",
                    date.ToString(),
                    path,
                    message);
            Debug.WriteLine(strLogLine);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\Hexer.cs ===
using System;
using System.Text;
using System.Text.RegularExpressions;

namespace ServerTestFramework.Utilities
{
    public class Hexer
    {
        public static byte[] unhex(string s)
        {
            if (s == null || s == "")
                return null;

            if (s.StartsWith("0x"))
                s = s.Substring(2);

            if (s.Length % 2 == 1)
                s = "0" + s;

            byte[] hex = new byte[s.Length / 2];
            for (int i = 0; i < s.Length / 2; i++)
            {
                hex[i] = (byte)((unhex(s[i*2]) << 4) + unhex(s[i*2+1]));
            }

            return hex;
        }

        public static byte unhex(char c)
        {
            if (c >= '0' && c <= '9')
                return (byte)(c - '0');
            else if (c >= 'a' && c <= 'z')
                return (byte)(c - 'a' + 10);
            else if (c >= 'A' && c <= 'Z')
                return (byte)(c - 'A' + 10);
            return 0;
        }

        public static ulong fromhex(string s)
        {
            //make it a byte array
            byte[] unhexed=unhex(s);
            if (unhexed==null)
                return 0;
            if (unhexed.Length>8)
                throw new System.Exception("String being unhexed is too long to fit in a ulong");

            //convert that array to a ulong
            ulong val=0;
            foreach (byte b in unhexed)
            {
                val<<=8;
                val|=b;
            }
            return val;
        }

        public static string tohex(byte[] bytes)
        {
            return tohex( bytes, false );
        }
        public static string tohex(byte[] bytes, bool reverse )
        {
            return tohex( bytes, 0, bytes.Length, reverse );
        }
        public static string tohex(byte[] bytes, int offset, int length)
        {
            return tohex( bytes, offset, length, false);
        }
        public static string tohex(byte[] bytes, int offset, int length, bool reverse)
        {
            if (bytes == null || bytes.Length == 0 || length<=0)
                return null;

            StringBuilder sb = new StringBuilder(length * 2);
            if( reverse )
            {
                for (int i = length - 1; i >= 0; --i)
                    sb.Append(tohex(bytes[offset+i]));
            }
            else
            {
                for (int i = 0; i < length; ++i)
                    sb.Append(tohex(bytes[offset+i]));
            }
            return sb.ToString();
        }

        public static string tohex(byte b)
        {
            byte b1 = (byte)(b >> 4);
            byte b2 = (byte)(b & 0xF);
            char c1 = (char)(b1 < 10 ? '0' + b1 : 'A' + b1 - 10);
            char c2 = (char)(b2 < 10 ? '0' + b2 : 'A' + b2 - 10);
            return "" + c1 + c2;
        }

        public static string tohex(uint b)
        {
            return tohex((byte)((b & 0xFF000000) >> 24)) + tohex((byte)((b & 0xFF0000) >> 16)) + tohex((byte)((b & 0xFF00) >> 8)) + tohex((byte)(b & 0xFF));
        }

        public static string tohex(ulong ul)
        {
            return tohex((uint)((ul & 0xFFFFFFFF00000000) >> 32)) + tohex((uint)(ul & 0xFFFFFFFF));
        }

        public static string IPHex(string ip)
        {
            Match match = new Regex(@"^(\d+)\.(\d+)\.(\d+)\.(\d+)$").Match(ip);

            if (match.Success)
            {
                uint addr = 0;
                addr |= Convert.ToUInt32(match.Groups[4].Value) << 24;
                addr |= Convert.ToUInt32(match.Groups[3].Value) << 16;
                addr |= Convert.ToUInt32(match.Groups[2].Value) << 8;
                addr |= Convert.ToUInt32(match.Groups[1].Value);
                return tohex(addr);
            }
            else
            {
                return null;
            }
        }

        public static string format(ulong ul)
        {
            return "0x" + ul.ToString("x");
        }

        public static string format(ulong []ula)
        {
            System.Text.StringBuilder str = new System.Text.StringBuilder(64);
            bool next = false;
            foreach(ulong ul in ula) 
            {
                if(next)
                    str.Append(", ");
                else
                    next = true;
                str.Append(format(ul));
            }

            return str.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\InfiniteLifetimeMarshalByRefObject.cs ===
using System;
using System.Security.Permissions;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// This overrides the lease provided on a MarshalByRef object so that it doesn't
    /// timeout during debugging or otherwise.
    /// </summary>
    public class InfiniteLifetimeMarshalByRefObject : MarshalByRefObject
    {
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public override Object InitializeLifetimeService()
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\FileReportDestination.cs ===
using System;
using System.IO;
using System.Text.RegularExpressions;

namespace ServerTestFramework.Utilities
{
    public class FileReportDestination : InfiniteLifetimeMarshalByRefObject, Report.BulkDestination
    {
        /// <summary> After this many bytes have been written to the file, an error will be written to the file and logging will be stopped.  -1 means no limit. </summary>
        public long OutputLimitInBytes=-1;

        private long bytesProcessedTotal=0;
        string _Filename;
        StreamWriter _LogFile=null;
        object streamLock=new object();

        private void Initialize(string filename)
        {
            _Filename = filename;

            // If the path specified for this filename doesn't exist, we need to create it.
            Match m = new Regex(@"^(.+)\\(.+)$").Match(filename);
            string pathName = ".";
            if (m.Success)
                pathName = m.Groups[1].Value;
            Directory.CreateDirectory(pathName);

            // This creates the file if it doesn't exist, but not the directory.
            _LogFile = File.AppendText(_Filename);

            string testName;
            ThreadTracker.GetTest(out testName);
            Log(Report.INFO, "", _Filename + ": stream opened for logging", testName, System.DateTime.Now);
        }

        public FileReportDestination(string filename)
        {
            Initialize(filename);
        }

        public FileReportDestination(string path, string filename, DateTime dt)
        {
            string fullName = String.Format(path + "\\{0}-{1}-{2}-{3}-{4}-{5}-{6}.txt",
                new object[]{
                                filename,
                                dt.Year,
                                dt.Month,
                                dt.Day,
                                dt.Hour,
                                dt.Minute,
                                dt.Second
                            });
            Initialize(fullName);
        }

        ~FileReportDestination()
        {
            Close();
        }

        // Implemented from Report.Destination
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            lock (streamLock)
            {
                if (_LogFile==null)
                {
                    return;
                }

                WriteSingleLine(level, path, message, testName, date);
                _LogFile.Flush();
            }
        }

        // Implemented from Report.BulkDestination
        public void LogBulk(System.Collections.Generic.LinkedList<Report.ReportLine> lines)
        {
            lock (streamLock)
            {
                if (_LogFile==null)
                {
                    return;
                }

                foreach (Report.ReportLine line in lines)
                {
                    WriteSingleLine(line.Level, line.Path, line.Message, line.TestName, line.Date);
                }

                _LogFile.Flush();
            }
        }

        private void WriteSingleLine(uint level, string path, string message, string testName, System.DateTime date)
        {
            string output=Report.FormatLogLine(date, level, path, message)+"\r\n";

            long prevBytesProcessedTotal=bytesProcessedTotal;
            bytesProcessedTotal+=output.Length;
            if (OutputLimitInBytes!=-1 && prevBytesProcessedTotal<OutputLimitInBytes && bytesProcessedTotal>=OutputLimitInBytes)
            {
                output="[Output limit reached.  No more will be logged.]\r\n";
            }
            else if (OutputLimitInBytes!=-1 && bytesProcessedTotal>=OutputLimitInBytes)
            {
                return;
            }

            _LogFile.Write(output);
        }

        public void Close()
        {
            lock (streamLock)
            {
                if (_LogFile!=null)
                {
                    try
                    {
                        _LogFile.Flush();
                        _LogFile.Close();
                    }
                    catch {}

                    _LogFile=null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\FeedbackInfo.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Create new SleepInfo objects to key off some user feedback
    /// sleep in the GUI/Console/Etc.
    /// 
    /// E.G: 
    ///		new SleepInfo("Waiting for server", 15 * 1000);
    ///		
    ///		This will sleep for 15 seconds while providing some progress
    ///		feedback to the user.
    /// </summary>
    public class SleepInfo
    {
        private uint _SleepStep;
        private uint _SleepValue;
        private uint _SleepTotal;
        private string _Title;

        /// <summary>
        /// Create new sleep info object, this will auto-induce sleep.
        /// </summary>
        /// <param name="title">Title of the feedback widget</param>
        /// <param name="millis">Milliseconds to sleep</param>
        public SleepInfo(string title, uint millis) : base()
        {
            if(millis < 1000)
            {
                throw new ArgumentException("Sleeps of less than a second specified, consider using Thread.Sleep() instead");
            }

            _Title = title;
            _SleepValue = 0;
            _SleepTotal = millis;
            _SleepStep = 100;
            Start();
        }

        // Start the internal timer and progress indication.
        private void Start()
        {
            ProgressFeedbackHandle fbh = FeedbackManager.Instance.CreateProgressFeedback(_Title);

            while(_SleepValue < _SleepTotal)
            {
                fbh.SetProgress(_SleepValue, _SleepTotal);
                Thread.Sleep((int)_SleepStep);
                _SleepValue += _SleepStep;
            }

            fbh.SetProgress(_SleepTotal, _SleepTotal);
            FeedbackManager.Instance.ReleaseProgressFeedback(fbh);
        }
    }

    /// <summary>
    /// ProgressInfo object provide fine grained control over
    /// the display of an elapsed task. 
    /// 
    /// E.G.: 
    /// 
    ///		ProgressInfo progress = new ProgressInfo("Creating objects", 100, 1);
    ///		
    ///		for(int i = 0; i &lt; 100; ++i)
    ///		{
    ///			progress.Step();
    ///		}
    ///		
    ///		If you are unsure of if your progress is finished you should call Finish()
    ///		to ensure that the progress handle is cleaned up internally.
    ///		
    ///		If you step up to or over the maximum value the progress info handle will 
    ///		be automatically cleaned up.
    ///		
    /// </summary>
    public class ProgressInfo
    {
        private string _Title;
        private uint _Total;
        private uint _Value;
        private uint _Step;
        private ProgressFeedbackHandle _Handle;

        /// <summary>
        /// Create a new progress info feedback object.
        /// </summary>
        /// <param name="title">Title as it should appear to the user</param>
        /// <param name="total">Total number of items before completion</param>
        /// <param name="step">Ammount to step per call to Step()</param>
        public ProgressInfo(string title, uint total, uint step)
        {
            _Title = title;
            _Total = total;
            _Value = 0;
            _Step = step;
            _Handle = FeedbackManager.Instance.CreateProgressFeedback(_Title); 
            _Handle.SetProgress(_Value, _Total);
        }

        // Release the handle back to the manager
        private void ReleaseHandle()
        {
            if(_Handle != null)
            {
                FeedbackManager.Instance.ReleaseProgressFeedback(_Handle);
                _Handle = null;
            }
        }

        /// <summary>
        /// Change the user visible message.
        /// </summary>
        /// <param name="message">Message as it should appear to the user</param>
        public void SetMessage(string message)
        {
            if(_Handle != null)
            {
                _Handle.SetMessage(message);
            }
        }

        /// <summary>
        /// Step one 'Step' unit. See the constructor.
        /// </summary>
        public void Step()
        {
            _Value += _Step;

            if(null != _Handle)
            {
                if(_Value >= _Total)
                {
                    _Handle.SetProgress(_Total, _Total);
                    ReleaseHandle();
                }
                else
                {
                    _Handle.SetProgress(_Value, _Total);
                }
            }
        }

        /// <summary>
        /// Step back one 'Step' unit. See the constructor.
        /// </summary>
        public void UnStep()
        {
            _Value -= _Step;

            if(null != _Handle)
            {
                if(_Value < 0)
                {
                    _Handle.SetProgress(0, _Total);
                    ReleaseHandle();
                }
                else
                {
                    _Handle.SetProgress(_Value, _Total);
                }
            }
        }

        /// <summary>
        /// Explicitly change the internal value.
        /// </summary>
        /// <param name="newValue">New value of progress</param>
        public void SetValue(uint newValue)
        {
            if(newValue >= _Total)
            {
                ReleaseHandle();
            }
            else
            {
                _Value = newValue;
                if(null != _Handle)
                {
                    _Handle.SetProgress(_Value, _Total);
                }
            }
        }

        /// <summary>
        /// Move Value to Maximum and cleanup the progress indicator.
        /// </summary>
        public void Finish()
        {
            if(_Handle != null)
            {
                _Handle.SetProgress(_Value, _Total);
                ReleaseHandle();
            }
        }
    }


    /// <summary>
    /// Feedback Handles are used by the concrete class to implement 
    /// user visible feedback however the user interface sees fit.
    /// </summary>
    public abstract class ProgressFeedbackHandle
    {
        public abstract void SetProgress(uint currentValue, uint totalValue);
        public abstract void SetMessage(string message);
    }

    /// <summary>
    /// The abstract factory is set on the manager (also a factory) to hand
    /// out new progress feedback handles. These will be handed out to new instances
    /// of the feedback info classes.
    /// </summary>
    public abstract class FeedbackHandleFactory
    {
        public abstract ProgressFeedbackHandle CreateProgressFeedback(string title);
        public abstract void ReleaseProgressFeedback(ProgressFeedbackHandle handle);
    }

    /// <summary>

    /// Feedback manager is a singleton that is the root of the feedback system. It 
    /// is a composite factory pattern but only one can be active at a time. Access
    /// the active manager with the Instance member. To register your user interface
    /// feedback factory use the SetFactory() method. 
    /// 
    /// New concrete feedback classes can be implemented by talking to the manager.
    /// </summary>
    public class FeedbackManager : FeedbackHandleFactory
    {
        private FeedbackHandleFactory _Factory;
        private static FeedbackManager _Instance;

        private FeedbackManager()
        {
        }

        /// <summary>
        /// Access the global instance of the feedback manager.
        /// </summary>
        public static FeedbackManager Instance {
            get {
                if(_Instance == null)
                {
                    _Instance = new FeedbackManager();
                }
                return _Instance;
            }
        }

        /// <summary>
        /// Set the internal factory. This class acts as a proxy container
        /// for that factory.
        /// </summary>
        /// <param name="factory">Factory to hand out feedback handles</param>
        public void SetFactory(FeedbackHandleFactory factory)
        {
            _Factory = factory;
        }

        /// <summary>
        /// Create a new progress feedback handles for talking to the user interface.
        /// </summary>
        /// <param name="title">User-visible title of the feedback</param>
        /// <returns>New feedback handle</returns>
        public override ProgressFeedbackHandle CreateProgressFeedback(string title)
        {
            CheckFactory();
            return _Factory.CreateProgressFeedback(title);
        }

        /// <summary>
        /// Release a progress feedback handle to the user interface.
        /// </summary>
        /// <param name="handle">Handle that was created with CreateProgressFeedback() on the manager</param>
        public override void ReleaseProgressFeedback(ProgressFeedbackHandle handle)
        {
            CheckFactory();
            _Factory.ReleaseProgressFeedback(handle);
        }

        // Check internal state.
        private void CheckFactory()
        {
            if(_Factory == null)
            {
                //throw new Exception("FeedbackManager: no 
                //factory implementation set");

                // Let's set a null factory instead of throwing an 
                // exception.
                SetFactory(new NullFeedbackHandleFactory()); 
            }
        }
    }

        /// <summary>
    /// The default class in case you try to use the ProgressInfo without 
    /// setting a factory, which seems to happen for certain calls within STF 
    /// when running outside STFRunner.
    /// </summary>
    public class NullProgressFeedbackHandle : ProgressFeedbackHandle
    {
        public override void SetProgress(uint currentValue, uint totalValue)
        {
        }

        public override void SetMessage(string message)
        {
        }
    }

    /// <summary>
    /// The null factory for handing out null feedback handles. Does nothing.
    /// </summary>
    public class NullFeedbackHandleFactory : FeedbackHandleFactory
    {
        public override ProgressFeedbackHandle CreateProgressFeedback(string title)
        {
            return new NullProgressFeedbackHandle();
        }

        public override void ReleaseProgressFeedback(ProgressFeedbackHandle handle)
        {
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\Events.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Works with event logs on multiple servers.  Primary use is searching for specific
    /// events withing logs since the last checkpoint.
    /// </summary>
    /// <example>
    /// // Set up checking event log for the kdc xmacs...
    /// string[] servers = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.kdcsvc);
    /// Events logs = new Events(servers);
    /// logs.Source = "XMACS"; //optional
    /// logs.Init();
    /// // Run tests...
    /// ...
    /// // Check for events by search string in new events.
    /// if (change.TestForChange("execution failed"))
    /// ...
    /// </example>
    public class Events
    {
        private Dictionary<string, int> _serverLastCheck;
        private string _log = "Application";
        private string _source="";
        private string[] _servers;

        public Events()
        {
        }

        public Events(string[] servers)
        {
            _servers = servers;
        }

        /// <summary>
        /// List of servers to check for events.
        /// </summary>
        public string[] Servers
        {
            get { return _servers; }
            set { _servers = value; }
        }
    
        /// <summary>
        /// Source of the events.  ie. 'xmatchfd'
        /// </summary>
        public string Source
        {
            get { return _source; }
            set { _source = value; }
        }

        /// <summary>
        /// Name of the Log to access.  Default 'Application'
        /// </summary>
        public string Log
        {
            get { return _log; }
            set { _log = value; }
        }

        /// <summary>
        /// Run before your operation to get a base for the log.
        /// </summary>
        /// <returns>True if all servers listed responded; false if any did not.</returns>
        public bool Init()
        {
            bool allGood=true;
            if (_serverLastCheck == null)
            {
                _serverLastCheck = new Dictionary<string, int>();
            }

            _serverLastCheck.Clear();

            foreach(string server in _servers)
            {
                try
                {
                    //get the latest index in the log
                    EventLog eventLog = new EventLog(Log, server, Source);
                    EventLogEntry entry = eventLog.Entries[eventLog.Entries.Count-1];

                    //add server
                    _serverLastCheck.Add(server, entry.Index);
                }
                catch (Exception e)
                {
                    allGood=false;
                    CoreGlobal.RO.Warn("Machine \""+server+"\" did not respond to event log request, so we won't be able to check it: "+e.Message);
                }
            }

            return allGood;
        }

        #region Member TestForChange*

        /// <summary>
        /// Searches new entries since Init() or the last TestForChange* was called.
        /// </summary>
        /// <param name="search">String to look for in the log.</param>
        /// <returns>True if Search string is found in any log since the last advancement.</returns>
        public bool TestForChange (string search)
        {
            return TestForChange(search, true);
        }

        /// <summary>
        /// Searches new entries since Init() or the last TestForChange* was called with advance == true.
        /// </summary>
        /// <param name="search">String to look for in the log.</param>
        /// <param name="advance">If true, advances the search index; if false, does not.</param>
        /// <returns>True if Search string is found in any log since the last advancement.</returns>
        public bool TestForChange (string search, bool advance)
        {
            // check each server
            foreach(string server in _servers)
            {
                if (_serverLastCheck.ContainsKey(server)) //except ones we couldn't connect to
                {
                    int lastChecked;
                    bool isChanged = TestServerForEvents(server, _log, _source, search, _serverLastCheck[server], 
                        out lastChecked);

                    if (advance)
                    {
                        _serverLastCheck[server] = lastChecked;
                    }
                    
                    if (isChanged)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Searches new entries since Init() or the last TestForChange* was called.
        /// </summary>
        /// <param name="id">The event id to search for.</param>
        /// <returns>True if event id is found in any log since the last advancement.</returns>
        public bool TestForChange (long id)
        {
            return TestForChange(id, null, true);
        }

        /// <summary>
        /// Searches new entries since Init() or the last TestForChange* was called.
        /// </summary>
        /// <param name="id">The event id to search for.</param>
        /// <param name="eventData">The event data to check events for.</param>
        /// <returns>True if event id is found in any log since the last advancement.</returns>
        public bool TestForChange (long id, byte[] eventData)
        {
            return TestForChange(id, eventData, true);
        }

        /// <summary>
        /// Searches new entries since Init() or the last TestForChange* was called with advance == true.
        /// </summary>
        /// <param name="id">The event id to search for.</param>
        /// <param name="advance">If true, advances the search index; if false, does not.</param>
        /// <returns>True if event id is found in any log since the last advancement.</returns>
        public bool TestForChange (long id, bool advance)
        {
            return TestForChange(id, null, advance);
        }

        /// <summary>
        /// Searches new entries since Init() or the last TestForChange* was called with advance == true.
        /// </summary>
        /// <param name="id">The event id to search for.</param>
        /// <param name="eventData">The event data to check events for.</param>
        /// <param name="advance">If true, advances the search index; if false, does not.</param>
        /// <returns>True if event id is found in any log since the last advancement.</returns>
        public bool TestForChange (long id, byte[] eventData, bool advance)
        {
            // check each server
            foreach (string server in _servers)
            {
                if (_serverLastCheck.ContainsKey(server)) //except ones we couldn't connect to
                {
                    int lastChecked;
                    bool isChanged = TestServerForEvents(server, _log, _source, id, eventData, _serverLastCheck[server],
                        out lastChecked);

                    if (advance)
                    {
                        _serverLastCheck[server] = lastChecked;
                    }

                    if (isChanged)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Searches new entries since Init() or the last TestForChange* was called.
        /// </summary>
        /// <param name="search">The string to search for.</param>
        /// <param name="expect">True if the string is expected; false if it is not.</param>
        /// <returns>
        /// If expect is true: Returns true if the string is found on all servers; false if it is missing from one or more.
        /// If expect is false: Returns true if the string is not found on all servers; false if it is found on one or more.
        /// </returns>
        public bool TestForChangeAll (string search, bool expect)
        {
            return TestForChangeAll(search, expect, true);
        }

        /// <summary>
        /// Searches new entries since Init() or the last TestForChange* was called with advance == true.
        /// </summary>
        /// <param name="search">The string to search for.</param>
        /// <param name="expect">True if the string is expected; false if it is not.</param>
        /// <param name="advance">If true, advances the last time; if false, does not.</param>
        /// <returns>
        /// If expect is true: Returns true if the string is found on all servers; false if it is missing from one or more.
        /// If expect is false: Returns true if the string is not found on all servers; false if it is found on one or more.
        /// </returns>
        public bool TestForChangeAll (string search, bool expect, bool advance)
        {
            foreach (string server in _servers)
            {
                if (_serverLastCheck.ContainsKey(server))
                {
                    int lastChecked;
                    bool isChanged = TestServerForEvents(server, _log, _source, search, _serverLastCheck[server], 
                        out lastChecked);

                    if (advance)
                    {
                        _serverLastCheck[server] = lastChecked;
                    }

                    if (isChanged != expect)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        #endregion

        #region Static TestServerForEvents

        /// <summary>
        /// Searches the server log for the search string that occured in an event after begin.
        /// </summary>
        /// <param name="server">The server to search.</param>
        /// <param name="log">The log to search.</param>
        /// <param name="source">The source of events.</param>
        /// <param name="search">The string to search for.</param>
        /// <param name="begin">The earliest the event could occur to be relevant.</param>
        /// <param name="outLastTime">Output param: The last time value that was checked for events in the log.</param>
        /// <returns>True if a matching event is found; false if it is not.</returns>
        public static bool TestServerForEvents (string server, string log, string source, string search, 
            DateTime begin, out DateTime outLastTime)
        {
            EventLog eventLog = new EventLog(log, server, source);
            EventLogEntry[] entries = GetEventsAfter(eventLog, begin);

            // this means that no events happened after begin, has to be false
            if (entries.Length == 0)
            {
                outLastTime = eventLog.Entries[eventLog.Entries.Count - 1].TimeGenerated;
                return false;
            }

            outLastTime = entries[entries.Length - 1].TimeGenerated;

            for (int i = entries.Length - 1; i >= 0; --i)
            {
                EventLogEntry entry = entries[i];

                if (source!=null && source.Length>0 && entry.Source!=source)
                {
                    continue;
                }

                if (entry.Message.ToLower().Contains(search.ToLower()))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Searches the server log for the search string that occured in an event after the given index.
        /// </summary>
        /// <param name="server">The server to search.</param>
        /// <param name="log">The log to search.</param>
        /// <param name="source">The source of events.</param>
        /// <param name="search">The string to search for.</param>
        /// <param name="index">The search will begin after the event with this index.</param>
        /// <param name="outLastIndex">Output param: The index of the last event that was checked in the log.</param>
        /// <returns>True if a matching event is found; false if it is not.</returns>
        public static bool TestServerForEvents (string server, string log, string source, string search,
            int index, out int outLastIndex)
        {
            EventLog eventLog = new EventLog(log, server, source);
            EventLogEntry[] entries = GetEventsAfter(eventLog, index);

            // this means that no events happened after index, has to be false
            if (entries.Length == 0)
            {
                outLastIndex = eventLog.Entries[eventLog.Entries.Count - 1].Index;
                return false;
            }

            outLastIndex = entries[entries.Length - 1].Index;

            for (int i = entries.Length - 1; i >= 0; --i)
            {
                EventLogEntry entry = entries[i];

                if (source != null && source.Length > 0 && entry.Source != source)
                {
                    continue;
                }

                if (entry.Message.ToLower().Contains(search.ToLower()))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Searches the server log for the event id after begin.
        /// </summary>
        /// <param name="server">The server to search.</param>
        /// <param name="log">The log to search.</param>
        /// <param name="source">The source of events.</param>
        /// <param name="id">The event id to search for.</param>
        /// <param name="begin">The earliest the event could occur to be relevant.</param>
        /// <param name="end">The latest the event could occur to be relevant.</param>
        /// <returns>True if a matching event is found; false if it is not.</returns>
        public static bool TestServerForEvents (string server, string log, string source, long id, DateTime begin,
            DateTime end)
        {
            EventLog eventLog = new EventLog(log, server, source);
            EventLogEntry[] entries = GetEventsAfter(eventLog, begin);

            for (int i = entries.Length - 1; i >= 0; --i)
            {
                EventLogEntry entry = entries[i];

                if (end < entry.TimeGenerated)
                {
                    continue;
                }

                if (source != null && source.Length > 0 && entry.Source != source)
                {
                    continue;
                }

                // because of the fact that InstanceId includes extra information, we let the bottom 30 bits match as well
                if (entry.InstanceId == id || (entry.InstanceId & 0x3FFFFFFF) == (id & 0x3FFFFFFF))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Searches the server log for the event id that occured after the given index.
        /// </summary>
        /// <param name="server">The server to search.</param>
        /// <param name="log">The log to search.</param>
        /// <param name="source">The source of events.</param>
        /// <param name="id">The event id to search for.</param>
        /// <param name="index">The search will begin after the event with this index.</param>
        /// <param name="outLastIndex">Output param: The index of the last event that was checked in the log.</param>
        /// <returns>True if a matching event is found; false if it is not.</returns>
        public static bool TestServerForEvents (string server, string log, string source, long id,
            int index, out int outLastIndex)
        {
            return TestServerForEvents(server, log, source, id, null, index, out outLastIndex);
        }

        /// <summary>
        /// Searches the server log for the event id that occured after the given index.
        /// </summary>
        /// <param name="server">The server to search.</param>
        /// <param name="log">The log to search.</param>
        /// <param name="source">The source of events.</param>
        /// <param name="id">The event id to search for.</param>
        /// <param name="eventData">The binary data that should be included in the event.</param>
        /// <param name="index">The search will begin after the event with this index.</param>
        /// <param name="outLastIndex">Output param: The index of the last event that was checked in the log.</param>
        /// <returns>True if a matching event is found; false if it is not.</returns>
        public static bool TestServerForEvents (string server, string log, string source, long id, byte[] eventData,
            int index, out int outLastIndex)
        {
            EventLog eventLog = new EventLog(log, server, source);
            EventLogEntry[] entries = GetEventsAfter(eventLog, index);

            // this means that no events happened after index, has to be false
            if (entries.Length == 0)
            {
                outLastIndex = eventLog.Entries[eventLog.Entries.Count - 1].Index;
                return false;
            }

            outLastIndex = entries[entries.Length - 1].Index;

            for (int i = entries.Length - 1; i >= 0; --i)
            {
                EventLogEntry entry = entries[i];

                if (source != null && source.Length > 0 && entry.Source != source)
                {
                    continue;
                }

                // because of the fact that InstanceId includes extra information, we let the bottom 30 bits match as well
                if (entry.InstanceId == id || (entry.InstanceId & 0x3FFFFFFF) == (id & 0x3FFFFFFF))
                {
                    // if we need to check event data
                    if (eventData != null)
                    {
                        byte[] entryData = entry.Data;

                        // event has no data, so it can't be right
                        // or the length is wrong
                        if (entryData == null || eventData.Length != entryData.Length)
                        {
                            continue;
                        }

                        // check the bytes
                        bool bytesBad = false;

                        for (int j = 0, k = eventData.Length; j < k; ++j)
                        {
                            if (eventData[j] != entryData[j])
                            {
                                bytesBad = true;
                                break;
                            }
                        }

                        if (bytesBad)
                        {
                            continue;
                        }
                    }

                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Searches the server log for the event id after begin.
        /// </summary>
        /// <param name="server">The server to search.</param>
        /// <param name="log">The log to search.</param>
        /// <param name="source">The source of events.</param>
        /// <param name="id">The event id to search for.</param>
        /// <param name="search">The string to search for.</param>
        /// <param name="begin">The earliest the event could occur to be relevant.</param>
        /// <param name="end">The latest the event could occur to be relevant.</param>
        /// <returns>True if a matching event is found; false if it is not.</returns>
        public static bool TestServerForEvents (string server, string log, string source, long id, string search, 
            DateTime begin, DateTime end)
        {
            EventLog eventLog = new EventLog(log, server, source);
            EventLogEntry[] entries = GetEventsAfter(eventLog, begin);

            for (int i = entries.Length - 1; i >= 0; --i)
            {
                EventLogEntry entry = entries[i];

                if (end < entry.TimeGenerated)
                {
                    continue;
                }

                if (source != null && source.Length > 0 && entry.Source != source)
                {
                    continue;
                }

                // because of the fact that InstanceId includes extra information, we let the bottom 30 bits match as well
                if ((entry.InstanceId == id || (entry.InstanceId & 0x3FFFFFFF) == (id & 0x3FFFFFFF)) && entry.Message.Contains(search))
                {
                    return true;
                }
            }

            return false;
        }

        public static bool TestServerForEvents(string server, string log, string source, string search, DateTime begin)
        {
            DateTime lastTimeWaste=new DateTime();
            return TestServerForEvents(server, log, source, search, begin, out lastTimeWaste);
        }

        #endregion

        #region Protected

        /// <summary>
        /// Gets all of the events after a certain time.  Attempts to compensate for a moving log target.
        /// </summary>
        /// <param name="eventLog">The log to get from.</param>
        /// <param name="begin">The time to start getting events.</param>
        /// <returns>An array of events from the log after the time.</returns>
        /// <remarks>
        /// The change to make this copy out the timed list of entries was due to the fact that when the event log
        /// becomes too large, it will automatically truncate.  This would cause the end of the list to drop out
        /// from under the index, throwing an exception.
        /// 
        /// We now do a binary search to find the oldest entry we care about, then copy out the entries from that
        /// one to the end.  If the oldest entry in the log hasn't changed, then we continue on.
        /// </remarks>
        protected static EventLogEntry[] GetEventsAfter (EventLog eventLog, DateTime begin)
        {
            EventLogEntry first = null;
            EventLogEntry[] entries = null;
            int tries_left = 10;

            while (tries_left > 0)
            {
                --tries_left;

                first = eventLog.Entries[0];
                int pos = FindFirstGTE(eventLog, begin);

                // although this could still not be perfect, its all we can do
                if (first.Equals(eventLog.Entries[0]))
                {
                    // this means that no events happened after begin, has to be empty
                    if (pos == -1)
                    {
                        return new EventLogEntry[0];
                    }

                    entries = new EventLogEntry[eventLog.Entries.Count - pos];

                    // hopefully we do this fast enough...
                    try
                    {
                        for (int i = 0; i < entries.Length; ++i)
                        {
                            entries[i] = eventLog.Entries[pos + i];
                        }

                        // check again for good measure
                        if (first.Equals(eventLog.Entries[0]))
                        {
                            break;
                        }
                    }
                    catch (Exception e)
                    {
                        CoreGlobal.RO.Debug("Got an exception when copying the entries over: " + e.Message);
                    }

                    // oh well, fail back around
                    entries = null;
                }
            }

            // ran out of tries
            if (entries == null)
            {
                throw new Exception("The event log that you are attempting to check is moving to fast to " +
                    "correctly analyze.");
            }

            return entries;
        }

        /// <summary>
        /// Does a binary search to find the first entry whose time is >= the time passed in.
        /// </summary>
        /// <param name="log">The log to search.</param>
        /// <param name="time">The time to search for.</param>
        /// <returns>The index of the entry, or -1 if it all entries are earlier than time.</returns>
        protected static int FindFirstGTE (EventLog log, DateTime time)
        {
            EventLogEntryCollection elec = log.Entries;
            int low = 0, high = -1;
            int pos = elec.Count / 2;

            while (true)
            {
                if (elec[pos].TimeGenerated < time)
                {
                    if (pos + 1 >= elec.Count)
                    {
                        return -1;
                    }
                    else if (elec[pos + 1].TimeGenerated >= time)
                    {
                        return pos + 1;
                    }
                    else
                    {
                        low = pos;
                        pos += ((high == -1 ? elec.Count : high) - pos) / 2;
                    }
                }
                else
                {
                    if (pos == 0)
                    {
                        return 0;
                    }
                    else if (elec[pos - 1].TimeGenerated < time)
                    {
                        return pos;
                    }
                    else
                    {
                        high = pos;
                        pos = low + (pos - low) / 2;
                    }
                }
            }
        }

        /// <summary>
        /// Gets all of the events after a certain index.  Attempts to compensate for a moving log target.
        /// </summary>
        /// <param name="eventLog">The log to get from.</param>
        /// <param name="index">The index after which to start getting events.</param>
        /// <returns>An array of events from the log after the index..</returns>
        protected static EventLogEntry[] GetEventsAfter (EventLog eventLog, int index)
        {
            EventLogEntry first = null;
            EventLogEntry[] entries = null;
            int tries_left = 10;

            while (tries_left > 0)
            {
                --tries_left;

                first = eventLog.Entries[0];

                List<EventLogEntry> ans = new List<EventLogEntry>();

                // hopefully we do this fast enough...
                try
                {
                    EventLogEntryCollection elec = eventLog.Entries;
                    int pos = elec.Count - 1;

                    while (pos >= 0 && elec[pos].Index > index)
                    {
                        ans.Add(elec[pos--]);
                    }

                    // check again for good measure
                    if (first.Equals(eventLog.Entries[0]))
                    {
                        ans.Reverse();
                        entries = ans.ToArray();
                        break;
                    }
                }
                catch (Exception e)
                {
                    CoreGlobal.RO.Debug("Got an exception when copying the entries over: " + e.Message);
                }
            }

            // ran out of tries
            if (entries == null)
            {
                throw new Exception("The event log that you are attempting to check is moving to fast to " +
                    "correctly analyze.");
            }

            return entries;
        }

        /// <summary>
        /// Does a binary search to find the first entry whose index is > the index passed in.
        /// </summary>
        /// <param name="log">The log to search.</param>
        /// <param name="index">The index to search for.</param>
        /// <returns>The index of the entry, or -1 if it all entries are earlier than index.</returns>
        protected static int FindFirstGT (EventLog log, int index)
        {
            EventLogEntryCollection elec = log.Entries;
            int low = 0, high = -1;
            int pos = elec.Count / 2;

            for (int i = 0, j = elec.Count; i < j; ++i)
            {
                if (elec[pos].Index <= index)
                {
                    if (pos + 1 >= elec.Count)
                    {
                        return -1;
                    }
                    else if (elec[pos + 1].Index > index)
                    {
                        return pos + 1;
                    }
                    else
                    {
                        low = pos;
                        pos += ((high == -1 ? elec.Count : high) - pos + 1) / 2;
                    }
                }
                else
                {
                    if (pos == 0)
                    {
                        return 0;
                    }
                    else if (elec[pos - 1].Index <= index)
                    {
                        return pos;
                    }
                    else
                    {
                        high = pos;
                        pos = low + (pos - low) / 2;
                    }
                }
            }

            throw new Exception(string.Format("Unable to find event index: low[{0}], high[{1}], pos[{2}], elec.Count[{3}]", 
                low, high, pos, elec.Count));
        }

        #endregion
    }

    /// <summary>
    /// Monitors an eventlog for a list of events.
    /// </summary>
    public class EventMonitor
    {
        public EventMonitor(string []serverList, string []eventStringList, string optionalSource, string optionalLogFileName)
        {
            servers=(string[])serverList.Clone();
            events=(string[])eventStringList.Clone();
            logFile=optionalLogFileName;
            source=optionalSource;

            ResetWatcher();
        }

        /// <summary>
        /// Checks eventChecker for an occurance of any event in eventStringList.
        /// If a logfile was provided, the event will be saved to that file.
        /// If another Poll on the object is already in progress, it returns immediately with null.
        /// </summary>
        /// <returns>A list of events that occured, or null if none (or failure trying to check).</returns>
        public string[] Poll()
        {
            if (inProgress) return null;
            if (watcher==null) ResetWatcher();
            if (watcher==null) return null;

            lock (pollLock)
            {
                try
                {
                    inProgress=true;

                    System.Collections.Generic.List<string> hits=new System.Collections.Generic.List<string>();

                    for (int i=0; i<events.Length; ++i)
                    {
                        bool adv=(i==events.Length-1?true:false);

                        if (watcher.TestForChange(events[i],adv))
                        {
                            //TODO: ideally we could grab the full event text here
                            LogString("Event string detected: "+events[i]);
                            hits.Add(events[i]);
                        }
                    }

                    if (hits.Count==0) return null;
                    else return hits.ToArray();
                }
                catch (Exception e)
                {
                    CoreGlobal.RO.Warn("Exception trying to check event log (we will try to resync to it): "+e.Message);
                    LogString("Event Monitor: Exception trying to check events.  We will resync: "+e.Message);
                    ResetWatcher();
                    return null;
                }
                finally
                {
                    inProgress=false;
                }
            }
        }

        // --

        private void ResetWatcher()
        {
            watcher=new Events(servers);
            if (source!=null && source.Length>0) watcher.Source=source;

            try
            {
                watcher.Init();
                LogString("Initialized event watcher.");
            }
            catch (Exception e)
            {
                CoreGlobal.RO.Warn("Exception in EventMonitor ResetWatcher: "+e.Message);
                LogString("Failed to initialize event watcher: "+e.Message);
                watcher=null;
            }
        }

        private void LogString(string str)
        {
            if (logFile==null || logFile.Length==0) return;

            //build the string into a byte array
            string logstr=System.DateTime.Now+": "+str+"\r\n";

            //write it
            try
            {
                System.IO.StreamWriter sw=System.IO.File.AppendText(logFile);
                sw.Write(logstr);
                sw.Close();
            }
            catch (Exception e)
            {
                CoreGlobal.RO.Warn("Failed to log event to file: "+e.Message);
            }
        }

        private string []servers;
        private string logFile=null;
        private string []events;
        private string source;

        private object pollLock=new object();
        private bool inProgress=false;

        private Events watcher;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\HttpClient.cs ===
using System;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Collections.Generic;

using ServerTestFramework;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// An exception thrown by the HttpClient class.
    /// </summary>
    public class HttpClientException : Exception
    {
        /// <summary>
        /// An exception thrown by the HttpClient class.
        /// </summary>
        public HttpClientException () : base() { }

        /// <summary>
        /// An exception thrown by the HttpClient class, with the given message.
        /// </summary>
        public HttpClientException (string message) : base(message) { }
    }

    /// <summary>
    /// A simple generic http client.
    /// Unlike .NET's wrapper, this does not guarentee that a built request is actually valid, making it useful for negative cases.
    /// </summary>
    public class HttpClient: IDisposable
    {
        public static bool Verbose=false;

        //Request, Response
        #region Useful Structs

        /// <summary>
        /// Used to build a request to the server.
        /// Any field set to null will not be included in the request.
        /// Each field is seperated by \r\n.
        /// </summary>
        public class Request
        {
            //Required first header
            public string Method="GET";
            public string URI="/";                                    //Path or Resourse to access (for example "/foo/bar.html")
            public string Version="HTTP/1.1";

            //Common headers
            public string Host;                                       //Name of the server (for example "livetest")
            public string UserAgent="STFTest/1.0";
            public string ContentLength;

            //Any other headers you'd like to include.
            //Each header is just added as-is (For valid requests you need to format it like "Name: Value"), and is seperated by \r\n.
            public LinkedList<string> OtherHeaders=new LinkedList<string>(); //A list of extra fields to include

            //The data-body to include
            public byte []Content;

            // --

            //ctors
            public Request()
            {
            }
            public Request(string host, string path)
            {
                Host=host;
                URI=path;
            }
            public Request(byte []requestBlob)
            {
                //parse out the headers chunk
                Nullify(); //we want a full clean slate here
                int bodyIndex=ArrayEx.SearchByteArray(requestBlob,ByteEncoding.Instance.GetBytes("\r\n\r\n"),0);
                if (bodyIndex!=-1) bodyIndex+=4; //rnrn

                string blob=ByteEncoding.Instance.GetString(requestBlob,0,(bodyIndex==-1?requestBlob.Length:bodyIndex));
                string []lines=blob.Split(new string[]{"\r\n"},StringSplitOptions.RemoveEmptyEntries);

                if (lines.Length>0)
                {
                    //the first line is the VERB URI VER line
                    string chunk="";
                    lines[0]+=" "; //simplify parsing
                    foreach (char c in lines[0])
                    {
                        if (c==' ') //section change
                        {
                            if (chunk.Length>0) //we finished a section
                            {
                                if (Method==null)
                                {
                                    Method=chunk;
                                    chunk="";
                                }
                                else if (URI==null)
                                {
                                    URI=chunk;
                                    chunk="";
                                }
                                else if (Version==null)
                                {
                                    Version=chunk;
                                    chunk="";
                                }
                            }
                        }
                        else
                            chunk+=c;
                    }

                    //the rest of the lines are headers
                    for (int l=1; l<lines.Length; ++l)
                    {
                        int divInd=lines[l].IndexOf(':');
                        if (divInd==-1) //?
                        {
                            //Global.RO.Warn("Unexpected header line format while parsing request blob: "+lines[l]);
                            OtherHeaders.AddLast(lines[l]); //just dump it into "others"
                        }
                        else
                        {
                            //use key to place as a known header if possible
                            string key=lines[l].Substring(0,divInd).Trim();
                            if (key=="Host") Host=lines[l].Substring(divInd+1).Trim();
                            else if (key=="User-Agent") UserAgent=lines[l].Substring(divInd+1).Trim();
                            else if (key=="Content-Length") ContentLength=lines[l].Substring(divInd+1).Trim();
                            else //any others go in "others"
                            {
                                OtherHeaders.AddLast(lines[l]);
                            }
                        }
                    }
                }

                //the rest is the body
                int contentLen=requestBlob.Length-bodyIndex;
                if (contentLen>0)
                {
                    Content=new byte[contentLen];
                    System.Buffer.BlockCopy(requestBlob,bodyIndex,Content,0,Content.Length);
                }
            }

            //sets all fields to null/empty
            public void Nullify()
            {
                Method=null;
                URI=null;
                Version=null;
                Host=null;
                UserAgent=null;
                ContentLength=null;
                OtherHeaders.Clear();
                Content=null;
            }

            //Sets the Content-Length and the body for the message
            public void SetContentLengthAndBody(byte []data)
            {
                Content=(byte[])data.Clone();
                ContentLength=data.Length.ToString();
            }
            public void SetContentLengthAndBody(string str)
            {
                SetContentLengthAndBody(ByteEncoding.Instance.GetBytes(str));
            }

            //Retrieves the body content as a string
            public string GetContentString()
            {
                return ByteEncoding.Instance.GetString(Content);
            }

            /// <summary>
            /// Constructs the header string.
            /// </summary>
            /// <returns>The header string.</returns>
            protected string GetHeaderString()
            {
                Request useRequest=this;
                if (BuildHeaderEvent!=null) BuildHeaderEvent(this, out useRequest);

                string s = "";

                //headers
                if (useRequest.Method != null) s += useRequest.Method + " ";
                if (useRequest.URI != null) s += useRequest.URI + " ";
                if (useRequest.Version != null) s += useRequest.Version;
                if (useRequest.Method != null || useRequest.URI != null || useRequest.Version != null) s += "\r\n";

                if (useRequest.Host != null) s += "Host: " + useRequest.Host + "\r\n";

                if (useRequest.UserAgent != null) s += "User-Agent: " + useRequest.UserAgent + "\r\n";

                if (useRequest.ContentLength != null) s += "Content-Length: " + useRequest.ContentLength + "\r\n";

                foreach (string ext in useRequest.OtherHeaders)
                {
                    s += ext + "\r\n";
                }

                s += "\r\n";

                return s;
            }

            //puts all the fields together into a single string for the request
            public override string ToString()
            {
                string s = GetHeaderString();

                if (Content!=null) s+=ByteEncoding.Instance.GetString(Content);

                return s;
            }

            //puts the string representation into bytes
            public byte[] ToBytes()
            {
                string headers = GetHeaderString();
                int byte_count = ByteEncoding.Instance.GetByteCount(headers);
                byte[] ans = new byte[byte_count + (Content == null ? 0 : Content.Length)];

                ByteEncoding.Instance.GetBytes(headers, 0, headers.Length, ans, 0);
                if (Content != null)
                {
                    Buffer.BlockCopy(Content, 0, ans, byte_count, Content.Length);
                }

                return ans;
            }

            //creates a copy of the object, with the headers being seperate, but the body data still shared
            public Request ShallowCloneWithDeepHeaders()
            {
                Request req=new Request();
                req.Method=Method;
                req.URI=URI;
                req.Version=Version;
                req.Host=Host;
                req.UserAgent=UserAgent;
                req.ContentLength=ContentLength;
                req.Content=Content;

                foreach (string s in OtherHeaders)
                {
                    req.OtherHeaders.AddLast(s);
                }

                return req;
            }

            //Event for a request being converted to data.  This can be hooked to fuzz the request at a higher level.
            public delegate void BuildHeaderDelegate(/*const*/ Request inReq, out Request outReq);
            public static event BuildHeaderDelegate BuildHeaderEvent;
        };

        /// <summary>
        /// Used to return the response from a server.
        /// If a field is null, it means there was no response for it.
        /// </summary>
        public class Response
        {
            //Required headers for every response
            public string Version;          //For example: HTTP/1.1
            public int Status;              //The response code from the server (200, etc)
            public string Reason;           //The human-friendly meaning of the returned code.

            //All headers are in here
            public LinkedList< KeyValuePair<string,string> > Headers=new LinkedList< KeyValuePair<string,string> >();

            //The body of the response
            public string ContentString;    //As a string
            public byte[] ContentBytes;     //As a binary blob

            /// <summary>An exception thrown when attempting to retrieve this response.</summary>
            public Exception Exception = null;

            // --

            //Returns the count of a specific header name.
            public uint GetHeaderCount(string name)
            {
                uint count=0;
                foreach (KeyValuePair<string,string> pair in Headers)
                {
                    if (pair.Key==name)
                    {
                        ++count;
                    }
                }

                return count;
            }

            //Returns the value of a specific header.  This throws if the header is not found, or if more than one were found.
            public string GetSingleHeader(string name)
            {
                string value=null;

                foreach (KeyValuePair<string,string> pair in Headers)
                {
                    if (pair.Key==name)
                    {
                        if (value!=null) throw new Exception("More than one header with the name "+name+" was found.");
                        else value=pair.Value;
                    }
                }

                if (value==null) throw new Exception("No header by the name "+name+" was found.");
                return value;
            }

            //Returns all values for a specific header (does not throw)
            public string[] GetHeaders(string name)
            {
                List<string> values=new List<string>();

                foreach (KeyValuePair<string,string> pair in Headers)
                {
                    if (pair.Key==name)
                    {
                        values.Add(pair.Value);
                    }
                }

                return values.ToArray();
            }

            //Parses a response from the server to fill in this struct.  Note that this assumes that the server returns well-formed responses.
            // If inData contains a full response, then returns true and outExtraData points to any extra unused bytes.
            // Else returns false if there's not enough data to build a full response.
            public bool FromBlob(byte []inData, bool parseBody, out byte []outExtraData)
            {
                outExtraData=null;

                //Parse out the Version+Status+Reason line
                string tmp="";
                int offset=0;
                foreach (byte b in inData)
                {
                    if (b==(byte)'\r') break;

                    if (b==32) //space
                    {
                        if (Version==null) Version=tmp;
                        else if (Status==0) Status=int.Parse(tmp);
                        else if (Reason==null) Reason=tmp;
                        else Reason+=" "+tmp;

                        tmp="";
                    }
                    else
                        tmp+=(char)b;

                    ++offset;
                }

                if (Reason==null) Reason=tmp;
                else Reason+=" "+tmp;

                offset+=2; //skip the \n

                if (Version==null || Status==0) return false;
                if (Verbose) CoreGlobal.RO.Debug("Parsed response status: "+Version+" "+Status+" "+Reason);

                //Parse out the headers
                int consecutiveBreaks=0;
                string key="";
                string val="";
                bool isDoingVal=false;
                for (; offset<inData.Length; ++offset)
                {
                    byte b=inData[offset];

                    //handle linebreaks
                    if (b==(byte)'\r' || b==(byte)'\n')
                    {
                        ++consecutiveBreaks;
                        if (consecutiveBreaks==4) break; //two \r\n in a row means end of headers

                        if (key.Length!=0) //add new header
                        {
                            if (Verbose) CoreGlobal.RO.Debug("Parsed response header: "+key+":"+val);
                            Headers.AddLast(new KeyValuePair<string,string>(key,val.Trim()));
                        }

                        key="";
                        val="";
                        isDoingVal=false;

                        continue;
                    }

                    consecutiveBreaks=0;

                    //handle other chars
                    if (!isDoingVal) //parsing key
                    {
                        if (b==(byte)':') //: is the end of the key
                            isDoingVal=true;
                        else
                            key+=(char)b;
                    }
                    else //parsing val
                    {
                        val+=(char)b;
                    }
                }
                ++offset;

                //if we don't need a body, return what we have
                if (!parseBody)
                {
                    if (offset<inData.Length) //is more data for another response
                    {
                        outExtraData=new byte[inData.Length-offset];
                        Buffer.BlockCopy(inData, offset, outExtraData, 0, outExtraData.Length);
                    }

                    return true;
                }

                //Parse out body if any
                int bodyBytes=0;
                if (GetHeaderCount("Content-Length")>0) bodyBytes=int.Parse(GetSingleHeader("Content-Length"));
                if (bodyBytes+offset>inData.Length) //not enough data to form the response body
                {
                    return false;
                }

                ContentBytes=new byte[bodyBytes];
                if (bodyBytes > 0)
                {
                    System.Buffer.BlockCopy(inData, offset, ContentBytes, 0, bodyBytes);
                }

                ContentString=ByteEncoding.Instance.GetString(ContentBytes);
                if (Verbose) CoreGlobal.RO.Debug("Parsed response body:\n"+ContentString);

                offset+=bodyBytes;

                //return the rest of the data
                if (offset<inData.Length) //is more data for another response
                {
                    outExtraData=new byte[inData.Length-offset];
                    Buffer.BlockCopy(inData, offset, outExtraData, 0, outExtraData.Length);
                }
                return true;
            }

            //Converts the struct back into a string that represents all the fields
            public override string ToString()
            {
                string s=Version+" "+Status+" "+Reason+"\r\n";

                foreach (KeyValuePair<string,string> pair in Headers)
                {
                    s+=pair.Key+": "+pair.Value+"\r\n";
                }

                s+="\r\n";
                if (ContentString!=null) s+=ContentString;

                return s;
            }
        };

        #endregion //Useful Structs

        //Constructor
        #region Setup

        /// <summary>
        /// Creates the socket, used by other constructors.
        /// </summary>
        protected HttpClient ()
        {
            sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        }

        /// <summary>
        /// From a hostname/ip and port.
        /// </summary>
        public HttpClient(string host, ushort port) : this()
        {
            Setup(host,port);
        }

        /// <summary>
        /// From a url (only the hostname and port are used).
        /// </summary>
        public HttpClient(string url) : this()
        {
            //remove prefix
            int htInd=url.IndexOf("http://");
            if (htInd==-1) htInd=url.IndexOf("https://");
            string sstr=url;
            if (htInd==0) sstr=url.Substring(sstr.IndexOf('/')+2);

            //remove path suffix
            int slashInd=sstr.IndexOf('/');
            if (slashInd!=-1) sstr=sstr.Substring(0,slashInd);

            //parse out name and port (default 80) from what's left([sub.]name[.domain]:port or just [sub.]name[.domain])
            string []parts=sstr.Split(new char[]{':'});
            serverHost=parts[0];
            serverPort=80;
            if (parts.Length>1) serverPort=ushort.Parse(parts[1]);

            //
            Setup(serverHost,serverPort);
        }

        /// <summary>
        /// Creates a client that points at the given IP endpoint.
        /// </summary>
        /// <param name="endpoint">The location to talk to.</param>
        public HttpClient (IPEndPoint endpoint) : this()
        {
            serverIP = endpoint.Address;
            serverHost = endpoint.Address.ToString();

            serverPort = (ushort) endpoint.Port;

            sock.ReceiveTimeout = (int) defaultSocketTimeout;
            sock.SendTimeout = (int) defaultSocketTimeout;
        }

        /// <summary>
        /// Creates a client using the given socket and IP endpoint.
        /// </summary>
        /// <param name="socket">The socket to use for the connection.</param>
        /// <param name="endpoint">The location to talk to.</param>
        public HttpClient (Socket socket, IPEndPoint endpoint)
        {
            serverIP = endpoint.Address;
            serverHost = endpoint.Address.ToString();

            serverPort = (ushort) endpoint.Port;

            sock = socket;
            sock.ReceiveTimeout = (int) defaultSocketTimeout;
            sock.SendTimeout = (int) defaultSocketTimeout;
        }

        public void Dispose()
        {
            if (sock!=null)
            {
                try
                {
                    sock.Close();
                }
                catch
                {
                }
            }
        }

        #endregion //Setup

        //Useful members
        public Socket Socket
        {
            get { return sock; }
        }

        //Event for data being sent.  This can be hooked to provide last-minute fuzzing or such.
        public delegate void DataSendDelegate(/*const*/ byte []inBytes, out byte []outBytes);
        public static event DataSendDelegate DataSendEvent;

        private delegate Response GetResponseDelegate(Boolean parseBody);

        /// <summary>
        /// Sends a request to the server.
        /// If we aren't connected, it will attempt to connect.
        /// </summary>
        public void SendRequest(Request r)
        {
            SendRequest(r.ToBytes());
        }
        public void SendRequest(string s)
        {
            SendRequest(ByteEncoding.Instance.GetBytes(s));
        }
        public void SendRequest(byte []blob)
        {
            Connect();

            byte []sendBlob=blob;
            if (DataSendEvent!=null) DataSendEvent(blob, out sendBlob);
            sock.Send(sendBlob);
            if (Verbose) CoreGlobal.RO.Debug("Sent request:\n"+ByteEncoding.Instance.GetString(sendBlob));
        }

        /// <summary>
        /// Receives and parses a single response from the server.  This call will block if required.
        /// If the request times out or not enough data to form a response comes back, returns null.
        /// </summary>
        /// <param name="parseBody">Whether a body should be parsed from the response.</param>
        public Response GetResponse()
        {
            return GetResponse(true);
        }

        public Response GetResponse(bool parseBody)
        {
            if (Verbose) CoreGlobal.RO.Debug("Starting http GetResponse()");
            //go until we either have a full response built, or stop getting packets
            while (sock.Poll(sock.ReceiveTimeout*1000, SelectMode.SelectRead))
            {
                //grab data
                if (sock.Available==0) break; //error?

                Response r = CheckForResponse(parseBody);

                if (r != null)
                {
                    return r;
                }
            }

            if (Verbose) CoreGlobal.RO.Debug("GetResponse() returning without a response");
            return null;
        }

        public IAsyncResult BeginGetResponse(AsyncCallback callback, Object state)
        {
            return BeginGetResponse(true, callback, state);
        }

        public IAsyncResult BeginGetResponse(Boolean parseBody, AsyncCallback callback, Object state)
        {
            GetResponseDelegate getResponse = new GetResponseDelegate(GetResponse);

            return getResponse.BeginInvoke(parseBody, callback, state);
        }

        public Response EndGetResponse(IAsyncResult ar)
        {
            System.Runtime.Remoting.Messaging.AsyncResult result = ar as System.Runtime.Remoting.Messaging.AsyncResult;
            var getResponse = result.AsyncDelegate as GetResponseDelegate;

            return getResponse.EndInvoke(result);
        }

        /// <summary>
        /// Checks a data blob to see if it contains a valid response.
        /// </summary>
        /// <param name="readBody">
        /// If true, read the body as specified by the Content-Length header; if false, do not.
        /// </param>
        /// <returns>The response if a valid one is found, or null if one is not.</returns>
        protected Response CheckForResponse (bool readBody)
        {
            Response r = new Response();
            byte[] extraBlob;

            lock (pendingBlob)
            {
                while (sock.Available > 0)
                {
                    byte[] blob = new byte[sock.Available];
                    sock.Receive(blob);
                    if (Verbose) CoreGlobal.RO.Debug("Got a packet of size " + blob.Length);
                    
                    pendingBlob.AddRange(blob);
                }

                if (r.FromBlob(pendingBlob.ToArray(), readBody, out extraBlob))
                {
                    pendingBlob.Clear();
                    if (extraBlob != null) pendingBlob.AddRange(extraBlob);

                    return r;
                }
            }

            return null;
        }

        /// <summary>
        /// Connect the socket to the remote server if it is not.
        /// </summary>
        public void Connect()
        {
            // shouldn't matter as an unconnected socket can't really touch pendingBlob
            lock (pendingBlob)
            {
                if (!sock.Connected)
                {
                    sock.Connect(serverIP, serverPort);
                    pendingBlob.Clear();
                }
            }
        }

        #region Async

        #region Types

        /// <summary>
        /// Called when a response is received asynchronously.
        /// </summary>
        /// <param name="response">The response that was received, or null if timed out.</param>
        public delegate void AsyncResponseCallback (Response response);

        /// <summary>
        /// The state object passed between the async calls.
        /// </summary>
        protected class AsyncState
        {
            public const int ReceiveBufferSize = 1024;
            public const double DefaultMaxReceiveTimeInSecs = 5;

            public byte[] Request = null;
            public int BytesSent = 0;
            public bool DoSend = false;
            public bool DoReceive = false;
            public bool ReadBody = false;
            public AsyncResponseCallback ResponseCallback = null;
            public byte[] Blob = null;
            public DateTime ReceiveBegin;
            public double MaxReceiveTimeInSecs = DefaultMaxReceiveTimeInSecs;

            public AsyncState () { }
        }

        #endregion

        #region Public

        /// <summary>
        /// Sends a request asynchronously.
        /// </summary>
        /// <param name="request">The request to send.</param>
        public void SendRequestAsync (Request request)
        {
            SendRequestAsync(request.ToBytes());
        }

        /// <summary>
        /// Sends a request asynchronously.
        /// </summary>
        /// <param name="request">The request to send.</param>
        public void SendRequestAsync (byte[] request)
        {
            AsyncState state = new AsyncState();
            state.Request = request;
            state.DoSend = true;

            if (!Socket.Connected)
            {
                ConnectAsync(state);
            }
            else
            {
                SendAsync(state);
            }
        }

        /// <summary>
        /// Gets a response asynchrounously.
        /// </summary>
        /// <param name="readBody">If true, read the body of the response; if false, do not.</param>
        /// <param name="callback">Called when a response is received.</param>
        public void GetResponseAsync (bool readBody, AsyncResponseCallback callback)
        {
            AsyncState state = new AsyncState();
            state.ReadBody = readBody;
            state.ResponseCallback = callback;
            state.Blob = new byte[AsyncState.ReceiveBufferSize];

            ReceiveAsync(state);
        }

        /// <summary>
        /// Sends and receives asynchrounously.
        /// </summary>
        /// <param name="request">The request to send.</param>
        /// <param name="readBody">If true, read the body of the response; if false, do not.</param>
        /// <param name="callback">Called when a response is received.</param>
        public void SendReceiveAsync (Request request, bool readBody, AsyncResponseCallback callback)
        {
            SendReceiveAsync(request.ToBytes(), readBody, callback);
        }

        /// <summary>
        /// Sends and receives asynchrounously.
        /// </summary>
        /// <param name="request">The request to send.</param>
        /// <param name="readBody">If true, read the body of the response; if false, do not.</param>
        /// <param name="callback">Called when a response is received.</param>
        public void SendReceiveAsync (byte[] request, bool readBody, AsyncResponseCallback callback)
        {
            AsyncState state = new AsyncState();
            state.Request = request;
            state.DoSend = true;
            state.DoReceive = true;
            state.ReadBody = readBody;
            state.ResponseCallback = callback;
            state.Blob = new byte[AsyncState.ReceiveBufferSize];

            if (!Socket.Connected)
            {
                ConnectAsync(state);
            }
            else
            {
                SendAsync(state);
            }
        }

        #endregion

        #region Objects

        /// <summary>
        /// Used to keep any other threads from calling BeginConnect while we are waiting to connect.
        /// </summary>
        private System.Threading.AutoResetEvent _connect_sync = new System.Threading.AutoResetEvent(true);

        #endregion

        #region NonPublic

        /// <summary>
        /// Begins the connect.
        /// </summary>
        /// <param name="state">The state to use.</param>
        protected void ConnectAsync (AsyncState state)
        {
            _connect_sync.WaitOne();

            if (Socket.Connected)
            {
                if (!_connect_sync.Set())
                {
                    throw new HttpClientException("Failed to set the connection sync object.");
                }

                if (state.DoSend)
                {
                    SendAsync(state);
                }
            }
            else
            {
                Socket.BeginConnect(serverIP, serverPort, new AsyncCallback(ConnectAsyncComplete), state);
            }
        }

        /// <summary>
        /// Ends the connect.
        /// </summary>
        /// <param name="result">The result passed in.</param>
        protected void ConnectAsyncComplete (IAsyncResult result)
        {
            try
            {
                Socket.EndConnect(result);

                if (!Socket.Connected)
                {
                    CoreGlobal.RO.Warn("After EndConnect, we should be connected.");
                }

                AsyncState state = (AsyncState) result.AsyncState;

                if (state.DoSend)
                {
                    SendAsync(state);
                }
            }
            catch (Exception exc)
            {
                CoreGlobal.RO.Error(exc.ToString());
            }
            finally
            {
                // Release everyone, even if we aren't connected
                if (!_connect_sync.Set())
                {
                    CoreGlobal.RO.Fatal("Failed to set the connection sync object.  This HttpClient will probably never connect.");
                }
            }
        }

        /// <summary>
        /// Begins the send.
        /// </summary>
        /// <param name="state">The state to use.</param>
        protected void SendAsync (AsyncState state)
        {
            Socket.BeginSend(state.Request, 0, state.Request.Length, SocketFlags.None,
                new AsyncCallback(SendAsyncComplete), state);
        }

        /// <summary>
        /// Ends the send.
        /// </summary>
        /// <param name="result">The result passed in.</param>
        protected void SendAsyncComplete (IAsyncResult result)
        {
            AsyncState state = (AsyncState) result.AsyncState;

            // get the number of bytes sent
            int sent = Socket.EndSend(result);

            if (sent == 0)
            {
                CoreGlobal.RO.Warn("Attempt to send did not move any bytes, aborting send.");
            }

            state.BytesSent += sent;

            // if the total number of bytes sent is less than the buffer, call send again
            if (state.BytesSent < state.Request.Length)
            {
                Socket.BeginSend(state.Request, state.BytesSent, state.Request.Length - state.BytesSent,
                    SocketFlags.None, new AsyncCallback(SendAsyncComplete), state);
            }
            else if (state.DoReceive)
            {
                ReceiveAsync(state);
            }
        }

        /// <summary>
        /// Begins the receive.
        /// </summary>
        /// <param name="state">The state to use.</param>
        protected void ReceiveAsync (AsyncState state)
        {
            state.ReceiveBegin = DateTime.Now;
            Socket.BeginReceive(state.Blob, 0, state.Blob.Length, SocketFlags.None,
                new AsyncCallback(ReceiveAsyncComplete), state);
        }

        /// <summary>
        /// Ends the receive.
        /// </summary>
        /// <param name="result">The result passed in.</param>
        protected void ReceiveAsyncComplete (IAsyncResult result)
        {
            AsyncState state = (AsyncState) result.AsyncState;
            Response resp = null;

            try
            {
                lock (pendingBlob)
                {
                    int recv = Socket.EndReceive(result);

                    // we got a full buffer
                    if (recv == state.Blob.Length)
                    {
                        pendingBlob.AddRange(state.Blob);
                    }
                    else
                    {
                        // is this the best way?  seems like it might be
                        byte[] temp = new byte[recv];
                        Buffer.BlockCopy(state.Blob, 0, temp, 0, recv);
                        pendingBlob.AddRange(temp);
                    }
                }

                // this will read all available bytes (no blocking, just read those bytes that are here now)
                // and check for a valid response from what is on pendingBlob
                resp = CheckForResponse(state.ReadBody);
            }
            catch (Exception e)
            {
                resp = new Response();
                resp.Exception = e;
            }

            if (resp != null)
            {
                state.ResponseCallback(resp);
                return;
            }

            TimeSpan elapsed = DateTime.Now.Subtract(state.ReceiveBegin);

            if (elapsed.TotalSeconds > state.MaxReceiveTimeInSecs)
            {
                state.ResponseCallback(null);
                return;
            }

            Socket.BeginReceive(state.Blob, 0, state.Blob.Length, SocketFlags.None,
                new AsyncCallback(ReceiveAsyncComplete), state);
        }

        #endregion

        #endregion

        #region Internal

        //socket and server
        Socket sock = null;
        string serverHost;
        IPAddress serverIP;
        ushort serverPort;

        private static uint defaultSocketTimeout=70000; //default send/receive timeout of the socket


        //leftover tcp data
        List<byte> pendingBlob=new List<byte>();

        //real constructor
        private void Setup(string hostName, ushort hostPort)
        {
            if (hostName==null || hostName.Length==0)
            {
                throw new System.Exception("No hostname provided");
            }

            IPAddress []ipAdd=Dns.GetHostAddresses(hostName);
            if (ipAdd.Length<1) throw new System.Exception("Dns lookup failed for: "+hostName);
            if (ipAdd.Length>1) CoreGlobal.RO.Warn(hostName+" has "+ipAdd.Length+" different addresses.  We are only using: "+ipAdd[0].ToString());
            serverIP=ipAdd[0];
            serverHost=hostName;

            serverPort=hostPort;

            sock.ReceiveTimeout=(int)defaultSocketTimeout;
            sock.SendTimeout=(int)defaultSocketTimeout;
            sock.ReceiveBufferSize=32*1024;
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\IOCPSocket.cs ===
using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace ServerTestFramework.Utilities
{
	/// <summary>
	/// Summary description for IOCP.
	/// </summary>
	public sealed class IOCPSocket
	{
		public Socket Socket = null;
        private static BooleanSwitch ShowDebugSpew = new BooleanSwitch("IOCPSocket_ShowDebugSpew", "Show IOCPSocket debug spew");

		public IOCPSocket()
		{
			Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
			DbgW("IOCPSocket instance created");
		}

		public IOCPSocket(Socket socket)
		{
			Socket = socket;
			DbgW("IOCPSocket instance created");
		}

		private void DbgW(string output)
		{
            if (ShowDebugSpew.Enabled)
            {
                System.Diagnostics.Debug.WriteLine("IOCPS[Inst:" + this.GetHashCode().ToString().PadLeft(4, '0') + 
                    "; TID: " + Thread.CurrentThread.ManagedThreadId.ToString().PadLeft(4, '0') +
                    "; Sock: " + Socket.GetHashCode().ToString().PadLeft(4, '0') +
                    "]: " + output);
            }
		}

		//
		// BIND & LISTEN
		//
		public void Bind(EndPoint localEP)
		{
			Socket.Bind(localEP);
		}

		public void Listen(int backlog)
		{
			Socket.Listen(backlog);
		}

		//
		// CONNECT
		//
		public delegate void ConnectHandler(object extraContext);
		private ConnectHandler OnConnect = null;

		public void Connect(EndPoint remoteEp, ConnectHandler onConnect, object extraContext)
		{
			OnConnect = onConnect;
			Socket.BeginConnect(remoteEp, new AsyncCallback(ConnectCallback), extraContext);
		}

		private void ConnectCallback(IAsyncResult ar)
		{
			DbgW("Entered ConnectCallback()");
			try
			{
				object extraContext = ar.AsyncState;
				try
				{
					DbgW("Calling EndConnect on socket " + Socket.GetHashCode());
					Socket.EndConnect(ar);
				}
				catch(ObjectDisposedException)
				{
					// We're shutting down
				}
				DbgW("Calling OnConnect");
				OnConnect(extraContext);
			}
			finally
			{
				DbgW("Exiting ConnectCallback()");
			}
		}


		//
		// ACCEPT
		//
		public delegate void AcceptHandler(IOCPSocket acceptedSocket, object extraContext);
		private AcceptHandler OnAccept = null;

		public void Accept(AcceptHandler onAccept, object extraContext)
		{
			DbgW("Entered Accept; storing OnAccept delagate reference " + onAccept.GetHashCode());
			OnAccept = onAccept;
			DbgW("Calling BeginAccept on socket " + Socket.GetHashCode());
			Socket.BeginAccept(new AsyncCallback(AcceptCallback), extraContext);
			DbgW("Exiting Accept");
		}

		private void AcceptCallback(IAsyncResult ar)
		{
			DbgW("Entered AcceptCallback()");
			try
			{
				object extraContext = ar.AsyncState;
				IOCPSocket newSocket = null;
				try
				{
					DbgW("Calling EndAccept on socket " + Socket.GetHashCode());
					newSocket = new IOCPSocket(Socket.EndAccept(ar));
					DbgW("Got new IOCPSocket instance " + newSocket.GetHashCode() + " using socket " + newSocket.Socket.GetHashCode());
				}
				catch(ObjectDisposedException)
				{
					// We're shutting down
				}
				if (newSocket != null)
				{
					DbgW("Calling OnAccept with socket " + newSocket.Socket.GetHashCode());
					OnAccept(newSocket, extraContext);
				}
			}
			finally
			{
				DbgW("Exiting AcceptCallback()");
			}
		}


		//
		// SEND
		//
		public delegate void SendHandler(IOCPSocket iocpSocket, int sentSize, object extraContext);
		private SendHandler OnSend = null;

		public void Send(byte[] SendBuffer, SendHandler onSend, object extraContext)
		{
			DbgW("Entered Send; storing OnSend delagate reference " + onSend.GetHashCode());
			OnSend = onSend;
			DbgW("Calling BeginSend on socket " + Socket.GetHashCode());
            Socket.BeginSend(SendBuffer, 0, SendBuffer.Length, 0, new AsyncCallback(SendCallback), extraContext);
			DbgW("Exiting Send");
		}

		private void SendCallback(IAsyncResult ar)
		{
			DbgW("Entered SendCallback()");
			try
			{
				object extraContext = ar.AsyncState;
				DbgW("Calling EndSend on socket " + Socket.GetHashCode());
				int sentSize = Socket.EndSend(ar);
				OnSend(this, sentSize, extraContext);
			}
			finally
			{
				DbgW("Exiting SendCallback()");
			}
		}


		//
		// RECEIVE
		//
		public delegate void ReceiveHandler(IOCPSocket socket, ReceiveContext recvContext, object extraContext);
		private ReceiveHandler OnReceive = null;

		public class ReceiveContext
		{
			private int InitialSize = 4096;
			public byte[] Buffer = null;
			public int Offset = 0;
			public int LastRead = 0;

			public ReceiveContext()
			{
				Buffer = new byte[InitialSize];
			}

			public ReceiveContext(int initialBufSize)
			{
				InitialSize = initialBufSize;
				Buffer = new byte[InitialSize];
			}

			public void GrowBuffer(uint sizeIncrease)
			{
				byte[] tempBuffer = new byte[Buffer.Length + sizeIncrease];
				Buffer.CopyTo(tempBuffer, 0);
				Buffer = tempBuffer;
			}
		}
		private ReceiveContext recvContext = null;

		public void Receive(ReceiveContext recvBuffer, ReceiveHandler onReceive, object extraContext)
		{
			DbgW("Entered Receive; storing OnReceive delagate reference " + onReceive.GetHashCode());
			OnReceive = onReceive;
			recvContext = recvBuffer;
			DbgW("Calling BeginReceive on socket " + Socket.GetHashCode());
            try
            {
                Socket.BeginReceive(recvContext.Buffer, recvContext.Offset, recvContext.Buffer.Length - recvContext.Offset, 0, new AsyncCallback(ReceiveCallback), extraContext);
            }
            catch (System.Net.Sockets.SocketException sockEx)
            {
                CoreGlobal.RO.Error("IOCPSocket::Receive: BeginReceive threw exception: (" + sockEx.ErrorCode + ") " + sockEx.Message);
                CoreGlobal.RO.Warn("IOCPSocket::Receive: Closing socket.");
                CleanDisconnect();
            }
			DbgW("Exiting Receive");
		}

		private void ReceiveCallback(IAsyncResult ar)
		{
			DbgW("Entered ReceiveCallback()");

			try
			{
				object extraContext = ar.AsyncState;
				int read = 0;
				try
				{
					DbgW("Calling EndReceive on socket " + Socket.GetHashCode());
					read = Socket.EndReceive(ar);
					recvContext.LastRead = read;
					recvContext.Offset += recvContext.LastRead;
				}
				catch(SocketException e)
				{
					if (e.ErrorCode == 10054)	// An existing connection was forcibly closed by the remote host
					{
						// Server closed this socket, cleanup and bail
						CleanDisconnect();
						return;
					}
					else
					{
						Console.WriteLine("ReceiveCallback: EndReceive() threw exception (" + e.ErrorCode.ToString() + "):\n" + e.ToString());
						throw;
					}
				}
				DbgW("Calling OnReceive delagate reference " + OnReceive.GetHashCode() + " with socket " + Socket.GetHashCode());
				OnReceive(this, recvContext, extraContext);
			}
			finally
			{
				DbgW("Exiting ReceiveCallback()");
			}
		}

		//
		// SHUTDOWN & CLOSE
		//
		public void Shutdown(SocketShutdown how)
		{
			if (Socket != null)
			{
				if (Socket.Connected == true)
				{
					Socket.Shutdown(how);
				}
			}		
		}

        public void Close()
		{
			if (Socket != null)
			{
				Socket.Close();
				if (Socket.Connected) 
				{
					// Not thread-safe, best-effort basis only
					CoreGlobal.RO.Error("IOCPSocket::Close: Winsock error: " + 
                        Convert.ToString(System.Runtime.InteropServices.Marshal.GetLastWin32Error()));
				}
			}
		}

		public void CleanDisconnect()
		{
			Shutdown(SocketShutdown.Both);
			Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\ListEx.cs ===
using System;
using System.Collections.Generic;

namespace ServerTestFramework
{
// Removing this until all conflicts can be resolved
/*
    public static class ListEx
    {
        public static List<T> NewList<T>(params T[] values)
        {
            List<T> list = new List<T>();
            foreach (T value in values)
            {
                list.Add(value);
            }
            return list;
        }
    }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\LocalInterface.cs ===
using System;
using System.Net;
using System.Net.Sockets;

namespace ServerTestFramework.Utilities
{
	/// <summary>
	/// Helper methods for LocalInterface.
	/// </summary>
	public class LocalInterface
	{
		/// <summary>
		/// This is where we attempt to divine which of our IPs (many clients are multihomed) the server will attempt to communicate with us on.
		/// </summary>
		/// <param name="localIp"></param>
		/// <returns></returns>
		public static bool GetBestMatch(IPEndPoint ep, out IPAddress localIp)
		{
			localIp=null;
			IPHostEntry iphe= Dns.GetHostEntry(Dns.GetHostName());
            ServerTestFramework.CoreGlobal.RO.Info("Found " + iphe.AddressList.Length + " IP host entries for hostname \"" + iphe.HostName + "\"");

			//Try to match on class c
			for (int i=0;i<iphe.AddressList.GetLength(0);i++)
			{
				localIp = iphe.AddressList[i];
				if ((ep.Address.GetAddressBytes()[0]==localIp.GetAddressBytes()[0])&&
					(ep.Address.GetAddressBytes()[1]==localIp.GetAddressBytes()[1])&&
					(ep.Address.GetAddressBytes()[2]==localIp.GetAddressBytes()[2]))
				{
					return true;
				}	
			}

			//Try to match on class B
			for (int i=0;i<iphe.AddressList.GetLength(0);i++)
			{
				localIp = iphe.AddressList[i];
				if ((ep.Address.GetAddressBytes()[0]==localIp.GetAddressBytes()[0])&&
					(ep.Address.GetAddressBytes()[1]==localIp.GetAddressBytes()[1]))
				{
					return true;
				}	
			}

			//Try to match on class A
			for (int i=0;i<iphe.AddressList.GetLength(0);i++)
			{
				localIp = iphe.AddressList[i];
				if ((ep.Address.GetAddressBytes()[0]==localIp.GetAddressBytes()[0]))
				{
					return true;
				}	
			}

			//Not even a class A match; Fail
			localIp=null;
			return false;
		}

        public static IPAddress EndPointToIPAddress(EndPoint endpoint)
        {
            string ip = endpoint.ToString().Split(':')[0];
            string[] strQuads = ip.Split('.');
            byte[] quads = new byte[4];
            int i = 0;

            foreach (string quad in strQuads)
            {
                quads[i++] = byte.Parse(quad);
            }

            return new IPAddress(quads);
        }

        /// <summary>
        /// This is where we attempt to divine which of our IPs (many clients are multihomed) the server will attempt to communicate with us on.
        /// </summary>
        /// <param name="localIp"></param>
        /// <returns></returns>
        public static bool GetBestMatchByConnecting(IPEndPoint ep, out IPAddress localIp)
        {
            localIp = null;

            try
            {
                Socket socket = new Socket(AddressFamily.InterNetwork,
                    SocketType.Stream, ProtocolType.Tcp);
                socket.Connect(ep);
                if (socket.Connected)
                {
                    localIp = EndPointToIPAddress(socket.LocalEndPoint);
                    return true;
                }
            }
            catch
            {
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\mmf.cs ===
using System;
using System.Runtime.InteropServices;

namespace MemoryMappedFile
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    unsafe public class MMF
    {
        #region Constants
        protected class Constants
        {
            public static void * INVALID_HANDLE_VALUE = (void *) -1;
            public const uint SDDL_REVISION_1     = 1;

            public const uint LMEM_FIXED          = 0x0000;
            public const uint LMEM_MOVEABLE       = 0x0002;
            public const uint LMEM_NOCOMPACT      = 0x0010;
            public const uint LMEM_NODISCARD      = 0x0020;
            public const uint LMEM_ZEROINIT       = 0x0040;
            public const uint LMEM_MODIFY         = 0x0080;
            public const uint LMEM_DISCARDABLE    = 0x0F00;
            public const uint LMEM_VALID_FLAGS    = 0x0F72;
            public const uint LMEM_INVALID_HANDLE = 0x8000;
            public const uint LHND                = (LMEM_MOVEABLE | LMEM_ZEROINIT);
            public const uint LPTR                = (LMEM_FIXED | LMEM_ZEROINIT);

            public const uint NONZEROLHND         = (LMEM_MOVEABLE);
            public const uint NONZEROLPTR         = (LMEM_FIXED);


            public const uint PAGE_READWRITE      = 0x04;
        
            public const uint DELETE                           = 0x00010000;
            public const uint READ_CONTROL                     = 0x00020000;
            public const uint WRITE_DAC                        = 0x00040000;
            public const uint WRITE_OWNER                      = 0x00080000;
            public const uint SYNCHRONIZE                      = 0x00100000;

            public const uint STANDARD_RIGHTS_REQUIRED         = 0x000F0000;
            public const uint SECTION_QUERY       = 0x0001;
            public const uint SECTION_MAP_WRITE   = 0x0002;
            public const uint SECTION_MAP_READ    = 0x0004;
            public const uint SECTION_MAP_EXECUTE = 0x0008;
            public const uint SECTION_EXTEND_SIZE = 0x0010;
            public const uint SECTION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|
                SECTION_MAP_WRITE |      
                SECTION_MAP_READ |       
                SECTION_MAP_EXECUTE |    
                SECTION_EXTEND_SIZE);
            public const uint FILE_MAP_ALL_ACCESS = SECTION_ALL_ACCESS;
        };
        #endregion

        #region Imported System APIs
        [StructLayout(LayoutKind.Sequential)]
        private struct SECURITY_ATTRIBUTES
        {
            public uint nLength;  
            public IntPtr lpSecurityDescriptor;  
            public bool bInheritHandle;
        };

        [DllImport("kernel32.dll", EntryPoint="MapViewOfFile", SetLastError=true)]
        private static extern byte* MapViewOfFile(void* hFileMappingObject,
            uint dwDesiredAccess,
            uint dwFileOffsetHigh,
            uint dwFileOffsetLow,
            uint dwNumberOfBytesToMap);

        [DllImport("advapi32.dll", EntryPoint="ConvertStringSecurityDescriptorToSecurityDescriptorW", SetLastError=true, CharSet=CharSet.Unicode)]
        private static extern bool MakeSecurityDescriptor(string StringSecurityDescriptor,
            uint StringSDRevision,
            out IntPtr lpSecurityDescriptor,
            uint *SecurityDescriptorSize
            );

        [DllImport("kernel32.dll", EntryPoint="UnmapViewOfFile", SetLastError=true)]
        private static extern bool UnmapViewOfFile(void* lpBaseAddress);

        [DllImport("kernel32.dll", EntryPoint="CloseHandle", SetLastError=true)]
        private static extern uint CloseHandle(void* handle);

        [DllImport("kernel32.dll", EntryPoint="LocalFree", SetLastError=true)]
        private static extern void* LocalFree(void* handle);

        [DllImport("kernel32.dll", EntryPoint="LocalAlloc", SetLastError=true)]
        private static extern void* LocalAlloc(uint uFlags, uint uBytes);

        [DllImport("kernel32.dll", EntryPoint="CreateFileMappingW", SetLastError=true, CharSet=CharSet.Unicode)]
        private static extern void* CreateFileMapping(void* hFile, 
            IntPtr lpAttributes,
            uint flProtect,
            uint dwMaximumSizeHigh,
            uint dwMaximumSizeLow,
            string name);

        [DllImport("kernel32.dll", EntryPoint="OpenFileMapping", SetLastError=true, CharSet=CharSet.Unicode)]
        private static extern void* OpenFileMapping(uint dwDesiredAccess, bool bInheritHandle, string name);
        #endregion

        const string Name = "Global\\FakeSG1";
        byte	*data;
        uint    addr;
        void	*hMapFile;
        uint    _Size;
        SECURITY_ATTRIBUTES *pSA;

        string firstCallCallstack = null;

        public MMF()
        {
            addr = 0;
            data = null;
            _Size = 0;
            pSA = (SECURITY_ATTRIBUTES *) LocalAlloc(Constants.LPTR, (uint) sizeof(SECURITY_ATTRIBUTES));
            pSA->bInheritHandle = false;
            pSA->lpSecurityDescriptor = IntPtr.Zero;
            pSA->nLength = 0;
        }

        // [lifted from ms-help://MS.VSCC.2003/MS.MSDNQTR.2003FEB.1033/security/security/creating_a_dacl.htm]
        // CreateMyDACL.
        //    Create a security descriptor that contains the DACL you want.
        //    This function uses SDDL to make Deny and Allow ACEs.
        //
        // Parameter:
        //    SECURITY_ATTRIBUTES * pSA
        //    Pointer to a SECURITY_ATTRIBUTES structure. It is the caller's
        //    responsibility to properly initialize the structure and to free 
        //    the structure's lpSecurityDescriptor member when the caller has
        //    finished using it. To free the structure's lpSecurityDescriptor 
        //    member, call the LocalFree function.
        // 
        // Return value:
        //    FALSE if the address to the structure is NULL. 
        //    Otherwise, this function returns the value from the
        //    ConvertStringSecurityDescriptorToSecurityDescriptor function.
        void CreateMyDACL()
        {
            // Define the SDDL for the DACL. This example sets 
            // the following access:
            //     Built-in guests are denied all access.
            //     Anonymous logon is denied all access.
            //     Authenticated users are allowed read/write/execute access.
            //     Administrators are allowed full control.
            // Modify these values as needed to generate the proper
            // DACL for your application. 
            /*
            System.Security.Principal.WindowsIdentity wi = System.Security.Principal.WindowsIdentity.GetCurrent();
            if(wi != null)
                throw new Exception(wi.Name + " " + wi.IsAnonymous + " " + wi.IsAuthenticated + " " + wi.IsGuest + " " + wi.IsSystem);
            */
            string szSD = "D:AR" +       // Discretionary ACL with auto inherit req
               // "(D;OICI;GA;;;BG)" +     // Deny access to built-in guests
                //TEXT("(D;OICI;GA;;;AN)")     // Deny access to anonymous logon
                //"(A;OICI;GRGWGX;;;AU)" +  // Allow read/write/execute to authenticated users
                //"(A;OICI;GA;;;BA)" +    // Allow full control to administrators
                //"(A;OICI;GA;;;SU)" +    // Allow full control to service logon users
                "(A;OICI;GA;;;WD)" +    // Allow full control to everyone
                "(A;OICI;GA;;;SY)";    // Allow full control to local system 

            if (!MakeSecurityDescriptor(
                szSD,
                Constants.SDDL_REVISION_1,
                out pSA->lpSecurityDescriptor,
                null))
                throw ExceptLastError(string.Format("ConvertStringSecurityDescriptorToSecurityDescriptor failed.\nSDDL:\n{0}\n", szSD));
        }

        Exception ExceptLastError(string message)
        {
            return new Exception(string.Format("{0}  Last error was: {1}", message, Convert.ToString(System.Runtime.InteropServices.Marshal.GetLastWin32Error())));
        }


        public void Create(uint size)
        {
            if(hMapFile == null)
            {
                firstCallCallstack=new System.Diagnostics.StackFrame().ToString();

                _Size=size;

                pSA->nLength = (uint) sizeof(SECURITY_ATTRIBUTES);
                pSA->bInheritHandle = false;  

                CreateMyDACL();
                IntPtr p = (IntPtr) pSA;
                if ((hMapFile = CreateFileMapping(Constants.INVALID_HANDLE_VALUE, p, Constants.PAGE_READWRITE, 0, _Size, Name)) == null)
                    throw ExceptLastError("Could not create file mapping object.");

                Map();
            }
            else
            {
                try
                {
                    throw new Exception("Second caller callstack.");
                }
                catch(Exception e)
                {
                    string s = "An additional call to MMF.Create occurred:\n" + firstCallCallstack + "\n-\n" + e.Message + "\n"+ e.StackTrace;
                    System.Diagnostics.EventLog evt = new System.Diagnostics.EventLog("Application", ".", "MMF");
                    evt.WriteEntry(s, System.Diagnostics.EventLogEntryType.Warning);
                }

            }
        }

        void Map()
        {
            if ((data = MapViewOfFile(hMapFile, Constants.FILE_MAP_ALL_ACCESS, 0, 0, 0)) == null)
            {
                CloseHandle(hMapFile);
                hMapFile = null;
                Close();

                throw ExceptLastError("Failed to map a view of the file.");
            }
            addr = (uint) data;
        }

        public uint Size
        {
            get{return _Size;}
        }

        public byte *GetData()
        {
            return data;
        }

        public bool DoesFileExist()
        {
            hMapFile = OpenFileMapping(Constants.PAGE_READWRITE, false, Name);

            if (hMapFile == null) 
            { 
                return false;
            }
            CloseHandle(hMapFile);
            hMapFile = null;
            return true;
        }

        public void Close()
        {
            if(pSA != null)
            {
                if (pSA->lpSecurityDescriptor != IntPtr.Zero)
                {
                    // Free the memory allocated for the SECURITY_DESCRIPTOR.
                    LocalFree((void *) pSA->lpSecurityDescriptor);
                }
                LocalFree(pSA);
				pSA = null;
            }

            if (hMapFile != null)
            {
                bool res = UnmapViewOfFile(data);
                if(!res)
                    throw ExceptLastError("UnmapViewOfFile failed!!!!");
                CloseHandle(hMapFile);
                hMapFile = null;
            }
        }

        ~MMF()
        {
            Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\IpHelper.cs ===
using System;
using System.Net;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;

namespace ServerTestFramework.Utilities
{
    public static class IpHelper
    {
        [DllImport("iphlpapi.dll")]
        private static extern UInt32 GetBestInterface (UInt32 dwDestAddr, out UInt32 pdwBestIfIndex);

        /// <summary>
        /// Determines the interface out which packets will be routed, given a destination address.
        /// </summary>
        /// <param name="destAddr">The destination address to route.</param>
        /// <returns>The IPAddress of the interface chosen as the routing target.</returns>
        public static IPAddress GetBestInterface (IPAddress destAddr)
        {
            // make a uint from bytes
            UInt32 saddr = BitConverter.ToUInt32(destAddr.GetAddressBytes(), 0);
            UInt32 index;

            UInt32 result = GetBestInterface(saddr, out index);

            if (result != 0)
            {
                throw new IpHelperException("GetBestInterface returned unexpected result: " + result);
            }

            // we are going to shortcut iphlpapi.dll here and grab this .net stuff (hopefully its the same)
            NetworkInterface[] interfaces = NetworkInterface.GetAllNetworkInterfaces();

            for (int i = 0; i < interfaces.Length; ++i)
            {
                NetworkInterface ni = interfaces[i];
                IPInterfaceProperties ipip = ni.GetIPProperties();
                IPv4InterfaceProperties ipv4ip = ipip.GetIPv4Properties();

                if (ipv4ip != null && ipv4ip.Index == index)
                {
                    foreach (UnicastIPAddressInformation uipai in ipip.UnicastAddresses)
                    {
                        if (uipai.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                        {
                            return uipai.Address;
                        }
                    }
                }
            }

            return null;
        }
    }

    /// <summary>
    /// An exception that is thrown by the IpHelper class.
    /// </summary>
    public class IpHelperException : Exception
    {
        public IpHelperException (string message) : base(message) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\MemoryReportDestination.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using ServerTestFramework;
using ReportLine = ServerTestFramework.Report.ReportLine;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Used to just keep track of loglines in memory, on a List of ReportLine objects.
    /// </summary>
    public class MemoryReportDestination : InfiniteLifetimeMarshalByRefObject, Report.BulkDestination
    {
        public List<ReportLine> _LogLines = new List<ReportLine>();

        public List<ReportLine> LogLines
        {
            get
            {
                lock (_LogLines)
                {
                    return new List<ReportLine>(_LogLines.ToArray());
                }
            }
        }

        public void ClearLogLines()
        {
            lock (_LogLines)
            {
                _LogLines.Clear();
            }
        }

        public MemoryReportDestination()
        {
        }

        ~MemoryReportDestination()
        {
            ClearLogLines();
        }

        // Implemented from Report.Destination
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            lock (_LogLines)
            {
                _LogLines.Add(new ReportLine(level, path, message, testName, date));
            }
        }

        // Implemented from Report.BulkDestination
        public void LogBulk(LinkedList<ReportLine> lines)
        {
            lock (_LogLines)
            {
                _LogLines.AddRange(lines);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\PuidPool.cs ===
using System;

namespace ServerTestFramework.Utilities
{
	/// <summary>
	/// A static accessor class for the service defined pre-allocated puid pools.
	/// </summary>
	public class PuidPool
	{
		/// <summary>
		/// Define your own puid pool enum here if you want to allocate a specific
		/// type of puid.
		/// </summary>
		public enum Type
		{ 
			Public, // calculated automatically
			Comps,
			TotalPools
		};

		static private ulong	[]puidPoolOffsets = new ulong[(int)Type.TotalPools];
		static private ulong	[]puidPoolLengths = new ulong[(int)Type.TotalPools]; 
		static private uint		[]puidPoolAllocPnts = new uint[(int)Type.TotalPools];
		static private bool		initialized = false;


		public static ulong NextPuid(Type type)
		{
			ulong puid = 0;

			lock(puidPoolOffsets)
			{
				if(!initialized)
				{
					//
					// Add your privately allcoated PUID pool here.
					//
					puidPoolOffsets[(int)Type.Comps] = 0x0009FFFFFFFFFC00;
					puidPoolLengths[(int)Type.Comps] = 1023;
				
					//
					// Public puid allocations start here
					puidPoolOffsets[(int)Type.Public] = 0x9500000000000;

					// Find highest number we can generate for regular puid 
					// randomizing
					puidPoolLengths[0] = 0xffffffffffffffff - puidPoolOffsets[0];

					for(int i = 1; i < (int)Type.TotalPools; ++i)
					{
						if(puidPoolOffsets[i] - puidPoolOffsets[0] < puidPoolLengths[0])
							puidPoolLengths[0] = puidPoolOffsets[i] - puidPoolOffsets[0];

						puidPoolAllocPnts[i] = 0;
					}

					initialized = true;
				}

				// 
				// Provide the next puid available in the pool and cycle back to beginning
				// when we run out
				puid = puidPoolOffsets[(int)type] + puidPoolAllocPnts[(int)type]++;
				if(puidPoolAllocPnts[(int)type] >= puidPoolLengths[(int)type]) 
					puidPoolAllocPnts[(int)type] = 0;

			}
			return puid;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\ProcessWrapper.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Threading;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Provides a way to run a process and capture it's output.
    /// </summary>
    public class ProcessWrapper
    {
        public static Report ro = new Report("ProcessWrapper");
        public bool Verbose = false;
        public bool EchoOutput=false;

        protected string _processName;
        protected string _exePath;
        protected string _workingDirectory;
        protected int _executeTimeout;
        protected string _output;
        protected string _error;
        protected Dictionary<string, string> _environmentVariables;

        public ProcessWrapper()
        {
            _processName = "";
            _exePath = "";
            _workingDirectory = "";
            _executeTimeout = 120;
            _output = "";
            _environmentVariables = null;
        }

        public ProcessWrapper(string name, string path) : this()
        {
            _processName = name;
            _exePath = path;
        }

        public ProcessWrapper(string name, string path, string workingDir, int timeout)
        {
            _processName = name;
            _exePath = path;
            _workingDirectory = workingDir;
            _executeTimeout = timeout;
            _output = "";
        }

        /// <summary>
        /// Gets or sets the friendly name of the process.
        /// </summary>
        public string ProcessName
        {
            get { return _processName; }
            set { _processName = value; }
        }

        /// <summary>
        /// Gets or sets the fully-qualified path to the process executable.
        /// </summary>
        public string ExecutablePath
        {
            get { return _exePath; }
            set { _exePath = value; }
        }

        /// <summary>
        /// Gets or sets the name of the working directory.
        /// </summary>
        public string WorkingDirectory
        {
            get { return _workingDirectory; }
            set { _workingDirectory = value; }
        }

        /// <summary>
        /// Gets or sets the number of seconds to allow the process to run before abandoning it. Default is 120.
        /// </summary>
        public int ExecutionTimeout
        {
            get { return _executeTimeout; }
            set { _executeTimeout = value; }
        }

        /// <summary>
        /// Gets the text written by the running process to the Standard Output stream.
        /// </summary>
        public string Output
        {
            get { return _output; }
        }

        /// <summary>
        /// Gets the text written by the running process to the Standard Error stream.
        /// </summary>
        public string Error
        {
            get { return _error; }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append( "ProcessName      = " + _processName + "\r\n" );
            sb.Append( "ExePath          = " + _exePath + "\r\n" );
            sb.Append( "WorkingDirectory = " + _workingDirectory + "\r\n" );
            sb.Append( "ExecuteTimeout   = " + _executeTimeout + "\r\n" );
            return sb.ToString();
        }

        public void SetEnvironmentVariable(string variableName, string value)
        {
            if (variableName == null)
            {
                throw new ArgumentNullException("variableName");
            }

            if (variableName.Length > 0)
            {
                if (_environmentVariables == null)
                {
                    _environmentVariables = new Dictionary<string, string>();
                }

                if (_environmentVariables.ContainsKey(variableName))
                {
                    // Replace the existing value of the environment variable
                    // Zero-length values will cause the variable to be removed later
                    if (value == null)
                    {
                        value = "";
                    }
                    _environmentVariables[variableName] = value;
                }
                else
                {
                    // null or zero-length values are invalid
                    if (value == null || value.Length == 0)
                    {
                        throw new ArgumentException("Cannot set a blank environment variable value.");
                    }
                    _environmentVariables.Add(variableName, value);
                }
            }
        }

        /// <summary>
        /// Method to run the process with the specified arguments.
        /// </summary>
        /// <param name="arguments">The command line arguments to send to the process.</param>
        /// <returns>The return code from the process.</returns>
        /// <remarks>
        /// The following exceptions can be thrown by this method:
        ///        ArgumentNullException        If the arguments string is null.
        ///        ProcessException            If the timeout expired waiting for the process to finish.
        ///        
        /// These exceptions can be thrown from the Process.Start method:
        ///        InvalidOperationException
        ///        Win32Exception
        ///        ObjectDisposedException
        /// </remarks>
        public int Run(string arguments)
        {
            if (arguments == null)
                throw new ArgumentNullException("arguments");

            Process process = new Process();
            ProcessOutputReader por = new ProcessOutputReader(process, false);
            ProcessOutputReader per = new ProcessOutputReader(process, true);
            por.Verbose=Verbose;
            per.Verbose=Verbose;
            por.EchoOutput=EchoOutput;
            per.EchoOutput=EchoOutput;
            Thread readThreadOut = ThreadMaker.CreateThread(por.ReadOutput);
            Thread readThreadErr = ThreadMaker.CreateThread(per.ReadOutput);
            bool processTimedOut = false;

            ro.Debug("Executing {0} {1}", _exePath, arguments);

            process.StartInfo.FileName = _exePath;
            process.StartInfo.WorkingDirectory = _workingDirectory;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.Arguments = arguments.Trim();
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.CreateNoWindow = true;

            // Set any defined environment variables
            if (_environmentVariables != null)
            {
                foreach (KeyValuePair<string, string> kvp in _environmentVariables)
                {
                    if (process.StartInfo.EnvironmentVariables.ContainsKey(kvp.Key))
                    {
                        // Replace the existing value. If the value is
                        // zero-length, remove the variable from the list
                        if (kvp.Value.Length > 0)
                        {
                            process.StartInfo.EnvironmentVariables[kvp.Key] = kvp.Value;
                        }
                        else
                        {
                            process.StartInfo.EnvironmentVariables.Remove(kvp.Key);
                        }
                    }
                    else
                    {
                        // Don't bother setting blank variables
                        if (kvp.Value.Length > 0)
                        {
                            process.StartInfo.EnvironmentVariables.Add(kvp.Key, kvp.Value);
                        }
                    }
                }
            }

            try
            {
                process.Start();

                // Start the read output thread
                if (Verbose)
                    ro.Debug("Beginning output read threads");
                readThreadOut.Start();
                readThreadErr.Start();

                // Wait for the process to end or the timeout to expire
                processTimedOut = !process.WaitForExit(_executeTimeout * 1000);
                if (Verbose)
                    ro.Debug("WaitForExit returned {0}", !processTimedOut);
            }
            catch (ThreadAbortException) //if we're going down, take our spawned process out too
            {
                ro.Debug("Killing wrapped process.");
                process.Kill();
            }
            finally
            {
                // Wait for all the _output to be read
                if (readThreadOut.Join(10000))
                {
                    if (Verbose)
                        ro.Debug("Read output thread exited normally.");
                }
                else
                {
                    if (Verbose)
                        ro.Debug("The read output thread did not exit within 10 seconds of process termination.");
                }

                if (readThreadErr.Join(10000))
                {
                    if (Verbose)
                        ro.Debug("Read error thread exited normally.");
                }
                else
                {
                    if (Verbose)
                        ro.Debug("The read error thread did not exit within 10 seconds of process termination.");
                }

                _output = por.Output;
                _error = per.Output;
            }

            if (processTimedOut)
                throw new ProcessException(_processName, "Timeout waiting for the process to finish.", _output);

            return process.ExitCode;
        }
    }

    /// <summary>
    /// Thread procedure wrapper that allows data to be passed in and out of the procedure.
    /// Used to read process output.
    /// </summary>
    internal class ProcessOutputReader
    {
        public bool Verbose=false;
        public bool EchoOutput=false;

        private Process _runningProcess;
        private string _stdOut;

        private bool readStdErr;

        internal ProcessOutputReader(Process RunningProcess, bool useStdErrInsteadOfStdOut)
        {
            if (RunningProcess == null)
            {
                throw new ArgumentNullException("RunningProcess");
            }

            _runningProcess = RunningProcess;
            _stdOut = String.Empty;
            readStdErr=useStdErrInsteadOfStdOut;
        }

        internal string Output
        {
            get { return _stdOut; }
        }

        internal void ReadOutput()
        {
            if (Verbose)
                ProcessWrapper.ro.Debug("Starting ReadOutput thread");

            // Sit in a loop reading the Standard Output buffer until
            // the process has been marked terminated and the buffer is empty.
            int bufferLength = 4096;
            int outputCharsRead = 0;
            char [] buffer = new char[bufferLength];
            StringBuilder outputData = new StringBuilder(bufferLength);
            StringBuilder echoBuffer = new StringBuilder(bufferLength);
            do
            {
                if (!readStdErr)
                {
                    outputCharsRead = _runningProcess.StandardOutput.Read(buffer, 0, bufferLength);
                }
                else
                {
                    outputCharsRead = _runningProcess.StandardError.Read(buffer, 0, bufferLength);
                }

                if (outputCharsRead > 0)
                {
                    outputData.Append(buffer, 0, outputCharsRead);

                    if (EchoOutput)
                    {
                        echoBuffer.Append(buffer, 0, outputCharsRead);
                        OutputEchoBuffer(ref echoBuffer, false);
                    }
                }
            } while (!(outputCharsRead == 0 && _runningProcess.HasExited));

            if (EchoOutput)
            {
                OutputEchoBuffer(ref echoBuffer, true);
            }

            if (outputData.Length>0 || Verbose)
            {
                ProcessWrapper.ro.Debug((readStdErr?"Error":"Output")+" characters read: {0}", outputData.Length);
            }

            _stdOut = outputData.ToString();
        }

        internal void OutputEchoBuffer(ref StringBuilder echoBuffer, bool flushAll)
        {
            string inputString=echoBuffer.ToString();

            //lop off line-break deliminated parts
            int lastBreak=0;
            int nextBreak;
            while (true)
            {
                //find the end of the next chunk
                nextBreak=-1;
                if (lastBreak<inputString.Length)
                {
                    nextBreak=inputString.IndexOf('\n', lastBreak);

                    if (nextBreak==-1 && flushAll)
                    {
                        nextBreak=inputString.Length;
                    }
                    else if (nextBreak!=-1)
                    {
                        ++nextBreak; //skip the \n
                    }
                }

                if (nextBreak==-1 || nextBreak==lastBreak)
                {
                    break;
                }

                //spit out that chunk and remove it from the buffer
                int chunkStart=lastBreak;
                int chunkLen=nextBreak-lastBreak;
                echoBuffer.Remove(0,chunkLen);
                string chunk=inputString.Substring(chunkStart, chunkLen);
                chunk=chunk.Replace("\r","").Replace("\n","");

                ProcessWrapper.ro.Info(chunk);

                //
                lastBreak=nextBreak;
            }
        }
    }

    public class ProcessException : Exception
    {
        protected string _output = "";
        protected string name = "";

        public ProcessException(string _processName) : base()
        {
            name = _processName;
        }
        public ProcessException(string _processName, string message) : base(message)
        {
            name = _processName;
        }
        public ProcessException(string _processName, string message, Exception innerException) :
            base (message, innerException)
        {
            name = _processName;
        }
        public ProcessException(string _processName, string message, string processOutput) : base(message)
        {
            name = _processName;
            _output = processOutput;
        }
        public ProcessException(string _processName, string message, string processOutput, Exception innerException) :
            base (message, innerException)
        {
            name = _processName;
            _output = processOutput;
        }

        public string ProcessOutput
        {
            get { return _output; }
            set { _output = value; }
        }

        public string ProcessName
        {
            get { return name; }
            set { name = value; }
        }

        public override string Message
        {
            get
            {
                if (name.Length > 0)
                    return name + ": " + base.Message;
                else
                    return base.Message;
            }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder(base.ToString());
            if (!String.IsNullOrEmpty(ProcessName) && !String.IsNullOrEmpty(ProcessOutput))
            {
                sb.AppendLine("\nOutput from " + ProcessName + ":");
                sb.AppendLine(ProcessOutput);
            }
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\RandomEx.cs ===
using System;
using System.Threading;
using System.Text;

namespace ServerTestFramework.Core.Utilities
{
    /// <summary>
    /// Summary description for Random.
    /// </summary>
    unsafe public class RandomEx
    {
        //a convienant global instance to use
        static public RandomEx GlobalRandGen = new RandomEx(); 

        // System.Random is not thread-safe, so we'll offer a per-thread instance
        [ThreadStatic]
        static protected Random _randGen;
        protected Random randGen
        {
            get
            {
                // Do not specify initial values for fields marked with ThreadStaticAttribute,
                // because such initialization occurs only once, when the class constructor executes,
                // and therefore affects only one thread. If you do not specify an initial value, you can
                // rely on the field being initialized to its default value if it is a value type, or to
                // a null reference if it is a reference type.
                if (_randGen == null)
                {
                    _randGen = new Random(Interlocked.Increment(ref seed));
                }
                return _randGen;
            }
        }

        static private int        seed=0;
        static private int        initialSeed=0;

        static RandomEx()
        {
            initialSeed = (int)DateTime.Now.Ticks;
            seed = initialSeed;
        }

        public RandomEx()
        {
            //lock (this.GetType())
            //{
            //    randGen = new Random(seed++);
            //}
        }

        public int Next()
        {
            return randGen.Next();
        }

        public int    Next(int maximum)
        {
            return randGen.Next(maximum);
        }

        public int    Next(int minimum, int maximum)
        {
            return randGen.Next(minimum, maximum);
        }

        public float Next(float maximum)
        {
            return (float)randGen.NextDouble() * maximum;
        }

        public ulong NextUlong()
        {
            ulong retValue;
            byte []bytes=new byte[8];
            randGen.NextBytes(bytes);
            fixed (byte *p=bytes)
            {
                retValue=*(ulong*)p;
            }
            return retValue;
        }

        public ulong NextPuid()
        {
            return (ulong)(randGen.NextDouble()*5000000000)+(ulong) 0x9500000000000;
        }

        public ulong NextTeamPuid()
        {
            return (ulong)(randGen.NextDouble()*5000000000) | (ulong) 0xFEFE000000000000;
        }

        public double NextDouble()
        {
            return randGen.NextDouble();
        }

        public bool    NextBool()
        {
            return randGen.Next()>(Int32.MaxValue/2);
        }

        public void NextBytes(byte[] buffer)
        {
            randGen.NextBytes(buffer);
        }

        static public int GetInstanceCount()
        {
            return seed - initialSeed;
        }

        // these characters can be used to create random names
        static string    validChars="0123456789aeiou";
        static int        validCharCount=validChars.Length;
        /// <summary>
        /// Generates a random ASCII string
        /// </summary>
        /// <param name="MaxLength">Length of string to generate</param>
        /// <returns></returns>
        public string GenerateRandomString(int MaxLength)
        {
            long i;
            StringBuilder Name;
        
            /*
                * I need two classes of users - ones whose gamertag can be changed,
                * and ones that will always have the same tag.
                * For this reason, some user names will begin with RMA, and some will begin with RMB
                */
        
            if (randGen.Next()<Int32.MaxValue/2)
                Name=new StringBuilder("RMA");
            else
                Name=new StringBuilder("RMB");
            //    Add some random characters
            for (i=Name.Length; i<MaxLength; i++)
            {
                Name.Append(validChars[randGen.Next(validCharCount)]);
            }
            return Name.ToString(0,MaxLength);
        }

        /// <summary>
        /// Like GenerateRandomString, but with specified prefix.
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        public string GenerateRandomString(string prefix, int MaxLength)
        {
            long i;
            StringBuilder Name;
            Name=new StringBuilder( prefix );

            //    Add some random characters
            for (i=Name.Length; i<MaxLength; i++)
            {
                Name.Append(validChars[randGen.Next(validCharCount)]);
            }
            return Name.ToString(0,MaxLength);
        }

        /// <summary>
        /// Unlike GenerateRandomString, there is no prefix with this version.
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        public string GenerateRandomNameString(int MaxLength)
        {
            long i;
            StringBuilder Name=new StringBuilder();

            //    Add some random characters
            for (i=Name.Length; i<MaxLength; i++)
            {
                Name.Append(validChars[randGen.Next(validCharCount)]);
            }
            return Name.ToString(0,MaxLength);
        }

        /// <summary>
        /// Generates a random UTF string
        /// </summary>
        /// <param name="MaxLength">Length of string to generate</param>
        /// <returns></returns>
        public string GenerateRandomUTFString(int MaxLength)
        {
            long i;
            StringBuilder Name=new StringBuilder("R");
            //    Add some time dependent chatacters
            for (i=Name.Length; i<MaxLength; i++)
            {
                Name.Append((char) randGen.Next(30000,32000));
            }
            return Name.ToString();
        }

        /// <summary>
        /// Generates a random string comprised of upper case characters and numbers.
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        public string GenerateRandomUpperAlphaNumericString(int Length)
        {
            StringBuilder Name=new StringBuilder();
            char []validUANChars={'1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};

            //    Add some random characters
            for (int i=Name.Length; i<Length; ++i)
            {
                Name.Append(validUANChars[randGen.Next(validUANChars.Length)]);
            }
            return Name.ToString(0,Length);
        }

        /// <summary>
        /// Generates a random string comprised of upper case characters and numbers.
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        public string GenerateRandomUpperAlphaNumericString(int minLength, int maxLength)
        {
            StringBuilder Name=new StringBuilder();
            char []validUANChars={'1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};

            int len=Next(minLength,maxLength);

            //Add some random characters
            for (int i=0; i<len; ++i)
            {
                Name.Append(validUANChars[randGen.Next(validUANChars.Length)]);
            }
            return Name.ToString(0,len);
        }

        /// <summary>
        /// Generates a random string comprised of lower and upper case characters and numbers.
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        public string GenerateRandomAlphaNumericString(int minLength, int maxLength)
        {
            StringBuilder Name=new StringBuilder();
            char []validANChars={'1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};

            int len=Next(minLength,maxLength);

            //Add some random characters
            for (int i=0; i<len; ++i)
            {
                Name.Append(validANChars[randGen.Next(validANChars.Length)]);
            }
            return Name.ToString(0,len);
        }

        /// <summary>
        /// This will generate, like, a totally, like, random string, dude.
        /// 
        /// The entire string is composed of chars in the 32..255 range
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        public string GenerateTotallyRandomString(int MaxLength)
        {
            StringBuilder Name=new StringBuilder(MaxLength);
            //    Add some time dependent chatacters
            for (int i=0; i<MaxLength; i++)
            {
                Name.Append((char) randGen.Next(32,127));
            }
            return Name.ToString();
        }

        /// <summary>
        /// This will generate number strings (0,1,2,....9).
        /// The entire string is composed of chars in the 48 - 57 range
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        public string GenerateNumberString(int MaxLength)
        {
            StringBuilder Name = new StringBuilder(MaxLength);
            
            for (int i = 0; i < MaxLength; i++)
            {
                Name.Append((char)randGen.Next(0x30, 0x3a));
            }
            return Name.ToString();
        }

        /// <summary>
        /// This will generate hex strings (0,1,2,....e,f) with a prepended 0x
        /// </summary>
        public string GenerateHexString(int MaxLength) //in hex chars, not bytes represented
        {
            StringBuilder Name = new StringBuilder(MaxLength + 2);
            Name.Append("0x");
            
            for (int i = 0; i < MaxLength; i++)
            {
                char num=(char)randGen.Next(0, 15);
                if (num<10) Name.Append((char)('0'+num));
                else Name.Append((char)('a'+(num-10)));
            }

            return Name.ToString();
        }

        /// <summary>
        /// Generates a random IP address in human readable dotted form.
        /// </summary>
        /// <returns></returns>
        public string GenerateIPString()
        {
            StringBuilder Name = new StringBuilder(4*3+3*1);
            
            for (int i = 0; i < 4; i++)
            {
                int num=randGen.Next(0, 255);
                Name.Append(num.ToString());
                if (i!=3) Name.Append(".");
            }
            return Name.ToString();
        }

        /// <summary>
        /// This will generate a random blob of bytes ranging from 0x0-0xff
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        public byte[] GenerateRandomBlob(int MaxLength)
        {
            byte[] blob = new byte[MaxLength];
            randGen.NextBytes(blob);
            return blob;
        }


        /// <summary>
        /// Returns an Int32 that logarithmically tends towards 0
        /// </summary>
        #region Random number distribution
        // (calculated from 10,000,000 samples)
        //49.99799
        //25.00818
        //12.49884
        // 6.25495
        // 3.12409
        // 1.55705
        // 0.77807
        // 0.39020
        // 0.19451
        // 0.09827
        // 0.04867
        // 0.02443
        // 0.01233
        // 0.00618
        // 0.00315
        // 0.00151
        // 0.00084
        // 0.00034
        // 0.00019
        // 0.00011
        // 0.00005
        // 0.00001
        // 0.00003
        // 0.00001
        #endregion
        public int NextLog()
        {
            return(int)(31 - Math.Log(randGen.Next() + 1, 2));
        }

        public string GenerateRandomName()
        {
            return GenerateRandomString(15);
        }

        public ulong GenerateRandomPuid()
        {
            ulong puid = (ulong)randGen.Next();
            puid = puid << 32;
            puid |= (uint)randGen.Next();

            return puid;
        }

        public string GenerateUnicodeString( int length )
        {
            return GeneratePrefixedUnicodeString( "", length, true );
        }

        public string GenerateUnicodeString( int length, bool noSpaces )
        {
            return GeneratePrefixedUnicodeString( "", length, noSpaces );
        }

        public string GenerateUnicodeString( int minLength, int maxLength )
        {
            return GeneratePrefixedUnicodeString( "", minLength, maxLength, true );
        }

        public string GenerateUnicodeString( int minLength, int maxLength, bool noSpaces )
        {
            return GeneratePrefixedUnicodeString( "", minLength, maxLength, noSpaces );
        }

        public string GeneratePrefixedUnicodeString( string prefix, int minLength, int maxLength )
        {
            return GeneratePrefixedUnicodeString( prefix, minLength, maxLength, true );
        }

        public string GeneratePrefixedUnicodeString( string prefix, int minLength, int maxLength, bool noSpaces )
        {
            if( maxLength < minLength )
                throw new ArgumentException( "Max Length is less than Min length" );
            if( prefix.Length > minLength )
                throw new ArgumentException( "Prefix is longer that speicified min length" );
            
            int length = randGen.Next( minLength, maxLength+1 );
            return GeneratePrefixedUnicodeString( prefix, length, noSpaces );
        }

        public string GeneratePrefixedUnicodeString( string prefix, int length )
        {
            return GeneratePrefixedUnicodeString( prefix, length, true );
        }

        public string GeneratePrefixedUnicodeString( string prefix, int length, bool noSpaces )
        {
            if( prefix.Length > length )
                throw new ArgumentException( "Prefix length is greater than speicified length" );

            StringBuilder sb = new StringBuilder( prefix );
            while( sb.Length < length )
            {
                // Pick any but Control Codes (0x0000  0x001F) and "Specials" (0xFFF0  0xFFFF0
                char c = (char) randGen.Next( 0x20, 0xFFF0 ); 
                
                // Check for Deprecated Format Characters (0x206A  0x206F) 
                if( (c >= 0x206A) && (c <= 0x206F) )
                    continue;

                // Check for Surrogates Area (0xD800  0xDFFF) 
                if( (c >= 0xD800) && (c <= 0xDFFF) )
                    continue;

                // Check for Private Use Area (0xE000  0xF8FF) 
                if( (c >= 0xE000) && (c <= 0xF8FF) )
                    continue;

                // Check for other "Special" (0xFEFF) 
                if( c == 0xFEFF )
                    continue;

                sb.Append( c );
            }
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\MultiEnumerator.cs ===
using System;
using System.Collections;
using System.Collections.Generic;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// An enumerator for enumerating over multiple enumerators simultaneously.
    /// </summary>
    /// <typeparam name="T">The type of values over which the base enumerators enumerate.</typeparam>
    public class MultiEnumerator<T> : IEnumerable<List<MultiEnumerator<T>.Entry>>
    {
        /// <summary>
        /// A single value from an enumerable.
        /// </summary>
        public class Entry
        {
            /// <summary>The value from the enumerable.</summary>
            public T Value { get; set; }
            /// <summary>If true, the Value is valid. If false, it is not.</summary>
            public bool Valid { get; set; }
        }

        /// <summary>
        /// The Enumerator for a MultiEnumerator.
        /// </summary>
        public class Enumerator : IEnumerator<List<Entry>>
        {
            /// <summary>The enumerators to enumerate over.</summary>
            protected IEnumerable<IEnumerator<T>> Enumerators;

            /// <summary>The current value of the enumerator.</summary>
            protected List<Entry> CurrentValue;

            /// <summary>
            /// Creates an Enumerator for the given enumerables.
            /// </summary>
            /// <param name="enumerables">The enumerables to enumerate over.</param>
            internal Enumerator (IEnumerable<IEnumerable<T>> enumerables)
            {
                List<IEnumerator<T>> enums = new List<IEnumerator<T>>();

                foreach (IEnumerable<T> enumerable in enumerables)
                {
                    enums.Add(enumerable.GetEnumerator());
                }

                Enumerators = enums;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose ()
            {
                foreach (IEnumerator<T> enm in Enumerators)
                {
                    enm.Dispose();
                }
                Enumerators = null;
                CurrentValue = null;
            }

            /// <summary>
            /// Moves the enumerator to the next value.
            /// </summary>
            /// <returns>True if there is a value; false if the end of the list has been reached.</returns>
            public bool MoveNext ()
            {
                bool ans = false;
                List<Entry> newCurrent = new List<Entry>();

                foreach (IEnumerator<T> enm in Enumerators)
                {
                    bool hasOne = enm.MoveNext();
                    ans = ans || hasOne;

                    newCurrent.Add(new Entry()
                    {
                        Value = (hasOne ? enm.Current : default(T)),
                        Valid = hasOne
                    });
                }

                CurrentValue = newCurrent;
                return ans;
            }

            /// <summary>
            /// Resets the enumerator to its initial state.
            /// </summary>
            public void Reset ()
            {
                foreach (IEnumerator<T> enm in Enumerators)
                {
                    enm.Reset();
                }
            }

            /// <summary>
            /// The current value of the enumerator.
            /// </summary>
            public List<Entry> Current
            {
                get
                {
                    return CurrentValue;
                }
            }

            /// <summary>
            /// The current value of the enumerator.
            /// </summary>
            object IEnumerator.Current
            {
                get
                {
                    return CurrentValue;
                }
            }
        }

        /// <summary>Our Enumerables.</summary>
        protected IEnumerable<IEnumerable<T>> Enumerables;

        /// <summary>
        /// Creates a MultiEnumerator from the given IEnumerables.
        /// </summary>
        /// <param name="enumerables">The IEnumerables to enumerate.</param>
        public MultiEnumerator (params IEnumerable<T>[] enumerables)
        {
            Enumerables = new List<IEnumerable<T>>(enumerables);
        }

        /// <summary>
        /// Creates a MultiEnumerator from the given IEnumerables.
        /// </summary>
        /// <param name="enumerables">The IEnumerables to enumerate.</param>
        public MultiEnumerator (IEnumerable<IEnumerable<T>> enumerables)
        {
            Enumerables = new List<IEnumerable<T>>(enumerables);
        }

        /// <summary>
        /// Creates an enumerator for this MultiEnumerator.
        /// </summary>
        /// <returns>An enumerator for this MultiEnumerator.</returns>
        public IEnumerator<List<Entry>> GetEnumerator ()
        {
            return new Enumerator(Enumerables);
        }

        /// <summary>
        /// Creates an enumerator for this MultiEnumerator.
        /// </summary>
        /// <returns>An enumerator for this MultiEnumerator.</returns>
        IEnumerator IEnumerable.GetEnumerator ()
        {
            return new Enumerator(Enumerables);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\ReflectionUtilities.cs ===
//The core RandomEx + some live-specific functions.
using System;
using System.Collections.Generic;
using System.Reflection;

namespace ServerTestFramework.Utilities
{
    public class ReflectionUtils
    {
        /// <summary>
        /// Uses the information passed in to build a list of all the types derived 
        /// from the baseType within a specific assembly
        /// </summary>
        /// <param name="list">The list to add the Types to.</param>
        /// <param name="asm">The assembly to search through.</param>
        /// <param name="baseType">The base type you want derived types from.</param>
        public static void GetDerivedTypes ( List<Type> list, Assembly asm, Type baseType )
        {
            Type[] asm_types = null;

            try
            {
                asm_types = asm.GetTypes();
            }
            catch (ReflectionTypeLoadException e)
            {
                asm_types = e.Types;

                foreach (Exception exc in e.LoaderExceptions)
                {
                    if (exc != null)
                    {
                        if (exc is TypeLoadException)
                        {
                            TypeLoadException tle = (TypeLoadException) exc;
                            CoreGlobal.RO.Debug("GetDerivedTypes:: Unable to load type: {0}: {1}", tle.TypeName, exc.Message);
                        }
                    }
                }
            }

            foreach (Type currentType in asm_types)
            {
                if (currentType != null && ! currentType.Equals(baseType) && 
                    baseType.IsAssignableFrom(currentType))
                {
                    list.Add(currentType);
                }
            }
        }

        /// <summary>
        /// Finds all types derived from baseType within the specified assembly.
        /// </summary>
        /// <param name="asm">The assembly to search through.</param>
        /// <param name="baseType">The base type you want derived types from.</param>
        /// <returns>A list of the types.</returns>
        public static List<Type> GetDerivedTypes ( Assembly asm, Type baseType )
        {
            List<Type> derivedList = new List<Type>();

            GetDerivedTypes(derivedList, asm, baseType);

            return derivedList;
        }

        /// <summary>
        /// Finds all typed derived from baseType in *ALL* assemblies
        /// </summary>
        /// <param name="baseType">The base type you want derived types from.</param>
        /// <returns>A list of the types.</returns>
        public static List<Type> GetDerivedTypes ( Type baseType )
        {
            List<Type> derivedList = new List<Type>();
            Assembly[] allAsm = AppDomain.CurrentDomain.GetAssemblies();

            foreach (Assembly asm in allAsm)
            {
                GetDerivedTypes(derivedList, asm, baseType);
            }

            return derivedList;
        }

        /// <summary>
        /// Finds all types derived from baseType and adds them to the specified List.
        /// </summary>
        /// <param name="list">The list to add the found types to.</param>
        /// <param name="baseType">The base type you want derived types for.</param>
        public static void GetDerivedTypes ( List<Type> list, Type baseType )
        {
            Assembly[] allAsm = AppDomain.CurrentDomain.GetAssemblies();

            foreach (Assembly asm in allAsm)
            {
                GetDerivedTypes(list, asm, baseType);
            }
        }

        /// <summary> This calls System.Type.GetNestedTypes() on the origType and all base classes and returns the combined result. </summary>
        public static Type[] GetNestedTypesInInheritanceTree(Type origType, BindingFlags flags)
        {
            List<Type> combinedTypes=new List<Type>();

            Type curType=origType;
            while (curType!=null)
            {
                foreach (Type nestedType in curType.GetNestedTypes(flags))
                {
                    bool exists=false;
                    foreach (Type existingType in combinedTypes)
                    {
                        if (nestedType.Name==existingType.Name)
                        {
                            exists=true;
                            break;
                        }
                    }

                    if (!exists)
                    {
                        combinedTypes.Add(nestedType);
                    }
                }
                curType=curType.BaseType;
            }

            return combinedTypes.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\RemoteTime.cs ===
using System;
using System.Management;

namespace ServerTestFramework.Utilities
{
	public class RemoteTime
	{
        public static DateTime GetRemoteDateTime(string remoteName)
        {
            ConnectionOptions           cOptions = new ConnectionOptions();
            ManagementScope             mScope = new ManagementScope("\\\\" + remoteName + "\\root\\cimv2", cOptions);
            ObjectQuery                 oQuery = new SelectQuery("Win32_UTCTime");
            ManagementObjectSearcher    moSearcher = new ManagementObjectSearcher(mScope, oQuery);
            ManagementObjectCollection  moCollection = moSearcher.Get();
            ManagementBaseObject[]      mbObject = new ManagementBaseObject[1];

            moCollection.CopyTo(mbObject, 0);

            DateTime                    dt = new DateTime((int) Convert.ToUInt32(mbObject[0]["year"]), (int) Convert.ToUInt32(mbObject[0]["month"]), (int) Convert.ToUInt32(mbObject[0]["day"]), (int) Convert.ToUInt32(mbObject[0]["hour"]), (int) Convert.ToUInt32(mbObject[0]["minute"]), (int) Convert.ToUInt32(mbObject[0]["second"]));

            return dt;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\RemoteReportDestination.cs ===
using System;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// This is a simple pass-through destination so that the destination and/or the report 
    /// object don't have to marshal their own parameters.
    /// </summary>
    public class RemoteReportDestination : InfiniteLifetimeMarshalByRefObject, ServerTestFramework.Report.Destination
    {
        private Report _Root;

        public RemoteReportDestination()
        {
            _Root = Report.GetRoot();
        }

        public void ClearLine()
        {
        }

        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            //_Root.Log(level, message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\SerializableDictionary.cs ===
//Serializable dictionary.

using System;
using System.Collections.Generic;
using System.Xml.Serialization;

namespace ServerTestFramework.Core.Utilities
{
    #region SerializableDictionary

    // --------------------------------------------------------------------------------------
    // SerializableDictionary
    //
    // Basic generic Dictionary<,> that can be used with XmlSerialize. Borrowed from 
    // http://weblogs.asp.net/pwelter34/archive/2006/05/03/444961.aspx.
    // --------------------------------------------------------------------------------------
    public class SerializableDictionary<TKey, TValue>
        : Dictionary<TKey, TValue>, IXmlSerializable
    {
        public System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }

        public void ReadXml(System.Xml.XmlReader reader)
        {
            XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
            XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

            bool wasEmpty = reader.IsEmptyElement;
            reader.Read();

            if (wasEmpty)
                return;

            while (reader.NodeType != System.Xml.XmlNodeType.EndElement)
            {
                reader.ReadStartElement("item");

                reader.ReadStartElement("key");
                TKey key = (TKey)keySerializer.Deserialize(reader);
                reader.ReadEndElement();

                reader.ReadStartElement("value");
                TValue value = (TValue)valueSerializer.Deserialize(reader);
                reader.ReadEndElement();

                this.Add(key, value);

                reader.ReadEndElement();
                reader.MoveToContent();
            }
            reader.ReadEndElement();
        }

        public void WriteXml(System.Xml.XmlWriter writer)
        {
            XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
            XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

            foreach (TKey key in this.Keys)
            {
                writer.WriteStartElement("item");

                writer.WriteStartElement("key");
                keySerializer.Serialize(writer, key);
                writer.WriteEndElement();

                writer.WriteStartElement("value");
                TValue value = this[key];
                valueSerializer.Serialize(writer, value);
                writer.WriteEndElement();

                writer.WriteEndElement();
            }
        }

        public void CopyInto(SerializableDictionary<TKey, TValue> src)
        {
            foreach (TKey key in src.Keys)
            {
                this.Add(key, src[key]);
            }
        }
    }

    #endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\SafeCounter.cs ===
using System;
using System.Threading;

namespace ServerTestFramework.Utilities
{
	//
	// This object wraps a counter in interlocked operations
	// this object can be passed by reference to multiple threads
	// to keep a safe master counter.
	//
	public class SafeCounter
	{
		private int _Value;

		public int Value {
			get {
				return _Value;
			}
			set 
			{
				Interlocked.Exchange(ref _Value, value);
			}
		}

		public SafeCounter()
		{
			_Value = 0;
		}

		public SafeCounter(int value)
		{
			_Value = value;
		}

		public int Increment()
		{
			return Interlocked.Increment(ref _Value);
		}

		public int Decrement()
		{
			return Interlocked.Decrement(ref _Value);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\SimpleJobMgr.cs ===
using System;
using System.Collections;
using System.Threading;

namespace ServerTestFramework.Utilities
{
	public sealed class SimpleJobMgr
	{
		public delegate void ExecutorDelegate(ref object State);
		public class Job
		{
			public ExecutorDelegate Executor;
			public object State;
			public Exception Exception;
		}

		private Thread[] workerThreads;
        private int runningJobsCount = 0;
        private Queue pendingJobs = new Queue();
		private Queue completedJobs = new Queue();
		private AutoResetEvent completedJobEnqueued = new AutoResetEvent(false);
        private bool inProgress = false;

		public void AddJob(ExecutorDelegate executor, object state)
		{
            if (inProgress == true)
            {
                throw new Exception("SimpleJobMgr::AddJob: Cannot add job after StartJobs has been called."); 
            }
			Job newJob = new Job();
			newJob.Executor = executor;
			newJob.State = state;
			pendingJobs.Enqueue(newJob);
		}

		private void JobRunner()
		{
            while (true)
            {
                Job job;
                try
                {
                    // Get a job
                    lock(pendingJobs)
                    {
                        job = (Job)pendingJobs.Dequeue();
                        Interlocked.Increment(ref runningJobsCount);
                    }
                }
                catch(InvalidOperationException)
                {
                    // pendingJobs queue is empty; nothing left to do
                    break;
                }

                try
                {
                    // Run the job
                    job.Executor(ref job.State);
                }
                catch(Exception e)
                {
                    // Save the exception even if it's just ThreadAbortException
                    job.Exception = e;
                }
                finally
                {
                    // Store the results
                    lock(completedJobs)
                    {
                        completedJobs.Enqueue(job);
                        completedJobEnqueued.Set();
                        Interlocked.Decrement(ref runningJobsCount);
                    }
                }
            }
		}

		public void StartJobs(int numThreads)
		{
			if (numThreads < 1)
			{
				throw new ArgumentException("SimpleJobMgr::StartJobs: # of threads must be greater than 0.  numThreads == " + numThreads);
            }
            if (inProgress == true)
            {
                throw new Exception("SimpleJobMgr::StartJobs: Cannot call StartJobs twice."); 
            }
            inProgress = true;
			workerThreads = new Thread[numThreads];
			for (int i = 0; i < workerThreads.Length; i++)
			{
				workerThreads[i] = new Thread(new ThreadStart(this.JobRunner));
				workerThreads[i].Start();
			}
		}

		public void Abort()
		{
			foreach (Thread workerThread in workerThreads)
			{
				workerThread.Abort();
			}
			Join();
		}

		public void Join()
		{
			foreach (Thread workerThread in workerThreads)
			{
				workerThread.Join();
			}
		}

		public bool Empty()
		{
            lock(pendingJobs)
            {
                if (pendingJobs.Count != 0)
                {
                    return false;
                }
            }
            lock(completedJobs)
            {
                if (completedJobs.Count != 0 || Thread.VolatileRead(ref runningJobsCount) != 0)
                {
                    return false;
                }
            }
            return true;
		}

		public Job GetCompletedJob()
		{
			return GetCompletedJob(true);
		}

		public Job GetCompletedJob(bool waitForCompletedJob)
		{
            lock(this)
            {
                // Check if any pending or completed jobs still exist
                if (Empty())
                {
                    return null;
                }
                // Return a completed job immediately if possible
                lock(completedJobs)
                {
                    completedJobEnqueued.Reset();
                    if (completedJobs.Count != 0)
                    {
                        return (Job)completedJobs.Dequeue();
                    }
                }
                // Only pending jobs exist at this time
                if (waitForCompletedJob)
                {
                    completedJobEnqueued.WaitOne();
                    lock(completedJobs)
                    {
                        return (Job)completedJobs.Dequeue();
                    }
                }
                else
                {
                    return null;
                }
            }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\StringUtils.cs ===
using System;
using System.Collections;

namespace ServerTestFramework.Utilities
{
    public class StringUtils
    {
        public delegate string MakeDeliminatorSeparatedListStringer(object o);

        /// <summary> Builds a string separated by a deliminator for a list of items.  Uses the specified delegate to convert each object to a string </summary>
        public static string MakeDeliminatorSeparatedList(IEnumerable list, string deliminator, MakeDeliminatorSeparatedListStringer stringer)
        {
            string ret="";
            if (list!=null)
            {
                foreach (object o in list)
                {
                    if (ret.Length>0)
                    {
                        ret+=deliminator;
                    }
                    ret+=stringer(o);
                }
            }

            return ret;
        }

        public static string MakeDeliminatorSeparatedListDefaultStringer(object o)
        {
            if (o==null)
            {
                return "<null>";
            }

            return o.ToString();
        }

        /// <summary>
        /// Builds a string separated by a deliminator for a list of items.  Each element in the list must be usefully convertable to a string.
        /// </summary>
        public static string MakeDeliminatorSeparatedList(IEnumerable list, string deliminator)
        {
            return MakeDeliminatorSeparatedList(list, ", ", MakeDeliminatorSeparatedListDefaultStringer);
        }

        /// <summary>
        /// Builds a string separated by commas for a list of items.  Each element in the list must be usefully convertable to a string.
        /// </summary>
        public static string MakeCommaSeparatedList(IEnumerable list)
        {
            return MakeDeliminatorSeparatedList(list, ", ");
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\StfXmlDoc.cs ===
using System;
using System.Xml;

namespace ServerTestFramework.Runner
{
    public class StfXmlDoc : XmlDocument
    {
        public StfXmlDoc() : base()
        {
        }

        public StfXmlDoc(string fileName) : base()
        {
            Load(fileName);
        }

        /// <summary>Path of the file identifier element.</summary>
        private const string FileIdentifierXPath = "/stf/configfile";

        /// <summary>Gets the named file identifier XmlNode from a document.</summary>
        private XmlNode GetFileIdentifier (XmlDocument doc, string identifier)
        {
            return doc.SelectSingleNode(FileIdentifierXPath + "[@identifier='" + identifier + "']");
        }

        /// <summary>
        /// Tests for the existence of a named file identifier element.
        /// </summary>
        /// <returns>True if the element exists; false otherwise.</returns>
        private bool TestForFileIdentifier (string identifier)
        {
            return (GetFileIdentifier(this, identifier) != null);
        }

        /// <summary>
        /// Conditionally merges the given document, based on whether it has been merged before or not.
        /// A known element is used to tag the merge.
        /// </summary>
        public void ConditionalMerge (XmlDocument doc, string pathToMerge, string identifier)
        {
            identifier = identifier.ToLower().Replace('\'', '_');

            if (!TestForFileIdentifier(identifier))
            {
                try
                {
                    Merge(doc, pathToMerge);
                }
                finally
                {
                    // make sure it got merged, if not, force it
                    if (!TestForFileIdentifier(identifier))
                    {
                        XmlNode stf = SelectSingleNode("stf");
                        XmlNode id = CreateElement("configfile");
                        XmlAttribute ident = CreateAttribute("identifier");
                        ident.Value = identifier;
                        id.Attributes.Append(ident);
                        stf.AppendChild(id);
                    }
                }
            }
        }

        public void Merge(XmlDocument doc, string pathToMerge)
        {
            XmlNode myRoot = SelectSingleNode(pathToMerge);
            if (myRoot == null)
            {
                AppendChild(ImportNode(doc.SelectSingleNode(pathToMerge), true));
            }
            else
            {
                XmlNode ssn = doc.SelectSingleNode(pathToMerge);

                if (ssn != null)
                {
                    foreach (XmlNode child in ssn.ChildNodes)
                    {
                        XmlNode localChild = ImportNode(child, true);
                        myRoot.AppendChild(localChild);
                    }
                }
            }
        }

        public XmlNode AddPath(string xpath)
        {
            xpath = xpath.TrimStart(new char[] {'/'});
            string[] pieces = xpath.Split(new char[] {'/'});
            string path = "/";
            XmlNode node = this;

            for (int i = 0; i < pieces.Length; i++)
            {
                path += "/" + pieces[i];
                XmlNode child = node.SelectSingleNode(path);
                if (child == null)
                {
                    child = this.CreateElement(pieces[i]);
                    node.AppendChild(child);
                }

                node = child;
            }

            return node;
        }

        public void SetParameter(string name, string value)
        {
            //see if the node already exists, make if not
            XmlNode paramNode=SelectSingleNode("/stf/config/parameters/parameter[@name='" + name + "']");
            if (paramNode==null)
            {
                XmlNode paramsNode = AddPath("/stf/config/parameters");
                paramNode = CreateElement("parameter");
                paramsNode.AppendChild(paramNode);
            }

            //set value
            XmlAttribute attr;
            attr = CreateAttribute("name");
            attr.Value = name;
            paramNode.Attributes.Remove(paramNode.Attributes["name"]);
            paramNode.Attributes.Append(attr);

            attr = CreateAttribute("value");
            attr.Value = value;
            paramNode.Attributes.Remove(paramNode.Attributes["value"]);
            paramNode.Attributes.Append(attr);
        }

        public void SetBoolParameter(string name, bool value)
        {
            SetParameter(name, value ? "true" : "false");
        }

        public string GetParameter(string name)
        {
            XmlNode paramNode = SelectSingleNode("/stf/config/parameters/parameter[@name='" + name + "']");
            if (paramNode == null || paramNode.Attributes["value"] == null)
                return null;
            return paramNode.Attributes["value"].Value;
        }

        public bool GetBoolParameter(string name)
        {
            string v = GetParameter(name);
            return v == "true" ? true : false;
        }


    }

    public class StfXmlDocException : Exception
    {
        public StfXmlDocException (string message) : base(message) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\TestCaseReports.cs ===
//handles sorting a Report output into which test case it belongs to, and accessing that information later

using System;

namespace ServerTestFramework
{
    public class TestCaseReports: Report.Destination
    {
        //handle output from the Report object (should be attached to Root)
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            //add to output
            string logString=Report.FormatLogLine(date,level,path,message) + "\n";

            string tableKey=testName;
            lock (logLock)
            {
                if (!storedLogs.ContainsKey(tableKey)) //not in table
                {
                    storedLogs.Add(tableKey, logString);
                }
                else //already in table
                {
                    storedLogs[tableKey]+=logString;
                }

                //TODO: A true circular buffer would be ideal here.  C# makes that hard though.
                //cap the storage for a single test to 64KB
                const int MAX_TESTDATA_LEN=1024*64;

                int slen=storedLogs[tableKey].Length;
                if (slen>MAX_TESTDATA_LEN)
                {
                    int numExtra=slen-MAX_TESTDATA_LEN;

                    storedLogs[tableKey]=storedLogs[tableKey].Substring(numExtra,MAX_TESTDATA_LEN);
                }
            }
        }

        //get all the output for a specific test case
        public static string GetCaseOutput(string testName)
        {
            string logString;
            string tableKey=testName;
            lock (logLock)
            {
                try
                {
                    logString=storedLogs[tableKey];
                }
                catch
                {
                    logString="";
                }
            }
            return logString;
        }

        //clears all stored log output
        public static void ClearOutput()
        {
            lock (logLock)
            {
                storedLogs.Clear();
            }
        }

        // --

        //locks
        private static object logLock=new object();

        //the stored output, sorted by test case
        private static System.Collections.Generic.Dictionary<string,string> storedLogs=new System.Collections.Generic.Dictionary<string,string>();
    };

} //namespace ServerTestFramework
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\SimpleUdp.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;

namespace ServerTestFramework.Utilities
{
	public class SimpleUdp
	{
		[ThreadStatic]
		private static Socket udpSocket;
		[ThreadStatic]
		private static byte[] recvBuffer;

		public static byte[] SendRecv(byte[] pb, string IP, ushort port, int timeOut) {return SendRecv(pb, new IPEndPoint(IPAddress.Parse(IP), port), timeOut);}
		public static byte[] SendRecv(byte[] pb, IPEndPoint host, int timeOut)
		{
			Debug.Assert((udpSocket == null) == (recvBuffer == null));
			if (udpSocket == null)
			{
				udpSocket = new Socket(host.AddressFamily, SocketType.Dgram, ProtocolType.Udp);
				recvBuffer = new byte[1500];
			}

			int sentBytes = udpSocket.SendTo(pb, host);
			if (sentBytes != pb.Length)
				throw new Exception("UDP send failed.");

			byte[] recv = null;
			if (udpSocket.Poll(timeOut * 1000, SelectMode.SelectRead))
			{
				int cb = udpSocket.Receive(recvBuffer);
				recv = new byte[cb];
				Array.Copy(recvBuffer, recv, cb);
			}
			else
			{
				// If we time out we want to get a brand new socket so that if the response comes in late it will come into the old port and not bother us.
				udpSocket.Close();
				udpSocket = new Socket(host.AddressFamily, SocketType.Dgram, ProtocolType.Udp);
			}

			return recv;
		}
	}

	public class TimeoutException : Exception
	{
		public TimeoutException() : base() {}
		public TimeoutException(string message) : base(message) {}
		public TimeoutException(string message, Exception inner) : base(message, inner) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\TextWriterReportBridge.cs ===
using System;
using System.IO;
using System.Text;
using ServerTestFramework;

namespace ServerTestFramework.Utilities
{
	/// <summary>
	/// Bridge between text writers and reporting system, used for rerouting console
	/// output into the report system
	/// </summary>
	public class TextWriterReportBridge : TextWriter
	{
		public override Encoding Encoding
		{
			get 
			{ 
				return Encoding.Default; 
			}
		}

		Report _RO;
		public TextWriterReportBridge(string name)
		{
			_RO = new Report(name);
		}

		public override void Write(string s)
		{
			_RO.Info(s,true);
		}

		public override void WriteLine(string s)
		{
			_RO.Info(s);
		}

		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\Timers.cs ===
using System;
using System.Runtime.InteropServices;

namespace ServerTestFramework.Utilities
{
	public class Timing
	{
		// The default precision of the timeGetTime function can be five milliseconds or more,
		// depending on the machine.
		[DllImport("winmm.dll")]
		public static extern uint timeGetTime();
		// timeBeginPeriod allegedly slows down the system (high interrupt latency, negative CPU cache effects, etc.)

        // More accurate timing functions that are based on a hardware tick
        [DllImport("Kernel32.dll")]
        public static extern bool QueryPerformanceCounter (out long perfcount);

        [DllImport("Kernel32.dll")]
        public static extern bool QueryPerformanceFrequency (out long freq);

        protected static long _freq = 0;
        protected static bool _queryPerfSupported = true;

        private const string _exceptionString = "QueryPerformanceFrequency does not appear to be supported by the current hardware.";

        /// <summary>
        /// The frequency at which the hardware performance counter ticks.
        /// </summary>
        /// <remarks>
        /// Returns the cached value.  Call QueryPerformanceFrequency() to requery the value from the system.
        /// </remarks>
        /// <exception cref="NotSupportedException">Thrown when the underlying call to QueryPerformanceFrequency returns false.</exception>
        public static long PerformanceFrequency
        {
            get
            {
                if (_freq == 0 && _queryPerfSupported)
                {
                    QueryPerformanceFrequency();
                }

                return _freq;
            }
        }

        /// <summary>
        /// Gets the current value of the hardware performance counter.
        /// </summary>
        /// <returns>The current value of the counter.</returns>
        /// <exception cref="NotSupportedException">Thrown when the underlying call to QueryPerformanceCounter returns false.</exception>
        public static long QueryPerformanceCounter ()
        {
            long ans;
            _queryPerfSupported = QueryPerformanceCounter(out ans);

            if (!_queryPerfSupported)
            {
                throw new NotSupportedException(_exceptionString);
            }

            return ans;
        }

        /// <summary>
        /// Gets the frequency at which the hardware performance counter ticks.
        /// </summary>
        /// <returns>The frequency at which the counter ticks.</returns>
        /// <exception cref="NotSupportedException">Thrown when the underlying call to QueryPerformanceFrequency returns false.</exception>
        public static long QueryPerformanceFrequency ()
        {
            _queryPerfSupported = QueryPerformanceFrequency(out _freq);

            if (!_queryPerfSupported || _freq == 0)
            {
                throw new NotSupportedException(_exceptionString);
            }

            return _freq;
        }

        /// <summary>
        /// Calculates the time between two values of the performance counter, in seconds.
        /// </summary>
        /// <param name="start">The sample of the performance counter taken first.</param>
        /// <param name="end">The sample of the performance counter taken second.</param>
        /// <returns>The time between the two samples of the counter, in seconds.</returns>
        /// <exception cref="NotSupportedException">Thrown when the underlying call to QueryPerformanceFrequency returns false.</exception>
        public static double CalculatePerformanceDelta (long start, long end)
        {
            if (!_queryPerfSupported)
            {
                throw new NotSupportedException(_exceptionString);
            }

            if (end < start)
            {
                return ((double) ((long.MaxValue - start) + end)) / ((double) PerformanceFrequency);
            }
            else
            {
                return ((double) (end - start)) / ((double) PerformanceFrequency);
            }
        }

        public static double SecondsElapsedSince(long start)
        {
            if (!_queryPerfSupported)
            {
                throw new NotSupportedException(_exceptionString);
            }

            return ((double)(QueryPerformanceCounter() - start)) / ((double) PerformanceFrequency);
	}


        }

	/// <summary>
	/// Summary description for Timers.
	/// </summary>
	public class StopWatch
	{
		uint startTime;
		ulong msElapsed;

		private uint GetTimeDelta(uint start, uint stop)
		{
			ulong safeStop = stop;
			if (stop < start)
			{
				// The uint counter rolled over to 0, your hardware is funky, or time slid backwards
				safeStop += uint.MaxValue;
			}
			return((uint)(safeStop - start));
		}

		public TimeSpan ConvertMsToTimeSpan(ulong ms)
		{
			// Supporting 35,791,394+ hours should be long enough
			int hours = (int)(ms / (60 * 60 * 1000));
			ms = ms % (60 * 60 * 1000);
			int minutes = (int)(ms / (60 * 1000));
			ms = ms % (60 * 1000);
			int secs = (int)(ms / 1000);
			ms = ms % 1000;
			return(new TimeSpan(0, hours, minutes, secs, (int)ms));
		}

		public void Start()
		{
			startTime = Timing.timeGetTime();
		}

		public void Reset()
		{
			msElapsed = 0;
		}

		public TimeSpan Stop()
		{
			msElapsed += GetTimeDelta(startTime, Timing.timeGetTime());
			return(ConvertMsToTimeSpan(msElapsed));
		}
	}

	public class TimeBomb
	{
		private StopWatch Timer = new StopWatch();
		public ulong MaxElapsedMs;

		public TimeBomb(ulong maxElapsedMilliseconds)
		{
			MaxElapsedMs = maxElapsedMilliseconds;
		}

		public void Start()
		{
			Timer.Start();
		}

		public void Stop()
		{
			TimeSpan elapsed = Timer.Stop();
			double elapsedMs = ((elapsed.Minutes * 60.0) + elapsed.Seconds) * 1000 + elapsed.Milliseconds;
			if (elapsedMs > MaxElapsedMs)
			{
				throw new Exception("TimeBomb: elapsed time: " + elapsedMs + " (ms) exceeds max allowed: " + MaxElapsedMs + " (ms)");
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\TcpRelay.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Collections.Generic;

using ServerTestFramework;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Listens for tcp connections on a port, and relays all that traffic to/from the destination.
    /// You must Dispose() this object when you are done with it, in order to kill the listener thread.
    /// </summary>
    public class TcpRelay: IDisposable
    {
        /// <summary>
        /// Prevent connections from anyone but ourself.
        /// </summary>
        public bool AllowOnlyLocalHost=false;

        /// <summary>
        /// The remote host to which traffic is relayed.
        /// </summary>
        public string Destination
        {
            get { return targetAddr.ToString(); }
        }

        /// <summary>
        /// The port on the remote host.
        /// </summary>
        public ushort RemotePort
        {
            get { return targetPort; }
        }

        /// <summary>
        /// The local port on which we listen for new connections.
        /// </summary>
        public ushort LocalListenPort
        {
            get { return localPort; }
        }

        /// <summary>
        /// Spew connections and relayed data.
        /// </summary>
        public bool Verbose
        {
            get { return verbose; }
            set { verbose=value;  }
        }

        //
        public TcpRelay(string remoteHost, ushort remotePort)
        {
            Startup(remoteHost, remotePort, 0);
        }

        //
        public TcpRelay(string remoteHost, ushort remotePort, ushort localPort)
        {
            Startup(remoteHost, remotePort, localPort);
        }

        /// <summary>
        /// Shuts down the listener thread and connections.
        /// </summary>
        public void Dispose()
        {
            string relayName="local port "+LocalListenPort+" to "+Destination+":"+RemotePort;
            CoreGlobal.RO.Debug("Stopping TCP relay: "+relayName+"...");

            lock (listenerThreadLock)
            {
                listener=null;

                while (connections.Count>0)
                {
                    try
                    {
                        connections.First.Value.local.Close();
                        connections.First.Value.remote.Close();
                    }
                    catch (Exception e)
                    {
                        CoreGlobal.RO.Error("Exception while closing socket: "+e.Message);
                    }

                    connections.RemoveFirst();
                }
            }

            CoreGlobal.RO.Debug("Stopped TCP relay: "+relayName);
        }

        /// <summary>
        /// Override this in order to alter the data before it is relayed from one side to the other.
        /// </summary>
        /// <param name="isRemoteTarget">If true, then the data being processed here is passing from the local side to the remote side.</param>
        public virtual void ProcessData(Connection c, bool isRemoteTarget, byte []incData, out byte []outData)
        {
            outData=incData;
        }

        /// <summary>
        /// Represents a connection on which we are relaying data
        /// </summary>
        public class Connection
        {
            public Socket local;
            public Socket remote;
        };

        #region Internals

        // --

        //constructor work
        private void Startup(string remoteHost, ushort remotePort, ushort localPort)
        {
            targetPort=remotePort;

            //setup the socket
            IPAddress []ipAdd=Dns.GetHostAddresses(remoteHost);
            if (ipAdd.Length<1) throw new System.Exception("Dns lookup failed for: "+remoteHost);
            if (ipAdd.Length>1) CoreGlobal.RO.Warn(remoteHost+" has "+ipAdd.Length+" different addresses.  We are only using: "+ipAdd[0].ToString());
            targetAddr=ipAdd[0];

            listener=new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            IPEndPoint ep=new IPEndPoint(IPAddress.Any, localPort);
            listener.Bind(ep);
            this.localPort=(ushort)((IPEndPoint)(listener.LocalEndPoint)).Port;
            listener.Listen(256);

            CoreGlobal.RO.Debug("Started TCP relay: local port "+LocalListenPort+" to "+Destination+":"+RemotePort);

            //start the thread
            ThreadMaker.CreateThread(ListenerProc).Start();
        }

        //listener thread proc
        private void ListenerProc()
        {
            while (true)
            {
                lock (listenerThreadLock)
                {
                    if (listener==null) break;

                    //check the sockets
                    List<Socket> listenList=new List<Socket>();
                    listenList.Add(listener);

                    //List<Socket> checkList0=new List<Socket>();
                    List<Socket> checkList1=new List<Socket>();
                    foreach (Connection c in connections)
                    {
                        //checkList0.Add(c.local);
                        checkList1.Add(c.local);
                        //checkList0.Add(c.remote);
                        checkList1.Add(c.remote);
                    }

                    Socket.Select(listenList, null/*checkList0*/, checkList1, 1000000); //1s timeout

                    //process new connections
                    try
                    {
                        foreach (Socket s in listenList)
                        {
                            Socket local=s.Accept();
                            if (AllowOnlyLocalHost && !IPAddress.IsLoopback(((IPEndPoint)(local.RemoteEndPoint)).Address)) continue;

                            //make a new remote connection for this one
                            if (verbose)
                            {
                                CoreGlobal.RO.Info("New incoming connection: "+local.RemoteEndPoint+".  Will relay to "+targetAddr+":"+targetPort);
                            }

                            Socket remote=new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                            remote.Connect(targetAddr, targetPort);

                            Connection c=new Connection();
                            local.ReceiveTimeout=2000;
                            local.SendTimeout=2000;
                            remote.ReceiveTimeout=2000;
                            remote.SendTimeout=2000;
                            c.local=local;
                            c.remote=remote;
                            connections.AddFirst(c);
                        }
                    }
                    catch (Exception e)
                    {
                        CoreGlobal.RO.Error("TcpRelay: Exception while handling a new connection: "+e.Message);
                    }

                    //process existing connections
                    foreach (Connection c in connections)
                    {
                        try
                        {
                            //check connectedness
                            if (!c.local.Connected)
                            {
                                c.remote.Close();
                                connections.Remove(c);
                                continue;
                            }

                            if (!c.remote.Connected)
                            {
                                c.local.Close();
                                connections.Remove(c);
                                continue;
                            }

                            //relay local to remote
                            if (c.local.Available>0)
                            {
                                byte []inData=new byte[c.local.Available];
                                c.local.Receive(inData);
                                byte []outData;
                                ProcessData(c, true, inData, out outData);

                                if (verbose)
                                {
                                    CoreGlobal.RO.Debug("Outbound data: "+outData.Length+" bytes.");
                                }

                                c.remote.Send(outData);
                            }

                            //relay remote to local
                            if (c.remote.Available>0)
                            {
                                byte []inData=new byte[c.remote.Available];
                                c.remote.Receive(inData);
                                byte []outData;
                                ProcessData(c, false, inData, out outData);

                                if (verbose)
                                {
                                    CoreGlobal.RO.Debug("Inbound data: "+outData.Length+" bytes.");
                                }

                                c.local.Send(outData);
                            }
                        }
                        catch (Exception e)
                        {
                            CoreGlobal.RO.Error("TcpRelay: Exception while processing existing connection: "+e.Message);
                        }
                    }
                }
            }
        }

        // -- private data

        IPAddress targetAddr;
        ushort targetPort;
        ushort localPort;

        Socket listener;
        object listenerThreadLock=new object();

        LinkedList<Connection> connections=new LinkedList<Connection>();

        bool verbose=false;

        #endregion //Internals
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\TimedQueue.cs ===
using System;
using System.Collections.Generic;

#pragma warning disable 0420 //a reference to a volatile field will not be treated as volatile

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// A queue that will only return items placed in it after a certain amount of time has elapsed for that item.
    /// This queue is thread-safe.
    /// </summary>
    public class TimedQueue<ObjectType>
    {
        /// <summary>
        /// A object placed in the queue will never be returned until at least this amount of time has passed.
        /// </summary>
        public TimeSpan MinimumReuseTime=new TimeSpan(0,0,0);

        /// <summary>
        /// Minumum number of objects to keep in the cache at any given time before any can be returned.
        /// </summary>
        public uint MinimumQueueSize=0;

        /// <summary>
        /// Maximum number of entries to allow into the queue, after which more more are ignored.
        /// </summary>
        public uint MaximumQueueSize=uint.MaxValue;

        /// <summary>
        /// Returns the number of objects in the queue.
        /// </summary>
        public uint Count
        {
            get {return (uint)cache.Count+(uint)cachedReadyListCount;}
        }

        /// <summary>
        /// Pre-caches a list of ready objects so they can be popped without a lock.
        /// The downside is if settings are changed, any objects in the cache that do not comply with the new settings will be returned.
        /// </summary>
        public bool UseCachedReadyList=true;

        /// <summary>
        /// Returns an object from the queue that is older than MinimumReuseTime.
        /// If no object is old enough, then null or 0 is returned.
        /// </summary>
        public ObjectType PopFront()
        {
            //first see if we can grab some from the cached ready list, so we don't have to take the lock
            ObjectType obj=PopFromReadyCache();
            if (obj!=null && !obj.Equals(default(ObjectType)))
            {
                return obj;
            }

            //none were ready, so take the lock
            lock (cache)
            {
                //check the cache again, as someone may have held the lock before us and already refilled it
                obj=PopFromReadyCache();
                if (obj!=null && !obj.Equals(default(ObjectType)))
                {
                    return obj;
                }

                //refill the ready cache
                int newCacheCount=0;
                while (newCacheCount<cachedReadyList.Length && Count>MinimumQueueSize && (DateTime.UtcNow-cache.First.Value.LastUseTime)>MinimumReuseTime)
                {
                    ObjectType ret=cache.First.Value.Object;
                    cache.RemoveFirst();

                    cachedReadyList[newCacheCount]=ret;
                    ++newCacheCount;
                }

                ++cachedReadyCycle;
                cachedReadyListCount=newCacheCount; //this "activates" the new ready list (since before it was 0)
            }

            //none were ready
            return PopFromReadyCache();
        }

        //pops an item from the lockless already-ready cache if possible, else returns 0 or null
        private ObjectType PopFromReadyCache()
        {
            while (UseCachedReadyList)
            {
                //here is what we think we are using
                int cycleISaw=cachedReadyCycle;
                int countISaw=cachedReadyListCount;
                if (countISaw<=0)
                {
                    break;
                }

                int cacheUseIndex=countISaw-1;
                ObjectType cacheUseEntry=cachedReadyList[cacheUseIndex];

                if (cachedReadyCycle!=cycleISaw)
                {
                    continue;
                }

                //now try to change the count to "say we are using it"
                int whatWasThere=System.Threading.Interlocked.CompareExchange(ref cachedReadyListCount, countISaw-1, countISaw);
                if (whatWasThere==countISaw)
                {
                    return cacheUseEntry;
                }
            }

            //none in cache
            return default(ObjectType);
        }

        /// <summary>
        /// Adds an object to the queue.  Returns false if the queue was full.
        /// </summary>
        public bool PushBack(ObjectType obj)
        {
            QueueEntry ce=new QueueEntry();
            ce.LastUseTime=DateTime.UtcNow;
            ce.Object=obj;

            lock (cache)
            {
                if (Count<MaximumQueueSize)
                {
                    cache.AddLast(ce);
                    return true;
                }
            }

            return false;
        }

        //internals
        private class QueueEntry
        {
            public DateTime    LastUseTime;
            public ObjectType  Object;
        };

        LinkedList<QueueEntry> cache=new LinkedList<QueueEntry>(); //the main queue

        ObjectType []cachedReadyList=new ObjectType[100]; //objects pre-pulled from the front of the queue that are ready to be returned now
        volatile int cachedReadyListCount=0;
        volatile int cachedReadyCycle=0;
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\SubStatic.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Reflection;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Used to make class variables class-static, as in each inherited subclass has it's own static instance of the class 
    /// variable.  Normally, when a field is static in a base class, all subclasses share one instance of this field.  
    /// Sometimes it is important that each subclass of a particular base class each have its own instance.
    /// 
    /// To use:
    ///    - Pick a field in a base class for which you want a static instance per sub class.
    ///    - Add a [SubStatic] attribute to that field.
    ///    - Call SubStatics.Initialize(this) in the constructor for the base class.
    ///    
    ///    If the constructor for this field type requires parameters, adjust them on the SubStaticAttribute.
    ///    Example:
    ///      [SubStatic(ParameterTypes=new Type[] {typeof(int)}, Parameters=new object[] {2})]
    /// </summary>
    public class SubStatics
    {
        private static Hashtable ht = new Hashtable();

        /// <summary>
        /// Initialize should be called in the constructor of any class that has SubStaticAttributes so that they are 
        /// actually initialized or set into the appropriate fields.
        /// </summary>
        /// <param name="target">A reference to the class containing fields with SubStaticAttributes.  Usually the "this" 
        /// keyword.</param>
        static public void Initialize(object target)
        {
            Type targetType = target.GetType();
            FieldInfo[] fields = target.GetType().GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

            for (int i = 0; i < fields.Length; i++)
            {
                FieldInfo field = fields[i];
                Attribute attr = Attribute.GetCustomAttribute(field, typeof(SubStaticAttribute), true);
                if (attr != null)
                {
                    object item = GetStatic(target.GetType(), field, (SubStaticAttribute)attr);

                    field.SetValue(target, item);
                }
            }
        }

        /// <summary>
        /// Use this function to get a SubStatic from a class without having to create an instance of the class.
        /// </summary>
        /// <param name="owner">The type of the class that contains the SubStatic.</param>
        /// <param name="fieldName">The field name of the SubStatic item you are interested in.</param>
        /// <returns>The SubStatic instance for the supplied field</returns>
        public static object GetStatic(Type owner, string fieldName)
        {
            return GetStatic(owner, (FieldInfo)owner.GetMember(fieldName)[0], null);
        }

        private static object GetStatic(Type owner, FieldInfo field, SubStaticAttribute attr)
        {
            // Check to see if this SubStatic has already been created.

            lock (ht)
            {
                object item = ht[GetFieldHash(owner, field)];
                if (item != null)
                    return item;

                // Query construction info from the field
                if (attr == null)
                {
                    attr = (SubStaticAttribute)Attribute.GetCustomAttribute(field, typeof(SubStaticAttribute), true);
                    if (attr == null)
                        throw new Exception("Field does not have a SubStaticAttribute.");
                }

                // Create the object of type "type"
                ConstructorInfo ci = field.FieldType.GetConstructor(attr.ParameterTypes);
                if (ci == null)
                    throw new Exception("Constructor with given types not found.");

                item = ci.Invoke(attr.Parameters);
                ht[GetFieldHash(owner, field)] = item;

                return item;
            }
        }

        public static void SetStatic(Type owner, string fieldName, object item)
        {
            SetStatic(owner, (FieldInfo)owner.GetMember(fieldName)[0], item);
        }

        private static void SetStatic(Type owner, FieldInfo field, object item)
        {
            lock (ht)
            {
                Debug.Assert(Attribute.GetCustomAttribute(field, typeof(SubStaticAttribute), true) as SubStaticAttribute != null);
                Debug.Assert(field.FieldType == item.GetType());

                ht[GetFieldHash(owner, field)] = item;
                field.SetValue(owner, item);
            }
        }

        static private string GetFieldHash(Type owner, FieldInfo field)
        {
            return owner.FullName + "." + field.Name;
        }
    }

    /// <summary>
    /// Add this attribute to a field to make it SubStatic.
    /// ParameterTypes and Parameters are nescessary to use when constructor for the SubStatic field has parameters
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple=false, Inherited=true)]
    public class SubStaticAttribute : Attribute
    {
        /// <summary>
        /// Array of the parameter types for the constructor of the SubStatic type.
        /// </summary>
        public Type[] ParameterTypes = Type.EmptyTypes;

        /// <summary>
        /// Array of the parameters for the constructor of the SubStatic type.
        /// </summary>
        public object[] Parameters = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\ValueCheck.cs ===
using System;
using System.Text;

namespace ServerTestFramework.Core.Utilities
{
    /// <summary>
    /// Contains a large number of helper function for validating a variety of condtions
    /// such as whether two objects are equivalent, greater than, or less than, or if a 
    /// result is one of any possible valid results.  
    /// 
    /// All the methods throw ExpectedValueCheckExceptions when the checks fail.
    /// </summary>
    public class ValueCheck
    {
        /// <summary>
        /// Tests whether the given condition is true
        /// </summary>
        /// <param name="cond">The condition to test</param>
        /// <param name="msg">A descriptive message of the check being performed</param>
        public static void IsTrue(Boolean cond, String msg)
        {
            if (!cond) throw new ExpectedValueCheckException("Condition check failed.  Expected True. " + msg);
        }

        /// <summary>
        /// Tests whether the given condition is true
        /// </summary>
        /// <param name="cond">The condition to test</param>
        /// <param name="msg">A descriptive format string of the check being performed</param>
        /// <param name="args">Parameters to be passed to the format</param>
        public static void IsTrue (Boolean cond, String msg, params object[] args)
        {
            if (!cond) throw new ExpectedValueCheckException("Condition check failed.  Expected True. " + string.Format(msg, args));
        }

        /// <summary>
        /// Tests whether the given condition is false
        /// </summary>
        /// <param name="cond">The condition to test</param>
        /// <param name="msg">A descriptive message of the check being performed</param>
        public static void IsFalse(Boolean cond, String msg)
        {
            if (cond) throw new ExpectedValueCheckException("Condition check failed. Expected False. " + msg);
        }

        /// <summary>
        /// Tests whether the given condition is false
        /// </summary>
        /// <param name="cond">The condition to test</param>
        /// <param name="msg">A descriptive format string of the check being performed</param>
        /// <param name="args">Parameters to be passed to the format</param>
        public static void IsFalse (Boolean cond, String msg, params object[] args)
        {
            if (cond) throw new ExpectedValueCheckException("Condition check failed. Expected False. " + string.Format(msg, args));
        }

        /// <summary>
        /// Tests whether two objects of the same type are equivalent.
        /// </summary>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="exp">The expected value</param>
        /// <param name="got">The actual value</param>
        public static void Test<T1, T2>(String msg, T1 exp, T2 got)
        {
            // If they're both null, then they are equal
            if (exp == null && got == null)
            {
                return;
            }

            // If one is null or they are not not equal, then throw
            if (exp == null || got == null)
            {
                throw new ExpectedValueCheckException(msg, exp, got);
            }

            Object objA = exp;
            Object objB = null;

            if (typeof(T1) == typeof(T2))
            {
                objB = got;
            }
            else
            {
                try
                {
                    objB = System.Convert.ChangeType(got, typeof(T1));
                }
                catch
                {
                    // We couldn't convert got to type T1
                    // Try converting exp to type T2
                    objA = got;
                    objB = System.Convert.ChangeType(exp, typeof(T2));
                }
            }

            // If one is null or they are not not equal, then throw
            if (!objA.Equals(objB))
            {
                throw new ExpectedValueCheckException(msg, exp, got);
            }
        }

        /// <summary>
        /// Tests whether every byte in the two arrays is equivalent.
        /// </summary>
        /// <param name="msg">A dsecriptive message fo the check being performed</param>
        /// <param name="expected">The array of expected values</param>
        /// <param name="got">The array of actual values</param>
        public static void Test(String msg, Byte[] expected, Byte[] got)
        {
            TestAll(msg, expected, got);
        }

        /// <summary>
        /// Verifies that the actual time is approximately equal to the expected 
        /// time within a given tolerance.
        /// </summary>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="expected">The expected time</param>
        /// <param name="got">The actual time</param>
        /// <param name="tolerance">The tolerance for a match</param>
        public static void Test(String msg, DateTime? expected, DateTime? got, TimeSpan tolerance)
        {
            if (expected == null && got == null)
            {
                return;
            }
            else if ((expected == null && got != null) || (expected != null && got == null))
            {
                throw new ExpectedValueCheckException(msg, expected, got);
            }
            else if (expected.HasValue && got.HasValue && ((expected.Value - got.Value).Duration() > tolerance.Duration()))
            {
                String formattedMsg = String.Format("{0}. Expected: {1}(+-{2}), Got: {3}",
                    msg, expected, tolerance, got);
                throw new ExpectedValueCheckException(formattedMsg);
            }
        }

        /// <summary>
        /// Verifies that the actual timespan is approximately equal to the expected 
        /// time within a given tolerance.
        /// </summary>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="expected">The expected time</param>
        /// <param name="got">The actual time</param>
        /// <param name="tolerance">The tolerance for a match</param>
        public static void Test(String msg, TimeSpan? expected, TimeSpan? got, TimeSpan tolerance)
        {
            if (expected == null && got == null)
            {
                return;
            }
            else if ((expected == null && got != null) || (expected != null && got == null))
            {
                throw new ExpectedValueCheckException(msg, expected, got);
            }
            else if (expected.HasValue && got.HasValue && ((expected.Value - got.Value).Duration() > tolerance.Duration()))
            {
                String formattedMsg = String.Format("{0}. Expected: {1}(+-{2}), Got: {3}",
                    msg, expected, tolerance, got);
                throw new ExpectedValueCheckException(formattedMsg);
            }
        }

        /// <summary>
        /// Verifies that two objects of the same type are different.
        /// </summary>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="exp">The value that should not be</param>
        /// <param name="got">The actual value</param>
        public static void TestDifferent<T1, T2>(String msg, T1 exp, T2 got)
        {
            // If they're both null, then they are equal
            if (exp == null && got == null)
            {
                throw new ExpectedNotValueCheckException(msg, exp, got);
            }

            // If one is null or they are not not equal, then they are different
            if (exp == null || got == null)
            {
                return;
            }

            Object objA = exp;
            Object objB = null;

            if (typeof(T1) == typeof(T2))
            {
                objB = got;
            }
            else
            {
                try
                {
                    objB = System.Convert.ChangeType(got, typeof(T1));
                }
                catch
                {
                    // We couldn't convert got to type T1
                    // Try converting exp to type T2
                    objA = got;
                    objB = System.Convert.ChangeType(exp, typeof(T2));
                }
            }

            // If are equal, then throw
            if (objA.Equals(objB))
            {
                throw new ExpectedNotValueCheckException(msg, exp, got);
            }
        }

        /// <summary> Verifies that the actual time is approximately not equal to the expected time within a given tolerance. </summary>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="expected">The expected time</param>
        /// <param name="got">The actual time</param>
        /// <param name="tolerance">The tolerance for a match</param>
        public static void TestDifferent(String msg, DateTime? expected, DateTime? got, TimeSpan tolerance)
        {
            if (expected==null && got==null)
            {
                throw new ExpectedNotValueCheckException(string.Format("{0}. Expected not null, got null.", msg));
            }
            else if ((expected==null && got!=null) || (expected!=null && got==null))
            {
                return;
            }
            else if (expected.HasValue && got.HasValue && ((expected.Value-got.Value).Duration()<=tolerance.Duration()))
            {
                throw new ExpectedNotValueCheckException(string.Format("{0}. Expected not: {1}(+-{2}), Got: {3}", msg, expected, tolerance, got));
            }
        }

        /// <summary>
        /// Checks that the arrays each array is the same length and that each 
        /// item in the arrays is the same.
        /// </summary>
        /// <param name="name">The name of the item that's being tested</param>
        /// <param name="expected">The array of expected values</param>
        /// <param name="got">The array of actual values</param>
        public static void TestAll(string name, Array expected, Array got)
        {
            if (expected.Length != got.Length)
            {
                throw new ExpectedValueCheckException(name, "Length " + expected.Length, "Length " + got.Length);
            }

            //collect all the indexes that are wrong, then throw it all at the end
            string exceptionText="";
            for (int i = 0; i < expected.Length; i++)
            {
                if (!expected.GetValue(i).Equals(got.GetValue(i)))
                {
                    exceptionText+=(String.Format("{0}. Index: {1} Expected: {2}, Got: {3}", name, i, expected.GetValue(i), got.GetValue(i)))+"\n";
                }
            }

            if (exceptionText!="")
            {
                throw new ExpectedValueCheckException(exceptionText);
            }
        }

        /// <summary> Checks that each array does not contain exactly the same set of elements (that they are different lengths or that at least one element is different). </summary>
        /// <param name="name">The name of the item that's being tested</param>
        /// <param name="expected">The array of expected values</param>
        /// <param name="got">The array of actual values</param>
        public static void TestNotAll(string name, Array expected, Array got)
        {
            if (expected.Length!=got.Length)
            {
                return;
            }

            //collect all the indexes that are wrong, then throw it all at the end
            for (int i=0; i<expected.Length; ++i)
            {
                if (!expected.GetValue(i).Equals(got.GetValue(i)))
                {
                    return;
                }
            }

            throw new ExpectedNotValueCheckException(name+": All array elements are unexpectedly identical.");
        }

        /// <summary>
        /// Checks that the arrays each array is the same length and that each 
        /// item in the arrays is the same.
        /// </summary>
        /// <param name="name">The name of the item that's being tested</param>
        /// <param name="expected">The array of expected values</param>
        /// <param name="got">The array of actual values</param>
        public static void TestSubset (string name, Array expected, uint expStart, Array got, uint gotStart, uint count)
        {
            if (count == 0)
            {
                throw new ExpectedValueCheckException("Count is 0.  This seems strange.");
            }

            if (((uint)expected.Length) <= expStart || ((uint)expected.Length) < (expStart + count))
            {
                throw new ExpectedValueCheckException("Expected subset is outside of the expected array.");
            }

            if (((uint)got.Length) <= gotStart || ((uint)got.Length) < (gotStart + count))
            {
                throw new ExpectedValueCheckException("Got subset is outside of the got array.");
            }

            //collect all the indexes that are wrong, then throw it all at the end
            string exceptionText = "";
            for (uint i = 0; i < count; i++)
            {
                if (!expected.GetValue(expStart + i).Equals(got.GetValue(gotStart + i)))
                {
                    exceptionText += String.Format("{0}. Index: {1}|{2} Expected: {3}, Got: {4}\n", name, expStart + i, gotStart + i, 
                        expected.GetValue(i), got.GetValue(i));
                }
            }

            if (exceptionText != "")
            {
                throw new ExpectedValueCheckException(exceptionText);
            }
        }

        /// <summary>
        /// Tests whether or not the actual value matches any of the expected values
        /// </summary>
        /// <typeparam name="T">The type of value to check</typeparam>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="exp">The array of possible expected values</param>
        /// <param name="got">The actual result value</param>
        public static void TestAny<T>(String msg, T[] exp, T got)
        {
            foreach (T t in exp)
            {
                if (t.Equals(got))
                {
                    return;
                }
            }

            StringBuilder sb = new StringBuilder(msg);
            sb.Append(". Expected Any: ");
            foreach (T t in exp)
            {
                sb.Append(t);
                sb.Append(", ");
            }

            sb.Remove(sb.Length - 2, 2);
            sb.Append("; Got: ");
            sb.Append(got);

            throw new ExpectedValueCheckException(sb.ToString());
        }

        public delegate bool TestAllUnorderedComparison<T>(T l, T r);
        public delegate string TestAllUnorderedStringer<T>(T o);

        /// <summary> Validates that two unordered sets contain the same set of elements using a specific comparison function and a specific function to convert the object to a string. </summary>
        public static void TestAllUnordered<T>(string msg, System.Collections.Generic.IEnumerable<T> expect, System.Collections.Generic.IEnumerable<T> got, TestAllUnorderedComparison<T> comparer, TestAllUnorderedStringer<T> stringer)
        {
            if (got==null && expect==null)
            {
                return;
            }

            if (got==null || expect==null)
            {
                throw new UnexpectedTestResultException("Expected "+(expect!=null?"Non-null":"null")+", Got "+((got!=null?"Non-null":"null")));
            }

            System.Collections.Generic.LinkedList<T> extraGot=new System.Collections.Generic.LinkedList<T>();
            foreach (T g in got)
            {
                extraGot.AddLast(g);
            }

            string missingList="";
            foreach (T exp in expect)
            {
                bool found=false;
                foreach (T extra in extraGot)
                {
                    if (comparer(extra, exp))
                    {
                        extraGot.Remove(extra);
                        found=true;
                        break;
                    }
                }

                if (!found)
                {
                    missingList+="Expected to find in list: "+stringer(exp)+"\n";
                }
            }

            string extrasList="";
            if (extraGot.Count>0)
            {
                foreach (T e in extraGot)
                {
                    extrasList+="Extra found in list: "+stringer(e)+"\n";
                }
            }

            if (missingList.Length>0 || extrasList.Length>0)
            {
                throw new UnexpectedTestResultException(msg+"\n"+missingList+extrasList);
            }
        }

        public static string TestAllUnorderedDefaultStringer<T>(T obj)
        {
            if (obj==null)
            {
                return "<null>";
            }

            return obj.ToString();
        }

        /// <summary> Validates that two unordered sets contain the same set of elements using a specific comparison function. </summary>
        public static void TestAllUnordered<T>(string msg, System.Collections.Generic.IEnumerable<T> expect, System.Collections.Generic.IEnumerable<T> got, TestAllUnorderedComparison<T> comparer)
        {
            TestAllUnordered(msg, expect, got, comparer, TestAllUnorderedDefaultStringer);
        }

        public static bool TestAllUnorderedDefaultEquals<T>(T left, T right)
        {
            return left.Equals(right);
        }

        /// <summary> Validates that two unordered sets contain the same set of elements. </summary>
        public static void TestAllUnordered<T>(string msg, System.Collections.Generic.IEnumerable<T> expect, System.Collections.Generic.IEnumerable<T> got)
        {
            TestAllUnordered(msg, expect, got, TestAllUnorderedDefaultEquals);
        }

        /// <summary>
        /// Tests if the value is equal to it's default value.  For most numeric types, this
        /// is 0.  For reference types this is null.  For other value types it is default(Type)
        /// </summary>
        /// <typeparam name="T">The type of the value to check.  default(T) is used to compare</typeparam>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="value">The value to check</param>
        public static void TestZero<T>(String msg, T value)
        {
            if (!value.Equals(default(T))) throw new ExpectedValueCheckException(String.Format("{0}, {1} should be zero", msg, value));
        }

        /// <summary>
        /// Tests if the value is not equal to it's default value.  For most numeric types, this
        /// is 0.  For reference types this is null.  For other value types it is default(Type)
        /// </summary>
        /// <typeparam name="T">The type of the value to check.  default(T) is used to compare</typeparam>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="value">The value to check</param>
        public static void TestNonZero<T>(String msg, T value)
        {
            if (value.Equals(default(T))) throw new ExpectedValueCheckException(String.Format("{0}, {1} should not be zero", msg, value));
        }
        /// <summary>
        /// Tests if a given dictionary contains a key within it. Useful for cases where an 
        /// item missing from a dictionary means we need to halt the test case.
        /// </summary>
        /// <typeparam name="T1">First type of the dictionary.</typeparam>
        /// <typeparam name="T2">Second type of the dictionary</typeparam>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="dict">The dictionary object.</param>
        /// <param name="key">Key to validate.</param>
        public static void ContainsKey<T1, T2>(String msg, System.Collections.Generic.Dictionary<T1, T2> dict, T1 key)
        {
            if (!dict.ContainsKey(key))
                throw new ExpectedValueCheckException(String.Format("{0}, key \"{1}\" was not present.", msg, key.ToString()));
        }

        /// <summary>
        /// Tests whether the actual value is greater than the expected value
        /// </summary>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="expected">The expected value to check against</param>
        /// <param name="got">The actual value</param>
        public static void TestGreaterThan(String msg, IComparable exp, Object got)
        {
            if (exp == null && got == null)
            {
                return;
            }

            if (exp == null || got == null || exp.CompareTo(got) >= 0)
            {
                throw new ExpectedValueCheckException("Expected Greater Than" + msg, exp, got);
            }
        }

        /// <summary>
        /// Tests whether the actual value is less than the expected value
        /// </summary>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="expected">The expected value to check against</param>
        /// <param name="got">The actual value</param>
        public static void TestLessThan(String msg, IComparable exp, Object got)
        {
            if (exp == null && got == null)
            {
                return;
            }

            if (exp == null || got == null || exp.CompareTo(got) <= 0)
            {
                throw new ExpectedValueCheckException("Expected Less Than" + msg, exp, got);
            }
        }

        /// <summary>
        /// Tests whether the provided object is non-null
        /// </summary>
        /// <param name="name">The name of the object to test</param>
        /// <param name="o">The object to test</param>
        public static void TestNotNull(String name, Object o)
        {
            if (o == null) throw new ExpectedValueCheckException(name + " cannot be null");
        }

        /// <summary>
        /// Tests whether the provided object is null
        /// </summary>
        /// <param name="name">The name of the object to test</param>
        /// <param name="o">The object to test</param>
        public static void TestNull(String name, Object o)
        {
            if (o != null) throw new ExpectedValueCheckException(name + " must be null");
        }

        /// <summary>
        /// Validates that all of the expected bits are set in the actual value
        /// </summary>
        /// <param name="msg">A descriptive message of the check being performed</param>
        /// <param name="expected">The set of expected bits</param>
        /// <param name="got">The actual result bits</param>
        /// <remarks>
        /// It would be nice if this could be expanded to other numeric types, 
        /// but there's no easy way to provide a comprehensive suite of methods
        /// for all the different numeric types.
        /// </remarks>
        public static void TestBits(string msg, uint expected, uint got)
        {
            if (expected != (expected & got))
            {
                throw new ExpectedValueCheckException(msg, "0x" + expected.ToString("X"), "0x" + got.ToString("X"));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\XmlFileReportDestination.cs ===
using System;
using System.IO;
using System.Xml;

namespace ServerTestFramework.Utilities
{
    public class XmlFileReportDestination : InfiniteLifetimeMarshalByRefObject, Report.Destination
    {
        private readonly string _filename;
        private XmlWriter _writer;
        private FileStream _stream;
        private bool _finished;

        public string Filename
        {
            get { return _filename; }
        }

        private void Initialize()
        {
            string path = Path.GetDirectoryName(Filename);

            if (path.Length > 0 && !Directory.Exists(path))
                Directory.CreateDirectory(path);

            XmlWriterSettings settings = new XmlWriterSettings();
            settings.CheckCharacters = false;
            settings.ConformanceLevel = ConformanceLevel.Fragment;
            settings.OmitXmlDeclaration = true;

            _stream = new FileStream(Filename, FileMode.Create);
            _writer = XmlWriter.Create(_stream, settings);
            _writer.WriteStartElement("Report");
            _writer.WriteRaw("\r\n");
            _finished = false;

            string testName;
            ThreadTracker.GetTest(out testName);
            Log(Report.INFO, "", Filename + ": stream opened for logging", testName, System.DateTime.Now);
        }

        public XmlFileReportDestination(string filename)
        {
            _filename = filename;
            Initialize();
        }

        public XmlFileReportDestination(string path, string filename, DateTime dt)
        {
            _filename = String.Format(
                path + "\\{0}-{1}-{2}-{3}-{4}-{5}-{6}.txt",
                filename,
                dt.Year,
                dt.Month,
                dt.Day,
                dt.Hour,
                dt.Minute,
                dt.Second
                );
            Initialize();
        }

        ~XmlFileReportDestination()
        {
            Close();
        }

        // Implemented from Report.Destination
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            lock (this)
            {
                if (!_finished && _writer != null && _writer.WriteState != WriteState.Closed)
                {
                    _writer.WriteStartElement("LogEntry");
                    _writer.WriteAttributeString("Date", date.ToString());
                    _writer.WriteAttributeString("Path", path);
                    _writer.WriteAttributeString("Test", testName);
                    _writer.WriteCData(message);
                    _writer.WriteEndElement();
                    _writer.WriteRaw("\r\n");
                    _writer.Flush();
                }
            }
        }

        public void FinishXml()
        {
            lock (this)
            {
                if (!_finished)
                {
                    _finished = true;
                    _writer.WriteEndElement();
                }
            }
        }

        public void Close()
        {
            lock (this)
            {
                if (_writer != null && _writer.WriteState != WriteState.Closed)
                {
                    if (!_finished)
                        FinishXml();

                    _writer.Close();
                    _writer = null;
                }

                if (_stream != null)
                {
                    _stream.Close();
                    _stream.Dispose();
                    _stream = null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\BlockUtil.cs ===
using System;
using System.Collections.Generic;

namespace ServerTestFramework
{
    public class XeGenericBlock : WireData
    {
        public const int BLOCK_MAX_LEN = 3000;

        public ushort blockLength;

        [WireInfo(SizeParam="blockLength")]
        public byte[] block;
    }

    public class BlockSerializer
    {
        public BlockSerializer(byte[] bytes, int minBlocks, int maxBlocks)
        {
            _bytes = bytes;
            if (minBlocks > maxBlocks)
            {
                throw new ArgumentException("minBlocks cannot be greater than maxBlocks");
            }
            _minBlocks = minBlocks;
            _maxBlocks = maxBlocks;
            _blockCount = (bytes.Length - 1) / MAX_BLOCK_LEN + 1;
        }

        public bool IsEmptyBlockCount
        {
            get
            {
                return _bytes.Length == 0;
            }
        }

        public bool IsBlockCountOutOfRange
        {
            get
            {
                return _blockCount < _minBlocks || _blockCount > _maxBlocks;
            }
        }

        public XeGenericBlock[] Serialize()
        {
            if (IsEmptyBlockCount || IsBlockCountOutOfRange)
            {
                throw new Exception("Cannot serialize the bytes into a XeGenericblock--you should do verification with IsEmptyBlockCount and IsBlockCountOutOfRange.");
            }

            int lastBlockLen = _bytes.Length % MAX_BLOCK_LEN;

            XeGenericBlock[] blocks = new XeGenericBlock[_blockCount];

            for (int i = 0; i < _blockCount; ++i)
            {
                int thisBlockLen = 0;
                if (i == _blockCount - 1)
                {
                    thisBlockLen = lastBlockLen;
                }
                else
                {
                    thisBlockLen = MAX_BLOCK_LEN;
                }
                blocks[i] = new XeGenericBlock();
                blocks[i].blockLength = (ushort)thisBlockLen;
                blocks[i].block = new byte[thisBlockLen];
                Array.Copy(_bytes, i * MAX_BLOCK_LEN, blocks[i].block, 0, thisBlockLen);
            }

            return blocks;
        }

        private readonly byte[] _bytes;
        private readonly int _minBlocks;
        private readonly int _maxBlocks;
        private readonly int _blockCount;

        private const int MAX_BLOCK_LEN = XeGenericBlock.BLOCK_MAX_LEN;
    }

    public class BlockDeserializer
    {
        public BlockDeserializer(XeGenericBlock[] blocks)
        {
            _blocks = blocks;
        }

        public byte[] Deserialize()
        {
            List<byte> listBytes = new List<byte>();
            foreach (XeGenericBlock block in _blocks)
            {
                listBytes.AddRange(block.block);
            }
            return listBytes.ToArray();
        }

        private readonly XeGenericBlock[] _blocks;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\AttrExceptsLive.cs ===
//live-specific attributes and exceptions

using System;
using ServerTestFramework.LiveService;

namespace ServerTestFramework
{
    /// <summary>
    /// Same as UnexpectedTestResult from the core, only with an xrl.
    /// </summary>
    public class UnexpectedXRLTestResultException : UnexpectedTestResultException
    {
        public XRLPayload xrl=null;
        public UnexpectedXRLTestResultException() : base() {}
        public UnexpectedXRLTestResultException(string message) : base(message) {}
        public UnexpectedXRLTestResultException(string message, Exception inner) : base(message, inner) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\XmlConfigFile.cs ===
using System;
using System.Xml;

namespace ServerTestFramework.Utilities
{
	// Version 1.2
	// Added the ability to specify keywords in XML file that get substituted when
	// reading it.  For example, reading this node from a machine named foo:
	// <username>%MACHINE%\someguy</username>
	// will actually return foo\someguy.
	// 
	// The keywords that can be interpreted are:
	//  o %MACHINE% -- the user's machine
	//  o %USERNAME% -- the user's name
	//  o %USERDOMAIN% -- the user's domain
	//
	// Version 1.1.
	// This version adds the ability to set an environment variable that determines
	// which branch of the XML config file to read.  To do this you must set the
	// environ tag to autodetect and set XMLCONFIG_ENV to either the name of the
	// branch you want to use.
	// 
	// You can also override any behavior by using passing 
	//		xmlconfig:[environment_name]
	//	at the command line.
	// 
	// This class facilitates the reading of an XML config file that contains
	// data that depends on the enviroment that it is running againt.  For
	// example: usernames may be different in TestNet vs. PreProd vs. BVTNet,
	// etc.
	// 
	// The format of the XML file is expected to be as such:
	// <config>
	//      <environ>[EnvironmentName]</environ>
	//      <[EnvironmentName1]>
	//           <value1></value1>
	//           <value2></value2>
	//           <value3></value3>
	//      </[EnvironmentName1]>
	//      <[EnvironmentName2]>
	//           <value1></value1>
	//           <value2></value2>
	//           <value3></value3>
	//      </[EnvironmentName2]>
	// </config>
	//
	// A practical example would be:
	// <config>
	//      <environ>TestNet</environ>
	//      <TestNet>
	//           <username>TestUser</username>
	//      </TestNet>
	//      <PreProd>
	//           <username>PreProdUser</username>
	//      </PreProd>
	// </config>
	//
	// If you need to read data that's in the same file but not environment 
	// dependent, you can use the ReadNode method.
	// 
	// Note that at this time, it only read XML innertext and not any of
	// the properties.
	// 
	// email massloi with questions, comments, etc...
	public class XmlConfigFile
	{
		// P R I V A T E   M E M B E R S //////////////////////////////////////
		private XmlDocument _Doc = null;
		private string _Environment = null;

		// P U B L I C   M E M B E R S ////////////////////////////////////////

		/// <summary>
		/// Constructor reads in the config file and determines the environment
		/// to run on based on the "environ" tag
		/// </summary>
		/// <param name="Filename">name of the config file</param>
		public XmlConfigFile (string Filename)
		{
			// Load the file
			_Doc = new XmlDocument ();
			_Doc.Load (Filename);

			// Firstly, if the command xmlconfig:[environment] was passed to 
			// the command line, override what's in the XML file
			foreach (string sArg in Environment.GetCommandLineArgs ())
			{
				// Is it ours?
				if (sArg.IndexOf ("xmlconfig") != -1)
				{
					// Good, we got it.  Now split it at the :
					string [] sCommands = sArg.Split (":".ToCharArray ());

					// Set the environment
					_Environment = "/config/" + sCommands[1];
				}
			}

			// Do this if we have no command line args
			if (null == _Environment)
			{
				// Read in the environment
				XmlNode xmlEnvironment;
				string sEnvironment;
				xmlEnvironment = _Doc.SelectSingleNode ("/config/environ");
				if (null != xmlEnvironment)
					sEnvironment = xmlEnvironment.InnerText;
				else
					throw new XmlException ("Could not determine which environment to read");

				// Do we check the XMLCONFIG_ENV environment variable or use what
				// we already have?
				if (String.Compare (sEnvironment, 0, "autodetect", 0, sEnvironment.Length, true) == 0)
				{
					sEnvironment = Environment.GetEnvironmentVariable ("XMLCONFIG_ENV");
					if (null == sEnvironment)
						throw new XmlException ("XML file set to autodetect, but XMLCONFIG_ENV was not a valid environment variable");
				}
			
				// Create the environment path
				_Environment = "/config/" + sEnvironment;
			}
		}

		/// <summary>
		/// Accessor method used to read the needed data, it automatically takes care of
		/// reading from the right environment.  It's used like this:
		/// 
		/// XmlConfigFile Config = new Config ("MyConfigFile.xml");
		/// string SomeSetting = Config["/Auth/Username"];
		/// 
		/// </summary>
		public string this [string NodeName]
		{
			get
			{
				// make sure there's a leading '/'
				if (NodeName[0] != '/')
					NodeName = "/" + NodeName;
				return ReadNode (_Environment + NodeName);
			}
		}

		/// <summary>
		/// Method used to read the needed data
		/// </summary>
		/// <param name="NodeName">name of the config file</param>
		/// <returns>The node's inner text</returns>
		public string ReadNode (string NodeName)
		{
			// Make sure that the XmlDocument's intialized and loaded
			if (null == _Doc)
				throw new XmlException ("XmlConfigFile not intialized");

			// Read in the wanted node
			XmlNode xmlData = _Doc.SelectSingleNode (NodeName);
			if (null == xmlData)
				throw new XmlException ("Cannot read " + NodeName + " in " + _Environment);
			else
				return _Parse (xmlData.InnerText);
		}

		/// <summary>
		/// Searches the given string for following keywords and substitutes them:
		///  o %MACHINE% -- the user's machine
		///  o %USERNAME% -- the user's name
		///  o %USERDOMAIN% -- the user's domain
		/// </summary>
		/// <param name="InnerText"></param>
		/// <returns></returns>
		protected string _Parse (string InnerText)
		{
			// Computer Name?
			if (InnerText.IndexOf ("%MACHINE%") > -1)
			{
				InnerText = InnerText.Replace ("%MACHINE%", Environment.MachineName);
			}

			// User Name?
			if (InnerText.IndexOf ("%USERNAME%") > -1)
			{
				InnerText = InnerText.Replace ("%USERNAME%", Environment.UserName);
			}

			// User Domain?
			if (InnerText.IndexOf ("%USERDOMAIN%") > -1)
			{
				InnerText = InnerText.Replace ("%USERDOMAIN%", Environment.UserDomainName);
			}

			// Done
			return InnerText;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\AuditInfo.cs ===
/*
 *  AuditInfo.cs
 *  Copyright (c) Microsoft Corporation.  All Rights Reserved.
 *
 *  The AuditInfo class contains data for a single audit point.
 *  AuditInfo is typically buffered on an AuditStream until it
 *  is written to the AuditLog.
 * 
 */

using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService
{
    public class AuditInfo
    {
        private ulong userPuid = 0;
        private Guid correlationId = Guid.Empty;
        private string subsystem;
        private string apiName;
        private string auditMessage;
        private string auditParams;
        private DateTime timestamp = DateTime.UtcNow;
        private bool optional =  false;

        public AuditInfo()
        {
        }

        public AuditInfo(
            ulong userPuid,
            Guid correlationId,
            string subsystem,
            string apiName,
            string auditMessage,
            string auditParams
        )
        {
            this.userPuid = userPuid;
            this.correlationId = correlationId;
            this.subsystem = subsystem;
            this.apiName = apiName;
            this.auditMessage = auditMessage;
            this.auditParams = auditParams;
        }

        public AuditInfo(
            ulong userPuid,
            Guid correlationId,
            string subsystem,
            string apiName,
            string auditMessage,
            string auditParams,
            DateTime timestamp,
            bool optional
        )
        {
            this.userPuid = userPuid;
            this.correlationId = correlationId;
            this.subsystem = subsystem;
            this.apiName = apiName;
            this.auditMessage = auditMessage;
            this.auditParams = auditParams;
            this.timestamp = timestamp;
            this.optional = optional;
        }

        public ulong UserPuid
        {
            get { return userPuid; }
        }

        public Guid CorrelationId
        {
            get { return correlationId; }
            set { correlationId = value; }
        }

        public string ApiName
        {
            get { return apiName; }
        }

        public string Message
        {
            get { return auditMessage; }
        }

        public bool Optional
        {
            get { return optional; }
        }

        public string Subsystem
        {
            get { return subsystem; }
        }

        public string AuditParams
        {
            get { return auditParams; }
        }

        public DateTime Timestamp
        {
            get { return timestamp; }
        }

        private void PrintAuditInfo()
        {
            Global.RO.Info("");
            Global.RO.Info("UserPuid:                 0x{0:X}", UserPuid);
            Global.RO.Info("CorrelationId:           {0}", CorrelationId);
            Global.RO.Info("SubSystem:              {0}", Subsystem);
            Global.RO.Info("Api:                          {0}", ApiName);
            Global.RO.Info("Audit Message:          {0}", Message);
            Global.RO.Info("Xml:                         {0}", AuditParams);
            Global.RO.Info("");
        }

        public static void VerifyAuditInfo(AuditInfo expectInfo, AuditInfo info)
        {
            ValueCheck.Test("UserPuid", expectInfo.UserPuid, info.UserPuid);
            ValueCheck.Test("Correlation id", expectInfo.CorrelationId.ToString(), info.CorrelationId.ToString());
            ValueCheck.Test("SubSystem", expectInfo.Subsystem, info.Subsystem);
            ValueCheck.Test("Api", expectInfo.ApiName, info.ApiName);
            ValueCheck.Test("Audit Message", expectInfo.Message, info.Message);

            if (!string.IsNullOrEmpty(expectInfo.AuditParams))
                ValueCheck.Test("Xml", expectInfo.AuditParams, info.AuditParams);
        }

        public static void VerifyAuditInfoArray(AuditInfo[] expectAuditInfos, AuditInfo[] auditInfos)
        {
            ValueCheck.Test("Audit info array size", expectAuditInfos.GetLength(0), auditInfos.GetLength(0));

            Guid lastGuid = Guid.Empty;
            for (int i = 0; i < expectAuditInfos.GetLength(0); i++)
            {
                Global.RO.Info("Compare audit info # " + i);
                expectAuditInfos[i].PrintAuditInfo();
                auditInfos[i].PrintAuditInfo();

                // verify the correlation ids are in correct order, even we don't know what exactly the correlation ids are.
                if (expectAuditInfos[i].CorrelationId != lastGuid)
                {
                    lastGuid = expectAuditInfos[i].CorrelationId;
                    expectAuditInfos[i].CorrelationId = auditInfos[i].CorrelationId;
                }
                else
                {
                    expectAuditInfos[i].CorrelationId = expectAuditInfos[i - 1].CorrelationId;
                }

                VerifyAuditInfo(expectAuditInfos[i], auditInfos[i]);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\XmlUtil.cs ===
using System.Xml;

namespace ServerTestFramework.Utilities
{
    public class XmlUtil
    {
        #region SetChildNodeValue

        /// <summary>
        /// Sets a the value of a child node of a node.  If it does not exist it is created.
        /// </summary>
        public static void SetChildNodeValue(XmlNode parent, string name, string value)
        {
            XmlNode node=parent.SelectSingleNode(name);
            if (node==null)
            {
                node=parent.OwnerDocument.CreateNode(XmlNodeType.Element, name, "");
                parent.AppendChild(node);
            }
            node.InnerXml=value;
        }
        /// <summary>
        /// Sets a the value of a child node of a node.  If it does not exist it is created.
        /// </summary>
        public static void SetChildNodeValue(XmlNode parent, string name, int value)
        {
            SetChildNodeValue(parent, name, value.ToString());
        }
        /// <summary>
        /// Sets a the value of a child node of a node.  If it does not exist it is created.
        /// </summary>
        public static void SetChildNodeValue(XmlNode parent, string name, float value)
        {
            SetChildNodeValue(parent, name, value.ToString());
        }
        /// <summary>
        /// Sets a the value of a child node of a node.  If it does not exist it is created.
        /// </summary>
        public static void SetChildNodeValue(XmlNode parent, string name, bool value)
        {
            SetChildNodeValue(parent, name, value?"1":"0");
        }

        #endregion

        #region SetAttributeValue

        /// <summary>
        /// Sets an attribute value on a node.  If it does not exist it is created.
        /// </summary>
        /// <param name="node">The node to set on.</param>
        /// <param name="name">The name of the attribute to set.</param>
        /// <param name="val">The value to set.</param>
        public static void SetAttributeValue(XmlNode node, string name, string val)
        {
            XmlNode attr = node.Attributes.GetNamedItem(name);
            if (attr == null)
            {
                attr = node.OwnerDocument.CreateNode(XmlNodeType.Attribute, name, "");
                node.Attributes.SetNamedItem(attr);
            }
            attr.Value = val;
        }

        /// <summary>
        /// Sets an attribute value on a node.  If it does not exist it is created.
        /// </summary>
        /// <param name="node">The node to set on.</param>
        /// <param name="name">The name of the attribute to set.</param>
        /// <param name="val">The value to set.</param>
        public static void SetAttributeValue(XmlNode node, string name, int val)
        {
            SetAttributeValue(node, name, val.ToString());
        }

        /// <summary>
        /// Sets an attribute value on a node.  If it does not exist it is created.
        /// </summary>
        /// <param name="node">The node to set on.</param>
        /// <param name="name">The name of the attribute to set.</param>
        /// <param name="val">The value to set.</param>
        public static void SetAttributeValue(XmlNode node, string name, float val)
        {
            SetAttributeValue(node, name, val.ToString());
        }

        /// <summary>
        /// Sets an attribute value on a node.  If it does not exist it is created.
        /// </summary>
        /// <param name="node">The node to set on.</param>
        /// <param name="name">The name of the attribute to set.</param>
        /// <param name="val">The value to set.</param>
        public static void SetAttributeValue(XmlNode node, string name, bool val)
        {
            SetAttributeValue(node, name, (val ? "1" : "0"));
        }

        #endregion

        #region GetChildNodeValue

        /// <summary>
        /// Gets a the value of a child node of a node, or a default value if it does not exist.
        /// </summary>
        public static string GetChildNodeValue(XmlNode parent, string name, string defaultValue)
        {
            XmlNode node=parent.SelectSingleNode(name);
            if (node==null || node.InnerXml==null || node.InnerXml.Length==0)
            {
                return defaultValue;
            }
            return node.InnerXml;
        }

        /// <summary>
        /// Gets a the value of a child node of a node, or a default value if it does not exist.
        /// </summary>
        public static int GetChildNodeValue(XmlNode parent, string name, int defaultValue)
        {
            string ret=GetChildNodeValue(parent, name, defaultValue.ToString());
            return int.Parse(ret);
        }

        /// <summary>
        /// Gets a the value of a child node of a node, or a default value if it does not exist.
        /// </summary>
        public static long GetChildNodeValue(XmlNode parent, string name, long defaultValue)
        {
            string ret=GetChildNodeValue(parent, name, defaultValue.ToString());
            return long.Parse(ret);
        }

        /// <summary>
        /// Gets a the value of a child node of a node, or a default value if it does not exist.
        /// </summary>
        public static float GetChildNodeValue(XmlNode parent, string name, float defaultValue)
        {
            string ret=GetChildNodeValue(parent, name, defaultValue.ToString());
            return float.Parse(ret);
        }

        /// <summary>
        /// Gets a the value of a child node of a node, or a default value if it does not exist.
        /// </summary>
        public static bool GetChildNodeValue(XmlNode parent, string name, bool defaultValue)
        {
            int ret=GetChildNodeValue(parent, name, defaultValue?1:0);
            return ret!=0;
        }

        /// <summary>
        /// Gets the value of a child node of a node.
        /// Returns true if the value was found, false if it was not.
        /// </summary>
        public static bool GetChildNodeValue (XmlNode parent, string name, out bool result)
        {
            int ret = GetChildNodeValue(parent, name, 2);

            // default case
            if (ret == 2)
            {
                result = false;
                return false;
            }

            result = (ret != 0);
            return true;
        }

        #endregion

        #region GetAttributeValue

        /// <summary>
        /// Gets an attribute value on a node.  If it does not exist the default is returned.
        /// </summary>
        /// <param name="node">The node to get from.</param>
        /// <param name="name">The name of the attribute to get.</param>
        /// <param name="defaultValue">The default value to return if not found.</param>
        public static string GetAttributeValue(XmlNode node, string name, string defaultValue)
        {
            XmlNode attr = node.Attributes.GetNamedItem(name);
            if (attr == null || attr.Value == null)
            {
                return defaultValue;
            }
            return attr.Value;
        }

        /// <summary>
        /// Gets an attribute value on a node.  If it does not exist the default is returned.
        /// </summary>
        /// <param name="node">The node to get from.</param>
        /// <param name="name">The name of the attribute to get.</param>
        /// <param name="defaultValue">The default value to return if not found.</param>
        public static int GetAttributeValue(XmlNode node, string name, int defaultValue)
        {
            string get = GetAttributeValue(node, name, "");
            int val;
            if (get == "" || !int.TryParse(get, out val)) { return defaultValue; }
            return val;
        }

        /// <summary>
        /// Gets an attribute value on a node.  If it does not exist the default is returned.
        /// </summary>
        /// <param name="node">The node to get from.</param>
        /// <param name="name">The name of the attribute to get.</param>
        /// <param name="defaultValue">The default value to return if not found.</param>
        public static float GetAttributeValue(XmlNode node, string name, float defaultValue)
        {
            string get = GetAttributeValue(node, name, "");
            float val;
            if (get == "" || !float.TryParse(get, out val)) { return defaultValue; }
            return val;
        }

        /// <summary>
        /// Gets an attribute value on a node.  If it does not exist the default is returned.
        /// </summary>
        /// <param name="node">The node to get from.</param>
        /// <param name="name">The name of the attribute to get.</param>
        /// <param name="defaultValue">The default value to return if not found.</param>
        public static bool GetAttributeValue(XmlNode node, string name, bool defaultValue)
        {
            string get = GetAttributeValue(node, name, "");

            switch (get)
            {
                case "1": return true;
                case "0": return false;
                default: return defaultValue;
            }
        }

        #endregion

        #region GetGroupNode

        /// <summary>
        /// Retrieves the child node of a unique group node, or creates it if it does not exist.
        /// </summary>
        public static XmlNode GetGroupNode(XmlNode parent, string name)
        {
            XmlNode node=parent.SelectSingleNode(name);
            if (node==null)
            {
                node=parent.OwnerDocument.CreateNode(XmlNodeType.Element, name, "");
                parent.AppendChild(node);
            }
            return node;
        }

        /// <summary>
        /// Retrieves the child node of a unique group node, or creates it if it does not exist.
        /// </summary>
        public static XmlNode GetGroupNode(XmlDocument parent, string name)
        {
            XmlNode node=parent.SelectSingleNode(name);
            if (node==null)
            {
                node=parent.CreateNode(XmlNodeType.Element, name, "");
                parent.AppendChild(node);
            }
            return node;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\VsTestResultTestEventListener.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using System.Collections.Generic;
using System.Xml;

namespace ServerTestFramework
{
    public class VsTestResultTestEventListener: TestEventListener
    {
        public VsTestResultTestEventListener()
        {
        }

        public VsTestResultTestEventListener(string fileName)
        {
            overrideFileName=fileName;
        }

        public string RunDescription=null; //goes into the TestSettings.Deployment.Description node of the result file

        public void OnTestEvent(TestEventArgs evt)
        {
            lock (eventLock)
            {
                if (evt.Action==TestAction.StartAll)
                {
                    //Reset everything
                    topLevelNodes=new List<TestNode>();
                    hasMagicTopLevelNode=false;
                    unitTestIds=new Dictionary<string, System.Guid>();
                    testListIds=new Dictionary<string, System.Guid>();
                    executionIds=new Dictionary<string, System.Guid>();
                    outcomeCounts=new Dictionary<string, int>();
                    startTime=System.DateTime.UtcNow;
                }
                else if (evt.Action==TestAction.StopAll)
                {
                    try
                    {
                        GenerateTrxFile();
                    }
                    catch (System.Exception e)
                    {
                        CoreGlobal.RO.Fatal("Unexpected exception generating .trx file:\n"+e);
                    }
                }
                else if (evt.Action==TestAction.Start || evt.Action==TestAction.PreStart)
                {
                    //If we see a top-level node, remember it for later use
                    if (evt.Node.Parent==null)
                    {
                        if (!topLevelNodes.Contains(evt.Node))
                        {
                            topLevelNodes.Add(evt.Node);
                        }
                    }
                }
            }
        }

        private void GenerateTrxFile()
        {
            System.DateTime startGenTime=System.DateTime.UtcNow;

            //Decide on a filename
            string fileName="FuncOutput\\"+StringUtils.MakeDeliminatorSeparatedList(topLevelNodes, "-", TestNodeStringer);
            fileName+="_"+startTime.ToString("yyyy-MM-dd-HHmm+ss")+".trx";
            if (overrideFileName!=null)
            {
                fileName=overrideFileName;
            }
            else
            {
                System.IO.Directory.CreateDirectory("FuncOutput");
            }

            if (topLevelNodes.Count!=0)
            {
                //build the xml document
                XmlDocument xmlDoc=new XmlDocument();

                //Outter TestRun tag
                XmlNode xmlTestRun=xmlDoc.CreateElement("TestRun", XMLNS); //without this namespace set, vs refuses to load the file
                xmlDoc.AppendChild(xmlTestRun);

                SetAttributeValue(xmlTestRun, "id", System.Guid.NewGuid().ToString());
                SetAttributeValue(xmlTestRun, "name", StringUtils.MakeDeliminatorSeparatedList(topLevelNodes, "-", TestNodeStringer));
                SetAttributeValue(xmlTestRun, "runUser", GetCurrentUser());

                //TestSettings tag inside TestRun
                XmlNode xmlTestSettings=xmlDoc.CreateElement("TestSettings", XMLNS);
                xmlTestRun.AppendChild(xmlTestSettings);

                SetAttributeValue(xmlTestSettings, "id", System.Guid.NewGuid().ToString());
                SetAttributeValue(xmlTestSettings, "name", "STF");

                //Deployment tag inside TestSettings
                XmlNode xmlTestSettingsDeployment=xmlDoc.CreateElement("Deployment", XMLNS);
                xmlTestSettings.AppendChild(xmlTestSettingsDeployment);

                SetAttributeValue(xmlTestSettingsDeployment, "runDeploymentRoot", System.IO.Directory.GetCurrentDirectory());

                //Description tag inside TestSettings
                if (RunDescription!=null)
                {
                    XmlNode xmlTestSettingsDescription=xmlDoc.CreateElement("Description", XMLNS);
                    xmlTestSettingsDescription.InnerXml=FilterAndEscapeString(RunDescription);
                    xmlTestSettings.AppendChild(xmlTestSettingsDescription);
                }

                //Times tag inside TestRun
                XmlNode xmlTimes=xmlDoc.CreateElement("Times", XMLNS);
                xmlTestRun.AppendChild(xmlTimes);

                SetAttributeValue(xmlTimes, "creation", startTime.ToString());
                SetAttributeValue(xmlTimes, "start", startTime.ToString());
                SetAttributeValue(xmlTimes, "finish", System.DateTime.UtcNow.ToString());

                //Add the test details
                GenerateTrxXmlTestDefinitions(xmlDoc, xmlTestRun);
                GenerateTrxXmlTestLists(xmlDoc, xmlTestRun);
                GenerateTrxXmlTestEntries(xmlDoc, xmlTestRun);
                GenerateTrxXmlResults(xmlDoc, xmlTestRun);
                GenerateTrxXmlResultSummary(xmlDoc, xmlTestRun);

                //write to file
                XmlWriterSettings xmlWriterSettings=new XmlWriterSettings();
                xmlWriterSettings.Indent=true;
                xmlWriterSettings.IndentChars="    ";

                using (XmlWriter xmlWriter=XmlWriter.Create(fileName, xmlWriterSettings))
                {
                    xmlDoc.WriteTo(xmlWriter);
                }

                System.DateTime endGenTime=System.DateTime.UtcNow;
                CoreGlobal.RO.Debug(fileName+" generated in "+(endGenTime-startGenTime).TotalSeconds+" seconds.");
            }
        }

        private void GenerateTrxXmlResultSummary(XmlDocument xmlDoc, XmlNode xmlTestRun)
        {
            FunctionalSchedulerNodeData overallFunctionalData=GetOverallResults();

            //ResultSummary tag inside TestRun
            XmlNode xmlResultSummary=xmlDoc.CreateElement("ResultSummary", XMLNS);
            xmlTestRun.AppendChild(xmlResultSummary);

            SetAttributeValue(xmlResultSummary, "outcome", TranslateFunctionalSchedulerDataToVsTestOutcome(overallFunctionalData));

            //Counters tag inside ResultSummary
            XmlNode xmlResultSummaryCounters=xmlDoc.CreateElement("Counters", XMLNS);
            xmlResultSummary.AppendChild(xmlResultSummaryCounters);

            int total=0;
            int executed=0;
            if (outcomeCounts.ContainsKey("Failed"))
            {
                total+=outcomeCounts["Failed"];
                executed+=outcomeCounts["Failed"];
                SetAttributeValue(xmlResultSummaryCounters, "failed", outcomeCounts["Failed"]);
            }
            if (outcomeCounts.ContainsKey("Timeout"))
            {
                total+=outcomeCounts["Timeout"];
                executed+=outcomeCounts["Timeout"];
                SetAttributeValue(xmlResultSummaryCounters, "timeout", outcomeCounts["Timeout"]);
            }
            if (outcomeCounts.ContainsKey("Inconclusive"))
            {
                total+=outcomeCounts["Inconclusive"];
                executed+=outcomeCounts["Inconclusive"];
                SetAttributeValue(xmlResultSummaryCounters, "inconclusive", outcomeCounts["Inconclusive"]);
            }
            if (outcomeCounts.ContainsKey("NotExecuted"))
            {
                total+=outcomeCounts["NotExecuted"];
                SetAttributeValue(xmlResultSummaryCounters, "notExecuted", outcomeCounts["NotExecuted"]);
            }
            if (outcomeCounts.ContainsKey("Warning"))
            {
                total+=outcomeCounts["Warning"];
                executed+=outcomeCounts["Warning"];
                SetAttributeValue(xmlResultSummaryCounters, "warning", outcomeCounts["Warning"]);
            }
            if (outcomeCounts.ContainsKey("Passed"))
            {
                total+=outcomeCounts["Passed"];
                executed+=outcomeCounts["Passed"];
                SetAttributeValue(xmlResultSummaryCounters, "passed", outcomeCounts["Passed"]);
            }

            SetAttributeValue(xmlResultSummaryCounters, "executed", executed);
            SetAttributeValue(xmlResultSummaryCounters, "total", total);

            //It would be nice to store STF's actual scheduler data counters for reference.  The only place I can find to do this is in the value attribute of Counters, which doesn't have any obvious meaning.  VS2010 seems to accept any string there, so for now we'll use it.
            XmlNode xmlResultSummaryStfCounters=xmlDoc.CreateElement("StfCounters", "STF");

            SetAttributeValue(xmlResultSummaryStfCounters, "NumberPassed", overallFunctionalData.NumberPassed);
            SetAttributeValue(xmlResultSummaryStfCounters, "NumberFailed", overallFunctionalData.NumberFailed);
            SetAttributeValue(xmlResultSummaryStfCounters, "NumberFailedWithBug", overallFunctionalData.NumberFailedWithBug);
            SetAttributeValue(xmlResultSummaryStfCounters, "NumberSkipped", overallFunctionalData.NumberSkipped);
            SetAttributeValue(xmlResultSummaryStfCounters, "NumberPreFailed", overallFunctionalData.NumberPreFailed);
            SetAttributeValue(xmlResultSummaryStfCounters, "NumberPostFailed", overallFunctionalData.NumberPostFailed);
            SetAttributeValue(xmlResultSummaryStfCounters, "NumberTimeOutFailed", overallFunctionalData.NumberTimeOutFailed);
            SetAttributeValue(xmlResultSummaryStfCounters, "NumberTotal", overallFunctionalData.NumberTotal);

            SetAttributeValue(xmlResultSummaryCounters, "value", xmlResultSummaryStfCounters.OuterXml.Replace("\"", ""));
        }

        private void GenerateTrxXmlTestDefinitions(XmlDocument xmlDoc, XmlNode xmlTestRun)
        {
            //TestDefinitions tag inside TestRun
            XmlNode xmlTestDefinitions=xmlDoc.CreateElement("TestDefinitions", XMLNS);
            xmlTestRun.AppendChild(xmlTestDefinitions);

            foreach (TestNode node in topLevelNodes)
            {
                FindTestNodeLeavesAndWriteTrxUnitTestEntry(xmlDoc, xmlTestDefinitions, node);
            }
        }

        private void FindTestNodeLeavesAndWriteTrxUnitTestEntry(XmlDocument xmlDoc, XmlNode xmlTestDefinitions, TestNode node)
        {
            if (node.FunctionalData==null || node.FunctionalData.SchedulerData==null)
            {
                return;
            }

            if (node.ChildrenCount==0) //leaf
            {
                WriteTrxUnitTestEntry(xmlDoc, xmlTestDefinitions, node);
            }
            else
            {
                foreach (TestNode child in node.Children)
                {
                    FindTestNodeLeavesAndWriteTrxUnitTestEntry(xmlDoc, xmlTestDefinitions, child);
                }
            }
        }

        private void WriteTrxUnitTestEntry(XmlDocument xmlDoc, XmlNode xmlTestDefinitions, TestNode node)
        {
            //generate and store some ids
            System.Guid testId=TestNodeToPersistantGuid(node);
            System.Guid executionId=System.Guid.NewGuid();

            unitTestIds.Add(node.FullName, testId);
            executionIds.Add(node.FullName, executionId);

            //
            XmlNode xmlUnitTest=xmlDoc.CreateElement("UnitTest", XMLNS);
            xmlTestDefinitions.AppendChild(xmlUnitTest);

            SetAttributeValue(xmlUnitTest, "name", FilterAndEscapeString(node.Name));
            SetAttributeValue(xmlUnitTest, "id", testId.ToString());

            //Description from test node
            if (node.Desc!=null && node.Desc.Length>0)
            {
                XmlNode xmlUnitTestDescription=xmlDoc.CreateElement("Description", XMLNS);
                xmlUnitTestDescription.InnerXml=FilterAndEscapeString(node.Desc);
                xmlUnitTest.AppendChild(xmlUnitTestDescription);
            }

            //Owner tags from test node
            Dictionary<string, NodeTaggingData.ValueSet> nearestTrunkTags=node.TaggingData.GetNearestTrunkTags();
            if (nearestTrunkTags.ContainsKey("Owner"))
            {
                XmlNode xmlUnitTestOwners=xmlDoc.CreateElement("Owners", XMLNS);
                xmlUnitTest.AppendChild(xmlUnitTestOwners);

                //vstst.xsd has a comment saying that multiple owners are not allowed, so we will put them in a comma separated list instead
                XmlNode xmlUnitTestOwner=xmlDoc.CreateElement("Owner", XMLNS);
                xmlUnitTestOwners.AppendChild(xmlUnitTestOwner);

                string ownerListString=StringUtils.MakeCommaSeparatedList(nearestTrunkTags["Owner"]);

                SetAttributeValue(xmlUnitTestOwner, "name", FilterAndEscapeString(ownerListString));
            }

            //Priority tags from test node
            if (nearestTrunkTags.ContainsKey("Priority"))
            {
                NodeTaggingData.ValueSet priorities=nearestTrunkTags["Priority"];
                if (priorities.Count==1)
                {
                    int priorityInt=int.MaxValue;
                    if (int.TryParse(priorities[0].ToString(), out priorityInt))
                    {
                        SetAttributeValue(xmlUnitTest, "priority", priorityInt.ToString());
                    }
                }
            }

            //Execution id
            XmlNode xmlUnitTestExecution=xmlDoc.CreateElement("Execution", XMLNS);
            xmlUnitTest.AppendChild(xmlUnitTestExecution);

            SetAttributeValue(xmlUnitTestExecution, "id", executionId.ToString());

            //Useless to us but the xsd requires it to be present
            XmlNode xmlUnitTestTestMethod=xmlDoc.CreateElement("TestMethod", XMLNS);
            xmlUnitTest.AppendChild(xmlUnitTestTestMethod);

            SetAttributeValue(xmlUnitTestTestMethod, "codeBase", "");
            SetAttributeValue(xmlUnitTestTestMethod, "className", "");
            SetAttributeValue(xmlUnitTestTestMethod, "name", FilterAndEscapeString(node.FullName)); //may as well stick something handy in here
        }

        private void GenerateTrxXmlTestLists(XmlDocument xmlDoc, XmlNode xmlTestRun)
        {
            //TestLists tag inside TestRun
            XmlNode xmlTestLists=xmlDoc.CreateElement("TestLists", XMLNS);
            xmlTestRun.AppendChild(xmlTestLists);

            //If we have multiple top-level nodes with the functional results, create a dummy node to hold them since vstest requires one top-level group
            int numTops=0;
            TestNode top=null;
            foreach (TestNode node in topLevelNodes)
            {
                if (node.FunctionalData!=null && node.FunctionalData.SchedulerData!=null)
                {
                    ++numTops;
                    top=node;
                }
            }

            if (numTops==0)
            {
                return;
            }

            //Add the magic required top-node
            XmlNode xmlTestListMagicTop=xmlDoc.CreateElement("TestList", XMLNS);
            xmlTestLists.AppendChild(xmlTestListMagicTop);

            if (numTops>1)
            {
                hasMagicTopLevelNode=true;

                SetAttributeValue(xmlTestListMagicTop, "name", "Multiple Suites");
                SetAttributeValue(xmlTestListMagicTop, "id", VSTEST_TOP_LEVEL_GUID.ToString());

                foreach (TestNode node in topLevelNodes)
                {
                    FindTestNodeGroupsAndWriteTrxTestListEntry(xmlDoc, xmlTestLists, node);
                }
            }
            else if (numTops==1)
            {
                SetAttributeValue(xmlTestListMagicTop, "name", FilterAndEscapeString(top.FullName));
                SetAttributeValue(xmlTestListMagicTop, "id", VSTEST_TOP_LEVEL_GUID.ToString());

                testListIds.Add(top.FullName, VSTEST_TOP_LEVEL_GUID);

                FindTestNodeGroupsAndWriteTrxTestListEntry(xmlDoc, xmlTestLists, top);
            }
        }

        private void FindTestNodeGroupsAndWriteTrxTestListEntry(XmlDocument xmlDoc, XmlNode xmlTestLists, TestNode node)
        {
            if (node.FunctionalData==null || node.FunctionalData.SchedulerData==null || node.ChildrenCount==0)
            {
                return;
            }

            //Add me
            if ((node.Parent==null && hasMagicTopLevelNode) || node.Parent!=null)
            {
                System.Guid groupGuid=TestNodeToPersistantGuid(node);
                testListIds.Add(node.FullName, groupGuid);

                System.Guid parentGuid;
                if (node.Parent==null && hasMagicTopLevelNode)
                {
                    parentGuid=VSTEST_TOP_LEVEL_GUID;
                }
                else
                {
                    parentGuid=testListIds[node.Parent.FullName];
                }

                XmlNode tl=xmlDoc.CreateElement("TestList", XMLNS);
                xmlTestLists.AppendChild(tl);

                SetAttributeValue(tl, "name", FilterAndEscapeString(node.FullName));
                SetAttributeValue(tl, "id", groupGuid.ToString());
                SetAttributeValue(tl, "parentListId", parentGuid.ToString());

                //Description from test node
                if (node.Desc!=null && node.Desc.Length>0)
                {
                    XmlNode xmlTestListDescription=xmlDoc.CreateElement("Description", XMLNS);
                    xmlTestListDescription.InnerXml=FilterAndEscapeString(node.Desc);
                    tl.AppendChild(xmlTestListDescription);
                }
            }

            //Add children
            foreach (TestNode child in node.Children)
            {
                FindTestNodeGroupsAndWriteTrxTestListEntry(xmlDoc, xmlTestLists, child);
            }
        }

        private void GenerateTrxXmlTestEntries(XmlDocument xmlDoc, XmlNode xmlTestRun)
        {
            //TestEntries tag inside TestRun
            XmlNode xmlTestEntries=xmlDoc.CreateElement("TestEntries", XMLNS);
            xmlTestRun.AppendChild(xmlTestEntries);

            foreach (TestNode child in topLevelNodes)
            {
                FindTestNodeLeavesAndWriteTrxTestEntry(xmlDoc, xmlTestEntries, child);
            }
        }

        private void FindTestNodeLeavesAndWriteTrxTestEntry(XmlDocument xmlDoc, XmlNode xmlTestEntries, TestNode node)
        {
            if (node.FunctionalData==null || node.FunctionalData.SchedulerData==null)
            {
                return;
            }

            if (node.ChildrenCount==0 && node.Parent!=null)
            {
                XmlNode te=xmlDoc.CreateElement("TestEntry", XMLNS);
                xmlTestEntries.AppendChild(te);

                SetAttributeValue(te, "testId", unitTestIds[node.FullName].ToString());
                SetAttributeValue(te, "executionId", executionIds[node.FullName].ToString());
                SetAttributeValue(te, "testListId", testListIds[node.Parent.FullName].ToString());
            }

            foreach (TestNode child in node.Children)
            {
                FindTestNodeLeavesAndWriteTrxTestEntry(xmlDoc, xmlTestEntries, child);
            }
        }

        private void GenerateTrxXmlResults(XmlDocument xmlDoc, XmlNode xmlTestRun)
        {
            //Results tag inside TestRun
            XmlNode xmlResults=xmlDoc.CreateElement("Results", XMLNS);
            xmlTestRun.AppendChild(xmlResults);

            foreach (TestNode child in topLevelNodes)
            {
                FindTestNodeLeavesAndWriteTrxResults(xmlDoc, xmlResults, child);
            }
        }

        private void FindTestNodeLeavesAndWriteTrxResults(XmlDocument xmlDoc, XmlNode xmlResults, TestNode node)
        {
            if (node.FunctionalData==null || node.FunctionalData.SchedulerData==null)
            {
                return;
            }

            if (node.ChildrenCount==0)
            {
                XmlNode utr=xmlDoc.CreateElement("UnitTestResult", XMLNS);
                xmlResults.AppendChild(utr);

                SetAttributeValue(utr, "testName", FilterAndEscapeString(node.FullName));
                SetAttributeValue(utr, "testType", VSTEST_TEST_TYPE_GUID.ToString());
                SetAttributeValue(utr, "testId", unitTestIds[node.FullName].ToString());
                SetAttributeValue(utr, "executionId", executionIds[node.FullName].ToString());
                SetAttributeValue(utr, "testListId", testListIds[node.Parent.FullName].ToString());
                SetAttributeValue(utr, "computerName", FilterAndEscapeString(GetMachineName()));
                SetAttributeValue(utr, "startTime", node.FunctionalData.SchedulerData.StartTime.ToString());
                SetAttributeValue(utr, "endTime", node.FunctionalData.SchedulerData.EndTime.ToString());
                SetAttributeValue(utr, "duration", (node.FunctionalData.SchedulerData.EndTime-node.FunctionalData.SchedulerData.StartTime).ToString());
                string outcome=TranslateFunctionalSchedulerDataToVsTestOutcome(node.FunctionalData.SchedulerData);
                CountOutcome(outcome);
                SetAttributeValue(utr, "outcome", outcome);

                if (node.FunctionalData.SchedulerData.RunException!=null)
                {
                    XmlNode utrOutput=xmlDoc.CreateElement("Output", XMLNS);
                    utr.AppendChild(utrOutput);

                    XmlNode utrOutputException=xmlDoc.CreateElement("Exception", XMLNS);
                    utrOutputException.InnerXml=FilterAndEscapeString(node.FunctionalData.SchedulerData.RunException.ToString());
                    utrOutput.AppendChild(utrOutputException);
                }
            }
            else //group node
            {
                //VsTest doesn't seem to have the concept of a group's setup failing, so we will translate that into every child node that is marked as enabled as being Inconclusive
                if (node.FunctionalData.SchedulerData.NumberTotal==0 && node.FunctionalData.SchedulerData.NumberPreFailed>0)
                {
                    string escapedExceptionText=null;
                    if (node.FunctionalData.SchedulerData.RunException!=null)
                    {
                        escapedExceptionText=FilterAndEscapeString(node.FunctionalData.SchedulerData.RunException.ToString());
                    }

                    foreach (TestNode child in node.Children)
                    {
                        FindTestNodeLeavesAndWriteTrxResultsAsSpecificOutcomeForAllEnabledNodes(xmlDoc, xmlResults, child, "Inconclusive", escapedExceptionText);
                    }

                    return; //don't write normal results for children in this case
                }
            }

            foreach (TestNode child in node.Children)
            {
                FindTestNodeLeavesAndWriteTrxResults(xmlDoc, xmlResults, child);
            }
        }

        private void FindTestNodeLeavesAndWriteTrxResultsAsSpecificOutcomeForAllEnabledNodes(XmlDocument xmlDoc, XmlNode xmlResults, TestNode node, string outcome, string escapedExceptionText)
        {
            if (node.FunctionalData==null || node.FunctionalData.SchedulerData==null || !node.FunctionalData.Enabled || node.FunctionalData.Ignored)
            {
                return;
            }

            if (node.ChildrenCount==0)
            {
                XmlNode utr=xmlDoc.CreateElement("UnitTestResult", XMLNS);
                xmlResults.AppendChild(utr);

                SetAttributeValue(utr, "testName", FilterAndEscapeString(node.FullName));
                SetAttributeValue(utr, "testType", VSTEST_TEST_TYPE_GUID.ToString());
                SetAttributeValue(utr, "testId", unitTestIds[node.FullName].ToString());
                SetAttributeValue(utr, "executionId", executionIds[node.FullName].ToString());
                SetAttributeValue(utr, "testListId", testListIds[node.Parent.FullName].ToString());
                SetAttributeValue(utr, "computerName", FilterAndEscapeString(GetMachineName()));
                SetAttributeValue(utr, "startTime", node.FunctionalData.SchedulerData.StartTime.ToString());
                SetAttributeValue(utr, "endTime", node.FunctionalData.SchedulerData.EndTime.ToString());
                SetAttributeValue(utr, "duration", (node.FunctionalData.SchedulerData.EndTime-node.FunctionalData.SchedulerData.StartTime).ToString());
                CountOutcome(outcome);
                SetAttributeValue(utr, "outcome", outcome);

                if (escapedExceptionText!=null)
                {
                    XmlNode utrOutput=xmlDoc.CreateElement("Output", XMLNS);
                    utr.AppendChild(utrOutput);

                    XmlNode utrOutputException=xmlDoc.CreateElement("Exception", XMLNS);
                    utrOutputException.InnerXml=escapedExceptionText;
                    utrOutput.AppendChild(utrOutputException);
                }
            }

            foreach (TestNode child in node.Children)
            {
                FindTestNodeLeavesAndWriteTrxResultsAsSpecificOutcomeForAllEnabledNodes(xmlDoc, xmlResults, child, outcome, escapedExceptionText);
            }
        }

        private string GetCurrentUser()
        {
            try
            {
                return System.Security.Principal.WindowsIdentity.GetCurrent().Name;
            }
            catch
            {
                return "Unknown";
            }
        }

        private string GetMachineName()
        {
            try
            {
                return System.Environment.MachineName;
            }
            catch
            {
                return "Unknown";
            }
        }

        private FunctionalSchedulerNodeData GetOverallResults()
        {
            //STF supports multiple top-level nodes.  VsTest does not.  So combine the results from all top-level nodes into one result set.
            FunctionalSchedulerNodeData fnd=new FunctionalSchedulerNodeData();
            fnd.RunResult=TEST_RESULTS.NOT_EXECUTED;
            fnd.StartTime=System.DateTime.MaxValue;
            fnd.EndTime=System.DateTime.MinValue;

            foreach (TestNode node in topLevelNodes)
            {
                if (node.FunctionalData==null || node.FunctionalData.SchedulerData==null)
                {
                    continue;
                }

                //run result
                if (fnd.RunResult==TEST_RESULTS.NOT_EXECUTED)
                {
                    fnd.RunResult=node.FunctionalData.SchedulerData.RunResult;
                }

                if (node.FunctionalData.SchedulerData.RunResult==TEST_RESULTS.FAILED)
                {
                    fnd.RunResult=TEST_RESULTS.FAILED;
                }

                //time stamps
                if (node.FunctionalData.SchedulerData.StartTime<fnd.StartTime)
                {
                    fnd.StartTime=node.FunctionalData.SchedulerData.StartTime;
                }

                if (node.FunctionalData.SchedulerData.EndTime>fnd.EndTime)
                {
                    fnd.EndTime=node.FunctionalData.SchedulerData.EndTime;
                }

                fnd.TotalTime+=node.FunctionalData.SchedulerData.TotalTime;

                //counts
                fnd.NumberPassed+=node.FunctionalData.SchedulerData.NumberPassed;
                fnd.NumberFailed+=node.FunctionalData.SchedulerData.NumberFailed;
                fnd.NumberFailedWithBug+=node.FunctionalData.SchedulerData.NumberFailedWithBug;
                fnd.NumberSkipped+=node.FunctionalData.SchedulerData.NumberSkipped;
                fnd.NumberPreFailed+=node.FunctionalData.SchedulerData.NumberPreFailed;
                fnd.NumberPostFailed+=node.FunctionalData.SchedulerData.NumberPostFailed;
                fnd.NumberPostFailed+=node.FunctionalData.SchedulerData.NumberPostFailed;
                fnd.NumberTimeOutFailed+=node.FunctionalData.SchedulerData.NumberTimeOutFailed;
                fnd.NumberTotal+=node.FunctionalData.SchedulerData.NumberTotal;

                //exception... we have to pick one even though there could be multiple
                if (fnd.RunException==null && node.FunctionalData.SchedulerData.RunException!=null)
                {
                    fnd.RunException=node.FunctionalData.SchedulerData.RunException;
                }
            }

            return fnd;
        }

        private string TranslateFunctionalSchedulerDataToVsTestOutcome(FunctionalSchedulerNodeData fnd)
        {
            if (fnd.RunResult==TEST_RESULTS.NOT_EXECUTED || fnd.NumberTotal==0)
            {
                if (fnd.NumberPreFailed==0)
                {
                    return "NotExecuted";
                }
                else
                {
                    return "Inconclusive";
                }
            }
            else if (fnd.NumberTotal==1) //leaf node
            {
                if (fnd.NumberPreFailed>0)
                {
                    return "Inconclusive";
                }
                else if (fnd.NumberTimeOutFailed>0)
                {
                    return "Timeout";
                }
                else if (fnd.NumberFailed>0)
                {
                    if (fnd.NumberFailedWithBug>0)
                    {
                        return "Warning";
                    }
                    else
                    {
                        return "Failed";
                    }
                }
                else if (fnd.NumberPassed>0)
                {
                    if (fnd.NumberPostFailed>0)
                    {
                        return "Warning";
                    }
                    else
                    {
                        return "Passed";
                    }
                }
                else
                {
                    throw new System.Exception("This should never be hit (leaf).");
                }
            }
            else //group node
            {
                if (fnd.NumberPreFailed>0 && fnd.NumberTimeOutFailed==0 && fnd.NumberFailed==0 && fnd.NumberPassed==0)
                {
                    return "Inconclusive";
                }
                else if (fnd.NumberTimeOutFailed>0 && fnd.NumberFailed==0 && fnd.NumberPassed==0)
                {
                    return "Timeout";
                }
                else if (fnd.NumberFailed>0)
                {
                    if (fnd.NumberFailedWithBug==fnd.NumberFailed)
                    {
                        return "Warning";
                    }
                    else
                    {
                        return "Failed";
                    }
                }
                else if (fnd.NumberPassed>0)
                {
                    if (fnd.NumberPostFailed>0)
                    {
                        return "Warning";
                    }
                    else
                    {
                        return "Passed";
                    }
                }
                else
                {
                    throw new System.Exception("This should never be hit (group).");
                }
            }
        }

        private void CountOutcome(string outcome)
        {
            if (!outcomeCounts.ContainsKey(outcome))
            {
                outcomeCounts[outcome]=0;
            }

            ++outcomeCounts[outcome];
        }

        private static void SetAttributeValue(XmlNode node, string name, int value)
        {
            SetAttributeValue(node, name, value.ToString());
        }

        private static void SetAttributeValue(XmlNode node, string name, string value)
        {
            XmlAttribute attr=node.Attributes[name];
            if (attr==null)
            {
                attr=node.OwnerDocument.CreateAttribute(name);
                node.Attributes.Append(attr);
            }
            attr.Value=value;
        }

        private static string TestNodeStringer(object o)
        {
            TestNode node=o as TestNode;
            if (node!=null)
            {
                return node.Name;
            }
            else if (o!=null)
            {
                return o.ToString();
            }
            else
            {
                return "";
            }
        }

        private static string FilterAndEscapeString(string orig)
        {
            System.Text.StringBuilder sbFiltered=new System.Text.StringBuilder(orig.Length);
            foreach (char c in orig)
            {
                if ((c>=32 && c<=126) || c=='\t' || c=='\n' || c=='\r')
                {
                    sbFiltered.Append(c);
                }
                else
                {
                    sbFiltered.Append(' ');
                }
            }

            return System.Security.SecurityElement.Escape(sbFiltered.ToString());
        }

        private static System.Guid TestNodeToPersistantGuid(TestNode node)
        {
            byte []hash=sha1Hasher.ComputeHash(System.Text.Encoding.Unicode.GetBytes(node.FullName));
            byte []truncatedHash=new byte[16];
            System.Array.Copy(hash, truncatedHash, 16);
            return new System.Guid(truncatedHash);
        }

        private static System.Security.Cryptography.HashAlgorithm sha1Hasher=new System.Security.Cryptography.SHA1CryptoServiceProvider(); 

        private object eventLock=new object();
        private System.DateTime startTime;
        private string overrideFileName=null;
        private List<TestNode> topLevelNodes;
        private bool hasMagicTopLevelNode;
        private Dictionary<string, System.Guid> unitTestIds=null;
        private Dictionary<string, System.Guid> testListIds=null;
        private Dictionary<string, System.Guid> executionIds=null;
        private Dictionary<string, int> outcomeCounts=null;

        private static readonly string XMLNS="http://microsoft.com/schemas/VisualStudio/TeamTest/2010";
        private static readonly System.Guid VSTEST_TOP_LEVEL_GUID=new System.Guid("19431567-8539-422a-85d7-44ee4e166bda");
        public static readonly System.Guid VSTEST_TEST_TYPE_GUID=new System.Guid("13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\ControlProtocol.cs ===
using System;
using System.Threading;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Collections;

namespace ServerTestFramework.LiveService
{
    public delegate void CmdListener_Stop();

    public enum PortConstants
    {
        Server = 65450,
        ServerCommand =65451
    }

    public class Controller
    {
        public int                  heartbeatTimeoutSecs    = 300;
        
        protected Register          msgRegister             = new Register();
        protected byte[]            bytesRegister           = null;
        protected AutoResetEvent    ShutDownEvent           = new System.Threading.AutoResetEvent(false);
        protected int               listenerPort            = 0;
        protected Thread            threadCommand;
        protected Thread            threadHeartbeat;
        protected IPEndPoint        epControllerServer      = null;
        
        // Function delegates
        protected CmdListener_Stop  funcStop                = null;

        /// <summary>
        /// Main thread for sending heartbeat messages to the server. Also responsible for sending
        /// initial register message, which is the same as a heartbeat.
        /// </summary>
        public void HeartbeatThread()
        {

            // Create socket
            FDTransaction.MyUdpClient sock = new FDTransaction.MyUdpClient();
            sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.SendTimeout,1000);

            // Send the intial 'start' message
            SendStart(sock);

            while(true)
            {
                try
                {
                    // Send the 'running' heartbeat message
                    SendRunning(sock);
					
                    // Sleep for x ms (5 minutes), but shutdown if event is signaled
                    int time = 1000 * heartbeatTimeoutSecs;
                    if(ShutDownEvent.WaitOne(time, false))
                    {
                        ShutDownEvent.Set();
                        
                        // Send the 'stop' message
                        SendStop(sock);

                        return;
                    }
					
                }
                catch(System.Exception e)
                {
                    System.Console.WriteLine(e);
                }
            }
        }

        private void SendStart(FDTransaction.MyUdpClient sock)
        {
            if (msgRegister.State != (int)TestState.start)
            {
                msgRegister.State = (int)TestState.start;
                bytesRegister = msgRegister.RebuildRegisterMessage();
            }
            sock.Send(bytesRegister, bytesRegister.Length, epControllerServer);
        }

        private void SendRunning(FDTransaction.MyUdpClient sock)
        {
            if (msgRegister.State != (int)TestState.running)
            {
                msgRegister.State = (int)TestState.running;
                bytesRegister = msgRegister.RebuildRegisterMessage();
            }
            sock.Send(bytesRegister, bytesRegister.Length, epControllerServer);
        }

        private void SendStop(FDTransaction.MyUdpClient sock)
        {
            if (msgRegister.State != (int)TestState.stop)
            {
                msgRegister.State = (int)TestState.stop;
                bytesRegister = msgRegister.RebuildRegisterMessage();
            }
            sock.Send(bytesRegister, bytesRegister.Length, epControllerServer);
        }
		
        /// <summary>
        /// Main thread for listening to incoming server commands. 
        /// </summary>
        public void CommandListenerThread()
        {
            // Create the listening socket.
            FDTransaction.MyUdpClient sock = new FDTransaction.MyUdpClient();
            sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReceiveTimeout,1000);
            sock.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.SendTimeout,35000);

            // Force a bind to a local socket, as we need to send the port information to the 
            // controller server, so that it knows where to send commands.
            listenerPort = sock.Bind();

            while(true)
            {
                try
                {
                    IPEndPoint endpoint = null;
                    byte[] recvdata = new  byte[0];
                    while (recvdata.Length<=0)
                    {
                        // Quickly check for a signal
                        if(ShutDownEvent.WaitOne(1,false))
                        {
                            // If set, reset event and exit thread
                            ShutDownEvent.Set();
                            return;
                        }

                        // Attempt receive
                        try
                        {
                            recvdata = sock.Receive(ref endpoint);
                        }
                        catch(SocketException  e)
                        {
                            // Code 10060 is timed out
                            if(e.ErrorCode != 10060)	
                                throw e;
                        }
                    }

                    if (recvdata.Length > 0)
                    {
                        // Read header
                        MemoryStream reqStream = new MemoryStream(recvdata);
                        MessageHeader msgHdr = (MessageHeader)new MessageHeader();
                        msgHdr.ReadStream(reqStream);
						
                        if (msgHdr.msgType == (int)MsgTypes.Command)
                        {
                            CommandMsg msg = new CommandMsg();
                            msg.ReadStream(reqStream);

                            string cmd = msg.Text.Trim().ToLower();
                            Global.RO.Debug("StressScheduler got command: {0}", cmd);

                            string me = msgRegister.Component.ToLower();

                            if (cmd == "stop" || cmd == "stop " + me)
                            {
                                // Call delegate
                                if (funcStop != null)
                                    funcStop();
                            }
                        }
                        else if (msgHdr.msgType == (int)MsgTypes.Register)
                        {
                            throw new Exception("Invalid message type received (Register)");
                        }
                        else if (msgHdr.msgType == (int)MsgTypes.RegisterResp)
                        {
                            throw new Exception("Invalid message type received (RegisterResp)");
                        }
                        else if (msgHdr.msgType == (int)MsgTypes.UpdateState)
                        {
                            throw new Exception("Invalid message type received (UpdateState)");
                        }
                        else
                        {
                            throw new Exception("Invalid message type received (unknown)");
                        }
					
                    }
                }
                catch(System.Exception e)
                {
                    System.Console.WriteLine(e.ToString());
                }
            }
		
		
        }

        /// <summary>
        /// Call this to register listener functions for handling incoming commands
        /// </summary>
        /// <param name="funcStop"></param>
        public void RegisterListeners(CmdListener_Stop funcStop)
        {
            this.funcStop = funcStop;
        }

        /// <summary>
        /// Call this to fire up the threads and send an initial register message. Uses default server port.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="state"></param>
        /// <param name="componentName"></param>
        /// <param name="serverIp"></param>
        public void Start(TestType type, TestState state, string componentName, string serverIp, CmdListener_Stop funcStop)
        {
            Start(type, state, componentName, new IPEndPoint(System.Net.IPAddress.Parse(serverIp), (int)PortConstants.Server), funcStop);
        }

        /// <summary>
        /// Call this to fire up the threads and send an initial register message.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="state"></param>
        /// <param name="componentName"></param>
        /// <param name="epControllerServer"></param>
        public void Start(TestType type, TestState state, string componentName, IPEndPoint epControllerServer, CmdListener_Stop funcStop)
        {
            if (epControllerServer == null)
            {
                Global.RO.Warn("No IP specified for StfController server, you probably need a line in the <config> section of stf.xml like: <stfcontroller ip=xxx port=xxx/>");
                Global.RO.Warn("Aborting use of StfController");
                return;
            }
            // If port is 0, use hard coded default
            if (epControllerServer.Port == 0)
                epControllerServer.Port = (int)PortConstants.Server;
            this.epControllerServer = epControllerServer;

            // Regsiter function callbacks
            RegisterListeners(funcStop);

            // Clear the event and reset the port, since we're waiting for the new bind() by
            // checking for a value of non-zero.
            ShutDownEvent.Reset();
            listenerPort = 0;

            // Create command listener thread
            threadCommand = ThreadMaker.CreateThread(CommandListenerThread);
            threadCommand.Start();
			
            // Once the listener thread binds to a port, this will no longer be 0.
            // Wait for it.
            while (listenerPort == 0)
            {
                Thread.Sleep(100);
            }

            // Fill in register message
            msgRegister.ListeningPort = listenerPort;
            SetCurrentState(type, state, componentName);
			
            // Create heartbeat thread
            threadHeartbeat = ThreadMaker.CreateThread(HeartbeatThread);
            threadHeartbeat.Start();

            Global.RO.Debug("StfController started, sending to {0}, listening on port {1}",
                epControllerServer.ToString(),
                listenerPort);
        }

        /// <summary>
        /// Shuts down the threads and causes a stop message to be sent to the server
        /// </summary>
        public void Stop()
        {
            ShutDownEvent.Set();
        }

        /// <summary>
        /// Client should call this to update its state
        /// </summary>
        /// <param name="type"></param>
        /// <param name="state"></param>
        /// <param name="componentName"></param>
        public void SetCurrentState(TestType type, TestState state, string componentName)
        {
            msgRegister.Set(type, state, componentName);
            this.bytesRegister = msgRegister.RebuildRegisterMessage();
        }
		
    }

    #region Packet definitions

    /// <summary>
    /// In MessageHeader, to indicate which kind of message is coming
    /// </summary>
    public enum MsgTypes
    {
        Register,
        RegisterResp,
        UpdateState,
        Command
    }

    /// <summary>
    /// Always sent before all other message types
    /// </summary>
    public class MessageHeader : WireData
    {
        public int msgType;
        public int size;
        public MessageHeader()
        {
        }
        public MessageHeader(int typ)
        {
            msgType=typ;
        }
        public MessageHeader(MsgTypes typ)
        {
            msgType=(int)typ;
        }
    }

    /// <summary>
    /// State of client for Register messages
    /// Warning: StfController relies on these, watch for build breaks if you change them.
    /// </summary>
    public enum TestState
    {
        start,          // send this when starting test
        init,           // not used
        running,        // send this while running as a heartbeat
        terminating,    // not used
        stop            // send this when stopping test
    }

    /// <summary>
    /// Type of client for Register messages
    /// Warning: StfController relies on these, watch for build breaks if you change them.
    /// </summary>
    public enum TestType
    {
        Functional,
        DVTFunctional,
        Stress
    }

    /// <summary>
    /// (xmit) Register message, for sending state to server
    /// </summary>
    public class Register : WireData
    {
        public int		Type;
        public int		State;
        public int		ListeningPort;
        public byte		ComponentLen;
        public string	Component;

        public Register()
        {
        }

        public void Set(TestType type, TestState state, string componentName)
        {
            Type = (int)type;
            State = (int)state;
            if (componentName.Length >= 255)
            {
                throw new Exception("componentName is too long, must be less than 255 characters");
            }
            Component = componentName;
            ComponentLen = (byte)Component.Length;
        }

        public byte[] RebuildRegisterMessage()
        {
            // Create uber-message byte array
            MessageHeader msgHdr = new MessageHeader(MsgTypes.Register);
            byte[] header = (byte[])msgHdr;
            byte[] data = (byte[])this;
            byte[] msgRequest = new byte[header.Length + data.Length];
            
            // Re-fill in total size now
            msgHdr.size = msgRequest.Length;
            header = (byte[])msgHdr;

            Array.Copy(header, msgRequest, header.Length);
            Array.Copy(data, 0, msgRequest, header.Length, data.Length);

            return msgRequest;
        }


        public override string ToString()
        {
            return (" STF|"+Component+"|"+ Type+"|"+State+"|"+ListeningPort);
        }
    }

    /// <summary>
    /// (recv) Command message
    /// </summary>
    public class CommandMsg : WireData
    {
        public int	  TextLen;
        public string Text;
		
    }

    #endregion

	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\BundledAuthData.cs ===
using System;
using System.IO;

// TAKEN FROM SGInfo.cs
namespace ServerTestFramework.LiveService
{
    /// <summary>
    /// Summary description for BundledAuthData.
    /// </summary>
    public class BundledAuthData
    {
        public const string HTTP_HEADER_BUNDLED_AUTH_DATA = "BundledAuthData";
        public const ushort HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION = 1;

        public BundledAuthData(uint paramTitleID, XUIDAndTrust[] paramUsers)
        {
            titleID = paramTitleID;
            users = paramUsers;
        }

        public BundledAuthData(string base64EncodedString)
        {
            BinaryReader reader = new BinaryReader(new MemoryStream(Convert.FromBase64String(base64EncodedString)));
            ushort wBundledAuthDataVersion;

            wBundledAuthDataVersion = reader.ReadUInt16();
            if (wBundledAuthDataVersion != HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION)
            {
                throw new Exception("BundledAuthData: Auth data version ("
                    + wBundledAuthDataVersion + ") is incorrect!");
            }
            users = new XUIDAndTrust[reader.ReadUInt16()];
            titleID = reader.ReadUInt32();
            for (int i = 0; i < users.Length; ++i)
            {
                users[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), reader.ReadSingle());
            }
        }

        public string GetBase64EncodedString()
        {
            MemoryStream memStream = new MemoryStream(users.Length * 16 + 8);

            BinaryWriter writer = new BinaryWriter(memStream);

            writer.Write(HTTP_HEADER_BUNDLED_AUTH_DATA_VERSION);
            writer.Write((ushort)users.Length);
            writer.Write(titleID);
            for (int i = 0; i < users.Length; ++i)
            {
                writer.Write(users[i].qwUserID);
                writer.Write(users[i].dwUserFlags);
                writer.Write(users[i].userTrust);
            }

            return Convert.ToBase64String(memStream.ToArray());
        }

        public readonly uint titleID;
        public XUIDAndTrust[] users;

        public void VerifyTitleId(uint titleId)
        {
            if (titleId != titleID)
            {
                throw new Exception("BundleAuthData.Verify: Title ID *" + titleId.ToString("X") + "* (Bundle says " + titleID.ToString("X") + ") cannot be verfied.");
            }
        }
    }

    public struct XUIDAndTrust : IComparable
    {
        private const uint XONLINE_USER_GUEST_MASK = 0x00000003;
        private const uint XONLINE_USER_VOICE_NOT_ALLOWED = 0x00010000;
        private const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        private const uint XONLINE_USER_COUNTRY_MASK = 0x0000FF00;

        public ulong qwUserID;
        public uint dwUserFlags;
        public float userTrust;

        public XUIDAndTrust(ulong userID, uint userFlags, float paramUserTrust)
        {
            qwUserID = userID;
            dwUserFlags = userFlags;
            userTrust = paramUserTrust;
        }

        public int CompareTo(object obj)
        {
            return qwUserID.CompareTo(((XUIDAndTrust)obj).qwUserID);
        }

        public uint GuestNumber()
        {
            return dwUserFlags & XONLINE_USER_GUEST_MASK;
        }

        public bool IsGuest()
        {
            return (GuestNumber() != 0);
        }

        public byte UserCountry()
        {
            return (byte)((dwUserFlags & XONLINE_USER_COUNTRY_MASK) >> 8);
        }

        public bool CanPurchase()
        {
            return ((dwUserFlags & (XONLINE_USER_GUEST_MASK | XONLINE_USER_PURCHASE_NOT_ALLOWED)) == 0);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\HTTPAuthData.cs ===
using System;
using System.Net;
using System.IO;
using System.Diagnostics;
using System.Threading;
using System.Text;

namespace ServerTestFramework.LiveService
{
	/// <summary>
	/// Taken from private\common\service\SGInfo.cs
	/// Storage datacenter request needs these httpHeader
	/// 
	/// This is a stripped down copy of the service SGInfo.cs.  This is unfortunate, as we
	/// also have a test version of SGInfo.cs (in ServerTestFramework\Liveservice\FakeSG\SGInfo.cs, 
	/// its object is CSGInfo.  CSGInfo is optimized for FakeSG, which requires an explicitly laid
	/// out struct so it can easily map to the memory-mapped file (MMF).  It is also a struct instead
	/// of a class.  When we get some down time, it might be nice to consolidate this and that. 
	/// 
	/// This does support AuthData3 now.
	/// 
	/// kgoodier
	/// 
	/// </summary>
	public class HTTPAuthData : SGInfo
	{
		public const string HTTP_HEADER_AUTH_DATA = "HTTPAuthData";
		public const ushort HTTP_HEADER_AUTH_DATA_VERSION = 3;

        //use this ONLY if you are using XRL common code and won't have SGInfo available (like for tools)
        public HTTPAuthData( ) : this( 0, 0, 0, 0, 0, 0, 0 )
        {
        }

        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong userID, uint titleID, uint serviceId1, uint serviceId2) : base(port, ip, requestId)
        {
            wAuthDataSize    = 0;
            wMajorVersion    = 0;
            wMinorVersion    = 0;
            wBuildNumber     = 0;
            wQFENumber       = 0;
            dwTitleID        = titleID;
            dwTitleVersion   = 0;
            dwTitleRegion    = 0;
            dwConsoleRegion  = 0;
            dwMediaID        = 0;
            wLanguageID      = 0;
            dwAuthDataFlags  = 0;

            qwXboxID         = 0;

            // users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            xUsers[0] = new XUIDAndTrust(userID, 0, 0.0F);
            for( int i = 1; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
            }

            // privileges
            wNumPrivileges = 0;
            dwPrivileges = new uint[XONLINE_NUM_PRIVILEGE_DWORDS];

            if ( serviceId1 > 0 && serviceId1 < XONLINE_MAX_PRIVILEGE_ID )
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId1;
                wNumPrivileges++;
            }
            if ( serviceId2 > 0 && serviceId2 < XONLINE_MAX_PRIVILEGE_ID )
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId2;
                wNumPrivileges++;
            }

            // services
            wNumDwordServices = 0;
            dwServiceIds = new uint[XONLINE_MAX_DWORD_SERVICEIDS];

            if ( serviceId1 > XONLINE_MAX_PRIVILEGE_ID )
            {
                dwServiceIds[wNumDwordServices++] = serviceId1;
            }

            if ( serviceId2 > XONLINE_MAX_PRIVILEGE_ID )
            {
                dwServiceIds[wNumDwordServices++] = serviceId2;
            }

            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];
            for( int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XONLINE_KEY_LENGTH];
        }

        public HTTPAuthData(ushort port, uint ip, ulong requestId, ulong xboxID, XUIDAndTrust[] users, uint titleID, uint serviceId1, uint serviceId2) : base(port, ip, requestId)
        {
            wAuthDataSize    = 0;
            wMajorVersion    = 0;
            wMinorVersion    = 0;
            wBuildNumber     = 0;
            wQFENumber       = 0;
            dwTitleID        = titleID;
            dwTitleVersion   = 0;
            dwTitleRegion    = 0;
            dwConsoleRegion  = 0;
            dwMediaID        = 0;
            wLanguageID      = 0;
            dwAuthDataFlags  = 0;

            wNumPrivileges   = 0;
            dwPrivileges = new uint[XONLINE_NUM_PRIVILEGE_DWORDS];

            qwXboxID         = xboxID;

            // users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                if (i < users.Length)
                {
                    xUsers[i] = users[i];
                }
                else
                {
                    xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
                }
            }

            // privileges and services
            if ( serviceId1 > 0 && serviceId1 < XONLINE_MAX_PRIVILEGE_ID )
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId1;
                wNumPrivileges++;
            }
            if ( serviceId2 > 0 && serviceId2 < XONLINE_MAX_PRIVILEGE_ID )
            {
                dwPrivileges[0] |= ((uint)1) << (byte)serviceId2;
                wNumPrivileges++;
            }

            wNumDwordServices = 0;
            dwServiceIds = new uint[XONLINE_MAX_DWORD_SERVICEIDS];

            if ( serviceId1 > XONLINE_MAX_PRIVILEGE_ID )
            {
                dwServiceIds[wNumDwordServices++] = serviceId1;
            }

            if ( serviceId2 > XONLINE_MAX_PRIVILEGE_ID )
            {
                dwServiceIds[wNumDwordServices++] = serviceId2;
            }

            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];
            for( int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++ )
            {
                dwAltTitleID[i] = 0;
            }

            key = new byte[XONLINE_KEY_LENGTH];
        }

		public string GetBase64EncodedString()
		{
			return ConstructBase64String();
		}
	}
	/// <summary>
	/// taken from SGInfo.cs, but only keeps the parts that HTTPAuthData uses
	/// </summary>
	public class SGInfo 
	{
		// This is a special constructor for HTTPAuthData construction
		public SGInfo(ushort port, uint ip, ulong requestId)
		{
			wAuthDataVersion = XONLINE_XENON_AUTHDATA_VERSION;
			_ipportI = port;
			_ipaI = ip;
			_liNonce = requestId;

			_sgaddr          = null;
			_wVersionKeyEx   = 0;
			_wFlagsKeyEx     = 0;
			_liTimeInit      = (ulong)DateTime.Now.Ticks;
			_fCs             = 0;
            
			dwServiceIds = new uint[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
            
			xUsers = new XUIDAndTrust[XOn.XONLINE_MAX_LOGON_USERS];
			for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ ) 
			{   
				xUsers[i] = new XUIDAndTrust(0, 0, 0.0F);
			}

			dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];

			key = new byte[XONLINE_KEY_LENGTH];
		}
        
        protected const int XONLINE_MAX_ALTERNATE_TITLE_ID = 4;
        protected const int XONLINE_MAX_NUMBER_SERVICE_PER_TICKET = 12;
        protected const int XONLINE_MAX_DWORD_SERVICEIDS   = 4;
        protected const int XONLINE_MAX_PRIVILEGE_ID       = 256;
        protected const int XONLINE_NUM_PRIVILEGE_DWORDS   = 8;
        protected const int XONLINE_KEY_LENGTH = 16;
        protected const ushort XONLINE_AUTHDATA_VERSION   = 0x02 ;
        protected const ushort XONLINE_XENON_AUTHDATA_VERSION   = 0x03 ;

        //  the following fields are in the SG Info structure. (XKERB_AD_XENON)
        //

        public ushort    wAuthDataVersion;
        public ushort    wAuthDataSize;        // Size of this struct in bytes

        // XBOX_LIBRARY_VERSION     clientVersion;
        public ushort    wMajorVersion;
        public ushort    wMinorVersion;
        public ushort    wBuildNumber;
        public ushort    wQFENumber;
        //

        public uint      dwTitleID;
        public uint      dwTitleVersion;
        public uint      dwTitleRegion;
        public uint      dwConsoleRegion;
        public uint      dwMediaID;
        public ushort    wLanguageID;

        // authdata flags
        public const uint XONLINE_AUTHDATA_FLAGS_ISXENON_MASK = 0x01;
        public uint      dwAuthDataFlags;

        public ushort    wNumPrivileges;
        public uint[]    dwPrivileges;

        public ulong     qwXboxID;

        //List of alternate title IDs
        //DWORD dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID]
        public uint[]    dwAltTitleID;

        // Key used for signing data within a session
        public byte[]    key;

        // The high 16 bits of dwUserFlags should come from the UODB User Table.
        public XUIDAndTrust[]   xUsers;

        public uint     dwNumServices;
        public ushort   wNumDwordServices;

        //DWORD dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
        public uint[]   dwServiceIds;
        //

    
        // the rest of the spidata structure (CSgMsgSpiData)

        public ushort  _ipportI;                   // IP port of the client on the Internet
        public uint    _ipaI;                      // IP address of the client on the Internet
        public byte[]  _sgaddr;                    // SGADDR of the client
        public ushort  _wVersionKeyEx;             // KeyEx version of the client
        public ushort  _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        public ulong   _liNonce;                   // A random nonce associated with this session
        public ulong   _liTimeInit;                // FILETIME marking session initiation
        public uint    _fCs;                       // TRUE if SG is providing connection services

        // size of the spidata structure
        public const int sizeSpiData = 186;
        public const int sizeSpiData2 = 54;


        // the following is the STATIC request number.  it is initialized to 0, and
        // should only be used with the Interlocked.Increment protection
        //
        public static int staticRequestNumber = 0;

        // the instance reqnum, set when a request is first made.
        public int thisRequestNumber;

        // config settings
        //
        public static int _maxRetries;
        public static int _sgTimeout;

        // SG ip
        public IPAddress _srcIP;

        public byte[] ConstructAuthData()
        {
            int i;
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);
            w.Write(wAuthDataVersion);
            w.Write(wAuthDataSize);
            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(dwTitleID);
            w.Write(dwTitleVersion);
            w.Write(dwTitleRegion);
            w.Write(dwConsoleRegion);
            w.Write(dwMediaID);
            w.Write(wLanguageID);
            w.Write(dwAuthDataFlags);

            w.Write(wNumPrivileges);
            Debug.Assert( dwPrivileges != null && dwPrivileges.Length == XONLINE_NUM_PRIVILEGE_DWORDS );
            for (i=0; i < dwPrivileges.Length; i++)
            {
                w.Write(dwPrivileges[i]);
            }

            w.Write(qwXboxID);
            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].qwUserID);
                w.Write(xUsers[i].dwUserFlags);
            }

            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].userTrust);
            }

            w.Write(wNumDwordServices);
            Debug.Assert( dwServiceIds != null && dwServiceIds.Length == XONLINE_MAX_DWORD_SERVICEIDS );
            for (i=0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                w.Write(dwServiceIds[i]);
            }

            for (i=0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                w.Write(dwAltTitleID[i]);
            }

            w.Write(key);

            return m.ToArray();
        }

		public string ConstructBase64String()
		{
			MemoryStream m = new MemoryStream(200);
			BinaryWriter w = new BinaryWriter(m);
			w.Write(HTTPAuthData.HTTP_HEADER_AUTH_DATA_VERSION);
			w.Write(_ipportI);
			w.Write(_ipaI);
			w.Write(_liNonce);
			w.Write(ConstructAuthData());

			return Convert.ToBase64String(m.ToArray());
		}
                
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\ITcpClient.cs ===
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;

namespace ServerTestFramework.LiveService
{

/// <summary>
/// Interface used by FDTransaction to send traffic to LIVE services.
/// </summary>
public interface ITcpClient
{
    /// <summary>Get the underlying socket for the client.</summary>
    ISocket Client { get; }

    /// <summary>Indicates exclusive address use.</summary>
    bool ExclusiveAddressUse { set; }

    /// <summary>The receive timeout of the client.</summary>
    int ReceiveTimeout { set; }

    /// <summary>The send timeout of the client.</summary>
    int SendTimeout { set; }

    /// <summary>Size of the receive buffer.</summary>
    int ReceiveBufferSize { get; }

    /// <summary>Connects to the given remote endpoint.</summary>
    void Connect (IPEndPoint endpoint);

    /// <summary>Gets the NetworkStream associated with the client.</summary>
    Stream GetStream ();

    /// <summary>Closes the client.</summary>
    void Close ();
}

/// <summary>
/// Interface used by FDTransaction to access the underlying socket for an ITcpClient.
/// </summary>
public interface ISocket
{
    /// <summary>The local endpoint of the socket.</summary>
    EndPoint LocalEndPoint { get; }

    /// <summary>Shuts down the socket with the given parameter.</summary>
    void Shutdown (SocketShutdown how);

    /// <summary>Receive from the socket.</summary>
    int Receive (byte[] buffer);

    /// <summary>Closes the socket.</summary>
    void Close ();
}

/// <summary>
/// Converts a Socket to an ISocket.
/// </summary>
public class SocketToISocket : ISocket
{
    protected Socket _socket;

    public SocketToISocket (Socket socket)
    {
        _socket = socket;
    }

    #region ISocket Members

    public EndPoint LocalEndPoint
    {
        get { return _socket.LocalEndPoint; }
    }

    public void Shutdown (SocketShutdown how)
    {
        _socket.Shutdown(how);
    }

    public int Receive (byte[] buffer)
    {
        return _socket.Receive(buffer);
    }

    public void Close ()
    {
        _socket.Close();
    }

    #endregion
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\FDTransaction.cs ===
using System;
using System.Collections.Generic;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Globalization;
using System.Diagnostics;
using System.Runtime.Remoting.Messaging;
using ServerTestFramework.LiveService.FakeSG;


namespace ServerTestFramework.LiveService
{
    // ****************************************
    // FD Transaction
    //  Utility class to perform HTTP transaction with Front Door servers
    //
    public class FDTransaction : IDeepCloneable
    {
        /// <summary>
        /// IP or DNS name of server
        /// </summary>
        public IPEndPoint endPoint = null;

        /// <summary>
        /// FD transactions can be UDP or TCP now
        /// </summary>
        public enum Transports
        {
            TCP,
            UDP
        }

        /// <summary>
        /// Use the UDP protocol transport for delivery
        /// </summary>
        public Transports transport = Transports.TCP;

        public static int sReceiveTimeOut = 35000;
        public static int sSendTimeOut = 35000;

        // For billing related requests, use a longer timeout 130 seconds.
        public const int BillingReceiveTimeout = 130000;

        public int ReceiveTimeOut = sReceiveTimeOut;
        public int SendTimeOut = sSendTimeOut;

        // if this flag is set to true then we will not wait for any UDP response.
        public bool IgnoreUDPReceive = false;

        /// <summary>
        /// http status in response
        /// </summary>
        public HttpStatusCode httpStatus
        {
            get { return _httpStatus; }
        }
        private HttpStatusCode _httpStatus = HttpStatusCode.NotFound;

        /// <summary>
        /// Buffer sized to contain raw contents of response
        /// </summary>
        public byte[] ResponseContents
        {
            get { return _respBuff; }
        }
        private byte[] _respBuff = null;

        /// <summary>
        /// Buffer sized to contain raw contents of error response
        /// </summary>
        public byte[] ErrorContents
        {
            get { return _errBuff; }
        }
        private byte[] _errBuff = null;

        [ThreadStatic]
        static byte[] responseData;

        /// <summary>
        /// Value returned in XErr header field when http response status is 500.
        /// </summary>
        public uint XErr
        {
            get { return _XErr; }
        }
        private uint _XErr = HResult.E_FAIL;

        public bool AppendSGIPPort = false;


        /// <summary>
        /// HTTP response header for client-side throttling
        /// </summary>
        public uint XDelay
        {
            get { return _XDelay; }
        }
        private uint _XDelay = 0;

        private int GetEndOfHeaderIndex(byte[] bytes)
        {
            // There may or may not be a complete header at this point
            int endOfHeader = -1;
            for (int i = 3; i < bytes.Length; i++)
            {
                if (bytes[i - 3] == '\r' && bytes[i - 2] == '\n' && bytes[i - 1] == '\r' && bytes[i] == '\n')
                {
                    endOfHeader = i;
                    break;
                }
            }
            return (endOfHeader);
        }

        private string GetHeaderString(byte[] bytes)
        {
            string header = null;
            int eohIdx = GetEndOfHeaderIndex(bytes);
            if (0 != eohIdx)
            {
                // We have header
                header = Encoding.ASCII.GetString(bytes, 0, eohIdx + 1);
            }
            return (header);
        }

        public Dictionary<string, string> GetHeader()
        {
            if (responseData == null)
            {
                return null;
            }

            string headerString = GetHeaderString(responseData);
            if (headerString == null)
            {
                return null;
            }
            Dictionary<string, string> headerDict = new Dictionary<string,string>();
            string[] fields = headerString.Split('\n');
            foreach (string field in fields)
            {
                string[] parts = field.Split(new char[] { ':' }, 2);
                if (parts.Length == 2)
                {
                    headerDict.Add(parts[0].Trim(), parts[1].Trim());
                }
            }
            return headerDict;
        }

        public object DeepClone()
        {
            // Shallow first
            FDTransaction clone = (FDTransaction)this.MemberwiseClone();
            // Then make it deep
            if (_respBuff != null)
            {
                clone._respBuff = (byte[])this._respBuff.Clone();
            }
            if (this.endPoint != null)
            {
                clone.endPoint = (IPEndPoint)this.endPoint.Create(this.endPoint.Serialize());
            }
            return (clone);
        }

        /*
                Regex RegexHttp=new Regex(@"HTTP\/1\.1 (?<error>(\d)+)");
                Regex RegexLength=new Regex(@"Content-Length: (?<length>(\d)+)");
                Regex RegexXerr=new Regex(@"X-Err: (?<XErr>(.)+)");
        */

        private uint HexToInt(byte b)
        {
            if (b >= 'a')
                return (uint)b - 'a' + 10;
            if (b >= 'A')
                return (uint)b - 'A' + 10;
            return (uint)b - '0';
        }

        private unsafe void ParseReturn(byte[] data, out HttpStatusCode StatusCode, out uint ixErr, out uint ixDelay, out int contentLen)
        {
            int iError = 0;
            int i;
            int len = data.Length;
            contentLen = 0;

            /*
             *  This code will dump []data to the console. Every now and then this will come in handy
             * to diagnose things. I recommend we keep this here.
                        ASCIIEncoding AE=new ASCIIEncoding();
                        char []buf=new Char[data.Length];
                        int len2=AE.GetDecoder().GetChars(data,0,data.Length,buf,0);
                        for (i=0; i<len2; i++)
                            Console.Write(buf[i]);
                        Console.WriteLine("\n");
             */

            fixed (byte* pData = data)
            {
                // find HTTP error code
                byte* p = pData + 9;
                iError = (*(p) - '0') * 100;
                iError += (*(p + 1) - '0') * 10;
                iError += (*(p + 2) - '0');

                // find XError code
                ixErr = 0;
                ixDelay = 0;
                for (i = 5; i < len; i += 2)
                {
                    if (p[i] <= 0x0D)
                    {
                        // this is a part of a CRLF. Let's see which
                        if (p[i] == 0x0D)
                            i += 2;
                        else
                            i++;

                        if (p[i] == 0x0D && p[i + 1] == 0x0A)
                            break;

                        if (p[i] == 'X')
                        {
                            if (p[i + 1] != '-' || (p[i + 2] != 'E' && p[i + 2] != 'D'))
                                continue;
                            // this may be X-Err or X-Delay (but don't be fooled by X-Event)
                            if (p[i + 2] == 'E' && p[i + 3] == 'r' && p[i + 4] == 'r')
                            {
                                i += 7;
                                // Is the error code '0x' prefixed?
                                if (p[i] == '0' && p[i + 1] == 'x')
                                {
                                    i += 2;
                                }
                                int j = i;
                                ixErr = 0;
                                int digits = 0;
                                while (p[j] >= '0' && digits < 8)
                                {
                                    ixErr <<= 4;
                                    ixErr += HexToInt(p[j]);
                                    j++;
                                    digits++;
                                }
                            }
                            else    //'D'
                            {
                                i += 9;
                                int j = i;
                                ixDelay = 0;
                                while (p[j] >= '0' && p[j] <= '9')
                                {
                                    ixDelay *= 10;
                                    ixDelay += (uint)(p[j] - '0');
                                    j++;
                                }
                            }
                        }
                        else if ((p[i] == 'C') && (p[i + 1] == 'o') && (p[i + 2] == 'n') && (p[i + 3] == 't'))
                        {
                            if ((p[i + 7] == '-') && (p[i + 8] == 'L'))
                            {
                                int j = i + 16; // j is the beginning of contentLen
                                contentLen = 0;
                                while (p[j] > 0x0D)
                                {
                                    contentLen = contentLen * 10 + (p[j] - '0');
                                    j++;
                                }
                            }
                        }
                    }
                }
            }
            StatusCode = HttpStatusCode.InternalServerError;

            switch (iError)
            {
                case 200:
                    StatusCode = HttpStatusCode.OK;
                    break;
                case 100:
                    StatusCode = HttpStatusCode.Continue;
                    break;
                case 400:
                    StatusCode = HttpStatusCode.BadRequest;
                    break;
                case 401:
                    StatusCode = HttpStatusCode.Unauthorized;
                    break;
                case 403:
                    StatusCode = HttpStatusCode.Forbidden;
                    break;
                case 404:
                    StatusCode = HttpStatusCode.NotFound;
                    break;
                case 405:
                    StatusCode = HttpStatusCode.MethodNotAllowed;
                    break;
                case 500:
                    StatusCode = HttpStatusCode.InternalServerError;
                    break;
                case 503:
                    StatusCode = HttpStatusCode.ServiceUnavailable;
                    break;
                default:
                    throw new Exception("Unknown http status code " + iError);
            }

        }

        // ----------------------------------------
        // Method: Execute
        //  Does http POST to url built from server and service and loads results into
        //  ResponseContents and XErr when appropriate.
        //  Params:
        //      reqStream - XRL data packed and ready for request contents.
        //  Returns
        //      true -  http rstatus is 200 or 500, the only possible values returned by a FD code.
        //                  XErr and ResponseContents are worth checking out.
        //      false - http status is something else.  XErr isn't set, but ResponseContents might not be empty.
        //
        //  This version also accepts a port number. The request will be sent out from that port
        //
        static int counter = 0;

        public class MyTcpClient : System.Net.Sockets.TcpClient, ITcpClient
        {
            public ushort Bind()
            {
                Client.Bind(new IPEndPoint(IPAddress.Any, 0));
                return (ushort)((IPEndPoint)Client.LocalEndPoint).Port;
            }
            ISocket ITcpClient.Client
            {
                get
                {
                    return new SocketToISocket(base.Client);
                }
            }

            Stream ITcpClient.GetStream ()
            {
                return base.GetStream();
            }
        }

        public class MyUdpClient : System.Net.Sockets.UdpClient, IUdpClient
        {
            public ushort Bind()
            {
                Client.Bind(new IPEndPoint(IPAddress.Any, 0));
                return (ushort)((IPEndPoint)Client.LocalEndPoint).Port;
            }
            public new Socket Client
            {
                get
                {
                    return base.Client;
                }
            }

            #region IUdpClient Members

            int IUdpClient.ReceiveTimeout
            {
                set
                {
                    Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, value);
                }
            }

            int IUdpClient.SendTimeout
            {
                set
                {
                    Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, value);
                }
            }

            IPEndPoint IUdpClient.LocalIPEndPoint
            {
                get
                {
                    return (IPEndPoint)Client.LocalEndPoint;
                }
            }

            #endregion
        }

        /// <summary>Delegate for an external TcpClient source.</summary>
        public delegate ITcpClient AcquireTcpClientDelegate (IPEndPoint remote);

        /// <summary>Delegate for an external TcpClient source.</summary>
        public static AcquireTcpClientDelegate ExternalTcpClient = null;

        /// <summary>
        /// Gets an ITcpClient for use in communicating with the given remote server.
        /// </summary>
        /// <param name="remote">The remote server that the request is bound for.</param>
        /// <returns>An ITcpClient for use in communicating with the remote server.</returns>
        protected static ITcpClient AcquireTcpClient (IPEndPoint remote)
        {
            if (ExternalTcpClient != null)
            {
                ITcpClient ans = ExternalTcpClient(remote);

                if (ans != null)
                {
                    return ans;
                }
            }

            // fall back to default if no one wants to offer one
            return new MyTcpClient();
        }

        /// <summary>Delegate for an external UdpClient source.</summary>
        public delegate IUdpClient AcquireUdpClientDelegate (IPEndPoint remote);

        /// <summary>Delegate for an external UdpClient source.</summary>
        public static AcquireUdpClientDelegate ExternalUdpClient = null;

        /// <summary>
        /// Gets an IUdpClient for use in communicating with the given remote server.
        /// </summary>
        /// <param name="remote">The remote server that the request is bound for.</param>
        /// <returns>An IUdpClient for use in communicating with the remote server.</returns>
        protected static IUdpClient AcquireUdpClient (IPEndPoint remote)
        {
            if (ExternalUdpClient != null)
            {
                IUdpClient ans = ExternalUdpClient(remote);

                if (ans != null)
                {
                    return ans;
                }
            }

            // fall back to default if no one wants to offer one
            return new MyUdpClient();
        }

        public bool Execute(byte[] httpHeader, ref CSGInfo Slot) { return Execute(httpHeader, null, ref Slot, true); }
        public bool Execute(byte[] httpHeader, MemoryStream reqStream, ref CSGInfo Slot) { return Execute(httpHeader, reqStream, ref Slot, true); }
        public bool Execute(byte[] httpHeader, MemoryStream reqStream, ref CSGInfo Slot, bool noContinue)
        {
            return Execute(httpHeader, reqStream, ref Slot, true, false);
        }

        public bool Execute(byte[] httpHeader, MemoryStream reqStream, ref CSGInfo Slot, bool noContinue, bool useHttpAuth)
        {
            switch (transport)
            {
                case Transports.TCP:
                    return ExecuteTCP(httpHeader, reqStream, ref Slot, noContinue, useHttpAuth);
                case Transports.UDP:
                    return ExecuteUDP(httpHeader, reqStream, ref Slot);
            }
            return false;
        }

        public bool ExecuteTCP(byte[] httpHeader, ref CSGInfo Slot)
        {
            return ExecuteTCP(httpHeader, null, ref Slot, true);
        }

        public bool ExecuteTCP(byte[] httpHeader, MemoryStream reqStream, ref CSGInfo Slot, bool noContinue)
        {
            return ExecuteTCP(httpHeader, reqStream, ref Slot, noContinue, false);
        }

        public bool ExecuteTCP(byte[] httpHeader, MemoryStream reqStream, ref CSGInfo Slot, bool noContinue, bool useHttpAuth)
        {
            ITcpClient localClient = null;
            Stream outStream = null;

            try
            {
                try
                {
                    int retries = 0;
                    while (true)
                    {
                        localClient = AcquireTcpClient(endPoint);
                        localClient.ExclusiveAddressUse = true;
                        localClient.ReceiveTimeout = ReceiveTimeOut;
                        localClient.SendTimeout = SendTimeOut;
                        Exception exc = null;

                        try
                        {
                            localClient.Connect(endPoint);
                            break;
                        }
                        catch (System.Net.Sockets.SocketException e)
                        {
                            exc = e;
                        }
                        catch (ServerTestFramework.LiveService.Auth.TcpForSGConnectionException e)
                        {
                            // ensure that the client is closed quickly
                            localClient.Close();

                            exc = e;
                        }

                        retries++;
                        if (retries == 5)
                        {
                            Global.RO.Info("Call to Connect() failed: " + exc.ToString() + "\r\nRetries exhausted; giving up.");
                            throw new FDTransactionException("Connect retries exhausted; giving up.", exc);
                        }
                        Global.RO.Info("Call to Connect() failed: " + exc.ToString() + "\r\nAttempting retry #" + retries);
                    }

                    if (useHttpAuth)
                    {
                        byte[] authHeader = Slot.GetHttpAuthHeaderBytes((IPEndPoint)localClient.Client.LocalEndPoint);

                        byte[] oldHttpHeader = httpHeader;
                        httpHeader = new byte[httpHeader.Length + authHeader.Length];
                        Array.Copy(oldHttpHeader, 0, httpHeader, 0, oldHttpHeader.Length - 2);
                        Array.Copy(authHeader, 0, httpHeader, oldHttpHeader.Length - 2, authHeader.Length);
                        httpHeader[httpHeader.Length - 2] = 0xD;
                        httpHeader[httpHeader.Length - 1] = 0xA;

                    }
                    else
                    {
                        Slot.port = (ushort)((IPEndPoint)localClient.Client.LocalEndPoint).Port;
                        if (GlobalFakeSG.FakeSG != null)
                            GlobalFakeSG.FakeSG.PutSlot(ref Slot, ((IPEndPoint)localClient.Client.LocalEndPoint).Address);
                    }

                }
                catch (Exception e)
                {
                    Interlocked.Increment(ref counter);

                    // We log here with this counter for stress applications
                    Global.RO.Error("Error communicating with Host: {0}, Message: {1}, Counter: {2}",
                        (endPoint==null?"null":endPoint.ToString()), e.Message, counter);

                    throw;
                }

                if (AppendSGIPPort)
                {
                    // append SGIPPort header
                    string sgipport = "SGIPPort: " + ((IPEndPoint)localClient.Client.LocalEndPoint).ToString() + "\r\n\r\n";
                    byte[] sgipportBytes = Encoding.ASCII.GetBytes(sgipport);

                    byte[] oldHttpHeader = httpHeader;
                    httpHeader = new byte[httpHeader.Length - 2 + sgipportBytes.Length];
                    Array.Copy(oldHttpHeader, 0, httpHeader, 0, oldHttpHeader.Length - 2);
                    Array.Copy(sgipportBytes, 0, httpHeader, oldHttpHeader.Length - 2, sgipportBytes.Length);
                }

                outStream = localClient.GetStream();

                if (responseData == null)
                {
                    responseData = new byte[localClient.ReceiveBufferSize];
                }
                int contentLen;
                if (noContinue)
                {
                    //local memory stream should be disposed via using
                    using (MemoryStream fullReq = new MemoryStream())
                    {
                        fullReq.Write(httpHeader, 0, httpHeader.Length);
                        //only write out the body (POST) if one was provided
                        if (reqStream != null && reqStream.Length > 0)
                            fullReq.Write(reqStream.GetBuffer(), 0, (int)reqStream.Length);

                        byte[] data = fullReq.GetBuffer();
                        if (data.Length > 0)    //only write to the stream if we have any data
                            outStream.Write(data, 0, (int)fullReq.Length);
                    }
                }
                else
                {
                    outStream.Write(httpHeader, 0, httpHeader.Length);

                    // This is where we get our Continue (100)
                    outStream.Read(responseData, 0, responseData.Length);
                    ParseReturn(responseData, out _httpStatus, out _XErr, out _XDelay, out contentLen);
                    if (_httpStatus != HttpStatusCode.Continue)
                    {
                        // We didn't get a continue... just exit
                        _XErr = 1;
                        return false;
                    }

                    // This is where we write out request
                    // only write out the body (POST) if one was provided
                    if (reqStream != null && reqStream.Length > 0)
                    {
                        byte[] data = reqStream.GetBuffer();
                        outStream.Write(data, 0, (int)reqStream.Length);
                    }
                }

                int bytesRead = outStream.Read(responseData, 0, responseData.Length);

                ParseReturn(responseData, out _httpStatus, out _XErr, out _XDelay, out contentLen);

                //The HEAD method is identical to GET except that the server DOES NOT return a message-body in the response.
                // if the request type is head do not read data.
                if (_httpStatus == HttpStatusCode.OK && !IsHeadRequest( httpHeader))
                {
                    int dataIndex = 0;
                    for (int i = 0; i < bytesRead - 3; i++)
                    {
                        if (responseData[i] == 0x0D && responseData[i + 1] == 0x0A &&
                            responseData[i + 2] == 0x0D && responseData[i + 3] == 0x0A)
                        {
                            dataIndex = i + 4;
                            break;
                        }
                    }

                    _respBuff = new byte[contentLen];
                    if (contentLen + dataIndex > bytesRead)
                    {
                        Array.Copy(responseData, dataIndex, _respBuff, 0, bytesRead - dataIndex);

                        int index = bytesRead - dataIndex;
                        while (index < contentLen)
                        {
                            if (contentLen - index > 1024)
                                index += outStream.Read(_respBuff, index, 1024);
                            else
                                index += outStream.Read(_respBuff, index, contentLen - index);
                        }
                    }
                    else
                    {
                        Array.Copy(responseData, dataIndex, _respBuff, 0, contentLen);
                    }
                }
                else if (!IsHeadRequest(httpHeader))
                {
                    int dataIndex = 0;
                    for (int i = 0; i < bytesRead - 3; i++)
                    {
                        if (responseData[i] == 0x0D && responseData[i + 1] == 0x0A &&
                            responseData[i + 2] == 0x0D && responseData[i + 3] == 0x0A)
                        {
                            dataIndex = i + 4;
                            break;
                        }
                    }

                    _errBuff = new byte[contentLen];
                    if (contentLen + dataIndex > bytesRead)
                    {
                        Array.Copy(responseData, dataIndex, _errBuff, 0, bytesRead - dataIndex);

                        int index = bytesRead - dataIndex;
                        while (index < contentLen)
                        {
                            if (contentLen - index > 1024)
                                index += outStream.Read(_errBuff, index, 1024);
                            else
                                index += outStream.Read(_errBuff, index, contentLen - index);
                        }
                    }
                    else
                    {
                        Array.Copy(responseData, dataIndex, _errBuff, 0, contentLen);
                    }
                }



                // Send and receive should be shutdown independently of each other
                // Do a half-close on the underlying socket
                ISocket s = localClient.Client;
                s.Shutdown(SocketShutdown.Both);
                s.Close();
            }
            finally
            {
                if (outStream != null)
                    outStream.Close();
                localClient.Close();
            }

            if (_httpStatus != HttpStatusCode.OK)
            {
                // We didn't get a continue... just ext
                if (_httpStatus == HttpStatusCode.Continue)
                {
                    //  This should never happen - we don't support multiple Continues
                    _XErr = 2;
                    return false;
                }
                return false;
            }

            return true;
        }

        public void EstablishConnection (bool useHttpAuth, byte[] httpHeader, ref CSGInfo Slot, out ITcpClient localClient) 
        {
            try
            {
                int retries = 0;
                while (true)
                {
                    localClient = AcquireTcpClient(endPoint);
                    localClient.ExclusiveAddressUse = true;
                    localClient.ReceiveTimeout = ReceiveTimeOut;
                    localClient.SendTimeout = SendTimeOut;
                    Exception exc = null;

                    try
                    {
                        localClient.Connect(endPoint);
                        break;
                    }
                    catch (System.Net.Sockets.SocketException e)
                    {
                        exc = e;
                    }
                    catch (ServerTestFramework.LiveService.Auth.TcpForSGConnectionException e)
                    {
                        // ensure that the client is closed quickly
                        localClient.Close();

                        exc = e;
                    }

                    retries++;
                    if (retries == 5)
                    {
                        Global.RO.Info("Call to Connect() failed: " + exc.ToString() + "\r\nRetries exhausted; giving up.");
                        throw new FDTransactionException("Connect retries exhausted; giving up.", exc);
                    }
                    Global.RO.Info("Call to Connect() failed: " + exc.ToString() + "\r\nAttempting retry #" + retries);
                }

            }
            catch (Exception e)
            {
                Interlocked.Increment(ref counter);

                // We log here with this counter for stress applications
                Global.RO.Error("Error communicating with Host: {0}, Message: {1}, Counter: {2}",
                                (endPoint==null?"null":endPoint.ToString()), e.Message, counter);

                throw;
            }
        }

        public void AppendSGIPPortHeader (byte[] httpHeader, ITcpClient localClient)
        {
            // append SGIPPort header
            string sgipport = "SGIPPort: " + ((IPEndPoint)localClient.Client.LocalEndPoint).ToString() + "\r\n\r\n";
            byte[] sgipportBytes = Encoding.ASCII.GetBytes(sgipport);

            byte[] oldHttpHeader = httpHeader;
            httpHeader = new byte[httpHeader.Length - 2 + sgipportBytes.Length];
            Array.Copy(oldHttpHeader, 0, httpHeader, 0, oldHttpHeader.Length - 2);
            Array.Copy(sgipportBytes, 0, httpHeader, oldHttpHeader.Length - 2, sgipportBytes.Length);
        }

        //a class for holding the state required during an XRL request.  Public so that the callback
        //delegate can hold it.  Implements IAsyncResult so that outer callers do not need access to
        //this type.
        public class RequestState : IAsyncResult {
            public Stream outStream;
            public MemoryStream reqStream;
            public byte [] httpHeader;
            public bool noContinue;
            public int contentLen;
            public AsyncCallback requestCompleteCallback;
            public byte [] responseData;
            public ITcpClient tcpClient;
            public bool success;
            public RequestStage stage;
            public XRLPayload xrl;
            //variables not created on construction
            public int index; //where in the response buffer we should write to next.
            public Exception e; //if an exception occurs during execution, store it here.

            public enum RequestStage {
                CONNECTING = 0,
                SENDING,
                RECEIVING,
                COMPLETE
            }

            public RequestState(Stream outStream,
                                MemoryStream reqStream,
                                byte [] httpHeader,
                                bool noContinue,
                                int contentLen,
                                AsyncCallback requestCompleteCallback,
                                byte [] responseData,
                                ITcpClient tcpClient,
                                bool success,
                                RequestStage stage,
                                XRLPayload xrl) 
            {
                this.outStream = outStream;
                this.reqStream = reqStream;
                this.httpHeader = httpHeader;
                this.noContinue = noContinue;
                this.contentLen = contentLen;
                this.requestCompleteCallback = requestCompleteCallback;
                this.responseData = responseData;
                this.tcpClient = tcpClient;
                this.success = success;
                this.stage = stage;
                this.xrl = xrl;
            }
            //Return this as the object containing state.
            public Object AsyncState
            {
                get { return this; }
            }

            //Currently not used.  Do not wait on this object.
            public WaitHandle AsyncWaitHandle
            {
                get { return null; }
            }

            //not used.
            public bool CompletedSynchronously 
            {
                get { return false; }
            }

            public bool IsCompleted
            {
                get { return (stage == RequestStage.COMPLETE); }
            }
        }

        //Perform this XRL Request asynchronously.  This method returns immediately after calling
        //BeginWriteRequest.  Further processing begins on the thread spawned inside the
        //BeginWriteRequest.  RequestCompleteCallback is given to every method that continues
        //processing up until the read is complete, and then executes it. If anything goes wrong, we
        //call the callback and bail.
        public IAsyncResult BeginExecute(byte[] httpHeader, MemoryStream reqStream, ref CSGInfo Slot, 
                                         bool noContinue, bool useHttpAuth, AsyncCallback requestCompleteCallback,
                                         XRLPayload xrl)
        {
            RequestState state = new RequestState(null, /*outStream,*/ reqStream, httpHeader, noContinue, 
                                                  0/*contentLen*/, requestCompleteCallback, null, 
                                                  null /*localClient*/, false, RequestState.RequestStage.CONNECTING, xrl);
            try {

                ITcpClient localClient;
                EstablishConnection(useHttpAuth, httpHeader, ref Slot, out localClient);
                if (useHttpAuth)
                {
                    byte[] authHeader = Slot.GetHttpAuthHeaderBytes((IPEndPoint)localClient.Client.LocalEndPoint);

                    byte[] oldHttpHeader = httpHeader;
                    httpHeader = new byte[httpHeader.Length + authHeader.Length];
                    Array.Copy(oldHttpHeader, 0, httpHeader, 0, oldHttpHeader.Length - 2);
                    Array.Copy(authHeader, 0, httpHeader, oldHttpHeader.Length - 2, authHeader.Length);
                    httpHeader[httpHeader.Length - 2] = 0xD;
                    httpHeader[httpHeader.Length - 1] = 0xA;

                }
                else
                {
                    Slot.port = (ushort)((IPEndPoint)localClient.Client.LocalEndPoint).Port;
                    if (GlobalFakeSG.FakeSG != null)
                        GlobalFakeSG.FakeSG.PutSlot(ref Slot, ((IPEndPoint)localClient.Client.LocalEndPoint).Address);
                }

                state.tcpClient = localClient;  //localClient and state.tcpClient are now synonymous
 
                if (AppendSGIPPort)
                {
                    AppendSGIPPortHeader(httpHeader, localClient);
                }

                state.outStream = state.tcpClient.GetStream();

                //Write the request.  Return false if the WriteRequest already got an error.
                if (!BeginWriteRequest(state)) {
                    //we've errored out already.  Call the requestCompleteCallback to clean up.
                    state.success = false;
                    state.requestCompleteCallback(state);
                }
                return state;
            }
            catch (Exception)
            {
                //if anything goes wrong, make sure we execute the callback.
                requestCompleteCallback(state);
                throw;
            }
        }

        //BeginWriteRequest starts posting the request, expecting that the socket has already been
        //connected.  BeginWrite hands off the write to another thread, with a callback for reading
        //the data.
        private bool BeginWriteRequest(RequestState state) 
        {
            try {
                state.stage = RequestState.RequestStage.SENDING;
                if (state.noContinue)
                {
                    state.contentLen = 0;
                    //local memory stream should be disposed via using
                    using (MemoryStream fullReq = new MemoryStream())
                    {
                        fullReq.Write(state.httpHeader, 0, state.httpHeader.Length);
                        //only write out the body (POST) if one was provided
                        if (state.reqStream != null && state.reqStream.Length > 0)
                            fullReq.Write(state.reqStream.GetBuffer(), 0, (int)state.reqStream.Length);

                        byte[] data = fullReq.GetBuffer();
                        if (data.Length > 0)    //only write to the stream if we have any data
                        {
                            state.outStream.BeginWrite(data, 0, (int)fullReq.Length, new AsyncCallback(OnWrite), state);
                        }
                    }
                }
                else
                {
                    state.outStream.Write(state.httpHeader, 0, state.httpHeader.Length);

                    // This is where we get our Continue (100)
                    state.outStream.Read(state.responseData, 0, state.responseData.Length);
                    ParseReturn(state.responseData, out _httpStatus, out _XErr, out _XDelay, out state.contentLen);
                    if (_httpStatus != HttpStatusCode.Continue)
                    {
                        // We didn't get a continue... just exit
                        _XErr = 1;
                        return false;
                    }

                    // This is where we write out request
                    // only write out the body (POST) if one was provided
                    if (state.reqStream != null && state.reqStream.Length > 0)
                    {
                        byte[] data = state.reqStream.GetBuffer();
                        state.outStream.BeginWrite(data, 0, (int)state.reqStream.Length, new AsyncCallback(OnWrite), state);
                    }
                }
            } catch (Exception e) {
                //if anything goes wrong, set the exception and return false, which calls the callback.
                state.e = e;
                return false;
            }
            return true;
        }    

        //this callback is called immediately after the write begins.  Its sole purpose is to wait
        //until the writing is complete.  Once complete, it will begin the read callback, which will
        //block until there is data to receive. 
        private void OnWrite(IAsyncResult ar) {
            RequestState state = (RequestState) ar.AsyncState;
            try {
                state.outStream.EndWrite(ar);
            } catch (Exception e) {
                state.e = e;
                state.requestCompleteCallback(state);
                return;
            }
            BeginReadRequest(state);
        }
        
        //this is called after all bytes have been written.  It kicks off the BeginRead, with a
        //callback to process the data.
        private void BeginReadRequest(RequestState state) {
            state.stage = RequestState.RequestStage.RECEIVING;

            if (state.responseData == null)
            {
                state.responseData = new byte[state.tcpClient.ReceiveBufferSize];
            }
            try {
                //Kick off the response-reading part.
                state.outStream.BeginRead(state.responseData, 0, state.responseData.Length, 
                                          new AsyncCallback(OnReadHeader), state);
            } catch (Exception e) {
                //If anything goes wrong, call the callback.
                state.e = e;
                state.requestCompleteCallback(state);
            }
        }
    

        //This callback begins the processing of data.  It begins with one async read request--when
        //any data comes back, that data is parsed for the contentLen.  Currently it appears this is
        //enough to get the content length, but it may need a reading loop to ensure this.  When
        //complete, if more data is necessary, it hands retrieving that data off to the next
        //callback method, OnReadData.
        private void OnReadHeader(IAsyncResult ar) {
            RequestState state = (RequestState) ar.AsyncState;
            try{
                int bytesRead = state.outStream.EndRead(ar);
                //do we need a reading loop here to make sure we have enough data for parsing the header?
                ParseReturn(state.responseData, out _httpStatus, out _XErr, out _XDelay, out state.contentLen);

                //The HEAD method is identical to GET except that the server DOES NOT return a message-body in the response.
                // if the request type is head do not read data.
                if (_httpStatus == HttpStatusCode.OK && !IsHeadRequest( state.httpHeader ))
                {
                    int dataIndex = 0;

                    //scan for the end of the HTTP Header, which is 0x0D0A0D0A
                    for (int i = 0; i < bytesRead - 3; i++)
                    {
                        if (state.responseData[i] == 0x0D && state.responseData[i + 1] == 0x0A &&
                            state.responseData[i + 2] == 0x0D && state.responseData[i + 3] == 0x0A)
                        {
                            dataIndex = i + 4;
                            break;
                        }
                    }

                    //prepare the data buffer, which is the response.
                    _respBuff = new byte[state.contentLen];
                    if (state.contentLen + dataIndex > bytesRead)
                    {
                        Array.Copy(responseData, dataIndex, _respBuff, 0, bytesRead - dataIndex);

                        state.index = bytesRead - dataIndex;
                        if (state.contentLen - state.index > 1024)
                            state.outStream.BeginRead(_respBuff, state.index, 1024, new AsyncCallback(OnReadData), state);
                        else
                            state.outStream.BeginRead(_respBuff, state.index, state.contentLen - state.index, 
                                                      new AsyncCallback(OnReadData), state);
                    }
                    else
                    {
                        Array.Copy(state.responseData, dataIndex, _respBuff, 0, state.contentLen);
                        state.stage = RequestState.RequestStage.COMPLETE;
                        //If we get here, the request is complete.  Call the callback which will call
                        //EndExecute to perform cleanup
                        state.requestCompleteCallback(state);
                    }
                }
                else
                {
                    //if we got here, we got an error in the http header, or there's nothing left.
                    //Call the callback, which will clean up for us.
                    state.requestCompleteCallback(state);
                }
            }
            catch (Exception e)
            {
                //if anything goes wrong, set the exception and call the callback.
                state.e = e;
                state.requestCompleteCallback(state);
            }
        }

        //This thread is called when we need to read the data portion of a response.  This is called
        //every time there is more data to be read.
        private void OnReadData(IAsyncResult ar) {
            RequestState state = (RequestState) ar.AsyncState;
            state.index += state.outStream.EndRead(ar); //increase where in the buffer we're
                                                          //storing data.
            
            if (state.index < state.contentLen)  //spin up another read if we don't have enough.
            {
                if (state.contentLen - state.index > 1024)
                    state.outStream.BeginRead(_respBuff, state.index, 1024, new AsyncCallback(OnReadData), state);
                else
                    state.outStream.BeginRead(_respBuff, state.index, state.contentLen - state.index, 
                                        new AsyncCallback(OnReadData), state);
            }            
            else
            {
                //we've read the whole response.  Call the callback, which will call
                //EndExecute to clean up the response.
                state.stage = RequestState.RequestStage.COMPLETE;
                state.requestCompleteCallback(state);
            }
        }

        public bool EndExecute(IAsyncResult ar) {
            RequestState state = (RequestState) ar.AsyncState;

            //clean up the client.
            if (state.outStream != null) 
                state.outStream.Close();
            state.tcpClient.Close();

            try{
                // Send and receive should be shutdown independently of each other
                // Do a half-close on the underlying socket
                ISocket s = state.tcpClient.Client;
                s.Shutdown(SocketShutdown.Send);
                
                // Give the other side time to close its part (our "receive" half) of the connection
                while (s.Receive(responseData) > 0)
                {
                }
                
                s.Close();
            } catch (ObjectDisposedException) {
                //they closed up the socket on their side--we don't have to do any shutdown details.
            }
            //interpret the result.
            if (_httpStatus != HttpStatusCode.OK)
            {
                // We didn't get a continue... just ext
                if (_httpStatus == HttpStatusCode.Continue)
                {
                    //  This should never happen - we don't support multiple Continues
                    _XErr = 2;
                    return false;
                }
                return false;
            }

            return true;
        }

        /*
         * Panaroma is making head request and XRlScan test uses this.
         * The HEAD method is identical to GET except that the server DOES NOT return a message-body in the response.
         * this code comparesthe first 4 Chars to "HEAD"
         */
        public bool IsHeadRequest(byte[] httpHeader)
        {
            if (httpHeader[0] == 72 && httpHeader[1] == 69 && httpHeader[2] == 65 && httpHeader[3] == 68)
                return true;

            return false;
        }

        public bool ExecuteUDP(byte[] httpHeader, MemoryStream reqStream, ref CSGInfo Slot)
        {
            IUdpClient localClient = AcquireUdpClient(endPoint);
            localClient.ReceiveTimeout = ReceiveTimeOut;
            localClient.SendTimeout = SendTimeOut;

            try
            {
                try
                {
                    localClient.Connect(endPoint);
                    Slot.port = (ushort)localClient.LocalIPEndPoint.Port;
                    if (GlobalFakeSG.FakeSG != null)
                        GlobalFakeSG.FakeSG.PutSlot(ref Slot, localClient.LocalIPEndPoint.Address);
                }
                catch (Exception e)
                {
                    Interlocked.Increment(ref counter);

                    // We log here with this counter for stress applications
                    Global.RO.Error("Error communicating with Host: {0}, Message: {1}, Counter: {2}",
                            endPoint.ToString(), e.Message, counter);

                    throw e;
                }

                int contentLen;

                MemoryStream fullReq = new MemoryStream((int)(httpHeader.Length + reqStream.Length));

                fullReq.Write(httpHeader, 0, httpHeader.Length);
                fullReq.Write(reqStream.GetBuffer(), 0, (int)reqStream.Length);

                byte[] data = fullReq.GetBuffer();

                localClient.Send(data, data.Length);

                if (!IgnoreUDPReceive)
                {
                    byte[] responseData = localClient.Receive(ref endPoint);
                    int bytesRead = responseData.Length;
                    ParseReturn(responseData, out _httpStatus, out _XErr, out _XDelay, out contentLen);
                    if (_httpStatus == HttpStatusCode.OK)
                    {
                        int dataIndex = 0;
                        for (int i = 0; i < bytesRead - 3; i++)
                        {
                            if (responseData[i] == 0x0D && responseData[i + 1] == 0x0A &&
                                responseData[i + 2] == 0x0D && responseData[i + 3] == 0x0A)
                            {
                                dataIndex = i + 4;
                                break;
                            }
                        }

                        _respBuff = new byte[contentLen];
                        if (contentLen + dataIndex > bytesRead)
                        {
                            throw new Exception("FDTransaction: corrupt UDP response");
                        }
                        else
                        {
                            Array.Copy(responseData, dataIndex, _respBuff, 0, contentLen);
                        }
                    }
                }
                else
                {
                    _respBuff = new byte[0];
                    _httpStatus = HttpStatusCode.OK;
                    this._XErr = HResult.S_OK;
                }
            }
            finally
            {
                localClient.Close();
            }

            if (_httpStatus != HttpStatusCode.OK)
            {
                // We didn't get a continue... just ext
                if (_httpStatus == HttpStatusCode.Continue)
                {
                    //  This should never happen - we don't support multiple Continues
                    _XErr = 2;
                    return false;
                }
                return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Exception thrown by FDTransaction.
    /// </summary>
    public class FDTransactionException : Exception
    {
        public FDTransactionException (string message, Exception inner) : base(message, inner) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\GameConfig.cs ===
using System;
using System.Collections;
using xonline.common.config;

namespace ServerTestFramework.LiveService
{

	public class Achievemt 
	{
		public uint  AchievementId = 0;
		public byte  Type          = 0;
		public int   Weight          = 0;
        public uint  ImageId       = 0;
		public string Title      = "";
        public string Description  = "";
		public bool ShowUnachieved=false;
		public string HowTo  = "";
        public uint[] NextIds      = null;
        public uint[] ReplaceIds      = null;

		

		
	}

	public class ContextStr
	{
		public uint ContextId;
		public string Name;
	}    


	/// <summary>
	/// Summary description for GameConfig.
	/// </summary>
    public class GameConfig
    {
        Hashtable titlesCfg = new Hashtable();
        public GameConfig()
        {
        }

        public void Load(uint[] titles)
        {

            for (int i = 0; i < titles.Length; i++)
            {
                try
                {
                    if (!titlesCfg.Contains(titles[i]))
                        titlesCfg.Add(titles[i], TitleConfig.GetTitle(titles[i]));
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn(e.ToString());
                }
            }
        }

        public Hashtable GetAchivement(uint title, ushort LocaleId, bool isweb)
        {
            Hashtable retval = new Hashtable();

            if (titlesCfg.ContainsKey(title))
            {
                // convert localeid to the string representation
                string localeName = Enum.GetName(typeof(Locales), LocaleId).ToString();
                localeName = localeName.Replace("_", "-");

                TitleConfig titlecfg = (TitleConfig)titlesCfg[title];
                SortedList slist = titlecfg.Achievements;
                Achievemt[] alist = new Achievemt[slist.Count];

                IList keylst = slist.GetKeyList();
                foreach (uint key in keylst)
                {
                    TitleAchievement Temp = (TitleAchievement)slist[key];
                    Achievemt achmt = new Achievemt();
                    achmt.AchievementId = Temp.Id;
                    achmt.Type = (byte)Temp.Type;
                    achmt.Weight = Temp.Cred;
                    achmt.ImageId = Temp.ImageId;
                    achmt.Title = Temp.Title[localeName];
                    achmt.Description = Temp.Description[localeName];
                    achmt.ShowUnachieved = Temp.ShowUnachieved;
                    achmt.HowTo = Temp.Unachieved[localeName];
                    achmt.NextIds = Temp.NextIds;
                    achmt.ReplaceIds = Temp.ReplaceIds;
                    retval.Add(achmt.AchievementId, achmt);
                }
                return retval;
            }

            return null;
        }


        public string GetTitleName(uint title, ushort LocaleId)
        {
            string titlename = "";

            if (titlesCfg.ContainsKey(title))
            {
                // convert localeid to the string representation
                string localeName = Enum.GetName(typeof(Locales), LocaleId).ToString();
                localeName = localeName.Replace("_", "-");

                TitleConfig titlecfg = (TitleConfig)titlesCfg[title];
                if (titlecfg.Names.Contains(localeName.ToLower()))
                {
                    titlename = titlecfg.Names[localeName.ToLower()];
                }
                else if (titlecfg.Names.Contains("en-US"))
                {
                    titlename = titlecfg.Names["en-US"];
                }
            }

            return titlename;
        }

        public bool[] GetSupportedPlatforms(uint title)
        {
            if (titlesCfg.ContainsKey(title))
            {
                TitleConfig titlecfg = (TitleConfig)titlesCfg[title];
                return titlecfg.Platforms;
            }

            return null;
        }

        public uint GetTotalCread(uint title)
        {
            uint totalcread = 0;

            if (titlesCfg.ContainsKey(title))
            {
                TitleConfig titlecfg = (TitleConfig)titlesCfg[title];
                totalcread = (ushort)titlecfg.MaxCred;

            }

            return totalcread;
        }

        public ushort GetTotalAchievements(uint title)
        {
            ushort totalAchievements = 0;

            if (titlesCfg.ContainsKey(title))
            {
                TitleConfig titlecfg = (TitleConfig)titlesCfg[title];
                totalAchievements = (ushort)titlecfg.Achievements.Count;
            }

            return totalAchievements;
        }

        public ArrayList ContextSting(uint title, uint ContextId, ushort LocaleId)
        {
            ArrayList clist = new ArrayList();
            if (titlesCfg.ContainsKey(title))
            {
                // convert localeid to the string representation
                string localeName = Enum.GetName(typeof(Locales), LocaleId).ToString();
                localeName = localeName.Replace("_", "-");


                TitleConfig titlecfg = (TitleConfig)titlesCfg[title];

                if (titlecfg.Contexts.ContainsKey(ContextId))
                {
                    TitleContext tc = (TitleContext)titlecfg.Contexts[ContextId];

                    foreach (uint key in tc.Values.Keys)
                    {
                        ContextStr tmp = new ContextStr();
                        tmp.ContextId = ((TitleContextValue)tc.Values[key]).Id;
                        tmp.Name = ((TitleContextValue)tc.Values[key]).Name[localeName];
                        clist.Add(tmp);
                    }
                }

            }
            return clist;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\IUdpClient.cs ===
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;

namespace ServerTestFramework.LiveService
{

/// <summary>
/// Interface used by FDTransaction to send traffic to LIVE services.
/// </summary>
public interface IUdpClient
{
    /// <summary>
    /// Set the remote host that the client will communicate with.
    /// </summary>
    /// <param name="endpoint">The remote host that the client will communicate with.</param>
    void Connect (IPEndPoint endpoint);

    /// <summary>
    /// Sends data to the remote host.
    /// </summary>
    /// <param name="buffer">The data to send.</param>
    /// <param name="length">The length of the data to send.</param>
    /// <returns>The number of bytes sent to the remote host.</returns>
    int Send (byte[] buffer, int length);

    /// <summary>
    /// Receives a single datagram from the remote host.
    /// </summary>
    /// <param name="remote">The remote host that sent the datagram.</param>
    /// <returns>The bytes of the datagram.</returns>
    byte[] Receive (ref IPEndPoint remote);

    /// <summary>Closes the client.</summary>
    void Close ();

    /// <summary>The receive timeout of the client.</summary>
    int ReceiveTimeout { set; }

    /// <summary>The send timeout of the client.</summary>
    int SendTimeout { set; }

    /// <summary>The local IP endpoint of the client.</summary>
    IPEndPoint LocalIPEndPoint { get; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\LiveServer.cs ===
using System;
using System.Net;
using System.Text.RegularExpressions;

namespace ServerTestFramework.LiveService
{
	public class LiveServer : ICloneable
	{
		static Regex RegexIP = new Regex(@"^(\d+)\.(\d+)\.(\d+)\.(\d+)(?::(\d+))?$", RegexOptions.Compiled);

		public string Name;
		public string TextDefault;
		public string[] TextInternet;
		public string[] TextFront;
		public string[] TextBack;
		public IPEndPoint EPDefault;
		public IPEndPoint[] EPInternet;
		public IPEndPoint[] EPFront;
		public IPEndPoint[] EPBack;

		override public string ToString()
		{
			return Name;
		}

		public string	IPToString()
		{
			if (EPDefault.Port!=80)
				return EPDefault.Address.ToString()+":"+EPDefault.Port;
			return EPDefault.Address.ToString();
		}

		public LiveServer(string name, string ipDefault)
		{
			this.Name = name;

			if (ipDefault != null)
			{
				TextDefault = ipDefault;
				EPDefault = ParseIP(ipDefault);
			}
		}

		public LiveServer(string name, string ipDefault, string[] ipInternet, string[] ipFront, string[] ipBack)
		{
			this.Name = name;

			if (ipDefault != null)
			{
				TextDefault = ipDefault;
				EPDefault = ParseIP(ipDefault);
			}

			if (ipInternet != null)
			{
				TextInternet = ipInternet;
				EPInternet = new IPEndPoint[ipInternet.Length];
				for (int i = 0; i < ipInternet.Length; i++)
					EPInternet[i] = ParseIP(ipInternet[i]);
			}

			if (ipFront != null)
			{
				TextFront = ipFront;
				EPFront = new IPEndPoint[ipFront.Length];
				for (int i = 0; i < ipFront.Length; i++)
					EPFront[i] = ParseIP(ipFront[i]);
			}

			if (ipBack != null)
			{
				TextBack = ipBack;
				EPBack = new IPEndPoint[ipBack.Length];
				for (int i = 0; i < ipBack.Length; i++)
					EPBack[i] = ParseIP(ipBack[i]);
			}
		}

		// This is a code compatibility operator, with the change to xconfig
		// we have ophaned code that has not yet been updated so I have this operator
		// to convert implicitly to IPEndPoints - jacobr
		public static implicit operator IPEndPoint(LiveServer ls)
		{
			return ls.EPDefault;
		}

		protected IPEndPoint ParseIP(string s)
		{
			if (s == "")
			{
				return new IPEndPoint(0, 0);
			}
			else
			{
				Match match = RegexIP.Match(s);

				if (!match.Success)
				{
					string []sp=s.Split(':');
					string host=sp[0];
					string port="80";
					if (sp.Length>1)
						port=sp[1];

					IPAddress a=Dns.GetHostEntry(host).AddressList[0];
					return new IPEndPoint(a, Convert.ToInt32(port));
				}
				else
				{
					byte []IPv4=new byte[4];
					uint addr = 0;
					addr |= Convert.ToUInt32(match.Groups[4].Value) << 24;
					addr |= Convert.ToUInt32(match.Groups[3].Value) << 16;
					addr |= Convert.ToUInt32(match.Groups[2].Value) << 8;
					addr |= Convert.ToUInt32(match.Groups[1].Value);

					uint port = 80;
					if (match.Groups[5].Success)
						port = Convert.ToUInt32(match.Groups[5].Value);
			
					return new IPEndPoint((long) addr, (int)port);
				}
			}
		}

		public object Clone()
		{
			return new LiveServer(Name, TextDefault, TextInternet, TextFront, TextBack);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\HttpWebRequestHelper.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Reflection;
using System.Text;

using xonline.common.service;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
namespace ServerTestFramework.LiveService
{

    public static class HttpWebRequestHelper
    {
        /// <summary>
        /// Creates a HttpWebRequest instance and synchronously writes to the RequestStream
        /// </summary>
        /// <param name="scheme">Scheme (http, https)</param>
        /// <param name="host">HostName</param>
        /// <param name="port">Port NUmber</param>
        /// <param name="path">Uri Path</param>
        /// <param name="queryString">Uri QueryString</param>
        /// <param name="contentType">ContentType header value</param>
        /// <param name="content">Content</param>
        /// <param name="method">Http Method</param>
        /// <param name="headers">Additional Headers to add</param>
        /// <returns>HttpWebRequest instance</returns>
        public static HttpWebRequest Prepare(string scheme, string host, int port, string path,string queryString, string contentType, byte[] content, string method, Dictionary<string, string> headers)
        {
            UriBuilder uriBuilder = new UriBuilder(scheme, host, port, path);
            if (String.IsNullOrEmpty(queryString) == false)
            {
                uriBuilder.Query = queryString;
            }
            return Prepare(uriBuilder.Uri, contentType, content, method, headers);
        }
        /// <summary>
        /// Creates a HttpWebRequest instance and synchronously writes to the RequestStream
        /// </summary>
        /// <param name="uri">Requst Uri</param>
        /// <param name="contentType">ContentType header value</param>
        /// <param name="content">Content</param>
        /// <param name="method">Http Method</param>
        /// <param name="headers">Additional Headers to add</param>
        /// <returns>HttpWebRequest instance</returns>
        public static HttpWebRequest Prepare(Uri uri, string contentType, byte[] content, string method, Dictionary<string, string> headers)
        {
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(uri);
            request.Method = method;

            if (headers != null)
            {
                foreach (var key in headers.Keys)
                {
                    request.Headers.Add(key, headers[key]);
                }
            }

            if (content != null && content.Length > 0)
            {
                request.ContentType = contentType;
                request.ContentLength = content.Length;
                using (var requestStream = request.GetRequestStream())
                {
                    requestStream.Write(content, 0, content.Length);
                }
            }

            return request;
        }
        /// <summary>
        /// Execute a HttpRequest and return a response
        /// </summary>
        /// <param name="request">WebRequest</param>
        /// <returns>Response</returns>
        public static HttpWebResponse Execute(HttpWebRequest request)
        {
            var callback = ServicePointManager.ServerCertificateValidationCallback;
            ServicePointManager.ServerCertificateValidationCallback = new RemoteCertificateValidationCallback(CertValidator);
            HttpWebResponse response = null;
            try
            {
                response = (HttpWebResponse)request.GetResponse();
            }
            catch (WebException webEx)
            {
                response = (HttpWebResponse)webEx.Response;
            }
            ServicePointManager.ServerCertificateValidationCallback = callback;
            return response;
        }
        /// <summary>
        /// Creates a HttpWebRequest instance and synchronously writes to the RequestStream, synchrously executes.  Caller is responsible for closing Response
        /// </summary>
        /// <param name="scheme">Scheme (http, https)</param>
        /// <param name="host">HostName</param>
        /// <param name="port">Port NUmber</param>
        /// <param name="path">Uri Path</param>
        /// <param name="queryString">Uri QueryString</param>
        /// <param name="contentType">ContentType header value</param>
        /// <param name="content">Content</param>
        /// <param name="method">Http Method</param>
        /// <param name="headers">Additional Headers to add</param>
        /// <returns>HttpWebResponse instance</returns>
        public static HttpWebResponse PrepareAndExecute(string scheme, string host, int port, string path, string queryString, string contentType, byte[] content, string method, Dictionary<string, string> headers)
        {
            var request = Prepare(scheme, host, port, path, queryString ,contentType, content, method, headers);
            return Execute(request);
        }
        private static bool CertValidator(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\STFLiveGlobals.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Net;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;  // for StfXmlDoc
using Microsoft.Win32;
using xonline.common.config;
using xonline.common.sql.webstore;

namespace ServerTestFramework
{
    /// <summary>
    /// Provides various statics for the entire framework.
    /// </summary>
    public class STFLiveGlobal: InfiniteLifetimeMarshalByRefObject
    {
        static STFLiveGlobal()
        {
            Global.ForceConstruct(); //make sure STFLiveConfig which we depend on gets initialized first
            CoreGlobal.RegisterInitializationCallback(STFLiveInitialize);
            CoreGlobal.RegisterUninitializationCallback(STFLiveUninitialize);
        }

        //this exists only to force the static constructor to run
        public static void ForceConstruct()
        {
        }

        private static Dictionary<string, BulkUserSet> bulkUserSets=new Dictionary<string, BulkUserSet>();

        //
        public static StfXmlDoc Config
        {
            get { return CoreGlobal.Config; }
        }

        // Internal initialize after we have a valid xml document (Global.Config)
        private static void STFLiveInitialize()
        {
            //convert BulkUserSetBase to BulkUserSet that we store
            foreach (string key in Global.UserSetHash.Keys)
            {
                bulkUserSets[key]=new BulkUserSet((BulkUserSetBase)Global.UserSetHash[key]);
            }
        }

        private static void STFLiveUninitialize()
        {
            bulkUserSets.Clear();

            if (!ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.IsFakeSGNull())
            {
                ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.Shutdown();
                ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG = null;
            }
        }

        /// <summary>
        /// Returns the BulkUserSet, if specified in the XML file. Grabs either the
        /// userset with tag "" or the first user set, if "" is not found.
        /// </summary>
        /// <returns></returns>
        static public BulkUserSet GetUserSet()
        {
            // Return the first entry in the hash, regardless of the tag
            if (bulkUserSets == null || bulkUserSets.Count <= 0)
                throw new StfException("No BulkUserSet configured, please add a valid <bulkusers> tag to stf.xml");

            // First check for the tagless case
            if (bulkUserSets.ContainsKey(""))
                return bulkUserSets[""];

            // Otherwise let's pick something. This is the only way I know of to get a 
            // value, any value.  Which value you get depends on the hashtable layout, 
            // but at least you'll get something.
            foreach (string k in bulkUserSets.Keys)
            {
                return bulkUserSets[k];
            }

            // Nothing found. This is bad, should have been caught above.
            throw new StfException("GetUserSet: no value found in collection, this shouldn't have made it here");
        }

        /// <summary>
        /// Returns the BulkUserSet, if specified in the XML file, for the given tag. This is
        /// user-settable, in the XML file, and allows for distinct user sets. You may want
        /// to create some Xenon and Xbox users, or partition them manually, etc.
        /// </summary>
        /// <param name="tag"></param>
        /// <returns></returns>
        static public BulkUserSet GetUserSet(string tag)
        {
            string key = tag.ToLower();
            if (bulkUserSets == null)
                throw new StfException("No BulkUserSet configured, please add a <bulkusers> tag to stf.xml");
            if (!bulkUserSets.ContainsKey(key))
                throw new StfException("No BulkUserSet exists in the hash with the tag \"{0}\"", key);
            return bulkUserSets[key];
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Achievement\AvatarAssetBase.cs ===
using System;
using System.IO;
using System.Threading;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.UserSettings;

namespace ServerTestFramework.LiveService.AvatarAsset
{
    public class AvatarAssetBase : PCBase
    {
        public uint _Title = 0;
        public ulong UWoner = 0;
        public ushort locale = 1033;

        public AvatarAssetBase()
        {
        }

        public AvatarAssetBase(uint title)
            : base(title)
        {
            _Title = title;
        }

        public AvatarAssetBase(uint title, ulong user)
            : base(title)
        {
            _Title = title;
            UWoner = user;
        }

        public void ClearAvatarAsset(ulong user)
        {
            // Delete all the Assets, Settings and Titles already
            // created for this user to start clean
            ProgressWS.ResetUserAvatarAssets(user);
            ProfileWS.ResetUserSetttings(user);
            ProgressWS.ResetUsertitles(user);
        }

        public int BuildAvatarAssetWDFlagForPlatform(uint flag, byte clientType)
        {
            return (int)(flag | (((uint)clientType << avatarassetflags.XAVATAR_DETAILS_PLATFORM_SHIFT) & avatarassetflags.XAVATAR_DETAILS_PLATFORM_MASK));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Achievement\XRLClearAchievement.cs.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using ServerTestFramework;
using System.Net;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Achievement
{
	/// <summary>
	/// Summary description for XRLClearAchievement.
	/// </summary>
	public class XRLClearAchievement :XRLPayload
	{
		[XRLPayloadFld(IsTitleId=true)]
		public uint  TitleId = 0;
		[XRLPayloadFld(IsUPuid=true)]
		public ulong Puid    = 0;

		protected override string GetServiceName()
		{
			return "/xstats/xachievementclear.ashx";
		}
	}

	public class InvalidXRLRequest : XRLPayload
	{
		int _bytestosend=0;
		string _url=null;

		public InvalidXRLRequest(int bytestosend,string url)
		{
			_bytestosend=bytestosend;
			_url=url;
		}
		
		protected override string GetServiceName()
		{
			return _url;
		}
		
		

		new public uint Execute()
		{
			// Prepare request 
			MemoryStream reqStream = new MemoryStream( 512 );
			byte[] buffer = new byte[_bytestosend];
			Random rand = new Random();
			rand.NextBytes(buffer);
			BinaryWriter writer = new  BinaryWriter(reqStream);
			writer.Write(buffer);
				
			bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xstatsfd),reqStream);
			return this.XErr;
		}


	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XblUser.cs ===
using System;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.LiveService
{
    using ServerTestFramework.LiveService.UserAccount;
    /// <summary>
    /// XblUserBase is intended to be used for stress purpose only.  Do not create XblUserBase object in your tools.
    /// </summary>
    public class XblUserBase
    {
        internal ulong _puid;
        public ulong Puid
        {
            get
            {
                return _puid;
            }
            set
            {
                this._puid = value;
            }
        }

        public XblUserBase(ulong puid)
        {
            this._puid = puid;
        }

        public XblUserBase()
        {
            this._puid = 0L;
        }

        /// <remarks>
        /// Other type castors should be handled by functional library.  For example, explicit cast to BillingInfo should be handled by UACSCommon.
        /// </remarks>
        public static implicit operator ulong(XblUserBase user)
        {
            return user._puid;
        }
    }

    /// <summary>
    /// XblUser represents user information for server test framework.
    /// Coders should make sure that following guideline is observed:
    /// 1. for libary code that intended to use by other components and thus require absolute performance, you can use _variable to access different fields directly
    /// 2. for utility code, please use provided accessor
    /// 3. utility coder should assume that each field can contain erronous data, including null.  This is to provide test cases writers to test negative (error condition).
    /// please refer to wiki page for more information.
    /// </summary>
    public sealed class XblUser : XblUserBase
    {
        /// <remarks>
        /// _gamertag, _billingInfo and _passportInfo are listed as internal to allow direct access for libraby code that requires absolute performance
        /// please remember that direct access of those members requires more responsibility in the area of house keeping.
        /// we do not add "protected" level of access to those members since XblUser is sealed.  If you make XblUser inheritable, you should consider to make those members
        /// protected internal.
        /// </remarks>
        internal string _gamertag = null;

        internal BillingInfo _billingInfo = null;
        internal PassportInfo _parentPassportInfo = null;
        internal PassportInfo _userPassportInfo = null;
        internal XblUserSettings _userSetting = null;

        /// <remarks>
        /// The following constructor are internal only.  They are intended for library code who need direct access to member variables.  Remember that using these
        /// two constructor may break utility code assumption that puid and gamertag is always there.
        /// </remarks>
        internal XblUser()
        {
        }
/*
        internal XblUser(ulong puid) : base (puid)
        {			
        }
*/
        /// <remarks>
        /// The following constructors are for public consumption.  If you add a new data member for this class, please don't forget to update the constructors.
        /// </remarks>
        internal XblUser(ulong puid, string gamertag) : base (puid)
        {
            this._gamertag = gamertag;
        }

        internal XblUser(ulong puid, string gamertag, BillingInfo billingInfo, PassportInfo userPassportInfo) : base (puid)
        {
            this._gamertag = gamertag;
            this._billingInfo = billingInfo;
            this._userPassportInfo = userPassportInfo;
        }

        internal XblUser(ulong puid, string gamertag, BillingInfo billingInfo, PassportInfo userPassportInfo, PassportInfo parentPassportInfo) : base (puid)
        {
            this._gamertag = gamertag;
            this._billingInfo = billingInfo;
            this._userPassportInfo = userPassportInfo;
            this._parentPassportInfo = parentPassportInfo;
        }

        public string Gamertag
        {
            get
            {
                return this._gamertag;
            }
            set
            {
                this._gamertag = value;
            }
        }

        public override string ToString()
        {
            string userInfoString = "<" + ((this._gamertag == null)? @"No gamertag" : this._gamertag) + ">(0x" + this._puid.ToString("X") + ")";
            return userInfoString;
        }

        public string ToString(bool fullInfo)
        {
            string userInfoString = this.ToString() + Environment.NewLine;
            if (fullInfo)
            {
                userInfoString += ((this._billingInfo != null) ? this._billingInfo.ToString() : "No billing info") + Environment.NewLine;
                userInfoString += ((this._userPassportInfo != null) ? this._userPassportInfo.ToString() : "No user passport info") + Environment.NewLine;
                userInfoString += ((this._parentPassportInfo != null) ? this._parentPassportInfo.ToString() : "No parent passport info") + Environment.NewLine;
            }
            return userInfoString;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Achievement\AchievementBase.cs ===
using System;
using System.IO;
using System.Threading;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Achievement
{

    public class UserAchProfile
    {
        public ulong userid;
        public uint title;
        public ArrayList AchievementsEarned = new ArrayList();
        public int LastSyncIdx = 0;
        public int LastIntSyncIdx = 0;
        public uint SortIndex = 0;  //aka the Sequence number.  Monotonically increasing, each time
                                    //an achievement is added.
        public ulong machinePuid = 0; //if zero, then do nothing.  Otherwise populate the
                                      //machinePuid slot in the request with this number.

        public UserAchProfile(ulong uid, uint _title)
        {
            userid = uid;
            title = _title;
        }

        public AchievementWD AddAchievement(uint Achid, bool earnedonline)
        {
            //Generate a new achievement
            AchievementWD AchToV = new AchievementWD(Achid, ++SortIndex, 0);
            AchievementWD tmp = null;

            if (earnedonline)
            {
                AchToV.Achieved = DateTime.UtcNow;
                AchToV.Flags = (int)(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE | achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED);
            }
            else
            {
                DateTime minval = new DateTime(1753, 1, 1);
                AchToV.Achieved = minval;
                //                AchToV.Achieved = DateTime.UtcNow;  //we should change this;  the client now sends
                //                the client time, but always expects to receive mindate.
                AchToV.Flags = (int)(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED);
            }

            AchToV.Flags = achievementflags.SetPlatformTypeInFlags(AchToV.Flags, XOn.XPLT_XBOX360);

            foreach (AchievementWD uA in AchievementsEarned)
            {
                if (AchToV.AchievementId == uA.AchievementId)
                {
                    tmp = uA;
                    break;
                }
            }

            if (tmp != null)
            {
                AchievementsEarned.Remove(tmp);
                if (LastSyncIdx != 0)
                    LastSyncIdx--;
                if (LastIntSyncIdx != 0)
                    LastIntSyncIdx--;
            }

            if (tmp != null && tmp.Achieved.CompareTo(AchToV.Achieved) > 0)
            {
                tmp.Flags = tmp.Flags | AchToV.Flags;
                AchievementsEarned.Add(tmp);
            }
            else
            {
                tmp = AchToV;
                AchievementsEarned.Add(AchToV);
            }

            return tmp;
        }

        public UserAchProfile Copy()
        {
            UserAchProfile tmp = new UserAchProfile(userid, title);

            for (int i = 0; i < AchievementsEarned.Count; i++)
            {

                tmp.AchievementsEarned.Add((AchievementWD)AchievementsEarned[i]);
            }
            tmp.LastSyncIdx = LastSyncIdx;
            tmp.LastIntSyncIdx = LastIntSyncIdx;

            return tmp;
        }
    }


	/// <summary>
	/// Summary description for AchievementBase.
	/// </summary>
    public class AchivementBase : PCBase
    {
        public uint _Title = 0;
        public ulong UWoner = 0;
        public GamerScore UWonerScore = new GamerScore();
        public ushort locale = 1033;
        public static GameConfig gconfig = new GameConfig();
        Hashtable AchievementsToVerify = new Hashtable();

        public AchivementBase()
        {
        }

        public AchivementBase(uint title)
            : base(title)
        {
            _Title = title;
        }

        public AchivementBase(uint title, ulong user)
            : base(title)
        {
            _Title = title;
            UWoner = user;
        }

        public void ClearAchivement(ulong user)
        {
            ProgressWS.ResetUserAchievements(user);
            ProfileWS.ResetUserSetttings(user);
            ProgressWS.ResetUsertitles(user);
        }

        public void ClearExpectedAchievements()
        {
            AchievementsToVerify = new Hashtable(); //clear out what we expect as well.
        }

        public DateTime LoadAchievement(int count, DateTime version)
        {
            return LoadAchievement(count, version, 0);
        }

        public DateTime LoadAchievement(int count, DateTime version, uint SqNum)
        {
            DateTime retval = version;
            int newCount = 0;
            int iteration = 0;
            if (count < AchievConst.MAX_Achievement)
            {
                newCount = count;
                iteration = 1;
            }
            else
            {
                iteration = (count / AchievConst.MAX_Achievement) + 1;
            }

            for (int idx = 0; idx < iteration; idx++)
            {
                if (iteration > 1)
                {
                    if (idx < (iteration - 1))
                        newCount = AchievConst.MAX_Achievement;
                    else
                        newCount = count - (AchievConst.MAX_Achievement * idx);
                }

                Hashtable titleAchievements = gconfig.GetAchivement(_Title, locale, false);
                AchievementWD[] lalist = new AchievementWD[newCount];
                for (int i = 0; i < lalist.Length; i++)
                {
                    uint id = (uint)((AchievConst.MAX_Achievement * idx) + i + 1);

                    Achievemt titleAchievement = (Achievemt)titleAchievements[id];

                    if (SqNum == 0)
                        lalist[i] = new AchievementWD(id, id);
                    else
                        lalist[i] = new AchievementWD(id, (uint)SqNum);

                    if (titleAchievement.ShowUnachieved)
                    {
                        lalist[i].Flags |= (int)achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED;
                    }

                    AddAchievementsToVerify(UWoner, _Title, lalist[i]);
                }

                XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, lalist, retval);
                SyncAchievementsResponse resp = req.Execute();
                if (SqNum == 0)
                    verify(resp, null, (AchievConst.MAX_Achievement * idx), newCount, true);
                else
                    verifySingleWrite(resp, null, (AchievConst.MAX_Achievement * idx), newCount);
                retval = resp.Version;
            }

            return retval;
        }

        public DateTime LoadAchievementByIndex(int startIndex, int count, DateTime version)
        {
            uint[] indices = new uint[count];
            for (int i = 0; i < count; ++i)
            {
                uint id = (uint)(startIndex + i + 1);
                indices[i] = id;
            }

            return LoadAchievementsByIds(indices, version);
        }

        public DateTime LoadAchievementsByIds(uint[] ids, DateTime version)
        {
            AchievementWD[] achievements = new AchievementWD[ids.Length];
            for (int i = 0; i < achievements.Length; ++i)
            {
                achievements[i] = new AchievementWD(ids[i], ids[i]);

                AddAchievementsToVerify(UWoner, _Title, achievements[i]);
            }

            XRLSyncAchievements req = new XRLSyncAchievements(_Title, UWoner, achievements, version);
            SyncAchievementsResponse resp = req.Execute();

            verify(resp, null, 0, achievements.Length, true);

            return resp.Version;
        }

        public SyncAchievementsResponse AchievementsEarned(UserAchProfile user, uint AchievementId, bool earnedonline, DateTime version)
        {
            return AchievementsEarned(user, AchievementId, earnedonline, version, true);

        }
        public SyncAchievementsResponse AchievementsEarned(UserAchProfile user, uint AchievementId, bool earnedonline, DateTime version, bool SyncToServer)
        {
            SyncAchievementsResponse resp = null;
            TitleKey key = new TitleKey(user.userid, user.title);

            if (AchievementId > 0)
            {
                user.AddAchievement(AchievementId, earnedonline);

            }

            if (earnedonline && SyncToServer)
            {

                ArrayList Alist = new ArrayList();
                if (AchievementsToVerify.ContainsKey(key))
                    Alist = (ArrayList)AchievementsToVerify[key];
                else
                    AchievementsToVerify.Add(key, Alist);

                int icount = user.AchievementsEarned.Count - user.LastIntSyncIdx;
                for (int i = 0; i < icount; i++)
                {
                    AchievementWD tmp = (AchievementWD)user.AchievementsEarned[user.LastIntSyncIdx + i];
                    if (!Alist.Contains(tmp))
                        Alist.Add(tmp);
                }
                user.LastIntSyncIdx = user.AchievementsEarned.Count;

                if (SyncToServer)
                {
                    int count = user.AchievementsEarned.Count - user.LastSyncIdx;
                    AchievementWD[] achs = new AchievementWD[count];
                    for (int i = 0; i < count; i++)
                    {
                        achs[i] = (AchievementWD)user.AchievementsEarned[user.LastSyncIdx + i];
                        if (!Alist.Contains(achs[i]))
                            Alist.Add(achs[i]);
                    }

                    XRLSyncAchievements req = new XRLSyncAchievements(user.title, user.userid, achs, version);
                    if (user.machinePuid != 0)
                    {
                        req.ManualPopulateSlot();
                        req.Slot.machinePuid = user.machinePuid;
                    }

                    resp = req.Execute();
                    user.LastSyncIdx = user.AchievementsEarned.Count;
                }
            }

            return resp;
        }

        public void EarnedLAchievement(UserAchProfile user, uint AchievementId)
        {
            AchievementWD tmp = null;
            TitleKey key = new TitleKey(user.userid, user.title);

            if (AchievementId > 0)
            {
                tmp = user.AddAchievement(AchievementId, true);

            }
            ProgressWS.AddLegacyAchievementRow(user.userid, (int)user.title, (int)tmp.AchievementId, (int)tmp.SortIndex, tmp.Achieved);

            ArrayList Alist = new ArrayList();
            if (AchievementsToVerify.ContainsKey(key))
                Alist = (ArrayList)AchievementsToVerify[key];
            else
                AchievementsToVerify.Add(key, Alist);

            if (!Alist.Contains(tmp))
                Alist.Add(tmp);

        }

        public void AddAchievementsToVerify(ulong user, uint title, AchievementWD ach)
        {
            TitleKey key = new TitleKey(user, title);

            if (AchievementsToVerify.ContainsKey(key))
            {
                ArrayList Alist = (ArrayList)AchievementsToVerify[key];
                if (!Alist.Contains(ach))
                    Alist.Add(ach);
                else
                {
                    Alist.Remove(ach);
                    Alist.Add(ach);
                }
            }
            else
            {
                ArrayList Alist = new ArrayList();
                Alist.Add(ach);
                AchievementsToVerify.Add(key, Alist);
            }
        }

        public void verify(SyncAchievementsResponse resp, uint[] ExpectedAchievIDs, int stidx, int count)
        {
            verify(resp, ExpectedAchievIDs, stidx, count, false);
        }

        public void verify(SyncAchievementsResponse resp, uint[] ExpectedAchievIDs, int stidx, int count, bool ignoreSyncresp)
        {
            verifySync(UWoner, _Title, resp, ExpectedAchievIDs, ignoreSyncresp);

            // enumerate and make sure that the request has correct values.

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stidx, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stidx, count, UWonerScore);
            // add code to make sure the  gamer profile is updated.
        }

        public void verifyGamerScore()
        {
            // title =  _Title, user = UWoner, gamerscore = UWonerScore

            //--read settings and enum title and verify.
            uint[] settings = new uint[4];
            settings[0] = ProfileDefs.GAMER_CRED;
            settings[1] = ProfileDefs.ACHIEVEMENTS_EARNED;
            settings[2] = ProfileDefs.TITLE_CRED_EARNED;
            settings[3] = ProfileDefs.TITLE_ACHIEVEMENTS_EARNED;

            ReadSettingsRequest req = new ReadSettingsRequest(_Title, UWoner, new ulong[] { UWoner }, settings);
            ReadSettingsResponse resp = req.Execute();
            TitleScore tscore = UWonerScore.GetGameScore(_Title);
            foreach (UserSetting us in resp.Settings)
            {
                if (us.Value.Length == 0)
                    continue;
                BinaryReader red = new System.IO.BinaryReader(new MemoryStream(us.Value));
                int Respvalue = red.ReadInt32();

                if (us.SettingId == ProfileDefs.GAMER_CRED)
                {
                    if (Respvalue != UWonerScore.total)
                        throw new Exception("Expected GAMER_CRED: " + UWonerScore.total + " but Received: " + Respvalue);
                }
                else if (us.SettingId == ProfileDefs.ACHIEVEMENTS_EARNED)
                {
                    if (Respvalue != UWonerScore.totalAchievements)
                        throw new Exception("Expected ACHIEVEMENTS_EARNED: " + UWonerScore.totalAchievements + " but Received: " + Respvalue);
                }
                else if (us.SettingId == ProfileDefs.TITLE_CRED_EARNED)
                {
                    if (Respvalue != tscore.score)
                        throw new Exception("Expected TITLE_CRED_EARNED: " + tscore.score + " but Received: " + Respvalue);

                }
                else if (us.SettingId == ProfileDefs.TITLE_ACHIEVEMENTS_EARNED)
                {
                    if (Respvalue != tscore.NoOfAchievements)
                        throw new Exception("Expected TITLE_ACHIEVEMENTS_EARNED: " + tscore.NoOfAchievements + " but Received: " + Respvalue);
                }
            }

            // enum title and verify the  values are consistant.
            EnumTitlesRequest etreq = new EnumTitlesRequest(UWoner, UWoner, 0, 32);
            EnumTitlesResponse etresp = etreq.Execute();

            if (etresp.XError != 0)
                throw new Exception("EnumTitlesRequest failed with hr " + etresp.XError);

            for (int i = 0; i < etresp.Titles.Length; i++)
            {
                UserTitle utitle = (UserTitle)etresp.Titles[i];

                TitleScore tscore1 = UWonerScore.GetGameScore(utitle.TitleId);
                if (tscore1 == null)
                    throw new Exception("unexpected Title " + utitle.TitleId);

                if (tscore1.score != utitle.NumCreds)
                    throw new Exception("Expected TITLE_CRED_EARNED: " + tscore1.score + " but Received: " + utitle.TotalCred);
                else if (tscore1.NoOfAchievements != utitle.NumAchievements)
                    throw new Exception("Expected TITLE_ACHIEVEMENTS_EARNED: " + tscore1.NoOfAchievements + " but Received: " + utitle.TotalAchievements);
            }
        }

        public void verify(SyncAchievementsResponse resp, uint[] ExpectedAchievIDs, int stidx, int count, GamerScore score)
        {
            verifySync(UWoner, _Title, resp, ExpectedAchievIDs);

            // enumerate and make sure that the request has correct values.

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stidx, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp, stidx, count, score);
            // add code to make sure the  gamer profile is updated.
        }

        public void verifySingleWrite(SyncAchievementsResponse resp, uint[] ExpectedAchievIDs, int stidx, int count)
        {
            verifySync(UWoner, _Title, resp, ExpectedAchievIDs);

            // enumerate and make sure that the request has correct values.

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, (ushort)stidx, (ushort)count);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnumSingleUpdate(UWoner, _Title, locale, false, enumresp, stidx, count);
        }

        public void verifySingleWrite(SyncAchievementsResponse resp, uint[] ExpectedAchievIDs)
        {
            verifySync(UWoner, _Title, resp, ExpectedAchievIDs);

            // enumerate and make sure that the request has correct values.

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, 0, AchievConst.MAX_Achievement);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnumSingleUpdate(UWoner, _Title, locale, false, enumresp, 0, -1);
        }

        public void verify(SyncAchievementsResponse resp, uint[] ExpectedAchievIDs)
        {
            verifySync(UWoner, _Title, resp, ExpectedAchievIDs);

            // enumerate and make sure that the request has correct values.

            XRLEnumAchievement req = new XRLEnumAchievement(_Title, UWoner, UWoner, locale, 0, AchievConst.MAX_Achievement);
            AchievementEnumResponse enumresp = req.Execute();
            verifyEnum(UWoner, _Title, locale, false, enumresp);
        }

        public void verifySync(ulong user, uint title, SyncAchievementsResponse resp, uint[] ExpectedAchievIds)
        {
            verifySync(user, title, resp, ExpectedAchievIds, true);
        }

        public void verifySync(ulong user, uint title, SyncAchievementsResponse resp, uint[] ExpectedAchievIds, bool verifySync)
        {
            if (resp.xResult != HResult.S_OK)
                throw new Exception("Unexpected XError returned by server:  " + resp.xResult);

            TitleKey key = new TitleKey(user, title);

            if (verifySync && ExpectedAchievIds == null && resp.AchievementsCount > 0)
                throw new Exception("SyncAchievement returned " + resp.AchievementsCount + " records but the client was expecting 0");
            if (AchievementsToVerify.ContainsKey(key) && ExpectedAchievIds != null && ExpectedAchievIds.Length > 0)
            {
                ArrayList Alist = (ArrayList)AchievementsToVerify[key];

                if (ExpectedAchievIds.Length != resp.AchievementsCount)
                    throw new Exception("Achievement count does not match. Expected: " + ExpectedAchievIds.Length + " Received: " + resp.AchievementsCount);

                for (int respidx = 0; respidx < resp.AchievementsCount; respidx++)
                {
                    bool achfound = false;
                    int Alistidx = 0;
                    for (; Alistidx < Alist.Count; Alistidx++)
                    {
                        if (((AchievementWD)Alist[Alistidx]).AchievementId == resp.Achievements[respidx].AchievementId)
                        {
                            achfound = true;
                            break;
                        }
                    }

                    if (achfound)
                    {
                        AchievementWD client = (AchievementWD)Alist[Alistidx];
                        AchievementWD server = resp.Achievements[respidx];
                        bool foundid = false;
                        int i = 0;
                        for (; i < ExpectedAchievIds.Length; i++)
                        {
                            if (ExpectedAchievIds[i] == server.AchievementId)
                            {
                                foundid = true;
                                break;
                            }
                        }
                        if (!foundid)
                            throw new Exception("Unexpected AchiviementID. Expected: " + ExpectedAchievIds[i] + " Received: " + server.AchievementId);

                        if (client.Achieved.ToString() != server.Achieved.ToString())
                            throw new Exception("Invalid Achieved Date. Expected: " + client.Achieved + " Received: " + server.Achieved);
                        if (client.Flags != server.Flags)
                            throw new Exception("Invalid Flags. Expected: " + client.Flags + " Received: " + server.Flags);

                        Hashtable schema = gconfig.GetAchivement(title, locale, false);
                        Achievemt tmp = (Achievemt)schema[client.AchievementId];

                        if (server.Type != 1)
                            throw new Exception("Invalid Type. Expected: " + tmp.Type + " Received: " + server.Type);
                        if (tmp.Weight != server.Cred)
                            throw new Exception("Invalid Cred. Expected: " + tmp.Weight + " Received: " + server.Cred);
                        if (tmp.ImageId != server.ImageId)
                            throw new Exception("Invalid ImagePath. Expected: " + tmp.ImageId + " Received: " + server.ImageId);
                        if (tmp.Title != server.Title)
                            throw new Exception("Invalid Title. Expected: " + tmp.Title + " Received: " + server.Title);
                        if (tmp.Description != server.Description)
                            throw new Exception("Invalid Description. Expected: " + tmp.Description + " Received: " + server.Description);
                        if (tmp.NextIds.Length != server.NextIdsLen)
                            throw new Exception("Invalid NextIdsLen. Expected: " + tmp.NextIds.Length + " Received: " + server.NextIdsLen);
                        for (int j = 0; j < tmp.NextIds.Length; j++)
                        {
                            if (tmp.NextIds[j] != server.NextIds[j])
                                throw new Exception("Invalid NextIds. Expected: " + tmp.NextIds + " Received: " + server.NextIds + " at index " + j);
                        }
                        if (tmp.ReplaceIds.Length != server.ReplaceIdsLen)
                            throw new Exception("Invalid ReplaceIdsLen. Expected: " + tmp.ReplaceIds.Length + " Received: " + server.ReplaceIdsLen);

                        for (int j = 0; j < tmp.ReplaceIds.Length; j++)
                        {
                            if (tmp.ReplaceIds[j] != server.ReplaceIds[j])
                                throw new Exception("Invalid ReplaceIds. Expected: " + tmp.ReplaceIds + " Received: " + server.ReplaceIds + " at index " + j);
                        }
                    }
                    else
                        throw new Exception("Invalid Achievement ID " + resp.Achievements[respidx].AchievementId);
                }
            }
            else
            {
                if (ExpectedAchievIds != null && ExpectedAchievIds.Length > 0)
                    throw new Exception("Achievement for title " + title + " and user " + user + " not found.");
            }
        }

        public void verifyEnum(ulong user, uint title, ushort locale, bool isweb, AchievementEnumResponse resp)
        {

            verifyEnum(user, title, locale, isweb, resp, 0, -1, UWonerScore);
        }

        public void verifyEnum(ulong user, uint title, ushort locale, bool isweb, AchievementEnumResponse resp, int startidx, int count, GamerScore score)
        {
            AchievementWD[] results = buildEnumResult(user, title, locale, isweb, score);

            if (results == null)
            {
                if (resp.AchievementsLen == 0)
                    return;
                else
                    throw new Exception("(Fall bug # 53567)Achievement count does not match. Expected: 0 Received: " + resp.AchievementsLen);
            }

            if (count == -1 && startidx == 0)
            {
                if (results.Length <= AchievConst.MAX_Achievement)
                    count = results.Length;
                else
                    count = AchievConst.MAX_Achievement;
            }

            int resultsidx = startidx;

            if (count != resp.AchievementsLen)
                throw new Exception("Achievement count  does not match Expected :" + count + " server returned" + resp.AchievementsLen);

            if ((resultsidx + count) > results.Length)
                throw new Exception("Invalid Achievement list");

            for (int respidx = 0; (respidx < resp.AchievementsLen && resultsidx < results.Length); respidx++, resultsidx++)
            {
                AchievementWD server = resp.Achievements[respidx];
                AchievementWD client = results[resultsidx];

                if (client.AchievementId != server.AchievementId)
                    throw new Exception("Invalid AchievedID, or ID out of order. Expected: " + client.AchievementId + " Received: " + server.AchievementId);
                if (client.Achieved.ToString() != server.Achieved.ToString())
                    throw new Exception("Invalid Achieved Date. Expected: " + client.Achieved + " Received: " + server.Achieved);
                // Check the flags leaving out the platforms
                if ((client.Flags & ~achievementflags.XACHIEVEMENT_DETAILS_PLATFORM_MASK) != (server.Flags & ~achievementflags.XACHIEVEMENT_DETAILS_PLATFORM_MASK))
                    throw new Exception("Invalid Flags. Expected: " + client.Flags + " Received: " + server.Flags);
                if (server.Type != 1)
                    throw new Exception("Invalid Type. Expected: 1 Received: " + server.Type);
                if (client.Cred != server.Cred)
                    throw new Exception("Invalid Cred. Expected: " + client.Cred + " Received: " + server.Cred);
                if (client.ImageId != server.ImageId)
                    throw new Exception("Invalid ImagePath. Expected: " + client.ImageId + " Received: " + server.ImageId);
                if (client.Title != server.Title)
                    throw new Exception("Invalid Title. Expected: " + client.Title + " Received: " + server.Title);
                if (client.Description != server.Description)
                    throw new Exception("Invalid Description. Expected: " + client.Description + " Received: " + server.Description);
                if (client.NextIds.Length != server.NextIdsLen)
                    throw new Exception("Invalid NextIdsLen. Expected: " + client.NextIds.Length + " Received: " + server.NextIds);
                for (int j = 0; j < client.NextIds.Length; j++)
                {
                    if (client.NextIds[j] != server.NextIds[j])
                        throw new Exception("Invalid NextIds. Expected: " + client.NextIds[j] + " Received: " + server.NextIds[j] + " at index " + j);
                }
                if (client.ReplaceIds.Length != server.ReplaceIdsLen)
                    throw new Exception("Invalid ReplaceIdsLen. Expected: " + client.ReplaceIds.Length + " Received: " + server.ReplaceIdsLen);

                for (int j = 0; j < client.ReplaceIdsLen; j++)
                {
                    if (client.ReplaceIds[j] != server.ReplaceIds[j])
                        throw new Exception("Invalid ReplaceIds. Expected: " + client.ReplaceIds[j] + " Received: " + server.ReplaceIds[j] + " at index " + j);
                }
            }

            verifyGamerScore();
        }

        public void verifyEnumSingleUpdate(ulong user, uint title, ushort locale, bool isweb, AchievementEnumResponse resp, int startidx, int count)
        {
            Hashtable results = GetEnumHashTb(user, title, locale, isweb);
            if (count == -1 && startidx == 0)
            {
                if (results.Count <= AchievConst.MAX_Achievement)
                    count = results.Count;
                else
                    count = AchievConst.MAX_Achievement;
            }

            int resultsidx = startidx;

            if (count != resp.AchievementsLen)
                throw new Exception("Achievement count does not match. Expected: " + count + " Received: " + resp.AchievementsLen);

            if ((resultsidx + count) > results.Count)
                throw new Exception("Invalid Achievement list");

            for (int respidx = 0; (respidx < resp.AchievementsLen && resultsidx < results.Count); respidx++, resultsidx++)
            {
                AchievementWD server = resp.Achievements[respidx];
                AchievementWD client = (AchievementWD)results[server.AchievementId];

                if (client.AchievementId != server.AchievementId)
                    throw new Exception("Invalid AchievedID. Expected: " + client.AchievementId + " Received: " + server.AchievementId);
                if (client.Achieved.ToString() != server.Achieved.ToString())
                    throw new Exception("Invalid Achieved Date. Expected: " + client.Achieved + " Received: " + server.Achieved);
                if (client.Flags != server.Flags)
                    throw new Exception("Invalid Flags. Expected: " + client.Flags + " Received: " + server.Flags);
                if (server.Type != 1)
                    throw new Exception("Invalid Type. Expected: 1 Received: " + server.Type);
                if (client.Cred != server.Cred)
                    throw new Exception("Invalid Cred. Expected: " + client.Cred + " Received: " + server.Cred);
                if (client.ImageId != server.ImageId)
                    throw new Exception("Invalid ImagePath. Expected: " + client.ImageId + " Received: " + server.ImageId);
                if (client.Title != server.Title)
                    throw new Exception("Invalid Title. Expected: " + client.Title + " Received: " + server.Title);
                if (client.Description != server.Description)
                    throw new Exception("Invalid Description. Expected: " + client.Description + " Received: " + server.Description);
                if (client.NextIds.Length != server.NextIdsLen)
                    throw new Exception("Invalid NextIdsLen. Expected: " + client.NextIds.Length + " Received: " + server.NextIds);
                for (int j = 0; j < client.NextIds.Length; j++)
                {
                    if (client.NextIds[j] != server.NextIds[j])
                        throw new Exception("Invalid NextIds. Expected: " + client.NextIds[j] + " Received: " + server.NextIds[j] + " at index " + j);
                }
                if (client.ReplaceIds.Length != server.ReplaceIdsLen)
                    throw new Exception("Invalid ReplaceIdsLen. Expected: " + client.ReplaceIds.Length + " Received: " + server.ReplaceIdsLen);

                for (int j = 0; j < client.ReplaceIdsLen; j++)
                {
                    if (client.ReplaceIds[j] != server.ReplaceIds[j])
                        throw new Exception("Invalid ReplaceIds. Expected: " + client.ReplaceIds[j] + " Received: " + server.ReplaceIds[j] + " at index " + j);
                }
            }
        }

        //GetEnumHashTb
        public Hashtable GetEnumHashTb(ulong user, uint title, ushort locale, bool isweb)
        {
            Hashtable schema = gconfig.GetAchivement(title, locale, isweb);
            Hashtable retval = new Hashtable();
            int retIdx = 0;
            TitleKey key = new TitleKey(user, title);

            if (AchievementsToVerify.ContainsKey(key))
            {
                ArrayList Alist = (ArrayList)AchievementsToVerify[key];
                Alist.Sort(new AchievementEnumComparer());
                for (int i = 0; i < Alist.Count; i++, retIdx++)
                {
                    Achievemt tmp = (Achievemt)schema[((AchievementWD)Alist[i]).AchievementId];
                    AchievementWD AchToV = (AchievementWD)Alist[i];
                    AchievementWD Achievtmp = new AchievementWD(AchToV.AchievementId, AchToV.SortIndex);
                    Achievtmp.Type = tmp.Type;
                    Achievtmp.Description = tmp.Description;
                    Achievtmp.HowTo = tmp.HowTo;
                    Achievtmp.Title = tmp.Title;
                    Achievtmp.ImageId = tmp.ImageId;
                    Achievtmp.NextIds = tmp.NextIds;
                    Achievtmp.ReplaceIds = tmp.ReplaceIds;
                    Achievtmp.Cred = tmp.Weight;
                    Achievtmp.Achieved = AchToV.Achieved;

                    retval.Add(Achievtmp.AchievementId, Achievtmp);
                }
            }

            int countAchived = retIdx;
            uint[] Achievkey = new uint[schema.Keys.Count];
            schema.Keys.CopyTo(Achievkey, 0);

            for (int idx = Achievkey.Length - 1; idx >= 0; idx--)
            {
                Achievemt tmp = (Achievemt)schema[Achievkey[idx]];

                if (retval.ContainsKey(tmp.AchievementId))
                {
                    AchievementWD Achievtmp = (AchievementWD)retval[tmp.AchievementId];
                    if (tmp.ShowUnachieved)
                    {
                        Achievtmp.Flags = Achievtmp.Flags | (int)achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED;
                    }
                }
                else
                {
                    AchievementWD Achievtmp = new AchievementWD();
                    Achievtmp.AchievementId = tmp.AchievementId;
                    Achievtmp.Type = tmp.Type;
                    //Achievtmp.Flags = ConvertFirstTitleConfigPlatformToFlags(gconfig.GetSupportedPlatforms(title));
                    if (tmp.ShowUnachieved)
                    {
                        Achievtmp.Flags |= (int)achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED;
                    }
                    Achievtmp.Description = tmp.Description;
                    Achievtmp.HowTo = tmp.HowTo;
                    Achievtmp.Title = tmp.Title;
                    Achievtmp.ImageId = tmp.ImageId;
                    Achievtmp.NextIds = tmp.NextIds;
                    Achievtmp.ReplaceIds = tmp.ReplaceIds;
                    Achievtmp.Cred = tmp.Weight;

                    retval.Add(Achievtmp.AchievementId, Achievtmp);
                    retIdx++;
                }
            }

            return retval;
        }

        public enum TitleConfigSupportedPlatform
        {
            Xbox360 = 0,
            PC = 1,
            Mobile = 2,
            WebGames = 3,
            MaxPlatforms = 4,
        }

        public int ConvertFirstTitleConfigPlatformToFlags(bool[] supportedPlatforms)
        {
            for (int iPlatform = 0; iPlatform < supportedPlatforms.Length; iPlatform++)
            {
                if (supportedPlatforms[iPlatform])
                {
                    switch (iPlatform)
                    {
                        case (int)TitleConfigSupportedPlatform.Xbox360:
                            return (int)XOn.XACHIEVEMENT_DETAILS_PLATFORM_360;

                        case (int)TitleConfigSupportedPlatform.PC:
                            return (int)XOn.XACHIEVEMENT_DETAILS_PLATFORM_PC;

                        case (int)TitleConfigSupportedPlatform.Mobile:
                            return (int)XOn.XACHIEVEMENT_DETAILS_PLATFORM_MOBILE;

                        case (int)TitleConfigSupportedPlatform.WebGames:
                            return (int)XOn.XACHIEVEMENT_DETAILS_PLATFORM_WEB_GAMES;
                    }
                }
            }

            return 0;
        }

        public AchievementWD[] buildEnumResult(ulong user, uint title, ushort locale, bool isweb, GamerScore score)
        {
            Hashtable schema = gconfig.GetAchivement(title, locale, isweb);
            if (schema == null)
                return null;
            AchievementWD[] retval = new AchievementWD[schema.Count];
            int retIdx = 0;
            TitleKey key = new TitleKey(user, title);

            long tscore = 0;
            int AchiveCount = 0;

            if (AchievementsToVerify.ContainsKey(key))
            {
                ArrayList Alist = (ArrayList)AchievementsToVerify[key];
                Alist.Sort(new AchievementEnumComparer());
                for (int i = 0; i < Alist.Count; i++, retIdx++)
                {
                    Achievemt tmp = (Achievemt)schema[((AchievementWD)Alist[i]).AchievementId];
                    AchievementWD AchToV = (AchievementWD)Alist[i];
                    retval[retIdx] = new AchievementWD(AchToV.AchievementId, AchToV.SortIndex);
                    retval[retIdx].Flags = AchToV.Flags;
                    retval[retIdx].Type = tmp.Type;
                    retval[retIdx].Description = tmp.Description;
                    retval[retIdx].HowTo = tmp.HowTo;
                    retval[retIdx].Title = tmp.Title;
                    retval[retIdx].ImageId = tmp.ImageId;
                    retval[retIdx].NextIds = tmp.NextIds;
                    retval[retIdx].ReplaceIds = tmp.ReplaceIds;
                    retval[retIdx].Cred = tmp.Weight;
                    retval[retIdx].Achieved = AchToV.Achieved;

                    tscore += (long)tmp.Weight;
                    AchiveCount += 1;
                }
            }

            score.AddGameScore(title, tscore, AchiveCount);
            int countAchived = retIdx;
            uint[] Achievkey = new uint[schema.Keys.Count];
            schema.Keys.CopyTo(Achievkey, 0);

            for (int idx = Achievkey.Length - 1; idx >= 0; idx--)
            {
                Achievemt tmp = (Achievemt)schema[Achievkey[idx]];
                bool found = false;
                for (int i = 0; i < countAchived; i++)
                {
                    if (retval[i].AchievementId == tmp.AchievementId)
                    {
                        found = true;
                        if (tmp.ShowUnachieved)
                        {
                            retval[i].Flags = retval[i].Flags | (int)achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED;
                        }
                    }
                }

                if (!found)
                {
                    retval[retIdx] = new AchievementWD();
                    retval[retIdx].AchievementId = tmp.AchievementId;
                    retval[retIdx].Type = tmp.Type;
                    if (tmp.ShowUnachieved)
                    {
                        retval[retIdx].Flags = (int)achievementflags.XACHIEVEMENT_DETAILS_SHOWUNACHIEVED;
                    }
                    retval[retIdx].Description = tmp.Description;
                    retval[retIdx].HowTo = tmp.HowTo;
                    retval[retIdx].Title = tmp.Title;
                    retval[retIdx].ImageId = tmp.ImageId;
                    retval[retIdx].NextIds = tmp.NextIds;
                    retval[retIdx].ReplaceIds = tmp.ReplaceIds;

                    retval[retIdx].Cred = tmp.Weight;

                    retIdx++;
                }
            }
            return retval;
        }
    }

	public class  TitleScore
	{
		public long score=0;
		public int NoOfAchievements=0;
		public TitleScore(long s,int count)
		{
			score=s;
			NoOfAchievements=count;
		}
	}

	public class GamerScore
	{
		public long total=0;
		public long totalAchievements=0;
		private Hashtable TitlesPlayed = new Hashtable();

		public void AddGameScore(uint title, long score, int NoOfAch)
		{
			if(TitlesPlayed.Contains(title))
			{
				TitleScore tmp = (TitleScore)TitlesPlayed[title];;
				total=total-tmp.score;
				totalAchievements=totalAchievements-tmp.NoOfAchievements;
				TitlesPlayed.Remove(title);
			}
			TitlesPlayed.Add(title,new TitleScore(score,NoOfAch));
			total+=score;
			totalAchievements+=NoOfAch;
		}

		public TitleScore GetGameScore(uint title)
		{
			if(TitlesPlayed.Contains(title))
			{
				return (TitleScore)TitlesPlayed[title];
			}

			return null;
		}
		public uint[] Gettitles()
		{
			uint[] ttitles = new uint[TitlesPlayed.Keys.Count];
			int i=0;
			foreach(uint title in TitlesPlayed.Keys)
			{
				ttitles[i++]=title;
			}

			return ttitles;
		}
	}

	class TitleKey
	{
		ulong user;
		uint title;
		
		public TitleKey(ulong _user,uint _title)
		{
			user=_user;
			title=_title;
		}

		public override bool Equals(object obj)
		{
			return (user == ((TitleKey)obj).user)
				&& (title == ((TitleKey)obj).title);
		}
        
		public override int GetHashCode()
		{
			return (int)(title + user);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Achievement\XRLSyncAchievements.cs ===
using System;
using System.Collections;
using System.IO;
using System.Runtime.InteropServices;
using ServerTestFramework;
using System.Net;
using xonline.common.config;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Achievement
{
    public class achievementflags
    {
        public static uint XACHIEVEMENT_DETAILS_MASK_TYPE          = 0x00000007;
        public static uint XACHIEVEMENT_DETAILS_SHOWUNACHIEVED     = 0x00000008;
        public static uint XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE    = 0x00010000;
        public static uint XACHIEVEMENT_DETAILS_ACHIEVED           = 0x00020000;

        public const int XACHIEVEMENT_DETAILS_PLATFORM_MASK = 0x00700000;
        public const int XACHIEVEMENT_DETAILS_PLATFORM_SHIFT = 20;

        // From Common.Protocol
        public static int SetPlatformTypeInFlags(int existingFlags, int platformType)
        {
            int newFlags = existingFlags & ~XACHIEVEMENT_DETAILS_PLATFORM_MASK;

            int achFlag = MapPlatformTypeFlags(platformType);

            newFlags |= achFlag & XACHIEVEMENT_DETAILS_PLATFORM_MASK;

            return (newFlags);
        }
        // Function added to map the XPL_* platform flags to the XACHIEVEMENT_DETAILS_* flags
        // which was needed when we added Windows Mobile and WebGames Platforms that can now earn achievements
        public static int MapPlatformTypeFlags(int platformType)
        {
            uint achFlag = 0;

            switch (platformType)
            {
                case xonline.common.service.XOn.XPLT_XBOX360:
                    achFlag = xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_360;
                    break;
                case xonline.common.service.XOn.XPLT_PC:
                    achFlag = xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_PC;
                    break;
                case xonline.common.service.XOn.XPLT_MOBILE:
                    achFlag = xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_MOBILE;
                    break;
                case xonline.common.service.XOn.XPLT_WEB_GAMES:
                    achFlag = xonline.common.service.XOn.XACHIEVEMENT_DETAILS_PLATFORM_WEB_GAMES;
                    break;
                default:
                    break;
            }
            return (int)achFlag;
        }
    }

    public class AchievConst
    {
        public static DateTime MinDateTime = new DateTime(2002, 11, 15);
        public static ushort MAX_Achievement = 32;
    }

    public class AchievementWD : WireData ,IComparable
    {
        public uint  AchievementId = 0;
        public DateTime Achieved   = AchievConst.MinDateTime;
        public uint  SortIndex     = 0;   //aka the sequence number.
        public int   Flags         = 0;
        public byte  Type          = 0;
        public int   Cred          = 0;
        public uint  ImageId       = 0;
        public byte TitleLen       = 0;
        public string Title        = "";
        
        public byte DescriptionLen = 0;
        public string Description  = "";

        public byte HowToLen       = 0;
        public string HowTo        = "";
        
        public byte NextIdsLen     = 0;
        public uint[] NextIds      = null;
        
        public byte ReplaceIdsLen  = 0;
        public uint[] ReplaceIds      = null;

        //these items are not part of the actual WireData, and are here solely to aid with testing.
        [WireInfo(Serialize=false)]
        public DateTime Dt_updated = DateTime.UtcNow;

        //max and min sync time represent a window.  All offline achievements earned are known to
        //occur in this window between two points of being online.  This represents the last time
        //you were online, and the time before that.
        [WireInfo(Serialize=false)]
        public DateTime minSyncTime = DateTime.FromFileTime(0);  //The last time a sync occurred.  This
                                                          //is to remain the win32 min time, as it is unused at
                                                          //the moment.

        [WireInfo(Serialize=false)]
        public DateTime maxSyncTime = DateTime.FromFileTime(0);  //The most recent time a sync occurred.


        public AchievementWD()
        {
        }

        public int CompareTo(object obj)
        {
            //The order should be:
            //max_time, min_time, sequence number

            int retval= ((AchievementWD)obj).maxSyncTime.ToFileTimeUtc().CompareTo(maxSyncTime.ToFileTimeUtc());
            if(retval == 0) {  //if that's the same, try the min time.
                retval= ((AchievementWD)obj).minSyncTime.ToFileTimeUtc().CompareTo(minSyncTime.ToFileTimeUtc());
                if (retval == 0) { //if *that's* the same, try using the SortIndex(aka sequence number)
                    retval= ((AchievementWD)obj).SortIndex.CompareTo(SortIndex);
                }
            }
            return retval;
        }

        public AchievementWD(uint achievementId, uint sortidx)
        {
            this.AchievementId = achievementId;
            this.SortIndex      = sortidx;
            // Assume Achievement from a 360 Platform if not specified
            this.Flags = achievementflags.SetPlatformTypeInFlags((int)(achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED | achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE), xonline.common.service.XOn.XPLT_XBOX360);
        }

        public AchievementWD(uint achievementId, uint sortidx, int flags)
        {
            this.AchievementId = achievementId;
            this.SortIndex      = sortidx;
            this.Flags         = flags | (int)achievementflags.XACHIEVEMENT_DETAILS_ACHIEVED_ONLINE;

            // Check if Platform is Set
            //if ((this.Flags & (achievementflags.XACHIEVEMENT_DETAILS_PLATFORM_MASK << achievementflags.XACHIEVEMENT_DETAILS_PLATFORM_SHIFT)) == 0x0)
            if ((this.Flags & achievementflags.XACHIEVEMENT_DETAILS_PLATFORM_MASK) == 0x0)
            {
                // No Platform flag, so set to 360 as Default
                this.Flags = achievementflags.SetPlatformTypeInFlags(this.Flags, xonline.common.service.XOn.XPLT_XBOX360);
            }
        }

        public override bool Equals(object obj)
        {
            bool retval = false;
            if(AchievementId == ((AchievementWD)obj).AchievementId)
                retval= true;

            return retval;
        }

        public override int GetHashCode()
        {
            return (int)(AchievementId);
        }

        //Record the time this achievement was synced.  For now, this will only affect the maxTime.
        public void RecordSyncTime(DateTime synced) {
            this.maxSyncTime = synced;
        }

    }


    public class AchievementEnumComparer : IComparer
    {
        //this only works on AchievementEnums.  Note that the legacy code has the two arguments flipped.
        public int Compare(object x,object y)
        {
            return ((AchievementWD)x).CompareTo((AchievementWD)y);
/*
  int retval= ((int)((AchievementWD)y).SortIndex).CompareTo((int)((AchievementWD)x).SortIndex);
  if (retval == 0)
  retval = ((AchievementWD)y).Dt_updated.ToFileTimeUtc().CompareTo(((AchievementWD)x).Dt_updated.ToFileTimeUtc());
  return retval;
*/
        }
    }

    /// <summary>
    /// Summary description for XRLSyncAchievements.
    /// </summary>
    public class XRLSyncAchievements :XRLPayload
    {
        [XRLPayloadFld(IsTitleId=true)]
        public uint  TitleId = 0;
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserId  = 0;
        public DateTime Version = DateTime.UtcNow;
        public ushort LocaleId = 1033;
        public ushort StartingIndex = 0;
        public ushort AchievementsLen = 0;
        public AchievementWD[] Achievements = null;

        [WireInfo(Serialize=false)]
        public AuthModify Modifyflag = AuthModify.None;
        [WireInfo(Serialize=false)]
        public uint LanguageID = 0;

        public override void ManualPopulateSlot()
        {
            PopulateSlot(ref Slot);

            if(Modifyflag == AuthModify.Change_Title)
            {
                Slot.titleId+=10;
            }
            else if (Modifyflag == AuthModify.Change_User)
            {
                Slot.userPuid0+=10;
                Slot.userPuid1+=10;
                Slot.userPuid2+=10;
                Slot.userPuid3+=10;
            }
            
            Slot.SetRegionInfo(0, LanguageID);

            ManualSlotSetup=true;
        }


        public XRLSyncAchievements()
        {
            // Set Xbox 360 as the default machine type the Achievements are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }
        public XRLSyncAchievements(uint title,ulong user,AchievementWD[] alist)
        {
            TitleId = title;
            UserId = user;
            Achievements= alist;
            // Set Xbox 360 as the default machine type the Achievements are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }
        public XRLSyncAchievements(uint title,ulong user,AchievementWD[] alist,DateTime _Version,ushort _StartingIndex,ushort _LocaleId)
        {
            TitleId = title;
            UserId = user;
            Achievements= alist;
            Version=_Version;
            StartingIndex= _StartingIndex;
            LocaleId=_LocaleId;
            // Set Xbox 360 as the default machine type the Achievements are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }
        public XRLSyncAchievements(uint title,ulong user,AchievementWD[] alist,DateTime _Version)
        {
            TitleId = title;
            UserId = user;
            Achievements= alist;
            Version=_Version;
            // Set Xbox 360 as the default machine type the Achievements are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }

        public XRLSyncAchievements(uint title,ulong user,AchievementWD[] alist,DateTime _Version,ushort _StartingIndex)
        {
            TitleId = title;
            UserId = user;
            Achievements= alist;
            Version=_Version;
            StartingIndex= _StartingIndex;
            // Set Xbox 360 as the default machine type the Achievements are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }

        public void SetMachineClientType(CSGInfo.ClientType clientType)
        {
            Slot.ChangeClientType(clientType);
        }

        protected override string GetServiceName()
        {
            return "/xstats/syncachievements.ashx";
        }

        new public SyncAchievementsResponse Execute()
        {
            //For test purposes only, we will note in the AchievementWD the current time for sync purposes.
            foreach(AchievementWD ach in Achievements) {
                ach.RecordSyncTime(DateTime.UtcNow);
            }

            // Prepare request 
            MemoryStream reqStream = new MemoryStream( 512 );
            this.WriteStream(reqStream);

            if(Modifyflag != AuthModify.None || LanguageID !=0)
                ManualPopulateSlot();
				
            bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd),reqStream);
            // create a streem here and then read all data;
            SyncAchievementsResponse readResp = (SyncAchievementsResponse)new SyncAchievementsResponse().ReadBytes(XErr,xAct.ResponseContents);
            return readResp;
				
        }

        // Added for testing WinMo/WebGames platforms which use the OnBehalfOf headers
        public SyncAchievementsResponse ExecuteInt(int iPlatform, int iOnBehalfOf)
        {
            SyncAchievementsResponse resp = null;
 
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            // HTTPAUTH
            IPEndPoint endpoint = Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd_int);
            ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
            byte[] addr = endpoint.Address.GetAddressBytes();
            uint ip = 0;
            for (int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];

            HTTPAuthData authData = new HTTPAuthData((ushort)endpoint.Port, ip, requestId, UserId, TitleId, (uint)XOService.Progress, 0);
            CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" + authData.GetBase64EncodedString() + "\r\n";

            // Pass in the XPLT platform and OnBehalfOf
            CustomHeader += "XPLT:" + iPlatform + "\r\n";
            CustomHeader += "XPLTOnBehalfOf:" + iOnBehalfOf + "\r\n";

            bool bRet = InternalExecute(endpoint, reqStream);

            if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
            {
                if (xAct.ResponseContents.Length > 0)
                    resp = (SyncAchievementsResponse)new SyncAchievementsResponse().ReadBytes(xAct.ResponseContents);
            }
            else
            {
                resp = (SyncAchievementsResponse)new SyncAchievementsResponse();
                resp.xResult = xAct.XErr;
            }

            return resp;
        }
    }

    public class SyncAchievementsResponse : WireData
    {
        public DateTime Version = DateTime.MinValue;
        public ushort TotalAchievements = 0;
        public ushort AchievementsCount = 0;
        [WireInfo(SizeParam="AchievementsCount")]
        public AchievementWD[] Achievements = null;
        [WireInfo(Serialize=false)]
        public uint xResult =0;

		
        public SyncAchievementsResponse ReadBytes(uint XErr,byte[]  Respdata)
        {
            xResult = XErr;
            if(HResult.Succeeded(XErr))
            {
                base.ReadBytes(Respdata);
            }
            return this;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Achievement\XRLEnumAvatarAsset.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using ServerTestFramework;
using System.Net;
using xonline.common.config;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.service;

namespace ServerTestFramework.LiveService.AvatarAsset
{
    public class XRLEnumAvatarAsset : XRLPayload
    {
        [XRLPayloadFld(IsTitleId = true)]
        public uint TitleId = 0;
        [XRLPayloadFld(IsUPuid = true)]
        public ulong Puid = 0;
        public ulong ForPuid = 0;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;
        public ushort MaxAssets = 32;

        [WireInfo(Serialize = false)]
        public AuthModify Modifyflag = AuthModify.None;

        [WireInfo(Serialize = false)]
        public uint LanguageID = 0;
        [WireInfo(Serialize = false)]
        public uint CountryID = 0;
        

        public override void ManualPopulateSlot()
        {
            PopulateSlot(ref Slot);

            if (Modifyflag == AuthModify.Change_Title)
            {
                Slot.titleId += 10;
            }
            else if (Modifyflag == AuthModify.Change_Title_PUB)
            {
                Slot.titleId = Slot.titleId + 0xFFF00000;
            }
            else if (Modifyflag == AuthModify.Change_User)
            {
                Slot.userPuid0 += 10;
                Slot.userPuid1 += 10;
                Slot.userPuid2 += 10;
                Slot.userPuid3 += 10;

            }
            else if (Modifyflag == AuthModify.Read_Activity_FriendOnly)
            {
                Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
                Slot.SetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
            }
            else if (Modifyflag == AuthModify.Read_Activity_None)
            {
                Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
                Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
            }

            Slot.SetRegionInfo(CountryID, (ushort)LanguageID);

            ManualSlotSetup = true;
        }


        public XRLEnumAvatarAsset(uint title, ulong user, ulong friend, ushort locale, ushort start, ushort count)
        {
            TitleId = title;
            Puid = user;
            ForPuid = friend;
            LocaleId = locale;
            StartingIndex = start;
            MaxAssets = count;
        }

        protected override string GetServiceName()
        {
            return "/xstats/xavatarassetenum.ashx";
        }

        new public AvatarAssetEnumResponse Execute()
        {
            AvatarAssetEnumResponse readResp = null;
            // Prepare request 
            MemoryStream reqStream = new MemoryStream(512);
            this.WriteStream(reqStream);

            if (Modifyflag != AuthModify.None || LanguageID != 0)
                ManualPopulateSlot();

            bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd), reqStream);
            // create a streem here and then read all data;
            if (xAct.httpStatus == HttpStatusCode.OK)
            {
                readResp = (AvatarAssetEnumResponse)new AvatarAssetEnumResponse().ReadBytes(xAct.ResponseContents);

            }
            else
            {
                readResp = (AvatarAssetEnumResponse)new AvatarAssetEnumResponse();
                readResp.xResult = xAct.XErr;
            }

            return readResp;

        }
    }

    public class AvatarAssetEnumResponse : WireData
    {
        public ushort AvatarAssetsCount = 0;
        [WireInfo(SizeParam = "AvatarAssetsCount")]
        public AvatarAssetWD[] AvatarAssets = null;
        [WireInfo(Serialize = false)]
        public uint xResult = 0;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WireData.cs ===
using System;
using System.Reflection;
using System.Net;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.ComponentModel;
using System.Runtime.InteropServices;

using xcs=xonline.common.service;
using xonline.core.wiredata;

namespace ServerTestFramework
{
    //TODO: this should be in a shared place instead of both here AND livelib, but for now it exists in 2 places and needs to be updated accordingly
    public static class WireDataPublicKey
    {
        private static byte[] key = null;
        private static int version = 0;

        public static byte[] GetLatestKey()
        {
            if (key == null)
            {
                UpdateCachedKey();
            }
            return key;
        }

        public static int GetLatestKeyVersion()
        {
            if (version == 0)
            {
                UpdateCachedKeyVersion();
            }
            return version;
        }

        private static void UpdateCachedKey()
        {
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            System.Data.SqlClient.SqlDataReader dr;
            string query = @"select [vc_value] from [t_live_registry_settings] 
                            where vc_setting = 'WiredataPublicKey' and
                            vc_environment = '" + ServerTestFramework.Global.XEnv.GetEnv() + "'";
            npdb.ReadData(query, out dr);
            if (dr.HasRows)
            {
                dr.Read();
                string storedKey = dr.GetString(0);
                key = System.Convert.FromBase64String(storedKey);
            }
            else
            {
                throw new Exception(string.Format("Failed to find WiredataPublicKey in t_live_registry_settings for environment: {0}!", ServerTestFramework.Global.XEnv.GetEnv()));
            }
        }

        private static void UpdateCachedKeyVersion()
        {
            ServerTestFramework.Database.Npdb npdb = new ServerTestFramework.Database.Npdb();
            npdb.ConnectToServer();
            System.Data.SqlClient.SqlDataReader dr;
            string query = @"select [vc_value] from [t_live_registry_settings] 
                            where vc_setting = 'WiredataKeyVersion' and
                            vc_environment = '" + ServerTestFramework.Global.XEnv.GetEnv() + "'";
            npdb.ReadData(query, out dr);
            if (dr.HasRows)
            {
                dr.Read();
                string sVersion = dr.GetString(0);
                version = Int32.Parse(sVersion);
            }
            else
            {
                throw new Exception(string.Format("Failed to find WiredataKeyVersion in t_live_registry_settings for environment: {0}!", ServerTestFramework.Global.XEnv.GetEnv()));
            }
        }
    }
    
    /// <summary>
    /// Extend this if you want to include a base class's members in the Wiredata serialization. This will
    /// include all public instance variables in base classes, up through the chain to the base Wiredata class.
    /// Fields in base classes will be serialized first.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public class WireDataIncludeBase : WireData
    {
        // Remove the BindingFlags.DeclaredOnly so that we include inherited members as well
        public WireDataIncludeBase() : base(BindingFlags.Public | BindingFlags.Instance)
        {
        }
    }


    /// <summary>
    /// Provides easy serialization of  structured data into byte streams.
    /// </summary>
    /// <remarks>
    /// The <c>WireData</c> class provides a method of serializing class data into byte streams.  This is especially
    /// useful transfering data over the network.  Using <c>WireData</c> is very simple.  First create a class that derives
    /// from <c>WireData</c>.  Then add public member variables that specify the format of the data that this class targets in
    /// the order it appears in the stream.  For many cases this is enough to start serializing and deserializing with
    /// your <c>WireData</c> class.
    /// <list type="bullet">
    /// <item>
    /// <term>Serialization to a byte[]</term>
    /// <description>Fill out your structure and cast your class to a <c>byte[]</c>.  The resulting <c>byte[]</c> will be your serialization data.  Alternatively you can call WriteStream and pass a <c>Stream</c> for a similar effect.</description>
    /// </item>
    /// <item>
    /// <term>Deserialization from a byte[] or a Stream</term>
    /// <description>Construct a new instance of your class and call ReadStream on your <c>byte[]</c> or <c>Stream</c>.  Your instance will contain the data that was present in the <c>Stream</c>.</description>
    /// </item>
    /// </list>
    ///
    /// WireData derived classes are made up of different data types.  The valid data types for serialization are as follows:
    /// <list type="bullet">
    /// <item>
    /// <term>Supported native types</term>
    /// <description>The types that may make up WireData types are: <c>bool</c>, <c>byte</c>, <c>char</c>, <c>decimal</c>, <c>double</c>, <c>short</c>, <c>int</c>, <c>long</c>, <c>sbyte</c>, <c>float</c>, <c>ushort</c>, <c>uint</c>, <c>ulong</c>, <c>DateTime</c>, <c>string</c>, arrays of any of these types and other <c>WireData</c> derived classes.  <c>DateTime</c> is supported like a native type and is serialized by calling its ToFileTime.</description>
    /// </item>
    /// <item>
    /// <term>Embedded WireData classes</term>
    /// <description><c>WireData</c> classes can also contain other embedded <c>WireData</c> classes as members.</description>
    /// </item>
    /// <item>
    /// <term>Arrays</term>
    /// <description><c>WireData</c> supports arrays of any of the other types of supported data types.  To use an array you must specifiy how many items are in the array.  See <see cref="ServerTestFramework.WireInfoAttribute"/> and "Arrays" section below for details on how to use arrays.</description>
    /// </item>
    /// <item>
    /// <term>Strings</term>
    /// <description>Strings are treated almost identically to arrays.  To use a string you must specifiy how many characters are in the string.  See <see cref="ServerTestFramework.WireInfoAttribute"/> and the "Arrays" section below for more information.  They are UTF8 encoded for serialization.</description>
    /// </item>
    /// </list>
    ///
    /// <b>Arrays</b><br/>
    /// <para>Since Arrays are not always the same size there are special considerations that are nescessary.  For example, a deserializer needs to know how many elements to allocate for the array and how much data to pull in.  A seriailzer needs to know where to serialize the element count for a variable sized array.  For these and other reasons, a <see cref="ServerTestFramework.WireInfoAttribute"/> needs to be specified any time an array is declared.</para>
    /// The size needs to be specified in one of three ways:
    /// <list type="number">
    /// <item>
    /// <term>ArraySize</term>
    /// <description>Specify an <c>ArraySize</c> when the array always has a constant number of elements.  If there are 4 <c>int</c>s (comprising 16 bytes) set <c>SizeParam = 4</c>.  On serialization if the array doesn't have enough elements the stream will be zero-padded.</description>
    /// </item>
    /// <item>
    /// <term>SizeParam</term>
    /// <description>For variable-sized arrays you can tell <c>WireData</c> to look at a different integral (such as <c>int</c>) field to get and set the number of array elements from and to.  Set <c>SizeParam</c> to be the name of the field that represents the element count.  If you set this up then when serializing/deserializing, <c>WireData</c> will take care of setting the linked count so you do not have to.  See the example below for more information.</description>
    /// </item>
    /// <item>
    /// <term>&lt;field&gt;Len</term>
    /// <description>For coveniance you don't usually have to specify the attribute for variable sized arrays at all.  Just take the field that you want to link as if you were using <c>SizeParam</c> above and name it the same as the array but append "Len" to the end.  See the example below for more information.</description>
    /// </item>
    /// </list>
    /// <para><b>Overloaded ReadStream/WriteStream</b></para>
    /// <para>There are situations where the above features don't make up enough functionality to match your protocol.  In these cases you will need to override <c>ReadStream</c> and <c>WriteStream</c> in your <c>WireData</c> derived class.  See <see cref="ServerTestFramework.WireData.ReadStream(Stream)"/> for more information.</para>
    /// </remarks>
    ///
    /// <example>
    /// This sample shows how to call use the main features of WireData.
    /// <code>
    ///    public class ExampleWireData : WireData
    ///    {
    ///        public byte JustAByte = 0;
    ///        [WireInfo(ArraySize=10)] public string ConstString;
    ///        public int SizeForVarString;
    ///        [WireInfo(SizeParam="SizeForVarString")] public string VarString;
    ///        public uint VarByteArrayLen;
    ///        public int[] VarByteArray;
    ///
    ///        [STAThread]
    ///        static void Main(string[] args)
    ///        {
    ///            // Create and fill out the ExampleWireData structure
    ///            ExampleWireData wd1 = new ExampleWireData();
    ///            wd1.JustAByte = 4;
    ///            wd1.ConstString = "hello";
    ///            wd1.VarString = "goodbye";
    ///            wd1.VarByteArray = new int[3] {5, 6, 7};
    ///
    ///            // Serialize ExampleWireData to byte array
    ///            byte[] data = (byte[])wd1;
    ///            Debug.Assert(data.Length == 38);
    ///
    ///            // Create, deserialize and verify that it was converted correctly
    ///            ExampleWireData wd2 = new ExampleWireData();
    ///            wd2.ReadBytes(data);
    ///            Debug.Assert(wd2.JustAByte == 4);
    ///            Debug.Assert(wd2.ConstString == "hello");
    ///            Debug.Assert(wd2.VarString == "goodbye");
    ///            Debug.Assert(wd2.VarByteArray[0] == 5);
    ///            Debug.Assert(wd2.VarByteArray[1] == 6);
    ///            Debug.Assert(wd2.VarByteArray[2] == 7);
    ///        }
    ///    }
    /// </code>
    /// </example>
    ///
    [StructLayout(LayoutKind.Sequential)]
    public class WireData
    {
        [WireInfo(Serialize=false)]
        protected static UTF8Encoding    utf8 = new UTF8Encoding();
        [WireInfo(Serialize=false)]
        protected static UnicodeEncoding unicodeEnc = new UnicodeEncoding();

        public static uint MakeSchemaVersion(ushort major, ushort minor)
        {
            return (uint)major << 16 | (uint)minor;
        }

        // Fuzzing flag. If true, the data will be fuzzed if it has the [FuzzData()]
        // attribute. If false, all fuzzing will be skipped.
        [WireInfo(Serialize = false)]
        public static bool Fuzz = false;

        // This is the version number of the latest schema. Must be the same as
        // XLIVE_SCHEMA_VERSION in xonline.xd in the client tree.
        [WireInfo(Serialize=false)]
        private static readonly uint CurrentSchemaVersion = MakeSchemaVersion(6, 6);
           
        // Version of the schema to use for serializing/deserializing this object.
        [WireInfo(Serialize=false)]
        public uint SchemaVersion = CurrentSchemaVersion;

        /// <summary>
        /// If set, you will need to manually provide array sizes when writing WireDatas
        /// </summary>
        [WireInfo(Serialize=false)]
        public bool ManualArraySize = false;

        /// <summary>
        /// Setting this to true will dump WireData info as it's being written to a stream
        /// </summary>
        [WireInfo(Serialize=false)]
        public static bool DumpDiagnosticInfo = false;

        /// <summary>
        /// If set, overrides NullTerminated attribute. That is things that are supposed to be
        ///  null terminated, won't be.
        /// </summary>
        [WireInfo(Serialize=false)]
        public bool NullTermOverRide = false;

        private class SizeParamIndex
        {
            public int[] forward = null;
            public int[] reverse = null;

            public SizeParamIndex(int size)
            {
                forward = new int[size];
                reverse = new int[size];

                for (int i = 0; i < size; i++)
                {
                    forward[i] = -1;
                    reverse[i] = -1;
                }
            }
        }

        [WireInfo(Serialize=false)]
        private static Hashtable sizeParamIndicies = new Hashtable();
        [WireInfo(Serialize=false)]
        private static Hashtable fieldCache = new Hashtable();

        [WireInfo(Serialize=false)]
        protected static BindingFlags defaultBindingFlags = (BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

        public WireData() : this(defaultBindingFlags)
        {
        }

        protected static void InitFieldCache ( Type type )
        {
            InitFieldCache(type, defaultBindingFlags);
        }

        protected static void InitFieldCache ( Type type, BindingFlags bindingFlags )
        {
            // Check to see if this WireData has already been initialized.
            if (sizeParamIndicies[type] != null)
                return;

            //Regarding the old comment below... the docs indicate otherwise.  Maybe it was ancient .NET v1 problem?
            //I'm adding the pre-check above as the lock was majorly impacting kdc stress perf.

            // Grab the lock to make sure we get this done in the right order.  We would like to do a early out for
            // this in the common case but because of some .NET out of order processing magic, execution might not occur in
            // the expected order.
            // We lock on the hashtable, which is a more restrictive lock than we might be able to use (GetType())
            // might be better but then we have to lock sizeParamIndicies at exactly the right places, which is even
            // more confusing.
            lock (sizeParamIndicies)
            {
                // Check to see if this WireData has already been initialized.
                if (sizeParamIndicies[type] != null)
                    return;

                //if this class is marked as not serializable, don't try to serialize it
                WireDataInfoAttribute []wdClassInfo=(WireDataInfoAttribute[])type.GetCustomAttributes(typeof(WireDataInfoAttribute), true);
                if (wdClassInfo!=null && wdClassInfo.Length!=0 && !wdClassInfo[0].Serialize)
                {
                    sizeParamIndicies.Add(type, new SizeParamIndex(0));
                    fieldCache.Add(type, new FieldCache(new FieldInfo[0], false));
                    return;
                }

                // Index this WireData derivative.
                // If not DeclaredOnly (which means we are including inherited members), then we
                // need to sort by the hierarchy.  Within a given class, the order of fields
                // is correct, but the order of classes is reversed.
                FieldCache fc;
                if ((bindingFlags & BindingFlags.DeclaredOnly) == 0)
                {
                    fc = new FieldCache(type.GetFields(bindingFlags), true);
                    fc.AddForcedFields(type.GetFields(BindingFlags.Instance | BindingFlags.Public |
                        BindingFlags.NonPublic), true);
                }
                else
                {
                    fc = new FieldCache(type.GetFields(bindingFlags), false);
                    fc.AddForcedFields(type.GetFields(BindingFlags.Instance | BindingFlags.Public |
                        BindingFlags.NonPublic | BindingFlags.DeclaredOnly), false);
                }
                SizeParamIndex index = new SizeParamIndex(fc.Fields.Length);

                for (int i = 0; i < fc.Fields.Length; i++)
                {
                    FieldInfo field = fc.Fields[i];
                    WireInfoAttribute wireInfo = fc.WireInfo[i];

                    // ignore if we are not serializing or we were forced to serialize
                    if (!wireInfo.Serialize || wireInfo.ForceSerialize)
                        continue; // ignore this field

                    if (field.FieldType.IsArray || field.FieldType == typeof(string))
                    {
                        if (wireInfo.ArraySize == -1)
                        {
                            if (!wireInfo.WriteOnlyVarLenString)
                            {
                                string sizeParamName = fc.WireInfo[i].SizeParam;
                                if (sizeParamName == null)
                                    sizeParamName = field.Name + "Len";

                                int j;
                                for (j = 0; j < i; j++)
                                    if (fc.Fields[j].Name == sizeParamName)
                                        break;

                                if (j == i)
                                    throw new Exception("Field \"" + field.Name + "\" must have either an ArraySize, a SizeParam or there must be a field named \"" + field.Name + "Len\".");

                                index.forward[i] = j;
                                index.reverse[j] = i;
                            }
                        }
                        else
                        {
                            if (wireInfo.SizeParam != null)
                                throw new Exception("Field \"" + field.Name + "\" can not have both a SizeParam and an ArraySize.");
                        }
                    }
                }
                sizeParamIndicies.Add(type, index);
                fieldCache.Add(type, fc);
            }
        }

        /// <summary>
        /// Gets the static entry in the WireData field cache that
        /// corresponds to the type passed in. If one does not exist,
        /// InitFieldCache will create one.
        /// </summary>
        /// <param name="type">Type to get the field cache line for.</param>
        /// <returns>The FieldCache object for the given type, or null if one cannot be constructed.</returns>
        public static WireData.FieldCache GetFieldCacheLine (Type type)
        {
            try
            {
                if (!fieldCache.Contains(type))
                {
                    WireData.InitFieldCache(type);
                }
            }
            catch (Exception ex)
            {
                Global.RO.Error(ex.Message);
                return null;
            }
            return (WireData.FieldCache) fieldCache[type];
        }

        public WireData(BindingFlags bindingFlags)
        {
            InitFieldCache(this.GetType(), bindingFlags);
        }

        /// <summary>
        /// This serializes a <c>WireData</c> class to a byte[].
        /// </summary>
        public static explicit operator byte[](WireData wiredata)
        {
            if (wiredata == null)
                return null;
            MemoryStream stream = new MemoryStream();
            wiredata.WriteStream(stream);
            return stream.ToArray();
        }

        /// <summary>
        /// ReadBytes deserializes a byte[] to a <c>WireData</c> class.
        /// </summary>
        public WireData ReadBytes(byte[] bytes)
        {
            if (bytes == null)
                return null;
            return ReadStream(new BinaryReader(new MemoryStream(bytes)));
        }

        /// <summary>
        /// ReadBytes deserializes a byte[] to a <c>WireData</c> class.
        /// </summary>
        /// <param name="bytes">Byte array of data, may be larger than necessary</param>
        /// <param name="bytesSize">The number of bytes of data to use. Must be less than or equal to bytes.Length.</param>
        /// <returns></returns>
        public WireData ReadBytes(byte[] bytes, int bytesSize)
        {
            return ReadStream(new BinaryReader(new MemoryStream(bytes, 0, bytesSize)));
        }

        public void ReadDelegate(xonline.common.service.WireData ignored, BinaryReader binaryReader)
        {
            SizeParamIndex index = (SizeParamIndex)sizeParamIndicies[GetType()];
            if (index == null)
                throw new Exception("This WireData type has not been initialized!  It should have been found in the sizeParamIndicies hashtable.");

            FieldCache fc = (FieldCache)fieldCache[GetType()];

            for (int i = 0; i < fc.Fields.Length; i++)
            {
                FieldInfo field = fc.Fields[i];
                WireInfoAttribute wireInfo = fc.WireInfo[i];

                if (!wireInfo.Serialize ||
                        this.SchemaVersion < wireInfo.MinSchemaVersionVal ||
                        this.SchemaVersion > wireInfo.MaxSchemaVersionVal)
                    continue;

                object o = null;
                // Handle arrays
                if (field.FieldType.IsArray || field.FieldType == typeof(string))
                {
                    int size = wireInfo.ArraySize;
                    if (size == -1 && !wireInfo.WriteOnlyVarLenString)
                    {
                        try
                        {
                            size = Convert.ToInt32(fc.Fields[index.forward[i]].GetValue(this));
                        }
                        catch (InvalidCastException e)
                        {
                            throw new Exception("Field \"" + field.Name + "\" is not an index (numeric) type.", e);
                        }
                    }

                    if (field.FieldType == typeof(string))
                    {
                        byte[] rawBytes = ReadBytes(binaryReader, size);

                        string s;
                        if (wireInfo.UnicodeEncoded)
                        {
                            s = unicodeEnc.GetString(rawBytes);
                        }
                        else
                        {
                            s = utf8.GetString(rawBytes);
                        }
                        int termPos = s.IndexOf((char)0);
                        if (termPos > 0)
                            o = s.Substring(0, s.IndexOf((char)0));
                        else if (termPos == -1)
                            o = s;
                        else
                            o = "";
                    }
                    else if (field.FieldType == typeof(byte[]))
                    {
                        o = ReadBytes(binaryReader, size);
                    }
                    else
                    {
                        o = field.GetValue(this);
                        if (o == null)
                        {
                            ArrayList values = new ArrayList();
                            Type elementType = field.FieldType.GetElementType();

                            if (size == -1)
                            {
                                try
                                {
                                    while (true)
                                    {
                                        values.Add(ReadValue(binaryReader, elementType, null));
                                    }
                                }
                                catch (EndOfStreamException)
                                {
                                    // swallow this, for it is the end, which means we will lose the cases where there was a
                                    // partial element.  changing that requires somewhat of a rearchitecting of the reading code
                                }
                            }
                            else
                            {
                                for (int j = 0; j < size; j++)
                                    values.Add(ReadValue(binaryReader, elementType, null));
                            }

                            o = values.ToArray(elementType);
                        }
                        else
                        {
                            // Use type info from the actual data passed in.
                            for (int k = 0; k < (o as Array).Length; ++k)
                            {
                                object val = (o as Array).GetValue(k);
                                (o as Array).SetValue(ReadValue(binaryReader, val.GetType(), val), k);
                            }
                        }
                    }
                }
                else
                {
                    o = ReadValue(binaryReader, field.FieldType, null);
                    CheckRange(o, wireInfo, field.FieldType, field.Name);
                }
                                
                field.SetValue(this, o);
            }
        }

        /// <summary>
        /// Private function for reading a byte[] from the reader.
        /// </summary>
        /// <param name="binaryReader">The reader to read from.</param>
        /// <param name="count">The number of bytes to read. -1 means read to the end.</param>
        /// <returns>A byte[] of the bytes read.</returns>
        private byte[] ReadBytes (BinaryReader binaryReader, int count)
        {
            byte[] ans = null;

            if (count == -1)
            {
                List<byte[]> byteSegments = new List<byte[]>();
                int arbitrarySize = 1 * 1024 * 1024;

                while (true)
                {
                    // read a MB at a time
                    byte[] bytes = binaryReader.ReadBytes(arbitrarySize);

                    // no bytes left to read
                    if (bytes.Length == 0)
                    {
                        break;
                    }

                    byteSegments.Add(bytes);
                }

                if (byteSegments.Count == 0)
                {
                    ans = new byte[0];
                }
                else if (byteSegments.Count == 1)
                {
                    ans = byteSegments[0];
                }
                else
                {
                    // count the total byte length
                    int totalCount = 0;

                    foreach (byte[] bytes in byteSegments)
                    {
                        totalCount += bytes.Length;
                    }

                    // create a new array to hold them all
                    ans = new byte[totalCount];

                    // copy them together
                    totalCount = 0;

                    foreach (byte[] bytes in byteSegments)
                    {
                        Buffer.BlockCopy(bytes, 0, ans, totalCount, bytes.Length);
                        totalCount += bytes.Length;
                    }
                }
            }
            else
            {
                ans = binaryReader.ReadBytes(count);
            }

            return ans;
        }
        
        #region Reader
        /// <summary>
        /// ReadStream deserializes a stream to fill this <c>WireData</c> class.
        /// </summary>
        /// <param name="stream">The source stream to deserialize from.</param>
        /// <returns>Returns a copy of itself.  This is just a convenience for constructing and deserializing at once.</returns>
        /// <example>
        /// <b>Overloaded ReadStream/WriteStream</b>
        /// <para>When implementing a complex protocol you may run into situations where the built in functionality is not sufficient.  An common example of this is when a header precedes a section that's structure depends on a value in the header.  For example, a IP packet has a byte 24 bytes in which if it equals 17 then the rest of the packet after the header should be interpreted as UDP and if it's 6, TCP.  This affects the following structure of the packet.</para>
        /// <para>The example below is a trivialized version of making TCP/UDP/IP packets.  For simplicity I am leaving out portions of the protocol and not actually handling the body of the packets.  This implementation is completely self-contained.  All you have to do is create a <c>Packet</c> object and call ReadStream on it to pull in a UDP or TCP packet.</para>
        /// <code>
        ///    public class Packet : WireData
        ///    {
        ///        public IPHeader IPHeader;
        ///        public ProtocolHeader ProtocolHeader;
        ///
        ///        public override WireData ReadStream(Stream stream)
        ///        {
        ///            IPHeader.ReadStream(stream);
        ///            Debug.Assert(IPHeader.Type == 0x11 || IPHeader.Type == 0x6);
        ///            if (IPHeader.Type == 0x11)
        ///                ProtocolHeader = (ProtocolHeader)new UDPHeader().ReadStream(stream);
        ///            else
        ///                ProtocolHeader = (ProtocolHeader)new TCPHeader().ReadStream(stream);
        ///
        ///            return this;
        ///        }
        ///
        ///        public override void WriteStream(Stream stream)
        ///        {
        ///            if (ProtocolHeader is UDPHeader)
        ///                IPHeader.Type = 0x11;
        ///            else
        ///                IPHeader.Type = 0x6;
        ///
        ///            IPHeader.WriteStream(stream);
        ///            ProtocolHeader.WriteStream(stream);
        ///        }
        ///    }
        ///
        ///    public class IPHeader : WireData
        ///    {
        ///        public byte Version;
        ///        public byte TOS;
        ///        public ushort TotalSize;
        ///        [WireInfo(ArraySize=5)] public byte[] Other1;
        ///        public byte Type;
        ///        [WireInfo(ArraySize=10)] public byte[] Other2;
        ///    }
        ///
        ///    public class ProtocolHeader : WireData
        ///    {
        ///    }
        ///
        ///    public class UDPHeader : ProtocolHeader
        ///    {
        ///        public short SourcePort;
        ///        public short DestPort;
        ///        public short DataLen;
        ///        public short Checksum;
        ///        [WireInfo(ArraySize=0)] public byte[] Data;
        ///    }
        ///
        ///    public class TCPHeader : ProtocolHeader
        ///    {
        ///        public short SourcePort;
        ///        public short DestPort;
        ///        public uint SequenceNumber;
        ///        [WireInfo(ArraySize=12)] public byte[] Other2;
        ///        [WireInfo(ArraySize=0)] public byte[] Data;
        ///    }
        ///    </code>
        /// </example>
        public WireData ReadStream(Stream stream)
            // DO NOT MAKE THIS VIRTUAL! If you need to override it, override ReadStream(BinaryReader) instead - reljam
        {
            // Create the reader, uses UTF8 decoding by default
            return ReadStream(new BinaryReader(stream));
        }

        public virtual WireData ReadStream(BinaryReader binaryReader)
        {
            xonline.common.service.WireDataReadDelegate readDelegate = this.ReadDelegate;

            try
            {
                if (EncryptionRequired)
                    //WireDataDecrypt.Read(new xonline.common.service.WireData(), readDelegate, binaryReader);
                    throw new NotSupportedException("You can't decrypt WireData ibjects in test code.");
                else
                {
                    readDelegate(new xonline.common.service.WireData(), binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new xcs.XRLException(xcs.HResult.XONLINE_E_END_OF_STREAM, xcs.XEvent.Id.WIREDATA_END_OF_STREAM, 
                    "Failed to read enough bytes for type " + GetType().Name, e);
            }
            return this;
        }
        #endregion

        #region Writer
        /// <summary>
        /// ReadStream serializes this <c>WireData</c> class into a stream.
        /// </summary>
        /// <remarks>
        /// See <see cref="ServerTestFramework.WireData.ReadStream(Stream)"/> for more information and an example.
        /// </remarks>
        /// <param name="stream">The destination stream to serialize to.</param>
        public void WriteStream(Stream stream)
            // DO NOT MAKE THIS VIRTUAL! If you need to override it, override WriteStream(BinaryWriter) instead - reljam
        {
            // Create the writer, uses UTF8 encoding by default
            WriteStream(new BinaryWriter(stream));
        }

        public void WriteDelegate(xonline.common.service.WireData ignored, BinaryWriter binaryWriter)
        {
            SizeParamIndex index = (SizeParamIndex)sizeParamIndicies[GetType()];
            if (index == null)
                throw new Exception("This WireData type has not been initialized!  It should have been found in the sizeParamIndicies hashtable.");

            FieldCache fc = (FieldCache)fieldCache[GetType()];

            for (int i = 0; i < fc.Fields.Length; i++)
            {
                FieldInfo field = fc.Fields[i];
                WireInfoAttribute wireInfo              = fc.WireInfo[i];
                Utilities.FuzzDataAttribute fuzzInfo    = fc.FuzzInfo[i];

                if (!wireInfo.Serialize ||
                            this.SchemaVersion < wireInfo.MinSchemaVersionVal ||
                            this.SchemaVersion > wireInfo.MaxSchemaVersionVal)
                    continue;

                if (WireData.DumpDiagnosticInfo)
                    Console.WriteLine(field.DeclaringType.ToString() + "::" + field.Name);

                object o = field.GetValue(this);

                if (field.FieldType.IsArray || field.FieldType == typeof(string))
                {
                    long startPos = binaryWriter.BaseStream.Position;
                    int actualArraySize = 0;

                    if (o != null)
                    {
                        actualArraySize = field.FieldType.IsArray ? (o as Array).Length : (o as string).Length;

                        if (!ManualArraySize)
                        {
                            // The size of the array or string should not be greater than the ArraySize attribute
                            if (wireInfo.ArraySize != -1 && actualArraySize > wireInfo.ArraySize)
                                throw new Exception("Field \"" + field.Name + "\" contains too many items for it's ArraySize.");
                        }

                        // check for fuzzing, if we should be doing it, we are going to jump
                        if (WireData.Fuzz && fc.FuzzClass && fuzzInfo != null && fuzzInfo.Fuzz)
                        {
                            Utilities.FuzzArrayAttribute faa = fuzzInfo as Utilities.FuzzArrayAttribute;

                            if (faa == null)
                            {
                                throw new Utilities.FuzzDataAttributeException("Attempt to fuzz an array not using a " +
                                    "FuzzArrayAttribute.  This should not be possible, it indicates a bug in the " +
                                    "FuzzDataAttribute.BindType function, or a failure to call it.");
                            }

                            faa.FuzzWriteArray(binaryWriter, o, field,
                                (wireInfo.UnicodeEncoded ? (Encoding) unicodeEnc : (Encoding) utf8),
                                (wireInfo.NullTerminated && !NullTermOverRide), actualArraySize);

                            // at this point we should be done
                            continue;
                        }

                        if (field.FieldType.IsArray)
                        {
                            char[] oChar = o as char[];
                            byte[] oByte = o as byte[];

                            if( wireInfo.UnicodeEncoded &&
                                (actualArraySize > 0) &&
                                (oChar != null) )
                            {
                                byte[] bytes = new byte[ oChar.Length * 2 ];
                                unicodeEnc.GetBytes( oChar, 0, oChar.Length, bytes, 0 );
                                binaryWriter.Write( bytes );

                                if( (wireInfo.NullTerminated) && !NullTermOverRide )
                                {
                                    binaryWriter.Write( (ushort)0 );
                                }
                            }
                            else if (oByte != null)
                            {
                                binaryWriter.Write(oByte);
                            }
                            else
                            {
                                Array oArray = o as Array;

                                for (int j = 0; j < actualArraySize; j++)
                                {
                                    object val = oArray.GetValue(j);
                                    WriteValue(binaryWriter, val);
                                }
                            }
                        }
                        else // This is a string
                        {
                            string s = (string)o;

                            if( wireInfo.UnicodeEncoded )
                            {
                                binaryWriter.Write( unicodeEnc.GetBytes( s ) );
                            }
                            else
                            {
                                binaryWriter.Write( utf8.GetBytes( s ) );
                            }

                            if( (wireInfo.NullTerminated) && !NullTermOverRide )
                            {
                                if( wireInfo.UnicodeEncoded )
                                {
                                    binaryWriter.Write( (ushort)0 );
                                }
                                else
                                {
                                    binaryWriter.Write( (byte)0 );
                                }
                            }
                        }
                    }

                    if (!ManualArraySize)
                    {
                        // Pad the end of the array/string with 0's if nescessary
                        if (wireInfo.ArraySize != -1)
                        {
                            if (field.FieldType.IsArray)
                            {
                                if (field.FieldType.GetElementType().IsSubclassOf(typeof(WireData)))
                                {
                                    ConstructorInfo ci = field.FieldType.GetElementType().GetConstructor(Type.EmptyTypes);
                                    if (ci == null)
                                        throw new Exception("WireData(): for type " + GetType().Name + "::" + field.FieldType.GetElementType().Name + " -- If the number of elements in the array is less than the ArraySize, the class must have a default constructor to use for padding the end of the array with empty structures.");

                                    int size = (ci.Invoke(null) as WireData).Size() * (wireInfo.ArraySize - actualArraySize);

                                    for (int j = 0; j < size; j++)
                                        binaryWriter.Write((byte)0);
                                }
                                else
                                {
                                    for (int j = actualArraySize; j < wireInfo.ArraySize; j++)
                                        WriteValue(binaryWriter, 0, field.FieldType.GetElementType());
                                }
                            }
                            else
                            {
                                // this must be a string so ArraySize is in bytes
                                binaryWriter.Write(new byte[wireInfo.ArraySize - (binaryWriter.BaseStream.Position - startPos)]);
                            }
                        }
                    }
                }
                else
                {
                    if (index.reverse[i] != -1)
                    {
                        if (!ManualArraySize)
                        {
                            object oT = fc.Fields[index.reverse[i]].GetValue(this);
                            if (oT == null)
                                o = 0;
                            else
                            {
                                // Determining the size of an array is not as simple as string.Length
                                // we need to convert the string to UTF-8 and get the size of that
                                // it would be great if we could cache this....
                                if (oT is Array)
                                    o = ((Array)oT).Length;
                                else
                                {
                                    if( fc.WireInfo[index.reverse[i]].UnicodeEncoded )
                                    {
                                        if( (fc.WireInfo[index.reverse[i]].NullTerminated) && !NullTermOverRide )
                                            o = unicodeEnc.GetByteCount((string)oT) + 2;
                                        else
                                            o = unicodeEnc.GetByteCount((string)oT);
                                    }
                                    else
                                    {
                                        if( (fc.WireInfo[index.reverse[i]].NullTerminated) && !NullTermOverRide )
                                            o = utf8.GetByteCount((string)oT) + 1;
                                        else
                                            o = utf8.GetByteCount((string)oT);
                                    }
                                }
                            }
                        }
                    }
                    if (wireInfo.OnlySerializeIfNotEmpty && (int) o==0)
                        return;

                    // Check that we should be fuzzing at all
                    if (WireData.Fuzz && fc.FuzzClass && fuzzInfo != null && fuzzInfo.Fuzz)
                    {
                        fuzzInfo.FuzzWrite(binaryWriter, o);
                    }
                    else
                    {
                        WriteValue(binaryWriter, o, field.FieldType);
                    }
                }
            }
        }
        
        public virtual void WriteStream(BinaryWriter binaryWriter)
        {
            xcs.WireDataWriteDelegate writeDelegate = this.WriteDelegate;

            if (this.EncryptionRequired)
            {
                using (xcs.RsaPublicKey key = new xcs.RsaPublicKey(WireDataPublicKey.GetLatestKeyVersion(), WireDataPublicKey.GetLatestKey())) 
               {

                // note that we're passing a new xonline.common.service.WireData object that we don't use, in order to make the function signatures match
                WireDataEncrypt.Write(new xonline.common.service.WireData(), writeDelegate, binaryWriter, key);
               }
            }
            else
            {
                // note that we're passing a new xonline.common.service.WireData object that we don't use, in order to make the function signatures match
                WriteDelegate(new xonline.common.service.WireData(), binaryWriter);
            }
   
        }
        #endregion

        /// <summary>
        /// Returns the size of this WireData class as currently configured.
        /// </summary>
        /// <remarks>
        /// This is expensive because it requires actually serializing the structure and getting the length of the resulting data.
        /// </remarks>
        public virtual int Size()
        {
            MemoryStream stream = new MemoryStream();
            WriteStream(stream);
            return (int)stream.Length;
        }

        #region Read/Write Converters

        private object ReadValue(BinaryReader reader, Type type, object obj)
        {
            if (type == typeof(bool))
                return reader.ReadBoolean();
            else if (type == typeof(byte))
                return reader.ReadByte();
            else if (type == typeof(char))
                return reader.ReadChar();
            else if (type == typeof(decimal))
                return reader.ReadDecimal();
            else if (type == typeof(double))
                return reader.ReadDouble();
            else if (type == typeof(short))
                return reader.ReadInt16();
            else if (type == typeof(int))
                return reader.ReadInt32();
            else if (type == typeof(long))
                return reader.ReadInt64();
            else if (type == typeof(sbyte))
                return reader.ReadSByte();
            else if (type == typeof(float))
                return reader.ReadSingle();
            else if (type == typeof(ushort))
                return reader.ReadUInt16();
            else if (type == typeof(uint))
                return reader.ReadUInt32();
            else if (type == typeof(ulong))
                return reader.ReadUInt64();
            else if (type == typeof(DateTime))
                return DateTime.FromFileTimeUtc(reader.ReadInt64());
            else if (type == typeof(Guid))
                return new Guid(reader.ReadBytes(16));
            else if (type.IsSubclassOf(typeof(WireData)))
            {
                if (obj == null)
                {
                    obj = (type.GetConstructor(Type.EmptyTypes).Invoke(null));
                }

                WireData wd = (WireData)obj;
                wd.SchemaVersion = this.SchemaVersion;
                return wd.ReadStream(reader);
            }
            else
                throw new Exception("Type \"" + type.ToString() + "\" not supported.");
        }

        private void WriteValue (BinaryWriter writer, object o)
        {
            BinaryWriteValue(writer, o, null, this);
        }
        private void WriteValue (BinaryWriter writer, object o, Type type)
        {
            BinaryWriteValue(writer, o, type, this);
        }

        /// <summary>
        /// Writes an object to the writer using the correctly typed function.
        /// </summary>
        /// <param name="writer">The writer to write to.</param>
        /// <param name="o">The object to write.</param>
        public static void BinaryWriteValue (BinaryWriter writer, object o)
        {
            BinaryWriteValue(writer, o, null, null);
        }

        /// <summary>
        /// Writes an object to the writer using the correctly typed function.
        /// </summary>
        /// <param name="writer">The writer to write to.</param>
        /// <param name="o">The object to write.</param>
        /// <param name="type">The type to write the object as.</param>
        public static void BinaryWriteValue (BinaryWriter writer, object o, Type type)
        {
            BinaryWriteValue(writer, o, type, null);
        }

        /// <summary>
        /// Writes an object to the writer using the correctly typed function.
        /// </summary>
        /// <param name="writer">The writer to write to.</param>
        /// <param name="o">The object to write.</param>
        /// <param name="type">The type to write the object as.</param>
        /// <param name="wiredata">The WireDate to inherit schema version from.</param>
        private static void BinaryWriteValue (BinaryWriter writer, object o, Type type, WireData wiredata)
        {
            if (type == null)
                type = o.GetType();

            if (type == typeof(bool))
                writer.Write(Convert.ToBoolean(o));
            else if (type == typeof(byte))
                writer.Write(Convert.ToByte(o));
            else if (type == typeof(char))
                writer.Write(Convert.ToChar(o));
            else if (type == typeof(decimal))
                writer.Write(Convert.ToDecimal(o));
            else if (type == typeof(double))
                writer.Write(Convert.ToDouble(o));
            else if (type == typeof(short))
                writer.Write(Convert.ToInt16(o));
            else if (type == typeof(int))
                writer.Write(Convert.ToInt32(o));
            else if (type == typeof(long))
                writer.Write(Convert.ToInt64(o));
            else if (type == typeof(sbyte))
                writer.Write(Convert.ToSByte(o));
            else if (type == typeof(float))
                writer.Write(Convert.ToSingle(o));
            else if (type == typeof(ushort))
                writer.Write(Convert.ToUInt16(o));
            else if (type == typeof(uint))
                writer.Write(Convert.ToUInt32(o));
            else if (type == typeof(ulong))
                writer.Write(Convert.ToUInt64(o));
            else if (type == typeof(DateTime))
                writer.Write(Convert.ToDateTime(o).ToFileTimeUtc());
            else if (type == typeof(Guid))
            {
                Guid g = (Guid) o;
                writer.Write(g.ToByteArray());
            }
            else if (type == typeof(xonline.common.service.Puid))
            {
                xonline.common.service.Puid g = (xonline.common.service.Puid) o;
                writer.Write((ulong)g);
            }
            else if (type.IsSubclassOf(typeof(WireData)))
            {
                if (o != null)  // If the WireData is null then assume a 0 size and don't output anything
                {
                    WireData wd = (WireData)o;
                    if (wiredata != null)
                    {
                        wd.SchemaVersion = wiredata.SchemaVersion;
                    }
                    wd.WriteStream(writer);
                }
            }
            else
                throw new Exception("Type \"" + type.ToString() + "\" not supported.");
        }

        #endregion

        // check max/min range
        private void CheckRange(object o, WireInfoAttribute wireInfo, Type type, string name)
        {
            long val;

            if (!wireInfo.MaxSet && !wireInfo.MinSet)
            {
                return;
            }

            if (type == typeof(byte))
            {
                val = (long)((byte) o);
            }
            else {
                if(type == typeof(decimal))
                {
                    val = (long)((decimal) o);
                }
                else 
                {
                    if(type == typeof(double)) {
                        val = (long)((double) o);
                    }
                    else 
                    {
                        if(type == typeof(short))
                        {   
                            val = (long)((short) o);
                        }
                        else 
                        {
                             if(type == typeof(int))
                             {
                                val = (long)((int) o);
                             }
                             else {
                                  if(type == typeof(long))
                                  {
                                    val = (long)((long) o);
                                  }
                                  else 
                                  {
                                      if(type == typeof(sbyte)){
                                          val = (long)((sbyte) o);
                                      }
                                      else {
                                        if(type == typeof(float)) 
                                        {
                                             val = (long)((float) o);
                                        }
                                        else 
                                        {
                                            if(type == typeof(ushort))
                                            {   
                                                val = (long)((ushort) o);
                                            }
                                            else {
                                                if(type == (typeof(uint)))
                                                {
                                                   val = (long)((uint) o);
                                                }
                                                else
                                                {
                                                    if(type == typeof(ulong)) 
                                                    {
                                                        val = (long)((ulong)o);
                                                    }
                                                    else 
                                                    {
                                                        return;
                                                    }
                                                }
                                            }
                                        }
                                      }
                                  }                                                             
                             }
                        }
                    }
                }
            }
 

            if (wireInfo.MaxSet == true && val > wireInfo.Max)
            {
                throw new Exception("The value specified for field " + name + " (" + val + ") exceeds the Max allowed value (" + wireInfo.Max + ") !");
            }

            if (wireInfo.MinSet == true && val < wireInfo.Min)
            {
                throw new Exception("The value specified for field " + name + " (" + val + ") is less than the Min allowed value (" + wireInfo.Min + ") !");
            }
        }

        // Returns the field cache that containes information on all the fields and the
        // related / important attributes.
        public static Hashtable GetFieldCache ()
        {
            return fieldCache;
        }

        public class FieldCache
        {
            public FieldInfo[] Fields;
            public WireInfoAttribute[] WireInfo;
            public Utilities.FuzzDataAttribute[] FuzzInfo;
            public bool FuzzClass;

            public FieldCache(FieldInfo[] fields, bool bSortedByClass)
            {
                if (bSortedByClass)
                {
                    this.Fields = SortFields(fields);
                }
                else
                {
                    this.Fields = fields;
                }

                WireInfo = new WireInfoAttribute[this.Fields.Length];
                FuzzInfo = new Utilities.FuzzDataAttribute[this.Fields.Length];
                for (int i = 0; i < this.Fields.Length; i++)
                {
                    WireInfo[i] = GetWireInfo(this.Fields[i]);
                    FuzzInfo[i] = GetFuzzInfo(this.Fields[i]);
                }

                FuzzClass = false;
            }

            /// <summary>
            /// Adds the fields that have WireData.ForceSerialize set to true.
            /// </summary>
            /// <param name="fields">The fields to check.</param>
            /// <param name="bSortedByClass">True to sort the fields, false if not.</param>
            public void AddForcedFields (FieldInfo[] fields, bool bSortedByClass)
            {
                // we'll use this to short-circuit if no forced fields found
                bool parity_safety = true;

                LinkedList<FieldInfo> ll_fields =
                    new LinkedList<FieldInfo>(bSortedByClass ? SortFields(fields) : fields);

                LinkedList<WireInfoAttribute> ll_wire_info = new LinkedList<WireInfoAttribute>();

                foreach (FieldInfo node in ll_fields)
                {
                    ll_wire_info.AddLast(GetWireInfo(node));
                }

                LinkedListNode<FieldInfo> field_ptr = ll_fields.First;
                LinkedListNode<WireInfoAttribute> info_ptr = ll_wire_info.First;
                int i = 0;

                while (field_ptr != null)
                {
                    LinkedListNode<FieldInfo> ftemp = field_ptr;
                    LinkedListNode<WireInfoAttribute> itemp = info_ptr;
                    field_ptr = field_ptr.Next;
                    info_ptr = info_ptr.Next;

                    // this is a field picked up in the default way
                    if (i < Fields.Length && ftemp.Value == Fields[i])
                    {
                        ++i;
                    }
                    // if it is forced, we keep it, otherwise, remove it here
                    else if (!itemp.Value.ForceSerialize)
                    {
                        parity_safety = false;
                        ll_fields.Remove(ftemp);
                        ll_wire_info.Remove(itemp);
                    }
                }

                if (i != Fields.Length)
                {
                    throw new Exception("We should have gotten a superset of fields passed in, so how did we " +
                        "not see every field that we already had?");
                }

                if (parity_safety)
                {
                    return;
                }

                // now we have the final list, convert to arrays
                Fields = new FieldInfo[ll_fields.Count];
                ll_fields.CopyTo(Fields, 0);
                WireInfo = new WireInfoAttribute[Fields.Length];
                ll_wire_info.CopyTo(WireInfo, 0);
                FuzzInfo = new Utilities.FuzzDataAttribute[Fields.Length];

                for (int j = 0; j < Fields.Length; j++)
                {
                    FuzzInfo[j] = GetFuzzInfo(Fields[j]);
                }
            }

            private static WireInfoAttribute GetWireInfo(FieldInfo field)
            {
                int len = field.GetCustomAttributes(typeof(WireInfoAttribute), false).Length;
                Debug.Assert(len == 0 || len == 1);
                if (len == 1)
                    return (WireInfoAttribute)field.GetCustomAttributes(typeof(WireInfoAttribute), false)[0];
                else
                    return WireInfoAttribute.None;
            }

            private static Utilities.FuzzDataAttribute GetFuzzInfo(FieldInfo field)
            {
                int len = field.GetCustomAttributes(typeof(Utilities.FuzzDataAttribute), false).Length;
                Debug.Assert(len == 0 || len == 1);
                if (len == 1)
                {
                    Utilities.FuzzDataAttribute fda = (Utilities.FuzzDataAttribute)
                        field.GetCustomAttributes(typeof(Utilities.FuzzDataAttribute), false)[0];
                    // to provide the most specific fuzzing, we bind to the type of the field
                    fda.BindType(field.FieldType);
                    // Actual gives us the more specific version of the fuzzer
                    return fda.Actual;
                }
                else
                    return null;
            }

            // Sorts the field list by base member class.  This is only a problem when we include
            // fields from base classes as well, which is not a default behavior.  The fields for
            // a given class are sorted correctly, but the order of the classes is reversed.  That
            // is, the first fields are from the child class, followed by its parent, and so on.
            // We need to reverse this, as I would expect the deepest inherited members should be
            // the first ones serialized.
            private FieldInfo[] SortFields(FieldInfo[] fields)
            {
                if (fields == null || fields.Length == 0)
                    return fields;

                ArrayList list = new ArrayList(fields.Length);
                int insertIdx = 0;
                System.Type lastType = fields[fields.Length-1].DeclaringType;

                // Bump this to the end of the array every time we find a new class
                for (int i = fields.Length - 1; i >= 0; i--)
                {
                    System.Type thisType = fields[i].DeclaringType;
                    if (thisType != lastType)
                    {
                        lastType = thisType;
                        insertIdx = list.Count;
                    }
                    list.Insert(insertIdx, fields[i]);
                }

                return (FieldInfo[])list.ToArray(typeof(FieldInfo));
            }

            /// <summary>
            /// Determines the index of the field with the given name.
            /// </summary>
            /// <param name="fieldName">The name of the field to find.</param>
            /// <returns>The index of the field with the given name.</returns>
            /// <exception cref="ArgumentOutOfRangeException">
            /// Thrown if no field can be found whose name matches the value passed in fieldName.
            /// </exception>
            public uint GetFieldIndex (string fieldName)
            {
                for (int i = 0; i < Fields.Length; ++i)
                {
                    if (Fields[i].Name == fieldName)
                    {
                        return (uint) i;
                    }
                }

                throw new ArgumentOutOfRangeException("fieldName", fieldName,
                    "This type does not contain a FieldInfo entry with the given name.");
            }

            /// <summary>
            /// Creates a FuzzDataAttribute for the given index, unless one already exists.
            /// </summary>
            /// <param name="i">The index to create at.</param>
            public void CreateFuzzData (int i)
            {
                if (FuzzInfo[i] == null)
                {
                    FuzzInfo[i] = new ServerTestFramework.Utilities.FuzzDataAttribute(false);
                    FuzzInfo[i].BindType(Fields[i].FieldType);
                    FuzzInfo[i] = FuzzInfo[i].Actual;
                }
            }
        }
        
        
        private bool EncryptionRequired
        {
            get
            {
                object[] attributes = this.GetType().GetCustomAttributes(typeof(WireDataEncryptionAttribute), true);
                if ((attributes == null) || (attributes.Length == 0)) return false;

                WireDataEncryptionAttribute attribute = (WireDataEncryptionAttribute)attributes[0];
                return this.SchemaVersion >= WireDataEncryptionAttribute.StringToVersion(attribute.AsOfSchemaVersion);
            }
        }

        /// <summary>How much to indent nested object and array members when converting to a string.</summary>
        private const int ToStringIndentStep = 2;

        /// <summary>
        /// Provide a formatted ToString method so that we can get good debug output in exceptions/events/logs
        /// this method uses reflection, and will be SLOW! Only use in exceptional cases, not in high performance codepaths.
        /// </summary>
        public virtual void ToString (StringBuilder str, int indent)
        {
            Type type = GetType();
            FieldCache index = (FieldCache)fieldCache[type];
            int newIndent = indent + ToStringIndentStep;
            int arrayIndent = newIndent + ToStringIndentStep;

            // ignore indent because it is either 0 or we are appending to a field string
            str.Append(type.Name);
            str.AppendLine(" {");

            for (int i = 0; i < index.Fields.Length; i++)
            {
                WireInfoAttribute wireinfo = index.WireInfo[i];

                // don't print things that aren't serialized
                if (!wireinfo.Serialize)
                {
                    continue;
                }

                FieldInfo field = index.Fields[i];
                object o = field.GetValue(this);

                // start with the field name
                str.Append(' ', newIndent);
                str.Append(field.Name);
                str.Append('=');
                
                if (o == null)
                {
                    str.AppendLine("null");
                }
                else if ((field.FieldType.IsArray) && (field.FieldType != typeof(string)) && (field.FieldType != typeof(byte[])))
                {
                    Array oArray = o as Array;
                    int actualArraySize = oArray.Length;

                    str.Append(field.FieldType.GetElementType().Name);
                    str.Append('[');
                    str.Append(actualArraySize);
                    str.AppendLine("] {");

                    for (int j = 0; j < actualArraySize; j++)
                    {
                        object val = oArray.GetValue(j);

                        str.Append(' ', arrayIndent);
                        str.Append('[');
                        str.Append(j);
                        str.Append("]=");

                        // Check for array of complex type
                        WireData valWireData = val as WireData;
                        if (valWireData != null)
                        {
                            valWireData.ToString(str, arrayIndent);
                            str.AppendLine();
                        }
                        else
                        {
                            str.AppendLine(val.ToString());
                        }
                    }
                }
                else
                {
                    // Check for complex type
                    WireData oWireData = o as WireData;
                    if (oWireData != null)
                    {
                        oWireData.ToString(str, newIndent);
                        str.AppendLine();
                    }
                    else
                    {
                        byte[] oByteArray = o as byte[];
                        if (oByteArray != null)
                        {
                            str.AppendLine(ServerTestFramework.Utilities.Hexer.tohex(oByteArray));
                        }
                        else
                        {
                            str.AppendLine(o.ToString());
                        }
                    }
                }
            }

            str.Append(' ', indent);
            str.Append('}');
        }

        public override string ToString ()
        {
            return ToString(0);
        }

        public virtual string ToString (int indent)
        {
            StringBuilder sb = new StringBuilder();
            ToString(sb, indent);
            return sb.ToString();
        }

    }

    /// <summary>
    /// Attribute placed on fields of a class derived from WireData to add context to the field in order to serialze it
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class WireInfoAttribute : Attribute
    {
        /// <summary>
        /// Used to specify a constant size for an array.
        /// </summary>
        public int ArraySize = -1;

        /// <summary>
        /// Used to specify which other field in a <c>WireData</c> class specifies the size of the array or string this attribute is put on.
        /// </summary>
        public string SizeParam = null;

        /// <summary>
        /// Include the Null in a varible length string and add 1 to it's length variable (if there is one)
        /// </summary>
        public bool NullTerminated = false;

        /// <summary>
        /// Whether the string represents a Hex number
        /// </summary>
        public bool HexString = false;

        /// <summary>
        /// Use unicode Encoding instead of the default (UTF8)
        /// </summary>
        public bool UnicodeEncoded = false;

        public long Max
        {
            get { return _max; }
            set { MaxSet = true; _max = value; }
        }

        public long Min
        {
            get { return _min; }
            set { MinSet = true; _min = value; }
        }

        public bool WriteOnlyVarLenString = false;
        public bool Serialize=true;
        public bool OnlySerializeIfNotEmpty=false;
        private long _min = 0;
        private long _max = 0;
        public bool MaxSet = false;
        public bool MinSet = false;

        /// <summary>If true, forces this field to be picked up for serialization.</summary>
        public bool ForceSerialize = false;

        public String MinSchemaVersion
        {
            get { return VersionToString(MinSchemaVersionVal); }
            set { MinSchemaVersionVal = StringToVersion(value); }
        }

        public String MaxSchemaVersion
        {
            get { return VersionToString(MaxSchemaVersionVal); }
            set { MaxSchemaVersionVal = StringToVersion(value); }
        }

        public uint MinSchemaVersionVal = 0;
        public uint MaxSchemaVersionVal = UInt32.MaxValue;

        public static uint StringToVersion(String versionStr)
        {
            String[] split = versionStr.Split('.');
            if (split.Length != 2)
                throw new ArgumentException();

            return UInt32.Parse(split[0]) << 16 | UInt32.Parse(split[1]);
        }

        public static String VersionToString(uint version)
        {
            return String.Format("{0}.{1}", (version & 0xFFFF0000) >> 16, version & 0xFFFF);
        }

        /// <summary>
        /// An static instance of <c>WireInfoAttribute</c> with all values set to defaults.
        /// </summary>
        public static WireInfoAttribute None = new WireInfoAttribute();
    }

    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false)]
    public class WireDataInfoAttribute : Attribute
    {
        public bool Serialize=true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Achievement\XRLEnumAchievement.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using ServerTestFramework;
using System.Net;
using xonline.common.config;
using ServerTestFramework.LiveService.UserSettings;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Achievement
{
	public class XRLEnumAchievement : XRLPayload
	{
		[XRLPayloadFld(IsTitleId=true)]
		public uint  TitleId = 0;
		[XRLPayloadFld(IsUPuid=true)]
		public ulong Puid    = 0;
		public ulong ForPuid = 0;
		public ushort LocaleId = 0;
		public ushort StartingIndex = 0;
		public ushort MaxAchievements = 32;

		[WireInfo(Serialize=false)]
		public AuthModify Modifyflag = AuthModify.None;

		[WireInfo(Serialize=false)]
		public uint LanguageID = 0;
		[WireInfo(Serialize=false)]
		public uint CountryID = 0;

		public override void ManualPopulateSlot()
		{
			PopulateSlot(ref Slot);

			if(Modifyflag == AuthModify.Change_Title)
			{
				Slot.titleId+=10;
			}
			else if(Modifyflag == AuthModify.Change_Title_PUB)
			{
				Slot.titleId =Slot.titleId + 0xFFF00000;
			}
			else if (Modifyflag == AuthModify.Change_User)
			{
				Slot.userPuid0+=10;
				Slot.userPuid1+=10;
				Slot.userPuid2+=10;
				Slot.userPuid3+=10;

			}
			else if (Modifyflag == AuthModify.Read_Activity_FriendOnly)
			{
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
				Slot.SetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
			}
			else if (Modifyflag == AuthModify.Read_Activity_None)
			{
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
			}

            Slot.SetRegionInfo(CountryID, LanguageID);
			
			ManualSlotSetup=true;
		}

		
		public XRLEnumAchievement(uint title,ulong user,ulong friend,ushort locale,ushort start,ushort count)
		{
			TitleId = title;
			Puid    = user;
			ForPuid = friend;
			LocaleId = locale;
			StartingIndex = start;
			MaxAchievements = count;
		}

		protected override string GetServiceName()
		{
			return "/xstats/xachievementenum.ashx";
		}

		new public AchievementEnumResponse Execute()
		{
			AchievementEnumResponse readResp = null;
			// Prepare request 
			MemoryStream reqStream = new MemoryStream( 512 );
			this.WriteStream(reqStream);
				
			if(Modifyflag != AuthModify.None || LanguageID !=0)
				ManualPopulateSlot();

			bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd),reqStream);
			// create a streem here and then read all data;
			if( xAct.httpStatus == HttpStatusCode.OK) 
			{	
				readResp = (AchievementEnumResponse)new AchievementEnumResponse().ReadBytes(xAct.ResponseContents);

			}
			else
			{
				readResp = (AchievementEnumResponse)new AchievementEnumResponse();
				readResp.xResult=xAct.XErr;
			}
			
			return readResp;
				
		}
	}

	public class AchievementEnumResponse : WireData
	{
		public ushort AchievementsLen = 0;
		public AchievementWD[] Achievements = null;
		[WireInfo(Serialize=false)]
		public uint xResult =0;
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Achievement\XRLSyncAvatarAsset.cs ===
using System;
using System.Collections;
using System.IO;
using System.Runtime.InteropServices;
using ServerTestFramework;
using System.Net;
using xonline.common.config;
using xonline.common.service;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.AvatarAsset;

namespace ServerTestFramework.LiveService.AvatarAsset
{
    public class avatarassetflags
    {
        public static uint XAVATAR_DETAILS_MASK_TYPE = 0x00000007;
        public static uint XAVATAR_DETAILS_STATUS_MASK = 0x000F0000;
        public static uint XAVATAR_DETAILS_SHOWUNACHIEVED = 0x00000008;
        public static uint XAVATAR_DETAILS_ACHIEVED_ONLINE = 0x00010000;
        public static uint XAVATAR_DETAILS_ACHIEVED = 0x00020000;
        public static uint XAVATAR_DETAILS_NOT_ACHIEVABLE = 0x00040000;
        public static uint XAVATAR_DETAILS_WAS_NOT_ACHIEVABLE = 0x00080000;

        public const int XAVATAR_DETAILS_PLATFORM_MASK = 0x00700000;
        public const int XAVATAR_DETAILS_PLATFORM_SHIFT = 20;

        // From Common.Protocol
        public static int SetPlatformTypeInFlags(int existingFlags, int platformType)
        {
            int newFlags = existingFlags & ~XAVATAR_DETAILS_PLATFORM_MASK;

            int avatarFlag = MapPlatformTypeFlags(platformType);

            newFlags |= avatarFlag & XAVATAR_DETAILS_PLATFORM_MASK;

            return (newFlags);
        }
        // Function added to map the XPL_* platform flags to the XAVATAR_DETAILS_* flags
        // which was needed when we added Windows Mobile and WebGames Platforms that can now earn avatar awards
        public static int MapPlatformTypeFlags(int platformType)
        {
            uint avatarFlag = 0;

            switch (platformType)
            {
                case xonline.common.service.XOn.XPLT_XBOX360:
                    avatarFlag = xonline.common.service.XOn.XAVATAR_DETAILS_PLATFORM_360;
                    break;
                case xonline.common.service.XOn.XPLT_PC:
                    avatarFlag = xonline.common.service.XOn.XAVATAR_DETAILS_PLATFORM_PC;
                    break;
                case xonline.common.service.XOn.XPLT_MOBILE:
                    avatarFlag = xonline.common.service.XOn.XAVATAR_DETAILS_PLATFORM_MOBILE;
                    break;
                case xonline.common.service.XOn.XPLT_WEB_GAMES:
                    avatarFlag = xonline.common.service.XOn.XAVATAR_DETAILS_PLATFORM_WEB_GAMES;
                    break;
                default:
                    break;
            }
            return (int)avatarFlag;
        }
    }

    public class AvatarAssetConst
    {
        public static DateTime MinDateTime = new DateTime(2002, 11, 15);
        public static ushort MAX_AvatarAssets = 32;  //XONLINE_MAX_AVATAR_ASSETS
    }

    public class AvatarAssetWD : WireData, IComparable
    {
        public uint AvatarAssetOrdinal = 0;
        public DateTime Awarded = AvatarAssetConst.MinDateTime;
        public uint Sequence = 0;
        public int Flags = 0;

        // guid assigned to asset by XLAST
        [WireInfo(ArraySize = 16)]
        public byte[] AvatarAssetId;

        public uint ImageId = 0;

        public byte TitleLen = 0;
        public string Title = "";

        public byte DescriptionLen = 0;
        public string Description = "";

        public byte HowToLen = 0;
        public string HowTo = "";

        public byte BodyTypeMask = 0;
        public uint BodyComponent = 0;
        public uint SubCategory = 0;


        //these items are not part of the actual WireData, and are here solely to aid with testing.
        [WireInfo(Serialize = false)]
        public DateTime Dt_updated = DateTime.UtcNow;

        //max and min sync time represent a window.  All offline achievements earned are known to
        //occur in this window between two points of being online.  This represents the last time
        //you were online, and the time before that.
        [WireInfo(Serialize = false)]
        public DateTime minSyncTime = DateTime.FromFileTime(0);  //The last time a sync occurred.  This
        //is to remain the win32 min time, as it is unused at
        //the moment.

        [WireInfo(Serialize = false)]
        public DateTime maxSyncTime = DateTime.FromFileTime(0);  //The most recent time a sync occurred.


        public AvatarAssetWD()
        {
        }

        public int CompareTo(object obj)
        {
            //The order should be:
            //max_time, min_time, sequence number

            int retval = ((AvatarAssetWD)obj).maxSyncTime.ToFileTimeUtc().CompareTo(maxSyncTime.ToFileTimeUtc());
            if (retval == 0)
            {  //if that's the same, try the min time.
                retval = ((AvatarAssetWD)obj).minSyncTime.ToFileTimeUtc().CompareTo(minSyncTime.ToFileTimeUtc());
                if (retval == 0)
                { //if *that's* the same, try using the SortIndex(aka sequence number)
                    retval = ((AvatarAssetWD)obj).Sequence.CompareTo(Sequence);
                }
            }
            return retval;
        }
        //Always creates Online 360 Assets
        //This is what GPSTress is using
        public AvatarAssetWD(uint AvatarAssetOrdinal, byte avatarAssetBodyTypeMask, uint sortidx)
        {
            this.AvatarAssetOrdinal = AvatarAssetOrdinal;
            this.BodyTypeMask = avatarAssetBodyTypeMask;
            this.Sequence = sortidx;

            // Assume Avatar Asset from a 360 Platform if not specified, as well as Earned Online
            // The server code will override this with the SGInfo Client anyway, but we will still set this
            // to be used when comparing the server flags sent back with what we sent up.
            this.Flags = avatarassetflags.SetPlatformTypeInFlags((int)(avatarassetflags.XAVATAR_DETAILS_ACHIEVED | avatarassetflags.XAVATAR_DETAILS_ACHIEVED_ONLINE), xonline.common.service.XOn.XPLT_XBOX360);
        }

        // Always creates Online Assets and Platform can be specified
        public AvatarAssetWD(uint AvatarAssetOrdinal, byte avatarAssetBodyTypeMask, uint sortidx, int flags)
        {
            this.AvatarAssetOrdinal = AvatarAssetOrdinal;
            this.BodyTypeMask = avatarAssetBodyTypeMask;
            this.Sequence = sortidx;

            this.Flags = flags | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED_ONLINE;

            // The server code will override this with the SGInfo Client anyway, but we will still set this
            // to be used when comparing the server flags sent back with what we sent up.
            // Check if Platform is Set, if not, default to XBOX 360
            //if ((this.Flags & (avatarassetflags.XAVATAR_DETAILS_PLATFORM_MASK << avatarassetflags.XAVATAR_DETAILS_PLATFORM_SHIFT)) == 0x0)
            if ((this.Flags & avatarassetflags.XAVATAR_DETAILS_PLATFORM_MASK) == 0x0)
            {
                // No Platform flag, so set to 360 as Default
                this.Flags = avatarassetflags.SetPlatformTypeInFlags(this.Flags, xonline.common.service.XOn.XPLT_XBOX360);
            }
        }
        // Allows Online/Offline and Platform can be specified
        public AvatarAssetWD(uint AvatarAssetOrdinal, byte avatarAssetBodyTypeMask, uint sortidx, int flags, bool earnedOnline)
        {
            this.AvatarAssetOrdinal = AvatarAssetOrdinal;
            this.BodyTypeMask = avatarAssetBodyTypeMask;
            this.Sequence = sortidx;

            if (earnedOnline)
            {
                this.Flags = flags | (int)avatarassetflags.XAVATAR_DETAILS_ACHIEVED_ONLINE;
            }
            else
            {
                this.Flags = flags;
            }

            // The server code will override this with the SGInfo Client anyway, but we will still set this
            // to be used when comparing the server flags sent back with what we sent up.
            // Check if Platform is Set, if not, default to XBOX 360
            if ((this.Flags & avatarassetflags.XAVATAR_DETAILS_PLATFORM_MASK) == 0x0)
            {
                // No Platform flag, so set to 360 as Default
                this.Flags = avatarassetflags.SetPlatformTypeInFlags(this.Flags, xonline.common.service.XOn.XPLT_XBOX360);
            }
        }
        public override bool Equals(object obj)
        {
            bool retval = false;
            if (AvatarAssetOrdinal == ((AvatarAssetWD)obj).AvatarAssetOrdinal)
                retval = true;

            return retval;
        }

        public override int GetHashCode()
        {
            return (int)(AvatarAssetOrdinal);
        }

        //Record the time this avatar asset was synced.  For now, this will only affect the maxTime.
        public void RecordSyncTime(DateTime synced)
        {
            this.maxSyncTime = synced;
        }

    }


    public class AvatarAssetEnumComparer : IComparer
    {
        //this only works on AvatarAssetsEnums.  Note that the legacy code has the two arguments flipped.
        public int Compare(object x, object y)
        {
            return ((AvatarAssetWD)x).CompareTo((AvatarAssetWD)y);

        }
    }

    /// <summary>
    /// Summary description for XRLSyncAvatarAssets.
    /// </summary>
    public class XRLSyncAvatarAssets : XRLPayload
    {
        [XRLPayloadFld(IsTitleId = true)]
        public uint TitleId = 0;
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserId = 0;
        public DateTime Version = DateTime.UtcNow;
        public ushort LocaleId = 1033;
        public ushort StartingIndex = 0;
        public ushort AvatarAssetCount = 0;
        [WireInfo(SizeParam = "AvatarAssetCount")]
        public AvatarAssetWD[] AvatarAssets = null;

        [WireInfo(Serialize = false)]
        public AuthModify Modifyflag = AuthModify.None;
        [WireInfo(Serialize = false)]
        public uint LanguageID = 0;

        public override void ManualPopulateSlot()
        {
            PopulateSlot(ref Slot);

            if (Modifyflag == AuthModify.Change_Title)
            {
                Slot.titleId += 10;
            }
            else if (Modifyflag == AuthModify.Change_User)
            {
                Slot.userPuid0 += 10;
                Slot.userPuid1 += 10;
                Slot.userPuid2 += 10;
                Slot.userPuid3 += 10;

            }

            Slot.SetRegionInfo(0, LanguageID);

            ManualSlotSetup = true;
        }


        public XRLSyncAvatarAssets()
        {
            // Set Xbox 360 as the default machine type the AvatarAssets are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }
        public XRLSyncAvatarAssets(uint title, ulong user, AvatarAssetWD[] aalist)
        {
            TitleId = title;
            UserId = user;
            AvatarAssets = aalist;
            // Set Xbox 360 as the default machine type the AvatarAssets are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }
        // Allows for the client type to be specified (PC, Xbox, Xbox 360)
        public XRLSyncAvatarAssets(uint title, ulong user, AvatarAssetWD[] aalist, CSGInfo.ClientType _clientType)
        {
            TitleId = title;
            UserId = user;
            AvatarAssets = aalist;
            // Set the client type for the XRLSync request
            SetMachineClientType(_clientType);
        }
        public XRLSyncAvatarAssets(uint title, ulong user, AvatarAssetWD[] aalist, DateTime _Version, ushort _StartingIndex, ushort _LocaleId)
        {
            TitleId = title;
            UserId = user;
            AvatarAssets = aalist;
            Version = _Version;
            StartingIndex = _StartingIndex;
            LocaleId = _LocaleId;
            // Set Xbox 360 as the default machine type the AvatarAssets are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }
        public XRLSyncAvatarAssets(uint title, ulong user, AvatarAssetWD[] aalist, DateTime _Version)
        {
            TitleId = title;
            UserId = user;
            AvatarAssets = aalist;
            Version = _Version;
            // Set Xbox 360 as the default machine type the AvatarAssets are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }

        public XRLSyncAvatarAssets(uint title, ulong user, AvatarAssetWD[] aalist, DateTime _Version, ushort _StartingIndex)
        {
            TitleId = title;
            UserId = user;
            AvatarAssets = aalist;
            Version = _Version;
            StartingIndex = _StartingIndex;
            // Set Xbox 360 as the default machine type the AvatarAssets are written from
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }


        public void SetMachineClientType(CSGInfo.ClientType clientType)
        {
            Slot.ChangeClientType(clientType);
        }


        protected override string GetServiceName()
        {
            return "/xstats/syncavatarassets.ashx";
        }

        new public SyncAvatarAssetsResponse Execute()
        {
            //For test purposes only, we will note in the AvatarAssetWD the current time for sync purposes.
            foreach (AvatarAssetWD aawd in AvatarAssets)
            {
                aawd.RecordSyncTime(DateTime.UtcNow);
            }

            // Prepare request 
            MemoryStream reqStream = new MemoryStream(512);
            this.WriteStream(reqStream);

            if (Modifyflag != AuthModify.None || LanguageID != 0)
                ManualPopulateSlot();

            bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd), reqStream);
            // create a streem here and then read all data;
            SyncAvatarAssetsResponse readResp = (SyncAvatarAssetsResponse)new SyncAvatarAssetsResponse().ReadBytes(XErr, xAct.ResponseContents);
            return readResp;

        }

        // Added for testing WinMo/WebGames platforms which use the OnBehalfOf headers
        public SyncAvatarAssetsResponse ExecuteInt(int iPlatform, int iOnBehalfOf)
        {
            SyncAvatarAssetsResponse resp = null;
 
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            // HTTPAUTH
            IPEndPoint endpoint = Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd_int);
            ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
            byte[] addr = endpoint.Address.GetAddressBytes();
            uint ip = 0;
            for (int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];

            HTTPAuthData authData = new HTTPAuthData((ushort)endpoint.Port, ip, requestId, UserId, TitleId, (uint)XOService.Progress, 0);
            CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" + authData.GetBase64EncodedString() + "\r\n";

            // Pass in the XPLT platform and OnBehalfOf
            CustomHeader += "XPLT:" + iPlatform + "\r\n";
            CustomHeader += "XPLTOnBehalfOf:" + iOnBehalfOf + "\r\n";

            bool bRet = InternalExecute(endpoint, reqStream);

            if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
            {
                if (xAct.ResponseContents.Length > 0)
                    resp = (SyncAvatarAssetsResponse)new SyncAvatarAssetsResponse().ReadBytes(xAct.ResponseContents);
            }
            else
            {
                resp = (SyncAvatarAssetsResponse)new SyncAvatarAssetsResponse();
                resp.xResult = xAct.XErr;
            }

            return resp;
        }
    }

    public class SyncAvatarAssetsResponse : WireData
    {
        public DateTime Version = DateTime.MinValue;
        public uint MoreAvatarAssetPending = 0;
        //add in the MAX
        public ushort AvatarAssetsCount = 0;
        [WireInfo(SizeParam = "AvatarAssetsCount")]
        public AvatarAssetWD[] AvatarAssets = null;
        [WireInfo(Serialize = false)]
        public uint xResult = 0;


        public SyncAvatarAssetsResponse ReadBytes(uint XErr, byte[] Respdata)
        {
            xResult = XErr;
            if (HResult.Succeeded(XErr))
            {
                base.ReadBytes(Respdata);
            }
            return this;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\WebRequest.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Reflection;
using System.Text;

using xonline.common.service;

using StringPair = System.Collections.Generic.KeyValuePair<string, string>;

namespace ServerTestFramework.LiveService
{
    public static class HttpMethod
    {
        public readonly static string Get = "GET";
        public readonly static string Post = "POST";

        public static String FromWebRequestType(WebRequestType type)
        {
            switch (type)
            {
                case WebRequestType.Get:
                    return HttpMethod.Get;
                case WebRequestType.Post:
                case WebRequestType.Soap1_1:
                case WebRequestType.Soap1_2:
                    return HttpMethod.Post;
                default:
                    throw new InvalidOperationException("Invalid WebRequestType: " + type);
            }
        }
    }

    public enum WebRequestType
    {
        Get,
        Post,
        Soap1_1,
        Soap1_2,
    }

    public enum WebRequestParamType
    {
        StandAlone,
        NameValuePair
    }

    public enum Requirement
    {
        Required,
        Optional
    }

    public class WebRequestParamAttribute : Attribute
    {
        public string WireName;
        public WebRequestParamType ParamType;
        public Requirement Requirement;
        public string DefaultValue;

        public WebRequestParamAttribute(string wireName, WebRequestParamType paramType)
        {
            WireName = wireName;
            ParamType = paramType;
            Requirement = Requirement.Required;
            DefaultValue = null;
        }

        public WebRequestParamAttribute(string wireName, WebRequestParamType paramType,
            Requirement requirement)
        {
            WireName = wireName;
            ParamType = paramType;
            Requirement = requirement;
            DefaultValue = null;
        }

        public WebRequestParamAttribute(string wireName, WebRequestParamType paramType,
            Requirement requirement, string defaultValue)
        {
            WireName = wireName;
            ParamType = paramType;
            Requirement = requirement;
            DefaultValue = defaultValue;
        }
    }

    public abstract class HttpRequestObject : XRLObject2
    {
        public abstract string GetHttpMethod();
        public abstract string GetRelativeUrl();
    }

    public abstract class WebRequestBase : HttpRequestObject
    {
        // We break a URL such as "http://ipaddr:port/xbos/billing.asmx/PurchaseHistory?..." into:
        // _basePath = "xbos/billing.asmx"    (required)
        // _operation = "PurchaseOffers"        (required)
        protected readonly string _basePath;
        protected readonly string _operation;

        private WebRequestType requestType = WebRequestType.Post;
        public WebRequestType RequestType
        {
            get { return requestType; }
            set { requestType = value; }
        }

        private bool useSSL = false;
        public bool UseSSL
        {
            get { return useSSL; }
            set { useSSL = value; }
        }

        private WebHeaderCollection headers;
        public WebHeaderCollection Headers
        {
            get { return headers; }
            set { headers = value; }
        }

        private uint xerr = HResult.S_OK;
        public uint XErr
        {
            get { return xerr; }
        }

        protected WebRequestBase(string basePath, string operation)
        {
            _basePath = RemoveLeadingTrailingSlashes(basePath);
            _operation = RemoveLeadingTrailingSlashes(operation);
        }

        public override string GetRelativeUrl()
        {
            string relativeUrl = "/" + _basePath + "/" + _operation;
            if (RequestType == WebRequestType.Get)
            {
                relativeUrl += ToQueryString();
            }
            return relativeUrl;
        }

        public override string GetHttpMethod()
        {
            return HttpMethod.FromWebRequestType(RequestType);
        }

        public void SetWebHeaders(WebHeaderCollection headers)
        {
            switch (RequestType)
            {
                case WebRequestType.Get:
                    break;
                case WebRequestType.Post:
                    headers.Add("Content-Type", "application/x-www-form-urlencoded");
                    break;
                case WebRequestType.Soap1_1:
                    headers.Add("Content-Type", "text/xml; charset=utf-8");
                    break;
                case WebRequestType.Soap1_2:
                    headers.Add("Content-Type", "application/soap+xml; charset=utf-8");
                    break;
                default: throw new InvalidOperationException("Unknown ContentType: " + RequestType);
            }
        }

        public override void WriteStream(System.IO.BinaryWriter binaryWriter)
        {
            switch (RequestType)
            {
                case WebRequestType.Get:
                    break;
                case WebRequestType.Post:
                    binaryWriter.Write(Encoding.UTF8.GetBytes(ToPostBody()));
                    break;
                default:
                    throw new Exception("WriteStream doesn't support FilterRequestType: " + RequestType);
            }
        }

        protected virtual string BuildHttpRequest(string seperator)
        {
            StringBuilder request = new StringBuilder();
            List<StringPair> list = WebRequestBase.WebRequestToList(this);

            foreach (StringPair pair in list)
            {
                request.AppendFormat("{0}={1}{2}", pair.Key, pair.Value, seperator);
            }

            String req = request.ToString();

            if (req.EndsWith(seperator))
            {
                req = req.Remove(req.Length - 1);
            }
            return req;
        }

        public virtual string ToQueryString()
        {
            return "?" + BuildHttpRequest("&");
        }

        public virtual string ToPostBody()
        {
            return BuildHttpRequest("&");
        }
        
        /// <summary>
        /// Override this method in any subclasses to provied a way to send the request
        /// </summary>
        /// <returns>True if the request is sucessful, false otherwise</returns>
        public virtual bool SendRequest()
        {
            throw new Exception("SendRequest() is not defined for " + GetType().ToString());
        }

        /// <summary>
        /// Sends this web request object to the provided address
        /// </summary>
        /// <param name="endPoint">The address to send the request</param>
        /// <returns>True if the request is sucessful, false otherwise</returns>
        public virtual bool SendRequest(IPEndPoint endPoint)
        {
            WebClient client = new WebClient();
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            byte[] respData;

            this.WriteStream(writer);
            writer.Flush();

            // Build the url
            String url = String.Empty;
            if (this.UseSSL)
            {
                url = "https://" + endPoint.Address.ToString() + ":" + endPoint.Port.ToString() + GetRelativeUrl();
            }
            else
            {
                url = "http://" + endPoint.Address.ToString() + ":" + endPoint.Port.ToString() + GetRelativeUrl();
            }

            // Setup all the headers as required
            if (headers == null)
            {
                headers = new WebHeaderCollection();
            }
            if (headers["Content-Type"] == null)
            {
                SetWebHeaders(headers);
            }

            client.Headers.Add(headers);

            // Perform the request
            try
            {
                // Send the data
                respData = client.UploadData(url, GetHttpMethod(), stream.GetBuffer());
                // Check the response
                String xErrHeader = client.ResponseHeaders["X-Err"];
                if (xErrHeader != null)
                {
                    xerr = uint.Parse(xErrHeader);
                }

                if (HResult.Succeeded(xerr))
                {
                    ReadResponse(respData);
                }
            }
            catch (WebException e)
            {
                Global.RO.Fatal(e.ToString());
                return false;
            }
            return HResult.Succeeded(xerr);
        }

        /// <summary>
        /// Override this method in any subclasses to read the response data as you need
        /// </summary>
        /// <param name="responseData">The data from the response</param>
        public virtual void ReadResponse(byte[] responseData)
        {
            throw new Exception("The server returned " + responseData.Length + " bytes, but you are ignoring them. Make sure you override ReadResponse");
        }

        private static string RemoveLeadingTrailingSlashes(string source)
        {
            return source.Trim('/');
        }

        private static void WriteNameAndValue(List<StringPair> filterList, FieldInfo fieldInfo, WebRequestParamAttribute reqParam, string name, object fieldValue)
        {
            string value;
            if (fieldInfo.FieldType.IsEnum)
            {
                value = Enum.Format(fieldInfo.FieldType, Enum.Parse(
                    fieldInfo.FieldType, fieldValue.ToString()), "d");
            }
            else
            {
                value = String.Format("{0}", fieldValue);
            }

            // Stand-alone pairs are written out like: "ClientType=Zune"
            if (reqParam.ParamType == WebRequestParamType.StandAlone)
            {
                filterList.Add(new StringPair(name, value));
            }
            // NameValue pairs are written out like: "Names=Locale&Values=en-US"
            else if (reqParam.ParamType == WebRequestParamType.NameValuePair)
            {
                // If it's optional and set to the default value, don't bother writing it out
                if (reqParam.Requirement == Requirement.Optional)
                {
                    if (value == reqParam.DefaultValue)
                    {
                        return;
                    }
                }
                filterList.Add(new StringPair("Names", name));
                filterList.Add(new StringPair("Values", value));
            }
            else
            {
                throw new Exception("Unknown WebRequestParamType: " + reqParam.ParamType);
            }
        }

        /// <summary>
        /// Takes an object and extracts any WebRequest parameters fields that it contains
        /// and returns a list of the names and values of the parameters.  This function will
        /// actually work on any object that has fields with the WebRequestParam attribute
        /// and not just on a WebRequestBase object.
        /// </summary>
        /// <param name="webRequest">The object to extract parameter names and values from</param>
        /// <returns>A list of Name-Value pairs of the parameters extracted from the object</returns>
        public static List<StringPair> WebRequestToList(object webRequest)
        {
            List<StringPair> filterList = new List<StringPair>();

            Type thisType = webRequest.GetType();
            FieldInfo[] fieldInfos = thisType.GetFields(
                BindingFlags.Instance |
                BindingFlags.Public
                );

            foreach (FieldInfo fieldInfo in fieldInfos)
            {
                object[] fieldAttrs = fieldInfo.GetCustomAttributes(typeof(WebRequestParamAttribute), true);
                if (fieldAttrs.Length == 0)
                {
                    // Ignore any field not marked with a WebRequestParam attribute
                    continue;
                }
                WebRequestParamAttribute reqParam = (WebRequestParamAttribute)fieldAttrs[0];
                string name = reqParam.WireName;
                object fieldValue = fieldInfo.GetValue(webRequest);

                if (fieldValue != null)
                {
                    // Crack open Lists and Arrays and write out their contents
                    Array array = null;
                    if (fieldInfo.FieldType.IsGenericType)
                    {
                        System.Reflection.MethodInfo toArrayMeth = fieldInfo.FieldType.GetMethod("ToArray");
                        array = (Array)toArrayMeth.Invoke(fieldValue, null);
                    }
                    if (fieldInfo.FieldType.IsArray)
                    {
                        array = (Array)fieldValue;
                    }
                    if (array != null)
                    {
                        // Empty Lists/Arrays write out nothing
                        for (int i = 0; i <= array.GetUpperBound(0); i++)
                        {
                            object elem = array.GetValue(i);
                            string value = String.Format("{0}", elem);

                            WriteNameAndValue(filterList, fieldInfo, reqParam, name, elem);
                        }
                    }
                    // If it's not an array, just add the property name and value
                    else
                    {
                        WriteNameAndValue(filterList, fieldInfo, reqParam, name, fieldValue);
                    }
                }
            }

            return filterList;
        }
    }

    public abstract class WebResponseBase : XRLObject2
    {
        public string Response;

        public override void ReadFromRequest(System.IO.BinaryReader reader, UTF8Encoding enc, long len, System.Collections.Specialized.NameValueCollection queryString)
        {
            byte[] resp = reader.ReadBytes((int)len);
            Response = enc.GetString(resp);
        }

        public override string ToString()
        {
            return Response;
        }
    }

    /// <summary>
    /// Provides a base class for all filters used by the FilteWebRequest class
    /// </summary>
    public abstract class FilterBase
    {
        /// <summary>
        /// Converts a WebRequestParam attrib marked-up class into a List
        /// </summary>
        /// <returns>A List containing the name/value pairs of the class</returns>
        public virtual List<StringPair> ToList()
        {
            return WebRequestBase.WebRequestToList(this);
        }

        public void BuildFilter(System.Collections.Hashtable valueTable)
        {
            Type thisType = this.GetType();
            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Public
                );

            foreach (System.Reflection.FieldInfo field in fieldInfos)
            {
                System.Collections.ArrayList tmpList = (System.Collections.ArrayList)valueTable[field.Name];
                if (tmpList != null)
                {
                    string[] tmpStr = (string[])tmpList.ToArray(typeof(string));
                    if (field.FieldType.GetInterface("IList") != null)
                    {
                        Type listType = field.FieldType.GetGenericArguments()[0];
                        IList list = (IList)Activator.CreateInstance(field.FieldType);

                        foreach (String str in tmpStr)
                        {
                            Object value = null;

                            if (listType == typeof(Guid))
                            {
                                if (str == "null")
                                {
                                    value = Guid.Empty;
                                }
                                else
                                {
                                    value = new Guid(str);
                                }
                            }
                            else
                            {
                                value = Convert.ChangeType(str, listType);
                            }

                            list.Add(value);
                        }

                        field.SetValue(this, list);
                    }
                    else
                    {
                        Object value = null;

                        if (field.FieldType == typeof(Guid))
                        {
                            value = new Guid(tmpStr[0]);
                        }
                        else if (field.FieldType == typeof(DateTime))
                        {
                            value = String.Equals(tmpStr[0], "null") ? DateTime.MinValue : DateTime.Parse(tmpStr[0]);
                        }
                        else
                        {
                            value = Convert.ChangeType(tmpStr[0], field.FieldType);
                        }

                        field.SetValue(this, value);
                    }
                }
            }
        }

        /// <summary>
        /// for internal server catalog query testing
        /// </summary>
        public List<StringPair> BuildNameValuePairs(System.Collections.Hashtable valueTable)
        {
            List<StringPair> filterList = new List<StringPair>();

            Type thisType = this.GetType();
            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Public
                );

            foreach (System.Reflection.FieldInfo field in fieldInfos)
            {
                object[] attrs = field.GetCustomAttributes(typeof(WebRequestParamAttribute), true);
                if (attrs.Length != 0 && ((WebRequestParamAttribute)attrs[0]).ParamType == WebRequestParamType.NameValuePair)
                {
                    string name = ((WebRequestParamAttribute)attrs[0]).WireName;
                    System.Collections.ArrayList tmpList = (System.Collections.ArrayList)valueTable[name];
                    if (tmpList != null)
                    {
                        string[] tmpStr = (string[])tmpList.ToArray(typeof(string));
                        // we ignore the field.FieldType.IsArray, but rather let input valueTable decide
                        // Empty Lists/Arrays write out nothing
                        for (int i = 0; i <= tmpStr.GetUpperBound(0); i++)
                        {
                            string value = String.Format("{0}", tmpStr[i]);
                            filterList.Add(new StringPair("Names", name));
                            filterList.Add(new StringPair("Values", value));
                        }
                    }
                }
            }

            return filterList;
        }

        public string[] GetInputParamNames()
        {
            Type thisType = this.GetType();
            System.Reflection.FieldInfo[] fieldInfos = thisType.GetFields(
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.Public
                );

            List<string> inputNames = new List<string>();

            foreach (System.Reflection.FieldInfo field in fieldInfos)
            {
                object[] attrs = field.GetCustomAttributes(typeof(WebRequestParamAttribute), true);
                if (attrs.Length != 0)
                {
                    inputNames.Add(((WebRequestParamAttribute)attrs[0]).WireName);
                }
            }
            return inputNames.ToArray();
        }
    }
    
    /// <summary>
    /// A WebRequest object that accepts a filter object and sends it in the request
    /// and then reads the response (usually an XML document) back in.
    /// </summary>
    public abstract class FilterWebRequest : WebRequestBase
    {
        protected FilterBase baseFilter = null;
        /// <summary>
        /// A reference to the base class version of the filter that was provided for this request
        /// </summary>
        public FilterBase BaseFilter
        {
            get { return baseFilter; }
        }

        protected String response;
        /// <summary>
        /// For simplicity, a FilterWebRequest just reads the request as raw UTF-8 encoded text 
        /// into a string.  This response data is accessible through this property.
        /// </summary>
        public String Response
        {
            get { return response; }
        }

        public FilterWebRequest(String basePath, String operation)
            : base(basePath, operation)
        {
        }

        public FilterWebRequest(String basePath, String operation, FilterBase filter)
            : base(basePath, operation)
        {
            this.baseFilter = filter;
        }

        protected override string BuildHttpRequest(string seperator)
        {
            // Get the base request
            StringBuilder sb = new StringBuilder(base.BuildHttpRequest(seperator));

            // If a filter was provided
            if (baseFilter != null)
            {
                // Append all the parameters from our filter
                foreach (var pair in baseFilter.ToList())
                {
                    sb.AppendFormat("{0}{1}={2}", seperator, pair.Key, pair.Value);
                }
            }

            // Then return the whole thing
            return sb.ToString().Trim(seperator[0]);
        }

        public override void ReadResponse(byte[] responseData)
        {
            this.response = Encoding.UTF8.GetString(responseData);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\XRL.cs ===
using System;
using System.Reflection;
using System.Net;
using System.Collections;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Utilities;

using xonline.common.service;

namespace ServerTestFramework.LiveService
{
    // Base class for front door data packages
    [StructLayout(LayoutKind.Sequential)]
    public class XRLPayload : WireData
    {
        public event EventHandler PreExecute = null; // Called right before the XRL is executed
        public event EventHandler OnExecute = null; // Called after this XRL gets executed

        public string CustomHeader = String.Empty;

        // These default values are used by derived classes to set certain fields;
        public XOService ServiceId = XOService.User_Account;
        public static ulong defaultUPuid = 0;
        public static ulong[] defaultUPuidArray = null;
        public static ulong defaultMPuid = 0x0009400000000000;
        public CSGInfo Slot;
        public bool ManualSlotSetup = false;		// If set, you will need to set up your own SGInfo slot
        public bool UseHttpAuth = false;
        public bool SetHttpHeader = true;
        public FDTransaction.Transports transport = FDTransaction.Transports.TCP;
        public bool IgnoreUDPReceive = false;

        // This data is to be filled in by the derived class when it calls Execute
        public HttpStatusCode httpStatus
        {
            get
            {
                return xAct.httpStatus;
            }
        }
        public uint XErr
        {
            get
            {
                return xAct.XErr;
            }
        }
        public uint XDelay
        {
            get
            {
                return xAct.XDelay;
            }
        }

        //User-friendly error status message
        public string ErrorStatusMessage
        {
            get
            {
                return "Http="+(int)httpStatus+": "+httpStatus+", XErr="+Global.XErrToString(XErr);
            }
        }

        protected string httpHeader;
        public FDTransaction xAct = new FDTransaction();

        [SubStatic]
        private string CachedHttpHeader = null;

        public XRLPayload()
        {
            if (GlobalFakeSG.FakeSG != null)
                Slot = GlobalFakeSG.FakeSG.GetSlot();

            // Because CSGInfo is declared as a struct, it doesn't need to be instantiated.  It already
            // exists by just the line "public CSGInfo Slot;" above.  By default, the user does not
            // exist.  This will be set in the PopulateSlot() method below, or if you call FakeSG.GetSlot().

            InitializeDefaults();
        }

        protected void DeepCloneTo(ref XRLPayload Dest)
        {
            Dest.PreExecute = this.PreExecute;
            Dest.OnExecute = this.OnExecute;

            if (this.CustomHeader != null)
            {
                Dest.CustomHeader = string.Copy(this.CustomHeader);
            }
            Dest.ServiceId = this.ServiceId;
            Dest.Slot = this.Slot.ShallowClone();
            Dest.ManualSlotSetup = this.ManualSlotSetup;
            Dest.UseHttpAuth = this.UseHttpAuth;
            if (this.httpHeader != null)
            {
                Dest.httpHeader = string.Copy(this.httpHeader);
            }
            Dest.xAct = (FDTransaction)this.xAct.DeepClone();
            if (this.CachedHttpHeader != null)
            {
                Dest.CachedHttpHeader = string.Copy(this.CachedHttpHeader);
            }
            if (this.CrapHeader != null)
            {
                Dest.CrapHeader = (byte[])this.CrapHeader.Clone();
            }
        }

        protected virtual void SetServices()
        {
            Slot.AddService(XOService.Tou);
            Slot.AddService(XOService.User_Account);
            Slot.AddService(XOService.Billing_Offering);
            Slot.AddService(XOService.Auto_Update);
            Slot.AddService(XOService.Base_Subscription);
        }

        // Initializes XRL to default values
        protected virtual void InitializeDefaults()
        {
            foreach (FieldInfo field in GetType().GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
            {
                if (field.GetCustomAttributes(typeof(XRLPayloadFldAttribute), false).Length == 1)
                {
                    XRLPayloadFldAttribute wireInfo = (XRLPayloadFldAttribute)field.GetCustomAttributes(typeof(XRLPayloadFldAttribute), false)[0];

                    if (wireInfo.IsMPuid)
                    {
                        field.SetValue(this, defaultMPuid);
                    }
                    else if (wireInfo.IsUPuid)
                    {
                        if (field.FieldType.IsArray)
                            field.SetValue(this, defaultUPuidArray);
                        else
                            field.SetValue(this, defaultUPuid);
                    }
                    else if (wireInfo.IsTitleId)
                    {
                        field.SetValue(this, 0xFFFE0000);
                    }
                    else if (wireInfo.IsTitleVersion)
                    {
                        field.SetValue(this, (uint)1);
                    }
                    else if (wireInfo.IsTier)
                    {
                        field.SetValue(this, (byte)3);
                    }
                }
            }
        }

        public virtual string GetDumpString()
        {
            string outputString;
            outputString = this.GetType().Name;
            outputString += " XErr:" + Global.XErrToString(XErr) + "  HTTP:" + httpStatus;
            return outputString;
        }

        public void Dump()
        {
            ConsoleX.WriteLine(CC.RED, GetDumpString());
        }

        protected virtual string GetServiceName()
        {
            return "";
        }

        byte[] CrapHeader;
        public virtual byte[] GenerateHttpHeader(IPEndPoint endPoint, MemoryStream reqStream)
        {
            StringBuilder sbURL;
            if (CachedHttpHeader == null)
            {
                sbURL = new StringBuilder();
                sbURL.Append("POST ");
                sbURL.Append(GetServiceName());
                sbURL.Append(" HTTP/1.0\r\n");
                sbURL.Append("Relja: true\r\n");  // This header was requested by SLamb to differentiate tools/tests and real clients
                sbURL.Append("Host: " + endPoint.ToString() + "\r\n");
                CachedHttpHeader = sbURL.ToString();
            }
            sbURL = new StringBuilder(CachedHttpHeader);
            sbURL.Append("Content-Type: xon/" + ((int)ServiceId).ToString("x") + "\r\n");
            sbURL.Append("User-Agent: " + ((int)ServiceId).ToString("x") + "/0.10.4715\r\n");
            sbURL.Append(CustomHeader);
            sbURL.Append("Content-Length: " + reqStream.Length + "\r\n\r\n");

            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            CrapHeader = AE.GetBytes(sbURL.ToString());
            return CrapHeader;
        }

        //XXX: OBSOLETE this to make people fix their XRLs
        protected virtual bool InternalExecute(LiveServer sServers, MemoryStream reqStream)
        {
            return InternalExecute(sServers.EPDefault, reqStream);
        }

        // Performs common execute functionality
        protected virtual bool InternalExecute(IPEndPoint endPoint, MemoryStream reqStream)
        {
            byte[] httpHeader;
            // We can potentially add header caching here. We'll do that later
            if (SetHttpHeader)            
                httpHeader = GenerateHttpHeader(endPoint, reqStream);
            else
                httpHeader = new byte[] { };
                   
            xAct.endPoint = endPoint;
            bool bRet = false;

            try
            {
                if (!ManualSlotSetup)
                    PopulateSlot(ref Slot);

                if (PreExecute != null)
                    PreExecute(this, null);

                xAct.transport = transport;
                if (transport == FDTransaction.Transports.UDP)
                {
                    xAct.IgnoreUDPReceive = IgnoreUDPReceive;
                    bRet = xAct.Execute(httpHeader, reqStream, ref Slot);
                }
                else
                {
                    bRet = xAct.Execute(httpHeader, reqStream, ref Slot, true, UseHttpAuth);
                }
            }
            catch (System.IO.IOException)
            {
                // I've commented this out because the TestBase handler really handles this in a better way -Relja
                //				Global.RO.Warn("IOException in " + GetType().Name + ".InternalExecute");
                throw;
            }
            catch (System.Net.Sockets.SocketException)
            {
                // I've commented this out because the TestBase handler really handles this in a better way -Relja
                //				Global.RO.Warn("SocketException in " + GetType().Name + ".InternalExecute");
                throw;
            }
            catch (System.InvalidCastException)
            {
                throw;
            }
            catch (Exception e)
            {
                Console.WriteLine("Something went wrong with the socket");
                Console.WriteLine(e.ToString());
                return false;
            }

            if (OnExecute != null)
                OnExecute(this, null);

            return bRet;
        }

        //Execute an XRL asynchronously.
        protected virtual IAsyncResult BeginInternalExecute(IPEndPoint endPoint, MemoryStream reqStream, 
                                                            AsyncCallback callback)
        {
            byte[] httpHeader;
            // We can potentially add header caching here. We'll do that later
            if (SetHttpHeader)
                httpHeader = GenerateHttpHeader(endPoint, reqStream);
            else
                httpHeader = new byte[] { };

            xAct.endPoint = endPoint;

            try
            {
                if (!ManualSlotSetup)
                    PopulateSlot(ref Slot);

                if (PreExecute != null)
                    PreExecute(this, null);

                xAct.transport = transport;
                if (transport == FDTransaction.Transports.UDP)
                {                    
                    xAct.IgnoreUDPReceive = true;
                    return xAct.BeginExecute(httpHeader, reqStream, ref Slot, true, false, callback, this);
                }
                else
                {
                    return xAct.BeginExecute(httpHeader, reqStream, ref Slot, true, UseHttpAuth, callback, this);
                }
            }
            catch (System.IO.IOException)
            {
                // I've commented this out because the TestBase handler really handles this in a better way -Relja
                //				Global.RO.Warn("IOException in " + GetType().Name + ".InternalExecute");
                throw;
            }
            catch (System.Net.Sockets.SocketException)
            {
                // I've commented this out because the TestBase handler really handles this in a better way -Relja
                //				Global.RO.Warn("SocketException in " + GetType().Name + ".InternalExecute");
                throw;
            }
            catch (System.InvalidCastException)
            {
                throw;
            }
            catch (Exception e)
            {
                Console.WriteLine("Something went wrong with the socket");
                Console.WriteLine(e.ToString());
                throw;
            }
        }

        //Call this to retrieve the result of an asynchronous call.
        protected bool EndInternalExecute(IAsyncResult ar) {
            bool bRet = xAct.EndExecute(ar);
            if (OnExecute != null)
                OnExecute(this, null);

            return bRet;
        }

        virtual protected void ReadResponse(MemoryStream responseStream)
        {
            throw new Exception("The server returned " + responseStream.Length + " bytes, but you are ignoring them. Make sure you override ReadResponse");
        }

        virtual public bool ExecuteSafe()
        {
            bool b = Execute();
            if (!b)
            {
                UnexpectedXRLTestResultException e = new UnexpectedXRLTestResultException(this.GetDumpString());
                e.xrl = this;
                throw e;
            }
            return b;
        }

        virtual public bool Execute()
        {
            throw new Exception("XrlPayload.Execute not provided for type " + ToString());
        }

        virtual public bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        // This standard execute works well for most cases
        virtual public bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
                {
                    if (xAct.ResponseContents.Length > 0)
                        ReadResponse(new MemoryStream(xAct.ResponseContents));
                    uRet = true;
                }
            }

            return uRet;
        }

        /// <summary>
        /// Verifies that the specified call failed, and that the returned error matches the expected code. 
        /// This behavior can be overriden to not check for an explicit error code
        /// 
        /// This function will also set ResultCode as needed
        /// </summary>
        public bool TestNegative(uint expectedCode)
        {
            if (httpStatus != HttpStatusCode.OK)
            {
                if (XErr == expectedCode)
                {
                    return true;
                }
            }

            Dump();
            return false;
        }

        // populate the slot that this XRL object already owns and set the manual
        // slot population option to override population later on during execution
        public virtual void ManualPopulateSlot()
        {
            PopulateSlot(ref Slot);
            ManualSlotSetup = true;
        }

        // Populates FakeSG slot information (machine and user PUIDs)
        public virtual void PopulateSlot(ref CSGInfo slot)
        {
            this.SetServices();

            // By default, let's say the user exists.  Tests can override this variable if necessary.
            Slot.UserExists = 1;

            XRLPayloadFldAttribute defaultAttribute = new XRLPayloadFldAttribute();

            foreach (FieldInfo field in GetType().GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
            {
                XRLPayloadFldAttribute wireInfo = defaultAttribute;
                if (field.GetCustomAttributes(typeof(XRLPayloadFldAttribute), false).Length == 1)
                    wireInfo = (XRLPayloadFldAttribute)field.GetCustomAttributes(typeof(XRLPayloadFldAttribute), false)[0];

                if (wireInfo.IsMPuid)
                {
                    slot.machinePuid = (ulong)field.GetValue(this);
                }
                else if (wireInfo.IsUPuid)
                {
                    if (field.FieldType.IsArray)
                    {
                        ulong[] ul = (ulong[])field.GetValue(this);
                        if (ul == null)
                        {
                            slot.userPuid0 = 0;
                            slot.userPuid1 = 0;
                            slot.userPuid2 = 0;
                            slot.userPuid3 = 0;
                        }
                        else
                        {
                            slot.userPuid0 = ul[0];
                            slot.userPuid1 = ul[1];
                            slot.userPuid2 = ul[2];
                            slot.userPuid3 = ul[3];

                        }
                    }
                    else
                    {
                        slot.userPuid0 = (ulong)field.GetValue(this);
                    }
                }
                else if (wireInfo.IsTitleId)
                {
                    slot.titleId = (uint)field.GetValue(this);
                }
                else if (wireInfo.IsTitleVersion)
                {
                    slot.titleVersion = (uint)field.GetValue(this);
                }
                else if (wireInfo.IsCountryId)
                {
                    slot.userFlag0 = (uint)((byte)field.GetValue(this) << 8);
                }
                else if (wireInfo.IsTier)
                {
                    slot.SetTier(0, (byte)(field.GetValue(this)));
                }
            }
        }

        public static void SetFlag(byte flag, bool set, ref byte value)
        {
            if (set == true)
                value = (byte)(value | flag);
            else
                value = (byte)(value & ~flag);
        }

        public static void SetFlag(ushort flag, bool set, ref ushort value)
        {
            if (set == true)
                value = (ushort)(value | flag);
            else
                value = (ushort)(value & ~flag);
        }

        public static bool IsFlagSet(byte flag, byte value)
        {
            return ((flag & value) == flag);
        }

        public static bool IsFlagSet(ushort flag, ushort value)
        {
            return ((flag & value) == flag);
        }
    }

    [AttributeUsage(AttributeTargets.Field)]
    public class XRLPayloadFldAttribute : WireInfoAttribute
    {
        public bool IsMPuid = false;
        public bool IsUPuid = false;
        public bool IsTitleId = false;
        public bool IsTitleVersion = false;
        public bool IsCountryId = false;
        public bool IsTier = false;
    }

    /// <summary>
    /// This class provides and easy generic way to link an XRL Payload object
    /// with a corresponding XRLObject2 request.  When executing, the request 
    /// object will automatically be serialized and transmitted.  
    /// </summary>
    /// <typeparam name="XRLObject2RequestType">A XRLObject2 request object to base the payload on</typeparam>
    /// <remarks>
    /// The ReadResponse method must be overridden to use this class otherwise 
    /// an exception will be thrown during execution.
    /// </remarks>
    [WireDataInfo(Serialize=false)]
    public class XRLPayload<XRLObject2RequestType> : XRLPayload
        where XRLObject2RequestType : XRLObject2, new()
    {
        private XRLObject2 XRLObject2Request;
        /// <summary>
        /// The request object that will be serialized and transmitted for this payload
        /// </summary>
        public XRLObject2RequestType Request
        {
            get { return (XRLObject2RequestType)XRLObject2Request; }
        }

        /// <summary>
        /// Execute this request using the appropriate request type and reads
        /// the response as appropriate
        /// </summary>
        /// <param name="endPoint">The endpoint against which to execute the request</param>
        /// <returns>True if the request was successfull, false otherwise.</returns>
        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream(512);
            Request.WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
                {
                    if (xAct.ResponseContents.Length > 0)
                        ReadResponse(new MemoryStream(xAct.ResponseContents));
                    uRet = true;
                }
            }

            return uRet;
        }

        //internal workings
        public XRLPayload()
        {
            XRLObject2Request = new XRLObject2RequestType();
        }

        protected override string GetServiceName()
        {
            if (Request.Xrl == null || Request.Xrl.Length == 0)
            {
                Global.RO.Debug("GetServiceName() warning: Request of type " + Request.GetType().ToString() + " returned an empty Xrl.");
            }

            return Request.Xrl;
        }

        public override void PopulateSlot(ref CSGInfo slot)
        {
            this.SetServices();

            // By default, let's say the user exists.  Tests can override this variable if necessary.
            Slot.UserExists = 1;

            XRLPayloadFldAttribute defaultAttribute = new XRLPayloadFldAttribute();

            foreach (FieldInfo field in Request.GetType().GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
            {
                XRLPayloadFldAttribute wireInfo = defaultAttribute;
                if (field.GetCustomAttributes(typeof(XRLPayloadFldAttribute), false).Length == 1)
                    wireInfo = (XRLPayloadFldAttribute)field.GetCustomAttributes(typeof(XRLPayloadFldAttribute), false)[0];

                if (wireInfo.IsMPuid)
                {
                    slot.machinePuid = (ulong)field.GetValue(Request);
                }
                else if (wireInfo.IsUPuid)
                {
                    if (field.FieldType.IsArray)
                    {
                        ulong[] ul = (ulong[])field.GetValue(Request);
                        if (ul == null)
                        {
                            slot.userPuid0 = 0;
                            slot.userPuid1 = 0;
                            slot.userPuid2 = 0;
                            slot.userPuid3 = 0;
                        }
                        else
                        {
                            slot.userPuid0 = ul[0];
                            slot.userPuid1 = ul[1];
                            slot.userPuid2 = ul[2];
                            slot.userPuid3 = ul[3];

                        }
                    }
                    else
                    {
                        slot.userPuid0 = (ulong)field.GetValue(Request);
                    }
                }
                else if (wireInfo.IsTitleId)
                {
                    slot.titleId = (uint)field.GetValue(Request);
                }
                else if (wireInfo.IsTitleVersion)
                {
                    slot.titleVersion = (uint)field.GetValue(Request);
                }
                else if (wireInfo.IsCountryId)
                {
                    slot.userFlag0 = (uint)((byte)field.GetValue(Request) << 8);
                }
                else if (wireInfo.IsTier)
                {
                    slot.SetTier(0, (byte)(field.GetValue(Request)));
                }
            }
        }
    }

    /// <summary>
    /// This class provides and easy generic way to link an XRL Payload object
    /// with corresponding XRLObject2 request and response objects.  When 
    /// executing, the request object will automatically be serialized and 
    /// transmitted.  If the request is successfull, the response will be read
    /// and parsed into the response object
    /// </summary>
    /// <typeparam name="XRLObject2RequestType">An XRLObject2 request object to base the payload on</typeparam>
    /// <typeparam name="XRLObject2ResponseType">An XRLObject2 response object to base the response on</typeparam>
    public class XRLPayload<XRLObject2RequestType, XRLObject2ResponseType> : XRLPayload<XRLObject2RequestType>
        where XRLObject2RequestType : XRLObject2, new()
        where XRLObject2ResponseType : XRLObject2, new()
    {
        private XRLObject2 XRLObject2Response = null;
        /// <summary>
        /// The response object that the response data will be read into after execution
        /// </summary>
        public XRLObject2ResponseType Response
        {
            get { return (XRLObject2ResponseType)XRLObject2Response; }
        }

        /// <summary>
        /// Reads the response from memory into an instance of our custom response object
        /// </summary>
        /// <param name="responseStream">The response data to read into the object</param>
        protected override void ReadResponse(MemoryStream responseStream)
        {
            XRLObject2Response = new XRLObject2ResponseType();

            if (responseStream != null)
            {
                Response.ReadStream(responseStream);
            }
        }
    }

    /// <summary>
    /// This class provides and easy generic way to link an XRL Payload object
    /// with corresponding XRLObject2 request and response for any API which 
    /// accepts multiple requests in a single request stream.  When executing 
    /// the request objects will automatically be serialized into the request 
    /// stream sequentially.  If the request is successful, the response stream
    /// will be read into an array of corresponding response objects.
    /// </summary>
    /// <typeparam name="XRLObject2RequestType">An XRLObject2 request object to base the payload on</typeparam>
    /// <typeparam name="XRLObject2ResponseType">An XRLObject2 response object to base the response on</typeparam>
    public class XRLPayloads<XRLObject2RequestType, XRLObject2ResponseType> : XRLPayload
        where XRLObject2RequestType : XRLObject2, new()
        where XRLObject2ResponseType : XRLObject2, new()
    {
        /// <summary>
        /// A delegate object used to retrieve some non-static properties from
        /// the request object type that are required to make the request
        /// </summary>
        private XRLObject2RequestType requestObj = null;

        /// <summary>
        /// An array of request objects to send to the server
        /// </summary>
        public XRLObject2RequestType[] Requests = null;
        public XRLObject2ResponseType[] Responses = null;

        //internal workings
        public XRLPayloads()
            : this(0)
        {
        }

        public XRLPayloads(Int32 numRequests)
        {
            Requests = new XRLObject2RequestType[numRequests];
            requestObj = new XRLObject2RequestType();
        }

        protected override string GetServiceName()
        {
            if (requestObj.Xrl == null || requestObj.Xrl.Length == 0)
            {
                Global.RO.Debug("GetServiceName() warning: Request of type " + requestObj.GetType().ToString() + " returned an empty Xrl.");
            }

            return requestObj.Xrl;
        }

        /// <summary>
        /// Writes each of the request objects into the request stream
        /// </summary>
        /// <param name="binaryWriter"></param>
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (Requests != null && Requests.Length > 0)
            {
                foreach (XRLObject2RequestType request in Requests)
                {
                    request.WriteStream(binaryWriter);
                }
            }
        }

        /// <summary>
        /// Reads the response from memory into an array of response objects.
        /// There should be one response object for each request object.
        /// </summary>
        /// <param name="responseStream">The response data</param>
        protected override void ReadResponse(MemoryStream responseStream)
        {
            Responses = new XRLObject2ResponseType[Requests.Length];

            if (responseStream != null)
            {
                Int32 index = 0;
                while (responseStream.Position != responseStream.Length)
                {
                    if (index > Requests.Length)
                    {
                        Global.RO.Warn("More responses returned than requested.");
                    }
                    Responses[index] = new XRLObject2ResponseType();
                    Responses[index].ReadStream(responseStream);
                    index++;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Achievement\XRLUploadConsoleListRequest.cs ===
using System;
using System.Collections;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using xonline.common.config;
using xonline.common.service;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.FakeSG;


namespace ServerTestFramework.LiveService.UploadConsoleList
{
    public class ConsoleIdData : WireData
    {
        [WireInfo(ArraySize = 5)]
        public byte[] ConsoleId = null;

        public ConsoleIdData()
        {

        }
        // Useful for tests creating these
        public ConsoleIdData(byte[] ConsoleId)
        {
            this.ConsoleId = ConsoleId;
        }

        // Used for displaying the consoleId in output strings mostly
        public static ulong GetDecimalValue(byte[] consoleIdBytes)
        {
            if (consoleIdBytes == null)
            {
                return 0;
            }

            ulong result = 0;
            for (int i = consoleIdBytes.Length - 1; i >= 0; --i)
            {
                result = (result << 8) + consoleIdBytes[i];
            }
            return result;
        }

    }

	public class XRLUploadConsoleListRequest : XRLPayload
	{
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserId = 0;
        
        public ConsoleIdData UploadingConsoleId = new ConsoleIdData();
        public ConsoleIdData SigningConsoleId = new ConsoleIdData();

        // should come from STF.common.service.XOn.XONLINE_MAX_CONSOLE_AUDIT_LIST
        // but STFLive keeps looking in ServerTestFramework.STF.common... which is wrong
        [WireInfo(Max = 100)]
        public byte ConsoleCount = 0;

        [WireInfo(SizeParam = "ConsoleCount")]
        public ConsoleIdData[] ConsoleIdList = null;

        // Empty, need to set in test, rejected by the service API because consoleList is empty
        public XRLUploadConsoleListRequest()
        {

        }

        // Simple for saying the upload, signing and console list is same consoleid
        public XRLUploadConsoleListRequest(ulong puid, byte[] consoleId)
        {
            UserId = puid;
            UploadingConsoleId.ConsoleId = consoleId;
            SigningConsoleId.ConsoleId = consoleId;
            ConsoleCount = 1;
            ConsoleIdData consoleList = new ConsoleIdData();
            consoleList.ConsoleId = consoleId;
            ConsoleIdList = new ConsoleIdData[] { consoleList };
        }

        // Most flexible for specifying the upload consoleid, signing consoleid
        // and the Console List being Sync'ed
        public XRLUploadConsoleListRequest(ulong puid, byte[] uploadingconsoleId, byte[] signingconsoleId, ConsoleIdData [] consoleList)
        {
            UserId = puid;
            UploadingConsoleId.ConsoleId = uploadingconsoleId;
            SigningConsoleId.ConsoleId = signingconsoleId;
            ConsoleCount = (byte)consoleList.Length;
            ConsoleIdList = new ConsoleIdData[consoleList.Length];
            ConsoleIdList = consoleList;
        }

        // Need to have this request which has no response size expected
        // which is not a standard API we normally have
        public uint PostXRLUploadConsoleListRequest(ulong user, XRLUploadConsoleListRequest req, CSGInfo.ClientType client)
        {
            uint hr;
            
            // FakeSG stuff
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            //Set the client type passed in 
            slot.SetClientType(client);
            slot.titleId = XOn.XENON_DASH_TITLE_ID;  //not sure this is required
            slot.userPuid0 = user;

            //MemoryStream reqStream = new MemoryStream(req., 0, requestData.Length, true, true);
            MemoryStream reqStream = new MemoryStream();
            req.WriteStream( reqStream );

            string uri = "POST " + GetServiceName() + " HTTP/1.0\r\n";

            WebHeaderCollection headers = new WebHeaderCollection();
            headers.Add("Content-Type", "xon/" + ((int)XOService.Profile).ToString("x"));
            headers.Add("User-Agent", ((int)XOService.Profile).ToString("x") + "/1.0.4325");
            headers.Add("Content-Length", reqStream.Length.ToString());
            if (req.httpHeader != null)
            {
                headers.Add(req.httpHeader);
            }

            // if no schema version is present, default to be the current schema version
            if (headers["X-Schema-Ver"] == null)
            {
                headers.Add("X-Schema-Ver", WireInfoAttribute.VersionToString(this.SchemaVersion));
            }

            FDTransaction xAct = new FDTransaction();
            xAct.endPoint = Global.XEnv.GetVirtualInterface(VirtualInterface.profilefd);
            xAct.AppendSGIPPort = false; ;

            string headerString = uri + headers.ToString();
            ASCIIEncoding ascii = new ASCIIEncoding();
            byte[] headerBytes = ascii.GetBytes(headerString);

            bool retValue = xAct.Execute(headerBytes, reqStream, ref slot);

            hr = xAct.XErr;

            if (!retValue && HResult.Succeeded(hr))
            {
                throw new Exception("PostXRLUploadConsoleListRequest: failed request: " + headerString);
            }

            return hr;
        }

        protected override string GetServiceName()
        {
            return "/xstats/uploadconsoleauditlist.ashx";
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Alerts\AlertsListener.cs ===
using System;
using System.Collections;
using System.Net.Sockets;
using System.Xml;
using System.IO;
using System.Threading;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using System.Diagnostics;

namespace ServerTestFramework.LiveService.Alerts
{
	/// <summary>
	/// MSN Alerts backend simulator
	/// </summary>
	public class AlertsListener : XHttpListener
	{

		/// <summary>
		/// Auto reset event for triggering gets from hash table to wakeup
		/// </summary>
		public static AutoResetEvent aRE = new AutoResetEvent(false);

		/// <summary>
		/// Hash table that stores alert data or alert counts
		/// </summary>
		public static Hashtable ht = Hashtable.Synchronized(new Hashtable());

		/// <summary>
		/// Running in stress mode?  Depends on constructor used
		/// </summary>
		private static bool isStress=false;

		/// <summary>
		/// Performance counter category
		/// </summary>
		private static string CounterCategory = "Alerts Stress Testing Listener";
		private static string[] CounterNames = {"Alerts Received"};

		/// <summary>
		/// Functional tests store Alert Data in Hashtable
		/// </summary>
		public class AlertData
		{
			public string notifyLang;
			public string subjectText;
			public string viewText;
			public string baseURL;
			public string actionURL;
			public string subscribeURL;
			public string iconURL;
		}

		/// <summary>
		/// Constructor for functional tests
		/// </summary>
		/// <param name="listenPort"></param>
		public AlertsListener(int listenPort, CPUIDList puidList):base(listenPort)
		{
			MemoryStream ms = null;
			BinaryReader br = null;
			ulong webId = 0UL;

			isStress=false;

			//Establish a queue in a hashtable for each webId in the form it will come back to us in for speed.
			int puids=puidList.GetSize();
			for (int i=0; i<puids;i++)
			{
				ms = new MemoryStream(puidList[i].WebId);
				br = new BinaryReader(ms);
				webId = br.ReadUInt64();
				ht[AlertsSQL.FormatSubscriberId(webId)]=new Queue();
			}
		}

		/// <summary>
		/// Constructor for stress
		/// </summary>
		/// <param name="listenPort"></param>
		public AlertsListener(int listenPort, ulong firstPuid, ulong puidCount):base(listenPort)
		{
			isStress=true;
		
			for (ulong i=0; i<puidCount; i++){
				ht[AlertsSQL.FormatSubscriberId(firstPuid+i)] = new long();
			}
			Counters.CreateCategory(CounterCategory,CounterNames);

		}

		/// <summary>
		/// Gets alert data stored in hashtable (functional tests)
		/// </summary>
		/// <param name="puid"></param>
		/// <param name="ad"></param>
		/// <param name="ts"></param>
		/// <returns></returns>
		public bool GetAlertData(ulong puid, out AlertData ad, TimeSpan ts)
		{
			ad=null;
			string puidStr = AlertsSQL.FormatSubscriberId(puid);

			Queue q=(Queue)(ht[puidStr]);
			long waitTicks = ts.Ticks;
			long startTime = DateTime.Now.Ticks;

			while (waitTicks>=0)
			{
				if (q.Count<=0)
				{
					aRE.WaitOne(new TimeSpan(waitTicks),true);	
					waitTicks-=DateTime.Now.Ticks-startTime;
					startTime=DateTime.Now.Ticks;
				}
				else
				{
					lock (q)
					{
						//Did it disappear before we locked it?
						if (q.Count>0)
						{
							ad=(AlertData)q.Dequeue();
							return true;
						}
					}
					waitTicks-=DateTime.Now.Ticks-startTime;
					startTime=DateTime.Now.Ticks;
				}
			}
			return false;
		}

		/// <summary>
		/// Peek at alert data stored in hashtable (functional tests)
		/// </summary>
		/// <param name="puid"></param>
		/// <param name="ad"></param>
		/// <param name="ts"></param>
		/// <returns></returns>
		public bool PeekAlertData(ulong puid, out AlertData ad, TimeSpan ts)
		{
			ad=null;
			string puidStr = AlertsSQL.FormatSubscriberId(puid);

			Queue q=(Queue)(ht[puidStr]);
			long waitTicks = ts.Ticks;
			long startTime = DateTime.Now.Ticks;

			while (waitTicks>=0)
			{
				if (q.Count<=0)
				{
					aRE.WaitOne(new TimeSpan(waitTicks),true);	
					waitTicks-=DateTime.Now.Ticks-startTime;
					startTime=DateTime.Now.Ticks;
				}
				else
				{
					lock (q)
					{
						//Did it disappear before we locked it?
						if (q.Count>0)
						{
							ad=(AlertData)q.Peek();
							return true;
						}
					}
					waitTicks-=DateTime.Now.Ticks-startTime;
					startTime=DateTime.Now.Ticks;
				}
			}
			return false;
		}

		/// <summary>
		/// Consumes incoming alerts soap requests and stores data based on test mode
		/// </summary>
		/// <param name="reqData"></param>
		/// <param name="index"></param>
		/// <param name="contentLen"></param>
		/// <returns></returns>
		public override bool ProcessData(byte[] reqData, int index, int contentLen)
		{
			XmlDocument xmd = new XmlDocument();
			MemoryStream ms = new MemoryStream(reqData,index,contentLen);
			xmd.Load(ms);
			string puid = xmd.DocumentElement["soap:Header"]["Target"]["ToPPUser"].Attributes["puid"].Value;

			//Drop unexpected alerts
			if (null==ht[puid])
			{
				ConsoleX.WriteLine(CC.WARNING,"Dropping alert for "+puid);
				return true;
			}

			if (isStress)
			{
				
				object o = ht[puid];
				lock(o)
				{
					long l = (long) o;
					Interlocked.Increment(ref l);
					ht[puid]=l;
				}
				Counters.Increment(CounterCategory,CounterNames[0]);
			}
			else
			{
				lock(ht[puid])
				{
					AlertData ad = new AlertData();
					ad.notifyLang=xmd.DocumentElement["soap:Body"]["Notify"].GetAttribute("xml:lang");
					ad.subjectText=xmd.DocumentElement["soap:Body"]["Notify"]["Meta"]["Subject"].InnerText;
					ad.baseURL=xmd.DocumentElement["soap:Body"]["Notify"]["Meta"].Attributes["baseUrl"].InnerText;
					ad.actionURL=xmd.DocumentElement["soap:Body"]["Notify"]["Meta"]["Action"].Attributes["url"].InnerText;
					ad.subscribeURL=xmd.DocumentElement["soap:Body"]["Notify"]["Meta"]["Subscr"].Attributes["url"].InnerText;
					ad.iconURL=xmd.DocumentElement["soap:Body"]["Notify"]["Meta"]["Icon"].Attributes["url"].InnerText;
					ad.viewText=xmd.DocumentElement["soap:Body"]["Notify"]["Content"]["View"].InnerText;
					((Queue)(ht[puid])).Enqueue(ad);
					aRE.Set();
					//Console.WriteLine("Received an alert for "+puid);

				}
			}

			return true;
		}

		/// <summary>
		/// Start the listener
		/// </summary>
		public override void Go()
		{
			base.Go ();
			ConsoleX.WriteLine(CC.WHITE,"Alert Listener Started");
		}

		/// <summary>
		/// Stop that closes socket so that thread abort exception will trigger
		/// </summary>
		public override void Stop()
		{
			aRE.Set();
			base.Stop();
			ConsoleX.WriteLine(CC.WHITE,"Alert Listener Stopped");
		}

		public bool FlushData()
		{
			Queue q = null;
			foreach(string str in ht.Keys)
			{
				q = (Queue) ht[str];
				lock (q)
				{
					q.Clear();
				}
			}
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Arbitration\HandlerOptions.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace ServerTestFramework.LiveService.Arbitration
{
	/// <summary>
	/// Summary description for HandlerOptions.
	/// </summary>
	public class HandlerOptions : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Button button1;
		private System.Windows.Forms.Button button2;
		public System.Windows.Forms.TextBox Delay;
		public System.Windows.Forms.TextBox MaxConn;
		public System.Windows.Forms.RadioButton OptStartStop;
		private System.Windows.Forms.Label label4;
		public  System.Windows.Forms.TextBox textBox1;
		private System.Windows.Forms.Label label5;
		public System.Windows.Forms.Label CurrentConn;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public HandlerOptions()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.Delay = new System.Windows.Forms.TextBox();
			this.label2 = new System.Windows.Forms.Label();
			this.MaxConn = new System.Windows.Forms.TextBox();
			this.label3 = new System.Windows.Forms.Label();
			this.button1 = new System.Windows.Forms.Button();
			this.button2 = new System.Windows.Forms.Button();
			this.OptStartStop = new System.Windows.Forms.RadioButton();
			this.label4 = new System.Windows.Forms.Label();
			this.textBox1 = new System.Windows.Forms.TextBox();
			this.label5 = new System.Windows.Forms.Label();
			this.CurrentConn = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(32, 40);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(64, 23);
			this.label1.TabIndex = 0;
			this.label1.Text = "Delay";
			// 
			// Delay
			// 
			this.Delay.Location = new System.Drawing.Point(136, 40);
			this.Delay.Name = "Delay";
			this.Delay.TabIndex = 1;
			this.Delay.Text = "200";
			this.Delay.TextChanged += new System.EventHandler(this.Delay_TextChanged);
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(24, 72);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(104, 23);
			this.label2.TabIndex = 2;
			this.label2.Text = "Max Connections";
			// 
			// MaxConn
			// 
			this.MaxConn.Location = new System.Drawing.Point(136, 72);
			this.MaxConn.Name = "MaxConn";
			this.MaxConn.TabIndex = 3;
			this.MaxConn.Text = "4";
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(248, 32);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(32, 16);
			this.label3.TabIndex = 4;
			this.label3.Text = "ms";
			// 
			// button1
			// 
			this.button1.Location = new System.Drawing.Point(32, 176);
			this.button1.Name = "button1";
			this.button1.TabIndex = 5;
			this.button1.Text = "ok";
			this.button1.Click += new System.EventHandler(this.button1_Click);
			// 
			// button2
			// 
			this.button2.Location = new System.Drawing.Point(152, 176);
			this.button2.Name = "button2";
			this.button2.TabIndex = 6;
			this.button2.Text = "Close";
			this.button2.Click += new System.EventHandler(this.button2_Click);
			// 
			// OptStartStop
			// 
			this.OptStartStop.Location = new System.Drawing.Point(32, 104);
			this.OptStartStop.Name = "OptStartStop";
			this.OptStartStop.Size = new System.Drawing.Size(192, 24);
			this.OptStartStop.TabIndex = 7;
			this.OptStartStop.Text = "Stop Listner";
			this.OptStartStop.CheckedChanged += new System.EventHandler(this.radioButton1_CheckedChanged);
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(32, 144);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(96, 16);
			this.label4.TabIndex = 8;
			this.label4.Text = "% Error returned:";
			// 
			// textBox1
			// 
			this.textBox1.Location = new System.Drawing.Point(144, 144);
			this.textBox1.MaxLength = 3;
			this.textBox1.Name = "textBox1";
			this.textBox1.TabIndex = 9;
			this.textBox1.Text = "0";
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(32, 8);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(128, 23);
			this.label5.TabIndex = 10;
			this.label5.Text = "Current # Connections";
			// 
			// CurrentConn
			// 
			this.CurrentConn.Location = new System.Drawing.Point(168, 8);
			this.CurrentConn.Name = "CurrentConn";
			this.CurrentConn.TabIndex = 11;
			this.CurrentConn.Text = "label6";
			// 
			// HandlerOptions
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(288, 230);
			this.Controls.Add(this.CurrentConn);
			this.Controls.Add(this.label5);
			this.Controls.Add(this.textBox1);
			this.Controls.Add(this.label4);
			this.Controls.Add(this.OptStartStop);
			this.Controls.Add(this.button2);
			this.Controls.Add(this.button1);
			this.Controls.Add(this.label3);
			this.Controls.Add(this.MaxConn);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.Delay);
			this.Controls.Add(this.label1);
			this.Name = "HandlerOptions";
			this.Text = "HandlerOptions";
			this.ResumeLayout(false);

		}
		#endregion

		private void button1_Click(object sender, System.EventArgs e)
		{
			int perr= Convert.ToInt32(textBox1.Text);
			if( perr<100)
			{
				this.DialogResult= DialogResult.OK;
				this.Close();
			}
			else
				textBox1.Text="Error enty  between 1 &100";
		}

		private void button2_Click(object sender, System.EventArgs e)
		{
			this.DialogResult= DialogResult.Cancel;
			this.Close();
		}

		private void radioButton1_CheckedChanged(object sender, System.EventArgs e)
		{
		
		}

		private void Delay_TextChanged(object sender, System.EventArgs e)
		{
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Arbitration\XRLDebugResult.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Arbitration
{
	/// <summary>
	/// Arbitration DebugResult request XRLPayload.
	/// </summary>
	public class XRLDebugResult : XRLPayload
	{
		public ushort protocolVersion=1;
		public ushort flags=0;
		[XRLPayloadFld(IsTitleId=true)]
		public uint titleId=XOn.DASH_TITLE_ID;
		public ulong sessionId=0UL;
		public ulong sessionNonce=0UL;
		[XRLPayloadFld(Serialize=false)]
		public static bool fFrontDoor=true;

		public XRLDebugResult()
		{
			ServiceId=XOService.Arbitration;
		}

		public override bool Execute()
		{
			return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
		}

		protected override void SetServices()
		{
			base.SetServices ();
			Slot.AddService(XOService.Arbitration);
		}

		protected override string GetServiceName()
		{
			if (fFrontDoor)
				return @"/xarb/DebugResult.ashx";
			return @"/xarbINH/DebugResult.ashx";
		}

		[XRLPayloadFld(Serialize=false)]
		public XRLDebugResultResponse Response=null;

		protected override void ReadResponse(System.IO.MemoryStream responseStream)
		{
			Response=new XRLDebugResultResponse();
			Response.ReadStream(responseStream);
		}

	}

	/// <summary>
	/// Arbitration DebugResult response wiredata
	/// </summary>
	public class XRLDebugResultResponse : WireData
	{
		public uint titleId;
		public ulong sessionId;
		public ulong sessionNonce;
		public double baseTrust;
		public double minorityQuorum;
		public double UserTournamentAmplification;
		public double PublisherTournamentAmplification;
		public uint BaseSessionTime;
		public double fermiK;
		public ushort flags;
		public ushort maxSessionSeconds;
		public ushort secondsLeftTillTimeout;
		public DateTime startTime;        
		public double sessionSeconds;
		public int xboxInfoLen;
		public ArbitrationXboxInfo[] xboxInfo;
		public int teamTicketCount;
		public double totalTrust;
		public uint reportCount;
		public bool arbitrated;
		public int result;
		public int nonProblematicResult;
		public float trustModificationScale;
		public int bundleLen;
		public ArbitrationBundle[] bundle;
		public int submittedBundleIndex;        
		public int suspiciousInfoLen;
		public ArbitrationSuspiciousInfo[] suspiciousInfo;
	}

	/// <summary>
	/// Arbitration DebugResult response ArbitrationXboxInfo wiredata
	/// </summary>
	public class ArbitrationXboxInfo : WireData
	{
		public byte timeExtendCount;
		public byte reportCount;
		public ushort reportFlags;
		public ulong xboxID;
		public int userXUIDAndTrustLen;
		public ArbitrationXUIDAndTrust[] userXUIDAndTrust;
		public double trust;
		public byte normalizedTrust;
		public int bundleIndex;
		public int diconnectedXboxLen;
		public ulong[] diconnectedXbox;
	}

	/// <summary>
	/// Arbitration DebugResult response ArbitrationXUIDAndTrust wiredata
	/// </summary>
	public class ArbitrationXUIDAndTrust : WireData
	{
		public ulong qwUserID;
		public uint dwUserFlags;
		public float userTrust;
	}

	/// <summary>
	/// Arbitration DebugResult response ArbitrationBundle wiredata
	/// </summary>
	public class ArbitrationBundle : WireData
	{
		public int index;
		public uint count;
		public double totalTrust;
	}

	/// <summary>
	/// Arbitration DebugResult response ArbitrationSuspiciousInfo wiredata
	/// </summary>
	public class ArbitrationSuspiciousInfo : WireData
	{
		public int type;
		public int messageLen;
		public string message;
		public int xboxLen;
		public ulong[] xbox;
		public int userLen;
		public ulong[] user;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Arbitration\XRLHealthARB.cs ===
using System;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Arbitration
{
	/// <summary>
	/// Summary description for XRLHealth.
	/// </summary>
	public class XRLHealthARB :XRLPayload
	{
		[XRLPayloadFld(Serialize=false)]
		public static bool fFrontDoor=true;

		public XRLHealthARB()
		{
			ServiceId=XOService.Arbitration;
			
		}

		protected override void ReadResponse(System.IO.MemoryStream responseStream)
		{
			
		}


		public override bool Execute()
		{
			return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
		}

		protected override void SetServices()
		{
			base.SetServices ();
			Slot.AddService(XOService.Arbitration);
		}

		protected override string GetServiceName()
		{
			if (fFrontDoor)
				return @"/xarb/Health.ashx";
			return @"/xarbINH/Health.ashx";
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Arbitration\ArbitrationSession.cs ===
using System;
using System.Collections;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Arbitration;
using ServerTestFramework.LiveService.Presence;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Arbitration
{
	/// <summary>
	/// This is a wrapper class that represents a shared arbitration session
	/// which you would use to
	/// </summary>
	///
	public class ArbSessionBase
	{

		protected ArrayList machines= new ArrayList();
		public ulong SessionId;
		public ulong SessionNonce;
		public uint TitleId;

		public ArbSessionBase(uint title)
		{
			TitleId = title;
			RandomEx rand = new RandomEx();
			SessionId = rand.NextUlong();
			SessionNonce = rand.NextUlong();
		}



		public class Machine
		{
			public ulong []Users;
			public uint UserCount;
			public ulong MachinePuid;


			public Machine()
			{
				UserCount = 0;
				Users = new ulong[4];
				MachinePuid = new RandomEx().NextPuid();
			}

			public void AddUser(ulong userPuid)
			{
				Users[UserCount++] = userPuid;
			}
		}


	}
	public class ArbitrationSession :ArbSessionBase
	{
		public enum SessionType
		{
			Stats=0,
			Competition=1

			// TODO: add more session types as needed
		}



		SessionType Type;

		public ushort Flags;

		public ArbitrationSession(SessionType type, uint titleId):base(titleId)
		{
			Type = type;
			switch(type)
			{
				case SessionType.Competition:
					Flags = XRLRegister.Flags.IsTournament;
					break;
				case SessionType.Stats:
					Flags =0;
					break;
				// TODO: add more flags here
			}
		}

		/// <summary>
		/// Create a new machine participating in the session.
		/// </summary>
		/// <returns>Index of machine for later calls to AddUser</returns>
		public uint AddMachine()
		{
			uint index = (uint)machines.Count;
			machines.Add(new Machine());
			return index;
		}

		/// <summary>
		/// Add a user playing on a machine by index.
		/// </summary>
		/// <param name="machine">Index of machine in session</param>
		/// <param name="userPuid">Unique ID of user</param>
		public void AddUser(uint machineId, ulong userPuid,ulong[] TeamPuids)
		{
			if(machineId >= machines.Count)
				throw new IndexOutOfRangeException("Machine index: " + machineId + " is out of range");

			Machine m = (Machine)machines[(int)machineId];
			if(m.UserCount > 3)
				throw new IndexOutOfRangeException("Machine index: " + machineId + " already has 4 participating users");


    		m.AddUser(userPuid);
		}

		/// <summary>
		/// Add a single user playing on their own machine.
		/// </summary>
		/// <param name="userPuid">The unique ID of the user</param>
		public void AddUser(ulong userPuid)
		{
			AddUser(AddMachine(), userPuid,null);
		}

		/// <summary>
		/// Add a single user playing on their own machine.
		/// </summary>
		/// <param name="userPuid">The unique ID of the user</param>
		public void AddUser(ulong userPuid,ulong[] teamPuids)
		{
			AddUser(AddMachine(), userPuid,teamPuids);
		}

		public void RegisterParticipants()
		{
			foreach(Machine m in machines)
			{
				XRLRegister register = new XRLRegister(this, m.Users, m.UserCount);
				register.machinePuid = m.MachinePuid;
				System.Console.WriteLine("XRLRegister"+register.machinePuid);
				register.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
			}
		}

		public void ReportSingleResult(byte[] bundle)
		{
			//if(Type != SessionType.Competition)
			//	throw new InvalidOperationException("Session was not created as a competition, you cannot report tournement results");

			foreach(Machine m in machines)
			{
				XRLReportResult report = new XRLReportResult();
				report.machinePuid = m.MachinePuid;
				report.sessionId = SessionId;
				report.sessionNonce = SessionNonce;
				report.titleId = TitleId;

				if(Flags == (ushort)SessionType.Competition)
				{
					report.flags |= XRLReportResult.Flags.TournamentBundleInfoSubmit;
					report.tournamentBundle = new TournamentBundle();
					report.tournamentBundle.bundle=bundle;
				}
				else if (Flags ==(ushort) SessionType.Stats)
				{
					report.flags |= XRLReportResult.Flags.StatsBundleInfoSubmit;
					report.statsBundle = new StatsBundle();
					report.statsBundle.bundle=bundle;
				}



				report.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
			}
		}

		// TODO: add other reporting wrappers here
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Arbitration\XArbListener.cs ===
using System;
using System.Windows.Forms;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Presence;


namespace ServerTestFramework.LiveService.Arbitration
{
	public class Stressbundle: WireData
	{
		public int	UsersLen=0;
		public ulong[]	Users = null;
		public int	randamdataLen=0;
		public byte []  randamdata=null;

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			if (Users != null)
			{
				UsersLen = Users.Length;
				binaryWriter.Write(UsersLen);
				foreach (ulong user in Users)
				{
					binaryWriter.Write(user);
				}
			}
			else
			{
				binaryWriter.Write(UsersLen);
			}
			if (randamdata != null)
			{
				randamdataLen = randamdata.Length;
				binaryWriter.Write(randamdataLen);
				binaryWriter.Write(randamdata);
			}
			else
			{
				binaryWriter.Write(randamdataLen);
			}
		}

	}
	public class StressSessionHandler
	{
		private static Hashtable Activeht = Hashtable.Synchronized(new Hashtable(20000)); 
		private static Hashtable InActiveht = Hashtable.Synchronized(new Hashtable(20000));
		private static Hashtable BackUP = Hashtable.Synchronized(new Hashtable(20000)); 
		private static int MaxSessionTime = 600 ;  // in seconds
		private DateTime ActiveTime;
		public System.Threading.Timer tmr;
		private static long FailCount;

		void ClearSessions(Object state)
		{
			lock(InActiveht)
			{
				lock(BackUP)
				{
					Hashtable tmp= InActiveht;
					InActiveht= BackUP;
					BackUP=tmp;
				}
			}
			// TODO Add Code to check
			// Go through the backup and see if all  sessions not recived are problamitic. else increment the Fail count.
			FailCount += BackUP.Count;
			Global.RO.Error("Invalid Session Count :"+FailCount);
			BackUP.Clear();
		}

		public StressSessionHandler()
		{
			ActiveTime= DateTime.UtcNow;
			ActiveTime.AddSeconds(MaxSessionTime*2);
			tmr = new System.Threading.Timer(new TimerCallback(ClearSessions), null,Timeout.Infinite, Timeout.Infinite);
		}

		public bool Contains(object Key)
		{
			bool contains= false;
/*
			if(InActiveht.Count > 0)
				contains = InActiveht.Contains(Key);
			else
			{	
				// if the time is 3 times the session time Swap
				lock(this)
				{
					if(DateTime.Compare(ActiveTime, DateTime.UtcNow)<0)
					{
						lock(Activeht)
						{
							lock(InActiveht)
							{
								Hashtable tmp=Activeht;
								Activeht = InActiveht;
								InActiveht=tmp;
								ActiveTime= DateTime.UtcNow;
								ActiveTime.AddSeconds(MaxSessionTime*2);
								tmr.Change((MaxSessionTime*1000)*2, Timeout.Infinite );

							}

						}
					}
				}
			}
*/
			if(!contains)
				contains = Activeht.Contains(Key);
			return contains;
		}

		public void Remove(object Key)
		{
			if(InActiveht.Count > 0 && InActiveht.Contains(Key))
				InActiveht.Remove(Key);
			else
				Activeht.Remove(Key);
		}

		public void Add(object key ,object Value)
		{
			Activeht.Add(key,Value);
		}

	}

	/// <summary>
	/// XArbListener threads listen for stats or query posts back from Arbitration server.
	/// </summary>
	/// 
	public class XArbListener : XHttpListenerIOCP
	{
		//Type of listners
		public enum types
		{
			invalid=0,
			stats,
			query
		}

		//Data structure stored in hash table
		public class SlotData
		{
			public BundledAuthData authData=null;
			public byte[] bundle= null;
		}


		//Protected member variables
		protected types listenerType= types.invalid;
		protected string ListnerName=null;
		public static AutoResetEvent aRE = new AutoResetEvent(false);

		//Static regular expressions
		private static Regex _regexBundledAuthData = new Regex(@"^BundledAuthData: (?<authdata>.*)\r", RegexOptions.Compiled | RegexOptions.Multiline);
		private static Regex _regexSessionIdNonce = new Regex(@"^POST /\w(?<sessionidnonce>\w{32})(?<bundlesize>\w{8})",RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
		

		
		//The hashtable
		public Hashtable ht = Hashtable.Synchronized(new Hashtable()); 
		public static bool IsStress=false;

		// this table is used only in case fo stress.
		public static StressSessionHandler  Stressht= new StressSessionHandler();
		static RandomEx RandomGen = new RandomEx();

		//Initialize member variable in constructor
		public XArbListener(types type, int listenPort): base(listenPort)
		{			
			Initialize(type);
		}
		public XArbListener(types type, int listenPort, string name, int Delay, int MaxConnection) : base(listenPort, Delay, MaxConnection)
		{	ListnerName = name;
			Initialize(type);
		}

		private void Initialize(types type)
		{
			listenerType=type;
			int availWorkerThreads, availCompletionPortThreads;
			ThreadPool.GetAvailableThreads(out availWorkerThreads, out availCompletionPortThreads);
			if (Global.RO != null)
			{
				Global.RO.Info("Available Worker Threads is:" + availWorkerThreads);
				Global.RO.Info("Available Completion Port Threads is:" + availCompletionPortThreads);
			}
		}

		//Stop the listner
		public override void Stop()
		{
			base.Stop();
			XArbListener.aRE.Set();
		}

		//Clear the slots
		public bool ClearSlots()
		{
			ht.Clear();
			return true;
		}

		//Remove a slot
		public void RemoveSlot(ulong sessionId, ulong sessionNonce)
		{
			ht.Remove(sessionId.ToString("X16")+sessionNonce.ToString("X16"));
		}

		//Get a slot and then remove it
		public bool GetSlot(ulong sessionId, ulong sessionNonce, out SlotData slotData)
		{
			return GetSlot(sessionId, sessionNonce, out slotData, true, new TimeSpan(0,0,0));
		}

		//Get a slot (wait for it) and then remove it
		public bool GetSlot(ulong sessionId, ulong sessionNonce, out SlotData slotData, TimeSpan ts)
		{
			return GetSlot(sessionId, sessionNonce, out slotData, true, ts);
		}

		//Get a slot and leave it
		public bool PeekSlot(ulong sessionId, ulong sessionNonce, out SlotData slotData)
		{
			return GetSlot(sessionId, sessionNonce, out slotData, false, new TimeSpan(0,0,0));
		}

		//Get a slot (wait for it) and leave it
		public bool PeekSlot(ulong sessionId, ulong sessionNonce, out SlotData slotData, TimeSpan ts)
		{
			return GetSlot(sessionId, sessionNonce, out slotData, false, ts);
		}

		//Slot get/peek helper
		protected bool GetSlot(ulong sessionId, ulong sessionNonce, out SlotData slotData, bool destroy, TimeSpan ts)
		{
			slotData=null;

			//Look up the item with the key or wait
			object obj=null;
			obj=ht[sessionId.ToString("X16")+sessionNonce.ToString("X16")];
			long waitTicks = ts.Ticks;
			long startTime = DateTime.Now.Ticks;
			while ((obj==null)&&(waitTicks>0))
			{
				XArbListener.aRE.WaitOne(new TimeSpan(waitTicks),true);
				string key = sessionId.ToString("X16")+sessionNonce.ToString("X16");
				obj=ht[sessionId.ToString("X16")+sessionNonce.ToString("X16")];
				if (obj==null)
				{	
					waitTicks-=DateTime.Now.Ticks-startTime;
				}
			}
			if (obj==null)
			{
				return false;
			}

			slotData=(SlotData)obj;

			if (destroy)
			{
				RemoveSlot(sessionId, sessionNonce);
			}

			return true;
		}
		
		//Parse the incoming request an store it
		public override bool ProcessData(byte[] bytes,int bundleIndex, int contentLength)
		{
			System.Diagnostics.Debug.WriteLine("XArbListener: Entered ProcessData()");
			bool retval= false;
			string sessionidnonce=null;
			uint bundleSize=0;
			byte[] tmpBytes=null;
			System.Text.ASCIIEncoding AE=new System.Text.ASCIIEncoding();
			string sURL = AE.GetString(bytes,0,bundleIndex);

			bool parseevertthing= true;

			//Allocate new Bundle of Data to store
			Match match = null;
			SlotData sd = new SlotData();

			

			try
			{
				//Get SessionId, Nonce and Bundle Length from the URL
				match = _regexSessionIdNonce.Match(sURL);
				if (match.Success)
				{
					sessionidnonce=match.Groups["sessionidnonce"].Value;
					bundleSize=System.UInt32.Parse(match.Groups["bundlesize"].Value,System.Globalization.NumberStyles.HexNumber);
				}
				else
				{
					Global.RO.Error("regex match for sessionidnonce failed");
					return false ;
				}

				if(XArbListener.IsStress)
				{
					// Validate the response from the server 5% of the time
					int val = RandomGen.Next(0,20);
					if (val < 19)
					{
						parseevertthing = false;
					}
				}

				if(parseevertthing)
				{
					//Store Auth Data
					match = _regexBundledAuthData.Match(sURL);
					if (match.Success)
					{
						sd.authData=new BundledAuthData(match.Groups["authdata"].ToString());
					}
					//Store the bundle
					if ((bundleIndex>=0) && (bundleSize<=contentLength))
					{
						sd.bundle=new byte[bundleSize];
						Array.Copy(bytes,bundleIndex,sd.bundle,0,bundleSize);
					}
					else
					{
						Global.RO.Error("Store the bundle failed");
						return  false;
					}

					//Store team tickets if we have them
					if (contentLength>bundleSize)
					{
						tmpBytes=new byte[contentLength-bundleSize];
						Array.Copy(bytes,bundleIndex+bundleSize,tmpBytes,0,contentLength-bundleSize);
					}
					if(!XArbListener.IsStress)
					{
						ht[sessionidnonce]=sd;
						XArbListener.aRE.Set();
						retval= true;
					}
					//Global.RO.Info("Validation succeeded");
				}

				//Add bundle data to hashtable
			
				//ConsoleX.ClearLine();
				//ConsoleX.WriteLine(listenerType.ToString()+" bundle received. Size: "+sd.bundle.Length);
				
				if(XArbListener.IsStress)
				{
					retval= true;

					if(XArbListener.Stressht.Contains(sessionidnonce))
					{
						XArbListener.Stressht.Remove(sessionidnonce);
					}
					else
					{
						return(retval);
					}

					if(parseevertthing)
					{
						//verify if the packet is correct here...
						Stressbundle Data =(Stressbundle) new Stressbundle().ReadBytes(sd.bundle);
						//check if all users are correct.
						Hashtable users = new Hashtable();
	
						if(Data.Users.Length != sd.authData.users.Length)
							Global.RO.Error("user count do not match");
					
						for(int i=0;i< sd.authData.users.Length;i++)
						{
							users.Add(sd.authData.users[i].qwUserID,null);
							
						}
						for(int i=0;i< Data.Users.Length;i++)
						{
							if(!users.Contains(Data.Users[i]))
								Global.RO.Error("user Does not exist :" +Data.Users[i] );
						}
					}
				
					

				}
			}
			catch(Exception  e )
			{
				Global.RO.Error("ProcessData threw exception:");
				Global.RO.Error(e.ToString());
				Global.RO.Error(bytes.ToString());
				retval= false;
			}

			return  retval;
		}

		
		// menu handler that can be used to change stress options.
		public void OptionHandler(Object sender, System.EventArgs e) 
		{
			// Code goes here that handles the Click event.
			HandlerOptions tmp = new HandlerOptions();
			tmp.Delay.Text=  delay.ToString();
			tmp.MaxConn.Text= maxCon.ToString();
			tmp.textBox1.Text= PercentError.ToString();
			tmp.CurrentConn.Text= Handlers.ToString();

			if(IsRunning)
				tmp.OptStartStop.Text= "Stop "+ListnerName+" Listner";
			else
				tmp.OptStartStop.Text= "Start "+ListnerName+" Listner ";
			if(tmp.ShowDialog()==DialogResult.OK)
			{
				lock(this)
				{
					delay=Convert.ToInt32(tmp.Delay.Text);
					int tmpmaxconn = Convert.ToInt32(tmp.MaxConn.Text);
					
					if(tmpmaxconn<maxCon)
					{
						maxCon=tmpmaxconn;
						Stop();
						Go();

					}
					else
						maxCon=tmpmaxconn;

					if(tmp.OptStartStop.Checked)
					{
						if(IsRunning)
						{
							IsRunning=false;
							Stop();
						}
						else
						{
							IsRunning=true;
							Go();
						}
					}
					int error = Convert.ToInt32(tmp.textBox1.Text);
					if(error>=0)
						PercentError=error;

				}
				
			}
		}




		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Alerts\XEvents.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Security;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.IO;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Alerts
{
	/// <summary>
	/// Wiredata for sending Alerts.
	/// </summary>
	public class XEvents:WireData
	{
		public const uint XONLINE_MAX_ALERT_SIZE = 1432;

		/// <summary>
		/// Alert Types
		/// </summary>
		sealed public class Types
		{
			public const ushort TitleCustom=0x0001;
			public const ushort FriendRequest=0x0002;
			public const ushort GameInvite=0x0003;
			public const ushort TeamRecruit=0x0004;
			public const ushort CompReminder=0x0005;
			public const ushort CompRequest=0x0006;
			public const ushort LiveMessage=0x0007;
			public const ushort Logon=0x0100;
			public const ushort Unknown=0x00FE;
		}

		/// <summary>
		/// System.Net.Sockets.UdpClient override to expose socket's client 
		/// </summary>
		private MyUdpClient localClient;
		protected class MyUdpClient : System.Net.Sockets.UdpClient
		{
			public ushort Bind()
			{
				Client.Bind(new IPEndPoint(IPAddress.Any, 0));
				return (ushort)((IPEndPoint)Client.LocalEndPoint).Port;
			}
			public new Socket Client 
			{
				get
				{
					return base.Client;
				}
			}
		}

		/// <summary>
		/// Used for unicode string conversions
		/// </summary>
		private new static UnicodeEncoding unicodeEnc = new UnicodeEncoding();

		/// <summary>
		/// Controls whether the connection to the xevent service is dropped after each udp transmit
		/// </summary>
		[WireInfoAttribute(Serialize=false)]
		public bool fDisconnectAfterTransmit=true;

		/// <summary>
		/// Serialized WireData
		/// </summary>
		public uint	titleId=XOn.DASH_TITLE_ID;
		public ushort type=0;
		public ushort flags=0;
		public ushort recipientsLen=0;
		public byte senderGamertagLen=0;
		public byte dataLen=0;
		public ulong senderUserId=0UL;
		public XEventsRecipients[] recipients=null;
		[WireInfoAttribute(UnicodeEncoded=true)]
		public char[] data;
		public string senderGamertag;

		/// <summary>
		/// Accessor: sets recipients and zeros out length for re-serialization
		/// </summary>
		public XEventsRecipients[] Recipients
		{
			set 
			{
				recipients = value;
				recipientsLen = 0;
			}
		}

		/// <summary>
		/// Accessor: converts standard string into unicode; then stores it for serialization.  Zero's out length for re-serialization.
		/// </summary>
		public string Data
		{
			set 
			{
				dataLen = 0;
				if (null!=value)
				{
					data=value.ToCharArray();
				}
				else
				{
					data=null;
				}
			}
			get
			{
				return new String(data);
			}
		}

		/// <summary>
		/// Accessor: sets gamertag and zeros out length for re-serialization
		/// </summary>
		public string SenderGamertag
		{
			set
			{
				senderGamertag=value;
				senderGamertagLen = 0;
			}
		}

		/// <summary>
		/// Destructor ensures connectioned is dropped during garbage collection at least.
		/// </summary>
		~XEvents()
		{
			Disconnect();
		}

		/// <summary>
		/// Call this when you are done with the object
		/// </summary>
		public void UnInitialize()
		{
			Disconnect();
		}

		/// <summary>
		/// Connects to an endpoint or switches endpoints on the fly
		/// </summary>
		/// <param name="endPoint"></param>
		/// <returns></returns>
		protected bool Connect(IPEndPoint endPoint)
		{
			bool retval = true;

			if ((localClient!=null) && (localClient.Client!=null))
			{
				IPEndPoint localEndPoint = (IPEndPoint)localClient.Client.RemoteEndPoint;
				if ((localClient.Client.Connected) && (true==endPoint.Address.Equals(localEndPoint.Address))) return true;
			}

			Disconnect();
			localClient=new MyUdpClient();
			if ((null==localClient) || (null==localClient.Client))
			{
				return false;
			}

			localClient.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReceiveTimeout,35000);
			localClient.Client.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.SendTimeout,35000);

			try
			{
				localClient.Bind();
				localClient.Connect(endPoint);
			}
			catch(SocketException)
			{
				//An error occurred when attempting to access the socket.
				retval=false;
			}
			catch(ArgumentNullException)
			{
				//Bind: localEP is a null reference.
				//Connect: endPoint is a null reference.
				retval=false;
			}
			catch (ObjectDisposedException)
			{
				//The Socket has been closed.
				retval=false;
			}
			catch (SecurityException)
			{
				//Bind Only: A caller higher in the call stack does not have permission for the requested operation
				retval=false;
			}
			return retval;
		}

		/// <summary>
		/// Disconnects from and endpoint
		/// </summary>
		/// <returns></returns>
		protected bool Disconnect()
		{
			try
			{
				if ((localClient!=null) && (localClient.Client!=null) && (localClient.Client.Connected))
				{
					localClient.Close();
				}
			}
			catch (SocketException)
			{
				//An error occurred when accessing the socket
			}
			return true;
		}

		/// <summary>
		/// Serialize data to wire with default STF XEvent server
		/// </summary>
		/// <returns>
		/// Success or Failure
		/// </returns>
		public bool Execute()
		{
			return Execute(Global.XEnv.GetInterface(Interface.xevents)[0]);
		}

		/// <summary>
		/// Serialize data to wire
		/// </summary>
		/// <param name="sServer">
		/// LiveServer object to server target
		/// </param>
		/// <returns>
		/// Success or failure
		/// </returns>
		public bool Execute(LiveServer sServer)
		{
			return Execute(sServer.EPDefault);
		}

		/// <summary>
		/// Serialize data to wire
		/// </summary>
		/// <param name="endPoint">
		/// IPEndPoint object to server target
		/// </param>
		/// <returns>
		/// Success or failure
		/// </returns>
		public bool Execute(IPEndPoint endPoint)
		{
			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );
			
			if (false==Connect(endPoint))
			{
				return false;
			}

			byte []data=reqStream.ToArray();
			localClient.Send(data,data.Length);

			if (fDisconnectAfterTransmit)
			{
				Disconnect();
			}

			return true;
		}

	}

	/// <summary>
	/// Wiredata portion for recipients of alert
	/// </summary>
	public class XEventsRecipients : WireData
	{
		public ulong webId;
		public ulong userId;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Arbitration\XRLRegister.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Arbitration
{
	/// <summary>
	/// Arbitration Register request XRLPayload.
	/// </summary>
	public class XRLRegister : XRLPayload
	{
		sealed public class Flags
		{
			public const ushort IsTournament=0x0001;
			public const ushort TimeExtendable=0x0002;
			public const ushort HostForwardsPackets=0x0004;
			public const ushort TeamMembershipInfoIncluded=0x0008;
			public const ushort SessionIsFreeForAll=0x0010;
			public const ushort PublisherBasedTournament=0x0020;

			public const ushort flagMask=IsTournament|TimeExtendable|HostForwardsPackets|TeamMembershipInfoIncluded|SessionIsFreeForAll|PublisherBasedTournament;
		}

		public ushort protocolVersion=1;
		public ushort flags=0;
		[XRLPayloadFld(IsTitleId=true)]
		public uint titleId=XOn.DASH_TITLE_ID;
		public ulong sessionId=0UL;
		public ulong sessionNonce=0UL;
		public ushort maxSessionSeconds=0;
		[XRLPayloadFld(Serialize=false)]
		public ulong[] userPuid = new ulong[4] {0UL,0UL,0UL,0UL};
		[XRLPayloadFld(Serialize=false)]
		public uint[] userFlag = new uint[4] {0,0,0,0};
		[XRLPayloadFld(Serialize=false)]
		public float[] userTrust = new float[4] {0.0f,0.0f,0.0f,0.0f,};
		[XRLPayloadFld(Serialize=false)]
		public ulong machinePuid=defaultMPuid;
		[XRLPayloadFld(Serialize=false)]
		public static bool fFrontDoor=true;

		public const float DEFAULT_USER_TRUST = 0.0f;
		public const uint DEFAULT_USER_FLAGS = 0x00000000;
		public const ushort DEFAULT_SESSION_SECONDS = 120;

		public XRLRegister()
		{
			ServiceId=XOService.Arbitration;
		}

        public byte[] ToByteArray()
        {
            System.IO.MemoryStream s = new MemoryStream();
            this.WriteStream(s);
            byte[] dest = new byte[s.Length];
            int pos = 0;
            int b;
            while ((b = s.ReadByte()) != -1)
            {
                dest[pos++] = (byte)b;
            }
            return(dest);
        }

		public XRLRegister DeepClone()
		{
			// Start with a shallow clone
			XRLRegister clone = (XRLRegister)this.MemberwiseClone();
			// Clone XRLPayload objects
			XRLPayload clonePayload = (XRLPayload)clone;
			base.DeepCloneTo(ref clonePayload);
			// Clone XRLRegister objects
			clone.userPuid = (ulong[])this.userPuid.Clone();
			clone.userFlag = (uint[])this.userFlag.Clone();
			clone.userTrust = (float[])this.userTrust.Clone();
			return(clone);
		}

		public override bool Execute()
		{
			//return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
			//TimeBomb bomb = new TimeBomb(1000);
			//bomb.Start();
			bool retval = Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
			//bomb.Stop();
			return retval;
		}

		public XRLRegister(ArbitrationSession session, ulong aUserPuid, uint titleId, uint flags)
		{
			ServiceId = XOService.Arbitration;
			userPuid[0] = aUserPuid;
			userTrust[0] = DEFAULT_USER_TRUST;
			userFlag[0] = DEFAULT_USER_FLAGS;
			maxSessionSeconds = DEFAULT_SESSION_SECONDS;
			_SetSession(session);
		}

		public XRLRegister(ArbitrationSession session, ulong []userPuids, uint count)
		{
			ServiceId = XOService.Arbitration;
			for(uint i = 0; i < count; ++i) 
			{
				userPuid[i] = userPuids[i];
				userTrust[i] = DEFAULT_USER_TRUST;
				userFlag[i] = DEFAULT_USER_FLAGS;
			}
			maxSessionSeconds = DEFAULT_SESSION_SECONDS;
			_SetSession(session);
		}

		protected void _SetSession(ArbitrationSession session)
		{
			titleId = session.TitleId;
			sessionId = session.SessionId;
			sessionNonce = session.SessionNonce;
			flags = session.Flags;
		}

		public override byte[] GenerateHttpHeader(IPEndPoint endPoint, MemoryStream reqStream)
		{
			//Early out for front door communication
			if (fFrontDoor) return base.GenerateHttpHeader(endPoint,reqStream);

			//Get the base header and strip off the terminator
			System.Text.ASCIIEncoding AE=new System.Text.ASCIIEncoding();
			string sURL = AE.GetString(base.GenerateHttpHeader(endPoint,reqStream));
			StringBuilder sbURL = new StringBuilder(sURL);
			if (sbURL.Length>=2)
			{
				sbURL.Remove(sbURL.Length-2,2);  //strip last /r/n off
			}

			//Conversions
			ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
			byte [] addr = endPoint.Address.GetAddressBytes();
			uint ip=0;
			for(int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];
			XUIDAndTrust[] xuids = new XUIDAndTrust[userPuid.Length];
			for(int i=0;i<userPuid.Length;i++)
				xuids[i]=new XUIDAndTrust(userPuid[i],userFlag[i],userTrust[i]);

			//Attach HTTP AUTH DATA to headers
			HTTPAuthData authData = new HTTPAuthData((ushort) endPoint.Port,ip,requestId,machinePuid,xuids,this.titleId,(uint)XOService.Arbitration,0);
			sbURL.Append(HTTPAuthData.HTTP_HEADER_AUTH_DATA+":"+authData.GetBase64EncodedString()+"\r\n");
			sbURL.Append("\r\n");
			byte[] Header=AE.GetBytes(sbURL.ToString());
			return Header;
		}

		protected override void SetServices()
		{
			base.SetServices ();
			Slot.AddService(XOService.Arbitration);
		}

		protected override string GetServiceName()
		{
			if (fFrontDoor)
				return @"/xarb/Register.ashx";
			return @"/xarbINH/Register.ashx";
		}

		[XRLPayloadFld(Serialize=false)]
		public XRLRegisterResponse Response=null;

		protected override void ReadResponse(System.IO.MemoryStream responseStream)
		{
			Response=new XRLRegisterResponse();
			Response.ReadStream(responseStream);
		}

		public override void PopulateSlot(ref CSGInfo slot)
		{
			//Early out for In-House communication
			if (!fFrontDoor) return;

			//base.PopulateSlot(ref slot);
			this.SetServices();
			// By default, let's say the user exists.  Tests can override this variable if necessary.
			Slot.UserExists = 1;
			slot.titleId = titleId;

			//Arbitration server pulls machine puid, user puid, user flags, and user trust from auth request
			slot.machinePuid=machinePuid;
			slot.userPuid0=userPuid[0];
			slot.userFlag0=userFlag[0];
			slot.userTrust0=userTrust[0];
			slot.userPuid1=userPuid[1];
			slot.userFlag1=userFlag[1];
			slot.userTrust1=userTrust[1];
			slot.userPuid2=userPuid[2];
			slot.userFlag2=userFlag[2];
			slot.userTrust2=userTrust[2];
			slot.userPuid3=userPuid[3];
			slot.userFlag3=userFlag[3];
			slot.userTrust3=userTrust[3];

			this.ManualSlotSetup = true;
		}
	}

	/// <summary>
	/// Arbitration Register response wiredata
	/// </summary>
	public class XRLRegisterResponse : WireData
	{
		public ushort registeredXboxLen=0;
		public RegisteredXbox[] registeredXbox=null;

		public override WireData ReadStream(BinaryReader binaryReader)
		{
			registeredXboxLen = binaryReader.ReadUInt16();
			registeredXbox = new RegisteredXbox[registeredXboxLen];
			for (int i = 0; i < registeredXboxLen; i++)
			{
				registeredXbox[i] = new RegisteredXbox();
				registeredXbox[i].ReadStream(binaryReader);
			}
			return(this);
		}
	}

	/// <summary>
	/// Arbitration Register response RegisteredXbox wiredata 
	/// </summary>
	public class RegisteredXbox : WireData
	{
		public ulong puid=0UL;
		public byte trustworthyness=0;
		public byte registeredUserLen=0;
		public RegisteredUser[] registeredUser=null;

		public override WireData ReadStream(BinaryReader binaryReader)
		{
			puid = binaryReader.ReadUInt64();
			trustworthyness = binaryReader.ReadByte();
			registeredUserLen = binaryReader.ReadByte();
			registeredUser = new RegisteredUser[registeredUserLen];
			for (int i = 0; i < registeredUserLen; i++)
			{
				registeredUser[i] = new RegisteredUser();
				registeredUser[i].ReadStream(binaryReader);
			}
			return(this);
		}
	}

	/// <summary>
	/// Arbitration Register repsonse RegisteredUser wiredata 
	/// </summary>
	public class RegisteredUser : WireData
	{
		//XUID
		public ulong userId=0UL;
		public uint flags=0;

		public override WireData ReadStream(BinaryReader binaryReader)
		{
			userId = binaryReader.ReadUInt64();
			flags = binaryReader.ReadUInt32();
			return(this);
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Arbitration\XRLReportResult.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Arbitration
{
	/// <summary>
	/// Arbitration ReportResult request XRLPayload.
	/// </summary>
	public class XRLReportResult : XRLPayload
	{
		sealed public class Flags
		{
			public const ushort VoluntarilyQuit=0x8000;
			public const ushort SessionHost=0x4000;
			public const ushort LostConnectivity=0x2000;
			public const ushort LostConnectivityInfoSubmit=0x1000;
			public const ushort SuspiciousInfo1Submit=0x0800;
			public const ushort SuspiciousInfo2Submit=0x0400;
			public const ushort SuspiciousInfo3Submit=0x0200;
			public const ushort StatsBundleInfoSubmit=0x0100;
			public const ushort TournamentBundleInfoSubmit=0x0080;

			public const ushort flagMask=VoluntarilyQuit|SessionHost|LostConnectivity|LostConnectivityInfoSubmit|SuspiciousInfo1Submit|SuspiciousInfo2Submit|SuspiciousInfo3Submit|StatsBundleInfoSubmit|TournamentBundleInfoSubmit;

		}

		public ushort protocolVersion=1;
		public ushort flags=0;
		[XRLPayloadFld(IsTitleId=true)]
		public uint titleId=XOn.DASH_TITLE_ID;
		public ulong sessionId=0UL;
		public ulong sessionNonce=0UL;
		public LostConnectivityInfo lostConnectivityInfo=null;
		public SuspiciousInfo type1SuspiciousInfo=null;
		public SuspiciousInfo type2SuspiciousInfo=null;
		public SuspiciousInfo type3SuspiciousInfo=null;
		public StatsBundle statsBundle=null;
		public TournamentBundle tournamentBundle=null;

		[XRLPayloadFld(Serialize=false)]
		public ulong machinePuid=defaultMPuid;
		[XRLPayloadFld(Serialize=false)]
		public IPEndPoint AlternateStatsDestination=null;
		[XRLPayloadFld(Serialize=false)]
		public IPEndPoint AlternateQueryDestination=null;

		[XRLPayloadFld(Serialize=false)]
		public int UdpReceiveTimeOut = 35000;
		[XRLPayloadFld(Serialize=false)]
		public static bool fFrontDoor=true;

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			binaryWriter.Write(protocolVersion);
			binaryWriter.Write(flags);
			binaryWriter.Write(titleId);
			binaryWriter.Write(sessionId);
			binaryWriter.Write(sessionNonce);
			if (lostConnectivityInfo != null)
			{
				lostConnectivityInfo.WriteStream(binaryWriter);
			}
			if (type1SuspiciousInfo != null)
			{
				type1SuspiciousInfo.WriteStream(binaryWriter);
			}
			if (type2SuspiciousInfo != null)
			{
				type2SuspiciousInfo.WriteStream(binaryWriter);
			}
			if (type3SuspiciousInfo != null)
			{
				type3SuspiciousInfo.WriteStream(binaryWriter);
			}
			if (statsBundle != null)
			{
				statsBundle.WriteStream(binaryWriter);
			}
			if (tournamentBundle != null)
			{
				tournamentBundle.WriteStream(binaryWriter);
			}
		}

		public XRLReportResult()
		{
			ServiceId=XOService.Arbitration;
			transport=FDTransaction.Transports.TCP;	
		}

		public XRLReportResult DeepClone()
		{
			// Start with a shallow clone
			XRLReportResult clone = (XRLReportResult)this.MemberwiseClone();
			// Clone XRLPayload objects
			XRLPayload clonePayload = (XRLPayload)clone;
			base.DeepCloneTo(ref clonePayload);
			// Clone XRLReportResult objects
			if (this.lostConnectivityInfo != null)
			{
				clone.lostConnectivityInfo = this.lostConnectivityInfo.DeepClone();
			}
			if (this.type1SuspiciousInfo != null)
			{
				clone.type1SuspiciousInfo = this.type1SuspiciousInfo.DeepClone();
			}
			if (this.type2SuspiciousInfo != null)
			{
				clone.type2SuspiciousInfo = this.type2SuspiciousInfo.DeepClone();
			}
			if (this.type3SuspiciousInfo != null)
			{
				clone.type3SuspiciousInfo = this.type3SuspiciousInfo.DeepClone();
			}
			if (this.statsBundle != null)
			{
				clone.statsBundle = this.statsBundle.DeepClone();
			}
			if (this.tournamentBundle != null)
			{
				clone.tournamentBundle = this.tournamentBundle.DeepClone();
			}
			if (this.AlternateStatsDestination != null)
			{
				clone.AlternateStatsDestination = (IPEndPoint)this.AlternateStatsDestination.Create(this.AlternateStatsDestination.Serialize());
			}
			if (this.AlternateQueryDestination != null)
			{
				clone.AlternateQueryDestination = (IPEndPoint)this.AlternateQueryDestination.Create(this.AlternateQueryDestination.Serialize());
			}
			return(clone);
		}

		public override bool Execute()
		{
			//return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
			//ServerTestFramework.Utilities.TimeBomb bomb = new ServerTestFramework.Utilities.TimeBomb(1000);
			//bomb.Start();
			bool retval = Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
			//bomb.Stop();
			return retval;
		}

		public override bool Execute(IPEndPoint endPoint)
		{
			if (fFrontDoor==false)
			{
				xAct.transport=FDTransaction.Transports.TCP;
			}
			else
			{
				switch (transport)
				{
					case FDTransaction.Transports.TCP:
						xAct.transport=FDTransaction.Transports.TCP;
						break;
					case FDTransaction.Transports.UDP:
						xAct.transport=FDTransaction.Transports.UDP;
						xAct.ReceiveTimeOut=UdpReceiveTimeOut;
						xAct.IgnoreUDPReceive=IgnoreUDPReceive;
						break;
				}
			}
			return base.Execute(endPoint);
		}

		protected override void SetServices()
		{
			base.SetServices ();
			Slot.AddService(XOService.Arbitration);
		}

		protected override string GetServiceName()
		{
			if (fFrontDoor)
				return @"/xarb/ReportResult.ashx";
			return @"/xarbINH/ReportResult.ashx";
		}

		public override void PopulateSlot(ref CSGInfo slot)
		{
			//Early out for In-House communication
			if (!fFrontDoor) return;

			//base.PopulateSlot(ref slot);
			this.SetServices();
			// By default, let's say the user exists.  Tests can override this variable if necessary.
			Slot.UserExists = 1;
			slot.titleId = titleId;

			//Arbitration server pulls machine puid from auth request
			slot.machinePuid=machinePuid;

			this.ManualSlotSetup = true;
		}

		public override byte[] GenerateHttpHeader(IPEndPoint endPoint, MemoryStream reqStream)
		{
			if ((AlternateStatsDestination == null) && (AlternateQueryDestination == null) && (fFrontDoor))
			{
				return base.GenerateHttpHeader(endPoint,reqStream);
			}

			System.Text.ASCIIEncoding AE=new System.Text.ASCIIEncoding();
			string sURL = AE.GetString(base.GenerateHttpHeader(endPoint,reqStream));
			StringBuilder sbURL = new StringBuilder(sURL);
			if (sbURL.Length>=2)
			{
				sbURL.Remove(sbURL.Length-2,2);  //strip last /r/n off
			}
			if ((AlternateStatsDestination != null) && (this.statsBundle != null) && (this.statsBundle.bundle != null))
			{
				sbURL.Append("AlternateStatsDestination: http://"+AlternateStatsDestination.Address.ToString()+
					":"+AlternateStatsDestination.Port.ToString()+
					"/S"+
					this.sessionId.ToString("X16")+ this.sessionNonce.ToString("X16")+this.statsBundle.bundle.GetLength(0).ToString("X8")+
					".ashx\r\n");
/*
				System.Diagnostics.Debug.WriteLine("GenerateHttpHeader: AlternateStatsDestination: http://"+AlternateStatsDestination.Address.ToString()+
					":"+AlternateStatsDestination.Port.ToString()+
					"/S"+
					this.sessionId.ToString("X16")+ this.sessionNonce.ToString("X16")+this.statsBundle.bundle.GetLength(0).ToString("X8")+
					".ashx");
*/
			}
			if ((AlternateQueryDestination != null) && (this.tournamentBundle != null) && (this.tournamentBundle.bundle != null))
			{
				sbURL.Append("AlternateQueryDestination: http://"+AlternateQueryDestination.Address.ToString()+
					":"+AlternateQueryDestination.Port.ToString()+
					"/Q"+
					this.sessionId.ToString("X16")+ this.sessionNonce.ToString("X16")+this.tournamentBundle.bundle.GetLength(0).ToString("X8")+
					".ashx\r\n");
/*
				System.Diagnostics.Debug.WriteLine("GenerateHttpHeader: AlternateQueryDestination: http://"+AlternateQueryDestination.Address.ToString()+
					":"+AlternateQueryDestination.Port.ToString()+
					"/Q"+
					this.sessionId.ToString("X16")+ this.sessionNonce.ToString("X16")+this.tournamentBundle.bundle.GetLength(0).ToString("X8")+
					".ashx");
*/
			}

			if (!fFrontDoor)
			{
				//Conversions
				ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
				byte [] addr = endPoint.Address.GetAddressBytes();
				uint ip=0;
				for(int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];

				//Attach HTTP AUTH DATA to headers
				HTTPAuthData authData = new HTTPAuthData((ushort) endPoint.Port,ip,requestId,0,this.titleId,(uint)XOService.Arbitration,0);
				authData.qwXboxID=this.machinePuid;
				sbURL.Append(HTTPAuthData.HTTP_HEADER_AUTH_DATA+":"+authData.GetBase64EncodedString()+"\r\n");

				//UDP?
				if (transport==FDTransaction.Transports.UDP)
				{
					sbURL.Append("AdaptedFromUDP: Yes\r\n");
				}
			}

			sbURL.Append("\r\n");
			byte[] Header=AE.GetBytes(sbURL.ToString());
			return Header;
		}
	}

	/// <summary>
	/// Arbitration ReportResult request LostConnectivityInfo wiredata
	/// </summary>
	public class LostConnectivityInfo : WireData
	{
		public byte xboxPuidLen=0;
		public ulong[] xboxPuid=null;

		public LostConnectivityInfo DeepClone()
		{
			LostConnectivityInfo clone = (LostConnectivityInfo)this.MemberwiseClone();
			if (xboxPuid != null)
			{
				clone.xboxPuid = (ulong[])this.xboxPuid.Clone();
			}
			return(clone);
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			if (xboxPuid != null)
			{
				xboxPuidLen = (byte)xboxPuid.Length;
				binaryWriter.Write(xboxPuidLen);
				foreach (ulong puid in xboxPuid)
				{
					binaryWriter.Write(puid);
				}
			}
			else
			{
				binaryWriter.Write(xboxPuidLen);
			}
		}
	}
	
	/// <summary>
	/// Arbitration ReportResult request SuspiciousInfo wiredata
	/// </summary>
	public class SuspiciousInfo : WireData
	{
		public byte messageLen=0;
		public byte[] message=null;
		public byte relatedXboxLen=0;
		public ulong[] relatedXbox=null;
		public byte relatedUserLen=0;
		public ulong[] relatedUser=null;

		public SuspiciousInfo DeepClone()
		{
			SuspiciousInfo clone = (SuspiciousInfo)this.MemberwiseClone();
			if (message != null)
			{
				clone.message = (byte[])this.message.Clone();
			}
			if (relatedXbox != null)
			{
				clone.relatedXbox = (ulong[])this.relatedXbox.Clone();
			}
			if (relatedUser != null)
			{
				clone.relatedUser = (ulong[])this.relatedUser.Clone();
			}
			return(clone);
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			if (message != null)
			{
				messageLen = (byte)message.Length;
				binaryWriter.Write(messageLen);
				binaryWriter.Write(message);
			}
			else
			{
				binaryWriter.Write(messageLen);
			}

			if (relatedXbox != null)
			{
				relatedXboxLen = (byte)relatedXbox.Length;
				binaryWriter.Write(relatedXboxLen);
				foreach (ulong xbox in relatedXbox)
				{
					binaryWriter.Write(xbox);
				}
			}
			else
			{
				binaryWriter.Write(relatedXboxLen);
			}

			if (relatedUser != null)
			{
				relatedUserLen = (byte)relatedUser.Length;
				binaryWriter.Write(relatedUserLen);
				foreach (ulong user in relatedUser)
				{
					binaryWriter.Write(user);
				}
			}
			else
			{
				binaryWriter.Write(relatedUserLen);
			}
		}
	}

	/// <summary>
	/// Arbitration ReportResult request StatsBundle wiredata
	/// </summary>
	public class StatsBundle : WireData
	{
		public uint bundleLen=0;
		public byte[] bundle=null;

		public StatsBundle DeepClone()
		{
			StatsBundle clone = (StatsBundle)this.MemberwiseClone();
			if (bundle != null)
			{
				clone.bundle = (byte[])this.bundle.Clone();
			}
			return(clone);
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			if (bundle != null)
			{
				bundleLen = (uint)bundle.Length;
				binaryWriter.Write(bundleLen);
				binaryWriter.Write(bundle);
			}
			else
			{
				binaryWriter.Write(bundleLen);
			}
		}
	}

	/// <summary>
	/// Arbitration ReportResult request TournamentBundle wiredata
	/// </summary>
	public class TournamentBundle : WireData
	{
		public uint bundleLen=0;
		public byte[] bundle=null;

		public TournamentBundle DeepClone()
		{
			TournamentBundle clone = (TournamentBundle)this.MemberwiseClone();
			if (bundle != null)
			{
				clone.bundle = (byte[])this.bundle.Clone();
			}
			return(clone);
		}

		public override void WriteStream(BinaryWriter binaryWriter)
		{
			if (bundle != null)
			{
				bundleLen = (uint)bundle.Length;
				binaryWriter.Write(bundleLen);
				binaryWriter.Write(bundle);
			}
			else
			{
				binaryWriter.Write(bundleLen);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Alerts\AlertsSQL.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Text.RegularExpressions;
using System.ServiceProcess;

namespace ServerTestFramework.LiveService.Alerts
{
	/// <summary>
	/// Access object for Alerts SQL databases xboxNSMain and xboxAlerts.
	/// </summary>
	public class AlertsSQL
	{
		/// <summary>
		/// Alerts databases
		/// </summary>
		private const string c_instanceDB = "xboxNSMain";
		private const string c_applicationDB = "xboxAlerts";

		/// <summary>
		/// Database connection instances
		/// </summary>
		protected SqlConnection m_instanceConnection;
		protected SqlConnection m_applicationConnection;

		/// <summary>
		/// Name of physical box that alerts databases reside on
		/// </summary>
		protected string m_ServerName;

		/// <summary>
		/// Constructor
		/// </summary>
		public AlertsSQL(){}

		/// <summary>
		/// Destructor ensures that database connection is closed
		/// </summary>
		~AlertsSQL()
		{
			Close();
		}

		/// <summary>
		/// Formats a subscriber id ulong into 0x########:0x########
		/// </summary>
		/// <param name="subscriberId"></param>
		/// <returns></returns>
		public static string FormatSubscriberId(ulong subscriberId)
		{
			string  strSubscriberId;
			uint    high;
			uint    low;

			high = (uint)(subscriberId >> 32);
			low = (uint)subscriberId;
            
			strSubscriberId = "0x" + high.ToString("x8") + ":0x" + low.ToString("x8");
            
			return strSubscriberId;
		}

		/// <summary>
		/// Open connections to Alerts databases
		/// </summary>
		/// <param name="_ServerName"></param>
		/// <returns></returns>
		public bool ConnectToServer(string _ServerName)
		{
			bool ret=false;

			m_ServerName=_ServerName;
			m_instanceConnection = new SqlConnection("server="+_ServerName+";database="+c_instanceDB+";Integrated Security=SSPI"); 
			m_applicationConnection = new SqlConnection("server="+_ServerName+";database="+c_applicationDB+";Integrated Security=SSPI"); 

			try
			{
				m_instanceConnection.Open();
				m_applicationConnection.Open();
				ret=true;
			}
			catch
			{
				if ((m_instanceConnection!=null) && (m_instanceConnection.State!=ConnectionState.Closed))
				{
					m_instanceConnection.Close();
					m_instanceConnection=null;
				}
				if ((m_applicationConnection!=null) && (m_applicationConnection.State!=ConnectionState.Closed))
				{
					m_applicationConnection.Close();
					m_applicationConnection=null;
				}
			}

			return ret;
		}

		/// <summary>
		/// Close connections to Alerts databases
		/// </summary>
		public void Close()
		{
			if ((m_instanceConnection!=null) && (m_instanceConnection.State!=ConnectionState.Closed))
			{
				m_instanceConnection.Close();
//				m_instanceConnection=null;		// setting these to null yielded an invalid operation, commenting out for the time being.  .NET can clean up
			}
			if ((m_applicationConnection!=null) && (m_applicationConnection.State!=ConnectionState.Closed))
			{
				m_applicationConnection.Close();
//				m_applicationConnection=null;	// setting these to null yielded an invalid operation, commenting out for the time being.  .NET can clean up
			}
		}

		/// <summary>
		/// Stored procedure wrapper for NSGetProtocols
		/// </summary>
		/// <param name="protocolName"></param>
		/// <param name="className"></param>
		/// <param name="assemblyName"></param>
		/// <returns></returns>
		public bool NSGetProtocols(out string[] protocolName, out string[] className, out string[] assemblyName)
		{
			bool ret=false;
			int index=0;
			protocolName=null;
			className=null;
			assemblyName=null;
			ArrayList aProtocolName = new ArrayList();
			ArrayList aClassName = new ArrayList();
			ArrayList aAssemblyName = new ArrayList();

			lock (m_instanceConnection)
			{
				SqlDataReader myDataReader=null;
				SqlCommand mySqlCommand = new SqlCommand("NSGetProtocols",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;

				try
				{
					myDataReader=mySqlCommand.ExecuteReader();
					while (myDataReader.Read())
					{
						index=0;
						string str=null;
			
						str=myDataReader.GetString(index++);
						aProtocolName.Add(str);
						if (myDataReader.IsDBNull(index++))
						{
							aClassName.Add(null);
						}
						else
						{
							str=myDataReader.GetString(index-1);
							aClassName.Add(str);
						}
						if (myDataReader.IsDBNull(index++))
						{
							aAssemblyName.Add(null);
						}
						else
						{
							str=myDataReader.GetString(index-1);
							aAssemblyName.Add(str);
						}
					}
					ret=true;
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
				finally
				{
					if (myDataReader!=null)
					{
						myDataReader.Close();
						myDataReader=null;
					}
				}
				protocolName=(string[])aProtocolName.ToArray(typeof(string));
				className=(string[])aClassName.ToArray(typeof(string));
				assemblyName=(string[])aAssemblyName.ToArray(typeof(string));
			}
			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSInsertProtocols
		/// </summary>
		/// <param name="protocolName"></param>
		/// <param name="className"></param>
		/// <param name="assemblyName"></param>
		/// <returns></returns>
		public bool NSInsertProtocol(string protocolName, string className, string assemblyName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSInsertProtocol",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@ProtocolName",SqlDbType.NVarChar,255).Value=protocolName;
				mySqlCommand.Parameters.Add("@ClassName",SqlDbType.NVarChar,255).Value=className;
				mySqlCommand.Parameters.Add("@AssemblyName",SqlDbType.NVarChar,255).Value=assemblyName;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSUpdateProtocol
		/// </summary>
		/// <param name="protocolName"></param>
		/// <param name="className"></param>
		/// <param name="assemblyName"></param>
		/// <returns></returns>
		public bool NSUpdateProtocol(string protocolName, string className, string assemblyName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSUpdateProtocol",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@ProtocolName",SqlDbType.NVarChar,255).Value=protocolName;
				mySqlCommand.Parameters.Add("@ClassName",SqlDbType.NVarChar,255).Value=className;
				mySqlCommand.Parameters.Add("@AssemblyName",SqlDbType.NVarChar,255).Value=assemblyName;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSDeleteProtocol
		/// </summary>
		/// <param name="protocolName"></param>
		/// <returns></returns>
		public bool NSDeleteProtocol(string protocolName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand = new SqlCommand("NSDeleteProtocol",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@ProtocolName",SqlDbType.NVarChar,255).Value=protocolName;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSGetDeliveryChannels
		/// </summary>
		/// <param name="deliveryChannelName"></param>
		/// <param name="protocolName"></param>
		/// <returns></returns>
		public bool NSGetDeliveryChannels(out string[] deliveryChannelName, out string[] protocolName)
		{
			bool ret=false;
			int index=0;
			deliveryChannelName=null;
			protocolName=null;
			ArrayList aDeliveryChannelName = new ArrayList();
			ArrayList aProtocolName = new ArrayList();

			lock (m_instanceConnection)
			{
				SqlDataReader myDataReader=null;
				SqlCommand mySqlCommand = new SqlCommand("NSGetDeliveryChannels",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;

				try
				{
					myDataReader=mySqlCommand.ExecuteReader();
					while (myDataReader.Read())
					{
						index=0;
						string str=null;
			
						str=myDataReader.GetString(index++);
						aDeliveryChannelName.Add(str);
						str=myDataReader.GetString(index++);
						aProtocolName.Add(str);
					}
					ret=true;
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
				finally
				{
					if (myDataReader!=null)
					{
						myDataReader.Close();
						myDataReader=null;
					}
				}
				deliveryChannelName=(string[])aDeliveryChannelName.ToArray(typeof(string));
				protocolName=(string[])aProtocolName.ToArray(typeof(string));
			}
			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSInsertDeliveryChannel
		/// </summary>
		/// <param name="deliveryChannelName"></param>
		/// <param name="protocolName"></param>
		/// <returns></returns>
		public bool NSInsertDeliveryChannel(string deliveryChannelName, string protocolName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSInsertDeliveryChannel",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@DeliveryChannelName",SqlDbType.NVarChar,255).Value=deliveryChannelName;
				mySqlCommand.Parameters.Add("@ProtocolName",SqlDbType.NVarChar,255).Value=protocolName;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSUpdateDeliveryChannel
		/// </summary>
		/// <param name="deliveryChannelName"></param>
		/// <param name="protocolName"></param>
		/// <returns></returns>
		public bool NSUpdateDeliveryChannel(string deliveryChannelName, string protocolName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSUpdateDeliveryChannel",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@DeliveryChannelName",SqlDbType.NVarChar,255).Value=deliveryChannelName;
				mySqlCommand.Parameters.Add("@ProtocolName",SqlDbType.NVarChar,255).Value=protocolName;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSDeleteDeliveryChannel
		/// </summary>
		/// <param name="deliveryChannelName"></param>
		/// <returns></returns>
		public bool NSDeleteDeliveryChannel(string deliveryChannelName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand = new SqlCommand("NSDeleteDeliveryChannel",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@DeliveryChannelName",SqlDbType.NVarChar,255).Value=deliveryChannelName;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSGetDeliveryChannelArguments
		/// </summary>
		/// <param name="deliveryChannelName"></param>
		/// <param name="argumentName"></param>
		/// <param name="argumentValue"></param>
		/// <returns></returns>
		public bool NSGetDeliveryChannelArguments(string deliveryChannelName, out string[] argumentName, out string[] argumentValue)
		{
			bool ret=false;
			int index=0;
			argumentName=null;
			argumentValue=null;
			ArrayList aArgumentName = new ArrayList();
			ArrayList aArgumentValue = new ArrayList();

			lock (m_instanceConnection)
			{
				SqlDataReader myDataReader=null;
				SqlCommand mySqlCommand = new SqlCommand("NSGetDeliveryChannelArguments",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@DeliveryChannelName",SqlDbType.NVarChar,255).Value=deliveryChannelName;

				try
				{
					myDataReader=mySqlCommand.ExecuteReader();
					while (myDataReader.Read())
					{
						index=0;
						string str=null;
			
						str=myDataReader.GetString(index++);
						aArgumentName.Add(str);
						str=myDataReader.GetString(index++);
						aArgumentValue.Add(str);
					}
					ret=true;
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
				finally
				{
					if (myDataReader!=null)
					{
						myDataReader.Close();
						myDataReader=null;
					}
				}
				argumentName=(string[])aArgumentName.ToArray(typeof(string));
				argumentValue=(string[])aArgumentValue.ToArray(typeof(string));
			}
			return ret;
		}

		/// <summary>
		/// Calls NSDeliveryChannelArguments store procedure and then retrieves the value for the named argument
		/// </summary>
		/// <param name="deliveryChannelName"></param>
		/// <param name="argumentName"></param>
		/// <param name="argumentValue"></param>
		/// <returns></returns>
		public bool GetDeliveryChannelArgumentValue(string deliveryChannelName, string argumentName, out string argumentValue)
		{
			string[] names=null;
			string[] values=null;
			argumentValue=null;

			if (!NSGetDeliveryChannelArguments(deliveryChannelName, out names, out values)) return false;
			for (int i=0; i<names.Length; i++)
			{
				if (names[i].ToLower().CompareTo(argumentName.ToLower())==0)
				{
					argumentValue=values[i];
					return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Stored procedure wrapper for NSInsertDeliveryChannelArgument
		/// </summary>
		/// <param name="deliveryChannelName"></param>
		/// <param name="argumentName"></param>
		/// <param name="argumentValue"></param>
		/// <returns></returns>
		public bool NSInsertDeliveryChannelArgument(string deliveryChannelName, string argumentName, string argumentValue)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSInsertDeliveryChannelArgument",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@DeliveryChannelName",SqlDbType.NVarChar,255).Value=deliveryChannelName;
				mySqlCommand.Parameters.Add("@ArgumentName",SqlDbType.NVarChar,255).Value=argumentName;
				mySqlCommand.Parameters.Add("@ArgumentValue",SqlDbType.NVarChar,4000).Value=argumentValue;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSUpdateDeliveryChannelArgument
		/// </summary>
		/// <param name="deliveryChannelName"></param>
		/// <param name="argumentName"></param>
		/// <param name="argumentValue"></param>
		/// <returns></returns>
		public bool NSUpdateDeliveryChannelArgument(string deliveryChannelName, string argumentName, string argumentValue)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSUpdateDeliveryChannelArgument",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@DeliveryChannelName",SqlDbType.NVarChar,255).Value=deliveryChannelName;
				mySqlCommand.Parameters.Add("@ArgumentName",SqlDbType.NVarChar,255).Value=argumentName;
				mySqlCommand.Parameters.Add("@ArgumentValue",SqlDbType.NVarChar,4000).Value=argumentValue;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSDeleteDeliveryChannelArguments
		/// </summary>
		/// <param name="deliveryChannelName"></param>
		/// <returns></returns>
		public bool NSDeleteDeliveryChannelArguments(string deliveryChannelName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand = new SqlCommand("NSDeleteDeliveryChannelArguments",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@DeliveryChannelName",SqlDbType.NVarChar,255).Value=deliveryChannelName;

				try
				{
					if (mySqlCommand.ExecuteNonQuery()>=1)
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSGetEvents
		/// </summary>
		/// <param name="type"></param>
		/// <param name="locale"></param>
		/// <param name="message"></param>
		/// <returns></returns>
		public bool NSGetEvents(out int[] type, out string[] locale, out string[] message)
		{
			bool ret=false;
			int index=0;	// indexes reader
			ArrayList aType = new ArrayList();
			ArrayList aLocale = new ArrayList();
			ArrayList aMessage = new ArrayList();

			lock (m_applicationConnection)
			{
				SqlDataReader myDataReader=null;
				SqlCommand mySqlCommand = new SqlCommand("select * from NSxContentEventsEvents",m_applicationConnection);
				mySqlCommand.CommandType=CommandType.Text;

				try
				{
					string str=null;
					int t=0;
					myDataReader=mySqlCommand.ExecuteReader();
					while (myDataReader.Read())
					{
						// EventBatchId - uint
						// EventId - uint
						// type - uint
						// locale - string
						// message - string
						// Date					
						index=2;	// skip the EventBatchId and EventId

						t=myDataReader.GetInt32(index++);
						aType.Add(t);
						str=myDataReader.GetString(index++);
						aLocale.Add(str);
						str=myDataReader.GetString(index++);
						aMessage.Add(str);
					}
					ret=true;
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
				finally
				{
					if (myDataReader!=null)
					{
						myDataReader.Close();
						myDataReader=null;
					}
				}
				type=(int[])aType.ToArray(typeof(int));
				locale=(string[])aLocale.ToArray(typeof(string));
				message=(string[])aMessage.ToArray(typeof(string));
			}
			return ret;
		}
 
		/// <summary>
		/// Stored procedure wrapper for NSGetSubscribers
		/// </summary>
		/// <param name="subscriberId"></param>
		/// <param name="enabled"></param>
		/// <returns></returns>
		public bool NSGetSubscribers(ulong subscriberId, out bool enabled)
		{
			bool ret=false;
			int index=0;
			enabled=false;

			lock (m_instanceConnection)
			{
				SqlDataReader myDataReader=null;
				SqlCommand mySqlCommand = new SqlCommand("NSGetSubscribers",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);

				try
				{
					myDataReader=mySqlCommand.ExecuteReader();
					if (myDataReader.Read())
					{
						enabled=myDataReader.GetBoolean(++index);
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
				finally
				{
					if (myDataReader!=null)
					{
						myDataReader.Close();
						myDataReader=null;
					}
				}
			}
			return ret;
		}
 
		/// <summary>
		/// Stored procedure wrapper for NSInsertSubscribers
		/// </summary>
		/// <param name="subscriberId"></param>
		/// <param name="enabled"></param>
		/// <returns></returns>
		public bool NSInsertSubscriber(ulong subscriberId, bool enabled)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSInsertSubscriber",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);
				mySqlCommand.Parameters.Add("@Enabled",SqlDbType.Bit,1).Value=enabled;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSUpdateSubscriber
		/// </summary>
		/// <param name="subscriberId"></param>
		/// <param name="enabled"></param>
		/// <returns></returns>
		public bool NSUpdateSubscriber(ulong subscriberId, bool enabled)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSUpdateSubscriber",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);
				mySqlCommand.Parameters.Add("@Enabled",SqlDbType.Bit,1).Value=enabled;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSDeleteSubscriber
		/// </summary>
		/// <param name="subscriberId"></param>
		/// <returns></returns>
		public bool NSDeleteSubscriber(ulong subscriberId)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand = new SqlCommand("NSDeleteSubscriber",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSGetSubscriberDevices
		/// </summary>
		/// <param name="subscriberId"></param>
		/// <param name="deviceName"></param>
		/// <param name="deviceTypeName"></param>
		/// <param name="deviceAddress"></param>
		/// <param name="deliveryChannelName"></param>
		/// <returns></returns>
		public bool NSGetSubscriberDevices(ulong subscriberId, out string[] deviceName, out string[] deviceTypeName, out string[] deviceAddress, out string[] deliveryChannelName)
		{
			bool ret=false;
			int index=0;
			deviceName=null;
			deviceTypeName=null;
			deliveryChannelName=null;
			ArrayList aDeviceName = new ArrayList();
			ArrayList aDeviceTypeName = new ArrayList();
			ArrayList aDeviceAddress = new ArrayList();
			ArrayList aDeliveryChannelName = new ArrayList();

			lock (m_instanceConnection)
			{
				SqlDataReader myDataReader=null;
				SqlCommand mySqlCommand = new SqlCommand("NSGetSubscriberDevices",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);

				try
				{
					string str=null;
					myDataReader=mySqlCommand.ExecuteReader();
					while (myDataReader.Read())
					{
						index=0;
						str=myDataReader.GetString(index++);
						aDeviceName.Add(str);
						str=myDataReader.GetString(index++);
						aDeviceTypeName.Add(str);
						if (myDataReader.IsDBNull(index++))
						{
							aDeviceAddress.Add(null);
						}
						else
						{
							str=myDataReader.GetString(index-1);
							aDeviceAddress.Add(str);
						}
						str=myDataReader.GetString(index++);
						aDeliveryChannelName.Add(str);
					}
					ret=true;
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
				finally
				{
					if (myDataReader!=null)
					{
						myDataReader.Close();
						myDataReader=null;
					}
				}
				deviceName=(string[])aDeviceName.ToArray(typeof(string));
				deviceTypeName=(string[])aDeviceTypeName.ToArray(typeof(string));
				deviceAddress=(string[])aDeviceAddress.ToArray(typeof(string));
				deliveryChannelName=(string[])aDeliveryChannelName.ToArray(typeof(string));
			}
			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSInsertSubscriberDevice
		/// </summary>
		/// <param name="subscriberId"></param>
		/// <param name="deviceName"></param>
		/// <param name="deviceTypeName"></param>
		/// <param name="deliveryChannelName"></param>
		/// <returns></returns>
		public bool NSInsertSubscriberDevice(ulong subscriberId, string deviceName, string deviceTypeName, string deliveryChannelName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSInsertSubscriberDevice",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);
				mySqlCommand.Parameters.Add("@DeviceName",SqlDbType.NVarChar,255).Value=deviceName;
				mySqlCommand.Parameters.Add("@DeviceTypeName",SqlDbType.NVarChar,255).Value=deviceTypeName;
				mySqlCommand.Parameters.Add("@DeliveryChannelName",SqlDbType.NVarChar,255).Value=deliveryChannelName;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSUpdateSubscriberDevice
		/// </summary>
		/// <param name="subscriberId"></param>
		/// <param name="deviceName"></param>
		/// <param name="deviceTypeName"></param>
		/// <param name="deliveryChannelName"></param>
		/// <returns></returns>
		public bool NSUpdateSubscriberDevice(ulong subscriberId, string deviceName, string deviceTypeName, string deliveryChannelName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSUpdateSubscriberDevice",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);
				mySqlCommand.Parameters.Add("@DeviceName",SqlDbType.NVarChar,255).Value=deviceName;
				mySqlCommand.Parameters.Add("@DeviceTypeName",SqlDbType.NVarChar,255).Value=deviceTypeName;
				mySqlCommand.Parameters.Add("@DeliveryChannelName",SqlDbType.NVarChar,255).Value=deliveryChannelName;

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSDeleteSubscriberDevice
		/// </summary>
		/// <param name="subscriberId"></param>
		/// <param name="deviceName"></param>
		/// <returns></returns>
		public bool NSDeleteSubscriberDevice(ulong subscriberId, string deviceName)
		{
			bool ret=false;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand = new SqlCommand("NSDeleteSubscriberDevice",m_instanceConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);
				mySqlCommand.Parameters.Add("@DeviceName",SqlDbType.NVarChar,255).Value=deviceName;

				try
				{
					if (mySqlCommand.ExecuteNonQuery()>=1)
					{
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSInsertxLiveSubscriptionsSubscription
		/// </summary>
		/// <param name="enabled"></param>
		/// <param name="type"></param>
		/// <param name="deviceName"></param>
		/// <param name="subscriberXUID"></param>
		/// <param name="subscriber"></param>
		/// <param name="subscriberLocale"></param>
		/// <param name="subscriberId"></param>
		/// <param name="subscriptionId"></param>
		/// <returns></returns>
		public bool NSInsertxLiveSubscriptionsSubscription(bool enabled, uint type, string deviceName, ulong subscriberXUID, string subscriber, string subscriberLocale, ulong subscriberId, out ulong subscriptionId)
		{
			bool ret=false;
			subscriptionId=0;

			lock (m_applicationConnection)
			{
				uint hr=0;

				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSInsertxLiveSubscriptionsSubscription",m_applicationConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				SqlParameter SqlParamReturn = mySqlCommand.Parameters.Add("@Ret", SqlDbType.Int);
				SqlParamReturn.Direction = ParameterDirection.ReturnValue;                
				SqlParameter SqlParamSubscriptionId = mySqlCommand.Parameters.Add("@SubscriptionId",SqlDbType.BigInt);
				SqlParamSubscriptionId.Direction=ParameterDirection.Output;
				mySqlCommand.Parameters.Add("@Enabled",SqlDbType.Bit).Value=enabled;
				mySqlCommand.Parameters.Add("@Type",SqlDbType.Int).Value=type;
				mySqlCommand.Parameters.Add("@DeviceName",SqlDbType.NVarChar,255).Value=deviceName;
				mySqlCommand.Parameters.Add("@SubscriberXUID",SqlDbType.BigInt).Value=subscriberXUID;
				mySqlCommand.Parameters.Add("@Subscriber",SqlDbType.NChar,16).Value=subscriber;
				mySqlCommand.Parameters.Add("@SubscriberLocale",SqlDbType.NChar,10).Value=subscriberLocale;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						hr=(uint)(int)SqlParamReturn.Value;
						subscriptionId = (ulong)(long)SqlParamSubscriptionId.Value;

						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Stored procedure wrapper for NSInsertxContentSubscriptionsSubscription
		/// </summary>
		/// <param name="enabled"></param>
		/// <param name="type"></param>
		/// <param name="deviceName"></param>
		/// <param name="subscriberLocale"></param>
		/// <param name="subscriberId"></param>
		/// <param name="subscriptionId"></param>
		/// <returns></returns>
		public bool NSInsertxContentSubscriptionsSubscription(bool enabled, int type, string deviceName, string subscriberLocale, ulong subscriberId, out ulong subscriptionId)
		{
			bool ret=false;
			subscriptionId=0;

			lock (m_applicationConnection)
			{
				uint hr=0;

				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSInsertxContentSubscriptionsSubscription",m_applicationConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				SqlParameter SqlParamReturn = mySqlCommand.Parameters.Add("@Ret", SqlDbType.Int);
				SqlParamReturn.Direction = ParameterDirection.ReturnValue;                
				SqlParameter SqlParamSubscriptionId = mySqlCommand.Parameters.Add("@SubscriptionId",SqlDbType.BigInt);
				SqlParamSubscriptionId.Direction=ParameterDirection.Output;
				mySqlCommand.Parameters.Add("@Enabled",SqlDbType.Bit).Value=enabled;
				mySqlCommand.Parameters.Add("@Type",SqlDbType.Int).Value=type;
				mySqlCommand.Parameters.Add("@DeviceName",SqlDbType.NVarChar,255).Value=deviceName;
				mySqlCommand.Parameters.Add("@SubscriberLocale",SqlDbType.NChar,10).Value=subscriberLocale;
				mySqlCommand.Parameters.Add("@SubscriberId",SqlDbType.NVarChar,255).Value=FormatSubscriberId(subscriberId);

				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						hr=(uint)(int)SqlParamReturn.Value;
						subscriptionId = (ulong)(long)SqlParamSubscriptionId.Value;

						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Adds a content event to the DB through batch system
		/// </summary>
		/// <param name="type"></param>
		/// <param name="locale"></param>
		/// <param name="message"></param>
		/// <param name="deliveryTime"></param>
		/// <returns></returns>
		public bool AddContentEvent(int type, string locale, string message, DateTime deliveryTime)
		{
			bool ret=false;
			
			lock (m_applicationConnection)
			{
				uint hr=0;

				//Start tne batch
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSEventBeginBatchxContentEvents",m_applicationConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				SqlParameter SqlParamReturn = mySqlCommand.Parameters.Add("@Ret", SqlDbType.Int);
				SqlParamReturn.Direction = ParameterDirection.ReturnValue;                
				SqlParameter SqlParamBatchId = mySqlCommand.Parameters.Add("@EventBatchId",SqlDbType.BigInt);
				SqlParamBatchId.Direction=ParameterDirection.Output;
				mySqlCommand.Parameters.Add("@ProviderName",SqlDbType.NVarChar, 255).Value = "xContentEP";
				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						hr=(uint)(int)SqlParamReturn.Value;
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}

				if (!ret) return ret;

				//Add the event
				mySqlCommand = new SqlCommand("NSEventWritexContentEvents",m_applicationConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				SqlParamReturn = mySqlCommand.Parameters.Add("@Ret", SqlDbType.Int);
				SqlParamReturn.Direction = ParameterDirection.ReturnValue;                
				mySqlCommand.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = SqlParamBatchId.Value;
				mySqlCommand.Parameters.Add("@Type", SqlDbType.Int).Value = unchecked((int)type);
				mySqlCommand.Parameters.Add("@Locale", SqlDbType.NVarChar, 10).Value = locale;
				mySqlCommand.Parameters.Add("@Message", SqlDbType.NVarChar, 255).Value = message;
				mySqlCommand.Parameters.Add("@DeliveryTime", SqlDbType.DateTime).Value = deliveryTime;
				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						hr=(uint)(int)SqlParamReturn.Value;
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}

				if (!ret) return ret;

				// Commit the batch
				mySqlCommand = new SqlCommand("NSEventFlushBatchxContentEvents",m_applicationConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				SqlParamReturn = mySqlCommand.Parameters.Add("@Ret", SqlDbType.Int);
				SqlParamReturn.Direction = ParameterDirection.ReturnValue;                
				mySqlCommand.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = SqlParamBatchId.Value;
				mySqlCommand.Parameters.Add("@EventCount", SqlDbType.Int).Value = 1;
				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						hr=(uint)(int)SqlParamReturn.Value;
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Adds a title event to the DB through batch system
		/// </summary>
		/// <param name="titleId"></param>
		/// <param name="locale"></param>
		/// <param name="name"></param>
		/// <returns></returns>
		public bool AddTitleEvent(uint titleId, string locale, string titleName)
		{
			bool ret=false;
			
			lock (m_applicationConnection)
			{
				uint hr=0;

				//Start tne batch
				SqlCommand mySqlCommand=null;
				mySqlCommand = new SqlCommand("NSEventBeginBatchxTitleEvents",m_applicationConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				SqlParameter SqlParamReturn = mySqlCommand.Parameters.Add("@Ret", SqlDbType.Int);
				SqlParamReturn.Direction = ParameterDirection.ReturnValue;                
				SqlParameter SqlParamBatchId = mySqlCommand.Parameters.Add("@EventBatchId",SqlDbType.BigInt);
				SqlParamBatchId.Direction=ParameterDirection.Output;
				mySqlCommand.Parameters.Add("@ProviderName",SqlDbType.NVarChar, 255).Value = "xContentEP";
				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						hr=(uint)(int)SqlParamReturn.Value;
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}

				if (!ret) return ret;

				//Add the event
				mySqlCommand = new SqlCommand("NSEventWritexTitleEvents",m_applicationConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				SqlParamReturn = mySqlCommand.Parameters.Add("@Ret", SqlDbType.Int);
				SqlParamReturn.Direction = ParameterDirection.ReturnValue;                
				mySqlCommand.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = SqlParamBatchId.Value;
				mySqlCommand.Parameters.Add("@TitleId", SqlDbType.Int).Value = unchecked((int)titleId);
				mySqlCommand.Parameters.Add("@TitleLocale", SqlDbType.NVarChar, 10).Value = locale;
				mySqlCommand.Parameters.Add("@TitleName", SqlDbType.NVarChar, 30).Value = titleName;
				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						hr=(uint)(int)SqlParamReturn.Value;
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}

				if (!ret) return ret;

				// Commit the batch
				mySqlCommand = new SqlCommand("NSEventFlushBatchxTitleEvents",m_applicationConnection);
				mySqlCommand.CommandType=CommandType.StoredProcedure;
				SqlParamReturn = mySqlCommand.Parameters.Add("@Ret", SqlDbType.Int);
				SqlParamReturn.Direction = ParameterDirection.ReturnValue;                
				mySqlCommand.Parameters.Add("@EventBatchId", SqlDbType.BigInt).Value = SqlParamBatchId.Value;
				mySqlCommand.Parameters.Add("@EventCount", SqlDbType.Int).Value = 1;
				try
				{
					if (1==mySqlCommand.ExecuteNonQuery())
					{
						hr=(uint)(int)SqlParamReturn.Value;
						ret=true;
					}
				}
				catch
				{
					if (mySqlCommand!=null)
					{
						mySqlCommand.Cancel();
						mySqlCommand=null;
					}
				}
			}

			return ret;
		}

		/// <summary>
		/// Gets data for a title
		/// </summary>
		/// <param name="titleId"></param>
		/// <param name="titleLocale"></param>
		/// <param name="titleName"></param>
		/// <returns></returns>
		public bool GetTitle(uint titleId, string titleLocale, out string titleName)
		{
			bool ret=false;
			int index=0;
			titleName=null;

			lock (m_applicationConnection)
			{
				SqlDataReader myDataReader = null;
				SqlCommand mySqlCommand = new SqlCommand("SELECT TitleName FROM xTitleChron WHERE TitleId = 0x"+titleId.ToString("X8")+" AND TitleLocale = '"+titleLocale+"'", m_applicationConnection);

				try
				{
					myDataReader = mySqlCommand.ExecuteReader();

					if (myDataReader.Read())
					{
						titleName=myDataReader.GetString(index++);
						ret=true;
					}
				}
				finally
				{
					if (myDataReader != null)
						myDataReader.Close();
				}
			}
			return ret;
		}

		/// <summary>
		/// Sets data for a title
		/// </summary>
		/// <param name="titleId"></param>
		/// <param name="titleLocale"></param>
		/// <param name="titleName"></param>
		/// <returns></returns>
		public bool SetTitle(uint titleId, string titleLocale, string titleName)
		{
			bool fRows=false;
			int FieldsAffected = 0;

			lock (m_applicationConnection)
			{
				SqlDataReader myDataReader=null;
				SqlCommand mySqlCommand = new SqlCommand("SELECT * FROM xTitleChron WHERE TitleId = "+((int)titleId).ToString()+" AND TitleLocale = N'"+titleLocale+"'",m_applicationConnection);
				try
				{
					myDataReader=mySqlCommand.ExecuteReader();
					fRows=myDataReader.Read();
				}
				finally
				{
					if (myDataReader!=null)
					{
						myDataReader.Close();
						myDataReader=null;
					}
				}

				if (!fRows)
				{
					mySqlCommand = new SqlCommand(				
						"INSERT INTO xTitleChron (TitleId,TitleLocale,TitleName) "+
						"VALUES ("+
						((int)titleId).ToString()+","+
						"'"+titleLocale+"',"+
						"'"+titleName+"'"+
						")",
						m_applicationConnection);
	
					FieldsAffected = 0;
					try{FieldsAffected=mySqlCommand.ExecuteNonQuery();}
					catch{}
				}
				else
				{
					mySqlCommand = new SqlCommand(				
						"UPDATE xTitleChron "+
						"SET TitleName = '"+titleName+"' "+" "+
						"WHERE TitleId = "+((int)titleId).ToString()+" AND TitleLocale = N'"+titleLocale+"'",
						m_applicationConnection);
	
					FieldsAffected = 0;
					try{FieldsAffected=mySqlCommand.ExecuteNonQuery();}
					catch{}
				}
			}
			return (FieldsAffected==1);
		}

		/// <summary>
		/// Deletes data about a title
		/// </summary>
		/// <param name="titleId"></param>
		/// <returns></returns>
		public bool DeleteTitle(uint titleId)
		{
			bool ret=true;
			bool fRows=false;
			int FieldsAffected = 0;

			lock (m_applicationConnection)
			{
				SqlDataReader myDataReader=null;
				SqlCommand mySqlCommand = new SqlCommand("SELECT * FROM xTitleChron WHERE TitleId = 0x"+titleId.ToString("X8")+"",m_applicationConnection);
				try
				{
					myDataReader=mySqlCommand.ExecuteReader();
					fRows=myDataReader.Read();
				}
				finally
				{
					if (myDataReader!=null)
					{
						myDataReader.Close();
						myDataReader=null;
					}
				}

				if (fRows)
				{
					mySqlCommand = new SqlCommand(				
						"DELETE FROM xTitleChron WHERE TitleId = 0x"+titleId.ToString("X8"),
						m_applicationConnection);
	
					FieldsAffected = 0;
					try
					{
						FieldsAffected=mySqlCommand.ExecuteNonQuery();
						if (FieldsAffected==0)
						{
							ret=false;
						}
					}
					catch
					{
						ret=false;
					}
				}
			}
			return ret;
		}

		/// <summary>
		/// Delete all subscriber devices that match deviceName
		/// </summary>
		/// <param name="deviceName"></param>
		/// <returns></returns>
		public bool DeleteSubscriberDevices(string deliveryChannelName)
		{
			bool ret=true;
			int FieldsAffected = 0;

			lock (m_instanceConnection)
			{
				SqlCommand mySqlCommand = new SqlCommand("DELETE FROM NSSubscriberDevices WHERE DeliveryChannelName = '"+deliveryChannelName+"'",m_instanceConnection);
				try
				{
					FieldsAffected=mySqlCommand.ExecuteNonQuery();						
					if (FieldsAffected==0)
					{
						ret=false;
					}
				}
				catch
				{
					ret=false;
				}
			}
			return ret;
		}
				
		/// <summary>
		/// Dynamically rewrites stored procedures that distributor uses to create work items with new delivery channel
		/// Specifically NSCreatexLiveNotificationsDistributorWorkItems and NSCreatexContentNotificationsDistributorWorkItems
		/// </summary>
		/// <param name="deliveryChannel"></param>
		/// <returns></returns>
		public bool AlterNSCreatexNotificationsDistributorWorkItems(string deliveryChannel)
		{
			string sprocText1=null;
			string sprocText2=null;
			if (!GetStoredProcedureText(m_applicationConnection,"NSCreatexLiveNotificationsDistributorWorkItems",out sprocText1)) return false;
			if (!GetStoredProcedureText(m_applicationConnection,"NSCreatexContentNotificationsDistributorWorkItems",out sprocText2)) return false;
			string newSprocText1=sprocText1;
			string newSprocText2=sprocText2;
			if (!AlterNSCreatexNotificationsDistributorWorkItemsText(ref newSprocText1,deliveryChannel))return false;
			if (!AlterNSCreatexNotificationsDistributorWorkItemsText(ref newSprocText2,deliveryChannel))return false;
			if (!ExecuteNonQuery(newSprocText1))return false;
			if (!ExecuteNonQuery(newSprocText2))
			{
				//Rollback if possible
				ExecuteNonQuery(sprocText1);
				return false;
			}

			return true;
		}

		/// <summary>
		/// Gets the text of a stored procedure
		/// </summary>
		/// <param name="conn"></param>
		/// <param name="sprocName"></param>
		/// <param name="sprocText"></param>
		/// <returns></returns>
		private bool GetStoredProcedureText(SqlConnection conn, string sprocName, out string sprocText)
		{
			bool ret=false;
			int index=0;
			string tmpText=null;
			sprocText=null;
			int id=0;

			lock (conn)
			{
				SqlDataReader myDataReader = null;
				SqlCommand mySqlCommand = new SqlCommand("SELECT id FROM sysobjects WHERE name = '"+sprocName+"' AND type = 'P'", conn);

				try
				{
					myDataReader = mySqlCommand.ExecuteReader();

					if (myDataReader.Read())
					{
						id=myDataReader.GetInt32(index++);
					}
					myDataReader.Close();

					mySqlCommand = new SqlCommand("select text from syscomments WHERE id = "+id,conn);
					myDataReader = mySqlCommand.ExecuteReader();
					while (myDataReader.Read())
					{
						index=0;
						tmpText=myDataReader.GetString(index++);
						sprocText=sprocText+tmpText;
					}
					ret=true;

				}
				finally
				{
					if (myDataReader != null)
						myDataReader.Close();
				}
			}
			return ret;

		}

		/// <summary>
		/// Helper method for updating NSCreatexContentNotificationsDistributorWorkItems
		/// </summary>
		/// <param name="sprocText"></param>
		/// <param name="deliveryChannel"></param>
		/// <returns></returns>
		private bool AlterNSCreatexNotificationsDistributorWorkItemsText(ref string sprocText, string deliveryChannel)
		{
			string newSprocText=null;
			Regex _regexFindChannels = new Regex(@"[\040]*-- Create work item for (?<cname>.*?) channel.*?\n(.*?\)--\s*\S*\n\n)", RegexOptions.Compiled | RegexOptions.Singleline);
			Regex _regexFindChannelName = new Regex(@"N'(?<cname>.*?)'", RegexOptions.Compiled | RegexOptions.Singleline);
			MatchCollection matches = _regexFindChannels.Matches(sprocText);
			bool found=false;

			if (matches.Count>0)
			{
				//Prefix
				newSprocText=sprocText.Substring(0,matches[0].Index).Replace("CREATE PROCEDURE","ALTER PROCEDURE");

				//Remove any delivery channel that matches
				Match match = null;
				
				for (int i=0; i<matches.Count;i++)
				{
					match=_regexFindChannelName.Match(matches[i].Value);
					if (!match.Success) continue;
					if (match.Groups[1].Value.ToLower().CompareTo(deliveryChannel.ToLower())==0)
					{
						found=true;
					}
					newSprocText=newSprocText+matches[i].Value;
				}

				//Add new delivery channel if needed
				if (!found)
				{
					string newDeliveryChannel=matches[0].Value;
					match=_regexFindChannelName.Match(matches[0].Value);
					newDeliveryChannel = newDeliveryChannel.Replace(match.Groups[1].Value,deliveryChannel);
					newSprocText=newSprocText+newDeliveryChannel;
				}

				//Postfix
				newSprocText=newSprocText+sprocText.Substring(matches[matches.Count-1].Index+matches[matches.Count-1].Length);
				sprocText=newSprocText;

				return true;
			}

			return false;
		}

		/// <summary>
		/// Helper method for executing non queries
		/// </summary>
		/// <param name="query"></param>
		/// <returns></returns>
		private bool ExecuteNonQuery(string query)
		{
			bool ret=false;
			int rowsAffected=0;

			lock (m_applicationConnection)
			{
				SqlCommand mySqlCommand = new SqlCommand(query, m_applicationConnection);

				try
				{
					rowsAffected = mySqlCommand.ExecuteNonQuery();
					if (rowsAffected==-1)
					{
						ret=true;
					}
				}
				catch{}
			}
			return ret;
		}

		/// <summary>
		/// Get the SQL server UTC Date
		/// </summary>
		/// <returns></returns>
		public DateTime GetUTCDate()
		{
			lock(m_applicationConnection)
			{

				DateTime ret=DateTime.MinValue;
				int index=0;
				SqlDataReader myDataReader = null;
				SqlCommand mySqlCommand = new SqlCommand("SELECT GETUTCDATE()", m_applicationConnection);

				try
				{
					myDataReader = mySqlCommand.ExecuteReader();

					// Always call Read before accessing data.
					if (myDataReader.Read())
					{
						ret=myDataReader.GetDateTime(index++);
					}
				}
				finally
				{
					// Always call Close when done reading.
					if (myDataReader != null)
						myDataReader.Close();
				}

				return ret;
			}
		}

	}

	/// <summary>
	/// Access object for Alerts SQLNS service
	/// </summary>
	public class AlertsSQLNS
	{
		/// <summary>
		/// Service name
		/// </summary>
		private const string serviceName = "ns$xbox";

		/// <summary>
		/// Remote server name
		/// </summary>
		private string m_serverName=null;

		/// <summary>
		/// Service control object
		/// </summary>
		private ServiceController m_sc = null;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="serverName"></param>
		public AlertsSQLNS(string serverName)
		{
			m_serverName=serverName;
		}

		bool WaitForServiceControllerStatus(string serviceName, string m_serverName, ServiceControllerStatus waitForStatus, int retrySecs)
		{
			int retry = 0;
			ServiceController tempSC = null;

			//Have to create a new ServiceController each time you want the status!
			tempSC = new ServiceController(serviceName, m_serverName);
			if (null==tempSC)
			{
				return(false);
			}

			while (!tempSC.Status.Equals(waitForStatus))
			{
				System.Threading.Thread.Sleep(500);
				++retry;
				if ((retrySecs / 2) == retry)	// Recheck status every 0.5 seconds
				{
					return(false);
				}

				tempSC = new ServiceController(serviceName, m_serverName);
				if (null==tempSC)
				{
					return(false);
				}
			}
			return(true);
		}

		/// <summary>
		/// Restart the service
		/// </summary>
		/// <returns></returns>
		public bool Restart()
		{
			try
			{
				m_sc = new ServiceController(serviceName,m_serverName);
				if (null==m_sc) return false;

				if (!m_sc.Status.Equals(ServiceControllerStatus.Stopped))
				{
					try
					{
						m_sc.Stop();
						if (!WaitForServiceControllerStatus(serviceName, m_serverName, ServiceControllerStatus.Stopped, 30))
						{
							return false;
						}
					}
					catch
					{
						return false;
					}
				}

				try
				{
					m_sc.Start();
					if (!WaitForServiceControllerStatus(serviceName, m_serverName, ServiceControllerStatus.Running, 30))
					{
						return false;
					}
				}
				catch
				{
					return false;
				}
			}
			finally
			{
				m_sc=null;
			}

			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\ActiveAuthHttpClient.cs ===
//Higher level client for talking to the ActiveAuth gateway.

using System;
using System.Net;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary>
    /// Exceptions thrown by the ActiveAuthClient itself.
    /// </summary>
    public class ActiveAuthException: Exception
    {
        public ActiveAuthException(string message): base(message) {}
    }

    /// <summary>
    /// For handling configuration/settings for activeauth.
    /// Requires Npdb access.
    /// </summary>
    public class ActiveAuthHttpConfig
    {
        public static string GetServerName()
        {
            SetupEnv();
            return cachedServerName;
        }
        public static ushort GetServerPort()
        {
            SetupEnv();
            return cachedServerPort;
        }

        //Override the server to run against with a custom one
        public static void OverrideServer(string ip, ushort port)
        {
            cachedServerName=ip;
            cachedServerPort=port;
            cachedNamePortEnvironment=Global.XEnv.GetEnv();
            targetOverriden=true;
        }

        //Restore server to use to the default
        public static void ResetServer()
        {
            cachedServerName=null;
            cachedServerPort=0;
            cachedNamePortEnvironment=null;
            targetOverriden=false;
        }

        /// <summary>
        /// Represents an entry in npdb's t_activeauth_policies.
        /// </summary>
        public class PolicyEntry
        {
            public string Path="/test/default";     //path the policy applies to (example: /foo)
            public bool AuthRequired=false;         //whether authorization (can only be true if AuthPolicy is not null)
            public string AuthPolicy=null;          //name of the passport ticket policy
            public bool SSLRequired=false;          //if an ssl connection is required
            public bool AntiDOS=false;              //if DOS protection is enabled
            /// <summary>If true, the passport user must map to a valid XUID (requires AuthRequired to be true).</summary>
            public bool RequiresXuid = false;
            /// <summary>If true, throttling is enabled.</summary>
            public bool Throttle = false;
            /// <summary>Throttle halflife in seconds.</summary>
            public int ThrottleHalflifeSeconds = 0;
            /// <summary>Throttle threshold.</summary>
            public int ThrottleThreshold = 0;
            public string Environment = "ALL";
            public string AuthHeader = null;
            public bool RequiresClientCert = false;
            public bool RequiresMachineId = false;
            public string AllowedAuthMethods = null;
            public string Instance = "activeauth";
            public string AllowListHeadersIncoming = null;
            public string AllowListHeadersOutgoing = null;
            public int RegexOrder = 0;

            //
            public PolicyEntry()
            {}
            public PolicyEntry(string p, bool ar, string ap, bool ssl, bool dos)
            {
                Path=p;
                AuthRequired=ar;
                AuthPolicy=ap;
                SSLRequired=ssl;
                AntiDOS=dos;
            }

            public PolicyEntry (string p, bool ar, string ap, bool ssl, bool dos, bool xuid, bool throttle, int halflife, int threshold)
            {
                Path = p;
                AuthRequired = ar;
                AuthPolicy = ap;
                SSLRequired = ssl;
                AntiDOS = dos;
                RequiresXuid = xuid;
                Throttle = throttle;
                ThrottleHalflifeSeconds = halflife;
                ThrottleThreshold = threshold;
            }
        }

        /// <summary>
        /// Updates or adds a policy entry to npdb for the module (t_activeauth_policies)
        /// </summary>
        public static void SetPolicyEntry (string p, bool ar, string ap, bool ssl, bool dos, bool xuid, bool throttle, int halflife, int threshold)
        {
            SetPolicyEntry(new PolicyEntry(p, ar, ap, ssl, dos, xuid, throttle, halflife, threshold));
        }

        /// <summary>
        /// Updates or adds a policy entry to npdb for the module (t_activeauth_policies)
        /// </summary>
        public static PolicyEntry SetPolicyEntry(PolicyEntry entry)
        {
            PolicyEntry oldEntry = GetPolicyEntry(entry.Path, entry.Environment, entry.Instance);
            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            npdb.IssueCommand(SetPolicyEntry_SQL(entry));
            npdb.Close();

            //verify
            //if (GetPolicyEntry(entry.Path)==null) throw new Exception("t_activeauth_policies did not seem to have the newly added row");

            //Global.RO.Info("Set ActiveAuth policy: "+entry.Path+"  auth="+(entry.AuthRequired?"yes":"no")+" policy="+(entry.AuthPolicy==null?"none":entry.AuthPolicy)+" ssl="+(entry.SSLRequired?"yes":"no")+" dos="+(entry.AntiDOS?"yes":"no"));
            return oldEntry;
        }

        /// <summary>
        /// Creates the SQL for updating/adding the policy entry.
        /// </summary>
        public static string SetPolicyEntry_SQL (PolicyEntry entry)
        {
            if (string.IsNullOrEmpty(entry.Path))
            {
                throw new Exception("Path must be at least 1 character");
            }

            if (string.IsNullOrEmpty(entry.Environment))
            {
                throw new Exception("Environment must be at least 1 character");
            }

            if (entry.Instance == null)
            {
                throw new Exception("Instance must not be null.");
            }

            return String.Format(@"
if exists (select null from t_activeauth_policies where vc_policy_key = '{0}' and vc_environment = '{9}' and
           vc_instance like '%{14}%') begin
    update t_activeauth_policies set
        b_requires_authentication = {1}, vc_auth_policy = {2}, b_ssl = {3}, b_antidos = {4},
        b_requires_xuid = {5}, b_throttle = {6}, i_throttle_halflife_seconds = {7}, i_throttle_threshold = {8},
        vc_auth_header = {10}, b_requires_clientcert = {11}, b_requires_machineid = {12},
        vc_allowed_auth_methods = {13}, vc_allowlistheadersincoming = {15}, vc_allowlistheadersoutgoing = {16}
        where vc_policy_key = '{0}' and vc_environment = '{9}' and vc_instance like '%{14}%'
end else begin
    insert into t_activeauth_policies
        (vc_policy_key , b_requires_authentication  , vc_auth_policy      , b_ssl         , 
         b_antidos     , b_requires_xuid            ,
         b_throttle    , i_throttle_halflife_seconds, i_throttle_threshold, vc_environment, 
         vc_auth_header, b_requires_clientcert      , b_requires_machineid, vc_allowed_auth_methods,
         vc_instance   , vc_allowlistheadersincoming, vc_allowlistheadersoutgoing, i_regex_order) values
        ('{0}'         , {1}                        , {2}                 , {3}           ,
         {4}           , {5}                        ,
         {6}           , {7}                        , {8}                 , '{9}'         ,
         {10}          , {11}                       , {12}                , {13}          ,
         '{14}'        , {15}                       , {16}                , {17})
end
",              // {0}                       , {1}
                entry.Path.Replace("'", "''"), (entry.AuthRequired ? 1 : 0), 
                // {2}
                (entry.AuthPolicy == null ? "null" : "'" + entry.AuthPolicy.Replace("'", "''") + "'"),
                // {3}                     , {4}
                (entry.SSLRequired ? 1 : 0), (entry.AntiDOS ? 1 : 0),
                // {5}                      , {6}
                (entry.RequiresXuid ? 1 : 0), (entry.Throttle ? 1 : 0),
                // {7}
                (entry.Throttle ? entry.ThrottleHalflifeSeconds.ToString() : "null"),
                // {8}
                (entry.Throttle ? entry.ThrottleThreshold.ToString() : "null"),
                // {9}
                entry.Environment.Replace("'", "''"),
                // {10}
                (entry.AuthHeader == null ? "null" : "'" + entry.AuthHeader.Replace("'", "''") + "'"),
                // {11}                           , {12}
                (entry.RequiresClientCert ? 1 : 0), (entry.RequiresMachineId ? 1 : 0),
                // {13}
                (entry.AllowedAuthMethods == null ? "null" : "'" + entry.AllowedAuthMethods.Replace("'", "''") + "'"),
                // {14}
                entry.Instance.Replace("'", "''"),
                // {15}
                (entry.AllowListHeadersIncoming == null ? "null" : "'" + entry.AllowListHeadersIncoming.Replace("'", "''") + "'"),
                // {16}
                (entry.AllowListHeadersOutgoing == null ? "null" : "'" + entry.AllowListHeadersOutgoing.Replace("'", "''") + "'"),
                // {17}
                entry.RegexOrder.ToString()
                );
        }

        /// <summary>
        /// Retrieves a policy entry from npdb, given the path that it applies to
        /// </summary>
        public static PolicyEntry GetPolicyEntry (string path)
        {
            return GetPolicyEntry(path, null, null);
        }

        /// <summary>
        /// Retrieves a policy entry from npdb, given the path that it applies to
        /// </summary>
        public static PolicyEntry GetPolicyEntry (string path, string environment)
        {
            return GetPolicyEntry(path, environment, null);
        }

        /// <summary>
        /// Retrieves a policy entry from npdb, given the path that it applies to
        /// </summary>
        public static PolicyEntry GetPolicyEntry (string path, string environment, string instance)
        {
            if (path.Length<1) throw new Exception("Path must be at least 1 char");
            string query =
@"select b_requires_authentication, vc_auth_policy, b_ssl, b_antidos,
    b_requires_xuid, b_throttle, i_throttle_halflife_seconds, i_throttle_threshold,
    vc_environment, vc_auth_header, b_requires_clientcert, b_requires_machineid,
    vc_allowed_auth_methods, vc_instance, vc_allowlistheadersincoming,
    vc_allowlistheadersoutgoing
    from t_activeauth_policies where vc_policy_key = '" + path.Replace("'", "''") + "'";
            if (environment != null)
            {
                query += " and vc_environment = '" + environment.Replace("'", "''") + "'";
            }
            if (instance != null)
            {
                query += " and vc_instance like '%" + instance.Replace("'", "''") + "%'";
            }

            //do query
            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            SqlDataReader reader;
            npdb.ReadData(query, out reader);
            if (!reader.Read()) return null;

            //grab data from it
            PolicyEntry entry=new PolicyEntry();
            entry.Path=path;
            entry.AuthRequired = reader.GetBoolean(0);
            try
            {
                entry.AuthPolicy = reader.GetString(1);
            }
            catch {} //don't feel like fighting C# today.. default to null
            entry.SSLRequired = reader.GetBoolean(2);
            entry.AntiDOS = reader.GetBoolean(3);

            entry.RequiresXuid = reader.GetBoolean(4);
            entry.Throttle = reader.GetBoolean(5);
            if (!reader.IsDBNull(6)) { entry.ThrottleHalflifeSeconds = reader.GetInt32(6); }
            if (!reader.IsDBNull(7)) { entry.ThrottleThreshold = reader.GetInt32(7); }

            entry.Environment = reader.GetString(8);
            entry.AuthHeader = (reader.IsDBNull(9) ? null : reader.GetString(9));
            entry.RequiresClientCert = reader.GetBoolean(10);
            entry.RequiresMachineId = reader.GetBoolean(11);

            entry.AllowedAuthMethods = reader.IsDBNull(12) ? null : reader.GetString(12);
            entry.Instance = reader.IsDBNull(13) ? null : reader.GetString(13);
            entry.AllowListHeadersIncoming = reader.IsDBNull(14) ? null : reader.GetString(14);
            entry.AllowListHeadersOutgoing = reader.IsDBNull(15) ? null : reader.GetString(15);

            if (reader.Read())
            {
                if (instance == String.Empty)
                    Global.RO.Warn("Environment and/or instance was not specified, and there are multiple entries for the policy key (" + path + "). Getting just one.");
                else
                    throw new ArgumentException("Environment and/or instance was not specified, and there are multiple entries for the policy key (" + 
                    path + ").");
            }

            //
            reader.Close();
            npdb.Close();
            return entry;
        }

        /// <summary>
        /// Removes a policy entry from npdb.
        /// </summary>
        public static bool RemovePolicyEntry (string path)
        {
            return RemovePolicyEntry(path, null, null);
        }

        /// <summary>
        /// Removes a policy entry from npdb.
        /// </summary>
        public static bool RemovePolicyEntry (string path, string environment)
        {
            return RemovePolicyEntry(path, environment, null);
        }

        /// <summary>
        /// Removes a policy entry from npdb.
        /// </summary>
        public static bool RemovePolicyEntry(string path, string environment, string instance)
        {
            if (path.Length<1) throw new Exception("Path must be at least 1 char");

            //do query
            string query = "delete from t_activeauth_policies where vc_policy_key='" + path.Replace("'", "''") + "'";
            if (environment != null)
            {
                query += " and vc_environment = '" + environment.Replace("'", "''") + "'";
            }
            if (instance != null)
            {
                query += " and vc_instance like '%" + instance.Replace("'", "''") + "%'";
            }

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            int rows=npdb.IssueCommand(query);
            npdb.Close();

            return rows==1;
        }

        /// <summary>
        /// Does an xmgmtc reload command on aamodule (to cause the policies to be reloaded)
        /// </summary>
        public static void AAModuleReload()
        {
            Global.RO.Info("Reloading aamodule (authsg).  This will fail(ok) if no appdomains are currently running...");
            Global.XEnv.ExecuteXmgmtCommand("authsg", "e :aamodule reload");
        }

        //
        private static string cachedServerName;
        private static ushort cachedServerPort;
        private static string cachedNamePortEnvironment=null;
        private static object cachedNamePortLock=new object();
        private static bool targetOverriden=false;

        private static void SetupEnv()
        {
            if (targetOverriden) return;

            if (cachedNamePortEnvironment==null || cachedNamePortEnvironment!=Global.XEnv.GetEnv())
            {
                lock (cachedNamePortLock)
                {
                    if (cachedNamePortEnvironment==null || cachedNamePortEnvironment!=Global.XEnv.GetEnv())
                    {
                        cachedNamePortEnvironment=Global.XEnv.GetEnv();

                        IPEndPoint eps=Global.XEnv.GetVirtualInterface("authsg");
                        //if (eps.Length!=1) throw new Exception("There is not exactly 1 interface for 'aaifdreflector', but there are "+eps.Length+".  Don't know which to use.");
                        IPEndPoint ep=eps;//[0];
                        cachedServerName=ep.Address.ToString();
                        cachedServerPort=(ushort)ep.Port;

                        Global.RO.Debug("Using authsg: "+cachedServerName+" port "+cachedServerPort);
                    }
                }
            }
        }
    };

    /// <summary>
    /// For making actual requests through the activeauth gateway.
    /// Can run from anywhere that has idcrl set up corectly.
    /// </summary>
    public class ActiveAuthHttpClient
    {
        #region ctor

        //static ctor
        static ActiveAuthHttpClient()
        {
            //init passport idcrl
            AuthClientBase.InitializePassportIDCRL();
        }

        //ctor
        public ActiveAuthHttpClient(): this(ActiveAuthHttpConfig.GetServerName(), ActiveAuthHttpConfig.GetServerPort())
        {
        }
        public ActiveAuthHttpClient(string server, ushort port)
        {
            this.port=port;
            this.server=server;

            http=new HttpClient(server,port);
        }

        #endregion //ctor

        #region Public Fields

        //what we are connected to
        public string Server
        { get {return server;} }
        public ushort Port
        { get {return port;} }

        //user passport credentials
        public string PassportName="";
        public string PassportPassword="";
        public string PassportTicket="";    //filled in automatically

        #endregion //Public Fields

        #region Public Static Helpers

        /// <summary>
        /// Validates that there are no unacceptable duplicate headers.
        /// </summary>
        public static void CheckMinimalResponseHeaders(HttpClient.Response res)
        {
            if (res==null)
            {
                throw new ActiveAuthException("No response to check.");
            }

            //not the most effecient, but gets it done for now
            foreach (KeyValuePair<string,string> pair in res.Headers)
            {
                //check for duplicates of headers
                string []vals=res.GetHeaders(pair.Key);

                if (vals.Length>1)
                {
                    //only these are allowed duplicates
                    if (pair.Key=="WWW-Authenticate")
                    {}
                    else
                    {
                        throw new ActiveAuthException("Duplicate header found in response: "+pair.Key);
                    }
                }
            }
        }

        /// <summary>
        /// Validates that a WWW-Authenticate: WLID1.0 header contains valid fields.
        /// Returns the parsed WLID fields.
        /// </summary>
        public static Dictionary<string,string> CheckWLIDHeader(HttpClient.Response res)
        {
            Dictionary<string,string> fields=ParseWLIDHeader(res.GetSingleHeader("WWW-Authenticate"));

            //check field existance
            if (!fields.ContainsKey("realm")) throw new ActiveAuthException("WLID1.0 header was expected to contain a realm param.");
            if (!fields.ContainsKey("fault")) Global.RO.Debug("WLID1.0 header does not contain the optional fault param."); //optional
            if (!fields.ContainsKey("policy")) throw new ActiveAuthException("WLID1.0 header was expected to contain a policy param.");
            if (!fields.ContainsKey("ver")) throw new ActiveAuthException("WLID1.0 header was expected to contain a ver param.");

            //check field values
            if (fields["realm"]!="WindowsLive") throw new ActiveAuthException("WLID1.0 header had the wrong realm: "+fields["realm"]);

            //int fault=(int)Hexer.fromhex(fields["fault"]);
            //if (res.Status>=400 && fault==0) throw new System.Exception("WLID1.0 header had 0 fault param even though status was an error.");
            //else if (res.Status<300 && fault!=0) throw new System.Exception("WLID1.0 header had a non-0 fault param for an passing status.");

            string policy=fields["policy"].ToLower();
            if (!(policy=="mbi_key_old" || policy=="lbi" || policy=="mbi" || policy=="hbi" || policy=="hbi_60sectest" || policy=="hbi_ssl")) throw new Exception("WLID1.0 header had an unknown policy: "+policy);

            if (fields["ver"].Length<3) throw new ActiveAuthException("WLID1.0 ver param is too short.");
            if (fields["ver"].Length>14) throw new ActiveAuthException("WLID1.0 ver param is too long.");

            //check total count
            if (fields.Count<3 || fields.Count>4) throw new ActiveAuthException("WLID1.0 header has an unexpected number of parameters: "+fields.Count);

            return fields;
        }

        /// <summary>
        /// WWW-Authenticate value to extract the WLID1.0 parameters
        /// example: WLID1.0 realm="WindowsLive", fault="0x00000000", policy="mbi", ver="4.0.1532.0"
        /// </summary>
        public static Dictionary<string,string> ParseWLIDHeader(string headerValue)
        {
            Dictionary<string,string> dic=new Dictionary<string,string>();

            //WLID1.0 part
            string str=headerValue.Trim();
            if (str.Length<7) throw new ActiveAuthException("Header isn't long enough to be type WLID1.0");
            string headerTypePhrase=str.Substring(0,7);
            if (headerTypePhrase!="WLID1.0") throw new ActiveAuthException("Header isn't type WLID1.0");
            str=str.Substring(8);

            //params part
            int phase=0;
            string keyParse="";
            string valParse="";
            foreach (char c in str)
            {
                if (phase==0) //looking for key
                {
                    if (!(c==' ' || c==','))
                    {
                        phase=1;
                        keyParse+=c;
                    }
                }
                else if (phase==1) //parsing key
                {
                    if (c=='=')
                        phase=2;
                    else
                        keyParse+=c;
                }
                else if (phase==2) //looking for opening quote
                {
                    if (c=='"')
                        phase=3;
                    else
                        phase=0;
                }
                else if (phase==3) //parsing value
                {
                    if (c=='"') //hit closing quote
                    {
                        phase=0;

                        dic.Add(keyParse,valParse);
                        keyParse="";
                        valParse="";
                    }
                    else //part of val
                        valParse+=c;
                }
            }

            return dic;
        }

        #endregion //Public Static Helpers

        #region Public Methods

        /// <summary>
        /// Uses GET method to retrieve a page.  Gets a passport ticket and uses WLID1.0 auth if needed and able.
        /// </summary>
        /// <param name="uri">example: /somewhere/page.html</param>
        public HttpClient.Response GetPageResponse(string uri)
        {
            HttpClient.Request req=new HttpClient.Request(server, uri);
            return DoPageRequest(req);
        }

        /// <summary>
        /// Uses POST to send data to and retrieve a page.  Gets a passport ticket and uses WLID1.0 auth if needed and able.
        /// </summary>
        /// <param name="uri">example: /something/greatness.php</param>
        /// <param name="content">The content to send (can be null)</param>
        /// <param name="contentType">The type of the content to send (can be null).  Example: text/html</param>
        public HttpClient.Response PostPageRequest(string uri, byte []content, string contentType)
        {
            HttpClient.Request req=new HttpClient.Request(server, uri);
            req.Method="POST";
            if (content!=null) req.SetContentLengthAndBody(content);
            if (contentType!=null) req.OtherHeaders.AddLast("Content-Type: "+contentType);
            return DoPageRequest(req);
        }
        public HttpClient.Response PostPageRequest(string uri, string content, string contentType)
        {
            if (content==null) return PostPageRequest(uri,(byte[])null,contentType);
            else return PostPageRequest(uri,ByteEncoding.Instance.GetBytes(content),contentType);
        }

        #endregion //Public Methods

        #region Internals

        //connection
        string server;
        ushort port;
        HttpClient http;

        //does the actual work of making a request and getting a ticket if needed
        private HttpClient.Response DoPageRequest(HttpClient.Request req)
        {
            //If we have no ticket, make an unauthenticated request first
            if (PassportTicket.Length==0)
            {
                HttpClient.Response res;
                http.SendRequest(req);
                res=http.GetResponse();

                CheckMinimalResponseHeaders(res);
                if (res==null) throw new ActiveAuthException("Did not get a response from initial "+req.Method+" request to "+server+":"+port+", uri: "+req.URI);
                if (res.Status==200) return res;

                //If we got a 401, we need to get a ticket and try again using wlid
                if (res.Status!=401) return res;
                Dictionary<string,string> wlidFields=CheckWLIDHeader(res);

                if (PassportName.Length==0 || PassportPassword.Length==0) throw new ActiveAuthException("Got 401+WLID header.  Can't continue with request because a passport username and password are required for "+req.Method+" to: "+server+":"+port+", uri: "+req.URI);
                string policy=wlidFields["policy"];
                PassportTicket=AuthClientBase.GetAAPassportTicket(PassportName, PassportPassword, policy);
            }

            //We have a ticket, so try the request using a WLID1.0
            {
                req.OtherHeaders.AddFirst("Authorization: WLID1.0 t="+PassportTicket);
                http.SendRequest(req);

                return http.GetResponse();
            }
        }

        #endregion //Internals
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\AuthClientBase.cs ===
using System;
using System.Net;
using System.Diagnostics;
using System.Text;
using System.Runtime.InteropServices;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using System.IO;

using XOnExt = xonline.common.service.XOn;

namespace ServerTestFramework.LiveService.Auth
{
    public class LogonException : Exception
    {
        public LogonException(string message) : base(message) 
        { 
            //Global.RO.Error(message); 
        }
        public LogonException(string format, params object[] args) : base(String.Format(format, args)) 
        { 
            //Global.RO.Error(format, args); 
        }
    }
    
    public class PassportException : Exception
    {
        public string Name = "";
        public string Password = "";
        public string ErrorMessage = "";
        public int    Hr = 0;
        public string HrString = "";

        public PassportException() : base("PassportException")
        {
        }

        public PassportException (string message)
        {
            ErrorMessage = message;
        }

        public PassportException(string message, COMException e, string name, string password) : base(message, e)
        {
            Name = name;
            Password = password;
            ErrorMessage = message;
            Hr = e.ErrorCode;

            byte []hrStringBytes=new byte[1024];
            int hrStringBytesSize=hrStringBytes.Length;
            AuthClientBase.DLL_HrToString(Hr, hrStringBytes, ref hrStringBytesSize);
            HrString=ByteEncoding.Instance.GetString(hrStringBytes, 0, (int)hrStringBytesSize-1);
        }
            
        public PassportException(string message, string name, string password)
        { 
            Name = name;
            Password = password;
            ErrorMessage = message;
        }

        public override string Message
        {
            get
            {
                if (Name == "" && Password == "" && Hr == 0 && HrString == "")
                {
                    return ErrorMessage;
                }
                else
                {
                    return String.Format("{0} [name:{1} password:{2} hr:0x{3:X} ({4})]", ErrorMessage, Name, Password, Hr, HrString);
                }
            }
        }
    }

    public abstract class AuthClientBase
    {
        #region DllImports - Kerberos functions

        //
        // Xmacs
        //

        // New for Xenon!
        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildXenonMachineRequest", PreserveSig=false)]
        protected static extern void DLL_BuildXenonMachine(
            byte[]              pConsoleCert,
            int                 bSignConsoleCert,   // Controls whether the console cert gets signed or not
            int                 bUseTestXmacsKey,   // Use test xmacs key or real xmacs key
            byte[]              pTitleInfo,         // XeTitleInfo
            byte[]              pMachineUser,       // XonlinepUser
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pbMessage,
            ref int             cbMessage,
            IntPtr              pTgtContextToken,
            byte[]              pSerialNumberBytes); //12 bytes, normally ascii encoded normally, no null termination or anything

        // Old Xbox style
        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildXboxMachineRequest", PreserveSig=false)]
        protected static extern void DLL_BuildXboxMachine(
            byte[]              pTitleInfo,         // XeTitleInfo
            byte[]              pMachineUser,       // XonlinepUser
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pbMessage,
            ref int             cbMessage,
            IntPtr              pTgtContextToken);

         
        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyMachineReply", PreserveSig=false)]
        protected static extern void DLL_VerifyMachine(
            byte[]              pbMessage,
            int                 cbMessage,
            IntPtr              pTgtContextToken,
            byte[]              pUser);         // XonlinepUser
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_PassportInit", CharSet=CharSet.Unicode, PreserveSig=false)]
        private static extern void DLL_PassportInit(
            string              passportEnvironment); // "INT" or "PROD"
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_PassportTerm", PreserveSig=true)]
        public static extern void DLL_PassportTerm();

        [DllImport("kerbclient2.dll", EntryPoint = "kcl_PassportGetTicket", CharSet = CharSet.Unicode, PreserveSig = false)]
        protected static extern void DLL_PassportGetTicket(
            string              memberName,
            string              password,
            string              service,
            string              servicePolicy, //optionally null for the default of "MBI_KEY_OLD"
            bool                ticketAsBinary, //true if you want the ticket in binary form, false if you want it as an ascii string
            byte[]   /* out */  ticket,
            ref int             cbTicket,
            byte[]   /* out */  key,
            ref int             cbKey);

        [DllImport("kerbclient2.dll", EntryPoint = "kcl_BuildPcMachineRequest", PreserveSig = false, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        protected static extern void DLL_BuildPcMachineRequest(
            byte[]              ticket,
            int                 cbTicket,
            byte[]              pcId,
            int                 cbPcId,
            [MarshalAs(UnmanagedType.LPStr)]
            string              sponsorToken,
            byte[]              sessionKey,
            int                 cbSessionKey,
            [MarshalAs(UnmanagedType.LPStr)]
            string              clientName,           // "PC.@XBOX.COM"
            [MarshalAs(UnmanagedType.LPStr)]
            string              targetTicketRealm,    // "XBOX.COM"
            [MarshalAs(UnmanagedType.LPStr)]
            string              requestRealm,         // "MACS.XBOX.COM"
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            bool                bUseTestXmacsKey,
            byte[]              message,
            out int             cbMessage,
            IntPtr              pTgtContextToken);
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyPcMachine", PreserveSig=false)]
        protected static extern void DLL_VerifyPcMachine(
            byte[]              pbMessage,
            int                 cbMessage,
            IntPtr              pTgtContextToken,
            byte[]              pUser);         // XonlinepUser

        //
        // Askdc
        //

        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildAsRequest", PreserveSig=false)]
        protected static extern void DLL_BuildAs(
            byte[]              pTitleInfo,         // XeTitleInfo
            byte[]              pAsInfo,
            uint                cbAsInfo,
            uint                fMachineAccount,    // BOOL
            byte[]              pUser,              // XonlinepUser
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pEchoPreauthBytes,
            uint                cbEchoPreauthBytes,
            bool                allowFakeCompoundPreauth,
            byte[]              pbMessage,
            ref int             cbMessage,
            IntPtr              pTgtContextToken,
            IntPtr              pInputTgtContextToken);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyAsReply", PreserveSig=false)]
        protected static extern void DLL_VerifyAs(
            byte[]              pbMessage,
            int                 cbMessage,
            IntPtr              pTgtContextToken);

        //
        // Xkdc
        //

        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildXboxTgsRequest", PreserveSig=false)]
        protected static extern void DLL_BuildXboxTgs(
            byte[]              pTitleInfo,         // XeTitleInfo
            IntPtr              pCombinedTgtContextToken,
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pbMessage,
            ref int             cbMessage,
            byte[]              pXKerbServicecontext);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyXboxTgsReply", PreserveSig=false)]
        protected static extern void DLL_VerifyXboxTgs(
            IntPtr              pCombinedTgtContextToken,
            byte[]              pbMessage,
            int                 cbMessage,
            byte[]              pXKerbServicecontext);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildXenonTgsRequest", PreserveSig=false)]
        protected static extern void DLL_BuildXenonTgs(
            byte[]              pTitleInfo,             // XeTitleInfo
            IntPtr              pCombinedTgtContextToken,
            uint[]              pPreauthTypeList,   // array of preauth types to add if possible
            uint                PreauthTypeListLength, //length of pPreauthTypeList array
            byte[]              pbMessage,
            ref int             cbMessage,
            byte[]              pXKerbServicecontext);  // ServiceContextXe

        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyXenonTgsReply", PreserveSig=false)]
        protected static extern void DLL_VerifyXenonTgs(
            IntPtr              pCombinedTgtContextToken,
            byte[]              pbMessage,
            int                 cbMessage,
            byte[]              pXKerbServicecontext,  // ServiceContextXe
            byte[]              pSessionKeyFromTgt); //returned from kerbclient, 16 bytes

        //
        // SG
        //

        [DllImport("kerbclient2.dll", EntryPoint = "kcl_BuildTicketTgs", PreserveSig = false, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        protected static extern void DLL_BuildTicketTgs(
            byte[]              pAuthdata,
            [MarshalAs(UnmanagedType.LPStr)]
            string              szServerName,       // "sg" or "ts"
            [MarshalAs(UnmanagedType.LPStr)]
            string              szSiteName,         // "site1", "site9999", etc
            [MarshalAs(UnmanagedType.LPStr)]
            string              szTicketRealm,      // "XBOX.COM"
            [MarshalAs(UnmanagedType.LPStr)]
            string              szClientRealm,      // "PASSPORT.NET"
            [MarshalAs(UnmanagedType.LPStr)]
            string              szClientName1,      // "XE.538451958491@xbox.com"
            [MarshalAs(UnmanagedType.LPStr)]
            string              szClientName2,      // "PASSPORT.NET"
            byte[]              pbSessionKey,
            byte[]              pbSiteKey,
            long                qwTicketLifeSpan,
            byte[]              pbTicket,           // output
            out uint            cbMessage);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_BuildApRequest", PreserveSig=false)]
        public static extern void DLL_BuildAp(
            byte[]              pXKerbServiceContext,
            out long            pqwTime,
            byte[]              pbSha,
            uint                cbSha,      // 20
            byte[]              pbMessage,
            out int             cbMessage);


        [DllImport("kerbclient2.dll", EntryPoint="kcl_VerifyApReply", PreserveSig=false)]
        protected static extern void DLL_VerifyAp(
            byte[]              pXKerbServiceContext,
            long[]              pqwTimes,
            int                 cTimes,
            byte[]              pbSha,
            int                 cbSha,
            byte[]              pbMessage,
            int                 cbMessage);


        #endregion - Kerberos functions

        #region DllImports - Library functions, TicketModifier stuff

        [DllImport("kerbclient2.dll", EntryPoint="kcl_Initialize", PreserveSig=false)]
        private static extern void DLL_Initialize(
            out int             pdwStatus);

        // Black box factory! Fun! This is hopefully temporary until we can get these structures imported
        // into C#.  
        // Type is one of the following:
        //      0: TgtContext token
        //      
        public enum TokenType
        {
            TgtContext = 0
        };

        [DllImport("kerbclient2.dll", EntryPoint="kcl_CreateToken", PreserveSig=false)]
        public static extern void DLL_CreateToken(
            uint                TokenType,
            out                 IntPtr pToken,
            byte[]              pOptionalData,
            uint                cbOptionalData,
            uint                dwOptionalDword);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_DeleteToken", PreserveSig=false)]
        public static extern void DLL_DeleteToken(
            IntPtr              pToken);
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_HrToString")]
        public static extern int DLL_HrToString(
            int                 hr,
            byte              []pszErrorMsg,
            ref int             pszErrorMsgLength);
        
        [DllImport("kerbclient2.dll", EntryPoint="kcl_GetPassportAuthInfoFromToken", PreserveSig=false)]
        public static extern void DLL_GetPassportAuthInfoFromToken(
            IntPtr              pTgtContextToken,
            out uint            isInfoAvailable,
            out UInt64          userId,
            byte[] /* out */    gamertag,
            ref uint            gamertagLen);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_GetTicketTimeRemaining", PreserveSig=false)]
        public static extern void DLL_GetTicketTimeRemaining(
            byte[]              rgKeyXboxCom,
            IntPtr              pTgtContextToken,
            out int             nSecsLeft);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_AddToTicketTimeRemaining", PreserveSig=false)]
        public static extern void DLL_AddToTicketTimeRemaining(
            byte[]              rgKeyXboxCom,
            IntPtr              pTgtContextToken,
            int                 nSecsToAdd);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_CopyPuidsOutToTgtContext", PreserveSig=false)]
        public static extern void DLL_CopyPuidsOutToTgtContext(
            byte[]              rgKeyXboxCom,
            IntPtr              pTgtContextToken,
            out ulong           puidMachine,
            ulong[]             puidUsers);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_GetAuthDataStruct", PreserveSig=false)]
        public static extern void DLL_GetAuthDataStruct(
            byte[]              rgKeySite,
            byte[]              pXKerbServicecontext,  // ServiceContextXe
            byte[]              rgbAuthData, 
            out uint            pdwAuthDataSize, 
            out ushort          pwAuthDataVersion);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_SetAuthDataStruct", PreserveSig=false)]
        public static extern void DLL_SetAuthDataStruct(
            byte[]              rgKeySite,
            byte[]              pXKerbServicecontext,  // ServiceContextXe
            byte[]              rgbAuthData);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_LibrarySetTimeSkew")]
        public static extern void DLL_SetTimeSkew(
            long                nSkewSeconds);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_LibraryGetTimeSkew")]
        public static extern void DLL_GetTimeSkew(
            out long            nSkewSeconds);

        // -- fuzzy fun!
        [StructLayout(LayoutKind.Sequential, Pack=4)]
        public struct SFuzzParam
        {
            //0-1: chance the data will be modified
            public float chance; 
            //max number of bits changed
            public uint maxBits;
        };

        //asn fuzz type list -- this must remain in sync with the struct in kerbfuzz.h
        [StructLayout(LayoutKind.Sequential, Pack=4)]
        public struct SAsnFuzzParams
        {
            //key: (x) = not used directly by kerbclient, (*) = used directly by kerbclient

            //ber
            public SFuzzParam ber_charStr;      //ASN1BEREncCharString - (x) - used by ASN1DEREncCharString
            //SFuzzParam ber_charStr16;    //ASN1BEREncChar16String - (x)
            //SFuzzParam ber_charStr32;    //ASN1BEREncChar32String - (x)
            public SFuzzParam ber_octStr;       //ASN1BEREncOctetString - (x) - used by ASN1DEREncOctetString
            public SFuzzParam ber_bitStr;       //ASN1BEREncBitString - (x) - used by ASN1DEREncBitString
            //SFuzzParam ber_floatDouble;  //ASN1BEREncDouble - (x)
            //SFuzzParam ber_genTime;      //ASN1BEREncGeneralizedTime - (x)
            public SFuzzParam ber_int32;        //ASN1BEREncS32 - (*) - used BY a boatload of things - uses ASN1BEREncTag and ASN1BEREncLength
            //SFuzzParam ber_intX;         //ASN1BEREncSX - (x)
            //SFuzzParam ber_zeroMBString; //ASN1BEREncZeroMultibyteString - (x)
            //SFuzzParam ber_mbString;     //ASN1BEREncMultibyteString - (x)
            //SFuzzParam ber_null;         //ASN1BEREncNull - (x)
            public SFuzzParam ber_objIden1;     //ASN1BEREncObjectIdentifier - (*) - uses ASN1BEREncTag and ASN1BEREncLength
            //SFuzzParam ber_objIden2;     //ASN1BEREncObjectIdentifier2 - (x)
            //SFuzzParam ber_removeZero;   //ASN1BEREncRemoveZeroBits - (x)
            //SFuzzParam ber_utcTime;      //ASN1BEREncUTCTime - (x)
            //SFuzzParam ber_flush;        //ASN1BEREncFlush - (x)
            public SFuzzParam ber_openType;     //ASN1BEREncOpenType - (*)
            //SFuzzParam ber_check;        //ASN1BEREncCheck - (x)
            public SFuzzParam ber_tag;          //ASN1BEREncTag - (x)
            //public SFuzzParam ber_expTag;       //ASN1BEREncExplicitTag - (*) - used BY a boatload of things
            public SFuzzParam ber_eoc;          //ASN1BEREncEndOfContents - (*) - used BY a boatload of things
            public SFuzzParam ber_length;       //ASN1BEREncLength - (x)
            public SFuzzParam ber_u32;          //ASN1BEREncU32 - (*) - uses ASN1BEREncTag and ASN1BEREncLength
            public SFuzzParam ber_booll;        //ASN1BEREncBool - (*) - uses ASN1BEREncTag and ASN1BEREncLength
            //SFuzzParam ber_eoid;         //ASN1BEREncEoid - (x)
            //SFuzzParam ber_utf8;         //ASN1BEREncUTF8String - (x)

            //cer
            //SFuzzParam cer_charStr;      //ASN1CEREncCharString - (x)
            //SFuzzParam cer_charStr16;    //ASN1CEREncChar16String - (x)
            //SFuzzParam cer_charStr32;    //ASN1CEREncChar32String - (x)
            //SFuzzParam cer_bitStr;       //ASN1CEREncBitString - (x)
            public SFuzzParam cer_genTime;      //ASN1CEREncGeneralizedTime - (x) - used by ASN1DEREncGeneralizedTime
            //SFuzzParam cer_zeroMBString; //ASN1CEREncZeroMultibyteString - (x)
            //SFuzzParam cer_mbString;     //ASN1CEREncMultibyteString - (x)
            //SFuzzParam cer_octStr;       //ASN1CEREncOctetString - (x)
            //SFuzzParam cer_utcTime;      //ASN1CEREncUTCTime - (x)
            //SFuzzParam cer_blkBegin;     //ASN1CEREncBeginBlk - (x)
            //SFuzzParam cer_blkNew;       //ASN1CEREncNewBlkElement - (x)
            //SFuzzParam cer_blkFlush;     //ASN1CEREncFlushBlkElement - (x)
            //SFuzzParam cer_blkEnd;       //ASN1CEREncEndBlk - (x)
            //SFuzzParam cer_utf8;         //ASN1CEREncUTF8String - (x) - uses ASN1BEREncUTF8String

            //der
            //SFuzzParam der_getTime;      //ASN1DEREncGeneralizedTime - (*) - uses ASN1CEREncGeneralizedTime
            //SFuzzParam der_utcTime;      //ASN1DEREncUTCTime - (x) - uses ASN1CEREncUTCTime
            //SFuzzParam der_blkBegin;     //ASN1DEREncBeginBlk - (x) - uses ASN1CEREncBeginBlk
            //SFuzzParam der_blkNew;       //ASN1DEREncNewBlkElement - (x) - uses ASN1CEREncNewBlkElement
            //SFuzzParam der_blkFlush;     //ASN1DEREncFlushBlkElement - (x) - uses ASN1CEREncFlushBlkElement
            //SFuzzParam der_blkEnd;       //ASN1DEREncEndBlk - (x) - uses ASN1CEREncEndBlk
            //SFuzzParam der_charStr;      //ASN1DEREncCharString - (*) - uses ASN1BEREncCharString
            //SFuzzParam der_charStr16;    //ASN1DEREncChar16String - (x) - uses ASN1BEREncCharString16
            //SFuzzParam der_charStr32;    //ASN1DEREncChar32String - (x) - uses ASN1BEREncChar32String
            //SFuzzParam der_bitStr;       //ASN1DEREncBitString - (*) - uses ASN1BEREncBitString
            //SFuzzParam der_zeroMBString; //ASN1DEREncZeroMultibyteString - (x) - uses ASN1BEREncZeroMultibyteString
            //SFuzzParam der_mbString;     //ASN1DEREncMultibyteString - (x) - uses ASN1BEREncMultibyteString
            //SFuzzParam der_octStr;       //ASN1DEREncOctetString - (*) - uses ASN1BEREncOctetString
            //SFuzzParam der_utf8;         //ASN1DEREncUTF8String - (x) - uses ASN1BEREncUTF8String
        };

        [DllImport("kerbclient2.dll", EntryPoint="kcl_SetAsnFuzzParams")]
        unsafe public static extern void DLL_SetAsnFuzzParams(
            SAsnFuzzParams *paramss);

        //kerb request type list -- this must remain in sync with the struct in kerbfuzz.h
        [StructLayout(LayoutKind.Sequential, Pack=4)]
        public struct SRequestFuzzParams
        {
            //types to fuzz
            public SFuzzParam ticket;
            public SFuzzParam tgt;
            public SFuzzParam title;
            public SFuzzParam service;
            public SFuzzParam user;
            public SFuzzParam cert;
            public SFuzzParam strings;
            public SFuzzParam keys;
            public SFuzzParam misc; //PC ID, random bools, etc

            //methods to fuzz (0 or non-0 ... not using bool due to C# interop)
            public uint XkerbBuildAsRequest;
            public uint kcl_BuildXenonMachineRequest;
            public uint kcl_BuildXenonTgsRequest;
            public uint kcl_BuildPcMachineRequest;
            public uint kcl_BuildAsWithPassportRequest;
        };

        [DllImport("kerbclient2.dll", EntryPoint="kcl_SetRequestFuzzParams")]
        unsafe public static extern void DLL_SetKerbRequestFuzzParams(
            SRequestFuzzParams *paramss);

        //grabs the returned error data echo bytes from a tgt
        [DllImport("kerbclient2.dll", EntryPoint="kcl_GetTGTEchoBytes")]
        public static extern uint kcl_GetTGTEchoBytes(IntPtr pTGTContext, byte []pData, uint cbData);

        #endregion stuff

        #region DllImports - Crypto stuff
    
        [DllImport("kerbclient2.dll", EntryPoint="XcHMAC4")]
        public static extern void XcHmac4(
            byte[] pbKeySha, int cbKeySha, 
            byte[] pb1, int cb1, 
            byte[] pb2, int cb2, 
            byte[] pb3, int cb3, 
            byte[] pb4, int cb4, 
            byte[] pbHash, int cbHash);
    
        [DllImport("kerbclient2.dll", EntryPoint="XcHMAC4")]
        unsafe public static extern void XcHmac4Unsafe(
            byte[] pbKeySha, int cbKeySha, 
            byte * pb1, int cb1, 
            byte * pb2, int cb2, 
            byte * pb3, int cb3, 
            byte * pb4, int cb4, 
            byte[] pbHash, int cbHash);
    

        [DllImport("kerbclient2.dll", EntryPoint="XcHMAC4WithKeyTable")]
        public static extern void XcHmac4WithKeyTable(
            byte[] pbKeyTable, 
            byte[] pb1, int cb1, 
            byte[] pb2, int cb2, 
            byte[] pb3, int cb3, 
            byte[] pb4, int cb4, 
            byte[] pbHash, int cbHash);

        [DllImport("kerbclient2.dll", EntryPoint="XcHMAC4WithKeyTable")]
        unsafe public static extern void XcHmac4WithKeyTableUnsafe(
            byte[] pbKeyTable, 
            byte * pb1, int cb1, 
            byte * pb2, int cb2, 
            byte * pb3, int cb3, 
            byte * pb4, int cb4, 
            byte[] pbHash, int cbHash);


        [DllImport("kerbclient2.dll", EntryPoint="XcCrypt")]
        public static extern void XcCrypt(
            uint dwOp, 
            byte[] pbKey, uint cbKey, 
            byte[] pbIv, 
            byte[] pb1, uint cb1,
            byte[] pb2, uint cb2);

        [DllImport("kerbclient2.dll", EntryPoint="XcCrypt2")]
        public static extern void XcCrypt2(
            uint cipherType,
            uint dwOp, 
            byte[] pbKey, uint cbKey, 
            byte[] pbIv, uint cbIv,
            byte[] pb1, uint cb1,
            byte[] pb2, uint cb2);

        [DllImport("kerbclient2.dll", EntryPoint="XcCrypt")]
        unsafe public static extern void XcCryptUnsafe(
            uint dwOp, 
            byte[] pbKey, uint cbKey, 
            byte[] pbIv, 
            byte * pb1, uint cb1,
            byte * pb2, uint cb2);


        [DllImport("kerbclient2.dll", EntryPoint="XcCryptWithKeyTable")]
        public static extern void XcCryptWithKeyTable(
            uint dwOp, 
            byte[] pbKeyTable, uint cbKey, 
            byte[] pbIv, 
            byte[] pb1, uint cb1,
            byte[] pb2, uint cb2);

        [DllImport("kerbclient2.dll", EntryPoint="XcCryptWithKeyTable")]
        unsafe public static extern void XcCryptWithKeyTableUnsafe(
            uint dwOp, 
            byte[] pbKeyTable, uint cbKey, 
            byte[] pbIv, 
            byte * pb1, uint cb1,
            byte * pb2, uint cb2);


        [DllImport("kerbclient2.dll", EntryPoint="XcDESKeyParity")]
        public static extern void XcDESKeyParity(
            byte[] pbKey,
            uint cbKey);

        [DllImport("kerbclient2.dll", EntryPoint="XcKeyTable")]
        public static extern void XcKeyTable(
            uint dwCipher,
            byte[] pbKeyTable,      // output
            byte[] pbKey);          // input

        [DllImport("kerbclient2.dll", EntryPoint="XcHMACMakeKeyTable")]
        public static extern void XcHMACMakeKeyTable(
            byte[] pbKeyMaterial,   // input
            uint cbKeyMaterial,     // input
            byte[] pbKey);          // output

        [DllImport("kerbclient2.dll", EntryPoint="ComputeDHGX")]
        public static extern void ComputeDHGX(
            byte[] pGX,
            byte[] pX);

        [DllImport("kerbclient2.dll", EntryPoint="ComputeDHGXY")]
        public static extern void ComputeDHGXY(
            byte[] pGXY,
            byte[] pGY,
            byte[] pX);

        // Constants for the dwOp parameter
        public const uint XC_SERVICE_ENCRYPT = 1;
        public const uint XC_SERVICE_DECRYPT = 0;

        // Constants for cipherType parameter
        public const uint XC_SERVICE_DEFAULT_CIPHER = 0xffffffff;
        public const uint XC_SERVICE_DES_CIPHER     = 0;
        public const uint XC_SERVICE_DES3_CIPHER    = 1;
        public const uint XC_SERVICE_AES_CIPHER     = 2;
        public const uint XC_SERVICE_AES256_CIPHER  = 0xff000002;
        public const uint XC_SERVICE_NULL_CIPHER    = 3;


        #endregion

        #region DllImports - KerbClient debug spew access

        [DllImport("kerbclient2.dll", EntryPoint="kcl_EnableDebugSpewCapture")]
        public static extern void kcl_EnableDebugSpewCapture(int enableLevel);

        [DllImport("kerbclient2.dll", EntryPoint="kcl_GetDebugSpewSize")]
        public static extern uint kcl_GetDebugSpewSize();

        [DllImport("kerbclient2.dll", EntryPoint="kcl_GetDebugSpew")]
        public static extern void kcl_GetDebugSpew(byte []buffer, uint bufferSize);

        #endregion

        // Constants.  Really.
        //
        public const int    k_Sha_Digest_Len        = 20;

        public static readonly int WAIT_AFTER_MACHINE_ACCOUNT_CREATION_IN_MS = 2000; //from client code: logon.cpp
        public static readonly int MAX_KERB_RETRIES = 6; //from client code: xkerberos.h
        public static int []c_dwDefaultKerbRetryDelayInMilliSeconds = new int[] { 2000, 2000, 2000, 2000, 2000, 2000 }; //from client code: from logon.cpp
        public static int []c_dwDefaultMACSRetryDelayInMilliSeconds = new int[] { 4000, 4000, 4000, 4000, 4000, 4000 }; //from client code: from logon.cpp

        // Static, publicly available helper members
        //
        static public ASCIIEncoding     ascii               = new ASCIIEncoding();
        static public RandomEx          rand                = new RandomEx();
        static public DeterministicRandom randfuzz          = new DeterministicRandom();

        // Protected base members
        //
        protected static readonly int  DefaultPacketSize    = 1500;
        protected byte[]                packet              = new byte[DefaultPacketSize];
        protected int                   packetLength        = DefaultPacketSize;
        protected byte[]                packetRecv          = null;
        protected int                   packetRecvLength    = 0;
        protected static int            fuzzIterations      = 0;      //number of bytes to fuzz
        protected static float          fuzzChance          = 0.0f;   //chance that the packet will be fuzzed (0-1)
        protected bool                  isSignedIn          = false;
        protected IPEndPoint            ipServer            = null;
        protected AuthContext           authContext         = null;

        // Public properties and members
        //
        public static int               DefaultTimeoutInMs  = 2000;
        public bool                     isManualSetup       = false;
        public int                      TimeoutInMs         = DefaultTimeoutInMs;
        public DateTime                 ClientBirth         = DateTime.Now; // time of this client's birth

        // kerbclient talk
        public enum KerbClientDebugLevel
        {
            Off=0,
            Warn=1,
            All=2
        }
        static protected Report roKerb = new Report("KerbClient");
        public static KerbClientDebugLevel KerbClientDebugSpew
        {
            get { return kerbClientDebugSpew; }
            set
            {
                kerbClientDebugSpew=value;
                kcl_EnableDebugSpewCapture((int)value);
            }
        }
        private static KerbClientDebugLevel kerbClientDebugSpew = KerbClientDebugLevel.Warn;

        public bool IsSignedIn
        {
            //get { return isSignedIn; }
            get { return (authContext != null ? authContext.SecKeys != null : false); }
        }

        public AuthContext Context
        {
            get { return authContext; }
            //set { authContext = value; }
        }

        public IPEndPoint IpServer
        {
            get { return ipServer; }
        }

        public byte[] SendPacketBuffer
        {
            get { return packet; }
        }

        public int SendPacketBufferLength
        {
            get { return packetLength; }
        }

        public byte[] ReceivePacketBuffer
        {
            get { return packetRecv; }
            set { packetRecv = value; }
        }

        public int ReceivePacketBufferLength
        {
            get { return packetRecvLength; }
            set { packetRecvLength = value; }
        }

        // "Fake" adjust our clock in relation to the KDC's clock.
        // Expressed in seconds. Static.
        public static long TimeSkew
        {
            get
            {
                long timeSkew;
                AuthClientBase.DLL_GetTimeSkew(out timeSkew);
                return timeSkew;
            }
            set
            {
                AuthClientBase.DLL_SetTimeSkew(value);
            }
        }

        private static string idcrlInitEnvironment=null;
        private static bool isKerbClientInitialized=false;
        private static object dllInitLock=new object();

        /// <summary>
        /// Inits passport IDCRL for the "INT" passport environment.  This is required before you can obtain tickets.
        /// This also calls InitializeKerbClient().
        /// </summary>
        public static bool InitializePassportIDCRL()
        {
            return InitializePassportIDCRL("INT");
        }

        /// <summary>
        /// Inits passport IDCRL for a specific passport environment.  This is required before you can obtain tickets.
        /// This also calls InitializeKerbClient().
        /// </summary>
        public static bool InitializePassportIDCRL(string passportEnvironment)
        {
            InitializeKerbClient();

            lock (dllInitLock)
            {
                if (idcrlInitEnvironment==passportEnvironment)
                {
                    return true;
                }

                //for the vastly most common case here, int, lets verify that IDCRL is actually configured correctly, and fix it if needed
                if (passportEnvironment.ToLower()=="int")
                {
                    object val=Microsoft.Win32.Registry.GetValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\IdentityCRL\\Environment\\INT", "RemoteFile", null);
                    if (val==null) //not setup, so set it up
                    {
                        Global.RO.Info("IDCRL is not configured for INT.  Adding setting to IDCRL for INT environment.");

                        //add registry key
                        Microsoft.Win32.Registry.SetValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\IdentityCRL\\Environment\\INT", "RemoteFile", "http://clientconfig.passport-int.net/PPCRLconfig.srf", Microsoft.Win32.RegistryValueKind.String);

                        //Normally we would delete cache in like C:\Documents and Settings\<user>\Application Data\Microsoft\IdentityCRL also... however... for a "fresh" client this is not needed... and it's also user-specific, and we don't know (or possibly even have access to) all possible users.  For now, lets just skip this step.
                    }
                }
                else
                {
                    Global.RO.Debug("Not verifying IDCRL configuration for IDCRL environment "+passportEnvironment);
                }

                //

                try
                {
                    DLL_PassportInit(passportEnvironment);
                }
                catch (Exception e)
                {
                    string HrString = "<unknown>";
                    int errorCode=0;
                    if (e is COMException)
                    {
                        errorCode=(e as COMException).ErrorCode;

                        byte []hrStringBytes=new byte[1024];
                        int hrStringBytesSize=hrStringBytes.Length;
                        DLL_HrToString(errorCode, hrStringBytes, ref hrStringBytesSize);
                        HrString=ByteEncoding.Instance.GetString(hrStringBytes, 0, (int)hrStringBytesSize-1);
                    }

                    Global.RO.Fatal("Passport IDCRL Init failed for passport environment: "+passportEnvironment+".  You will not be able to retrieve passport tickets.  Error=0x"+string.Format("{0:X}",errorCode)+": "+HrString);
                    idcrlInitEnvironment=null;
                    return false;
                }
                finally
                {
                    SpewKerbclientDebug();
                }

                Global.RO.Info("Successfully initialized IDCRL for passport environment: "+passportEnvironment);
                idcrlInitEnvironment=passportEnvironment;
                return true;
            }
        }

        /// <summary>
        /// Prepares KerbClient for use.  This must be done before it is valid to call any of the dll exports into kerbclient.
        /// </summary>
        public static bool InitializeKerbClient()
        {
            lock (dllInitLock)
            {
                if (isKerbClientInitialized)
                {
                    return true;
                }

                int status = -1;
                try
                {
                    AuthClientBase.DLL_Initialize(out status);
                    Global.RO.Info("Successfully initialized kerbclient, status=0x{0:X}", status);
                }
                catch (Exception e)
                {
                    Global.RO.Fatal("Error initializing kerbclient, status=0x{1:X}.  Exception: {1}", status, e.ToString());
                    return false;
                }
                finally
                {
                    SpewKerbclientDebug();
                }

                isKerbClientInitialized=true;
                return true;
            }
        }

        /// <summary>
        /// Base constructor. Doesn't do much. (It does init kerbclient if needed though)
        /// </summary>
        public AuthClientBase(AuthContext ctx, IPEndPoint ip, bool manualSetup)
        {
            if (!isKerbClientInitialized)
            {
                InitializeKerbClient();
            }

            authContext = ctx;
            ipServer = ip;
            isManualSetup = manualSetup;
            if (packet == null)
            {
                packet = new byte[DefaultPacketSize];
                packetLength = DefaultPacketSize;
            }

            // TODO: determine the environment we are running in. Set keySite1 and keyXboxCom to appropriate key
            // for the environment. 
        }

        protected void SendRecv(string serverName)
        {
            bool fuzz = (fuzzIterations>0 && fuzzChance>0.0f);
            if (fuzz)
            {
                fuzz = ((float)rand.NextDouble() < fuzzChance);
            }
            
            if (fuzz)
            {
                // Randomly mutate some bytes
                randfuzz.MutateBytes(packet, packetLength, fuzzIterations);
            }

            //clear anything already in the receive buffer (potentially leftover from previous timeouts)
            byte []clearBytes;
            do
            {
                clearBytes=authContext.Udp.Recv(0);
            } while(clearBytes!=null && clearBytes.Length>0);

            //do send and receive
            Send();
            Recv(TimeoutInMs);
            if (packetRecv == null)
            {
                throw new ServerTestFramework.Utilities.TimeoutException(String.Format("{0} -> {1}/{2} timed out in {3}ms", authContext.Udp.LocalIP.ToString(), serverName, ipServer.ToString(), TimeoutInMs));
            }
        }

        protected void Send()
        {
            // Send it
            authContext.Udp.SendFast(packet, (int)packetLength, ipServer);
        }

        protected void Recv(int timeoutInMs)
        {
            // Recv it
            packetRecv = authContext.Udp.RecvFast(timeoutInMs, out packetRecvLength);
        }

        //Used for negative replay attack cases
        public void ResendLastPacket()
        {
            if (packetLength==0 || packet==null || packet.Length==0)
            {
                throw new Exception("No packet to send");
            }

            Send();
        }

        public void ResendLastPacketAndRecv()
        {
            ResendLastPacket();
            Recv(TimeoutInMs);
            if (packetRecv == null)
            {
                throw new ServerTestFramework.Utilities.TimeoutException(String.Format("{0} -> {1} timed out in {2}ms", authContext.Udp.LocalIP.ToString(), ipServer.ToString(), TimeoutInMs));
            }
        }

        //
        public static void SetFuzzParameters(int iterations, float chance)
        {
            fuzzIterations = iterations;
            fuzzChance = chance;
        }

        /// <summary>
        /// Builds gamertag (principal) for a machine based on the console id
        /// </summary>
        /// <param name="ConsoleId">Input 5-byte console id</param>
        /// <param name="Gamertag">Output 15 character gamertag for machine name</param>
        public static void BuildXenonConsolePrincipal(byte[] ConsoleId, byte[] Gamertag)
        {
            long qwConsoleId = 0;
            for (int i = 0; i < ConsoleId.Length; i++)
            {
                qwConsoleId = (qwConsoleId << 8) + ConsoleId[i];
            }

            // First nibble is the verification digit, remaing 36 bits form the console id
            uint dwDigit = (uint)(qwConsoleId & 0xF);
            qwConsoleId >>= 4;
            string s = String.Format("XE.{0:D11}{1:D1}", qwConsoleId, dwDigit);
            StringToBytes(Gamertag, s);
        }

        public static void StringToBytes(byte[] destArray, string srcString)
        {
            // Fill with zeros first
            FillBytes(destArray, 0);
            if (srcString == null || srcString.Length == 0)
                return;
            int srcCount = Math.Min(ascii.GetByteCount(srcString), destArray.Length);
            ascii.GetBytes(srcString, 0, srcCount, destArray, 0);
        }

        public static string BytesToString(byte[] srcBytes)
        {
            return ascii.GetString(srcBytes).TrimEnd(new char[] {'\0'});
        }

        public static void FillBytes(byte[] destArray, byte val)
        {
            for (int i = 0; i < destArray.Length; i++)
            {
                destArray[i] = val;
            }
        }

        public enum PassportSite
        {
            KdcPanorama,
            KdcXenon,
            ActiveAuth
        };

        public static string GetPassportSite(PassportSite rpsSiteToUse)
        {
            string rpsSite;
            if (!Global.IsEnvironmentInternal)
            {
                Global.RO.Debug("Using kdc.test.xboxlive.com for RPS site, since we can't pull it from npdb.");
                rpsSite="kdc.test.xboxlive.com";
            }
            else
            {
                if (rpsSiteToUse==PassportSite.KdcPanorama)
                {
                    rpsSite=GetSinglePassportSiteFromMultisetting("kdcsvc_managed_rpsPCSites");
                }
                else if (rpsSiteToUse==PassportSite.KdcXenon)
                {
                    rpsSite=GetSinglePassportSiteFromMultisetting("kdcsvc_managed_rpsXenonSites");
                }
                else if (rpsSiteToUse==PassportSite.ActiveAuth)
                {
                    rpsSite=Global.XEnv.GetSetting("aamodule_Rps_site");
                }
                else
                {
                    throw new System.Exception("Invalid rps site: "+rpsSiteToUse);
                }
            }

            return rpsSite;
        }

        private static string GetSinglePassportSiteFromMultisetting(string multisettingName)
        {
            string []settings=Global.XEnv.MultiSettingRead(multisettingName);
            if (settings.Length==0)
            {
                throw new System.Exception("Passport multisetting "+multisettingName+" has no entries in npdb.  Cannot determine passport site to use.");
            }
            else if (settings.Length>1)
            {
                Global.RO.Warn("Passport multisetting "+multisettingName+" has more than one entry in npdb.  Using '"+settings[0]+"', but that MAY NOT BE THE CORRECT VALID CHOICE.  Please update this logic to determine the correct value to use in all cases.");
                return settings[0];
            }
            else
            {
                return settings[0];
            }
        }

        //intended for kdc use only
        public static void GetPassportTicket(
            string passportMemberName,
            string passportPassword,
            out byte[] ticket,
            out byte[] sessionKey,
            string servicePolicy,
            PassportSite rpsSiteToUse)
        {
            GetPassportTicket(passportMemberName, passportPassword, out ticket, out sessionKey, servicePolicy, GetPassportSite(rpsSiteToUse));
        }

        //intended for kdc use only
        public static void GetPassportTicket(
            string passportMemberName,
            string passportPassword,
            out byte[] ticket,
            out byte[] sessionKey,
            string servicePolicy,
            string rpsSite)
        {
            byte[] ticketScratch = new byte[2048];
            byte[] keyScratch    = new byte[100];
            int cbTicket = ticketScratch.Length;
            int cbKey = keyScratch.Length;

            // initialize idcrl if necessary (to default environment)
            if (idcrlInitEnvironment == null)
            {
                if (!InitializePassportIDCRL())
                {
                    throw new PassportException("Passport initialization failed, see log for more information.");
                }
            }

            for (int i=0; i<3; ++i) //retry up to 3 times
            {
                try
                {
                    Global.RO.Debug("[Passport] Retrieving \"{0}\" ticket for user \"{1}\", pw \"{2}\" on site \"{3}\"",
                        servicePolicy,
                        passportMemberName,
                        passportPassword,
                        rpsSite);

                    DLL_PassportGetTicket(
                        passportMemberName,
                        passportPassword,
                        rpsSite,
                        servicePolicy,
                        true,
                        ticketScratch,
                        ref cbTicket,
                        keyScratch,
                        ref cbKey);
                    break;
                }
                catch (COMException e)
                {
                    if (i==2)
                    {
                        throw new PassportException("Error getting ticket", e, passportMemberName, passportPassword);
                    }
                    else
                    {
                        Global.RO.Warn("Exception getting passport ticket for "+passportMemberName+" (will retry): "+e.Message);
                        System.Threading.Thread.Sleep(1000+4000*i);
                    }
                }
                finally
                {
                    SpewKerbclientDebug();
                }
            }

            if (cbTicket == 0)
                throw new PassportException("No ticket returned", passportMemberName, passportPassword);
            ticket = new byte[cbTicket];
            Buffer.BlockCopy(ticketScratch, 0, ticket, 0, cbTicket);

            if (cbKey == 0 && servicePolicy.ToLower().Contains("key"))
                throw new PassportException("No session key returned", passportMemberName, passportPassword);
            sessionKey = new byte[cbKey];
            Buffer.BlockCopy(keyScratch, 0, sessionKey, 0, cbKey);
        }

        //intended for kdc use only
        public static void GetPassportTicketSelfGen (
            string passportMemberName,
            long puid,
            out byte[] ticket,
            out byte[] sessionKey)
        {
            string xmacsRpsSite = "kdc.test.xboxlive.com"; //default to test environments
            if (!Global.IsEnvironmentInternal)
            {
                Global.RO.Debug("Using kdc.test.xboxlive.com for RPS site, since we can't pull it from npdb.");
            }
            else
            {
                xmacsRpsSite = Global.XEnv.GetSetting("kdcsvc_xmacs_Rps_site");
            }

            RPSTicketGen.TicketParameters ticketParams = new RPSTicketGen.TicketParameters();
            ticketParams.MemberName = passportMemberName;
            ticketParams.Puid = puid;
            ticketParams.CId = RPSTicketGen.TicketGen.ComputeCId(puid, DateTime.UtcNow);
            ticketParams.SiteId = ConvertSiteNameToNumber(xmacsRpsSite);
            ticketParams.Environment = ConvertSiteNameToCert(xmacsRpsSite);

            RPSTicketGen.TicketGen.GenerateTicketBytes(ticketParams, out ticket, out sessionKey);
        }

        //intended for activeauth use
        public static string GetAAPassportTicket (
            string passportMemberName,
            string passportPassword,
            string servicePolicy       //if null, default of MBI_KEY_OLD is used
            )
        {
            //TODO: what service for aa?
            string rpsSite = "kdc.test.xboxlive.com"; //default to test environments
            if (!Global.IsEnvironmentInternal)
            {
                Global.RO.Debug("Using kdc.test.xboxlive.com for RPS site, since we can't pull it from npdb.");
            }
            else
            {
                rpsSite = Global.XEnv.GetSetting(xonline.common.config.Setting.aamodule_Rps_site);
            }

            return GetAAPassportTicket(passportMemberName, passportPassword, servicePolicy, rpsSite);
        }

        //intended for activeauth use
        public static string GetAAPassportTicket(
            string passportMemberName,
            string passportPassword,
            string servicePolicy,       //if null, default of MBI_KEY_OLD is used
            string rpsSite
            )
        {
            byte[] ticketScratch = new byte[2048];
            byte[] keyScratch    = new byte[100];
            int cbTicket = ticketScratch.Length;
            int cbKey = keyScratch.Length;

            // initialize idcrl if necessary (to default environment)
            if (idcrlInitEnvironment == null)
            {
                if (!InitializePassportIDCRL())
                {
                    throw new PassportException("Passport initialization failed, see log for more information.");
                }
            }

            //get the ticket
            for (int i=0; i<3; ++i) //retry up to 3 times
            {
                try
                {
                    Global.RO.Debug("[Passport] Retrieving \"{0}\" ticket for user \"{1}\", pw \"{2}\"",
                        servicePolicy,
                        passportMemberName,
                        passportPassword);

                    DLL_PassportGetTicket(
                        passportMemberName,
                        passportPassword,
                        rpsSite,
                        servicePolicy,
                        false,
                        ticketScratch,
                        ref cbTicket,
                        keyScratch,
                        ref cbKey);
                    break;
                }
                catch (COMException e)
                {
                    if (i==2)
                    {
                        throw new PassportException("Error getting ticket", e, passportMemberName, passportPassword);
                    }
                    else
                    {
                        Global.RO.Warn("Exception getting passport ticket for "+passportMemberName+" (will retry): "+e.Message);
                        System.Threading.Thread.Sleep(1000+4000*i);
                    }
                }
                finally
                {
                    SpewKerbclientDebug();
                }
            }

            if (cbTicket == 0) throw new PassportException("No ticket returned", passportMemberName, passportPassword);

            //convert ascii ticket to string
            return Encoding.ASCII.GetString(ticketScratch,0,cbTicket-1);
        }

        /// <summary>
        /// Uses the RPS ticket generator to make a ticket locally.
        /// </summary>
        public static string GetAAPassportTicketSelfGen (
            string passportMemberName,
            long puid
            )
        {
            string rpsSite = "kdc.test.xboxlive.com"; //default to test environments
            if (!Global.IsEnvironmentInternal)
            {
                Global.RO.Debug("Using kdc.test.xboxlive.com for RPS site, since we can't pull it from npdb.");
            }
            else
            {
                rpsSite = Global.XEnv.GetSetting(xonline.common.config.Setting.aamodule_Rps_site);
            }

            return GetAAPassportTicketSelfGen(passportMemberName, puid, rpsSite);
        }

        /// <summary>
        /// Uses the RPS ticket generator to make a ticket locally.
        /// </summary>
        public static string GetAAPassportTicketSelfGen (
            string passportMemberName,
            long puid,
            string rpsSite
            )
        {
            RPSTicketGen.TicketParameters ticketParams = new RPSTicketGen.TicketParameters();
            ticketParams.MemberName = passportMemberName;
            ticketParams.Puid = puid;
            ticketParams.CId = RPSTicketGen.TicketGen.ComputeCId(puid, DateTime.UtcNow);
            ticketParams.SiteId = ConvertSiteNameToNumber(rpsSite);
            ticketParams.Environment = ConvertSiteNameToCert(rpsSite);

            return RPSTicketGen.TicketGen.GenerateTicket(ticketParams);
        }

        /// <summary>
        /// Uses the RPS ticket generator to make a ticket locally.
        /// </summary>
        public static string GetAAPassportDelegationTicketSelfGen(
            string passportMemberName,
            long puid,
            string rpsSite,
            string offerDotAction,
            long appId,
            System.DateTime ?expireTime
            )
        {
            RPSTicketGen.TicketParameters ticketParams = new RPSTicketGen.TicketParameters();
            ticketParams.TicketType = RPSTicketGen.TicketParameters.PassportTicketType.Delegation;
            ticketParams.MemberName = passportMemberName;
            ticketParams.Puid = puid;
            ticketParams.CId = RPSTicketGen.TicketGen.ComputeCId(puid, DateTime.UtcNow);
            ticketParams.SiteId = ConvertSiteNameToNumber(rpsSite);
            ticketParams.Environment = ConvertSiteNameToCert(rpsSite);
            ticketParams.OfferDotAction = offerDotAction;
            ticketParams.AppId = appId;

            if (expireTime!=null)
            {
                ticketParams.ExpireTime=(System.DateTime)expireTime;
            }

            return RPSTicketGen.TicketGen.GenerateTicket(ticketParams);
        }

        /// <summary>
        /// Converts our site names to their corresponding numbers.  Only for INT.
        /// </summary>
        public static uint ConvertSiteNameToNumber (string site)
        {
            site = site.Trim().ToLower();

            switch (site)
            {
                    // xblob
                case "kdc.xblob.xboxlive.com": return 267168;
                case "xuacs.xblob.xboxlive.com": return 267168;
                    // cert
                case "kdc.xboxlive.com": return 64173;
                case "xuacs.cert.xboxlive.com": return 64174;
                    // prod
                case "xuacs.xboxlive.com": return 76285;
                    // stress1, stress2, testnet
                case "kdc.test.xboxlive.com": return 64155;
                case "xuacs.test.xboxlive.com": return 64146;
                    // XSTS Del tokens
                case "xsts.test.xboxlive.com": return 285307;
                    // xbox.com sites
                case "live.test.xbox.com": return 60278;
                case "live.stress2.xbox.com": return 258199;
                case "live.stress.xbox.com": return 250338;
                case "live.storax.xbox.com": return 269655;
                case "live.dev.xbox.com": return 60733;
                case "live.part.xbox.com": return 61056;
                case "live.nobs.xbox.com": return 272648;
                case "live.cert.xbox.com": return 267529;
            }

            throw new ArgumentOutOfRangeException("site", site, "Given site value is unknown.");
        }

        /// <summary>
        /// Converts our site names to their corresponding environment cert.  Only for INT.
        /// </summary>
        public static RPSTicketGen.TicketParameters.EnvironmentEnum ConvertSiteNameToCert (string site)
        {
            site = site.Trim().ToLower();

            switch (site)
            {
                // xblob
                case "kdc.xblob.xboxlive.com":
                case "xuacs.xblob.xboxlive.com":
                    return RPSTicketGen.TicketParameters.EnvironmentEnum.Xblob;
                // cert
                // stress1, stress2, testnet
                case "kdc.xboxlive.com":
                case "xuacs.cert.xboxlive.com":
                case "kdc.test.xboxlive.com":
                case "xuacs.test.xboxlive.com":
                default:
                    return RPSTicketGen.TicketParameters.EnvironmentEnum.IntRps;

                // xbox.com sites
                case "live.test.xbox.com":
                case "live.stress2.xbox.com":
                case "live.stress.xbox.com":
                case "live.storax.xbox.com":
                case "live.dev.xbox.com":
                case "live.part.xbox.com":
                case "live.nobs.xbox.com":
                case "live.cert.xbox.com":
                    return RPSTicketGen.TicketParameters.EnvironmentEnum.IntXboxCom;
            }

            throw new ArgumentOutOfRangeException("site", site, "Given site value is unknown.");
        }

        //
        public static void SetTimestamp(byte[] data, int dataOffset, uint sequenceNum, ulong timestamp)
        {
            if (data != null && data.Length >= dataOffset + 4)
            {
                // We must be super uber fast, no allocating of nothin'.
                data[dataOffset + 0] = (byte)((sequenceNum       ) & 0xFF);
                data[dataOffset + 1] = (byte)((sequenceNum  >>  8) & 0xFF);
                data[dataOffset + 2] = (byte)((sequenceNum  >> 16) & 0xFF);
                data[dataOffset + 3] = (byte)((sequenceNum  >> 24) & 0xFF);
            }
            if (data != null && data.Length >= dataOffset + 12)
            {
                long ticks = (long)timestamp;
                //long ticks = DateTime.Now.Ticks - ClientBirth.Ticks;
                data[dataOffset + 4] = (byte)((ticks      ) & 0xFF);
                data[dataOffset + 5] = (byte)((ticks >>  8) & 0xFF);
                data[dataOffset + 6] = (byte)((ticks >> 16) & 0xFF);
                data[dataOffset + 7] = (byte)((ticks >> 24) & 0xFF);
                data[dataOffset + 8] = (byte)((ticks >> 32) & 0xFF);
                data[dataOffset + 9] = (byte)((ticks >> 40) & 0xFF);
                data[dataOffset +10] = (byte)((ticks >> 48) & 0xFF);
                data[dataOffset +11] = (byte)((ticks >> 56) & 0xFF);
            }
        }

        public static void GetTimestamp(byte[] data, int dataOffset, out uint sequenceNum, out ulong timestamp)
        {
            sequenceNum = 0;
            timestamp = 0;
            if (data != null && data.Length >= dataOffset + 4)
            {
                int v = 
                    (data[dataOffset + 0]      ) +
                    (data[dataOffset + 1] <<  8) +
                    (data[dataOffset + 2] << 16) +
                    (data[dataOffset + 3] << 24);
                sequenceNum = (uint)v;
            }
            if (data != null && data.Length >= dataOffset + 12)
            {
                long v =
                    (data[dataOffset + 4]       ) +
                    (data[dataOffset + 5]  <<  8) +
                    (data[dataOffset + 6]  << 16) +
                    (data[dataOffset + 7]  << 24) +
                    (data[dataOffset + 8]  << 32) +
                    (data[dataOffset + 9]  << 40) +
                    (data[dataOffset + 10] << 48) +
                    (data[dataOffset + 11] << 56);
                timestamp = (ulong)v;
            }
        }

        // call this to output any debug from kerbclient (if enabled) for the most recent call on the current thread
        public static void SpewKerbclientDebug()
        {
            if (KerbClientDebugSpew==KerbClientDebugLevel.Off)
            {
                return;
            }

            //get the message, as ascii bytes
            uint msgSize=kcl_GetDebugSpewSize();
            if (msgSize==0)
            {
                return;
            }
            byte []msg=new byte[msgSize];
            kcl_GetDebugSpew(msg, msgSize);

            //convert to widechar and output each line
            string str=ByteEncoding.Instance.GetString(msg, 0, (int)msgSize-1);
            string []strLines=str.Split(new char[]{'\n'});
            foreach (string line in strLines)
            {
                roKerb.Debug(line);
            }
        }

        // Abstract functions
        abstract protected void Initialize(AuthContext ctx);

        //abstract static public void SetDefaults(AuthContext ctx);

        //Helper used by both the managed and native kdc clients to verify whether ServiceAddress6 was returned in the correct cases
        public static void VerifyXkdcResponseCommon(int requestVersion, bool gotServiceAddressFailed, bool gotValidTicket, bool ?overrideServiceAddressFailedExpectation, uint overallHr, uint []userHR, bool isAutodiscover, bool ?overrideValidTicketExpectation)
        {
            //valid ticket pexpectations
            bool expectValidTicket=gotValidTicket; //we won't verify most cases for this, just a few specific ones, so default to correct
            bool anyBanned=false;

            if (userHR[0]==0x80151200 || userHR[1]==0x80151200 || userHR[2]==0x80151200 || userHR[3]==0x80151200) //XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
            {
                expectValidTicket=true;
            }

            if (userHR[0]==0x80154005 || userHR[1]==0x80154005 || userHR[2]==0x80154005 || userHR[3]==0x80154005) //XONLINE_E_ACCOUNTS_ACCOUNT_BANNED
            {
                anyBanned=true;
                expectValidTicket=false;
            }

            if (overallHr!=0)
            {
                expectValidTicket=false;
            }

            if (overallHr==0x8015190D) //XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED
            {
                anyBanned=true;
            }

            if (overrideValidTicketExpectation!=null)
            {
                expectValidTicket=(bool)overrideValidTicketExpectation;
            }

            //service address failed expectations
            bool expectServiceAddressFailed=false;

            if (requestVersion>=6)
            {
                expectServiceAddressFailed=!gotValidTicket;

                if (anyBanned)
                {
                    expectServiceAddressFailed=true;
                }

                if (overrideServiceAddressFailedExpectation!=null)
                {
                    expectServiceAddressFailed=(bool)overrideServiceAddressFailedExpectation;
                }
            }

            //
            ValueCheck.Test("Valid ticket returned by the xkdc", expectValidTicket, gotValidTicket);
            ValueCheck.Test("Response contained ServiceAddressFailed preauth", expectServiceAddressFailed, gotServiceAddressFailed);

            //For service address failed, we should NEVER get account requires management or unknown trust since those require valid tickets to process
            if (gotServiceAddressFailed)
            {
                if (userHR[0]==0x80151200 || userHR[1]==0x80151200 || userHR[2]==0x80151200 || userHR[3]==0x80151200) //XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
                {
                    throw new UnexpectedTestResultException("A UserHR was XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT(0x80151200) in a ServiceAddressFailed.");
                }

                if (userHR[0]==0x80151013 || userHR[1]==0x80151013 || userHR[2]==0x80151013 || userHR[3]==0x80151013) //XONLINE_E_LOGON_USER_UNKNOWN_TRUST
                {
                    throw new UnexpectedTestResultException("A UserHR was XONLINE_E_LOGON_USER_UNKNOWN_TRUST(0x80151013) in a ServiceAddressFailed.");
                }
            }
        }
    }

    /// <summary>
    /// This class holds all auth-related information and is passed around between the 
    /// various auth clients (xmacs, askdc, xkdc, sg). It is test-oriented, so a lot of 
    /// information is exposed. However, it should also be very simple to use for mainline 
    /// stuff. Each auth client has its own requirements for what fields need to be set 
    /// prior to signing in and what fields are set after signing in. Refer to the 
    /// IsSignedIn* properties for the post-signin fields, and refer to the SetDefaults() 
    /// function in each client for the pre-signin fields.
    /// </summary>
    public class AuthContext : IDisposable
    {
        // What kind of client is this?
        protected ClientTypes           clientType          = ClientTypes.Xenon;

        // XMACS Xenon
        public bool                     UseXmacsTestKey     = false;
        //public IntPtr                   TokenCrypto         = IntPtr.Zero;
        public ConsoleCertificate       ConsoleCert         = null;
        public string                   ConsoleSerialNumber = null; // If not null it must be 12 bytes.  Only applicable if UseXenonMac2 is true.
        public bool                     UseXenonMac2        = true; // Whether Xbox360 requests should use the xenonmac1 or xenonmac2 preauth

        // XMACS Panorama
        public int                      DefaultPcXmacsPreauth = 1;  //1: use original preauth.  2: use encrypted passport preauth.

        // XKDC Xenon
        public ServiceContextXe         ServiceCtxXe        = null;     // Set before & afer XKDC
        public ulong                    FlowToken           = 0;        // used in the request only

        // XKDC Xbox
        public ServiceContextXbox       ServiceCtxXbox      = null;     // Set before & afer XKDC

        // KDCs and Panorama
        public const int                PcIdLength          = 8;

        // Panorama and Passport stuff (XMACS and ASKDC)
        public string                   PassportMemberName  = null;
        public string                   PassportPassword    = null;
        public string                   PassportTicketPolicy="";        //policy used to retrieve the currently stored passport ticket
        public byte[]                   PassportTicket      = null;
        public byte[]                   PassportSessionKey  = null;
        public bool                     IncludeEncryptedPassportByDefault = false; //if set, pc user requests will use the encrypted passport preauth for askdc rather than the old passport preauth, and xbox360 askdc user requests will include the preauth

        public byte[]                   PcId                = null; 
        public string                   SponsorToken        = null;
        public bool                     IsPCLimited         = false;    // if true, then we expect that the machine is a limited machine account
        public uint                     LimitedMacsLeft     = 100;      //number of uses remaining for a passport for limited machine creation

        // SG
        public SecReg                   SecKeys             = null;     // set after SG sign in (key exchange)
        public SiteInfo                 Site                = null;     // data for current site
        public long                     TicketLifetimeInMS  = (long) 1000 * (60*60*24*365); // one year 

        // All
        public XeTitleInfo              TitleInfo           = null;     // Used multiple places
        public XonlinepUser[]           Users               = null;     // Used multiple places
        public XonlinepUser             MachineUser         = null;     // pre-xmacs
        public XonlinepUser             UsersMachine        = null;     // post-xmacs
        public TgtContext               CombinedTgt         = null;     // for ASKDC
        public Authdata_Base            Authdata            = null;     // post-XKDC

        // Preauths to use (see kerbStructs.cs) - xmacs,askdc,xkdc - null means use default valid ones
        public uint[]                   PreAuthListXmacs    = null;
        public uint[]                   PreAuthListAskdc    = null;
        public uint[]                   PreAuthListXkdc     = null;

        //XenonServiceRequest preauth version to use for the request.  Currently only applicable to Xbox360 and PC.
        //0 = automatically pick a sane default for the current platform
        //4 = original xenon preauth (struct#2, v4)
        //5 = updated xenon preauth that supports 128 services (struct#3, v5)
        public int                      XenonPreauthVersion = 0;

        public bool?                    ExpectXkdcServiceAddressFailed = null; //Only relevent to request versions 6+.  null means "default expectations", else this overrides expectations.
        public bool?                    ExpectXkdcValidTicket = null; //null means "default expectations", else this overrides expectations.

        public bool                     AskdcFirstUserHasTgt = false;

        /// <summary>When set to true, this context is intended to be used for an LSP connection.</summary>
        public bool                     IsLspContext         = false;

        // ASKDC
        public AsRequestInfo            KerbAsRequestInfo    = null;

        // Note: Users[4] plus UsersMachine represent the inputs to the ASKDC client.  The 
        // MachineUser field is used as an input to XMACS. I know the names are confusing.

        // Not auth related
        //private AuthTransportLayer      _Transport           = null;
        public SimpleUdpSG              Udp                 = null;

        // Constants.  But not really.  Override them for negative tests.
        //
        public string k_MacsKerberosRealm                   = "MACS.XBOX.COM";
        public string k_PassportKerberosRealm               = "PASSPORT.NET";
        public string k_XboxKerberosRealm                   = "XBOX.COM";
        public string k_TicketClientName1                   = "XE.538451958491@xbox.com"; // TGS
        public string k_TicketClientName2                   = "PASSPORT.NET";             // TGS
        public string k_PcMachineName                       = "PC.@XBOX.COM";             // Panorama
        //public string k_PcUserName                          = "PC.USER@XBOX.COM";       // Panorama - value here is correct but this variable no longer used

        // Enums
        //

        public enum ClientTypes
        {
            Xbox,                   // Xbox console, Xbox title
            Xenon,                  // Xenon console, Xenon title
            XenonBackCompat,        // Xenon console, Xbox title
            Panorama                // Windows machine
        }

        // Read/write properties
        //

        public ClientTypes ClientType
        {
            get { return clientType; }
            set { clientType = value; SetDefaults(); }
        }

        public bool IsXenonConsole 
        {
            get { return ClientType == ClientTypes.Xenon || ClientType == ClientTypes.XenonBackCompat; }
        }

        public bool IsXenonTitle
        {
            get { return ClientType == ClientTypes.Xenon; }
        }

        public bool IsPanorama
        {
            get { return ClientType == ClientTypes.Panorama; }
        }

        public bool IsSignedInXmacs
        {
            get { return this.UsersMachine != null; } 
        }

        public bool IsSignedInAskdc
        {
            get { return this.CombinedTgt != null; }
        }

        public bool IsSignedInXkdc
        {
            get { return (IsXenonTitle && ServiceCtxXe != null) || (!IsXenonTitle && ServiceCtxXbox != null); }
        }

        public bool IsSignedInSg
        {
            get { return this.SecKeys != null; }
        }

        public int NumUsers
        {
            get
            {
                int num = 0;
                if (Users == null)
                    return 0;
                for (int i = 0; i < Users.Length; i++)
                {
                    if (Users[i] != null)
                        num++;
                }
                return num;
            }
        }

#if false
        /// <summary>
        /// Public accessor for lazy instantiation of Transport object
        /// </summary>
        public AuthTransportLayer Transport
        {
            get
            {
                if (_Transport == null)
                {
                    _Transport = new AuthUdpLayer();
                }
                return _Transport;
            }
            set { _Transport = value; }
        }
#endif

        /// <summary>
        /// Construct an AuthContext as a Xenon client
        /// </summary>
        public AuthContext ()
        {
            clientType = ClientTypes.Xenon;
            Initialize();
        }

        /// <summary>
        /// Construct an AuthContext with a specific client type
        /// </summary>
        /// <param name="type">What kind of client to simulate</param>
        public AuthContext(ClientTypes type)
        {
            clientType = type;
            Initialize();
        }

        /// <summary>
        /// Construct an AuthContext with a specific client type.
        /// </summary>
        /// <param name="type">What kind of client to simulate.</param>
        /// <param name="createUdp">If true, creates a SimpleUdpSg; if false, does not.</param>
        public AuthContext (ClientTypes type, bool createUdp)
        {
            clientType = type;
            Initialize(createUdp);
        }

        /// <summary>
        /// Copy constructor for faking out the SG for improving stress test performance
        /// </summary>
        /// <param name="ctx"></param>
        public AuthContext(AuthContext ctx, byte[] serviceContextBytes, byte[] authdataBytes)
        {
            // We're only doing a minimal subset of members for faking out the SG

            // Client type
            this.clientType = ctx.clientType;

            // ServiceContext
            if (ctx.ServiceCtxXe != null)
            {
                this.ServiceCtxXe = new ServiceContextXe();
                if (serviceContextBytes != null)
                    this.ServiceCtxXe.ReadBytes(serviceContextBytes);
                else
                    this.ServiceCtxXe.ReadBytes((byte[])ctx.ServiceCtxXe);
            }
            else if (ctx.ServiceCtxXbox != null)
            {
                this.ServiceCtxXbox = new ServiceContextXbox();
                if (serviceContextBytes != null)
                    this.ServiceCtxXbox.ReadBytes(serviceContextBytes);
                else
                    this.ServiceCtxXbox.ReadBytes((byte[])ctx.ServiceCtxXbox);
            }

            // Authdata
            this.Authdata = Authdata_Base.NewDefaultOfSameType(ctx.Authdata);
            if (authdataBytes != null)
                this.Authdata.ReadBytes(authdataBytes);
            else
                this.Authdata.ReadBytes((byte[])(ctx.Authdata));
                        
            // Users
            // shallow copy OK, it's read-only
            this.Users = (XonlinepUser[])ctx.Users.Clone();

            // Title info
            this.TitleInfo = new XeTitleInfo(ctx.TitleInfo.TitleId, ctx.TitleInfo.TitleVersion, ctx.TitleInfo.TitleGameRegion);

            // Udp - shared!
            this.Udp = ctx.Udp;
        }

        public void Initialize ()
        {
            Initialize(true);
        }

        public void Initialize (bool createUdp)
        {
            if (createUdp)
            {
                Udp = new SimpleUdpSG();
            }

            // These can, and should, be changed depending on what and who you want 
            // to log in with.
            TitleInfo = new XeTitleInfo();
            KerbAsRequestInfo=new AsRequestInfo();
            MachineUser = new XonlinepUser();
            Users = new XonlinepUser[4];

            SetDefaults();
        }

        public void SetDefaults()
        {
            // Default title depends on whether we are an Xbox or Xenon title
            if (IsXenonTitle)
                SetTitle(0xC0FE0800, 1, 1);
            else if (IsPanorama)
                SetTitle(0xC0FE0900, 1, 1);
            else
                SetTitle(0xFFC0FE00, 1, 1);

            // Set to default value, allows user to override in XML file
            this.UseXmacsTestKey = XmacsClient.UseXmacsTestKey();
        }

        /// <summary>
        /// Sets the title to be the 'dash' title depending on platform.
        /// </summary>
        public void SetDashTitle ()
        {
            if (IsXenonTitle)
                SetTitle(XOnExt.XENON_DASH_TITLE_ID, 1, 1);
            else if (IsPanorama)
                SetTitle(XOnExt.PC_DASH_TITLE_ID, 1, 1);
            else
                SetTitle(XOnExt.DASH_TITLE_ID, 1, 1);
        }

        /// <summary> Get a ticket from Passport and store it in the auth context. </summary>
        public void PassportAuthenticate(string policy, AuthClientBase.PassportSite rpsSiteToUse)
        {
            PassportAuthenticate(policy, AuthClientBase.GetPassportSite(rpsSiteToUse));
        }

        /// <summary> Get a ticket from Passport and store it in the auth context. </summary>
        public void PassportAuthenticate(string policy, string rpsSite)
        {
            if (policy==null || policy=="")
            {
                policy="MBI_KEY_OLD"; //original panorama policy
            }

            // Create a new passport user if none has been supplied
            if (PassportMemberName==null)
            {
                UacsCommon uc=new UacsCommon();
                UacsCommon.PassportUser passportUser=null;
                for (int i=0; i<10; ++i)
                {
                    try
                    {
                        passportUser=uc.CreatePassportUser();
                        break;
                    }
                    catch (Exception e)
                    {
                        if (i==9) throw;
                        Global.RO.Debug("CreatePassportUser failed(will retry):"+e.Message);
                    }
                }

                PassportMemberName=passportUser.MemberName;
                PassportPassword=passportUser.Password;
            }

            AuthClientBase.GetPassportTicket(
                PassportMemberName,
                PassportPassword,
                out PassportTicket,
                out PassportSessionKey,
                policy,
                rpsSite);
            PassportTicketPolicy=policy;
        }

        /// <summary> Get a ticket from Passport for the given user and password and store it in the auth context. </summary>
        public void PassportAuthenticate(string passportMemberName, string passportPassword, string policy, AuthClientBase.PassportSite rpsSiteToUse)
        {
            PassportAuthenticate(passportMemberName, passportPassword, policy, AuthClientBase.GetPassportSite(rpsSiteToUse));
        }

        /// <summary> Get a ticket from Passport for the given user and password and store it in the auth context. </summary>
        public void PassportAuthenticate(string passportMemberName, string passportPassword, string policy, string rpsSite)
        {
            this.PassportMemberName=passportMemberName;
            this.PassportPassword=passportPassword;
            PassportAuthenticate(policy, rpsSite);
        }

        /// <summary> Sets the machine from a MachineEditor, so that an askdc request can be performed using it (skips xmacs). </summary>
        public void SetMachine(ServerTestFramework.Database.MachineEditor machine)
        {
            MachineUser=new XonlinepUser();
            UsersMachine=MachineUser;

            MachineUser.xuid.qwUserID=machine.Id;
            MachineUser.SetGamertag(machine.GetDecoratedConsoleId());
            AuthClientBase.StringToBytes(MachineUser.Domain, "XBOX.COM");
            AuthClientBase.StringToBytes(MachineUser.KerberosRealm, "PASSPORT.NET");
            MachineUser.Key=machine.CalculateKey();
        }

        /// <summary>
        /// Create an XonlinepUser object with the given gamertag and 
        /// a default generated user key
        /// </summary>
        /// <param name="name">The gamertag of the new user</param>
        /// <returns>A new user object with the given gamertag</returns>
        public static XonlinepUser MakeUser(string name)
        {
            return MakeUser(name, null);
        }

        /// <summary>
        /// Create an XonlinepUser object with the given gamertag and
        /// user key
        /// </summary>
        /// <param name="name">The gamertag of the new user</param>
        /// <param name="key">The user key of the user</param>
        /// <returns>A new user object with the given gamertag</returns>
        public static XonlinepUser MakeUser(string name, byte[] key)
        {
            if (name == null)
                return null;

            XonlinepUser user = new XonlinepUser();
            AuthClientBase.StringToBytes(user.Gamertag, name);
            AuthClientBase.StringToBytes(user.Domain, "XBOX.COM");
            AuthClientBase.StringToBytes(user.KerberosRealm, "PASSPORT.NET");
            if (key == null)
            {
                user.Key=CalculateKeyFromGamertag(name, true);
            }
            else if (key.Length != user.Key.Length)
            {
                throw new Exception("User key length should be 16 bytes long");
            }
            else
            {
                Array.Copy(key, 0, user.Key, 0, user.Key.Length);
            }
            return user;
        }

        /// <summary>
        /// Creates a user with the given gamertag and puts them into a slot of this context
        /// </summary>
        /// <param name="name">The gamertag of the user to create</param>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        public void SetUser(string name, int slot)
        {
            SetUser(MakeUser(name), slot);
        }

        /// <summary>
        /// Sets a provided user into the indicated slot of this context
        /// </summary>
        /// <param name="user">The UACS user account to set.  Make sure this user has been Create()ed</param>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        public void SetUser(XeUser user, int slot)
        {
            if (IsPanorama && PassportMemberName == null && user.PassportMemberName != null) //for panorama the passport info is needed
            {
                SetUserPassport(user);
            }

            // Create an XonlienpUser account from the UACS user data and set that into the slot
            SetUser(MakeUser(user.Gamertag, user.m_response.XenonKey), slot, user.UserPuid);
        }

        /// <summary>
        /// Sets a provided user into the indicated slot of this context
        /// </summary>
        /// <param name="user">The UACS user account to set.  Make sure this user has been Created</param>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        /// <param name="key">xenon key.</param>
        public void SetUser( XeUser user, int slot, byte[] key )
        {
            if ( IsPanorama && PassportMemberName == null && user.PassportMemberName != null ) //for panorama the passport info is needed
            {
                SetUserPassport( user );
            }

            // Create an XonlienpUser account from the UACS user data and set that into the slot
            SetUser( MakeUser( user.Gamertag, key ), slot, user.UserPuid );
        }

        /// <summary>
        /// Sets a provided user into the indicated slot of this context
        /// </summary>
        /// <param name="user">The user account to set.</param>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        public void SetUser(KdcUser user, int slot)
        {
            if (IsPanorama)
            {
                SetUserPassport(user);
            }

            // Create an XonlienpUser account from the user data and set that into the slot
            SetUser(MakeUser(user.Gamertag, user.XenonKey), slot, user.UserID);
        }

        /// <summary>
        /// Sets a provided user into the indicated slot of this context
        /// </summary>
        /// <param name="user">The DB-based user account</param>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        public void SetUser(ServerTestFramework.Database.UserEditor user, int slot)
        {
            if (IsPanorama && PassportMemberName==null) //for panorama the passport info is needed
            {
                Global.RO.Warn("A UserEditor instance does not have access to passport info, so cannot (by itself) be used for Panorama.  Please set passport info in the AuthContext manually.");
            }

            // Create an XonlinepUser account from the UserEditor data and the set that into the slot
            SetUser(MakeUser(user.Gamertag, (user.CurrentAccountType==0?user.XboxKey:user.XenonKey)), slot, user.Puid);
        }

        /// <summary>
        /// Sets the provided user into the indicated slot of this context
        /// </summary>
        /// <param name="user">The user object to populate the slot with</param>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        /// <param name="userPuid">The user puid to set in the slot</param>
        public void SetUser(XonlinepUser user, int slot, ulong userPuid)
        {
            SetUser(user, slot);
            Users[slot].xuid.qwUserID = userPuid;
        }

        /// <summary>
        /// Sets the provided user into the indicated slot of this context
        /// </summary>
        /// <param name="user">The user object to populate the slot with</param>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        public void SetUser(XonlinepUser user, int slot)
        {
            if (Users == null || slot < 0 || slot >= Users.Length)
                return;
            Users[slot] = user;
            if (this.CombinedTgt != null)
            {
                this.CombinedTgt.Dispose();
                this.CombinedTgt = null;
            }

            if (IsPanorama && PassportMemberName==null) //for panorama the passport info is needed
            {
                Global.RO.Warn("SetUser called with a XonlinepUser for a panorama client, but their passport info is not set.");
            }
        }

        /// <summary>
        /// Create a new KdcUser object using the given parameters
        /// </summary>
        /// <param name="createPassport">If true, create a passport for the user</param>
        /// <param name="createAsGold">If true, create the user as a gold user, else create a silver user</param>
        /// <returns>A new KdcUser object</returns>
        public static KdcUser MakeNewGenericUser(bool createPassport, bool createAsGold)
        {
            return MakeNewGenericUser(createPassport, createAsGold, false);
        }

        /// <summary>
        /// Create a new KdcUser object using the given parameters
        /// </summary>
        /// <param name="createPassport">If true, create a passport for the user</param>
        /// <param name="createAsGold">If true, create the user as a gold user, else create a silver user</param>
        /// <returns>A new KdcUser object</returns>
        public static KdcUser MakeNewGenericUser(bool createPassport, bool createAsGold, bool createMachine)
        {
            //create them
            KdcUser user=new KdcUser();
            user.CreateUser(createPassport);

            //set their subscription
            ServerTestFramework.Database.UserEditor ue=ServerTestFramework.Database.UserEditor.FromPuid(user.UserID);
            ue.RemoveAllSubscriptions(true);
            ue.AddBaseSubscription(createAsGold ? ServerTestFramework.Database.BaseSubscriptions.Xbox360Gold : ServerTestFramework.Database.BaseSubscriptions.Xbox360Silver);

            //set their machine
            if (createMachine)
            {
                ulong machinePuid=ServerTestFramework.Database.MachineEditor.CreateNew(ServerTestFramework.Database.MachineType.Xbox360).Id;
                ue.MachinePuid=unchecked((long)machinePuid);
            }

            return user;
        }

        /// <summary>
        /// Create a new XeUser object using the given parameters, which can be used for billing stuff.
        /// </summary>
        /// <param name="createPassport">If true, create a passport for the user</param>
        /// <param name="createAsGold">If true, create the user as a gold user, else create a silver user</param>
        /// <returns>A new XeUser object</returns>
        public static XeUser MakeNewBillingUser(bool createPassport, bool createAsGold, bool createMachine)
        {
            // Sometimes the billing box can be really slow, so lets increase the timeout
            FDTransaction.sReceiveTimeOut = 110 * 1000;

            ulong machinePuid = 0;

            if (createMachine)
            {
                machinePuid = ServerTestFramework.Database.MachineEditor.CreateNew(ServerTestFramework.Database.MachineType.Xbox360).Id;
            }

            // Create the user
            int retryCount = 5;
            XeUser user = null;
            for (uint i = 0; i <= retryCount; ++i)
            {
                if (createMachine)
                {
                    user = new XeUser(createPassport, machinePuid);
                }
                else
                {
                    user = new XeUser(createPassport);
                }

                user.CreateAsGold = createAsGold;

                Exception lastException = null;

                try
                {
                    lastException = null;
                    if (user.Create() != 0)
                    {
                        // Successfully created a user
                        break;
                    }
                }
                catch (IOException ioe)
                {
                    if (i == retryCount-1)
                    {
                        // These usually indicate that the request is timing out waiting at the service
                        // If we're on the last retry attempt, let's try an offer that works more often
                        user.CreateOffer = ServerTestFramework.LiveService.Billing.Offers.BaseOffers.GoldSignup;
                    }
                    lastException = new Exception("Request probably timed out, this is probably a billing issue", ioe);
                }
                catch (Exception e)
                {
                    lastException = e;
                }

                // So the user creation failed here
                // Clear the user
                Global.RO.Debug(user.GetDumpString());
                user = null;

                if (i < retryCount)
                {
                    // So we failed, but didn't get an exception.  Wait a bit then try again
                    Global.RO.Debug("Create user failed, will retry");

                    // Sometimes the billing box can be really slow, so lets increase the recieve timeout
                    int timeoutStep = 5 * 1000; // 5 Seconds
                    FDTransaction.sReceiveTimeOut += timeoutStep;

                    // Sleep for a bit
                    System.Threading.Thread.Sleep(1000*(int)i);
                }
                else
                {
                    // We're not retrying anymore
                    throw new Exception("Failed to create an Xbox Live billing user", lastException);
                }

            }

            return user;
        }

        /// <summary>
        /// Create a new silver KdcUser object and populate the given slot with it
        /// </summary>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        /// <returns>The silver user that was created and populated into the slot</returns>
        public KdcUser SetNewUser(int slot)
        {
            return SetNewUser(slot, false);
        }

        /// <summary>
        /// Create a new KdcUser object and populate the given slot with it
        /// </summary>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        /// <param name="createAsGold">If true, the user is created as a gold user</param>
        /// <returns>The user that was created and populated into the slot</returns>
        public KdcUser SetNewUser(int slot, bool createAsGold)
        {
            KdcUser user=MakeNewGenericUser(false, createAsGold);

            XonlinepUser xbluser=MakeUser(user.Gamertag, user.XenonKey);
            SetUser(xbluser, slot);
            return user;
        }

        /// <summary>
        /// Create a new silver KdcUser with a passport and populate the given slot with it
        /// </summary>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        /// <returns>The silver user that was created and populated into the slot</returns>
        public KdcUser SetNewPassportUser(int slot)
        {
            return SetNewPassportUser(slot, false);
        }

        /// <summary>
        /// Create a new XeUser object with a passport and populate the given slot with it
        /// </summary>
        /// <param name="slot">The slot to populate. Can be slot 1 to 4 (i.e. controller ports).</param>
        /// <param name="createAsGold">If true, the user is created as a gold user</param>
        /// <returns>The user that was created and populated into the slot</returns>
        public KdcUser SetNewPassportUser(int slot, bool createAsGold)
        {
            KdcUser user=MakeNewGenericUser(true, createAsGold);

            SetUserPassport(user);

            XonlinepUser xbluser=MakeUser(user.Gamertag, user.XenonKey);
            SetUser(xbluser, slot);
            return user;
        }

        /// <summary>
        /// Sets the passport info for this context from a given user
        /// </summary>
        /// <param name="user">The user to get passport info from</param>
        public void SetUserPassport(XeUser user)
        {
            if (String.IsNullOrEmpty(user.PassportMemberName))
            {
                throw new Exception("SetUserPassport requires that the user have a passport.");
            }

            PassportMemberName = user.PassportMemberName;
            PassportPassword = user.PassportPassword;
        }

        /// <summary> Sets the passport info for this context from a given user if they have one, else does nothing.  If the user has more than one ticket for different policies cached, one is picked at random without any preferance. </summary>
        public void SetUserPassport(KdcUser user)
        {
            if (user.Passport!=null)
            {
                PassportMemberName=user.Passport.UserName;
                PassportPassword=user.Passport.Password;

                PassportTicket ticket=user.Passport.GetRandomCachedTicket();
                if (ticket!=null)
                {
                    PassportTicket=ticket.Bytes;
                    PassportSessionKey=ticket.Key;
                }
            }
        }

        /// <summary>
        /// If there are any users associated with thi context, clear them out
        /// </summary>
        public void ClearUsers()
        {
            if (Users == null)
            {
                return;
            }

            for (int i = 0; i < Users.Length; i++)
            {
                Users[i] = null;
            }

            if (this.CombinedTgt != null)
            {
                this.CombinedTgt.Dispose();
                this.CombinedTgt = null;
            }
        }

        public static byte[] CalculateKeyFromGamertag(string gamertag, bool xenon)
        {
            char []gamertagChars=gamertag.ToLower().ToCharArray();
            byte[] rawkey = new byte[16];
            for (int i=0; i<15 && i<gamertagChars.Length; ++i)
            {
                rawkey[i]=(byte)gamertagChars[i];
            }
            rawkey[15]=(byte)(xenon?2:1);
            return rawkey;
        }

        public void ClearPassport()
        {
            PassportMemberName = null;
            PassportPassword = null;
            PassportTicket = null;
            PassportSessionKey = null;
            PassportTicketPolicy = "";
        }

        public void SetTitle(uint id, uint ver, uint reg)
        { 
            TitleInfo.TitleId = id;
            TitleInfo.TitleVersion = ver;
            TitleInfo.TitleGameRegion = reg;
        }
        
        public XkdcResult GetXkdcResult()
        {
            XkdcResult sr;
            if (IsXenonTitle || IsPanorama)
            {
                if (this.ServiceCtxXe == null)
                    return null;
                sr = this.ServiceCtxXe.GetXkdcResult();
            }
            else
            {
                if (this.ServiceCtxXbox == null)
                    return null;
                sr = this.ServiceCtxXbox.GetXkdcResult();
            }
            sr.authData = this.Authdata;
            sr.MachineOnly = (NumUsers == 0);
            return sr;
        }

        public IPEndPoint GetSGSiteIP()
        {
            IpAddr a = ((IsXenonTitle || IsPanorama) ? 
                (ServiceCtxXe == null ? null : ServiceCtxXe.siteIPAddress) :
                (ServiceCtxXbox == null ? null : ServiceCtxXbox.siteIPAddress));
            if (a == null)
                return null;
            IPEndPoint ep = a.GetIPEndPoint();
            ep.Port = 3074;
            return ep;
        }

        public byte[] GetSessionKey()
        {
            byte[] key = ((IsXenonTitle || IsPanorama) ? 
                (ServiceCtxXe == null ? null : ServiceCtxXe.SessionKey) :
                (ServiceCtxXbox == null ? null : ServiceCtxXbox.SessionKey));
            return key;
        }

        public void ClearPcMachine()
        {
            ClearXmacs();
            ClearPassport();
        }

        public void ClearXmacs()
        {
            // Clear result
            this.UsersMachine = null;
            ClearAskdc();
        }

        public void ClearAskdc()
        {
            if (this.CombinedTgt != null)
            {
                this.CombinedTgt.Dispose();
                this.CombinedTgt = null;
            }
            ClearXkdc();
        }

        public void ClearXkdc()
        {
            this.ServiceCtxXbox = null;
            this.ServiceCtxXe = null;
            ClearSg();
        }

        public void ClearSg()
        {
            this.SecKeys = null;
        }


        #region IDisposable Members

        public void Dispose()
        {
            if (CombinedTgt != null)
            {
                CombinedTgt.Dispose();
                CombinedTgt = null;
            }
        }

        #endregion
    }





}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Arbitration\XRLTimeExtend.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Arbitration
{
	/// <summary>
	/// Arbitration TimeExtend request XRLPayload.
	/// </summary>
	public class XRLTimeExtend : XRLPayload
	{
		sealed public class Flags
		{
			public const ushort flagMask=0;
		}

		public ushort protocolVersion=1;
		public ushort flags=0;
		[XRLPayloadFld(IsTitleId=true)]
		public uint titleId=XOn.DASH_TITLE_ID;
		public ulong sessionId=0UL;
		public ulong sessionNonce=0UL;
		public ushort maxSessionSecondsFromNow=0;

		[XRLPayloadFld(Serialize=false)]
		public ulong machinePuid=defaultMPuid;
		[XRLPayloadFld(Serialize=false)]
		public int ReceiveTimeOut = 35000;
		[XRLPayloadFld(Serialize=false)]
		public static bool fFrontDoor=true;

		public XRLTimeExtend()
		{
			ServiceId=XOService.Arbitration;
			transport=FDTransaction.Transports.UDP;
		}

		public XRLTimeExtend DeepClone()
		{
			// Start with a shallow clone
			XRLTimeExtend clone = (XRLTimeExtend)this.MemberwiseClone();
			// Clone XRLPayload objects
			XRLPayload clonePayload = (XRLPayload)clone;
			base.DeepCloneTo(ref clonePayload);
			return(clone);
		}

		protected override void SetServices()
		{
			base.SetServices();
			Slot.AddService(XOService.Arbitration);
		}

		protected override string GetServiceName()
		{
			if (fFrontDoor)
				return @"/xarb/TimeExtend.ashx";
			return @"/xarbINH/TimeExtend.ashx";
		}

		public override byte[] GenerateHttpHeader(IPEndPoint endPoint, MemoryStream reqStream)
		{
			//Early out for front door communication
			if (fFrontDoor) return base.GenerateHttpHeader(endPoint,reqStream);

			//Get the base header and strip off the terminator
			System.Text.ASCIIEncoding AE=new System.Text.ASCIIEncoding();
			string sURL = AE.GetString(base.GenerateHttpHeader(endPoint,reqStream));
			StringBuilder sbURL = new StringBuilder(sURL);
			if (sbURL.Length>=2)
			{
				sbURL.Remove(sbURL.Length-2,2);  //strip last /r/n off
			}

			//Conversions
			ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
			byte [] addr = endPoint.Address.GetAddressBytes();
			uint ip=0;
			for(int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];

			//Attach HTTP AUTH DATA to headers
			HTTPAuthData authData = new HTTPAuthData((ushort) endPoint.Port,ip,requestId,0,this.titleId,(uint)XOService.Arbitration,0);
			authData.qwXboxID=this.machinePuid;
			sbURL.Append(HTTPAuthData.HTTP_HEADER_AUTH_DATA+":"+authData.GetBase64EncodedString()+"\r\n");

			//UDP?
			if (transport==FDTransaction.Transports.UDP)
			{
				sbURL.Append("AdaptedFromUDP: Yes\r\n");
			}

			sbURL.Append("\r\n");
			byte[] Header=AE.GetBytes(sbURL.ToString());
			return Header;
		}

		public override void PopulateSlot(ref CSGInfo slot)
		{
			//Early out for In-House communication
			if (!fFrontDoor) return;

			//base.PopulateSlot(ref slot);
			this.SetServices();
			// By default, let's say the user exists.  Tests can override this variable if necessary.
			Slot.UserExists = 1;
			slot.titleId = titleId;

			//Arbitration server pulls machine puid from auth request
			slot.machinePuid=machinePuid;

			this.ManualSlotSetup = true;
		}

		public override bool Execute()
		{
			//return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
			//ServerTestFramework.Utilities.TimeBomb bomb = new ServerTestFramework.Utilities.TimeBomb(1000);
			//bomb.Start();

			bool retval = Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xarb));
			//bomb.Stop();
			return retval;
		}

		public override bool Execute(IPEndPoint endPoint)
		{
			if (fFrontDoor==false)
			{
				xAct.transport=FDTransaction.Transports.TCP;
			}
			else
			{
				switch (transport)
				{
					case FDTransaction.Transports.TCP:
						xAct.transport=FDTransaction.Transports.TCP;
						break;
					case FDTransaction.Transports.UDP:
						xAct.transport=FDTransaction.Transports.UDP;
						xAct.ReceiveTimeOut=ReceiveTimeOut;
						xAct.IgnoreUDPReceive=IgnoreUDPReceive;
						break;
				}
			}
			return base.Execute(endPoint);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\AuthUtils.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Management;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace ServerTestFramework.LiveService.Auth
{

    /// <summary>
    /// Handy utilities for kerb &amp; sg related things.
    /// </summary>
    public class AuthUtils
    {
        protected static Random rand = new Random();

        /// <summary>
        /// Get a new 8-byte nonce. Supposed to be super-duper unique and random. In reality, it comes
        /// kinda close.  We use 4 random bytes and 4 byte from the timer.
        /// </summary>
        /// <returns></returns>
        static public byte[] GetNewNonce()
        {            
            byte[] nonce = new byte[8];
//            System.Threading.Thread.Sleep(5);
//            Random rnd = new Random();
//            rnd.NextBytes(nonce);
            lock (rand)
            {
                rand.NextBytes(nonce);
            }
            int ticks = Environment.TickCount;
            byte[] ticksArray = BitConverter.GetBytes(ticks);
            ticksArray.CopyTo(nonce, 0);
            return nonce;
        }

        static public uint GetNewSpi()
        {
//            Random rnd = new Random();
//            uint val = (uint)rnd.Next();
//            val &= XspHeader.XSP_SPI_MASK;
            uint val;
            lock (rand)
            {
                // Last byte is reserved for spiflags
                val = (uint)(rand.Next() & XspHeader.XSP_SPI_MASK);
            }
            return val;
        }

        static public IpMacPair GetMacAddress()
        {
            IpMacPair[] pairs = GetMacAddresses();
            return pairs[0];
        }

        /// <summary>
        /// Gets the IpMacPair whose IP matches the remote IP most closely.
        /// </summary>
        /// <param name="remote">The remote address to use as a reference point.</param>
        /// <returns>The IpMacPair closest to the remote address.</returns>
        static public IpMacPair GetMacAddress (IpAddr remote)
        {
            IpMacPair[] pairs = GetMacAddresses();

            IpMacPair ans = null;
            uint ans_val = 0;

            foreach (IpMacPair imp in pairs)
            {
                uint curr_val = ~(imp.ip.S_addr ^ remote.S_addr);
                curr_val = NetConstants.HTONUI(curr_val);

                if (curr_val > ans_val)
                {
                    ans_val = curr_val;
                    ans = imp;
                }
            }

            return ans;
        }

        static public IpMacPair[] GetMacAddresses()
        {
            ManagementObjectSearcher query = null; 
            ManagementObjectCollection queryCollection = null; 
            ArrayList pairs = new ArrayList(8);
            try 
            { 
                query = new ManagementObjectSearcher("SELECT MacAddress,IPAddress FROM Win32_NetworkAdapterConfiguration where IPEnabled=TRUE") ; 
                queryCollection = query.Get(); 
                foreach( ManagementObject mo in queryCollection ) 
                { 
                    if(mo["IPAddress"] != null) 
                    {
                        object[] o = (object[])mo["IPAddress"];
                        IpMacPair p = new IpMacPair(o[0].ToString(), mo["MacAddress"].ToString());
                        pairs.Add(p);
                    } 
                } 
            } 
            catch(Exception ex) 
            { 
                Console.WriteLine(ex.Source); 
                Console.WriteLine(ex.Message); 
            } 
            return (IpMacPair[])pairs.ToArray(typeof(IpMacPair));
        }


    }
   

    /// <summary>
    /// When we key exchange with the SG, it sends back an ICMP Port Unreachable packet just before the real
    /// response. This causes an exception. This class will swallow that exception and attempt to recvfrom()
    /// again, to get the real reply.
    /// </summary>
    public class SimpleUdpSG : IDisposable
    {
        public Socket udpSocket
        {
            get
            {
                if (sock==null)
                {
                    ReCreate();
                }

                return sock;
            }
        }
        
        private Socket sock;

        private byte[] recvBuffer;
        private int oSendBuffer;
        private int oRecvBuffer;

        // Incremented for every ConnectionReset event we get, which the SG is supposed to 
        // send for every key exchange. Allow this to be publicly read so we can verify the 
        // SG did this.
        public int connResetCounter = 0;

        // The remote connection after Recv()
        public EndPoint epRemote = new IPEndPoint(IPAddress.Any, 0);

        public IPEndPoint LocalIP
        {
            get 
            {
                return (IPEndPoint)udpSocket.LocalEndPoint;
            }
        }

        public SimpleUdpSG()
        {
        }

        public void Reset()
        {
            sock=null;
        }

        private void ReCreate()
        {
            sock = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

            // try to use 3074 first
            EndPoint epLocal = new IPEndPoint(IPAddress.Any, 3074);

            // check to see if we are actually on the machine running the SG
            // (should only happen when running STF tests on an xblob itself)
            IPEndPoint sgEp = Global.XEnv.GetVirtualInterface(Interface.sgsvc);
            if (IpHelper.GetBestInterface(sgEp.Address).Equals(sgEp.Address))
            {
                // don't try to take 3074 as that leads to problems
                // (we are bound to the same IP:Port that the SG is using)
                ((IPEndPoint)epLocal).Port = 0;
            }

            try
            {
                sock.Bind(epLocal);
            }
            catch (SocketException e)
            {
                if (e.SocketErrorCode == SocketError.AddressAlreadyInUse)
                {
                    // if that didn't work, we'll take any port
                    ((IPEndPoint)epLocal).Port = 0;
                    sock.Bind(epLocal);
                }
                else
                {
                    throw;
                }
            }

            //avoid known-bad ports.  If we hit one, hold the socket reference and try again so it will pick a different port.
            Socket localSock = sock;
            foreach (int blackPort in KdcClient.BlacklistedPorts)
            {
                if (((IPEndPoint)localSock.LocalEndPoint).Port == blackPort)
                {
                    ReCreate();
                    return;
                }
            }

            if (recvBuffer == null || recvBuffer.Length != 3000)
                recvBuffer = new byte[3000];

            // Socket options
            oSendBuffer = (int)sock.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer);
            oRecvBuffer = (int)sock.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer);
            oSendBuffer *= 2;
            oRecvBuffer *= 2;
            sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, oSendBuffer);
            sock.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, oRecvBuffer);
        }

        public void Send(byte[] pb, IPEndPoint host)
        {
            int sentBytes = udpSocket.SendTo(pb, host);
            if (sentBytes != pb.Length)
                throw new Exception("UDP send failed.");
        }

        public void SendFast(byte[] pb, int cb, IPEndPoint host)
        {
            int sentBytes = udpSocket.SendTo(pb, 0, cb, System.Net.Sockets.SocketFlags.None, host);
            if (sentBytes != cb)
                throw new Exception("UDP send failed.");
        }

        public void SendFast (byte[] pb, int offset, int cb, IPEndPoint host)
        {
            int sentBytes = udpSocket.SendTo(pb, offset, cb, System.Net.Sockets.SocketFlags.None, host);
            if (sentBytes != cb)
                throw new Exception("UDP send failed.");
        }


        public byte[] Recv(int timeoutInMs)
        {
            int packetSize = 0;
            RecvFast(timeoutInMs, out packetSize);
            if (packetSize > 0)
            {
                byte[] smallBuf = new byte[packetSize];
                Array.Copy(recvBuffer, 0, smallBuf, 0, packetSize);
                return smallBuf;
            }
            return null;
        }

        public byte[] RecvFast(int timeoutInMs, out int packetSize)
        {
            RecvFast(timeoutInMs, recvBuffer, out packetSize);
            if (packetSize > 0)
                return recvBuffer;
            else
                return null;
        }

        public void RecvFast(int timeoutInMs, byte[] buffer, out int packetSize)
        {
            DateTime begin = DateTime.Now;

            packetSize = 0;
            connResetCounter = 0;
TryAgain:
            if (udpSocket.Poll(timeoutInMs * 1000, SelectMode.SelectRead))
            {
                try 
                {
                    packetSize = udpSocket.ReceiveFrom(buffer, ref epRemote);
                }
                catch (System.Net.Sockets.SocketException e)
                {
                    // WSAECONNRESET
                    // This happens when we receive an ICMP Port Unreachable packet.
                    // The SG happens to send one out for every KeyExXbToSgInit message.
                    // It does this because of some Netgear router bug. WinSock is kinda
                    // stupid here -- this is a *connectionless* protocol after all so it should
                    // just swallow a connection reset message -- so let's try it again. 
                    // This should succeed and read the reply that actually was sent.
                    if (e.ErrorCode == 10054 && connResetCounter < 1)
                    {
                        connResetCounter++;
                        timeoutInMs -= (int) (DateTime.Now.Subtract(begin).TotalMilliseconds);
                        if (timeoutInMs > 0)
                        {
                            goto TryAgain;
                        }
                    }
                    else
                    {
                        throw e; 
                    }
                }
            }
        }

        public byte[] SendRecv(byte[] pb, string IP, ushort port, int timeOut) 
        {
            return SendRecv(pb, new IPEndPoint(IPAddress.Parse(IP), port), timeOut);
        }

        public byte[] SendRecv(byte[] pb, IPEndPoint host, int timeOut)
        {
            Send(pb, host);
            return Recv(timeOut);
        }

        /// <summary>
        /// The callback function for use with RecvAsync.
        /// </summary>
        /// <param name="state">The state object passed in to RecvAsync.</param>
        /// <param name="buffer">The buffer passed in to RecvAsync.</param>
        /// <param name="length">The amount of data that was read into the buffer.</param>
        /// <param name="endpoint">The location that the packet came from.</param>
        /// <param name="connection_reset">True if the connection was reset, false if not.</param>
        /// <param name="exc">The exception, if any, that was thrown by EndReceiveFrom.</param>
        public delegate void RecvAsyncCallback (object state, byte[] buffer, int length, IPEndPoint endpoint, 
            bool connection_reset, Exception exc);

        protected class RecvAsyncState
        {
            public Socket Socket = null;
            public byte[] Buffer = null;
            public RecvAsyncCallback Callback = null;
            public object State = null;
            public EndPoint Location = new IPEndPoint(IPAddress.Any, 0);
            public bool ConnReset = false;
        }

        /// <summary>
        /// Asynchronously receives data from the socket.
        /// </summary>
        /// <param name="buffer">The buffer to fill with data. It is suggested to be 1500 bytes.</param>
        /// <param name="callback">The callback function.</param>
        /// <param name="state">The state object for use by the callback function.</param>
        public void RecvAsync (byte[] buffer, RecvAsyncCallback callback, object state)
        {
            RecvAsyncState state_obj = new RecvAsyncState();
            state_obj.Socket = udpSocket;
            state_obj.Buffer = buffer;
            state_obj.Callback = callback;
            state_obj.State = state;

            state_obj.Socket.BeginReceiveFrom(buffer, 0, buffer.Length, SocketFlags.None, ref state_obj.Location,
                RecvAsyncEnd, state_obj);
        }

        protected void RecvAsyncEnd (IAsyncResult result)
        {
            RecvAsyncState state = (RecvAsyncState) result.AsyncState;

            int read = 0;
            Exception exc = null;

            try
            {
                read = state.Socket.EndReceiveFrom(result, ref state.Location);
            }
            catch (SocketException e)
            {
                // WSAECONNRESET
                if (e.ErrorCode == 10054 && !state.ConnReset)
                {
                    state.ConnReset = true;
                    state.Socket.BeginReceiveFrom(state.Buffer, 0, state.Buffer.Length, SocketFlags.None,
                        ref state.Location, RecvAsyncEnd, state);
                    return;
                }
                else
                {
                    exc = e;
                }
            }
            catch (Exception e)
            {
                exc = e;
            }

            state.Callback(state.State, state.Buffer, read, (IPEndPoint) state.Location, state.ConnReset, exc);
        }

        #region IDisposable Members

        public void Dispose()
        {
            if (sock != null)
            {
                sock.Close();
                sock = null;
            }
        }

        #endregion
    }

    public class DeterministicRandom 
    {
        private Random      rand        = null;
        private int         seed        = 0;
        private long        iter        = 0;
        private long        iterStart   = 0;

        public DeterministicRandom()
        {
            SeedRandom();
        }

        public DeterministicRandom(int initialSeed)
        {
            Seed(initialSeed);
        }

        public void Reset()
        {
            rand = new Random(seed);
            iter = 0;
            iterStart = 0;
        }

        public void Seed(int s)
        {
            if (s == seed)
                return;
            seed = s;
            Reset();
        }

        public int SeedRandom()
        {
            seed = (int)DateTime.Now.Ticks;
            Reset();
            return seed;
        }

        public void JumpToIteration(long iteration)
        {
            if (iteration == iter || iteration < 0)
                return;
            else if (iteration < iter)
                Reset();
            for (iter = 0; iter < iteration; iter++)
            {
                rand.Next();
            }
            iterStart = iteration;
        }

        public int Next(int minValue, int maxValue)
        {
            iter++;
            return rand.Next(minValue, maxValue);
        }

        public int Next(int maxValue)
        {
            iter++;
            return rand.Next(maxValue);
        }

        public int Next()
        {
            iter++;
            return rand.Next();
        }

        public byte NextByte()
        {
            iter++;
            return (byte)(rand.Next() % 256);
        }

        public override string ToString()
        {
            return String.Format("DeterministicRandom seed={0}, start={1}, iter={2} (delta={3})", seed, iterStart, iter, iter - iterStart);   
        }

        // Packet fuzzing helper functions

        /// <summary>
        /// Changes random bytes in an array to random values
        /// </summary>
        /// <param name="packet"></param>
        /// <param name="packetLength"></param>
        /// <param name="iterations">The number of random bytes to change</param>
        public void MutateBytes(byte[] packet, int packetLength, int iterations)
        {
            for (int i = 0; i < iterations; i++)
            {
                int idx = Next(packetLength);
                byte val = NextByte();
                packet[idx] = val;
            }
        }




    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\AskdcClient.cs ===
using System;
using System.Net;
using System.Diagnostics;
using System.Text;
using System.Runtime.InteropServices;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Auth
{
    public class AskdcClient : AuthClientBase
    {
        /// <summary>
        /// ASKDC constructor.  Signs on users and machine to get a combinedTgt.
        /// </summary>
        /// <param name="ctx">AuthContext state</param>
        /// <param name="ip">IP address of the ASKDC server. May be null.</param>
        /// <param name="manualSetup">If false, use default values. If true, user will set all values.</param>
        public AskdcClient(AuthContext ctx, IPEndPoint ip, bool manualSetup)
            : base(ctx, ip, manualSetup)
        {
            Initialize(ctx);
        }

        public AskdcClient(AuthContext ctx)
            : base(ctx, null, false)
        {
            Initialize(ctx);
        }

        private static object lockBuild = new object();
        private static object lockProcess = new object();

        //enables overly verbose output result
        public static bool EnableOverlyVerboseOutput = false;

        //We used to only make a single request and fail if that times out (after 5s by default).  Set this to true to go back to that old behaviour.
        //If this is true, then we will use timeout values (replacing TimeoutInMs) and retry timedout requests similar to how a real client would do it.
        public bool EmulateClientBehavior = true;
        private int signinTryNumber=0;

        //By default, if we get KDC_ERR_PREAUTH_REQUIRED, we will automatically remake the request echoing back the echo preauth data
        public bool AutomaticallyRespondToEcho = true;

        //callback triggered before each step of signin.  message will not be sent if it returns false;
        public delegate bool SigninProgressCallbackDelegate(AuthContext ctx, XonlinepUser user, bool isMachine, bool isEchoRetry, ref byte []echoBytesToSend);
        public SigninProgressCallbackDelegate SigninProgressCallback;

        /// <summary>
        /// Common constructor code to initialize various members and member of AuthContext
        /// </summary>
        protected override void Initialize(AuthContext ctx)
        {
            // Default IP
            if (ipServer == null)
            {
                try
                {
                    ipServer = Global.XEnv.GetVirtualInterface(VirtualInterface.kdcsvc);
                }
                catch
                {
                    Global.RO.Error("GetVirtualInterface failed for kdcsvc.  If you have no Npdb, you must specify this in an override.");
                    throw;
                }
            }

            // Users
            if (ctx.Users == null)
            {
                ctx.Users = new XonlinepUser[4];
                for (int i = 0; i < ctx.Users.Length; i++)
                {
                    ctx.Users[i] = null;
                }
            }

        }


        /// <summary>
        /// Reset everything to valid default values. You should be able to sign in with 
        /// just these values.  Think of this as the most basic, simple, valid request possible.
        /// </summary>
        public static void SetDefaults(AuthContext ctx)
        {
            // All we really need is a valid machine account.  We could also have a user or 4, but
            // it's not necessary.

            // I think we need to update the realm, etc of the machine account
            if (ctx.UsersMachine != null)
            {
                StringToBytes(ctx.UsersMachine.Domain, ctx.k_XboxKerberosRealm);
                StringToBytes(ctx.UsersMachine.KerberosRealm, ctx.k_PassportKerberosRealm);
            }

        }


        private TgtContext prevTgt;
        private TgtContext curTgt;
        private byte[] bytesTitleInfo;

        /// <summary>
        ///  Sign in to the ASKDC server. 
        /// </summary>
        public void SignInAskdc()
        {
            PrepareForSignIn();
            authContext.CombinedTgt=null;

            bool machineFirst=true; //We are now doing the machine first by default, but original askdc non-encrypted passport user requests require machine to be last

            if (authContext.IsPanorama && !authContext.IncludeEncryptedPassportByDefault)
            {
                machineFirst=false;
            }

            try
            {
                if (machineFirst)
                {
                    if (authContext.UsersMachine != null)
                    {
                        SignInUser(authContext.UsersMachine, true);
                        prevTgt=curTgt;
                    }
                }

                // Loop through and sign in each user. Don't forget there can be holes in the array of users.
                for (int i=0; i<4; ++i)
                {
                    if (i==0 && authContext.AskdcFirstUserHasTgt) //for neg preauth case: set the tgt on first user (doesn't have to be valid)
                    {
                        Global.RO.Debug("AskdcFirstUserHasFakeTGT fake token used: "+prevTgt.tgtToken);
                    }

                    if (authContext.Users[i]==null)
                        continue;
                    SignInUser(authContext.Users[i], false);
                    prevTgt=curTgt;
                }

                if (!machineFirst)
                {
                    if (authContext.UsersMachine!=null)
                    {
                        SignInUser(authContext.UsersMachine, true);
                        prevTgt=curTgt;
                    }
                }

                // Done!
                authContext.CombinedTgt=curTgt;
                if (authContext.CombinedTgt==null)
                {
                    throw new LogonException("Invalid response received from ASKDC");
                }

                if (!InitializePUIDS())
                {
                    throw new LogonException("Failed to copy puids out of encrypted askdc ticket.");
                }

                isSignedIn=true;
            }
            finally
            {
                if (prevTgt!=null)
                {
                    prevTgt=null; //just remove reference, don't Dispose since authContext.CombinedTgt points to the same thing
                }
            }
        }


        // Now we need to copy the puids, which are embedded in the encrypted and packet ticket within
        // the TGT context, out to the PUID fields in the TGT context.  This handy function will also
        // return the puids to us.  Handy indeed.
        // Let's put them in the XonlinepUser structures.  This may be atypical, so keep your eyes open.
        //
        // Hmm.  I don't think we're getting any user puids.  What's in the ticket may just be what is
        // in the request, which would be our ingoing TGT.  It has puids of 0, except for the machine
        // one, which XMACS gives to us.  Everything (TGS) seems to work with only machine puid,
        // so maybe this doesn't matter. The actual user puids can be retrieved from within the AuthData
        // structure in the TGS ticket.
        public bool InitializePUIDS ()
        {
            try
            {
                ulong[] puidUsers = new ulong[4];
                DLL_CopyPuidsOutToTgtContext(
                    ServiceKeys.GetServiceKey(ServiceKeys.Key_KdcXboxCom),
                    authContext.CombinedTgt.tgtToken,
                    out authContext.UsersMachine.xuid.qwUserID,
                    puidUsers);
                for(int i = 0; i < puidUsers.Length; i++)
                {
                    if(authContext.Users != null && authContext.Users[i] != null)
                    {
                        authContext.Users[i].xuid.qwUserID = puidUsers[i];
                    }
                }
            }
            catch(COMException e)
            {
                Global.RO.Debug("Failed CopyPuidsOutToTgtContext. I think decryption failed. ErrorCode=0x{0:X}", e.ErrorCode);
                return false;
            }
            finally
            {
                SpewKerbclientDebug();
            }

            return true;
        }

        //
        public void PrepareForSignIn ()
        {
            isSignedIn = false;
            signinTryNumber = 0;
            echoBytes=null; //forget old echo

            // First make sure we have a valid machine account. 
            if(!authContext.IsSignedInXmacs)
            {
                XmacsClient xmacs = new XmacsClient(authContext);
                xmacs.EmulateClientBehavior=EmulateClientBehavior;
                xmacs.SignInXmacs();
            }

            // Then set up defaults if necessary
            if(!isManualSetup)
            {
                SetDefaults(authContext);
            }

            // Store bytes 
            bytesTitleInfo = (byte[])authContext.TitleInfo;

            // Get a Passport ticket for Panorama sign-ins automatically, but only if we 
            // need to and only if the user is not using manual setup. Presumably, only 
            // the KDC tests will use manual setup.
            if(authContext.IsPanorama && authContext.NumUsers> 0 && authContext.PassportTicket == null)
            {
                if(!isManualSetup)
                {
                    if (authContext.IncludeEncryptedPassportByDefault)
                    {
                        authContext.PassportAuthenticate("MBI", AuthClientBase.PassportSite.KdcPanorama);
                    }
                    else
                    {
                        authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                    }
                }
                else
                {
                    Global.RO.Warn("Your PassportTicket in authContext is null, maybe you want to call PassportAuthenticate()?");
                }
            }

            if (prevTgt!=null)
                prevTgt.Dispose();
            prevTgt = null;

            if (curTgt!=null)
                curTgt.Dispose();
            curTgt = null;
        }


        private XonlinepUser user;

        public void BuildUserRequest(XonlinepUser user,
                                      bool fIsMachine,
                                      byte []echoBytesToSend)
        {
            try
            {
                curTgt=new TgtContext();
                this.user=user;
                authContext.KerbAsRequestInfo.UsePcNonceKey=0;

                uint []preauthList=authContext.PreAuthListAskdc;

                //Decide which preauths to include if the using the default
                if (!fIsMachine && authContext.IncludeEncryptedPassportByDefault) //user request using encrypted passport
                {
                    if (preauthList==null)
                    {
                        preauthList=new uint[] {
                            PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY,
                            PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                            PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                            PreAuthType.KRB5_PADATA_XBOX_ECHO,
                            PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION };
                    }
                }
                else if(authContext.IsPanorama && !fIsMachine) //pc user old request
                {
                    authContext.KerbAsRequestInfo.UsePcNonceKey=1;

                    if (authContext.KerbAsRequestInfo.AutoRandomizePcNonce)
                    {
                        authContext.KerbAsRequestInfo.PcNonce=rand.NextUlong();
                    }

                    if (preauthList==null)
                    {
                        preauthList=new uint[] {
                            PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY,
                            PreAuthType.KRB5_PADATA_PAC_REQUEST_EX, //the old client that uses this preauth includes this so include it by default in these cases
                            PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                            PreAuthType.KRB5_PADATA_XBOX_ECHO,
                            PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION };
                    }
                }
                else //machine or non-passport user
                {
                    if (preauthList==null)
                    {
                        //see if we have a xenon certificate hash available
                        bool certHashAvailable=(authContext.ConsoleCert!=null);

                        // Set up a default preauth list if none was provided
                        if (certHashAvailable && fIsMachine && user.Gamertag.Length>=3 && user.Gamertag[0]==(byte)'X' && user.Gamertag[1]==(byte)'E' && user.Gamertag[2]==(byte)'.') //xenon machine
                        {
                            if (authContext.KerbAsRequestInfo.AutoComputeCertificateHash)
                            {
                                authContext.KerbAsRequestInfo.CertificateHash=authContext.ConsoleCert.ComputeHash();
                            }

                            preauthList=new uint[] {
                                PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY,
                                PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                                PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                                PreAuthType.KRB5_PADATA_XBOX_ECHO,
                                PreAuthType.KRB5_PADATA_XENON_PPA };
                        }
                        else //xbox machine or xbox/xenon user or old xenon machine that doesn't use the xenon ppa preauth
                        {
                            preauthList=new uint[] {
                                PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY,
                                PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                                PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                                PreAuthType.KRB5_PADATA_XBOX_ECHO };
                        }
                    }
                }

                // Copy passport ticket into AS request info if needed
                foreach (uint pa in preauthList)
                {
                    if (pa==PreAuthType.KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION || pa==PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION)
                    {
                        if (authContext.PassportTicket!=null)
                        {
                            authContext.KerbAsRequestInfo.PassportTicket=authContext.PassportTicket;
                            authContext.KerbAsRequestInfo.PassportTicketLength=(uint)authContext.PassportTicket.Length;
                        }
                        else
                        {
                            throw new System.Exception("AskdcClient BuildUserRequest: PassportTicket is required for this request.");
                        }
                    }

                    if (pa==PreAuthType.KRB5_PADATA_PASSPORT_AUTHENTICATION)
                    {
                        if (authContext.PassportSessionKey!=null)
                        {
                            authContext.KerbAsRequestInfo.PassportSessionKey=authContext.PassportSessionKey;
                            authContext.KerbAsRequestInfo.PassportSessionKeyLength=(uint)authContext.PassportSessionKey.Length;
                        }
                        else
                        {
                            throw new System.Exception("AskdcClient BuildUserRequest: PassportSessionKey is required for this request.");
                        }
                    }
                }

                // Store bytes
                byte[] bytesUser=(byte[])user;
                byte[] bytesAsInfo=(byte[])authContext.KerbAsRequestInfo;

                // Build the request
                packetLength=packet.Length;
                lock(lockBuild)
                {
                    DLL_BuildAs(
                        bytesTitleInfo,
                        bytesAsInfo,
                        (uint)bytesAsInfo.Length,
                        1, //TODO: Investigate what's going on here.  After the change to send machine accounts first in the chain, the old logic caused the wrong sname to be sent to askdc.  Old logic: fIsMachine ? (uint)1 : (uint)0,
                        bytesUser,
                        preauthList,
                        (uint)preauthList.Length,
                        (echoBytesToSend==null?null:echoBytesToSend),
                        (echoBytesToSend==null?0:(uint)echoBytesToSend.Length),
                        authContext.AskdcFirstUserHasTgt,
                        packet,
                        ref packetLength,
                        curTgt.tgtToken,
                        (prevTgt==null) ? IntPtr.Zero : prevTgt.tgtToken
                        );
                }
            }
            catch(Exception)
            {
                if(curTgt!=null)
                    curTgt.Dispose();
                curTgt=null;
                if(prevTgt!=null)
                    prevTgt.Dispose();
                prevTgt=null;
                throw;
            }
            finally
            {
                SpewKerbclientDebug();
            }
        }

        protected void VerifyResponse()
        {
            if(packetLength < 10)
            {
                Global.RO.Warn("SignInUser: returned packet is {0} bytes long, this is too short", packetLength);
                return;
            }

            // Process it
            try
            {
                lock(lockProcess)
                {
                    DLL_VerifyAs(
                        packetRecv,
                        packetRecvLength,
                        curTgt.tgtToken
                        );
                }
            }
            catch(COMException e)
            {
                if(KerbErr.IsKerbErr(e.ErrorCode))
                {
                    KerbErrException ke = new KerbErrException(e.ErrorCode, e);
                    ke.ExtraMessage = "User " + AuthClientBase.BytesToString(user.Gamertag)+", Attempt "+(1+signinTryNumber);
                    throw ke;
                }
                if((uint)e.ErrorCode == 0xD000006D || (uint)e.ErrorCode == 0xC000006D)
                    throw new LogonException("Askdc returned 0x{0:X}, UDP port is {1}, user is {2}"+", Attempt "+(1+signinTryNumber),
                        e.ErrorCode,
                        ((IPEndPoint)Context.Udp.udpSocket.LocalEndPoint).Port,
                        AuthClientBase.BytesToString(user.Gamertag));

                throw;
            }
            finally
            {
                SpewKerbclientDebug();
            }

            if (EnableOverlyVerboseOutput)
            {
                //use the managed kerberos classes to parse this and spit it out
                try
                {
                    long bytesUsed;
                    ServerTestFramework.LiveService.Auth.Asn.AsnValueBase asn=ServerTestFramework.LiveService.Auth.Asn.Compound.AsnValueParser.Parse(packetRecv, 0, packetRecvLength, out bytesUsed);
                    AskdcGenericReply reply=AskdcGenericReply.CreateFromAsnForClientType(asn, authContext.ClientType);
                    reply.Decrypt(null, ServiceKeys.GetServiceKey(ServiceKeys.Key_KdcXboxCom));

                    Global.RO.Debug("Got askdc response:");
                    Global.RO.Debug(reply.ToString());
                }
                catch (System.Exception e)
                {
                    Global.RO.Debug("Exception parsing native askdc client response using managed client ("+e.Message+").");
                }
            }
        }

        private byte []echoBytes=null;

        //PrepareForSignin should have been called at some point before this
        protected void SignInUser(XonlinepUser user, bool fIsMachine)
        {
            if (EnableOverlyVerboseOutput)
            {
                Global.RO.Debug("Making askdc request for principal: "+user.GetGamertag());
            }

            try
            {
                int maxTries=EmulateClientBehavior?MAX_KERB_RETRIES:1;
                for (; signinTryNumber<maxTries; ++signinTryNumber)
                {
                    if (EmulateClientBehavior)
                    {
                        TimeoutInMs=c_dwDefaultKerbRetryDelayInMilliSeconds[signinTryNumber];
                    }

                    System.DateTime requestStartTime=System.DateTime.Now;
                    try
                    {
                        //try normal request
                        if (SigninProgressCallback!=null)
                        {
                            if (!SigninProgressCallback(authContext, user, fIsMachine, false, ref echoBytes))
                            {
                                return;
                            }
                        }

                        BuildUserRequest(user, fIsMachine, echoBytes);
                        SendRecv("Askdc");

                        //verify
                        try
                        {
                            VerifyResponse();
                        }
                        catch (KerbErrException kee)
                        {
                            if (EnableOverlyVerboseOutput)
                            {
                                Global.RO.Debug("Got KerbError: "+kee.Message);
                            }

                            //preauth with echo retry may be needed
                            if (AutomaticallyRespondToEcho && kee.KerbErr==KerbErrCode.KDC_ERR_PREAUTH_REQUIRED && curTgt!=null)
                            {
                                uint echoByteCount=kcl_GetTGTEchoBytes(curTgt.tgtToken, echoBytes, 0);
                                echoBytes=new byte[echoByteCount];
                                kcl_GetTGTEchoBytes(curTgt.tgtToken, echoBytes, echoByteCount);

                                //try again using echo data this time
                                if (SigninProgressCallback!=null)
                                {
                                    if (!SigninProgressCallback(authContext, user, fIsMachine, true, ref echoBytes))
                                    {
                                        return;
                                    }
                                }
                                else if (echoByteCount==0) //not meant for us to handle if no echo data
                                {
                                    throw;
                                }

                                BuildUserRequest(user, fIsMachine, echoBytes);
                                SendRecv("Askdc");

                                VerifyResponse();
                            }
                            else
                            {
                                throw;
                            }
                        }

                        break;
                    }
                    catch (ServerTestFramework.Utilities.TimeoutException)
                    {
                        Global.RO.Warn("Askdc TimeoutException on attempt "+(signinTryNumber+1)+" of "+maxTries+" after "+(System.DateTime.Now-requestStartTime).TotalMilliseconds+"ms for "+(fIsMachine?"machine ":"user ")+user.GetGamertag());
                        if (signinTryNumber==maxTries-1) throw;
                    }
                }
            }
            catch
            {
                if (curTgt!=null)
                    curTgt.Dispose();
                curTgt=null;

                if(prevTgt != null)
                    prevTgt.Dispose();
                prevTgt=null;

                throw;
            }
        }

        /// <summary>
        /// Adds time to the ticket expiration time. Currently in Testnet, tickets
        /// expire after 30 minutes (I believe), which makes stress testing difficult.
        /// Use this to artificially add more time to the ticket.
        /// </summary>
        public bool AddToTicketTimeRemaining(int nSecsToAdd)
        {
            try
            {
                if (authContext.CombinedTgt==null)
                {
                    Global.RO.Error("AddToTicketTimeRemaining failed: no tgt context in auth data to work with.");
                    return false;
                }
                else
                {
                    DLL_AddToTicketTimeRemaining(
                        ServiceKeys.GetServiceKey(ServiceKeys.Key_KdcXboxCom),
                        authContext.CombinedTgt.tgtToken,
                        nSecsToAdd);
                    return true;
                }
            }
            finally
            {
                SpewKerbclientDebug();
            }
        }

        /// <summary>
        /// Decrypts the bytes that the askdc returned in an echo preauth.
        /// </summary>
        public static byte[] DecryptEchoBytes(byte []echoBytesFromServer)
        {
            byte []data=new byte[echoBytesFromServer.Length];
            Array.Copy(echoBytesFromServer, data, echoBytesFromServer.Length);

            byte []echoKey=ServiceKeys.GetServiceKey(ServiceKeys.Key_AskdcEcho);

            try
            {
                XcCrypt2(XC_SERVICE_AES256_CIPHER, XC_SERVICE_DECRYPT,
                    echoKey, (uint)echoKey.Length,
                    new byte[16], 16,
                    data, (uint)data.Length,
                    new byte[0], 0);
            }
            finally
            {
                SpewKerbclientDebug();
            }

            return data;
        }

        /// <summary>
        /// Encrypts bytes to store in the askdc echo preauth.
        /// </summary>
        public static byte[] EncryptEchoBytes(byte []echoBytesToEncrypt)
        {
            byte []data=new byte[echoBytesToEncrypt.Length];
            Array.Copy(echoBytesToEncrypt, data, echoBytesToEncrypt.Length);

            byte []echoKey=ServiceKeys.GetServiceKey(ServiceKeys.Key_AskdcEcho);

            try
            {
                XcCrypt2(XC_SERVICE_AES256_CIPHER, XC_SERVICE_ENCRYPT,
                    echoKey, (uint)echoKey.Length,
                    new byte[16], 16,
                    data, (uint)data.Length,
                    new byte[0], 0);
            }
            finally
            {
                SpewKerbclientDebug();
            }

            return data;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\ChallengeManager.cs ===
using System;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary>
    /// Aids in managing challenge/response and filter files on the SG server -- 
    /// configuring, enumerating, enabling, etc.
    /// </summary>
    public class ChallengeManager
    {
        #region Statics

        /// <summary>Report object for use by ChallengeManager.</summary>
        private static Report ro = new Report("ChallengeManager");

        #region Preconfigured Scripts

        /// <summary>Container for preconfigured scripts.</summary>
        private static Dictionary<string, LuaScript> _PreconfiguredLuaScripts = null;

        /// <summary>Preconfigured Lua scripts.</summary>
        public static Dictionary<string, LuaScript> PreconfiguredLuaScripts
        {
            get
            {
                if (_PreconfiguredLuaScripts == null)
                {
                    LoadPreconfiguredLuaScripts(Global.Config);
                }
                return _PreconfiguredLuaScripts;
            }
        }

        /// <summary>
        /// Loads Lua scripts from an Xml document.
        /// </summary>
        /// <param name="config">The Xml document to load scripts from.</param>
        public static void LoadPreconfiguredLuaScripts (XmlDocument config)
        {
            // Only select these nodes:
            // <sgscripts><sgscript type="lua">
            XmlNodeList scriptNodes = config.SelectNodes("//sgscripts/sgscript[@type='lua']");
            if (scriptNodes == null)
                return;

            Dictionary<string, LuaScript> scripts = new Dictionary<string, LuaScript>(scriptNodes.Count);

            foreach (XmlNode scriptNode in scriptNodes)
            {
                string name = null;
                string script = null;
                byte[] blob = null;

                // Atrributes first
                name = scriptNode.Attributes["name"].Value;
                if (name == null || name == "")
                {
                    ro.Warn("The 'name' attribute in {0} cannot be null", scriptNode.ToString());
                    continue;
                }

                XmlAttribute filename_attr = scriptNode.Attributes["external"];
                if (filename_attr != null)
                {
                    string filename = filename_attr.Value;

                    if (filename == null || filename == string.Empty)
                    {
                        ro.Warn("The 'external' attribute cannot be empty:\n" + scriptNode.ToString());
                        continue;
                    }
                    else
                    {
                        // find the file, look in these places
                        string[] paths = new string[] { "{0}", "{0}.lua", "suites\\{0}", "suites\\{0}.lua" };

                        foreach (string format in paths)
                        {
                            string temp = string.Format(format, filename);
                            if (File.Exists(temp))
                            {
                                filename = temp;
                                break;
                            }
                        }

                        if (!File.Exists(filename))
                        {
                            ro.Warn("Could not find external file referenced:\n" + scriptNode.ToString());
                            continue;
                        }

                        // load the file and its .bin (if it exists)
                        script = File.ReadAllText(filename);

                        filename += ".bin";

                        if (File.Exists(filename))
                        {
                            blob = File.ReadAllBytes(filename);
                        }
                    }
                }

                // Loop through children
                foreach (XmlNode childNode in scriptNode.ChildNodes)
                {
                    if (childNode.Name.ToLower() == "script")
                    {
                        script = childNode.InnerText;
                    }
                    else if (childNode.Name.ToLower() == "blob")
                    {
                        string temp_blob = childNode.InnerText;
                        // Trim whitespace
                        temp_blob = temp_blob.Replace(" ", "");
                        temp_blob = temp_blob.Replace("\n", "");
                        temp_blob = temp_blob.Replace("\r", "");

                        blob = Hexer.unhex(temp_blob);
                    }
                    else
                    {
                        ro.Warn("Unknown node {0} found in {1} node", childNode.ToString(), scriptNode.ToString());
                    }
                }

                // Insert into dictionary
                scripts[name] = new LuaScript() { Name = name, Script = script, Blob = blob };
                ro.Debug("Added \"{0}\" to pre-configured LUA scripts", name);

            }

            _PreconfiguredLuaScripts = scripts;
        }

        #endregion

        #endregion

        #region Script Management

        /// <summary>Our scripts.</summary>
        private Dictionary<LuaScript, LuaScriptAuthdata> _Scripts = new Dictionary<LuaScript, LuaScriptAuthdata>();

        /// <summary>
        /// Adds a script to our collection and the database.
        /// </summary>
        /// <param name="luaScript">The script to add.</param>
        public void AddScript (LuaScript luaScript)
        {
            AddScript(luaScript, true);
        }

        /// <summary>
        /// Adds a script to our collection and the database.
        /// </summary>
        /// <param name="luaScript">The script to add.</param>
        /// <param name="reload">If true, reloads the SG(s).</param>
        public void AddScript (LuaScript luaScript, bool reload)
        {
            // check for already here
            lock (_Scripts)
            {
                if (_Scripts.ContainsKey(luaScript))
                {
                    return;
                }
            }

            LuaScriptAuthdata lsa = new LuaScriptAuthdata(AuthdataTarget, luaScript);

            lock (_Scripts)
            {
                _Scripts.Add(luaScript, lsa);
            }

            lsa.ModifiedScript.PropScript(reload);
        }

        /// <summary>
        /// Removes a script from our collection and the database.
        /// </summary>
        /// <param name="luaScript">The script to remove.</param>
        public void RemoveScript (LuaScript luaScript)
        {
            RemoveScript(luaScript, true);
        }

        /// <summary>
        /// Removes a script from our collection and the database.
        /// </summary>
        /// <param name="luaScript">The script to remove.</param>
        /// <param name="reload">If true, reloads the SG(s).</param>
        public void RemoveScript (LuaScript luaScript, bool reload)
        {
            LuaScriptAuthdata lsa = null;

            lock (_Scripts)
            {
                if (!_Scripts.TryGetValue(luaScript, out lsa))
                {
                    return;
                }
            }

            lsa.ModifiedScript.RemoveScript(reload);

            lock (_Scripts)
            {
                _Scripts.Remove(luaScript);
            }
        }

        /// <summary>
        /// Removes a script from our collection and the database.
        /// </summary>
        /// <param name="scriptName">The script to remove.</param>
        public void RemoveScript (string scriptName)
        {
            RemoveScript(scriptName, true);
        }

        /// <summary>
        /// Removes a script from our collection and the database.
        /// </summary>
        /// <param name="scriptName">The script to remove.</param>
        /// <param name="reload">If true, reloads the SG(s).</param>
        public void RemoveScript (string scriptName, bool reload)
        {
            RemoveScript(_Scripts.First(s => s.Key.Name == scriptName).Key, reload);
        }

        /// <summary>
        /// Removes all scripts from our collection and the database.
        /// </summary>
        public void RemoveAllScripts ()
        {
            RemoveAllScripts(true);
        }

        /// <summary>
        /// Removes all scripts from our collection and the database.
        /// </summary>
        /// <param name="reload">If true, reloads the SG(s).</param>
        public void RemoveAllScripts (bool reload)
        {
            lock (_Scripts)
            {
                foreach (var kvp in _Scripts)
                {
                    kvp.Value.ModifiedScript.RemoveScript(false);
                }
                _Scripts.Clear();
            }

            if (reload)
            {
                SgServerInfo.ReloadChallenges();
            }
        }

        #endregion

        #region Authdata Targeting

        /// <summary>
        /// Types of authdata targeting.
        /// </summary>
        public enum AuthdataTargetType
        {
            Version,
            Title,
        }

        /// <summary>The type of targeting this manager uses.</summary>
        public AuthdataTargetType AuthdataTarget { get; set; }

        /// <summary>
        /// The authdata associated with a Lua script.
        /// </summary>
        private class LuaScriptAuthdata
        {
            /// <summary>Static for value used to uniquely identify the script.</summary>
            private static int AuthdataIdentiferIndex = 0;

            /// <summary>This value will be replaced in scripts with the challenge id.</summary>
            private const string ChallengeDeclareMacro = "--{ChallengeManager.ChallengeDeclare}";

            /// <summary>This value will be replaced in scripts with the default binary blob.</summary>
            private const string DefaultBinaryMacro = "--{ChallengeManager.DefaultBinary}";

            /// <summary>This value will be replaced in scripts with the target filter.</summary>
            private const string AuthdataTargetMacro = "--{ChallengeManager.AuthdataTarget}";

            #region Lua Code for Macro Replacements

            private const string ChallengeDeclareReplace = @"
ChallengeDeclare({0}, '{1}', {2}, {3}, {4})
";
            private const string DefaultBinaryReplace = @"
__Binary = Buffer.new('109B4C547A611BD257BAe9C7D94D2DF1803AEE2CABBB1B8D9277F54389FD8FA927Dc227E1585A2D4DF506C0911DEAFC2C705BFACD88F032CBBBD9CE1A905C319BBAC270AF2877F42A7B66B152EA9B4C195837B5D0F2AC53F28F2B7E6237A252A9516FD5591F0042C5C22221311301D4E742288981AC737CA2F91E2676E116A08C5D76BA7C17421512D7D8F88B8DFAE4889273B87A46F5818D710C4996D7BB381C14F44CA9A0EF13B4027B6AA6844FA02579C715005C1F78C747D04FDCF6A097D10B9AC3801C11A6E72795E967CA4E0ED6C0DAFAC196CEB4F50F1FDB246303A61C94CAECF87F8B83DB008785D62A3FE9600010110000100030000200000800070')
";

            private const string AuthdataTargetForVersion = @"
if Spi.GetClientMajor() ~= 0x5347 or Spi.GetClientMinor() ~= 0x434D or Spi.GetClientBuild() ~= {0} or Spi.GetClientQfe() ~= {1} then
   return
end";

            private const string AuthdataTargetForTitle = @"
if Spi.GetTitleId() ~= 0x5347434D or Spi.GetTitleVersion() ~= 0x{0:X4}{1:X4} then
   return
end";

            #endregion

            public LuaScriptAuthdata (AuthdataTargetType targetType, LuaScript baseScript)
            {
                TargetType = targetType;
                AuthdataIdentifier = System.Threading.Interlocked.Increment(ref AuthdataIdentiferIndex);

                if (baseScript.Script.Contains(ChallengeDeclareMacro) ||
                    baseScript.Script.Contains(DefaultBinaryMacro) || 
                    baseScript.Script.Contains(AuthdataTargetMacro))
                {
                    ModifiedScript = new LuaScript(baseScript);

                    // modify name
                    ModifiedScript.Name += AuthdataIdentifier.ToString();

                    // modify script for challenge declaration
                    ModifiedScript.Script = ModifiedScript.Script.Replace(ChallengeDeclareMacro, 
                        "--{ChallengeManager.ChallengeDeclare Expanded}" +
                        string.Format(ChallengeDeclareReplace, 
                        0x53470000 | (AuthdataIdentifier & 0xFFFF), ModifiedScript.Name.Replace('\'', '_'),
                        ModifiedScript.IsSync.ToString().ToLower(), ModifiedScript.IsPc.ToString().ToLower(),
                        ModifiedScript.IsDevkit.ToString().ToLower()));

                    // modify script for default binary blob
                    ModifiedScript.Script = ModifiedScript.Script.Replace(DefaultBinaryMacro,
                        "--{ChallengeManager.DefaultBinary Expanded}" + DefaultBinaryReplace);
                    
                    // modify script for targetting
                    string format = null;

                    switch (targetType)
                    {
                        case AuthdataTargetType.Version:
                            format = AuthdataTargetForVersion;
                            break;

                        case AuthdataTargetType.Title:
                            format = null;
                            break;
                    }

                    ModifiedScript.Script = ModifiedScript.Script.Replace(AuthdataTargetMacro, 
                        "--{ChallengeManager.AuthdataTarget Expanded}" +
                        string.Format(format, (AuthdataIdentifier >> 16) & 0xFFFF, AuthdataIdentifier & 0xFFFF));
                }
                else
                {
                    ModifiedScript = baseScript;
                }
            }

            public AuthdataTargetType TargetType;
            public int AuthdataIdentifier;
            public LuaScript ModifiedScript;
        }

        /// <summary>
        /// Sets the given authdata so that the given script will target it.
        /// </summary>
        /// <param name="luaScript">The script to target.</param>
        /// <param name="authdata">The authdata to modify.</param>
        public void SetAuthdataForScript (LuaScript luaScript, Authdata_Base authdata)
        {
            // find the entry for the given script
            LuaScriptAuthdata lsa = null;

            lock (_Scripts)
            {
                if (!_Scripts.TryGetValue(luaScript, out lsa))
                {
                    return;
                }
            }

            // set the authdata accordingly
            switch (lsa.TargetType)
            {
                case AuthdataTargetType.Version:
                    authdata.MajorVersion = 0x5347;
                    authdata.MinorVersion = 0x434D;
                    authdata.BuildNumber = (ushort)((lsa.AuthdataIdentifier >> 16) & 0xFFFF);
                    authdata.QFENumber = (ushort)(lsa.AuthdataIdentifier & 0xFFFF);
                    break;

                case AuthdataTargetType.Title:
                    authdata.TitleId = 0x5347434D;
                    authdata.TitleVersion = (uint)lsa.AuthdataIdentifier;
                    break;
            }
        }

        /// <summary>
        /// Gets the challenge id that a script was propped with.
        /// </summary>
        /// <param name="luaScript">The script to get the challenge id of.</param>
        /// <returns>The challenge id of the script.</returns>
        public uint GetChallengeIdForScript (LuaScript luaScript)
        {
            // find the entry for the given script
            LuaScriptAuthdata lsa = null;

            lock (_Scripts)
            {
                if (!_Scripts.TryGetValue(luaScript, out lsa))
                {
                    return 0;
                }
            }

            return (uint)(0x53470000 | (lsa.AuthdataIdentifier & 0xFFFF));
        }

        #endregion
    }

    /// <summary>
    /// A lua script that can be put into t_sg_scripts.
    /// </summary>
    public class LuaScript
    {
        /// <summary>Name of the script (vc_script_name).</summary>
        public string Name { get; set; }

        /// <summary>If true, is enabled; if false its not (ti_enabled).</summary>
        public bool Enabled { get; set; }

        /// <summary>The script body (txt_script).</summary>
        public string Script { get; set; }

        /// <summary>The binary blob (im_blob).</summary>
        public byte[] Blob { get; set; }

        /// <summary>Sets the __KickEnabled field in the challenge/controller's Lua global table (ti_chal_kick_enabled).</summary>
        public bool KickEnabled { get; set; }

        /// <summary>Sets the __TimeoutEnabled field in the challenge/controller's Lua global table (ti_chal_timeout_enabled).</summary>
        public bool TimeoutEnabled { get; set; }

        /// <summary>Used to replace the ChallengeDeclare macro.</summary>
        public bool IsSync { get; set; }

        /// <summary>Used to replace the ChallengeDeclare macro.</summary>
        public bool IsPc { get; set; }

        /// <summary>Used to replace the ChallengeDeclare macro.</summary>
        public bool IsDevkit { get; set; }

        /// <summary>
        /// Basic constructor.
        /// </summary>
        public LuaScript ()
        {
            Enabled = true;
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="script">The script to copy.</param>
        public LuaScript (LuaScript luaScript)
        {
            Name = luaScript.Name;
            Enabled = luaScript.Enabled;
            Script = luaScript.Script;
            Blob = (luaScript.Blob == null ? null : (byte[])luaScript.Blob.Clone());
            KickEnabled = luaScript.KickEnabled;
            TimeoutEnabled = luaScript.TimeoutEnabled;
            IsSync = luaScript.IsSync;
            IsPc = luaScript.IsPc;
            IsDevkit = luaScript.IsDevkit;
        }

        /// <summary>
        /// Props the Lua script to the database and conditionally reloads the SG.
        /// </summary>
        /// <param name="reload">If true, reload the SG; if false, don't.</param>
        public void PropScript (bool reload)
        {
            // Insert into t_sg_scripts in npdb
            using (NpdbUtility npdb = new NpdbUtility())
            {
                npdb.ConnectToServer();
                npdb.PropSgScript(Name, Enabled, Script, Blob, KickEnabled, TimeoutEnabled);
            }

            // Force a reload of the config
            if (reload)
            {
                SgServerInfo.ReloadChallenges();
            }
        }

        /// <summary>
        /// Removes the Lua script from the database and conditionally reloads the SG.
        /// </summary>
        /// <param name="reload">If true, reload the SG; if false, don't.</param>
        public void RemoveScript (bool reload)
        {
            // Delete from t_sg_scripts in npdb
            using (NpdbUtility npdb = new NpdbUtility())
            {
                npdb.ConnectToServer();
                npdb.RemoveSgScript(Name);
            }

            // Force a reload of the config
            if (reload)
            {
                SgServerInfo.ReloadChallenges();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\kerbErr.cs ===
using System;

namespace ServerTestFramework.LiveService.Auth
{
    public class KerbErrException : Exception
    {
        public KerbErr KerbErr = null;
        public string ExtraMessage = null;

        public KerbErrException(int kerbErr) : this(new KerbErr(kerbErr)) {}
        public KerbErrException(int kerbErr, Exception inner) : this(new KerbErr(kerbErr), inner) {}
        public KerbErrException(uint kerbErr) : this(new KerbErr(kerbErr)) {}
        public KerbErrException(uint kerbErr, Exception inner) : this(new KerbErr(kerbErr), inner) {}
        public KerbErrException(KerbErr kerbErr) : this(kerbErr, null) {}
        public KerbErrException(KerbErr kerbErr, Exception inner) : base("KerbError: " + kerbErr.ToString(), inner)
        {
            KerbErr = kerbErr;
        }

        public override string ToString()
        {
            if (ExtraMessage != null)
            {
                return base.ToString() + ": " + ExtraMessage;
            }
            else
            {
                return base.ToString();
            }
        }

        public override string Message
        {
            get
            {
                if (ExtraMessage != null)
                    return base.Message + ": " + ExtraMessage;
                else
                    return base.Message;
            }
        }

        public override bool Equals(object obj)
        {
            if (obj is KerbErrException)
                return KerbErr.Equals(((KerbErrException)obj).KerbErr);
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            return KerbErr.GetHashCode();
        }

        public static bool operator!=(KerbErrException a, KerbErrException b)
        {
            return a.KerbErr != b.KerbErr;
        }
        
        public static bool operator==(KerbErrException a, KerbErrException b)
        {
            return a.KerbErr == b.KerbErr;
        }
    }

    public enum KerbErrCode
    {
        #region KerbErrCode
        KDC_ERR_NONE = 0x0, 
        KDC_ERR_NAME_EXP = 0x1, 
        KDC_ERR_SERVICE_EXP = 0x2, 
        KDC_ERR_BAD_PVNO = 0x3, 
        KDC_ERR_C_OLD_MAST_KVNO = 0x4, 
        KDC_ERR_S_OLD_MAST_KVNO = 0x5, 
        KDC_ERR_C_PRINCIPAL_UNKNOWN = 0x6, 
        KDC_ERR_S_PRINCIPAL_UNKNOWN = 0x7, 
        KDC_ERR_PRINCIPAL_NOT_UNIQUE = 0x8, 
        KDC_ERR_NULL_KEY = 0x9, 
        KDC_ERR_CANNOT_POSTDATE = 0xA, 
        KDC_ERR_NEVER_VALID = 0xB, 
        KDC_ERR_POLICY = 0xC, 
        KDC_ERR_BADOPTION = 0xD, 
        KDC_ERR_ETYPE_NOTSUPP = 0xE, 
        KDC_ERR_SUMTYPE_NOSUPP = 0xF, 
        KDC_ERR_PADATA_TYPE_NOSUPP = 0x10, 
        KDC_ERR_TRTYPE_NO_SUPP = 0x11, 
        KDC_ERR_CLIENT_REVOKED = 0x12, 
        KDC_ERR_SERVICE_REVOKED = 0x13, 
        KDC_ERR_TGT_REVOKED = 0x14, 
        KDC_ERR_CLIENT_NOTYET = 0x15, 
        KDC_ERR_SERVICE_NOTYET = 0x16, 
        KDC_ERR_KEY_EXPIRED = 0x17, 
        KDC_ERR_PREAUTH_FAILED = 0x18, 
        KDC_ERR_PREAUTH_REQUIRED = 0x19, 
        KDC_ERR_SERVER_NOMATCH = 0x1A, 
        KDC_ERR_MUST_USE_USER2USER = 0x1B, 
        KDC_ERR_PATH_NOT_ACCPETED = 0x1C, 
        KDC_ERR_SVC_UNAVAILABLE = 0x1D, 
        KRB_AP_ERR_BAD_INTEGRITY = 0x1F, 
        KRB_AP_ERR_TKT_EXPIRED = 0x20, 
        KRB_AP_ERR_TKT_NYV = 0x21, 
        KRB_AP_ERR_REPEAT = 0x22, 
        KRB_AP_ERR_NOT_US = 0x23, 
        KRB_AP_ERR_BADMATCH = 0x24, 
        KRB_AP_ERR_SKEW = 0x25, 
        KRB_AP_ERR_BADADDR = 0x26, 
        KRB_AP_ERR_BADVERSION = 0x27, 
        KRB_AP_ERR_MSG_TYPE = 0x28, 
        KRB_AP_ERR_MODIFIED = 0x29, 
        KRB_AP_ERR_BADORDER = 0x2A, 
        KRB_AP_ERR_ILL_CR_TKT = 0x2B, 
        KRB_AP_ERR_BADKEYVER = 0x2C, 
        KRB_AP_ERR_NOKEY = 0x2D, 
        KRB_AP_ERR_MUT_FAIL = 0x2E, 
        KRB_AP_ERR_BADDIRECTION = 0x2F, 
        KRB_AP_ERR_METHOD = 0x30, 
        KRB_AP_ERR_BADSEQ = 0x31, 
        KRB_AP_ERR_INAPP_CKSUM = 0x32, 
        KRB_AP_PATH_NOT_ACCEPTED = 0x33, 
        KRB_ERR_RESPONSE_TOO_BIG = 0x34, 
        KRB_ERR_GENERIC = 0x3C, 
        KRB_ERR_FIELD_TOOLONG = 0x3D, 
        KDC_ERR_CLIENT_NOT_TRUSTED = 0x3E, 
        KDC_ERR_KDC_NOT_TRUSTED = 0x3F, 
        KDC_ERR_INVALID_SIG = 0x40, 
        KDC_ERR_KEY_TOO_WEAK = 0x41, 
        KDC_ERR_CERTIFICATE_MISMATCH = 0x42, 
        KRB_AP_ERR_NO_TGT = 0x43, 
        KDC_ERR_WRONG_REALM = 0x44, 
        KRB_AP_ERR_USER_TO_USER_REQUIRED = 0x45, 
        KDC_ERR_CANT_VERIFY_CERTIFICATE = 0x46, 
        KDC_ERR_INVALID_CERTIFICATE = 0x47, 
        KDC_ERR_REVOKED_CERTIFICATE = 0x48, 
        KDC_ERR_REVOCATION_STATUS_UNKNOWN = 0x49, 
        KDC_ERR_REVOCATION_STATUS_UNAVAILABLE = 0x4a, 
        KDC_ERR_CLIENT_NAME_MISMATCH = 0x4b, 
        KDC_ERR_KDC_NAME_MISMATCH = 0x4c,
        KDC_ERR_PASSPORT_PUID_MISMATCH = 0x4d,
                KDC_ERR_XBOX_TOKEN_INVALID = 0x1000,
                KDC_ERR_XBOX_TOKEN_BANNED = 0x1001,
                KDC_ERR_XBOX_TOKEN_USAGE_EXCEEDED = 0x1002,
                KDC_ERR_XBOX_TOKEN_IN_USE = 0x1003,
                KDC_ERR_MAX_VALUE = 0x1004

        #endregion
    }

    public class KerbErr
    {
        private uint errorCode = 0;
        
        public uint ErrorCode {get {return errorCode;} set {errorCode = ToKerbErr(value);}}
        public KerbErrCode Error {get {return (KerbErrCode)errorCode;} set {errorCode = (uint)value;}}

        public KerbErr()
        {
        }

        public KerbErr(int kerbErr)
        {
            ErrorCode = ToKerbErr((uint)kerbErr);
        }

        public KerbErr(uint kerbErr)
        {
            ErrorCode = ToKerbErr(kerbErr);
        }

        public static bool IsKerbErr(int kerbErr)
        {
            return IsKerbErr((uint)kerbErr);
        }

        public static bool IsKerbErr(uint kerbErr)
        {
            if (((kerbErr & 0xAFFF0000) == 0xAFFF0000) || (kerbErr < (uint)KerbErrCode.KDC_ERR_MAX_VALUE))
                return true;
            return false;
        }

        private uint ToKerbErr(uint kerbErr)
        {
            if (!IsKerbErr(kerbErr))
                throw new ArgumentException("0x" + kerbErr.ToString("x") + " is not a KerbErr");

            return kerbErr & 0x0000FFFF;
        }

        public override string ToString()
        {
            return string.Format("0x{0} ({1})", ErrorCode.ToString("x"), Error.ToString());
        }

        public override bool Equals(object obj)
        {
            if (obj is KerbErr)
                return ((KerbErr)obj).errorCode == errorCode;
            else if (obj is KerbErrCode)
                return (KerbErrCode)obj == Error;
            
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            return errorCode.GetHashCode();
        }

        public static bool operator!=(KerbErr a, KerbErr b)
        {
            return a.ErrorCode != b.ErrorCode;
        }
        
        public static bool operator==(KerbErr a, KerbErr b)
        {
            return a.ErrorCode == b.ErrorCode;
        }
        
        public static bool operator!=(KerbErr err, KerbErrCode code)
        {
            return code != err.Error;
        }
        
        public static bool operator==(KerbErr err, KerbErrCode code)
        {
            return code == err.Error;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\kerbStore.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;

namespace ServerTestFramework.LiveService.Auth
{
    public class KerbStoreGeneric
    {
        private int WaitTimeInMs        = 0;
        private int MaxItems            = 1000;
        private object lockMe              = new object();
        private WaitingQueue items;

        /*
        private WaitingQueue machineAccounts;
        private WaitingQueue userAccounts;
        private WaitingQueue tgts;
        private WaitingQueue serviceResults;
        */

        public KerbStoreGeneric (int WaitTimeInMs, int MaxItems)
        {
            this.WaitTimeInMs = WaitTimeInMs;
            this.MaxItems = MaxItems;
            items = new WaitingQueue(MaxItems, WaitTimeInMs);
        }

        public int NumValidItems
        {
            get
            {
                return items.NumValidItems;
            }
        }

        public int NumWaitingItems
        {
            get
            {
                return items.NumWaitingItems;
            }
        }

        /// <summary>
        /// Adds item to store
        /// </summary>
        /// <param name="item"></param>
        public void Add (object item)
        {
            lock(lockMe)
            {
                items.Enqueue(item);
            }
        }

        /// <summary>
        /// Gets item but leaves it in the store
        /// </summary>
        /// <returns></returns>
        public object Get ()
        {
            lock(lockMe)
            {
                // Remove
                object item = items.Dequeue();

                // And put back
                if(item != null)
                    items.Enqueue(item);

                return item;
            }
        }

        /// <summary>
        /// Gets item from store and removes it
        /// </summary>
        /// <returns></returns>
        public object Pop ()
        {
            lock(lockMe)
            {
                // Remove
                return items.Dequeue();
            }
        }

        public bool Valid ()
        {
            lock(lockMe)
                return items.Valid();
        }
    }

    public class WaitingQueue
    {
        private Queue items;
        private Queue waiting;
        private int maxItems;
        private int waitMSec;

        public WaitingQueue (int maxItems, int waitMSec)
        {
            this.items = new Queue(maxItems);
            this.waiting = new Queue(maxItems);
            this.maxItems = maxItems;
            this.waitMSec = waitMSec;
        }

        public int NumValidItems
        {
            get
            {
                return items.Count;
            }
        }

        public int NumWaitingItems
        {
            get
            {
                return waiting.Count;
            }
        }

        public void Enqueue (object o)
        {
            PumpWaitingItems();

            if(maxItems == -1 || items.Count + waiting.Count < maxItems)
            {
                if(waitMSec == 0)
                    items.Enqueue(o);
                else
                    waiting.Enqueue(new WaitingItem(o, waitMSec));
            }
        }

        public object Dequeue ()
        {
            PumpWaitingItems();

            if(items.Count > 0)
                return items.Dequeue();

            return null;
        }

        private void PumpWaitingItems ()
        {
            while(waiting.Count > 0 && DateTime.Now >= ((WaitingItem)waiting.Peek()).ValidAt)
                items.Enqueue(((WaitingItem)waiting.Dequeue()).Item);
        }

        public bool Valid ()
        {
            object[] ia = items.ToArray();
            object[] wa = waiting.ToArray();

            for(int i = 0; i < ia.Length; i++)
            {
                // Make sure there are no duplicates
                for(int j = i+1; j < ia.Length; j++)
                    Debug.Assert(ia[i] != ia[j]);

                // Make sure there is no duplicate item in the waiting queue
                for(int j = 0; j < wa.Length; j++)
                    Debug.Assert(ia[i] != wa[j]);
            }

            return true;
        }
    }

    public class WaitingItem
    {
        public object Item;
        public DateTime ValidAt = DateTime.MinValue;

        public WaitingItem (object item)
        {
            this.Item = item;
        }

        public WaitingItem (object item, DateTime validAt) : this(item)
        {
            this.ValidAt = validAt;
        }

        public WaitingItem (object item, int waitMSec) : this(item)
        {
            this.ValidAt = DateTime.Now + new TimeSpan(0, 0, 0, 0, waitMSec);
        }
    }

    public class KerbStore<T> where T: class
    {
        private int             WaitTimeInMs        = 0;
        private int             MaxItems            = 1000;
        private object          lockMe              = new object();
        private WaitingQueue<T> items;

        /*
        private WaitingQueue machineAccounts;
        private WaitingQueue userAccounts;
        private WaitingQueue tgts;
        private WaitingQueue serviceResults;
        */

        public KerbStore(int WaitTimeInMs, int MaxItems)
        {
            this.WaitTimeInMs = WaitTimeInMs;
            this.MaxItems = MaxItems;
            items = new WaitingQueue<T>(MaxItems, WaitTimeInMs);
        }

        public int NumValidItems
        { 
            get 
            {
                return items.NumValidItems;
            }
        }

        public int NumWaitingItems
        {
            get
            {
                return items.NumWaitingItems;
            }
        }

        /// <summary>
        /// Adds item to store
        /// </summary>
        /// <param name="item"></param>
        public void Add(T item)
        {
            lock (lockMe)
            {
                items.Enqueue(item);
            }
        }

        /// <summary>
        /// Gets item but leaves it in the store
        /// </summary>
        /// <returns></returns>
        public T Get()
        {
            lock (lockMe)
            {
                // Remove
                T item = items.Dequeue();

                // And put back
                if (item != null)
                    items.Enqueue(item);

                return item;
            }
        }

        /// <summary>
        /// Gets item from store and removes it
        /// </summary>
        /// <returns></returns>
        public T Pop()
        {
            lock (lockMe)
            {
                // Remove
                return items.Dequeue();
            }
        }

        public bool Valid()
        {
            lock (lockMe)
                return items.Valid();
        }
    }

    public class WaitingQueue<T>
        where T: class
    {
        private Queue<T> items;
        private Queue<WaitingItem<T>> waiting;
        private int maxItems;
        private int waitMSec;

        public WaitingQueue(int maxItems, int waitMSec)
        {
            this.items = new Queue<T>(maxItems);
            this.waiting = new Queue<WaitingItem<T>>(maxItems);
            this.maxItems = maxItems;
            this.waitMSec = waitMSec;
        }

        public int NumValidItems
        {
            get
            {
                return items.Count;
            }
        }

        public int NumWaitingItems
        {
            get
            {
                return waiting.Count;
            }
        }

        public void Enqueue(T o)
        {
            PumpWaitingItems();

            if (maxItems == -1 || items.Count + waiting.Count < maxItems)
            {
                if (waitMSec == 0)
                    items.Enqueue(o);
                else
                    waiting.Enqueue(new WaitingItem<T>(o, waitMSec));
            }
        }

        public T Dequeue()
        {
            PumpWaitingItems();

            if (items.Count > 0)
                return items.Dequeue();

            return null;
        }

        private void PumpWaitingItems()
        {
            while (waiting.Count > 0 && DateTime.Now >= waiting.Peek().ValidAt)
                items.Enqueue(waiting.Dequeue().Item);
        }

        public bool Valid()
        {
            T[] ia = items.ToArray();
            WaitingItem<T>[] wa = waiting.ToArray();

            for (int i = 0; i < ia.Length; i++)
            {
                // Make sure there are no duplicates
                for (int j = i+1; j < ia.Length; j++)
                    Debug.Assert(ia[i] != ia[j]);

                // Make sure there is no duplicate item in the waiting queue
                for (int j = 0; j < wa.Length; j++)
                    Debug.Assert(ia[i] != wa[j]);
            }

            return true;
        }
    }


    public class WaitingItem<T>
    {
        public T Item;
        public DateTime ValidAt = DateTime.MinValue;

        public WaitingItem(T item)
        {
            this.Item = item;
        }

        public WaitingItem(T item, DateTime validAt) : this(item)
        {
            this.ValidAt = validAt;
        }

        public WaitingItem(T item, int waitMSec) : this(item)
        {
            this.ValidAt = DateTime.Now + new TimeSpan(0, 0, 0, 0, waitMSec);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\QOS.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary>
    /// Embodies the Quality of Service (QoS) message/response to the Live service.
    /// </summary>
    public class QOS
    {
        public SecMsgQosInit Init1 = new SecMsgQosInit();
        public SecMsgQosInit Init2 = new SecMsgQosInit();
        public SecMsgQosResp Resp1 = null;
        public SecMsgQosResp Resp2 = null;
        
        // Cahced after the send
        public XspPacket Init1Xsp = null;
        public XspPacket Init2Xsp = null;

        // Sequence for all QOS packets sent
        public static byte PktIdx = 0;

        // Delay between sending packets
        public int DelayMs = 0;

        public long TscFreq;
        public bool TscValid;
        public long TscXmit;
        public long TscRecv1 = 0;
        public long TscRecv2;
        public double Rtt1us;
        public double Rtt2us;
        public double GapRus;
        public double GapLus;
        public const double Microseconds = 1000000.0;
        public const uint CBPKT_SECMSG_TYPE_SGTOXB_QOS_RESP = 94;
        public const uint CBPKT_SECMSG_TYPE_XBTOSG_QOS_INIT = 86;
        public const uint CBEXT_SECMSG_TYPE_XBTOSG_QOS_INIT = 1024;

        // Use large QoS packets
        protected bool _useLargePackets = false;
        /// <summary>
        /// If true, large QoS packets will be sent to the SG; otherwise small ones.
        /// </summary>
        public bool UseLargePackets
        {
            get { return _useLargePackets; }
            set { _useLargePackets = value; Reset(); }
        }

        // Sucessful QoS exchange?
        protected bool bSuccess = false;
        public bool Success
        {
            get { return bSuccess; }
        }

        // Did we even get a reply?
        public bool NoReply
        {
            get { return Resp1 == null && Resp2 == null; }
        }

        
        /// <summary>
        /// Return the current timer in milliseconds
        /// </summary>
        protected double TimerMs
        {
            get
            {
                return System.DateTime.Now.TimeOfDay.TotalMilliseconds;
            }
        }

        public QOS()
        {
            Reset();
        }

        public QOS(int delayMs)
        {
            DelayMs = delayMs;
            Reset();
        }

        /// <summary>
        /// Creates a new QOS object with the specified value for UseLargePackets.
        /// </summary>
        /// <param name="useLargePackets">The value to set UseLargePackets to.</param>
        public QOS (bool useLargePackets)
        {
            _useLargePackets = useLargePackets;
            Reset();
        }

        public void Reset()
        {
            Random rand = new Random();

            Init1.Type = SecMsgHeader.SECMSG_TYPE_XBTOSG_QOS_INIT;
            Init1.cbEnt = SecMsgQosInit.SIZE;
            Init1.QosIdx = (ushort)rand.Next();
            Init1.PktIdx = PktIdx;
            Init1.Flags = 0;
            Init1.Nonce = AuthUtils.GetNewNonce();

            // Init2 is exactly same as Init1 except for Flags
            Init2.Type = Init1.Type;
            Init2.cbEnt = Init1.cbEnt;
            Init2.QosIdx = Init1.QosIdx;
            Init2.PktIdx = Init1.PktIdx;
            Init2.Flags = SecMsgHeader.QPF_PAIR_TWO;
            Init2.Nonce = (byte[])Init1.Nonce.Clone();

            if (_useLargePackets)
            {
                Init1.cbEnt += (short) CBEXT_SECMSG_TYPE_XBTOSG_QOS_INIT;
                Init2.cbEnt += (short) CBEXT_SECMSG_TYPE_XBTOSG_QOS_INIT;
            }

            Resp1 = null;
            Resp2 = null;

            TscRecv1 = 0;
        }

        public bool SendRecv(SgClient sgclient)
        {
            Send(sgclient);
            return Recv(sgclient);
        }
        public bool SendRecv(SgClient sgclient, int timeoutInMS)
        {
            Send(sgclient);
            return Recv(sgclient,timeoutInMS);
        }

        public void Send(SgClient sgclient)
        {
            byte pkIdx=PktIdx++;

            // Save sent time for client calculations
            try
            {
                TscFreq = Timing.QueryPerformanceFrequency();
                TscValid = true;

                TscXmit = Timing.QueryPerformanceCounter();
            }
            catch (NotSupportedException)
            {
                TscValid = false;
            }


            if (Init1 != null)
            {
                Init1.PktIdx = pkIdx;
                if (Init1Xsp == null)
                {
                    Init1Xsp = sgclient.XspSend(Init1);
                }
                else
                {
                    // We can re-serialize, re-encrypt, and re-send. Fast!
                    byte[] msg = (byte[])Init1;
                    sgclient.XspResend(Init1Xsp, msg);
                }
                if (DelayMs > 0)
                {
                    System.Threading.Thread.Sleep(DelayMs);
                }
            }

            if (Init2 != null)
            {
                Init2.PktIdx = pkIdx;
                if (Init2Xsp == null)
                {
                    Init2Xsp = sgclient.XspSend(Init2);
                }
                else
                {
                    // We can re-serialize, re-encrypt, and re-send. Fast!
                    byte[] msg = (byte[])Init2;
                    sgclient.XspResend(Init2Xsp, msg);
                }

            }
        }

        public bool Recv(SgClient sgclient)
        {
            return Recv(sgclient,2000);
        }
        public bool Recv(SgClient sgclient, int timeoutInMS)
        {
            bSuccess = true;
            Resp1 = null;
            Resp2 = null;
            SecMsgHeader Resp1hdr;
            SecMsgHeader Resp2hdr;

            if (!RecvLoop(timeoutInMS, sgclient, out Resp1hdr))
            {
                bSuccess = false;
            }
            if (!RecvLoop(timeoutInMS, sgclient, out Resp2hdr))
            {
                bSuccess = false;
            }
   
            Resp1 = Resp1hdr as SecMsgQosResp;
            Resp2 = Resp2hdr as SecMsgQosResp;
            if (bSuccess)
            {
                bSuccess = VerifyResponse();
            }
            return bSuccess;
        }

        protected bool RecvLoop(int timeoutInMs, SgClient sgclient, out SecMsgHeader hdrRet)
        {
            hdrRet = null;
            SecMsgHeader hdr = null;
            double startTime = TimerMs;
            double stopTime = TimerMs + timeoutInMs;
            while (TimerMs < stopTime)
            {
                int remainTime = (int)(stopTime - TimerMs);
                hdr = sgclient.SecMsgRecv(remainTime);

                // Get the current timing value that we received this packet
                long TscNow = 0;
                if (TscValid)
                {
                    TscNow = Timing.QueryPerformanceCounter();
                    TscNow = (TscNow == 0 ? 1 : TscNow);
                }

                if (hdr == null)
                {
                    return false;
                }

                if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL)
                {
                    SecMsgSgToXbChal sgChallenge = hdr as SecMsgSgToXbChal;
                    //if (bVerbose)
                        Global.RO.Debug("[QOS] Got SECMSG_TYPE_SGTOXB_CHAL type=0x{0:X}, size={1}, nonce={2:X8} in {3} ms", hdr.Type, hdr.cbEnt, sgChallenge.ChallengeNonce, (int)(TimerMs - startTime));
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK)
                {
                    SecMsgSgToXbChalRespAck sgAck = hdr as SecMsgSgToXbChalRespAck;
                    //if (bVerbose)
                        Global.RO.Debug("[QOS] Got SECMSG_TYPE_SGTOXB_CHALRESP_ACK type=0x{0:X}, size={1}, nonce={2:X8} in {3} ms", hdr.Type, hdr.cbEnt, sgAck.ChallengeNonce, (int)(TimerMs - startTime));
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2)
                {
                    //if (bVerbose)
                        Global.RO.Debug("[QOS] Got SECMSG_TYPE_SGTOXB_PULSE_2 type=0x{0:X}, size={1} in {2} ms, replying...", hdr.Type, hdr.cbEnt, (int)(TimerMs - startTime));
                    // Respond with a heartbeat
                    sgclient.SendDataPulse();
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_DELETE)
                {
                    // We just got booted :(
                    //if (bVerbose)
                        Global.RO.Debug("[CR] Got SECMSG_TYPE_DELETE type=0x{0:X}, size={1} in {2} ms", hdr.Type, hdr.cbEnt, (int)(TimerMs - startTime));
                }
                else if (hdr.Type == SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP)
                {
                    // Do client calculations for computing latency and bandwidth
                    if (TscValid)
                    {
                        // check frequency, if it has changed, then this whole thing is whack
                        long newFreq = Timing.QueryPerformanceFrequency();

                        if (newFreq != TscFreq)
                        {
                            TscValid = false;
                        }
                        else
                        {
                            SecMsgQosResp resp = (SecMsgQosResp) hdr;

                            if ((resp.Flags & SecMsgQosResp.QPF_PAIR_TWO) == 0)
                            {
                                TscRecv1 = TscNow;
                                Rtt1us = Timing.CalculatePerformanceDelta(TscXmit, TscNow) * Microseconds;
                                Rtt1us -= Math.Min(Rtt1us, (double) resp.Rtt);
                            }
                            else
                            {
                                TscRecv2 = TscNow;
                                Rtt2us = Timing.CalculatePerformanceDelta(TscXmit, TscNow) * Microseconds;
                                Rtt2us -= Math.Min(Rtt2us, (double) resp.Rtt);
                                GapRus = (double) resp.Gap;
                                Rtt2us -= Math.Min(Rtt2us, GapRus);

                                if (TscRecv1 == 0)
                                {
                                    Global.RO.Warn("QoS packets received out of order, client doesn't like this.");
                                }
                                else
                                {
                                    GapLus = Timing.CalculatePerformanceDelta(TscRecv1, TscNow) * Microseconds;
                                    Rtt2us -= Math.Min(Rtt2us, GapLus);
                                }
                            }
                        }
                    }

                    hdrRet = hdr;
                    return true;
                }
                else
                {
                    Global.RO.Debug("[CR] Got SECMSG type=0x{0:X} size={1} in {2} ms", hdr.Type, hdr.cbEnt, (int)(TimerMs - startTime));
                }
            }
            // Didn't get what we were looking for...
            return false;
        }


        public bool VerifyResponse()
        {
            // It's possible the two response packets got re-ordered, so let's correct
            // that if it happend.
            if (this.Resp1 != null && 
                (this.Resp1.Flags & SecMsgHeader.QPF_PAIR_TWO) == SecMsgHeader.QPF_PAIR_TWO)
            {
                SecMsgQosResp temp = this.Resp2;                
                this.Resp2 = this.Resp1;
                this.Resp1 = temp;
            }

            if (!VerifyResponsePair(this.Init1, this.Resp1))
            {
                Global.RO.Debug("[QoS] QoS packet pair #1 failed check");
                return false;
            }
            if (!VerifyResponsePair(this.Init2, this.Resp2))
            {
                Global.RO.Debug("[QoS] QoS packet pair #2 failed check");
                return false;
            }
            return true;
        }

        protected bool VerifyResponsePair(SecMsgQosInit init, SecMsgQosResp resp)
        {
            if (init == null)
            {
                return (resp == null);
            }

            if (resp == null)
            {
                Global.RO.Debug("[QoS] Response is null");
                return false;
            }

            if (resp.Type != SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP)
            {
                Global.RO.Debug("[QoS] Wrong packet type");
                return false;
            }
            for (int i = 0; i < init.Nonce.Length; i++)
            {
                if (init.Nonce[i] != resp.Nonce[i])
                {
                    Global.RO.Debug("[QoS] Nonce mismatch");
                    return false;
                }
            }
            if (init.QosIdx != resp.QosIdx)
            {
                Global.RO.Debug("[QoS] QosIdx mismatch");
                return false;
            }
            if (init.PktIdx != resp.PktIdx)
            {
                Global.RO.Debug("[QoS] PktIdx mismatch");
                return false;
            }
            // Special processing for 2nd packet of the pair
            if ((init.Flags & SecMsgHeader.QPF_PAIR_TWO) == SecMsgHeader.QPF_PAIR_TWO)
            {
                if (init.Flags != resp.Flags && (init.Flags | SecMsgHeader.QPF_DATA_NONE) != resp.Flags)
                {
                    Global.RO.Debug("[QoS] Flags mismatch for packet 2");
                    return false;
                }
                if (resp.Gap == 0)
                {
                    Global.RO.Debug("[QoS] Gap is zero in response");
                    return false;
                }
                if (resp.Rtt != 0)
                {
                    Global.RO.Debug("[QoS] Rtt is not zero in response");
                    return false;
                }
            }
            // Special processing for 1st packet of the pair
            else 
            {
                if (init.Flags != resp.Flags)
                {
                    Global.RO.Debug("[QoS] Flags mismatch for packet 1");
                    return false;
                }
                if (resp.Gap != 0)
                {
                    Global.RO.Debug("[QoS] Gap is not zero in response");
                    return false;
                }
                if (resp.Rtt == 0)
                {
                    Global.RO.Debug("[QoS] Rtt is zero in response");
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// The results of a client QoS computation.
        /// </summary>
        public class Results
        {
            public double RttMinInMsecs;
            public double RttMaxInMsecs;
            public double RttMedInMsecs;
            public double UpBitsPerSec;
            public double DnBitsPerSec;
            public double SuccessRate;

            public Results ()
            {
                RttMinInMsecs = RttMaxInMsecs = RttMedInMsecs = UpBitsPerSec = DnBitsPerSec = SuccessRate = 0;
            }
        }

        /// <summary>
        /// Computes the client QoS numbers from the given individual QoS tests.
        /// </summary>
        /// <param name="probes">The QoS tests to use.</param>
        /// <returns>A Results object that contains the same values that are computed on the client.</returns>
        /// <remarks>Adapted from \xenon\private\xtl\net\base\Ipqos.cpp::IpQosCliInfoCompute</remarks>
        public static Results ComputeClientQoS (List<QOS> probes)
        {
            Results ans = new Results();
            List<double> samples = new List<double>(probes.Count * 2);
            int numFail = 0;

            for (int i = 0; i < probes.Count; ++i)
            {
                if (probes[i].TscValid && probes[i].bSuccess)
                {
                    if (probes[i].Rtt1us != 0)
                    {
                        samples.Add(probes[i].Rtt1us);
                    }
                    if (probes[i].Rtt2us != 0)
                    {
                        samples.Add(probes[i].Rtt2us);
                    }
                }
                else
                {
                    numFail++;
                }
            }

            ans.SuccessRate = (double)(probes.Count - numFail) / probes.Count;

            if (samples.Count > 0)
            {
                samples.Sort();

                // calculate median, round into milliseconds
                int tempMid = samples.Count / 2;
                ans.RttMedInMsecs = (samples.Count % 1 == 0 ? 
                    (samples[tempMid - 1] + samples[tempMid]) / 2 : 
                    samples[tempMid]);
                ans.RttMedInMsecs = (ans.RttMedInMsecs + 500) / 1000;

                // round minimum into milliseconds
                ans.RttMinInMsecs = (samples[0] + 500) / 1000;

                // round maximum into milliseconds
                ans.RttMaxInMsecs = (samples[samples.Count - 1] + 500) / 1000;

                ans.UpBitsPerSec = ComputeClientBandwidth(probes, false);
                ans.DnBitsPerSec = ComputeClientBandwidth(probes, true);
            }

            return ans;
        }

        /// <summary>
        /// Used in ComputeClientBandwidth to 'bucketize' the sampled values.
        /// </summary>
        private class QoSBucket
        {
            public double BitsPerSecond;
            public int Count;
            public double Density;

            public QoSBucket ()
            {
                BitsPerSecond = Density = 0;
                Count = 0;
            }
        }

        /// <summary>
        /// Computes the client bandwidth from the given individual QoS tests.
        /// </summary>
        /// <param name="probes">The QoS tests to use.</param>
        /// <param name="downstream">True for the downstream bandwidth; false for the upstream.</param>
        /// <returns>The bits per second bandwidth value for the requested direction.</returns>
        /// <remarks>Adapted from \xenon\private\xtl\net\base\Ipqos.cpp::IpQosBandwidth</remarks>
        protected static double ComputeClientBandwidth (List<QOS> probes, bool downstream)
        {
            List<double> samples = new List<double>(probes.Count);

            uint bitsPerPkt = (downstream ? CBPKT_SECMSG_TYPE_SGTOXB_QOS_RESP : CBPKT_SECMSG_TYPE_XBTOSG_QOS_INIT) * 8;

            // Compute the bits per second for each probe by taking the packet size and dividing by the time between
            // receiving two packets that should have been sent consecutively.
            for (int i = 0; i < probes.Count; ++i)
            {
                double gap = (downstream ? probes[i].GapLus : probes[i].GapRus);

                if (probes[i].TscValid && probes[i].bSuccess && gap > 0)
                {
                    uint bits = bitsPerPkt;

                    if (!downstream && probes[i]._useLargePackets)
                    {
                        bits += CBEXT_SECMSG_TYPE_XBTOSG_QOS_INIT * 8;
                    }

                    gap = (((double) bits) * Microseconds) / gap;

                    samples.Add(Math.Min(gap, 10.0 * 1000.0 * 1000.0));
                }
            }

            samples.Sort();

            // For small sample size, we just use the computed values
            switch (samples.Count)
            {
                case 2:
                    return (samples[0] + samples[1]) / 2;
                case 1:
                    return samples[0];
                case 0:
                    throw new ArgumentException("No valid QoS probes were found in the given list.");
                default:
                    // We have more than a trivial amount, we need to do more processing
                    break;
            }

            // Sort all of the samples into buckets of bits per second values, then average those buckets
            List<QoSBucket> buckets = new List<QoSBucket>();
            QoSBucket bucket = null;
            double bitsPerSecond = 0;

            for (int i = 0; i < samples.Count; ++i)
            {
                double samp = samples[i];

                if (samp >= bitsPerSecond)
                {
                    if (buckets.Count > 0)
                    {
                        bucket.BitsPerSecond /= bucket.Count;
                    }

                    buckets.Add(new QoSBucket());
                    bucket = buckets[buckets.Count - 1];

                    bucket.BitsPerSecond = samp;
                    bucket.Count = 1;
                    bucket.Density = 0;

                    bitsPerSecond = samp + 5000;
                }
                else
                {
                    bucket.BitsPerSecond += samp;
                    bucket.Count += 1;
                }
            }

            bucket.BitsPerSecond /= bucket.Count;

            // If all of the values were reasonably close to each other, we just use the average
            if (buckets.Count == 1)
            {
                return buckets[0].BitsPerSecond;
            }

            // Compute density values
            // Not sure exactly what the math or reasoning behind this is
            double densityMin = double.MaxValue;

            for (int i = 0; i < buckets.Count; ++i)
            {
                QoSBucket bucket1 = buckets[i];
                double bps1 = bucket1.BitsPerSecond;

                for (int j = 0; j < buckets.Count; ++j)
                {
                    QoSBucket bucket2 = buckets[j];
                    double bps2 = bucket2.BitsPerSecond;

                    // Density[i] = sigma(j=0 .. cQosCliBucket){abs(bw[i]-bw[j])}
                    bucket1.Density += (bps1 > bps2 ? bps1 - bps2 : bps2 - bps1) * bucket2.Count;
                }

                if (densityMin > bucket1.Density)
                {
                    densityMin = bucket1.Density;
                }
            }

            samples.Clear();

            for (int i = 0; i < buckets.Count; ++i)
            {
                if (buckets[i].Density - densityMin < 0.000001)
                {
                    samples.Add(buckets[i].BitsPerSecond);
                }
            }

            if (samples.Count == 0)
            {
                throw new Exception("Despite being a value taken from the bucket list, there was no bucket " + 
                    "that matched the value.  This should never happen.");
            }

            int sampMed = samples.Count / 2;
            return ((samples.Count & 1) == 1 ? samples[sampMed] : (samples[sampMed - 1] + samples[sampMed]) / 2);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\kerbStructs.cs ===
using System;
using System.Net;
using System.IO;
using System.Text;

namespace ServerTestFramework.LiveService.Auth
{

    // XkdcResult
    // TgtContext
    // XeTitleInfo
    // XonlinepUser
    // XoKerbInfo
    // ServiceContextXe
    // ServiceContextXbox
    #region Structure defs

    public class XkdcResult
    {
        public int              NumServices         = 0;
        public int              NumValidServices    = 0;
        public uint             ServiceHR           = 0;
        public uint[]           ServiceHRs          = new uint[128+4];
        public uint[]           ServiceIDs          = new uint[128+4];
        public uint[]           ServicePorts        = new uint[128+4];
        public uint[,]          Privileges          = new uint[4,8];
        public uint[]           UserHRs             = new uint[4];
        public uint[]           UserFlags           = new uint[4];
        public Authdata_Base    authData            = null;
        public ulong            MachinePuid         = 0;
        public bool             MachineOnly         = true;
        public uint             ServiceAddressPreauthVersion = 0;
        public ulong            ConsoleBanExpireTime=0;
        public ulong[]          UserBanExpireTime   = new ulong[4];

        public override string ToString()
        {
            return ToString(false);
        }

        public string ToString(bool bVerbose)
        {
            int i;
            StringBuilder sb = new StringBuilder(1024);
            sb.Append("XKDC Result:\n");
            sb.AppendFormat("      NumServices: {0}\n", NumServices);
            sb.AppendFormat(" NumValidServices: {0}\n", NumValidServices);
            sb.AppendFormat("        ServiceHR: 0x{0:X}\n", ServiceHR);
            sb.AppendFormat("      MachinePuid: 0x{0:X}\n", MachinePuid);
            sb.AppendFormat("    Services HR 0: ");
            for (i = 0; i < ServiceHRs.Length; i++)
            {
                if (ServiceHRs[i] == 0 && ServiceIDs[i] != 0)
                    sb.AppendFormat("{0} ", ServiceIDs[i]);
            }
            sb.AppendFormat("\n    Services HR 1: ");
            for (i = 0; i < ServiceHRs.Length; i++)
            {
                if (ServiceHRs[i] == 1 && ServiceIDs[i] != 0)
                    sb.AppendFormat("{0} ", ServiceIDs[i]);
            }
            sb.AppendFormat("\n   Services Other: ");
            for (i = 0; i < ServiceHRs.Length; i++)
            {
                if (ServiceHRs[i] != 0 && ServiceHRs[i] != 1 && ServiceIDs[i] != 0)
                    sb.AppendFormat("[{0},{1}] ", ServiceIDs[i], ServiceHRs[i]);
            }
            for (i = 0; i < UserHRs.Length; i++)
            {
                sb.AppendFormat("\n U{0}: HR=0x{1:X} Flags=0x{2:X} ServBits:0x{3:X} PrivBits:0x{4:X}", i, UserHRs[i], UserFlags[i], Privileges[i,0], Privileges[i,7]);
            }
            sb.AppendFormat("\n");

            if (bVerbose)
            {
                sb.AppendFormat(authData != null ? authData.ToString() : "No authdata.");
            }


            return sb.ToString();
        }

        //Helper to check whether a specific privilege bit is set
        public bool HasPrivilege(int userIndex, int privilege)
        {
            int whichDword=privilege/32;
            int whichBit=privilege%32;
            return (Privileges[userIndex, whichDword] & (1<<whichBit)) != 0;
        }
    }

    public class TgtContext : IDisposable
    {
        // TODO: update this to be a real struct that we can WireData. Use tokens for now.

        private IntPtr                   _tgtToken    = IntPtr.Zero;

        public IntPtr tgtToken
        {
            get
            {
                return _tgtToken;
            }
        }

        public TgtContext()
        {
            AuthClientBase.DLL_CreateToken((uint)AuthClientBase.TokenType.TgtContext, out _tgtToken, null, 0, 0);
            if (_tgtToken == IntPtr.Zero)
            {
                throw new OutOfMemoryException("Error creating TgtContext token");
            }
        }

        ~TgtContext()
        {
            Dispose();
        }

        public void Dispose()
        {
            if (_tgtToken != IntPtr.Zero)
            {
                AuthClientBase.DLL_DeleteToken(_tgtToken);
                _tgtToken = IntPtr.Zero;
            }
            GC.SuppressFinalize(this);
        }
    }

    public class XeTitleInfo : WireData
    {
        public uint                     TitleId;
        public uint                     TitleVersion;
        public uint                     TitleGameRegion;
        [WireInfo(ArraySize=16)]
        public byte[]                   XboxVersion = new byte[16];
        public ushort                   MajorVersion;
        public ushort                   MinorVersion;
        public ushort                   BuildNumber;
        public ushort                   QFENumber;
        public uint                     FlashVersion;
        public ushort                   OverrideDefaultServiceRequest;
        public ushort                   OverrideDefaultServiceRequestVersion;

        public XeTitleInfo()
        {
            Initialize();
        }

        public XeTitleInfo(uint TitleId, uint TitleVersion, uint TitleGameRegion)
        {
            Initialize();
            this.TitleId = TitleId;
            this.TitleVersion = TitleVersion;
            this.TitleGameRegion = TitleGameRegion;
        }

        public void Initialize()
        {
            TitleId = 0xC0FE0800;   // This is a Xenon title, eventually it won't work for Xbox TGS requests.
            TitleVersion = 1;
            TitleGameRegion = 1;
            MajorVersion = 0xF;
            MinorVersion = 0xF;
            BuildNumber = 0xFFFF;
            QFENumber = 0x0;
            FlashVersion = 0xFFFFFF00;
            OverrideDefaultServiceRequest = 0;
            OverrideDefaultServiceRequestVersion = 5;
        }

        /// <summary>
        /// Get TitleInfo struct, for backwards compatibility
        /// </summary>
        /// <returns></returns>
        public TitleInfo GetTitleInfo()
        {
            TitleInfo ti = new TitleInfo(TitleId, TitleVersion, TitleGameRegion);
            return ti;
        }

        /// <summary>
        /// Sets members based on TitleInfo object, for backwards compatibility
        /// </summary>
        /// <param name="ti"></param>
        public void SetTitleInfo(TitleInfo ti)
        {
            this.TitleId = (uint)ti.TitleId;
            this.TitleVersion = (uint)ti.Version;
            this.TitleGameRegion = (uint)ti.Region;
        }
    }

    //extra info passed to native code to build the as request with
    public class AsRequestInfo: WireData
    {
        public const int XONLINE_MAX_TICKET_LENGTH = 1024;

        [WireInfo(Serialize=false)]
        public bool   AutoComputeCertificateHash = true;
        [WireInfo(ArraySize=20)]
        public byte[] CertificateHash = new byte[20];

        public uint   PassportTicketLength; //automatically set from authcontext
        [WireInfo(ArraySize=XONLINE_MAX_TICKET_LENGTH)]
        public byte[] PassportTicket = new byte[XONLINE_MAX_TICKET_LENGTH]; //automatically set from authcontext
        public uint   PassportSessionKeyLength; //automatically set from authcontext
        [WireInfo(ArraySize=64)]
        public byte[] PassportSessionKey; //automatically set from authcontext

        [WireInfo(Serialize=false)]
        public bool   AutoRandomizePcNonce = true;
        public ulong  PcNonce;
        public uint   UsePcNonceKey; //automatically set from authcontext
    }

    public class XonlinepUser : WireData, ICloneable
    {
        public XUserID                  xuid = new XUserID();
        [WireInfo(ArraySize=16)]
        public byte[]                   Gamertag = new byte[16];
        public uint                     UserOptions;
        [WireInfo(ArraySize=4)]
        public byte[]                   Passcode = new byte[4];
        [WireInfo(ArraySize=20)]
        public byte[]                   Domain = new byte[20];
        [WireInfo(ArraySize=24)]
        public byte[]                   KerberosRealm = new byte[24];
        [WireInfo(ArraySize=16)]
        public byte[]                   Key = new byte[16];
        public uint                     SignatureTime;
        [WireInfo(ArraySize=8)]
        public byte[]                   Signature = new byte[8];
        public uint                     hr;

        public const int SIZE = 112;

        public XonlinepUser()
        {
            Initialize();
        }

        public void Initialize()
        {
            xuid.qwUserID = 0;
            xuid.dwUserFlags = 0;
            UserOptions = 0;
            SignatureTime = 0;
            hr = 0;
        }

        public void SetGamertag(string tag)
        {
            AuthClientBase.StringToBytes(Gamertag, tag);
        }

        public string GetGamertag()
        {
            return AuthClientBase.BytesToString(Gamertag);
        }

        public void SetRealm(string realm)
        {
            AuthClientBase.StringToBytes(KerberosRealm, realm);
        }

        #region ICloneable Members

            public object Clone()
            {
                XonlinepUser u = new XonlinepUser();

                // We're going to cheat a little by taking advantage of WireData
                byte[] b = (byte[])this;
                u.ReadBytes(b);
                return u;
            }

        #endregion
    }

    public class XoKerbInfo : WireData
    {
        [WireInfo(ArraySize=96)]
        public byte[]       DhX = new byte[96];         // Diffie-hellman X
        [WireInfo(ArraySize=96)]
        public byte[]       DhGX = new byte[96];        // Diffie-hellman g^X
        [WireInfo(ArraySize=16)]
        public byte[]       Key = new byte[16];         // Session key from ticket
        public uint         TicketId;                   // Ticket identifier
        public uint         ApReqMax;                   // Maximum size of AP request
        public int          UserPerm;                   // User permutation and guest bits
    }

    public class ServiceContextXe : WireData
    {
        public const int    XENON_SERVICE_CONTEXT_FLAG          = 0x12345678;
        public const int    XONLINE_XE_MAX_BYTE_SERVICEIDS      = 32;
        public const int    XONLINE_XE_MAX_BYTE_SERVICEIDS_2    = 128;
        public const int    XONLINE_MAX_DWORD_SERVICEIDS        = 4;
        public const int    XONLINE_MAX_LOGON_USERS             = 4;
        public const int    KERBEROS_MAX_PRINCIPLE_NAME_SIZE    = 4 + 16 + 20 + 24 + 20;
        public const int    XONLINE_KERBEROSREALM_SIZE          = 24;
        public const int    XONLINE_USERDOMAIN_SIZE             = 20;
        public const int    XC_SERVICE_DIGEST_SIZE              = 20;
        public const int    XONLINE_MAX_TICKET_LENGTH           = 1024;
        public const int    XONLINE_NUM_PRIVILEGE_DWORDS        = 8;
        public const int    XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID = 4;

        public ulong        MachineID;
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public ulong[]      UserID = new ulong[XONLINE_MAX_LOGON_USERS];
        public uint         dwTitleID;
        public uint         dwTitleVersion;
        public uint         dwNumServices;
        [WireInfo(ArraySize=XONLINE_XE_MAX_BYTE_SERVICEIDS)]
        public byte[]       bServiceID3 = new byte[XONLINE_XE_MAX_BYTE_SERVICEIDS];  // 32 of them (the other 96 are later)
        [WireInfo(ArraySize=XONLINE_MAX_DWORD_SERVICEIDS)]
        public uint[]       dwServiceID3 = new uint[XONLINE_MAX_DWORD_SERVICEIDS];  // 4 of them
        public ulong        StartTime;                  // TimeStamp
        public ulong        ExpirationTime;             // TimeStamp
        public uint         ctNumNonces;
        [WireInfo(ArraySize=8)]
        public uint[]       Nonce = new uint[8];
        [WireInfo(ArraySize=8)]
        public ulong[]      AuthenticatorTime = new ulong[8];       // TimeStamp
        public uint         hr;
        public XoKerbInfo   xoKerbInfo = new XoKerbInfo();
        public IpAddr       siteIPAddress = new IpAddr();
        public uint         dwBwLimit;
        public uint         dwXenonFlag = XENON_SERVICE_CONTEXT_FLAG;  // set to XENON_SERVICE_CONTEXT_FLAG to indicate struct type, kind of a hack, but this struct IS larger than the others
        public uint         dwConsoleRegion;
        public uint         dwMediaID;
        public ushort       wLanguageID;
        public ushort       wAutoDiscoverServices;
        [WireInfo(ArraySize=4)]
        public uint[]       dwReserved3 = new uint[4];  // size chosen to maintain field offsets
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public uint[]       hrUser = new uint[XONLINE_MAX_LOGON_USERS];
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public uint[]       dwUserFlags = new uint[XONLINE_MAX_LOGON_USERS];
        [WireInfo(ArraySize=XONLINE_XE_MAX_BYTE_SERVICEIDS)]
        public ushort[]     wServicePortBytes3 = new ushort[XONLINE_XE_MAX_BYTE_SERVICEIDS]; // for the service id bytes (32)
        [WireInfo(ArraySize=XONLINE_MAX_DWORD_SERVICEIDS)]
        public ushort[]     wServicePortDwords3 = new ushort[XONLINE_MAX_DWORD_SERVICEIDS]; // for the service id dwords (4)
        [WireInfo(ArraySize=KERBEROS_MAX_PRINCIPLE_NAME_SIZE)]
        public byte[]       ClientName = new byte[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
        [WireInfo(ArraySize=XONLINE_KERBEROSREALM_SIZE)]
        public byte[]       ClientRealm = new byte[XONLINE_KERBEROSREALM_SIZE];
        [WireInfo(ArraySize=XONLINE_KERBEROSREALM_SIZE)]
        public byte[]       ServiceRealm = new byte[XONLINE_KERBEROSREALM_SIZE];
        [WireInfo(ArraySize=16)]
        public byte[]       SessionKey = new byte[16];
        [WireInfo(ArraySize=XC_SERVICE_DIGEST_SIZE)]
        public byte[]       RawKeySignature = new byte[XC_SERVICE_DIGEST_SIZE];
        public uint         dwTicketLength;
        [WireInfo(ArraySize=XONLINE_MAX_TICKET_LENGTH)]
        public byte[]       Ticket = new byte[XONLINE_MAX_TICKET_LENGTH];
        [WireInfo(ArraySize=XONLINE_XE_MAX_BYTE_SERVICEIDS)]
        public uint[]       hrServiceBytes3 = new uint[XONLINE_XE_MAX_BYTE_SERVICEIDS]; // for the service id bytes (the first 32, the other 96 are later)
        [WireInfo(ArraySize=XONLINE_MAX_DWORD_SERVICEIDS)]
        public uint[]       hrServiceDwords3 = new uint[XONLINE_MAX_DWORD_SERVICEIDS]; // for the service id dwords (4)
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS*XONLINE_NUM_PRIVILEGE_DWORDS)]
        public uint[]       dwUserPrivileges = new uint[XONLINE_MAX_LOGON_USERS*XONLINE_NUM_PRIVILEGE_DWORDS];  // 4*8*4 bytes
        public uint         dwLiveTitleId;
        [WireInfo(ArraySize=XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID)]
        public byte[]       bAltServiceIds = new byte[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];
        [WireInfo(ArraySize=XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID)]
        public uint[]       dwAltServiceTitleIds = new uint[XONLINE_MAX_LIVE_ALTERNATE_TITLE_ID];

        [WireInfo(ArraySize=XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS)]
        public byte[]       bServiceID4 = new byte[XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS];  //the last 96 of them
        [WireInfo(ArraySize=XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS)]
        public uint[]       hrServiceBytes4 = new uint[XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS]; //the last 96 of them
        [WireInfo(ArraySize=XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS)]
        public ushort[]     wServicePortBytes4 = new ushort[XONLINE_XE_MAX_BYTE_SERVICEIDS_2-XONLINE_XE_MAX_BYTE_SERVICEIDS]; //the last 96
        [WireInfo(ArraySize=4)]
        public uint[]       UserPins = new uint[4];
        public ulong        FlowToken;
        public uint         ServiceAddressPreauthVersion;

        public ulong        ConsoleBanExpireTime;
        [WireInfo(ArraySize=4)]
        public ulong[]      UserBanExpireTime = new ulong[4];

        /// <summary>
        /// Helper function for compatibility
        /// </summary>
        /// <returns></returns>
        public XkdcResult GetXkdcResult()
        {
            int i = 0;
            int j = 0;

            XkdcResult sr = new XkdcResult();
            sr.ServiceHR = this.hr;
            sr.MachinePuid = this.MachineID;

            // Set user stuff
            Array.Copy(this.hrUser, sr.UserHRs, sr.UserHRs.Length);
            Array.Copy(this.dwUserFlags, sr.UserFlags, sr.UserFlags.Length);

            // Set service stuff
            sr.NumValidServices = 0;
            for (i = 0; i < XONLINE_XE_MAX_BYTE_SERVICEIDS_2; i++)
            {
                if (i<XONLINE_XE_MAX_BYTE_SERVICEIDS) //the first 32
                {
                    if (this.bServiceID3[i] != 0)
                    {
                        sr.ServiceHRs[j] = this.hrServiceBytes3[i];
                        sr.ServiceIDs[j] = this.bServiceID3[i];
                        sr.ServicePorts[j] = this.wServicePortBytes3[i];
                        if (sr.ServiceHRs[j] == 0)
                            sr.NumValidServices++;
                        j++;
                    }
                }
                else //the last 96
                {
                    if (this.bServiceID4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS] != 0)
                    {
                        sr.ServiceHRs[j] = this.hrServiceBytes4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS];
                        sr.ServiceIDs[j] = this.bServiceID4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS];
                        sr.ServicePorts[j] = this.wServicePortBytes4[i-XONLINE_XE_MAX_BYTE_SERVICEIDS];
                        if (sr.ServiceHRs[j] == 0)
                            sr.NumValidServices++;
                        j++;
                    }
                }
            }
            for (i = 0; i < XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                if (this.dwServiceID3[i] != 0)
                {
                    sr.ServiceHRs[j] = this.hrServiceDwords3[i];
                    sr.ServiceIDs[j] = this.dwServiceID3[i];
                    sr.ServicePorts[j] = this.wServicePortDwords3[i];
                    if (sr.ServiceHRs[j] == 0)
                        sr.NumValidServices++;
                    j++;
                }
            }
            // We can't use this.dwNumServices since it is for the request. The Xkdc doesn't actually
            // tell us how many services we got back (afaik), so we have to count them.
            sr.NumServices = j;

            // Set privilege stuff
            for (i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
            {
                for (j = 0; j < XONLINE_NUM_PRIVILEGE_DWORDS; j++)
                {
                    sr.Privileges[i,j] = this.dwUserPrivileges[i*XONLINE_NUM_PRIVILEGE_DWORDS + j];
                }
            }

            //
            sr.ServiceAddressPreauthVersion=ServiceAddressPreauthVersion;

            sr.ConsoleBanExpireTime=ConsoleBanExpireTime;
            for (i=0; i<4; ++i)
            {
                sr.UserBanExpireTime[i]=UserBanExpireTime[i];
            }

            return sr;
        }
    }

    public class ServiceContextXbox : WireData
    {
        public const int    XONLINE_MAX_LOGON_USERS             = 4;
        public const int    XONLINE_LEGACY_MAX_NUMBER_SERVICE   = 12;
        public const int    RESERVED_DWORDS_IN_XBOX_PA          = 8;
        public const int    KERBEROS_MAX_PRINCIPLE_NAME_SIZE    = 4 + 16 + 20 + 24 + 20;
        public const int    XONLINE_KERBEROSREALM_SIZE          = 24;
        public const int    XONLINE_USERDOMAIN_SIZE             = 20;
        public const int    XC_SERVICE_DIGEST_SIZE              = 20;
        public const int    XONLINE_MAX_TICKET_LENGTH           = 1024;

        public ulong        MachineID;
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public ulong[]      UserID = new ulong[XONLINE_MAX_LOGON_USERS];
        public uint         dwTitleID;
        public uint         dwTitleVersion;
        public uint         dwNumServices;
        [WireInfo(ArraySize=XONLINE_LEGACY_MAX_NUMBER_SERVICE)]
        public uint[]       dwServiceID1 = new uint[XONLINE_LEGACY_MAX_NUMBER_SERVICE];
        public ulong        StartTime;                  // TimeStamp
        public ulong        ExpirationTime;             // TimeStamp
        public uint         ctNumNonces;
        [WireInfo(ArraySize=8)]
        public uint[]       Nonce = new uint[8];
        [WireInfo(ArraySize=8)]
        public ulong[]      AuthenticatorTime = new ulong[8];       // TimeStamp
        public uint         hr;
        public XoKerbInfo   xoKerbInfo = new XoKerbInfo();
        public IpAddr       siteIPAddress = new IpAddr();
        public uint         dwBwLimit;
        [WireInfo(ArraySize=RESERVED_DWORDS_IN_XBOX_PA)]
        public uint[]       dwReserved = new uint[RESERVED_DWORDS_IN_XBOX_PA];
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public uint[]       hrUser = new uint[XONLINE_MAX_LOGON_USERS];
        [WireInfo(ArraySize=XONLINE_MAX_LOGON_USERS)]
        public uint[]       dwUserFlags = new uint[XONLINE_MAX_LOGON_USERS];
        [WireInfo(ArraySize=XONLINE_LEGACY_MAX_NUMBER_SERVICE)]            
        public uint[]       hrService1 = new uint[XONLINE_LEGACY_MAX_NUMBER_SERVICE];
        [WireInfo(ArraySize=XONLINE_LEGACY_MAX_NUMBER_SERVICE)]
        public ushort[]     wServicePort1 = new ushort[XONLINE_LEGACY_MAX_NUMBER_SERVICE];
        [WireInfo(ArraySize=KERBEROS_MAX_PRINCIPLE_NAME_SIZE)]
        public byte[]       ClientName = new byte[KERBEROS_MAX_PRINCIPLE_NAME_SIZE];
        [WireInfo(ArraySize=XONLINE_KERBEROSREALM_SIZE)]
        public byte[]       ClientRealm = new byte[XONLINE_KERBEROSREALM_SIZE];
        [WireInfo(ArraySize=XONLINE_KERBEROSREALM_SIZE)]
        public byte[]       ServiceRealm = new byte[XONLINE_KERBEROSREALM_SIZE];
        [WireInfo(ArraySize=16)]
        public byte[]       SessionKey = new byte[16];
        [WireInfo(ArraySize=XC_SERVICE_DIGEST_SIZE)]
        public byte[]       RawKeySignature = new byte[XC_SERVICE_DIGEST_SIZE];
        public uint         dwTicketLength;
        [WireInfo(ArraySize=XONLINE_MAX_TICKET_LENGTH)]
        public byte[]       Ticket = new byte[XONLINE_MAX_TICKET_LENGTH];

        /// <summary>
        /// Helper function for backwards compatibility
        /// </summary>
        /// <returns></returns>
        public XkdcResult GetXkdcResult()
        {
            int i = 0;

            XkdcResult sr = new XkdcResult();
            sr.ServiceHR = this.hr;
            sr.MachinePuid = this.MachineID;

            // Set user stuff
            Array.Copy(this.hrUser, sr.UserHRs, sr.UserHRs.Length);
            Array.Copy(this.dwUserFlags, sr.UserFlags, sr.UserFlags.Length);

            // Set service stuff
            for (i = 0; i < this.dwNumServices; i++)
            {
                sr.ServiceHRs[i] = this.hrService1[i];
                sr.ServiceIDs[i] = this.dwServiceID1[i];
                sr.ServicePorts[i] = this.wServicePort1[i];
                if (sr.ServiceHRs[i] == 0)
                    sr.NumValidServices++;
            }
            // this.dwNumServices is actually for the request, but since Xbox logins require
            // explicitly requesting services, this number should match what was returned.
            sr.NumServices = (int)this.dwNumServices;
            
            // No privileges for Xbox sign in

            return sr;
        }

    }

    #endregion

    // ConsolePublicKey
    // ConsoleCertificate
    #region Console certificates

    public class ConsolePublicKey : WireData
    {
        public const int    CONSOLE_PUBLIC_KEY_EXPONENT_SIZE   = 4;
        public const int    CONSOLE_PUBLIC_KEY_MODULUS_SIZE    = 128;

        //The public key
        [WireInfo(ArraySize=CONSOLE_PUBLIC_KEY_EXPONENT_SIZE)]
        public byte[]       PublicExp;
        [WireInfo(ArraySize=CONSOLE_PUBLIC_KEY_MODULUS_SIZE)]
        public byte[]       Modulus;

        //The csp blob representing both the private and public key pair.  If this is null then the public key is the default test console key.
        [WireInfo(Serialize=false)]
        public byte[]       CspBlob=null;

        //by default we use the same console test key pair always
        public ConsolePublicKey()
        {
            Initialize();
        }

        private ConsolePublicKey(bool init)
        {
            if (init)
            {
                Initialize();
            }
        }

        public void Initialize()
        {
            PublicExp = new byte[CONSOLE_PUBLIC_KEY_EXPONENT_SIZE]
                {
                    0x00,0x00,0x00,0x03
                };
            Modulus = new byte[CONSOLE_PUBLIC_KEY_MODULUS_SIZE]
                {
                    0x96,0x73,0x76,0xe4,0x6a,0xfd,0x3c,0x39,
                    0x58,0xad,0x2d,0xe6,0xc3,0x2b,0x96,0xb5,
                    0x97,0x05,0xdc,0x49,0x83,0x7e,0xe2,0xc8,
                    0xcc,0x45,0xd7,0x0d,0xd2,0x91,0x2d,0x2a,
                    0xdd,0x6c,0xee,0x4e,0x5c,0xc3,0xa4,0x19,
                    0xa7,0xc8,0xe0,0xa4,0x0a,0xf6,0xe9,0x4c,
                    0xce,0xbc,0xa7,0x1d,0xbb,0x0d,0x71,0x60,
                    0x5e,0xa5,0x96,0x26,0xa5,0x96,0x77,0x5b,
                    0x1f,0x12,0x3c,0x1f,0x93,0xef,0xde,0x66,
                    0xf0,0x6c,0x38,0x6c,0xbd,0xb3,0xcb,0x93,
                    0xac,0xab,0x76,0x78,0xfb,0x90,0xe9,0x84,
                    0x16,0x50,0x7a,0x8b,0x10,0xce,0x37,0xa2,
                    0x21,0xa6,0x22,0x06,0xde,0x31,0xaa,0x86,
                    0xd0,0x45,0x54,0x56,0x50,0x1c,0x3e,0x77,
                    0xf1,0xdf,0xa7,0xc8,0x7b,0xd8,0x45,0x51,
                    0xca,0x00,0x32,0x8a,0x9d,0x39,0x8f,0xf9
                };
        }

        //Generate a new random key.  NOTE: KerbClient can not handle any key except for default.  KdcClient does.
        public void GenerateRandomKey()
        {
            CspBlob=ConsoleKeys.GenerateConsoleKeyPairCspBlob(out PublicExp, out Modulus);

            //We have some weird endianness issues
            PublicExp=BYTESWAP32(PublicExp);
            Modulus=CopyAndByteSwap64(Modulus);
        }

        public byte[] CopyAndByteSwap64(byte []srcData)
        {
            if (srcData.Length%8!=0)
            {
                throw new System.Exception("srcData must be divisible by 8");
            }

            int qwordCount=srcData.Length/8;

            ulong []newData64=new ulong[qwordCount];
            System.Buffer.BlockCopy(srcData, 0, newData64, 0, srcData.Length);

            for(int i=0; i<qwordCount; ++i)
            {
                newData64[i]=BYTESWAP64(newData64[i]);
            }

            byte []newData8=new byte[qwordCount*8];
            System.Buffer.BlockCopy(newData64, 0, newData8, 0, qwordCount*8);
            return newData8;
        }

        public static byte[] BYTESWAP32(byte []srcData)
        {
            if (srcData.Length!=4)
            {
                throw new System.Exception("srcData must be length 4");
            }

            uint []data32=new uint[1];
            System.Buffer.BlockCopy(srcData, 0, data32, 0, 4);

            uint ret=ConsoleCertificate.BYTESWAP32(data32[0]);

            byte []data8=new byte[4];
            System.Buffer.BlockCopy(new uint[1]{ret}, 0, data8, 0, 4);
            return data8;
        }

        ulong BYTESWAP64(ulong data)
        {
            uint halfA=(uint)(data&0x00000000ffffffff);
            uint halfB=(uint)(data>>32);

            halfA=ConsoleCertificate.BYTESWAP32(halfA);
            halfB=ConsoleCertificate.BYTESWAP32(halfB);

            return (((ulong)halfA)<<32) | ((ulong)halfB);
        }

        //
        public ConsolePublicKey Clone()
        {
            ConsolePublicKey copy=new ConsolePublicKey(false);
            copy.PublicExp=(byte[])PublicExp.Clone();
            copy.Modulus=(byte[])Modulus.Clone();
            copy.CspBlob=(byte[])CspBlob.Clone();

            return copy;
        }

        public override string ToString()
        {
            return "ConsolePublicKey(PublicExp=0x"+ServerTestFramework.Utilities.Hexer.tohex(PublicExp)+" Modulus=0x"+ServerTestFramework.Utilities.Hexer.tohex(Modulus)+")";
        }
    }

    public class ConsoleCertificate : WireData
    {
        public const int    CONSOLE_ID_SIZE                     = 5;
        public const int    CONSOLE_CERT_PART_NUMBER_SIZE       = 11;
        public const int    CONSOLE_CERTIFICATE_RESERVED_SIZE   = 6;
        public const int    CONSOLE_CERTIFICATE_SIGNATURE_SIZE  = 256;

        // Devkits will have this bit set in the console type field
        public const uint   CONSOLE_TYPE_DEV                    = 0x00000001;

        // Retail boxes will have this bit set in the console type field
        public const uint   CONSOLE_TYPE_RETAIL                 = 0x00000002;

        // Testkits will have the 2nd most significant bit set. A testkit can be either
        // a dev or a retail box.
        public const uint   CONSOLE_TYPE_TESTKIT                = 0x40000000;

        // Test certificates (signed with the test master signing key) will have this bit
        // set in the console type field in the console certificate. The server doesn't 
        // really do much with this, though. If it can't use the real key, then it falls 
        // back to the test key anyway.
        public const uint   CONSOLE_TYPE_TEST_CERTIFICATE       = 0x80000000;

        //Types used for PC - there are only internal to the kdc, and aren't part of the request or response.
        public const uint PC_MACHINE_TYPE_NORMAL                = 0x00000000;  //default for normal PC machine accounts
        public const uint PC_MACHINE_TYPE_LIMITED               = 0x00000001;

        // Begin structure layout
        public ushort                   CertSize;               // Size of this structure (424, 0x01A8)
        [WireInfo(ArraySize=CONSOLE_ID_SIZE)]
        public byte[]                   ConsoleId;              // Uniquely ids console
        [WireInfo(ArraySize=CONSOLE_CERT_PART_NUMBER_SIZE)]
        public byte[]                   ConsolePartNumber;      // Identifies mfg part number
        [WireInfo(ArraySize=CONSOLE_CERTIFICATE_RESERVED_SIZE)]
        public byte[]                   Reserved;
        public uint                     ConsoleType;            // States whether console is a retail or dev/test kit
        public ulong                    ManufacturingDate;      // Date of mfg for console
        public ConsolePublicKey         ConsolePublicKey;       // Console's Public Key
        [WireInfo(ArraySize=CONSOLE_CERTIFICATE_SIGNATURE_SIZE)]
        public byte[]                   Signature; // RsaSign(MasterKey.Private, CertSize thru ConsolePublicKey)

        public static ushort BYTESWAP16(ushort us)
        {
            return (ushort)(((us >> 8) & 0x00FF) | ((us << 8) & 0xFF00));
        }

        public static uint BYTESWAP32(uint ui)
        {
            return (uint)(
                ((ui >> 24) & 0x000000FF) |
                ((ui >> 8)  & 0x0000FF00) |
                ((ui << 8)  & 0x00FF0000) |
                ((ui << 24) & 0xFF000000));
        }

        public bool IsTestkit
        {
            get { return (BYTESWAP32(ConsoleType) & CONSOLE_TYPE_TESTKIT) > 0; }
        }

        public bool IsDev
        {
            get { return (BYTESWAP32(ConsoleType) & CONSOLE_TYPE_DEV) > 0; }
        }

        public bool IsRetail
        {
            get { return (BYTESWAP32(ConsoleType) & CONSOLE_TYPE_RETAIL) > 0; }
        }

        public ConsoleCertificate()
        {
            Initialize();
        }

        public bool SetConsoleIdFromGamertag(string gamertag)
        {
            string gt = gamertag.ToLower();
            if (!gt.StartsWith("xe."))
                return false;
            if (gt.Length == 16 && !gt.EndsWith("\0"))
                return false;
            if (gt.Length < 15 || gt.Length > 16)
                return false;

            int chksum = 0;
            int digit = 0;
            long cid = 0;
            int i = 0;
            for (i = 3; i < gt.Length - 1; i++)
            {
                digit = gt[i] - '0';
                chksum += digit;
                cid = (cid * 10) + digit;
            }
            // Verify checksum
            digit = gt[i] - '0';
            if (digit != chksum % 10)
                return false;
            cid = (cid << 4) + digit;

            // Convert to 5-byte array
            byte[] bytes = BitConverter.GetBytes(cid);
            for (i = 0; i < this.ConsoleId.Length; i++)
            {
                this.ConsoleId[this.ConsoleId.Length - i - 1] = bytes[i];
            }

            return true;
        }

        public void SetConsoleType(uint type)
        {
            this.ConsoleType = BYTESWAP32(type);
        }

        public void SetConsoleTypeTest(uint type)
        {
            // OR with 0x80000000 to indicate a test certficate.  The difference:
            //   Real cert: everything is signed, including Signature field (all zeroes)
            //   Test cert: sign everything but the Signature field
            //this.ConsoleType = BYTESWAP32(type | CONSOLE_TYPE_TEST_CERTIFICATE);
            this.ConsoleType = BYTESWAP32(type);
        }

        public void Initialize()
        {
            // Defaults, from Xetestkeys.cpp in common\crypto\helperlib\
            // Don't forget to byteswap this.
            CertSize = BYTESWAP16(0x01A8);

            // Translates to XE.123456789016
            ConsoleId = new byte[CONSOLE_ID_SIZE]
                { 
                    0x2d,0xfd,0xc1,0xc3,0x56 
                };

            ConsolePartNumber = new byte[CONSOLE_CERT_PART_NUMBER_SIZE]
                {
                    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x00,0x00,0x00
                };

            Reserved = new byte[CONSOLE_CERTIFICATE_RESERVED_SIZE];

            // 1=devkit, 2=retail
            SetConsoleType(CONSOLE_TYPE_RETAIL);

            ManufacturingDate = 0x1c50a67ba37af69;
            ConsolePublicKey = new ConsolePublicKey();

            //If you want it signed correctly, call Sign yourself (kerbclient will normally sign it internally if you are using it)
            Signature = new byte[CONSOLE_CERTIFICATE_SIGNATURE_SIZE];
        }

        /// <summary> Computes the 20 byte SHA1 hash of the certificate, which is used as a secondary identifier along with console ID to uniquely identify an xbox360. </summary>
        public byte[] ComputeHash()
        {
            MemoryStream certBytesWithSignature=new MemoryStream();
            this.WriteStream(certBytesWithSignature);

            byte []certBytesNoSignature=certBytesWithSignature.ToArray();
            System.Array.Resize(ref certBytesNoSignature, certBytesNoSignature.Length-ConsoleCertificate.CONSOLE_CERTIFICATE_SIGNATURE_SIZE);

            System.Security.Cryptography.SHA1 sha=new System.Security.Cryptography.SHA1Managed();
            return sha.ComputeHash(certBytesNoSignature);
        }

        public void Sign()
        {
            //Sign it with the test master key.  Note that this process is slightly different than signing with the retail key.
            MemoryStream ms=new MemoryStream();
            WriteStream(ms);
            byte []bytes=ms.ToArray();
            System.Array.Resize(ref bytes, bytes.Length-CONSOLE_CERTIFICATE_SIGNATURE_SIZE);

            Signature=ConsoleKeys.GenerateCertificateSignature(bytes);
        }

        public override string ToString()
        {
            string s="";
            s+="ConsoleCertificate CertSize="+BYTESWAP16(CertSize);
            s+="\nConsoleCertificate ConsoleId(Compact)=0x"+ServerTestFramework.Utilities.Hexer.tohex(ConsoleId);
            s+="\nConsoleCertificate ConsolePartNumber=0x"+ServerTestFramework.Utilities.Hexer.tohex(ConsolePartNumber);
            s+="\nConsoleCertificate ReservedBytes=0x"+ServerTestFramework.Utilities.Hexer.tohex(Reserved);
            s+="\nConsoleCertificate ConsoleType=0x"+ServerTestFramework.Utilities.Hexer.tohex(ConsoleType);
            s+="\nConsoleCertificate ManufacturingDate="+ManufacturingDate+" ("+System.DateTime.FromFileTimeUtc((long)ManufacturingDate)+")";
            s+="\nConsoleCertificate ConsolePublicKey="+ConsolePublicKey;
            s+="\nConsoleCertificate Signature=0x"+ServerTestFramework.Utilities.Hexer.tohex(Signature);
            return s;
        }
    }

    #endregion

   
    // Needed for old XKDC tests, don't use this class for anything new.  See XeTitleInfo 
    // instead.
    public class TitleInfo
    {
        public TitleInfo(int ID, int ver, int reg)
        {
            TitleId = ID;
            Version = ver;
            Region = reg;
        }

        public TitleInfo(uint ID, uint ver, uint reg)
        {
            unchecked 
            {
                TitleId = (int)ID;
                Version = (int)ver;
                Region = (int)reg;
            }
        }

        public int TitleId = 0;
        public int Version = 0;
        public int Region = 0;
    }


    // -------------------------------------------------------------------------------- 
    // SecReg
    //
    // Stores keys related to XSP packets. Builds said keys from the key exchange 
    // information, and also provides the encryption & decryption routines.
    //
    // -------------------------------------------------------------------------------- 
    public class SecReg
    {
        public enum CipherType : uint
        {
            // Must match values in xcrypt.h for XC_SERVICE_*_CIPHER
            DES     = 0,
            DES3    = 1,
            AES     = 2,
            NULL    = 3
        }

        // Trim these to save memory?
        public uint         SpiRecv;        
        public uint         SpiXmit;     
        public byte[]       NonceInit;      // 8 bytes
        public byte[]       NonceResp;      // 8 bytes

        public byte[]       KeyShaRecv;     // 16 bytes
        public byte[]       KeyCryptRecv;   // up to 24 bytes
        public byte[]       IvRecv;         // 16 bytes
        
        public byte[]       KeyShaXmit;     // 16 bytes
        public byte[]       KeyCryptXmit;   // up to 24 bytes
        public byte[]       IvXmit;         // 16 bytes

        // Optional, but using pre-computed key tables will speed things up considerably 
        // for smaller packets, like 10%-30%.. but it takes up more memory if you are 
        // storing a lot of SecReg objects.
        public byte[]       KeyTableShaRecv;
        public byte[]       KeyTableShaXmit;
        public byte[]       KeyTableCryptRecv;
        public byte[]       KeyTableCryptXmit;

        public uint         KeyLength;
        
        public CipherType   Cipher
        {
            get 
            {
                return _Cipher;
            }
            set
            {
                _Cipher = value;
                KeyLength = GetKeyLengthFromCipher(_Cipher);
            }
        }

        public uint BlockSize
        {
            get
            {
                switch (_Cipher)
                {
                case CipherType.AES:
                case CipherType.NULL:
                    return 16;
                case CipherType.DES:
                case CipherType.DES3:
                default:
                    return 8;
                }
            }
        }

        public uint KeyTableSize
        {
            get 
            {
                switch (_Cipher)
                {
                case CipherType.AES:
                    return 364;
                case CipherType.NULL:
                    return 0;
                case CipherType.DES:
                    return 128;
                case CipherType.DES3:
                    return 384;
                default:
                    return 0;
                }
            }
        }


        private CipherType  _Cipher;

        public SecReg(bool fUseKeyTable)
        {
            Cipher = CipherType.DES3;
        }

        public SecReg(
            bool fUseKeyTable, 
            KeyExchangeResponsePacket Result, 
            byte[] ticketKey)
        {
            // Shortcuts
            KeyExchangeInitResponse Response = Result.keyexResp;
            
            Cipher = GetCipherTypeFromFlags(Response.Flags);

            BuildKeys(
                fUseKeyTable,
                Response.NonceInit, 
                Response.NonceResp, 
                (uint)Response.SpiInit, 
                (uint)Response.SpiResp,
                Result.keyexDhgy.DHGy, 
                ticketKey);
        }

        public SecReg(
            bool fUseKeyTable, 
            KeyExchangeTsResponsePacket Result, 
            byte[] ticketKey, 
            byte[] keyExchangeKey)
        {
            // Shortcuts
            KeyExchangeTsInitResponse Response = Result.keyexResp;

            Cipher = GetCipherTypeFromFlags(Response.Flags);

            BuildKeysTs(
                fUseKeyTable,
                Response.NonceInit, 
                Response.NonceResp, 
                (uint)Response.SpiInit, 
                (uint)Response.SpiResp,
                keyExchangeKey, 
                ticketKey);
        }

        public static CipherType GetCipherTypeFromFlags(short flags)
        {
            int bit_count = 0;
            CipherType ans = CipherType.DES3;

            // Get cipher from response
            if ((flags & KeyExchangeInitResponse.SXRF_ENCRYPT_AES) != 0)
            {
                ++bit_count;
                ans = CipherType.AES;
            }
            if ((flags & KeyExchangeInitResponse.SXRF_ENCRYPT_3DES) != 0)
            {
                ++bit_count;
                ans = CipherType.DES3;
            }
            if ((flags & KeyExchangeInitResponse.SXRF_ENCRYPT_DES) != 0)
            {
                ++bit_count;
                ans = CipherType.DES;
            }
            if ((flags & KeyExchangeInitResponse.SXRF_ENCRYPT_NULL) != 0)
            {
                ++bit_count;
                ans = CipherType.NULL;
            }
            
            if (bit_count == 0)
            {
                throw new Exception("Unknown encryption type in Flags in KeyExchangeResponse. Flags=0x" +
                                    flags.ToString("X4"));
            }

            if (bit_count > 1)
            {
                throw new Exception("Multiple encryption type bits set. Flags=0x" + flags.ToString("X4"));
            }

            return ans;
        }

        public static uint GetKeyLengthFromCipher(CipherType cipher)
        {
            switch (cipher)
            {
            case CipherType.DES:
                return 8;
            case CipherType.DES3:
                return 24;
            case CipherType.AES:
                return 16;
            case CipherType.NULL:
                return 0;
            }
            return 24;
        }

        private static string a2s(byte[] data)
        {
            if (data == null) 
                return "";
            StringBuilder sb = new StringBuilder(data.Length*2);
            for (int i = 0; i < data.Length; i++)
            {
                sb.Append(data[i].ToString("X2"));
            }
            return sb.ToString();
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("\nSecReg Xmit:\n");
            sb.AppendFormat("   NonceInit: 0x{0}\n", a2s(NonceInit));
            sb.AppendFormat("         Spi: 0x{0:X8}\n", SpiXmit);
            sb.AppendFormat("      KeySha: 0x{0}\n", a2s(KeyShaXmit));
            sb.AppendFormat("      KeyDes: 0x{0}\n", a2s(KeyCryptXmit));
            sb.AppendFormat("          Iv: 0x{0}\n", a2s(IvXmit));
            sb.AppendFormat("SecReg Recv:\n");
            sb.AppendFormat("   NonceResp: 0x{0}\n", a2s(NonceResp));
            sb.AppendFormat("         Spi: 0x{0:X8}\n", SpiRecv);
            sb.AppendFormat("      KeySha: 0x{0}\n", a2s(KeyShaRecv));
            sb.AppendFormat("      KeyDes: 0x{0}\n", a2s(KeyCryptRecv));
            sb.AppendFormat("          Iv: 0x{0}\n", a2s(IvRecv));
            sb.AppendFormat("Cipher    : {0}\n", Cipher);
            sb.AppendFormat("KeyLength : {0}\n", KeyLength);
            return sb.ToString();
        }


        private void BuildKeys(
            bool fUseKeyTable,
            byte[] nonceInit, 
            byte[] nonceResp, 
            uint spiInit, 
            uint spiResp,
            byte[] DHGy, 
            byte[] ticketKey)
        {
            this.NonceInit  = (byte[])nonceInit.Clone();
            this.NonceResp  = (byte[])nonceResp.Clone();
            this.SpiRecv    = spiResp;
            this.SpiXmit    = spiInit;
            
            if(NonceInit.Length != 8 || NonceResp.Length != 8)
                throw new Exception("Assert failed: (NonceInit.Length != 8 || NonceResp.Length != 8)");
            
            //our X would be 0x01010101....
            byte[] DHx = new byte[KC.k_dwDHKeySize];
            for (int i = 0; i < DHx.Length; i++)
            {
                DHx[i] = 1;
            }
 
            byte[] DHGxy = new byte[KC.k_dwDHKeySize];
            AuthClientBase.ComputeDHGXY(DHGxy, DHGy, DHx);

            MemoryStream keyStream = new MemoryStream(100);
            byte[] keyBlock = new byte[20];

            for(int i=0; i < 5; i++)
            {
                AuthClientBase.XcHmac4(ticketKey,       ticketKey.Length,
                                       DHGxy,           DHGxy.Length,
                                       NonceInit,       NonceInit.Length,
                                       NonceResp,       NonceResp.Length,
                                       null,            0,
                                       keyBlock,        keyBlock.Length);

                keyStream.Write(keyBlock, 0, keyBlock.Length);

                DHGxy[0] += 1;
            }

            keyStream.Seek(0, SeekOrigin.Begin);
            BinaryReader keyReader = new BinaryReader(keyStream);

            // Reverse Recv/Xmit order from SG
            if (BlockSize == 16)
            {
                KeyShaXmit   = keyReader.ReadBytes(16);
                KeyCryptXmit = keyReader.ReadBytes(16);
                KeyShaRecv   = keyReader.ReadBytes(16);
                KeyCryptRecv = keyReader.ReadBytes(16);
                IvXmit       = keyReader.ReadBytes(16);
                IvRecv       = keyReader.ReadBytes(16);
            }
            else
            {
                KeyShaXmit   = keyReader.ReadBytes(16);
                KeyCryptXmit = keyReader.ReadBytes(24);
                KeyShaRecv   = keyReader.ReadBytes(16);
                KeyCryptRecv = keyReader.ReadBytes(24);
                IvXmit       = keyReader.ReadBytes(8);
                IvRecv       = keyReader.ReadBytes(8);
            }

            if (Cipher == CipherType.DES || Cipher == CipherType.DES3)
            {
                AuthClientBase.XcDESKeyParity(KeyCryptXmit, KeyLength);
                AuthClientBase.XcDESKeyParity(KeyCryptRecv, KeyLength);
            }
        
            if (fUseKeyTable)
            {
                BuildKeyTables();
            }
        }
        
        private void BuildKeysTs(
            bool fUseKeyTable,
            byte[] nonceInit, 
            byte[] nonceResp, 
            uint spiInit, 
            uint spiResp,
            byte[] keyExchangeKey,
            byte[] ticketKey)
        {
            this.NonceInit = (byte[])nonceInit.Clone();
            this.NonceResp = (byte[])nonceResp.Clone();
            this.SpiRecv = spiResp;
            this.SpiXmit = spiInit;

            // set up title server keys
            // Hmac-Sha(Key-Exchange-Key, ticket-key | NonceInit | NonceResp)
            
            if(keyExchangeKey.Length != 16)
                throw new Exception("Assert failed: keyExchangeKey.Length != 16");

            if (NonceInit.Length != 8 || NonceResp.Length != 8)
                throw new Exception("Assert failed: (NonceInit.Length != 8 || NonceResp.Length != 8)");
            
            MemoryStream keyStream = new MemoryStream(100);
            byte[] keyBlock = new byte[20];
            byte[] clonedTicketKey = (byte[])ticketKey.Clone();
            byte clonedTickeKeyB0 = clonedTicketKey[0];

            for(int i=0; i < 5; i++)
            {
                AuthClientBase.XcHmac4(keyExchangeKey,  keyExchangeKey.Length,
                                       clonedTicketKey, clonedTicketKey.Length,
                                       NonceInit,       NonceInit.Length,
                                       NonceResp,       NonceResp.Length,
                                       null,            0,
                                       keyBlock,        keyBlock.Length);

                keyStream.Write(keyBlock, 0, keyBlock.Length);

                clonedTicketKey[0] += 1;
            }
            clonedTicketKey[0] = clonedTickeKeyB0;

            keyStream.Seek(0, SeekOrigin.Begin);
            BinaryReader keyReader = new BinaryReader(keyStream);

            // Reverse Recv/Xmit order from SG
            if (BlockSize == 16)
            {
                KeyShaXmit   = keyReader.ReadBytes(16);
                KeyCryptXmit = keyReader.ReadBytes(16);
                KeyShaRecv   = keyReader.ReadBytes(16);
                KeyCryptRecv = keyReader.ReadBytes(16);
                IvXmit       = keyReader.ReadBytes(16);
                IvRecv       = keyReader.ReadBytes(16);
            }
            else
            {
                KeyShaXmit   = keyReader.ReadBytes(16);
                KeyCryptXmit = keyReader.ReadBytes(24);
                KeyShaRecv   = keyReader.ReadBytes(16);
                KeyCryptRecv = keyReader.ReadBytes(24);
                IvXmit       = keyReader.ReadBytes(8);
                IvRecv       = keyReader.ReadBytes(8);
            }

            if (Cipher == CipherType.DES || Cipher == CipherType.DES3)
            {
                AuthClientBase.XcDESKeyParity(KeyCryptXmit, KeyLength);
                AuthClientBase.XcDESKeyParity(KeyCryptRecv, KeyLength);
            }
            
            if (fUseKeyTable)
            {
                BuildKeyTables();
            }
        }

        private void BuildKeyTables()
        {
            KeyTableShaXmit   = new byte[232];
            KeyTableShaRecv   = new byte[232];
            KeyTableCryptXmit = new byte[KeyTableSize];
            KeyTableCryptRecv = new byte[KeyTableSize];

            AuthClientBase.XcHMACMakeKeyTable(
                KeyShaXmit,
                (uint)KeyShaXmit.Length,
                KeyTableShaXmit);
            AuthClientBase.XcHMACMakeKeyTable(
                KeyShaRecv,
                (uint)KeyShaRecv.Length,
                KeyTableShaRecv);
            AuthClientBase.XcKeyTable(
                (uint)Cipher,
                KeyTableCryptXmit,
                KeyCryptXmit);
            AuthClientBase.XcKeyTable(
                (uint)Cipher,
                KeyTableCryptRecv,
                KeyCryptRecv);
        }

        // -------------------------------------------------------------------------------- 
        // CalcIvAtSeq
        //
        // Given an intial IV and a sequence numer, calculate a new IV. This will work for 
        // either DES (8 byte IV) or AES (16 byte IV) depending on the configured cipher 
        // type.
        // -------------------------------------------------------------------------------- 
        public byte[] CalcIvAtSeq(
            byte[]  ivInit,
            uint    seqNum)
        {
            byte[] ivCalc = new byte[BlockSize];
            CalcIvAtSeq_Helper(ivInit, 0, seqNum, ivCalc);

            if (BlockSize == 16)
            {
                CalcIvAtSeq_Helper(ivInit, 8, seqNum, ivCalc);
            }

            return ivCalc;
        }

        private void CalcIvAtSeq_Helper(
            byte[]  ivInit,
            uint    ivInitIndex,
            uint    seqNum,
            byte[]  ivCalc)
        {
            ulong ivInit1 = (ulong)BitConverter.ToUInt32(ivInit, (int)ivInitIndex);
            ulong ivInit2 = (ulong)BitConverter.ToUInt32(ivInit, (int)ivInitIndex + 4);
            ulong qw1 = ivInit1 * (ulong)seqNum;
            ulong qw2 = ivInit2 * (ulong)seqNum;
            byte[] qw1Bytes = BitConverter.GetBytes(qw1);
            byte[] qw2Bytes = BitConverter.GetBytes(qw2);

            uint ivCalc1 = BitConverter.ToUInt32(qw1Bytes, 0) ^ BitConverter.ToUInt32(qw2Bytes, 4);
            uint ivCalc2 = BitConverter.ToUInt32(qw1Bytes, 4) ^ BitConverter.ToUInt32(qw2Bytes, 0);

            BinaryWriter bw = new BinaryWriter(new MemoryStream(ivCalc));
            bw.BaseStream.Position = ivInitIndex;
            bw.Write(ivCalc1);
            bw.Write(ivCalc2);
        }
            

        // -------------------------------------------------------------------------------- 
        // Crypt
        //
        // Mainline wrapper.
        // -------------------------------------------------------------------------------- 
        public void Crypt(
            bool    fXmit,
            byte[]  iv,
            byte[]  pb1, int cb1)
        {
            Crypt(fXmit, iv, pb1, (uint)cb1, null, 0);
        }


        // ------------------------------------------------------------------------------- 
        // Crypt 
        //
        // Uses appropriate cipher to encrypt 1 or 2 chunks of data. pb2 may be null. If 
        // fXmit is true, use xmit keys and encrypt operation. If fXmit is false, use recv 
        // keys and decrypt operation.
        // -------------------------------------------------------------------------------- 
        public void Crypt(
            bool    fXmit,
            byte[]  iv,
            byte[]  pb1, uint    cb1,
            byte[]  pb2, uint    cb2)
        {
            byte[] keys = (fXmit) ? KeyTableCryptXmit : KeyTableCryptRecv;
            uint op = (fXmit) ? AuthClientBase.XC_SERVICE_ENCRYPT : AuthClientBase.XC_SERVICE_DECRYPT;

            if (keys != null)
            {
                AuthClientBase.XcCryptWithKeyTable(
                    op,
                    keys, KeyLength, 
                    iv, 
                    pb1, cb1,
                    pb2, cb2);
            }
            else
            {
                // slower
                keys = (fXmit) ? KeyCryptXmit : KeyCryptRecv;
                AuthClientBase.XcCrypt(
                    op,
                    keys, KeyLength, 
                    iv, 
                    pb1, cb1,
                    pb2, cb2);
            }
        }

        // ------------------------------------------------------------------------------- 
        // CryptUnsafe
        //
        // Uses appropriate cipher to encrypt 1 or 2 chunks of data. pb2 may be null. If 
        // fXmit is true, use xmit keys and encrypt operation. If fXmit is false, use recv 
        // keys and decrypt operation.
        // -------------------------------------------------------------------------------- 
        unsafe public void CryptUnsafe(
            bool    fXmit,
            byte[]  iv,
            byte *  pb1, uint    cb1,
            byte *  pb2, uint    cb2)
        {
            byte[] keys = (fXmit) ? KeyTableCryptXmit : KeyTableCryptRecv;
            uint op = (fXmit) ? AuthClientBase.XC_SERVICE_ENCRYPT : AuthClientBase.XC_SERVICE_DECRYPT;

            if (keys != null)
            {
                AuthClientBase.XcCryptWithKeyTableUnsafe(
                    op,
                    keys, KeyLength, 
                    iv, 
                    pb1, cb1,
                    pb2, cb2);
            }
            else
            {
                // slower
                keys = (fXmit) ? KeyCryptXmit : KeyCryptRecv;
                AuthClientBase.XcCryptUnsafe(
                    op,
                    keys, KeyLength, 
                    iv, 
                    pb1, cb1,
                    pb2, cb2);
            }
        }


        // ------------------------------------------------------------------------------- 
        // CryptWithCipher 
        //
        // Uses appropriate cipher to encrypt 1 or 2 chunks of data. pb2 may be null. If 
        // fXmit is true, use xmit keys and encrypt operation. If fXmit is false, use recv 
        // keys and decrypt operation.
        //
        // This is sort of an "out of band" operation, so don't use any precomputed key 
        // tables.
        // -------------------------------------------------------------------------------- 
        public void CryptWithCipher(
            bool        fXmit,
            CipherType  cipher,
            byte[]      iv,
            byte[]      pb1, uint    cb1,
            byte[]      pb2, uint    cb2)
        {
            uint   keyLen = GetKeyLengthFromCipher(cipher);
            byte[] keys = (fXmit) ? KeyCryptXmit : KeyCryptRecv;
            uint   op = (fXmit) ? AuthClientBase.XC_SERVICE_ENCRYPT : AuthClientBase.XC_SERVICE_DECRYPT;

            AuthClientBase.XcCrypt(
                op,
                keys, keyLen,  // override
                iv, 
                pb1, cb1,
                pb2, cb2);
        }


        // -------------------------------------------------------------------------------- 
        // Hmac 
        //
        // Generates a digest for up to 4 inputs. If fXmit is true, use xmit keys. If 
        // fXmit is false, use recv keys.
        // -------------------------------------------------------------------------------- 
        public void Hmac(
            bool   fXmit,
            byte[] pb1, uint cb1,
            byte[] pb2, uint cb2,
            byte[] pb3, uint cb3,
            byte[] pb4, uint cb4,
            byte[] hmac, uint cbHmac)
        {
            byte[] keys = (fXmit) ? KeyTableShaXmit : KeyTableShaRecv;
            if (keys != null)
            {
                AuthClientBase.XcHmac4WithKeyTable(
                    keys,
                    pb1, (int)cb1,
                    pb2, (int)cb2,
                    pb3, (int)cb3,
                    pb4, (int)cb4,
                    hmac, (int)cbHmac);
            }
            else
            {
                keys = (fXmit) ? KeyShaXmit : KeyShaRecv;
                AuthClientBase.XcHmac4(
                    keys, keys.Length,
                    pb1, (int)cb1,
                    pb2, (int)cb2,
                    pb3, (int)cb3,
                    pb4, (int)cb4,
                    hmac, (int)cbHmac);
            }
        }


        // -------------------------------------------------------------------------------- 
        // HmacUnsafe 
        //
        // Generates a digest for up to 4 inputs. If fXmit is true, use xmit keys. If 
        // fXmit is false, use recv keys.
        // -------------------------------------------------------------------------------- 
        unsafe public void HmacUnsafe(
            bool   fXmit,
            byte * pb1, uint cb1,
            byte * pb2, uint cb2,
            byte * pb3, uint cb3,
            byte * pb4, uint cb4,
            byte[] hmac, uint cbHmac)
        {
            byte[] keys = (fXmit) ? KeyTableShaXmit : KeyTableShaRecv;
            if (keys != null)
            {
                AuthClientBase.XcHmac4WithKeyTableUnsafe(
                    keys,
                    pb1, (int)cb1,
                    pb2, (int)cb2,
                    pb3, (int)cb3,
                    pb4, (int)cb4,
                    hmac, (int)cbHmac);
            }
            else
            {
                keys = (fXmit) ? KeyShaXmit : KeyShaRecv;
                AuthClientBase.XcHmac4Unsafe(
                    keys, keys.Length,
                    pb1, (int)cb1,
                    pb2, (int)cb2,
                    pb3, (int)cb3,
                    pb4, (int)cb4,
                    hmac, (int)cbHmac);
            }
        }



    };

    //kdc preauth types
    public class PreAuthType
    {
        //from kerbclient.h
        public const uint KRB5_PADATA_NONE                = 0;
        public const uint KRB5_PADATA_AP_REQ              = 1;
        public const uint KRB5_PADATA_TGS_REQ             = KRB5_PADATA_AP_REQ;
        public const uint KRB5_PADATA_ENC_TIMESTAMP       = 2;
        public const uint KRB5_PADATA_PW_SALT             = 3;
        public const uint KRB5_PADATA_ENC_UNIX_TIME       = 5;  // timestamp encrypted in key
        public const uint KRB5_PADATA_ENC_SANDIA_SECURID  = 6;  // SecurId passcode
        public const uint KRB5_PADATA_SESAME              = 7;  // Sesame project
        public const uint KRB5_PADATA_OSF_DCE             = 8;  // OSF DCE
        public const uint KRB5_CYBERSAFE_SECUREID         = 9;  // Cybersafe
        public const uint KRB5_PADATA_AFS3_SALT           = 10; // Cygnus
        public const uint KRB5_PADATA_ETYPE_INFO          = 11; // Etype info for preauth
        public const uint KRB5_PADATA_SAM_CHALLENGE       = 12; // draft challenge system
        public const uint KRB5_PADATA_SAM_RESPONSE        = 13; // draft challenge system response
        public const uint KRB5_PADATA_PK_AS_REQ           = 14; // pkinit
        public const uint KRB5_PADATA_PK_AS_REP           = 15; // pkinit
        public const uint KRB5_PADATA_PK_AS_SIGN          = 16; // pkinit
        public const uint KRB5_PADATA_PK_KEY_REQ          = 17; // pkinit
        public const uint KRB5_PADATA_PK_KEY_REP          = 18; // pkinit
        public const uint KRB5_PADATA_REFERRAL_INFO       = 20; // referral names for canonicalization
        public const uint KRB5_PADATA_PAC_REQUEST         = 128; // allow client to request or ignore PAC
        public const uint KRB5_PADATA_S4U                 = 129; // S4U
        public const uint KRB5_PADATA_COMPOUND_IDENTITY   = 130; // authenticate multiple identities
        public const uint KRB5_PADATA_PAC_REQUEST_EX      = 131; // allow client to request or ignore PAC or specify what sections
        public const uint KRB5_PADATA_CLIENT_VERSION      = 132; // allow client to report version info

        //from Xonlinep.h
        public const uint KRB5_PADATA_XBOX_SERVICE_REQUEST    = 201; // contains both versions (v1 and v2) of an xbox1 xkdc request
        public const uint KRB5_PADATA_XBOX_SERVICE_ADDRESS    = 202; // containts both versions (v1 and v2) of on xbox1 xkdc reply
        public const uint KRB5_PADATA_XBOX_ACCOUNT_CREATION   = 203; // xbox1 machine account creation
        public const uint KRB5_PADATA_XBOX_PPA                = 204; // some hashes used for early anti-dos protection
        public const uint KRB5_PADATA_XBOX_ECHO               = 205; // forces a client to retry to prove they originate at the IP the request came from
        public const uint KRB5_PADATA_XBOX_CLIENT_VERSION     = 206; // signed client version info (not currently used)
        public const uint KRB5_PADATA_XENON_MAC_REQUEST       = 209; // xbox360 machine account creation
        public const uint KRB5_PADATA_XENON_SERVICE_REQUEST2  = 210; // contains an xbox360 xkdc request (v4 only)
        public const uint KRB5_PADATA_XENON_SERVICE_ADDRESS2  = 211; // contains an xbox360 xkdc reply (v4 only)
        public const uint KRB5_PADATA_PC_ACCOUNT_CREATION     = 212; // pc machine account creation
        public const uint KRB5_PADATA_PASSPORT_AUTHENTICATION = 213; // passport user authentication
        public const uint KRB5_PADATA_XENON_SERVICE_REQUEST3  = 214; // contains an xbox360 xkdc request (v5 only), introduced in 2010
        public const uint KRB5_PADATA_XENON_SERVICE_ADDRESS3  = 215; // contains an xbox360 xkdc request (v5 only), introduced in 2010
        public const uint KRB5_PADATA_XENON_PPA               = 216; // used for duplicate console id separation in xmacs/askdc
        public const uint KRB5_PADATA_XENON_SERVICE_ADDRESS_FAILURE = 217; //when a service request 3 with version 6 or higher is sent up, this will be returned instead of service address in the case of a failed hr
        public const uint KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION = 218; //similar to KRB5_PADATA_PASSPORT_AUTHENTICATION except the ticket is encrypted with the user's key
        public const uint KRB5_PADATA_XENON_MAC_REQUEST2      = 219; // updated xbox360 machine account creation (with Serial Number)
        public const uint KRB5_PADATA_PC_ACCOUNT_CREATION2    = 220; // pc2 machine account creation

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\LspClient.cs ===
using System;
using System.Net;
using System.Text;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections;
using ServerTestFramework.Utilities;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary>
    /// Custom LSP exception so we can catch() more explicitly
    /// </summary>
    public class LSPException : Exception
    {
        public LSPException(string message) : base(message) 
        { 
            if (Global.RO != null)
                Global.RO.Error(message); 
        }
        public LSPException(string format, params object[] args) : base(String.Format(format, args)) 
        { 
            if (Global.RO != null)
                Global.RO.Error(format, args); 
        }
    }


    public class LspClient : SgClient
    {
        // Used to be in AuthContext, but really belong here as nothing else
        // outside of LspClient needs access to them.  Only used for the 
        // SignInLSPWithTSKey() call.  SignInLSP() uses the regular SG key
        // exchange protocol.
        public KeyExchangeTsRequestPacket TsKeyexRequest        = null;     // set before SG sign in (key exchange)
        public KeyExchangeTsResponsePacket TsKeyexResult        = null;     // set after SG sign in (key exchange)

        public override uint SPI
        {
            get 
            {
                if (this.TsKeyexRequest == null || this.TsKeyexRequest.keyexInit == null)
                {
                    // It may be this LSP client actually signed in with SignInSg(), using 
                    // the old key exchange method. Let's return that one here, which 
                    // should still return 0 if the client hasn't signed in at all.
                    return base.SPI;
                }
                else
                {
                    return this.TsKeyexRequest.keyexInit.SpiInit & XspHeader.XSP_SPI_MASK;
                }
            }
        }

        // Note: no SGADDR in a TS key exchange response


        /// <summary>
        /// LSP constructor.
        /// </summary>
        /// <param name="ctx">AuthContext state</param>
        /// <param name="ip">IP address of the LSP server. May be null.</param>
        /// <param name="manualSetup">If false, use default values. If true, user will set all values.</param>
        public LspClient(AuthContext ctx, IPEndPoint ip, bool manualSetup)
            : base(ctx, ip, manualSetup)
        {
            Initialize(ctx);
        }

        public LspClient(AuthContext ctx)
            : base(ctx, null, false)
        {
            Initialize(ctx);
        }


        /// <summary>
        /// Common constructor code to intialize various members and member of AuthContext
        /// </summary>
        protected override void Initialize(AuthContext ctx)
        {
            base.Initialize(ctx);

            // Set special TS key exchange structures
            TsKeyexRequest = null;
            TsKeyexResult = null;

            ctx.IsLspContext = true;
        }

        /// <summary>
        /// Reset everything to valid default values. You should be able to sign in with 
        /// just these values.  Think of this as the most basic, simple, valid request possible.
        /// </summary>
        public new static void SetDefaults(AuthContext ctx)
        {
            if (ctx.Site == null)
            {
                ctx.Site = SiteInfoManager.GetDefaultLspSite();
            }
            SgClient.SetDefaults(ctx);

            ctx.IsLspContext = true;
        }

        
        // SignOutLSP
        // SignInLSP
        // SignInLSPWithTSKey
        // SimpleVerify
        #region SignIn, SignOut, Verify

        /// <summary>
        /// Sign out of the LSPSG.
        /// </summary>
        public void SignOutLSP()
        {
            base.SignOutSG();
        }

        /// <summary>
        /// Do the key exchange with the LSPSG and store the keys.
        /// </summary>
        public void SignInLSP() 
        { 
            // Set defaults if necessary
            if (!isManualSetup)
            {
                SetDefaults(authContext);
            }
            
            // Populate authdata and build a fake TGS ticket
            if (!authContext.IsSignedInXkdc)
            {
                FakeSignInXkdc();
            }

            // That's all of the custom stuff we need to do.  Use the base method now.
            base.SignInSG();
        }

        public void SignInLSPWithTSKey()
        {
            isSignedIn = false;

            // Set defaults if necessary
            if (!isManualSetup)
            {
                SetDefaults(authContext);
            }

            // Populate authdata and build a fake TGS ticket
            if (!authContext.IsSignedInXkdc)
            {
                FakeSignInXkdc();
            }

            // Overridden ip address from the site info?
            if (authContext.Site.siteIp != null)
            {
                this.ipServer = authContext.Site.siteIp;
            }

            // Set request packet
            if (TsKeyexRequest == null)
            {
                TsKeyexRequest = new KeyExchangeTsRequestPacket();
            }
            else
            {
                TsKeyexRequest.Reset();
            }

            // Set XnKid BEFORE building AP authenticator
            TsKeyexRequest.keyexInit.Xnkid = authContext.Site.tsXnKid;
            
            // Build AP
            // This must be done for every key exchange packet that is sent, or 
            // else the SG logs event #50052,  
            // EVENT_SG_REPLAYED_KERBEROS_AUTHENTICATOR.
            byte[] apData = BuildTsAP();

            // Assign result to the KeyexRequest packet
            TsKeyexRequest.keyexAPReq.Data = apData;

            // Send and receive
            lastSendTime = DateTime.Now;
            packet = (byte[])TsKeyexRequest;
            packetLength = packet.Length;

            // Split the send and receive so we can better control the receive.
            Send();

            // Recv it.  We might be sharing the socket, so keep retrying up to 
            // the timeout period.
            DateTime starttime = DateTime.Now;
            bool gotReply = false;
            int packetCount = 0;
            while ((DateTime.Now - starttime).TotalMilliseconds < TimeoutInMs && !gotReply)
            {
                Recv(TimeoutInMs);
                packetCount++;
                if (packetRecv == null)
                {
                    // TODO: warning, make sure this TGT gets cleaned up
                    throw new ServerTestFramework.Utilities.TimeoutException(String.Format("{0} -> {1}/{2} timed out in {3}ms", authContext.Udp.LocalIP.ToString(), authContext.Site.serverName, ipServer.ToString(), TimeoutInMs));
                }
                else if (packetRecvLength > 6)
                {
                    // Bytes 0-3 are the SPI
                    uint spi = (uint)(packetRecv[0] + (packetRecv[1] << 8) + (packetRecv[2] << 16) + (packetRecv[3] << 24));
                    short type = (short)(packetRecv[4] + (packetRecv[5] << 8));
                    if (spi == TsKeyexRequest.SPI && type == KeyExchangeHeader.KEYEX_TYPE_TSTOXB_RESP)
                    {
                        gotReply = true;
                    }
                    else if (type == KeyExchangeHeader.KEYEX_TYPE_TSTOXB_RESP)
                    {
                        Global.RO.Warn("LspSignIn: Got TS keyexchange reply, but spi doesn't match (got 0x{0:X}, expected 0x{1:X})", spi, TsKeyexRequest.SPI);
                    }
                    else if (type == KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP)
                    {
                        Global.RO.Warn("LspSignIn: Got regular keyexchange reply, but spi doesn't match (got 0x{0:X}, expected 0x{1:X})", spi, TsKeyexRequest.SPI);
                    }
                    else
                    {
                        //Global.RO.Debug("LspSignIn: Got [{0}] unknown packet of length {1}", packetCount, packetRecvLength);
                    }
                }
            }

            if (!gotReply)
            {
                throw new ServerTestFramework.Utilities.TimeoutException(String.Format("SG timed out after receiving {0} non-keyex-response packets", packetCount));
            }

            lastRecvTime = DateTime.Now;

            // Process it
            if (TsKeyexResult == null)
            {
                TsKeyexResult = new KeyExchangeTsResponsePacket(TsKeyexRequest.SPI);
            }
            TsKeyexResult.ReadBytes(packetRecv, packetRecvLength);


            // Have to reset the receive sequence number, otherwise we'll decrypt with the wrong IV and get
            // garbage packets.
            SequenceRecv = 1;
            SequenceXmit = 1;

            // Valid reply?
            if (bVerifyKeyEx)
            {
                SimpleVerifyTs();
            }

            // Save original port and spi for safety checks
            //OriginalPort = NetConstants.HTONS((ushort)KeyexResult.keyexResp.PortInit);  // flip bytes
            OriginalSpi = (uint)TsKeyexResult.keyexResp.SpiResp;

            // Send heartbeat back to acknowledge
            this.SendDataPulse();

            isSignedIn = true;
        }
        
        /// <summary>
        /// Build the Kerberos AP portion of the key exchange request packet
        /// </summary>
        /// <returns></returns>
        protected byte[] BuildTsAP()
        {
            long APTime;
            byte[] pb = new byte[1500];
            int cb = (int)pb.Length;

            // Compute SHA of pre-AP data
            byte[] sha      = new byte[k_Sha_Digest_Len];
            byte[] key      = authContext.GetSessionKey();
            byte[] data     = (byte[]) TsKeyexRequest.keyexInit;
            
            AuthClientBase.XcHmac4(
                key,                        key.Length,
                data,                       data.Length,
                null,                       0,
                null,                       0,
                null,                       0,
                sha,                        sha.Length);
            
            try
            {
                if (authContext.IsXenonTitle || authContext.IsPanorama)
                {
                    byte[] bytesServiceCtx = (byte[])authContext.ServiceCtxXe;
                    AuthClientBase.DLL_BuildAp(
                        bytesServiceCtx, 
                        out APTime,
                        sha,
                        k_Sha_Digest_Len,
                        pb,
                        out cb);
                }
                else
                {
                    byte[] bytesServiceCtx = (byte[])authContext.ServiceCtxXbox;
                    AuthClientBase.DLL_BuildAp(
                        bytesServiceCtx, 
                        out APTime,
                        sha,
                        k_Sha_Digest_Len,
                        pb,
                        out cb);
                }
            }
            finally
            {
                SpewKerbclientDebug();
            }

            byte[] returnPacket = new byte[cb];
            Array.Copy(pb, returnPacket, cb);

            return returnPacket;
        }


        /// <summary>
        /// Quickly verify that the key exchange succeeded
        /// </summary>
        /// <param name="result"></param>
        public void SimpleVerifyTs()
        {
            // Verify authContext.KeyexResult for null
            if (TsKeyexResult == null)
            {
                throw new SGNoReplyException("KeyexResult is null, expected a value");
            }

            // Verify packet return type
            if (TsKeyexResult.keyexResp.Type != KeyExchangeHeader.KEYEX_TYPE_TSTOXB_RESP)
            {
                throw new SGException("Incorrect packet type in key exchange response, type={0}", TsKeyexResult.keyexResp.Type);
            }

            // Verify nonce
            byte[] nonce1 = TsKeyexRequest.keyexInit.NonceInit;
            byte[] nonce2 = TsKeyexResult.keyexResp.NonceInit;
            for (int i = 0; i < nonce1.Length; i++)
            {
                if (nonce1[i] != nonce2[i])
                {
                    throw new SGException("Nonce mismatch in KeyExchange response");
                }
            }

            // Verify SPI
            if (TsKeyexRequest.SPI != TsKeyexResult.SPI)
            {
                throw new SGException("SPI mismatch in KeyExchange response, RequestSPI=0x{0:X}, ResponseSPI=0x{1:X}", TsKeyexRequest.SPI, TsKeyexResult.SPI);
            }

            // Key exchange looks good, store the keys
            authContext.SecKeys = new SecReg(true, TsKeyexResult, authContext.GetSessionKey(), authContext.Site.tsKeyExchangeKey );
        }
        
        #endregion

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\ServiceKeys.cs ===
using ServerTestFramework.Database;

namespace ServerTestFramework.LiveService.Auth
{
    public static class ServiceKeys
    {
        public const int Key_KdcPassportNet=1;
        public const int Key_KdcXboxCom=2;
        public const int Key_KEK=5;
        public const int Key_SG=6;
        public const int Key_SignatureServer=7;
        public const int Key_AskdcEcho=9;
        public const int Key_WiredataPrivate=12;
        public const int Key_WiredataPublic=13;
        public const int Key_XAuthdata=18;

        /// <summary> Retrieves a key matching keyType.  If there are more than one key of the specified type, this will throw. </summary>
        public static byte[] GetServiceKey(int keyType)
        {
            return GetServiceKey(keyType, null, null);
        }

        /// <summary> Retrieves a service key matching keyType and serviceData.  If serviceData are null they are not used for matching.  If there are more than one matching keys, this will throw. </summary>
        public static byte[] GetServiceKey(int keyType, string serviceData1, string serviceData2)
        {
            byte []key=null;
            if (TryGetServiceKeyFromKnownList(keyType, out key, serviceData1, serviceData2))
            {
                return key;
            }

            if (TryGetServiceKeyFromCache(keyType, out key, serviceData1, serviceData2))
            {
                return key;
            }

            if (TryGetServiceKeyFromDb(keyType, out key, ref serviceData1, ref serviceData2))
            {
                StoreServiceKeyInCache(keyType, key, serviceData1, serviceData2);
                return key;
            }

            throw new System.Exception("ServiceKey "+keyType+" does not exist.");
        }

        //cache
        private static bool TryGetServiceKeyFromCache(int keyType, out byte []key, string serviceData1, string serviceData2)
        {
            string env=Global.XEnv.GetEnv();
            KeyKey keyKey=new KeyKey(env, keyType, serviceData1, serviceData2);

            lock (keyCacheLock)
            {
                if (keyCache.ContainsKey(keyKey))
                {
                    key=keyCache[keyKey];
                    return true;
                }
            }

            key=null;
            return false;
        }

        private static void StoreServiceKeyInCache(int keyType, byte []key, string serviceData1, string serviceData2)
        {
            string env=Global.XEnv.GetEnv();
            KeyKey keyKey=new KeyKey(env, keyType, serviceData1, serviceData2);

            lock (keyCacheLock)
            {
                keyCache[keyKey]=key;
            }
        }

        private class KeyKey: System.IEquatable<KeyKey>
        {
            public string Environment;
            public int KeyType;
            public string ServiceData1;
            public string ServiceData2;

            public KeyKey()
            {
            }

            public KeyKey(string env, int keyType, string serviceData1, string serviceData2)
            {
                Environment=env;
                KeyType=keyType;
                ServiceData1=serviceData1;
                ServiceData2=serviceData2;
            }

            public bool Equals(KeyKey other)
            {
                return Environment==other.Environment &&
                    KeyType==other.KeyType &&
                    ServiceData1==other.ServiceData1 &&
                    ServiceData2==other.ServiceData2;
            }

            public override int GetHashCode()
            {
                int h=KeyType.GetHashCode();
                if (Environment!=null)
                {
                    h^=Environment.GetHashCode();
                }
                if (ServiceData1!=null)
                {
                    h^=ServiceData1.GetHashCode();
                }
                if (ServiceData2!=null)
                {
                    h^=ServiceData2.GetHashCode();
                }
                return h;
            }
        }

        private static object keyCacheLock=new object();
        private static System.Collections.Generic.Dictionary<KeyKey, byte[]> keyCache=new System.Collections.Generic.Dictionary<KeyKey, byte[]>();

        //db
        private static bool TryGetServiceKeyFromDb(int keyType, out byte []key, ref string serviceData1, ref string serviceData2)
        {
            //read from db
            string query="select vc_service_data1, vc_service_data2, bin_key, i_master_key_version from t_service_keys where i_key_type="+keyType;
            if (serviceData1!=null)
            {
                query+=" and vc_service_data1='"+QueryGenerator.EscapeString(serviceData1)+"'";
            }
            if (serviceData2!=null)
            {
                query+=" and vc_service_data2='"+QueryGenerator.EscapeString(serviceData2)+"'";
            }
            query+=" and vc_environment='"+Global.XEnv.GetEnv()+"'";

            int masterKeyVersion;
            byte []encKey;
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                System.Data.SqlClient.SqlDataReader reader;
                npdb.ReadData(query, out reader);
                using (reader)
                {
                    if (!reader.Read())
                    {
                        key=null;
                        return false;
                    }

                    serviceData1=(string)reader[0];
                    serviceData2=(string)reader[1];
                    encKey=(byte[])reader[2];
                    masterKeyVersion=(int)reader[3];

                    if (reader.Read())
                    {
                        throw new System.Exception("Multiple service keys found for query: "+query);
                    }
                }

            }

            //decrypt with master key
            using (xonline.common.service.MasterKey masterKey=new xonline.common.service.MasterKey(masterKeyVersion))
            {
                key=masterKey.Decrypt(encKey);
            }

            return true;
        }

        //pre-populated data
        private static bool warnedAboutKnownKeyUsage=false;

        private static bool TryGetServiceKeyFromKnownList(int keyType, out byte []key, string serviceData1, string serviceData2)
        {
            string lowerEnvName=Global.XEnv.GetEnv().ToLower();
            bool isTestNetKey=lowerEnvName.Contains("testnet") || lowerEnvName.Contains("autonet") || lowerEnvName.Contains("stress") || lowerEnvName=="bvtnet" || lowerEnvName=="corenet" || Global.CurrentEnvironment.IsXblob || !Global.IsEnvironmentInternal;

            if (!warnedAboutKnownKeyUsage && isTestNetKey)
            {
                warnedAboutKnownKeyUsage=true;
                Global.RO.Debug("Using already-known testnet service keys when able.");
            }

            if (keyType==Key_KdcPassportNet)
            {
                if (isTestNetKey)
                {
                    key=ServerTestFramework.Utilities.Hexer.unhex("0x055555F71AFB0D5CDB5DC64BFCB7D751");
                    return true;
                }
            }
            else if (keyType==Key_KdcXboxCom)
            {
                if (isTestNetKey)
                {
                    key=new byte[16]{0xAF, 0xB0, 0xD5, 0xF7, 0x1A, 0xFB, 0x0D, 0x5C, 0xDC, 0xB7, 0xD6, 0x4B, 0xFC, 0xB7, 0xD7, 0x51};
                    return true;
                }
            }
            else if (keyType==Key_SG)
            {
                if (isTestNetKey)
                {
                    key=new byte[16]{0x38, 0xab, 0x83, 0xbd, 0x2f, 0xf5, 0x54, 0x68, 0xeb, 0xe9, 0x2d, 0x0a, 0x56, 0x46, 0x43, 0x8e};
                    return true;
                }
            }
            else if (keyType==Key_AskdcEcho)
            {
                if (isTestNetKey)
                {
                    key=new byte[32]{0x13, 0x27, 0x29, 0xB4, 0x94, 0x88, 0x41, 0x53, 0x29, 0xF6, 0xD4, 0x1C, 0xD1, 0x18, 0x77, 0x94, 0xA1, 0xEA, 0xA0, 0xB9, 0x05, 0x5E, 0x42, 0xAD, 0x83, 0xEF, 0x8E, 0x9D, 0xA4, 0x94, 0xFF, 0x21};
                    return true;
                }
            }
            else if (keyType==Key_KEK)
            {
                if (isTestNetKey)
                {
                    key=ServerTestFramework.Utilities.Hexer.unhex("0x50387a05be3c25204273e8aa8a8252bd7ed81fdfebc8b4311cdbd1746e72a5ad");
                    return true;
                }
                else if (lowerEnvName=="int2")
                {
                    key=ServerTestFramework.Utilities.Hexer.unhex("0xB97EC05755902D8D1DE565C358404A98B647E3E2903E399CAC1895C84A217126");
                    return true;
                }
            }

            key=null;
            return false;
        }

        //Other hard-coded keys
        public static byte[] Key_XmacsTicket = new byte[16]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; //ticket coming from xmacs is unused, and encrypted with a pointless key
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\NetworkPackets.cs ===
using System;
using System.Net;
using System.Runtime.InteropServices;
using ServerTestFramework;

namespace ServerTestFramework.LiveService.Auth
{
    public class NetConstants
    {
        public const int    ENET_MAX_FRAME      = 1514;
        public const int    ENET_HDR_SIZE       = 14;
        public const int    IP_HDR_SIZE         = 20;
        public const int    UDP_HDR_SIZE        = 8;
        public const byte   UDP_PROTOCOL        = 0x11;
        public const ushort ENET_TYPE_IP        = 0x0008;
        public const ushort ENET_TYPE_ARP       = 0x0608;
        public const ushort ARP_OP_REQUEST      = 0x0100;
        public const ushort ARP_OP_REPLY        = 0x0200;
        public const ushort ARP_HWTYPE_ENET     = 0x0100;
        public const int    ARP_PACKET_SIZE     = 42;
        public const int    ICMP_HDR_SIZE       = 8;
        public const byte   ICMP_PROTOCOL       = 0x1;

        public static ushort HTONS(ushort us)
        {
            return (ushort)(((us >> 8) & 0x00FF) | ((us << 8) & 0xFF00));
        }
        
        public static ulong HTONUL(ulong ul)
        {
            return (ulong)(
                ((ul >> 56) & 0xFF) |
                ((ul >> 40) & 0xFF00) |
                ((ul >> 24) & 0xFF0000) |
                ((ul >> 8)  & 0xFF000000) |
                ((ul << 8)  & 0xFF00000000) |
                ((ul << 24) & 0xFF0000000000) |
                ((ul << 40) & 0xFF000000000000) |
                ((ul << 56) & 0xFF00000000000000));
        }

        public static uint HTONUI (uint ui)
        {
            return (uint) (((ui & 0x000000ff) << 24) | ((ui & 0x0000ff00) << 8) |
                ((ui & 0x00ff0000) >> 8) | ((ui & 0xff000000) >> 24));
        }
    }

    public class IpMacPair
    {
        public IpAddr ip;
        public EnetAddr mac;
        public ushort port;

        public IpMacPair(string ipAddr, string enetAddr)
        {
            ip = new IpAddr(ipAddr);
            mac = new EnetAddr(enetAddr);
            port = 0;
        }

        public IpMacPair(string ipAddr, string enetAddr, ushort port)
        {
            ip = new IpAddr(ipAddr);
            mac = new EnetAddr(enetAddr);
            this.port = port;
        }

        public IpMacPair(IpAddr ipAddr, EnetAddr enetAddr)
        {
            ip = ipAddr;
            mac = enetAddr;
            port = 0;
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class EnetAddr : WireData
    {
        [WireInfo(ArraySize=6)]
        public byte[]                   _ab = new byte[6];

        public static EnetAddr Broadcast()
        {
            return new EnetAddr(new byte[6] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF });
        }

        public static EnetAddr Zero()
        {
            return new EnetAddr(new byte[6] { 0, 0, 0, 0, 0, 0 });
        }

        public EnetAddr() : this(new byte[6]) 
        {}

        public EnetAddr (EnetAddr enetaddr)
        {
            _ab = (byte[]) enetaddr._ab.Clone();
        }

        public EnetAddr(byte[] addr)
        {
            if (addr.Length != 6)
            {
                throw new Exception("Length of MAC address must be 6");
            }
            _ab = addr;
        }

        public EnetAddr(string addr)
        {
            string delim = ":-";
            string[] fields = addr.Split(delim.ToCharArray());
            if (fields.Length != 6)
            {
                throw new Exception("Length of MAC address must be 6, separators can be : or -");
            }
            for (int i = 0; i < fields.Length; i++)
            {
                _ab[i] = byte.Parse(fields[i], System.Globalization.NumberStyles.HexNumber);
            }
        }

        public override bool Equals(Object obj)
        {
            if ((obj == null) || (GetType() != obj.GetType()))
            {
                return false;
            }
            EnetAddr b = (EnetAddr)obj;
            for (int i = 0; i < this._ab.Length; i++)
            {
                if (this._ab[i] != b._ab[i])
                    return false;
            }
            return true;
        }

        public override int GetHashCode()
        {
            return _ab[0] ^ _ab[1] ^ _ab[2] ^ _ab[3] ^ _ab[4] ^ _ab[5];
        }

        public override string ToString()
        {
            return String.Format("{0:X}-{1:X}-{2:X}-{3:X}-{4:X}-{5:X}", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
        }
    }


    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class EnetHdr : WireData
    {
        public EnetAddr             eaDst = new EnetAddr();
        public EnetAddr             eaSrc = new EnetAddr();
        public ushort               Type;

        public override string ToString()
        {
            return String.Format("Dst: {0}, Src: {1}, Type: {2}", eaDst.ToString(), eaSrc.ToString(), Type);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class IpAddr : WireData
    {
        /// <summary>
        /// IpAddr representing 0.0.0.0; Please do not modify!
        /// </summary>
        public static IpAddr Zero = new IpAddr();

        public uint                 S_addr          = 0;

        public IpAddr() : this(0)
        {}

        public IpAddr (IpAddr ipaddr)
        {
            S_addr = ipaddr.S_addr;
        }

        public IpAddr(uint a)
        {
            S_addr = a;
        }

        public IpAddr(byte a, byte b, byte c, byte d)
        {
            // TODO: is this right?  
            // NOTE: yes, pretty sure.
            S_addr = (uint)((d << 24) + (c << 16) + (b << 8) + a);
        }

        public IpAddr(byte[] addr) : this(addr[0], addr[1], addr[2], addr[3])
        {}

        public IpAddr(string addr)
        {
            string delim = ".:";
            string[] fields = addr.Split(delim.ToCharArray());
            if (fields.Length < 4)
            {
                throw new Exception("Length of IP address must at least 4, separators can be . or :");
            }
            for (int i = 0; i < fields.Length; i++)
            {
                byte a = byte.Parse(fields[i]);
                S_addr += (uint)(a << (8 * i));
            }
        }

        public IPEndPoint GetIPEndPoint()
        {
            return new IPEndPoint(S_addr, 0);
        }

        public bool EqualsIp(System.Net.IPAddress ipa)
        {
            IpAddr ip2 = new IpAddr(ipa.GetAddressBytes());
            return (this.S_addr == ip2.S_addr);
        }

        public override bool Equals (object obj)
        {
            IpAddr ipAddr = obj as IpAddr;

            if (ipAddr != null)
            {
                return Equals(ipAddr);
            }

            IPAddress ipAddress = obj as IPAddress;

            if (ipAddress != null)
            {
                return EqualsIp(ipAddress);
            }

            return false;
        }

        public bool Equals (IpAddr ipa)
        {
            return S_addr == ipa.S_addr;
        }

        public override int GetHashCode ()
        {
            return (int)S_addr;
        }

        public override string ToString()
        {
            return GetIPEndPoint().Address.ToString();
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class PseudoIpHdr : WireData
    {
        public IpAddr               ipaSrc;
        public IpAddr               ipaDst;
        public byte                 Zero;
        public byte                 Protocol;
        public ushort               Len;
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class IpHdr : WireData
    {
        public byte                 VerHdr;                 // Version & header length
        public byte                 Tos;                    // Type of service
        public ushort               Len;                    // Total length including IP header
        public ushort               Id;                     // Identification
        public ushort               FragOff;                // Flags and fragment offset
        public byte                 Ttl;                    // Time to live
        public byte                 Protocol;               // Protocol
        public ushort               Checksum;               // Header checksum
        public IpAddr               ipaSrc = new IpAddr();  // Source address
        public IpAddr               ipaDst = new IpAddr();  // Destination address

        public uint GetHdrLen()     
        { 
            return (uint)((VerHdr & 0xF) << 2); 
        }

        public void SetHdrLen(uint cb)  
        { 
            VerHdr = (byte)(0x40 | (cb >> 2)); 
        }

        public void DoChecksum()
        {
            Checksum = 0;
            Checksum = ComputeIPChecksum((byte[])this);
        }

        /// <summary>
        /// Computes the IP checksum for the given array.
        /// </summary>
        /// <param name="data">The data to checksum.</param>
        /// <returns>The checksum value for the given data.  !!!In network order!!!</returns>
        public static ushort ComputeIPChecksum (byte[] data)
        {
            uint tempChecksum = 0;

            for (int i = 0; i < data.Length; i += 2)
            {
                ushort s = BitConverter.ToUInt16(data, i);
                tempChecksum += (uint) NetConstants.HTONS(s);
            }

            while ((tempChecksum & 0xFFFF0000) != 0)
            {
                tempChecksum = (tempChecksum & 0xFFFF) + (tempChecksum >> 16);
            }

            return NetConstants.HTONS((ushort) (~(tempChecksum & 0xFFFF)));
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public class IcmpHdr : WireData
    {
        public byte Type;
        public byte Code;
        public ushort Checksum;
        public ushort ID;
        public ushort Sequence;

        // Constants
        public const byte ECHO_REPLY = 0;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public class IcmpPacket : WireData
    {
        public EnetHdr Enet = new EnetHdr();
        public IpHdr Ip = new IpHdr();
        public IcmpHdr Icmp = new IcmpHdr();

        public IcmpPacket () { }

        public void Set (IpMacPair local, IpMacPair remote)
        {
            // Set constants
            Enet.Type = NetConstants.ENET_TYPE_IP;
            Ip.VerHdr = 0x45;
            Ip.Tos = 0x00;
            Ip.Id = 0;
            Ip.FragOff = 0;
            Ip.Ttl = 0x40;
            Ip.Protocol = NetConstants.ICMP_PROTOCOL;
            Ip.Checksum = 0;

            // Set parameters
            Enet.eaSrc = new EnetAddr(local.mac);
            Enet.eaDst = new EnetAddr(remote.mac);
            Ip.Len = NetConstants.HTONS((ushort) (NetConstants.IP_HDR_SIZE + NetConstants.ICMP_HDR_SIZE));
            Ip.ipaSrc = new IpAddr(local.ip);
            Ip.ipaDst = new IpAddr(remote.ip);
            Ip.DoChecksum();

            DoIcmpChecksum();
        }

        public void DoIcmpChecksum ()
        {
            Icmp.Checksum = 0;
            Icmp.Checksum = IpHdr.ComputeIPChecksum((byte[]) Icmp);
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class UdpHdr : WireData
    {
        public ushort               portSrc;
        public ushort               portDst;
        public ushort               Len;
        public ushort               Checksum;
    }

    
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class UdpPacket : WireData
    {
        public EnetHdr              Enet = new EnetHdr();
        public IpHdr                Ip = new IpHdr();
        public UdpHdr               Udp = new UdpHdr();
        [WireInfo(WriteOnlyVarLenString=true)]
        public byte[] Payload = null;

        public UdpPacket()
        {
        }

        public void Set(IpMacPair local, IpMacPair remote, byte[] payload, ushort id)
        {
            // Set constants
            Enet.Type = NetConstants.ENET_TYPE_IP;
            Ip.VerHdr = 0x45;
            Ip.Tos = 0x00;
            Ip.Id = 0;
            Ip.FragOff = 0;
            Ip.Ttl = 0x40;
            Ip.Protocol = NetConstants.UDP_PROTOCOL;
            Ip.Checksum = 0;

            // Set parameters
            Enet.eaSrc = new EnetAddr(local.mac);
            Enet.eaDst = new EnetAddr(remote.mac);
            Ip.Len = NetConstants.HTONS((ushort)(NetConstants.IP_HDR_SIZE + NetConstants.UDP_HDR_SIZE + payload.Length));
            Ip.ipaSrc = new IpAddr(local.ip);
            Ip.ipaDst = new IpAddr(remote.ip);
            Ip.DoChecksum();
            Udp.portSrc = NetConstants.HTONS(local.port);
            Udp.portDst = NetConstants.HTONS(remote.port);
            Udp.Len = NetConstants.HTONS((ushort)(NetConstants.UDP_HDR_SIZE + payload.Length));
            DoUdpChecksum(payload);

            Payload = payload;
        }

        public void DoUdpChecksum(byte[] payload)
        {
            // We need an array consisting of:
            //   PseudoHdr
            //   UdpHdr
            //   Payload
            //   [1 byte pad if Payload length is odd]

            PseudoIpHdr pseudo = new PseudoIpHdr();
            pseudo.ipaSrc = Ip.ipaSrc;
            pseudo.ipaDst = Ip.ipaDst;
            pseudo.Zero = 0;
            pseudo.Protocol = NetConstants.UDP_PROTOCOL;
            pseudo.Len = Udp.Len;

            // Construct final array totalBytes on which to compute the checksum
            byte[] pseudoBytes = (byte[])pseudo;
            byte[] udpBytes = (byte[])this.Udp;
            int totalBytesLength = pseudoBytes.Length + udpBytes.Length + payload.Length;
            if ((totalBytesLength % 2) != 0)
                totalBytesLength++;
            byte[] totalBytes = new byte[totalBytesLength];
            pseudoBytes.CopyTo(totalBytes, 0);
            udpBytes.CopyTo(totalBytes, pseudoBytes.Length);
            payload.CopyTo(totalBytes, pseudoBytes.Length + udpBytes.Length);            

            // wChecksum has to be on the stack
            // If we use the member variable, it will change
            // the IP header when the checksum is being evaluated
            // and result in an invalid checksum
            Udp.Checksum = 0;
            ushort tempChecksum = 0;
            ushort prevChecksum = 0;
            ushort Overflow = 0;

            for(int i = 0; i < totalBytes.Length; i += 2)
            {
                ushort s = (ushort)BitConverter.ToInt16(totalBytes, i);
                tempChecksum += NetConstants.HTONS(s);

                if(tempChecksum < prevChecksum)
                    Overflow++;

                prevChecksum = tempChecksum;
            }

            tempChecksum = (ushort)(~tempChecksum);
            tempChecksum = (ushort)(tempChecksum - Overflow);
            if (tempChecksum == 0)
                tempChecksum = 0xFFFF;
            Udp.Checksum = NetConstants.HTONS(tempChecksum);
        }

    }
            
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class ArpPacket : WireData
    {
        public EnetHdr              Enet = new EnetHdr();
        public ushort               Hrd;                        // hardware address space
        public ushort               Pro;                        // protocol address space (ENET_TYPE_IP)
        public byte                 Hln;                        // hardware address length (6)
        public byte                 Pln;                        // protocol address length (4)
        public ushort               Op;                         // opcode
        public EnetAddr             eaSender = new EnetAddr();  // sender's hardware address
        public IpAddr               ipaSender = new IpAddr();   // sender's protocol address
        public EnetAddr             eaTarget = new EnetAddr();  // target's hardware address
        public IpAddr               ipaTarget = new IpAddr();   // target's protocol address

        public void Set(EnetAddr eaSelf, IpAddr ipSelf, IpAddr ipTarget)
        {
            Enet.eaDst = EnetAddr.Broadcast();
            Enet.eaSrc = eaSelf;
            Enet.Type = NetConstants.ENET_TYPE_ARP;
            Hrd = NetConstants.ARP_HWTYPE_ENET;
            Pro = NetConstants.ENET_TYPE_IP;
            Hln = 6;
            Pln = 4;
            Op = NetConstants.ARP_OP_REQUEST;
            eaSender = eaSelf;
            ipaSender = ipSelf;
            eaTarget = EnetAddr.Zero();
            ipaTarget = ipTarget;
        }

        /// <summary>
        /// Creates an ARP probe packet from the given MAC for the given IP.
        /// </summary>
        /// <param name="eaSelf">The MAC of the prober.</param>
        /// <param name="ipTarget">The IP being probed for.</param>
        public void SetProbe (EnetAddr eaSelf, IpAddr ipTarget)
        {
            Set(eaSelf, IpAddr.Zero, ipTarget);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\RawNic.cs ===
using System;
using System.Runtime.InteropServices;
using System.IO;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary>
    /// Provides frame-level access to the NIC. Careful, it's tricky to use.
    /// </summary>
    public class RawNic : IDisposable
    {
        #region DllImports from rawnic.dll

        [DllImport("rawnic.dll", EntryPoint="RawnicDetectDriver", PreserveSig=true)]
        private static extern uint RawDetectDriver();

        [DllImport("rawnic.dll", EntryPoint = "RawnicInstallDriver", PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern uint RawInstallDriver(
            [MarshalAs(UnmanagedType.LPWStr)]
            string pwszProduct,
            out bool pfRebootRequired,
            IntPtr perror);

        [DllImport("rawnic.dll", EntryPoint = "RawnicUninstallDriver", PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern uint RawUninstallDriver(
            [MarshalAs(UnmanagedType.LPWStr)]
            string pwszProduct,
            out bool pfRebootRequired,
            IntPtr perror);
        
        [DllImport("rawnic.dll", EntryPoint="RawAdapterOpen", PreserveSig=true)]
        private static extern uint RawOpen(
            byte[] pbEaNic,        // 6 bytes
            byte[] pbEaVirtual,    // 6 bytes
            uint dwOptions,
            uint dwRecvMaxLatency,      // in microseconds
            uint dwRecvDesiredLatency,  // in microseconds
            out IntPtr pRawnicToken);

        // TODO: RawClose() is not implemented in rawnic, but the old one just called 
        // CloseHandle().  Maybe go directly to Win32 call? It's the same signature after 
        // all.
        [DllImport("kernel32.dll", EntryPoint="CloseHandle", PreserveSig=true, SetLastError=true)]
        private static extern uint RawClose(
            IntPtr pRawnicToken);
            
        [DllImport("rawnic.dll", EntryPoint="RawAdapterQueryStatus", PreserveSig=true)]
        private static extern uint RawQueryStatus(
            IntPtr pRawnicToken);
            
        [DllImport("rawnic.dll", EntryPoint="RawAdapterRecv", PreserveSig=true)]
        private static extern uint RawRecv(
            IntPtr pRawnicToken,
            uint cb,
            byte[] pb,
            IntPtr lpOverlapped,
            out uint cbReceived);

        [DllImport("rawnic.dll", EntryPoint="RawAdapterSend", PreserveSig=true)]
        private static extern uint RawSend(
            IntPtr pRawnicToken,
            uint cb,
            byte[] pb,
            IntPtr lpOverlapped);

        [DllImport("rawnic.dll", EntryPoint="RawAdapterReadCounters", PreserveSig=true)]
        private static extern uint RawReadCounters(
            IntPtr pRawnicToken,
            uint cbCounters,
            uint[] pCounters,  // 5 uints: cReceiveCalls, cSendCalls, cPacketReceived, cPacketDropped, cPacketSent
            IntPtr lpOverlapped);

        #endregion

        public const int RN_OPTION_OVERLAPPED        = 0x00000001;
        public const int RN_OPTION_BROADCAST_ARP     = 0x00000002;
        public const int RN_OPTION_BROADCAST_DHCP    = 0x00000004;
        public const int RN_OPTION_BROADCAST_XBOX    = 0x00000008;
        public const int RN_OPTION_BROADCAST_ANY     = 0x00000010;
        public const int RN_OPTION_PROMISCUOUS       = 0x00000020;

        public class RawNicException : Exception
        {
            public RawNicException(string message) : base("[RawNic] " + message) { }
            public RawNicException(string format, params object[] args) : base(String.Format("[RawNic] " + format, args)) { }
        }

        private IntPtr Token = IntPtr.Zero;
        private string ProductName = "";
        private IpMacPair realIpMac;
        private IpMacPair virtualIpMac;

        /// <summary>
        /// Access to the virtual MAC used to open RawNic.
        /// (12/3/08 this is actually the real MAC of the NIC)
        /// </summary>
        public IpMacPair VirtualIpMacPair { get { return virtualIpMac; } }

        private byte[] buffer = new byte[2000];

        public RawNic()
        {
        }

        ~RawNic()
        {
            Close();
        }

        public void Install() { Install("RawnicWrapper"); }
        public void Install(string productName)
        {
            ProductName = productName;
            bool fRebootRequired;
            uint err = RawInstallDriver(ProductName, out fRebootRequired, IntPtr.Zero);
            // Install returns a bool, true means a good install
            if (err != 1)
            {
                throw new RawNicException("Install driver returned {0} (bool value)", err);
            }
            if (fRebootRequired)
            {
                throw new RawNicException("RawnicInstallDriver says you need to reboot to complete the installation. Sorry.");
            }
        }

        public void Uninstall()
        {
            bool fRebootRequired;
            uint err = RawUninstallDriver(ProductName, out fRebootRequired, IntPtr.Zero);
            if (err != 0)
            {
                throw new RawNicException("Uninstall driver returned {0}", err);
            }
            if (fRebootRequired)
            {
                throw new RawNicException("RawnicUninstallDriver says you need to reboot to complete the uninstallation. Sorry.");
            }
        }

        public void Open()
        {
            realIpMac = AuthUtils.GetMacAddress();
            virtualIpMac = new IpMacPair(
                new IpAddr(realIpMac.ip.S_addr),
                GenerateVirtualMac(realIpMac.mac));
            Open(realIpMac.mac, virtualIpMac.mac, 0);
        }

        /// <summary>
        /// Opend RAWNIC on the MAC that is the closest to the remote IP address.
        /// </summary>
        /// <param name="remoteIP">The remote IP address that we want to connect to.</param>
        public void Open (IpAddr remoteIP)
        {
            Open(remoteIP, true);
        }
        
        /// <summary>
        /// Opend RAWNIC on the MAC that is the closest to the remote IP address.
        /// </summary>
        /// <param name="remoteIP">The remote IP address that we want to connect to.</param>
        /// <param name="installIfNecessary">If true, the driver will be installed if it is not detected.</param>
        public void Open (IpAddr remoteIP, bool installIfNecessary)
        {
            realIpMac = AuthUtils.GetMacAddress(remoteIP);
            virtualIpMac = new IpMacPair(
                new IpAddr(realIpMac.ip.S_addr),
                GenerateVirtualMac(realIpMac.mac));
            Open(realIpMac.mac, virtualIpMac.mac, 0, installIfNecessary);
        }

        public void Open (EnetAddr eaReal, EnetAddr eaVirtual, uint options)
        {
            Open(eaReal, eaVirtual, options, true);
        }

        public void Open (EnetAddr eaReal, EnetAddr eaVirtual, uint options, bool installIfNecessary)
        {
            uint err;
            if (Token != IntPtr.Zero)
            {
                Close();
            }

            err = RawDetectDriver();
            if (err != 0)
            {
                if (installIfNecessary)
                {
                    Install();
                }
                else
                {
                    throw new RawNicException("RawNic was not detected [error 0x{0:X8}]", err);
                }
            }

            err = RawOpen(eaReal._ab, eaVirtual._ab, options, 15000, 20, out Token);
            if (err != 0)
            {
                throw new RawNicException("Open returned {0}", err);
            }
        }

        public void Close()
        {
            uint err;
            if (Token == IntPtr.Zero)
            {
                return;
            }
            err = RawClose(Token);
            Token = IntPtr.Zero;

            // RawClose is currently mapped to CloseHandle, which returns a BOOL (0 is failure)
            // The real error will be from GetLastError, which the default constructor for
            // Win32Exception looks up for us
            if (err == 0)
            {
                throw new System.ComponentModel.Win32Exception();
            }
        }
    
        public void Send(byte[] data)
        {
            uint err;
            // New rawnic takes a 2-byte prefix before the packet that indicates the 
            // length of the packet.
            Array.Copy(data, 0, buffer, 2, data.Length);
            buffer[0] = (byte)((data.Length) & 0xFF);
            buffer[1] = (byte)((data.Length >> 8) & 0xFF);
            err = RawSend(Token, (uint)data.Length + 2, buffer, IntPtr.Zero);
            if (err != 0)
            {
                throw new RawNicException("Send returned {0}", err);
            }
        }

        public byte[] Recv()
        {
            uint err;
            uint cbReceived;
            err = RawRecv(Token, (uint)buffer.Length, buffer, IntPtr.Zero, out cbReceived);
            if (cbReceived <= 2)
            {
                return null;
            }
            int packetsize = buffer[0] + (buffer[1] << 8);
            if (packetsize > cbReceived - 2)
            {
                return null;
            }
            byte[] data = new byte[packetsize];
            Array.Copy(buffer, 2, data, 0, packetsize);
            return data;
        }

        public uint Recv(byte[] buf, out uint cbReceived)
        {
            uint err;
            err = RawRecv(Token, (uint)buffer.Length, buffer, IntPtr.Zero, out cbReceived);
            if (cbReceived <= 2)
            {
                cbReceived = 0;
                return 0;
            }
            int packetsize = buffer[0] + (buffer[1] << 8);
            if (packetsize > cbReceived - 2 || packetsize > buf.Length)
            {
                cbReceived = 0;
                return 0;
            }
            Array.Copy(buffer, 2, buf, 0, packetsize);
            return err;
        }

        protected EnetAddr GenerateVirtualMac(EnetAddr realMac)
        {
            // If we send packets with the same IP address but a different MAC address from
            // our real machine, Windows will throw up its hands and complain about a duplicate
            // IP address on the network.  Using the same IP and MAC seems to work OK, so this
            // function will do nothing right now.
            return new EnetAddr(realMac._ab);
        }

        public IpMacPair LookupMac(IpAddr remoteIp)
        {
            ArpPacket       arpRequest  = new ArpPacket();
            ArpPacket       arpReply    = new ArpPacket();
            IpMacPair       localIpMac  = AuthUtils.GetMacAddress(remoteIp);
            byte[]          recvpacket  = new byte[2000];
            uint            cbReceived  = 0;
            uint            err;
            TimeSpan        timeout     = new TimeSpan(0, 0, 2);  // 2 seconds per try
            int             numRetries  = 4;

            for (int retry = 0; retry < numRetries; retry++)
            {
                // Send it
                arpRequest.Set(localIpMac.mac, localIpMac.ip, remoteIp);
                Send((byte[])arpRequest);

                DateTime startTime = DateTime.Now;
                while (DateTime.Now.Subtract(startTime) < timeout)
                {
                    cbReceived = 0;
                    err = RawRecv(Token, (uint)buffer.Length, buffer, IntPtr.Zero, out cbReceived);
                
                    // Walk through all of the packets embedded in this buffer
                    int cb = 0;
                    int packetsize = 0;
                    for (cb = 0; cb < cbReceived; cb += packetsize)
                    {
                        packetsize = buffer[cb] + (buffer[cb+1] << 8);
                        cb += 2;
                    
                        // Got something approximately the right size?
                        if (packetsize < 42)
                            continue;
                
                        // Arp type?
                        if (buffer[cb + 12] != 0x08 || buffer[cb + 13] != 0x06)
                            continue;

                        // Looks promising. Let's wiredata it.
                        MemoryStream ms = new MemoryStream(buffer, cb, packetsize);
                        arpReply.ReadBytes(ms.ToArray());

                        // Arp reply?
                        if (arpReply.Op != NetConstants.ARP_OP_REPLY)
                            continue;

                        // Sent to us?
                        if (!arpReply.Enet.eaDst.Equals(localIpMac.mac))
                            continue;

                        // This is it!
                        IpMacPair remote = new IpMacPair(arpReply.ipaSender, arpReply.eaSender);
                        return remote;
                    }
                }
            }
            throw new RawNicException("Timed out [{0} seconds, {1} retries] waiting for ARP response", timeout.TotalSeconds, numRetries);
        }
        #region IDisposable Members

        public void Dispose()
        {
            Close();
        }

        #endregion
    }

    public class RawNicSimpleUdp : RawNic
    {
        protected IpMacPair localIpMac = null;
        protected IpMacPair remoteIpMac = null;
        protected static ushort udpId = 0;

        public IpMacPair LocalIpMac { get { return localIpMac; } }

        public void ConnectTo(IpAddr remoteIp, ushort remotePort)
        {
            ConnectTo(remoteIp, remotePort, 2112);
        }
        
        public void ConnectTo(IpAddr remoteIp, ushort remotePort, ushort localPort)
        {
            this.localIpMac = AuthUtils.GetMacAddress(remoteIp);
            this.remoteIpMac = LookupMac(remoteIp);
            this.localIpMac.port = localPort;
            this.remoteIpMac.port = remotePort;
        }

        public UdpPacket ConstructPacket(byte[] payload)
        {
            if (remoteIpMac == null)
                throw new RawNicException("Unable to construct a packet, please call ConnectTo first");
            UdpPacket udp = new UdpPacket();
            udp.Set(localIpMac, remoteIpMac, payload, udpId++);
            return udp;
        }

        public IcmpPacket ConstructIcmpPacket ()
        {
            if (remoteIpMac == null)
                throw new RawNicException("Unable to construct a packet, please call ConnectTo first");
            IcmpPacket icmp = new IcmpPacket();
            icmp.Set(localIpMac, remoteIpMac);
            return icmp;
        }

        public void SendUdp(byte[] payload)
        {
            UdpPacket udp = ConstructPacket(payload);

            MemoryStream stream = new MemoryStream();
            udp.WriteStream(stream);
            stream.Write(payload, 0, payload.Length);
            Send(stream.ToArray());
            
            /*
            byte[] udpBytes = (byte[])udp;
            byte[] totalBytes = new byte[udpBytes.Length + payload.Length];
            udpBytes.CopyTo(totalBytes, 0);
            payload.CopyTo(totalBytes, udpBytes.Length);
            Send(totalBytes);
            */
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\SGConnectionPool.cs ===
using System;
using System.Collections.Generic;
using System.Threading;

namespace ServerTestFramework.LiveService.Auth
{

    /// <summary>
    /// A collection of SGConnections that are managed by the pool.
    /// </summary>
    public class SGConnectionPool
    {

        /// <summary>
        /// The threads that are being used to keep the connections going.
        /// </summary>
        private List<Thread> Threads;

        /// <summary>
        /// The connections in the pool.
        /// </summary>
        private SGConnection[] Connections;

        /// <summary>
        /// The index that is used by the threads to walk through the connections.
        /// </summary>
        private int ThreadConnectionPointer;

        /// <summary>
        /// The transport for use by the connections.
        /// </summary>
        private XspUdp Transport;

        /// <summary>
        /// The number of threads to use to keep the connections going.
        /// </summary>
        public int ThreadCount { get; private set; }

        /// <summary>
        /// The number of connections that are in the pool.
        /// </summary>
        public int MaxConnectionCount { get; private set; }

        /// <summary>
        /// True if the pool is running; false if it is not.
        /// </summary>
        public bool IsRunning { get; private set; }

        /// <summary>
        /// Create a new connection pool with default values.
        /// </summary>
        public SGConnectionPool ()
        {
            ThreadCount = 4;
            MaxConnectionCount = 10000;
            NewConnection = CreateNewConnection;
            ProcessChallenge = PrivateProcessChallenge;
        }

        /// <summary>
        /// Create a new connection pool with specified values.
        /// </summary>
        public SGConnectionPool (int threadCount, int maxConnectionCount) : this()
        {
            ThreadCount = threadCount;
            MaxConnectionCount = maxConnectionCount;
        }

        /// <summary>
        /// Start the connection pool, which creates and signs in all of the connections.
        /// </summary>
        public void Start ()
        {
            Threads = new List<Thread>();
            Connections = new SGConnection[MaxConnectionCount];
            ThreadConnectionPointer = 0;
            Transport = new XspUdp();

            IsRunning = true;

            try
            {
                for (int i = 0; i < ThreadCount; ++i)
                {
                    Thread t = new Thread(ThreadHandler);
                    t.Start();
                    Threads.Add(t);
                }
            }
            catch
            {
                Stop();
                throw;
            }
        }

        /// <summary>
        /// Stops the connection pool, which signs out all of the connections and discards them.
        /// </summary>
        public void Stop ()
        {
            IsRunning = false;

            if (Threads != null)
            {
                for (int i = 0; i < Threads.Count; ++i)
                {
                    Threads[i].Join();
                }

                Threads = null;
            }

            Connections = null;

            if (Transport != null)
            {
                Transport.Close();
                Transport = null;
            }
        }

        /// <summary>
        /// The thread start function for keeping the connections going.
        /// </summary>
        private void ThreadHandler ()
        {
            while (IsRunning)
            {
                try
                {
                    long currentIndex = ((uint)(Interlocked.Increment(ref ThreadConnectionPointer) - 1)) % Connections.Length;
                    SGConnection conn = Connections[currentIndex];

                    if (conn == null)
                    {
                        conn = (NewConnection ?? CreateNewConnection)();
                        Connections[currentIndex] = conn;
                    }

                    // check if we are disconnected
                    if (conn.State == SGConnection.ConnectionState.Disconnected)
                    {
                        // attempt to connect and go back around
                        if (conn.SinceLastKeyexInit >= conn.KeyExchangeMinRetryTime)
                        {
                            conn.ConnectAsync();
                        }
                        continue;
                    }

                    // always pump the queue
                    conn.ProcessReceiveQueue();

                    switch (conn.State)
                    {
                        case SGConnection.ConnectionState.Disconnected:
                            // disconnected by server
                            continue;

                        case SGConnection.ConnectionState.ConnectWait:
                            if (conn.SinceLastKeyexInit.TotalMilliseconds >= conn.KeyExchangeTimeoutInMs)
                            {
                                // keyex timeout
                                conn.SetDisconnected();
                            }
                            continue;
                    }

                    // check for a challenge
                    if (conn.HasCurrentChallenge && ProcessChallenge != null)
                    {
                        ProcessChallenge(conn);
                    }

                    // if needed, send a heartbeat
                    conn.SendHeartbeat(true);
                }
                catch (Exception e)
                {
                    Global.RO.Error(e.ToString());
                }
            }

            // no longer running, we need to disconnect everyone
            for (int i = 0; i < Connections.Length; ++i)
            {
                try
                {
                    long currentIndex = ((uint)(Interlocked.Increment(ref ThreadConnectionPointer) - 1)) % Connections.Length;
                    SGConnection conn = Connections[currentIndex];

                    if (conn == null)
                    {
                        continue;
                    }

                    conn.Disconnect();
                }
                catch (Exception e)
                {
                    Global.RO.Error(e.ToString());
                }
            }
        }

        public SGConnection BorrowConnection ()
        {
            return null;
        }

        public void ReturnConnection (SGConnection conn)
        {
        }

        /// <summary>
        /// Backing for DefaultSite.
        /// </summary>
        private static SiteInfo _DefaultSite;

        /// <summary>
        /// The default site to use for connections.
        /// </summary>
        public static SiteInfo DefaultSite
        {
            get
            {
                if (_DefaultSite == null)
                {
                    _DefaultSite = SiteInfoManager.GetDefaultSgSite().CloneDeep();
                }

                return _DefaultSite;
            }
        }

        /// <summary>Creates a new SgConnection.</summary>
        public SGConnection CreateNewConnection ()
        {
            return CreateNewConnection(AuthContext.ClientTypes.Xenon, 1);
        }

        /// <summary>Creates a new SgConnection.</summary>
        public SGConnection CreateNewConnection (AuthContext.ClientTypes clientType, int numUsers)
        {
            SGConnection ans = new SGConnection();

            ans.Context = new AuthContext(clientType);
            ans.Context.Site = DefaultSite;
            ans.Context.Authdata = Authdata_Base.NewDefaultFromSite(ans.Context.Site);
            ans.Transport = Transport;

            // Set some user names.  DefaultAuthData() will detect this and
            // make up unique puids for us.
            ans.Context.ClearUsers();
            for (int i = 0; i < numUsers; i++)
            {
                ans.Context.SetUser("sgtestuser" + i, i);
            }

            SgClient.SetDefaultAuthdata(ans.Context, ans.Context.Authdata);

            return ans;
        }

        /// <summary>Our challenge handler; will at least respond.</summary>
        private void PrivateProcessChallenge (SGConnection conn)
        {
            SecMsgSgToXbChal chal = conn.CurrentChallengePacket;

            if (chal == null)
            {
                return;
            }

            SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck() { ChallengeNonce = chal.ChallengeNonce };
            conn.Send(ack);

            SecMsgXbToSgChalResp2 resp = new SecMsgXbToSgChalResp2() { ChallengeNonce = chal.ChallengeNonce };
            conn.Send(resp);
        }

        /// <summary>
        /// Delegate to create a new SGConnection.
        /// </summary>
        /// <returns>A new SGConnection.</returns>
        public delegate SGConnection NewConnectionDelegate ();

        /// <summary>
        /// Called when a new connection needs to be created.
        /// </summary>
        public NewConnectionDelegate NewConnection;

        /// <summary>
        /// Delegate to process challenges.
        /// </summary>
        /// <param name="conn">The connection that has the challenge.</param>
        public delegate void ProcessChallengeDelegate (SGConnection conn);

        /// <summary>
        /// Called when a connection has a challenge to be processed.
        /// </summary>
        public ProcessChallengeDelegate ProcessChallenge;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\SGClient.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary>
    /// Custom SG exception so we can catch() more explicitly
    /// </summary>
    public class SGException : Exception
    {
        public SGException(string message) : base(message) 
        { 
            if (Global.RO != null)
                Global.RO.Error(message); 
        }
        public SGException(string format, params object[] args) : base(String.Format(format, args)) 
        { 
            if (Global.RO != null)
                Global.RO.Error(format, args); 
        }
    }

    /// <summary>
    /// Custom SG exception so we can catch() more explicitly
    /// </summary>
    public class SGNoReplyException : SGException
    {
        public SGNoReplyException(string message) : base(message) {  }
        public SGNoReplyException(string format, params object[] args) : base(String.Format(format, args)) { }
    }

    /// <summary>
    /// Custom SG exception so we can catch() more explicitly
    /// </summary>
    public class SGRetryException : SGException
    {
        public SGRetryException(string message) : base(message) {  }
        public SGRetryException(string format, params object[] args) : base(String.Format(format, args)) { }
    }



    public class SgClient : AuthClientBase
    {
        // Handy constants
        public readonly static ulong k_XboxMachinePuidMask      = 0x0009000000000000;
        public readonly static ulong k_XenonMachinePuidMask     = 0xFA00000000000000;
        public readonly static ulong k_PanoramaMachinePuidMask  = 0xFB00000000000000;
        public readonly static ulong k_UserPuidMask             = 0x0009000000000000;
        public readonly static ulong k_CounterPuidMask          = 0x000000FFFFFFFFFF;

        public static uint[] k_DefaultServices =
            new uint[] { (uint)XOService.PresNotification, 
                           (uint)XOService.User_Account, 
                           (uint)XOService.Signature_Server };

        // We want to build a unique machine puid across all instances of SgClient,
        // so this is the current counter. We'll always seed it with a random
        // value.
        protected static long          CurrentSgPuidCounter    = 0;

        /// <summary>
        /// Static Constructor.
        /// </summary>
        static SgClient ()
        {
            // Mask off 2 high bytes (for puid) plus 1 extra byte (plenty of growth room)
            // don't forget to add 0x0009... or 0xFA00....
            CurrentSgPuidCounter = (long)(rand.NextUlong() & k_CounterPuidMask);
        }

        /// <summary>
        /// The next random puid derived from CurrentSgPuidCounter.
        /// </summary>
        public static ulong NextSgPuid
        {
            get
            {
                return ((ulong)(Interlocked.Increment(ref CurrentSgPuidCounter)) & k_CounterPuidMask);
            }
        }

        public      DateTime            LastPulse               = DateTime.MinValue;       // time of last pulse sent to SG
        public      bool                bGotChallenged          = false; // set after SG sign in
        public      uint                SequenceRecv            = 1;       // XspRecv sequence number
        public      uint                SequenceXmit            = 1;       // XspSend sequence number
        public      DateTime            lastSendTime;
        public      DateTime            lastRecvTime;
        protected   uint                challengeNonce          = 0;

        // Purely for stress, stored here because on SgClients are multi-thread
        // safe in my stress client. Move along, nothing to see.
        public      double              timeToSendChalResponse  = 0;

        // Factories and cached items to speed things up
        public      XspPacketFactory            XspFactory;
        protected   QOS                         LastQOS = null;
        private     SecMsgPulse                 msgPulse = null;
        private     SecMsgDataPulse             msgDataPulse = null;
        private     SecMsgDataPulse_StateChange msgDataPulseStateChange = null;
        private     SecMsgChangeUsersReq        msgChangeUsers = null;
        private     SecMsgDelete                msgDelete = null;
        private     SecMsgNatDetReq             msgNatDetect = null;
        private     SecMsgXbToXbForward         msgXbToXbForward = null;
        private     SecMsgXbToXbForward2        msgXbToXbForward2 = null;
        private     SecMsgXbToSgChalResp2       msgChalResp = null;
        private     SecMsgXbToSgChalAck         msgChalAck = null;


        // Safety checks
        protected   ushort              OriginalPort;
        protected   uint                OriginalSpi;

        // Used to be in AuthContext, but really belong here as nothing else
        // outside of SgClient needs access to them.
        public KeyExchangeRequestPacket KeyexRequest        = null;     // set before SG sign in (key exchange)
        public KeyExchangeResponsePacket KeyexResult        = null;     // set after SG sign in (key exchange)


        /// <summary>
        /// Returns the elapsed time, in seconds, of the last successful round trip.  This of course
        /// relies on using a call that both sends and receives a packet, otherwise this value will be
        /// negative or undefined.
        /// </summary>
        public double LastRTT
        {
            get 
            {
                return (lastRecvTime - lastSendTime).TotalSeconds;
            }
        }

        public double SecondsElapsedSinceLastReceive
        {
            get
            {
                return (DateTime.Now - lastRecvTime).TotalSeconds;
            }
        }

        /// <summary>
        /// SPI of this client
        /// </summary>
        public virtual uint SPI
        {
            get 
            {
                if (this.KeyexRequest == null || this.KeyexRequest.keyexInit == null)
                    return 0;
                else
                    return this.KeyexRequest.keyexInit.SpiInit & XspHeader.XSP_SPI_MASK;
            }
        }

        /// <summary>
        /// The asynchronous challenge nonce, used for correspondence with SG
        /// </summary>
        public uint ChallengeNonce
        {
            get { return challengeNonce; }
            set { challengeNonce = value; }
        }

        /// <summary>
        /// Return the SGADDR of this client, known only after we have signed-in to the SG
        /// </summary>
        public virtual SGAddress SGADDR
        {
            get 
            {
                if (this.KeyexResult == null || this.KeyexResult.keyexResp == null)
                    return null;
                else
                    return this.KeyexResult.keyexResp.SGAddressInit;
            }
        }

        // 
        // Override the following settings for your tests, as appropriate
        //

        /// <summary>
        /// Use the SG IP address returned from the KDC or override it with our own, as specified in the
        /// stf.xml file?
        /// </summary>
        public bool bUseSgIpFromKDC     = false;

        /// <summary>
        /// Should we verify the keyex reply?  If we don't, the keys won't be stored, which means we
        /// can't send any SecMsg packets... but on the other hand, it will be faster
        /// </summary>
        public bool bVerifyKeyEx        = true;

        /// <summary>
        /// Only applies to user key exchanges (machine-only logons don't count). Requires 
        /// the presence or signature service, otherwise SG will throw an event.  With this enabled,
        /// the SG will send update messages to presence on the datacenter side of things. It may
        /// do more stuff as well..
        /// </summary>
        public bool bUseConnectionServices  = false;

        /// <summary>
        /// To get the TGS ticket, should we use the real XKDC or generate a fake ticket?
        /// TODO: port all tests that need the real KDC to set this to true
        /// </summary>
        public bool bUseRealXKDC = false;

        /// <summary>
        /// If true, sends a SecMsgDataPulse after in SignInSG.  If false, does not.
        /// </summary>
        public bool SendPulseAfterSignIn = true;

        /// <summary>
        /// Sets the real KDC client's behavior, only useful if bUseRealXKDC is true.
        /// </summary>
        public bool KDCEmulateClientBehavior = true;

        /// <summary>
        /// SG constructor.
        /// </summary>
        /// <param name="ctx">AuthContext state</param>
        /// <param name="ip">IP address of the SG server. May be null.</param>
        /// <param name="manualSetup">If false, use default values. If true, user will set all values.</param>
        public SgClient(AuthContext ctx, IPEndPoint ip, bool manualSetup)
            : base(ctx, ip, manualSetup)
        {
            Initialize(ctx);
        }

        public SgClient(AuthContext ctx)
            : base(ctx, null, false)
        {
            Initialize(ctx);
        }


        /// <summary>
        /// Common constructor code to intialize various members and member of AuthContext
        /// </summary>
        protected override void Initialize(AuthContext ctx)
        {
            // This may be overridden prior to this, or after this.. but at least set
            // some reasonable default.
//            if (base.ipServer == null)
//            {
//                base.ipServer = Global.XEnv.GetVirtualInterface(VirtualInterface.sgsvc);
//            }

            lastSendTime = DateTime.Now;
            lastRecvTime = DateTime.Now;
            SequenceRecv = 1;
            SequenceXmit = 1;
            XspFactory = new XspPacketFactory();

            KeyexRequest = null;
            KeyexResult = null;
        }

        /// <summary>
        /// Reset everything to valid default values. You should be able to sign in with 
        /// just these values.  Think of this as the most basic, simple, valid request possible.
        /// </summary>
        public static void SetDefaults(AuthContext ctx)
        {
            if (ctx.Site == null)
            {
                ctx.Site = SiteInfoManager.GetDefaultSgSite();
            }
        }


        // FakeSignInXkdc
        // SignInSG
        // SignOutSG
        // SetRequest
        // SimpleVerify
        #region SignIn, SignOut, Verify

        /// <summary>
        /// Prepares the context for building a fake ticket by setting a site and
        /// default authdata.  Useful for making custom modifications to the default authdata.
        /// </summary>
        public static void SetupForFakeSignInXkdc (AuthContext authContext)
        {
            if (authContext == null)
            {
                throw new ArgumentNullException("authContext");
            }

            if (authContext.Site == null)
            {
                // Occasionally during stress authContext.Site is null.. not sure why,
                // so let's just set the default.  
                authContext.Site = SiteInfoManager.GetDefaultSgSite();
                //throw new NullReferenceException("authContext.Site is null in FakeSignInXkdc");
            }

            if (authContext.Authdata == null)
            {
                authContext.Authdata = Authdata_Base.NewDefaultFromSite(authContext.Site);
                SetDefaultAuthdata(authContext, authContext.Authdata);
            }
        }

        /// <summary>
        /// Helper for calling the static method using the instance context.
        /// </summary>
        public void SetupForFakeSignInXkdc ()
        {
            SetupForFakeSignInXkdc(authContext);
        }

        /// <summary>
        /// If we aren't "signed in" to the XKDC, then we need to generate
        /// fake authdata and populate it with reasonable defaults.  You are
        /// free to do this before calling SignIn, as long as the ServiceContext
        /// is set, we will be "signed in" to the XKDC.
        /// </summary>
        public static void FakeSignInXkdc (AuthContext authContext)
        {
            SetupForFakeSignInXkdc(authContext);
            BuildFakeTicket(authContext, authContext.Authdata, authContext.Site.serverName, 
                authContext.Site.siteName, authContext.Site.siteKey);
        }

        /// <summary>
        /// Creates a fake XKDC ticket.
        /// </summary>
        public void FakeSignInXkdc ()
        {
            FakeSignInXkdc(authContext);
        }
        
        /// <summary>
        /// Sign out of the SG.
        /// </summary>
        public void SignOutSG()
        {
            if (isSignedIn)
            {
                SendDelete(SecMsgDelete.SHUTDOWN);   
            }
            KeyexResult = null;
            isSignedIn = false;
            ClearCache();
        }

        public void ClearCache()
        {
            this.msgPulse = null;
            this.msgDataPulse = null;
            this.msgDataPulseStateChange = null;
            this.msgChangeUsers = null;
            this.msgDelete = null;
            this.msgXbToXbForward = null;
            this.msgNatDetect = null;
            this.msgChalResp = null;
            this.msgChalAck = null;
            this.LastQOS = null;
            this.XspFactory.Reset();
            lastSendTime = DateTime.Now;
            lastRecvTime = DateTime.Now;
        }

        public void SetRequest(KeyExchangeRequestPacket request)
        {
            // Don't want to set defaults after doing this
            KeyexRequest = request;
            isManualSetup = true;
        }

         /// <summary>
        /// Do the key exchange with the SG and store the keys. Sign in with KDC if necessary.
        /// </summary>
        public void SignInSG() 
        { 
            isSignedIn = false;

            // Set defaults if necessary
            if (!isManualSetup)
            {
                SetDefaults(authContext);
            }

            // Sign in to the XKDC automagically
            if (!authContext.IsSignedInXkdc)
            {
                if (bUseRealXKDC)
                {
                    XkdcClient xkdc = new XkdcClient(authContext);
                    xkdc.EmulateClientRetryAndTimingBehavior = KDCEmulateClientBehavior;
                    xkdc.SignInXkdc();
                }
                else
                {
                    this.FakeSignInXkdc();
                }
            }

            // Construct the request packet
            if (KeyexRequest == null)
            {
                KeyexRequest = new KeyExchangeRequestPacket();
            }
            else
            {
                KeyexRequest.Reset();
            }

            // Set Connection Services if necessary
            if (bUseConnectionServices)  // && authContext.NumUsers > 0)
            {
                // If we're logging in with at least 1 user (versus a machine-only login), then we should
                // request connection services (CS).  This is required for the data pulses (such as
                // presence uses).
                KeyexRequest.keyexInit.wFlags = KeyExchangeInit.XSIF_CONNECTION_SERVICE;
            }

            // Use SG IP from XKDC?    
            if (bUseRealXKDC && bUseSgIpFromKDC)
            {
                this.ipServer = authContext.GetSGSiteIP();
            }
                // Overridden ip address from the site info?
            else if (authContext.Site.siteIp != null)
            {
                this.ipServer = authContext.Site.siteIp;
            }
            else if (base.ipServer == null)
            {
                base.ipServer = Global.XEnv.GetVirtualInterface(VirtualInterface.sgsvc);
            }

            // Build AP            
            // This must be done for every key exchange packet that is sent, or else the SG logs 
            // event #50052, EVENT_SG_REPLAYED_KERBEROS_AUTHENTICATOR.
            byte[] apData = BuildAP();

            // Assign result to the KeyexRequest packet
            KeyexRequest.keyexAPReq.Data = apData;

            // Send and receive
            lastSendTime = DateTime.Now;
            packet = (byte[])KeyexRequest;
            packetLength = packet.Length;

            // Split the send and receive so we can better control the receive.
            Send();

            // Recv it.  We might be sharing the socket, so keep retrying up to 
            // the timeout period.
            DateTime starttime = DateTime.Now;
            bool gotReply = false;
            int packetCount = 0;
            while ((DateTime.Now - starttime).TotalMilliseconds < TimeoutInMs && !gotReply)
            {
                Recv(TimeoutInMs);
                packetCount++;
                if (packetRecv == null)
                {
                    // TODO: warning, make sure this TGT gets cleaned up
                    throw new ServerTestFramework.Utilities.TimeoutException(String.Format("{0} -> {1}/{2} timed out in {3}ms", authContext.Udp.LocalIP.ToString(), authContext.Site.serverName, ipServer.ToString(), TimeoutInMs));
                }
                else if (packetRecvLength > 6)
                {
                    // Bytes 0-3 are the SPI
                    uint spi = (uint)(packetRecv[0] + (packetRecv[1] << 8) + (packetRecv[2] << 16) + (packetRecv[3] << 24));
                    short type = (short)(packetRecv[4] + (packetRecv[5] << 8));
                    if (spi == KeyexRequest.SPI && type == KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP)
                    {
                        gotReply = true;
                    }
                    else
                    {
                        //Global.RO.Debug("Sg.SignIn: Got [{0}] unknown packet of length {1}", packetCount, packetRecvLength);
                    }
                }
            }

            if (!gotReply)
            {
                throw new ServerTestFramework.Utilities.TimeoutException(String.Format("SG timed out after receiving {0} non-keyex-response packets", packetCount));
            }

            lastRecvTime = DateTime.Now;

            // Store IP and port used to initiate the connection
            //LocalPort = authContext.Udp.LocalIP.Port;

            // Process it
            if (KeyexResult == null)
            {
                KeyexResult = new KeyExchangeResponsePacket(KeyexRequest.SPI);
            }
            KeyexResult.ReadBytes(packetRecv, packetRecvLength);

            // TODO: process AP reply
#if false
            try
            {
                APRep = this.ProcessAPRequest(KeyexResult.keyexAPRep.Data, APReq);
            }
            catch (COMException)
            {
                // Swallow this, we seem to be having trouble with ProcessAPRequest, perhaps
                // I don't fully understand the packet structure.
                //Global.RO.Warn("KeyExchange: Got COM Exception: " + e.ToString());
            }
#endif

            // Have to reset the receive sequence number, otherwise we'll decrypt with the wrong IV and get
            // garbage packets.
            SequenceRecv = 1;
            SequenceXmit = 1;

            // Valid reply?
            if (bVerifyKeyEx)
            {
                SimpleVerify();

                // Decrypt the encrypted keyex response blob
                KeyexResult.keyexResp.Decrypt(authContext.SecKeys);

                // Save original port and spi for safety checks
                // no point in doing this if we haven't decrypted, so I moved it into this block
                OriginalPort = NetConstants.HTONS((ushort)KeyexResult.keyexResp.PortInit);  // flip bytes
                OriginalSpi = (uint)KeyexResult.keyexResp.SpiResp;

                // Note: it's important to verify the first block of data, to make sure 
                // the nonce (IV) is correct. After the first block, the cipher text is 
                // used as the IV, so all additional blocks should be ok. Yeesh.  We can 
                // do this for AES, but not really DES.

                SGAddress sgaddr = KeyexResult.keyexResp.SGAddressInit;
                uint expectedSpiSg = 0;
                ulong expectedXboxID = 0;
                if (bUseConnectionServices)
                {
                    // Only get an SGADDR when using CS, otherwise it is zeroed out.
                    expectedSpiSg = KeyexResult.keyexResp.SpiResp;
                    expectedXboxID = GetMachinePuid();
                }
               
                // why oh why isn't SpiSg a uint???
                if (((uint)sgaddr.SpiSg) != expectedSpiSg)
                {
                    throw new SGException(String.Format("SpiSg in SGADDR in (decrypted) keyex response does not match -- got 0x{0:X8}, expected 0x{1:X8}",
                                                        sgaddr.SpiSg, expectedSpiSg));
                }
                if (sgaddr.XboxID != expectedXboxID)
                {
                    throw new SGException(String.Format("XboxID in SGADDR in (decrypted) keyex response does not match -- got 0x{0:X16}, expected 0x{1:X16}",
                                                        sgaddr.XboxID, expectedXboxID));
                }
                if (KeyexResult.keyexResp.PadZero != 0)
                {
                    throw new SGException("PadZero in (decrypted) keyex response is not zero -- did you decrypt correctly?");
                }

                // check IP and port as seen by the SG, it should be the same as the local unless we are behind a router
                // the IP is compared against all local IPs, because the socket only returns 0.0.0.0
                // any local IP match is a good match
                IPEndPoint local_ep = Context.Udp.LocalIP;

                IPAddress seen_ip = new IPAddress(BitConverter.GetBytes(KeyexResult.keyexResp.IPInit.S_addr));
                bool ip_found = false;

                NetworkInterface[] netIntList = NetworkInterface.GetAllNetworkInterfaces();
                foreach (NetworkInterface curNetInt in netIntList)
                {
                    //Global.RO.Debug("'{1}' {0}", curNetInt.Id, curNetInt.Name);
                    //Global.RO.Debug(" Descr: {0}", curNetInt.Description);
                    IPInterfaceProperties ipInt = curNetInt.GetIPProperties();
                    UnicastIPAddressInformationCollection unicastAddrList = ipInt.UnicastAddresses;
                    foreach (UnicastIPAddressInformation curAddr in unicastAddrList)
                    {
                        //Global.RO.Debug(" Addr: {0}", curAddr.Address);
                        if (curAddr.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork &&
                            seen_ip.Equals(curAddr.Address))
                        {
                            ip_found = true;
                            break;
                        }
                    }
                }

                if (!ip_found)
                {
                    throw new SGException("IP address in keyex response (as seen by the SG) does not match any local address: {0}",
                        KeyexResult.keyexResp.IPInit);
                }

                if (OriginalPort != local_ep.Port)
                {
                    throw new SGException("Port in keyex response (as seen by the SG) does not match local: {0} != {1}",
                        OriginalPort, local_ep.Port);
                }

                // If there is a keyex challenge here, decrypt it
                if (KeyexResult.keyexChal != null)
                    KeyexResult.keyexChal.Decrypt(authContext.SecKeys);
            }

            // Send heartbeat back to acknowledge
            if (SendPulseAfterSignIn)
            {
                this.SendDataPulse();
            }

            isSignedIn = true;
        }


        /// <summary>
        /// Quickly verify that the key exchange succeeded
        /// </summary>
        /// <param name="result"></param>
        public void SimpleVerify()
        {
            // Verify authContext.KeyexResult for null
            if (KeyexResult == null)
            {
                throw new SGNoReplyException("KeyexResult is null, expected a value");
            }

            // Verify packet return type
            if (KeyexResult.keyexResp.Type != KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP)
            {
                throw new SGException("Incorrect packet type in key exchange response, type={0}", KeyexResult.keyexResp.Type);
            }

            // Verify SPI
            if (KeyexRequest.keyexInit.SpiInit != KeyexResult.keyexResp.SpiInit)
            {
                throw new SGException("SPI mismatch in KeyExchange response, RequestSPI=0x{0:X}, ResponseSPI=0x{1:X}", KeyexRequest.keyexInit.SpiInit, KeyexResult.keyexResp.SpiInit);
            }

            // Verify nonce
            byte[] nonce1 = KeyexRequest.keyexInit.NonceInit;
            byte[] nonce2 = KeyexResult.keyexResp.NonceInit;
            for (int i = 0; i < nonce1.Length; i++)
            {
                if (nonce1[i] != nonce2[i])
                {
                    throw new SGException("Nonce mismatch in KeyExchange response, RequestNonce={0}, ResponseNonce={1}",
                        Hexer.tohex(nonce1),
                        Hexer.tohex(nonce2));
                }
            }

            // Verify if we got challenged
            if (KeyexResult.keyexChal != null && 
                KeyexResult.keyexChal.Type == KeyExchangeHeader.KEYEX_TYPE_SGTOXB_CHAL &&
                KeyexResult.keyexChal.cbEnt > KeyExchangeSgToXbChallenge.SIZE)
            {
                Global.RO.Debug("We got challenged by the SG, code chal size = {0}", (KeyexResult.keyexChal.ChalCode != null ? KeyexResult.keyexChal.ChalCode.Length : 0));
                this.bGotChallenged = true;
            }

            // Key exchange looks good, store the keys
            authContext.SecKeys = new SecReg(true, KeyexResult, authContext.GetSessionKey());

        }

        
        #endregion

        // BuildAP
        // SetDefaultAuthdata (Xenon)
        // SetDefaultAuthdata (Xbox2)
        // BuildFakeTicket
        #region Packet build functions

        /// <summary>
        /// Build the Kerberos AP portion of the key exchange request packet
        /// </summary>
        /// <returns></returns>
        protected byte[] BuildAP()
        {
            return KeyexRequest.BuildAP(authContext);
        }

        public void SetDefaultAuthdata(Authdata_Base ad)
        {
            SetDefaultAuthdata(authContext, ad);
        }

        public static void SetDefaultAuthdata (AuthContext authContext, Authdata_Base ad)
        {
            if (ad.IsXenon2)
                SetDefaultAuthdata(authContext, ad as Authdata_Xenon2);
            else if (ad.IsXbox2)
                SetDefaultAuthdata(authContext, ad as Authdata_Xbox2);
            else if (ad.IsXenon)
                SetDefaultAuthdata(authContext, ad as Authdata_Xenon);
            else
                throw new Exception("Unknown authdata type");
        }

        public static void SetDefaultAuthdata(AuthContext authContext, Authdata_Xenon ad)
        {
            int i;

            // Version and size
            ad.wAuthDataVersion = 3;
            ad.wAuthDataSize = Authdata_Xenon.SIZE;
            ad.wMajorVersion = 0xF;
            ad.wMinorVersion = 0xF;
            ad.wBuildNumber = 0x0000;
            ad.wQFENumber = 0x00;

            // Client type
            switch (authContext.ClientType)
            {
                case AuthContext.ClientTypes.Xbox:
                    ad.dwAuthDataFlags = 0;
                    break;
                case AuthContext.ClientTypes.Xenon:
                    ad.dwAuthDataFlags = Authdata_Xenon.FLAGS_ISXENON;
                    break;
                case AuthContext.ClientTypes.XenonBackCompat:
                    ad.dwAuthDataFlags = Authdata_Xenon.FLAGS_ISXENONBACKCOMPAT;
                    break;
                case AuthContext.ClientTypes.Panorama:
                    ad.dwAuthDataFlags = 0;
                    break;
            }

            // Make a super fake session key
            byte[] defKey = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
            Array.Copy(defKey, ad.abKey, ad.abKey.Length);

            // Title info
            if (authContext.TitleInfo != null)
            {
                ad.dwTitleID = authContext.TitleInfo.TitleId;
                ad.dwTitleVersion = authContext.TitleInfo.TitleVersion;
                ad.dwTitleRegion = authContext.TitleInfo.TitleGameRegion;
                ad.wMajorVersion = authContext.TitleInfo.MajorVersion;
                ad.wMinorVersion = authContext.TitleInfo.MinorVersion;
                ad.wBuildNumber = authContext.TitleInfo.BuildNumber;
                ad.wQFENumber = authContext.TitleInfo.QFENumber;
            }
            else
            {
                ad.dwTitleID = 0xC0FE0800;
                ad.dwTitleVersion = 1;
                ad.dwTitleRegion = 1;
            }

            GetNewMachine(authContext, ad);

            // User puids and flags, make up something unique-ish
            ad.users = new XUserID[4];
            for (i = 0; i < 4; i++)
            {
                ad.users[i] = new XUserID();
                if (authContext.NumUsers > 0 && authContext.Users[i] != null)
                {
                    // If authcontext doesn't specify a user puid, make up a unique one
                    if (authContext.Users[i].xuid.qwUserID == 0)
                    {
                        ulong puid = NextSgPuid | k_UserPuidMask;
                        ad.users[i].qwUserID = puid;
                        // Reverse set the user puid in the authcontext
                        authContext.Users[i].xuid.qwUserID = ad.users[i].qwUserID;
                    }
                    else
                    {
                        // Otherwise let's just use the provided user puid
                        ad.users[i].qwUserID = authContext.Users[i].xuid.qwUserID;
                    }

                    // If authcontext doesn't specify a userflags, use default
                    if (authContext.Users[i].xuid.dwUserFlags == 0)
                    {
                        // typical user flags: 	0x0260676c
                        ad.users[i].dwUserFlags = 0x0260676c;
                        // Reverse set the user flags in the authcontext
                        authContext.Users[i].xuid.dwUserFlags = ad.users[i].dwUserFlags;
                    }
                    else
                    {
                        // Otherwise let's just use the provided user flags
                        ad.users[i].dwUserFlags = authContext.Users[i].xuid.dwUserFlags;
                    }
                }

            }

            // Typical services dwPrivileges[0]: 
            // mach logon: 00000000 00100100 00011010 10111100 (0x00241ABC)
            // user logon: 00000000 00101101 00111011 11111110 (0x002D3BFE)
            // Typical privileges dwPrivileges[7]:
            // user logon: 11111111 11111100 00000000 00000000 (0xfffc0000)
            //
            // Also grant access to service 28 (Test FD Service)
            if (authContext.NumUsers > 0)
            {
                ad.dwPrivileges[0] = 0x102d3bfe;
                ad.dwPrivileges[1] = 0x00000001;
                ad.dwPrivileges[7] = 0xfffc0000;
                ad.wNumPrivileges = 32;  // count 'em, if you don't believe me
            }
            else
            {
                ad.dwPrivileges[0] = 0x10241abc;
                ad.dwPrivileges[1] = 0x00000001;
                ad.dwPrivileges[7] = 0x00000000;
                ad.wNumPrivileges = 12;  // count 'em, if you don't believe me
            }

            if (authContext.IsLspContext)
            {
                // Plus change the default title id if one is not specified
                if (authContext.TitleInfo == null)
                {
                    ad.TitleId = 0xFFFF0072;
                }

                // Plus give the default LSP service id
                // By default, grant access to the SG test throughput service
                for (i = 0; i < ad.dwServiceID.Length; i++)
                {
                    if (ad.dwServiceID[i] == 0)
                    {
                        ad.dwServiceID[i] = 0xFFFF0072;
                        ad.wNumDwordServices++;
                        break;
                    }
                }
            }
        }

        public static void SetDefaultAuthdata(AuthContext authContext, Authdata_Xenon2 ad)
        {
            int i;

            // Version and size
            ad.wAuthDataVersion = 4;
            ad.wAuthDataSize = Authdata_Xenon2.SIZE;
            ad.wMajorVersion = 0xF;
            ad.wMinorVersion = 0xF;
            ad.wBuildNumber = 0x0000;
            ad.wQFENumber = 0x00;

            // Client type
            switch (authContext.ClientType)
            {
                case AuthContext.ClientTypes.Xbox:
                    ad.dwAuthDataFlags = 0;
                    break;
                case AuthContext.ClientTypes.Xenon:
                    ad.dwAuthDataFlags = Authdata_Xenon2.FLAGS_ISXENON;
                    break;
                case AuthContext.ClientTypes.XenonBackCompat:
                    ad.dwAuthDataFlags = Authdata_Xenon2.FLAGS_ISXENONBACKCOMPAT;
                    break;
                case AuthContext.ClientTypes.Panorama:
                    ad.dwAuthDataFlags = 0;
                    break;
            }

            // Make a super fake session key
            byte[] defKey = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
            Array.Copy(defKey, ad.abKey, ad.abKey.Length);

            // Title info
            if (authContext.TitleInfo != null)
            {
                ad.dwTitleID = authContext.TitleInfo.TitleId;
                ad.dwTitleVersion = authContext.TitleInfo.TitleVersion;
                ad.dwTitleRegion = authContext.TitleInfo.TitleGameRegion;
                ad.wMajorVersion = authContext.TitleInfo.MajorVersion;
                ad.wMinorVersion = authContext.TitleInfo.MinorVersion;
                ad.wBuildNumber = authContext.TitleInfo.BuildNumber;
                ad.wQFENumber = authContext.TitleInfo.QFENumber;
            }
            else
            {
                ad.dwTitleID = 0xC0FE0800;
                ad.dwTitleVersion = 1;
                ad.dwTitleRegion = 1;
            }

            GetNewMachine(authContext, ad);

            // User puids and flags, make up something unique-ish
            ad.users = new XUserID[4];
            for (i = 0; i < 4; i++)
            {
                ad.users[i] = new XUserID();
                if (authContext.NumUsers > 0 && authContext.Users[i] != null)
                {
                    // If authcontext doesn't specify a user puid, make up a unique one
                    if (authContext.Users[i].xuid.qwUserID == 0)
                    {
                        ulong puid = NextSgPuid | k_UserPuidMask;
                        ad.users[i].qwUserID = puid;
                        // Reverse set the user puid in the authcontext
                        authContext.Users[i].xuid.qwUserID = ad.users[i].qwUserID;
                    }
                    else
                    {
                        // Otherwise let's just use the provided user puid
                        ad.users[i].qwUserID = authContext.Users[i].xuid.qwUserID;
                    }

                    // If authcontext doesn't specify a userflags, use default
                    if (authContext.Users[i].xuid.dwUserFlags == 0)
                    {
                        // typical user flags: 	0x0260676c
                        ad.users[i].dwUserFlags = 0x0260676c;
                        // Reverse set the user flags in the authcontext
                        authContext.Users[i].xuid.dwUserFlags = ad.users[i].dwUserFlags;
                    }
                    else
                    {
                        // Otherwise let's just use the provided user flags
                        ad.users[i].dwUserFlags = authContext.Users[i].xuid.dwUserFlags;
                    }
                }

            }

            // Typical services dwPrivileges[0]: 
            // mach logon: 00000000 00100100 00011010 10111100 (0x00241ABC)
            // user logon: 00000000 00101101 00111011 11111110 (0x002D3BFE)
            // Typical privileges dwPrivileges[7]:
            // user logon: 11111111 11111100 00000000 00000000 (0xfffc0000)
            //
            // Also grant access to service 28 (Test FD Service)
            if (authContext.NumUsers > 0)
            {
                ad.SetPrivileges(new uint[] { 0x102d3bfe, 0x00000001, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfffc0000 });
            }
            else
            {
                ad.SetPrivileges(new uint[] { 0x10241abc, 0x00000001, 0x0, 0x0, 0x0, 0x0, 0x0, 0x00000000 });
            }

            // add a flowtoken value
            ad.flowToken = xonline.common.service.Floken.NewFloken().FlowToken;

            if (authContext.IsLspContext)
            {
                // Plus change the default title id if one is not specified
                if (authContext.TitleInfo == null)
                {
                    ad.TitleId = 0xFFFF0072;
                }

                // Plus give the default LSP service id
                // By default, grant access to the SG test throughput service
                ad.AddExtendedService(0xFFFF0072);
            }
        }

        /// <summary>
        /// Puts a new machine puid in the authdata.
        /// </summary>
        public static void GetNewMachine(AuthContext authContext, Authdata_Base ad)
        {
            // Machine puid, make up something unique-ish
            ulong box_puid = NextSgPuid;
            if (authContext.IsXenonConsole)
            {
                ad.XboxID = box_puid | k_XenonMachinePuidMask;
            }
            else if (authContext.IsPanorama)
            {
                ad.XboxID = box_puid | k_PanoramaMachinePuidMask;
            }
            else
            {
                ad.XboxID = box_puid | k_XboxMachinePuidMask;
            }
        }

        /// <summary>
        /// Puts a new machine puid in the authdata.
        /// </summary>
        public void GetNewMachine()
        {
            GetNewMachine(authContext, authContext.Authdata);
        }

        /// <summary>
        /// Construct reasonable authdata info for use when building fake TGS tickets.
        /// This is for the legacy Authdata version 2 format.
        /// </summary>
        public static void SetDefaultAuthdata (AuthContext authContext, Authdata_Xbox2 ad)
        {
            // Version and size
            ad.wAuthDataVersion = 2;
            ad.wAuthDataSize = Authdata_Xbox2.SIZE;

            // Make a super fake session key
            byte[] defKey = new byte[] { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 };
            Array.Copy(defKey, ad.abKey, ad.abKey.Length);

            // Title info
            if (authContext.TitleInfo != null)
            {
                ad.dwTitleID = authContext.TitleInfo.TitleId;
                ad.dwTitleVersion = authContext.TitleInfo.TitleVersion;
                ad.dwTitleRegion = authContext.TitleInfo.TitleGameRegion;
                ad.wMajorVersion = authContext.TitleInfo.MajorVersion;
                ad.wMinorVersion = authContext.TitleInfo.MinorVersion;
                ad.wBuildNumber = authContext.TitleInfo.BuildNumber;
                ad.wQFENumber = authContext.TitleInfo.QFENumber;
            }
            else
            {
                ad.dwTitleID = 0xFFC0FE00;
                ad.dwTitleVersion = 1;
                ad.dwTitleRegion = 1;
                ad.wMajorVersion = 0xF;
                ad.wMinorVersion = 0xF;
                ad.wBuildNumber = 0xFFFF;
                ad.wQFENumber = 0x0;
            }

            // Machine puid, make up something unique-ish
            ulong box_puid = NextSgPuid;
            if (authContext.IsXenonConsole)
                ad.qwXboxID = box_puid | k_XenonMachinePuidMask;
            else if (authContext.IsPanorama)
                ad.qwXboxID = box_puid | k_PanoramaMachinePuidMask;
            else
                ad.qwXboxID = box_puid | k_XboxMachinePuidMask;

            // User puids and flags, make up something unique-ish
            ad.users = new XUserID[4];
            for (int i = 0; i < 4; i++)
            {
                ad.users[i] = new XUserID();
                if (authContext.NumUsers > 0 && authContext.Users[i] != null)
                {
                    if (authContext.Users[i].xuid.qwUserID != 0)
                    {
                        ulong puid = NextSgPuid | k_UserPuidMask;
                        ad.users[i].qwUserID = puid;
                        authContext.Users[i].xuid.qwUserID = puid;
                    }
                    else
                    {
                        ad.users[i].qwUserID = authContext.Users[i].xuid.qwUserID;
                    }
                }

            }

            // services
            // Give them presence and stats by default
            ad.dwNumServices = 4;
            ad.dwServiceID[0] = (uint)XOService.PresNotification;
            ad.dwServiceID[1] = (uint)XOService.Stats;
            ad.dwServiceID[2] = (uint)SGFakeService.TEST_SERVICE_ID;
            // Also grant access to service 28 (Test FD Service)
            ad.dwServiceID[3] = (uint)28;

            if (authContext.IsLspContext)
            {
                // Plus change the default title id if one is not specified
                if (authContext.TitleInfo == null)
                {
                    ad.TitleId = 0xFFFF0072;
                }

                // Plus give the default LSP service id
                // By default, grant access to the SG test throughput service
                ad.dwNumServices = 2;
                ad.dwServiceID[0] = (uint)SGFakeService.TEST_SERVICE_ID;
                ad.dwServiceID[1] = (uint)0xFFFF0072;  // Testnet LSP service
                ad.dwServiceID[2] = 0;
            }
        }

        #region BuildFakeTicket

        public void BuildFakeTicket(Authdata_Base authdata)
        {
            if (authContext.Site == null)
                BuildFakeTicket(authContext,
                                authdata, 
                                "sg", 
                                "site1", 
                                authContext.k_XboxKerberosRealm, 
                                authContext.k_PassportKerberosRealm, 
                                authContext.k_TicketClientName1, 
                                authContext.k_TicketClientName2, 
                                ServiceKeys.GetServiceKey(ServiceKeys.Key_SG, "sg", "site1"));
            else
                BuildFakeTicket(authContext,
                                authdata, 
                                authContext.Site.serverName, 
                                authContext.Site.siteName, 
                                authContext.k_XboxKerberosRealm, 
                                authContext.k_PassportKerberosRealm, 
                                authContext.k_TicketClientName1, 
                                authContext.k_TicketClientName2, 
                                authContext.Site.siteKey);
        }


        public void BuildFakeTicket(Authdata_Base authdata, string serverName, string siteName, byte[] siteKey)
        {
            BuildFakeTicket(authContext,
                            authdata, 
                            serverName, 
                            siteName, 
                            authContext.k_XboxKerberosRealm, 
                            authContext.k_PassportKerberosRealm, 
                            authContext.k_TicketClientName1, 
                            authContext.k_TicketClientName2, 
                            siteKey);
        }

        public void BuildFakeTicket (
            Authdata_Base authdata,
            string serverName,
            string siteName,
            string ticketRealm,
            string clientRealm,
            string clientName1,
            string clientName2,
            byte[] siteKey)
        {
            BuildFakeTicket(authContext, authdata, serverName, siteName, ticketRealm, clientRealm, clientName1,
                clientName2, siteKey);
        }

        public static void BuildFakeTicket (AuthContext authContext, Authdata_Base authdata, string serverName, 
            string siteName, byte[] siteKey)
        {
            BuildFakeTicket(authContext, authdata, serverName, siteName,
                            authContext.k_XboxKerberosRealm,
                            authContext.k_PassportKerberosRealm,
                            authContext.k_TicketClientName1,
                            authContext.k_TicketClientName2,
                            siteKey);
        }
        
        public static void BuildFakeTicket(
            AuthContext authContext,
            Authdata_Base authdata, 
            string serverName, 
            string siteName, 
            string ticketRealm, 
            string clientRealm, 
            string clientName1, 
            string clientName2, 
            byte[] siteKey)
        {
            try
            {
                byte[] authdatabytes = (byte[])authdata;
                if (authContext.IsXenonTitle || authContext.IsPanorama)
                {
                    // XENON
                    if (authContext.ServiceCtxXe == null)
                    {
                        authContext.ServiceCtxXe = new ServiceContextXe();
                    }
                    else if (authContext.ServiceCtxXe.Ticket == null)
                    {
                        authContext.ServiceCtxXe.Ticket = new byte[ServiceContextXe.XONLINE_MAX_TICKET_LENGTH];
                    }

                    // Reset length
                    authContext.ServiceCtxXe.dwTicketLength = (uint)authContext.ServiceCtxXe.Ticket.Length;

                    // Ensure session key in authdata matches the session key used to encrypt the AP
                    authContext.ServiceCtxXe.SessionKey = authdata.Key;

                    AuthClientBase.DLL_BuildTicketTgs(
                        authdatabytes,
                        serverName,
                        siteName,
                        ticketRealm,
                        clientRealm,
                        clientName1,
                        clientName2,
                        authContext.ServiceCtxXe.SessionKey,
                        siteKey,
                        authContext.TicketLifetimeInMS * 10000, // This api needs time in 100 nanosecond intervals
                        authContext.ServiceCtxXe.Ticket,
                        out authContext.ServiceCtxXe.dwTicketLength);

                    // BuildApRequest requires the following fields in the ServiceContext
                    //   SessionKey
                    //   Ticket
                    //   dwTicketLength
                    //   ClientName
                    //   ClientRealm
                    // We just set Ticket and dwTicketLength.  I think ClientName and ClientRealm 
                    // get ignored.  SessionKey is used to encrypted the authenticator in the AP 
                    // request; it is also encrypted inside the TGS ticket. Thus they had better
                    // match.  

                    // Typical ClientName: "2\0XE.179811164334@xbox.com\0PASSPORT.NET"
                    // Typical ClientRealm: "PASSPORT.NET"
                }
                else
                {
                    // XBOX
                    if (authContext.ServiceCtxXbox == null)
                    {
                        authContext.ServiceCtxXbox = new ServiceContextXbox();
                    }
                    else if (authContext.ServiceCtxXbox.Ticket == null)
                    {
                        authContext.ServiceCtxXbox.Ticket = new byte[ServiceContextXbox.XONLINE_MAX_TICKET_LENGTH];
                    }
                    // Reset length
                    authContext.ServiceCtxXbox.dwTicketLength = (uint)authContext.ServiceCtxXbox.Ticket.Length;

                    // Ensure session key in authdata matches the session key used to encrypt the AP
                    authContext.ServiceCtxXbox.SessionKey = authdata.Key;

                    AuthClientBase.DLL_BuildTicketTgs(
                        authdatabytes,
                        serverName,
                        siteName,
                        ticketRealm,
                        clientRealm,
                        clientName1,
                        clientName2,
                        authContext.ServiceCtxXbox.SessionKey,
                        siteKey,
                        authContext.TicketLifetimeInMS * 10000, // This api needs time in 100 nanosecond intervals
                        authContext.ServiceCtxXbox.Ticket,
                        out authContext.ServiceCtxXbox.dwTicketLength);
                    
                    // BuildApRequest requires the following fields in the ServiceContext
                    // SessionKey
                    // Ticket
                    // dwTicketLength
                    // ClientName
                    // ClientRealm

                }
            }
            finally
            {
                SpewKerbclientDebug();
            }

        #endregion

        }


        #endregion

        // XspSendAdjustSize
        // XspSend
        // XspResend
        // XspSendData
        // XspRecv
        // SecMsgRecv
        #region XspSend and XspRecv functions

        /// <summary>
        /// Verify the port we initiated the connection with is still being used
        /// </summary>
        protected void CheckPortAndSpi(XspPacket xsp)
        {
            if (KeyexResult == null || KeyexResult.keyexResp == null)
                return;

            // Check current SPI with authContext SPI
            if (xsp.SpiHeader.GetSpi() != authContext.SecKeys.SpiRecv)
            {
                throw new SGException("CheckPortAndSpi: keys.SpiRecv 0x{0:X} does not match XSP spi 0x{1:X}",
                    authContext.SecKeys.SpiRecv,
                    xsp.SpiHeader.GetSpi());
            }

            // Check current port with original port
            // Remember to flip the bytes
            if (authContext.Udp.LocalIP.Port != OriginalPort)
            {
                throw new SGException("CheckPortAndSpi: original port {0} does not match current port {1}",
                    (ushort)OriginalPort,
                    (ushort)authContext.Udp.LocalIP.Port);
            }

            // Check current SPI with original SPI
            if (xsp.SpiHeader.GetSpi() != OriginalSpi)
            {
                throw new SGException("CheckPortAndSpi: original SPI 0x{0:X} does not match XSP spi 0x{1:X}",
                    OriginalSpi,
                    xsp.SpiHeader.GetSpi());
            }
            

        }

        /// <summary>
        /// Sends an encrypted XSP packet, but allows the caller to adjust the number of bytes sent.  Used only for 
        /// testing.
        /// </summary>
        /// <param name="message">A SecMsg* packet converted to a byte array</param>
        /// <param name="extraBytes">Extra bytes to send.  May be positive or negative.</param>
        public XspPacket XspSendAdjustSize(byte[] message, int extraBytes)
        {
            MemoryStream ms = new MemoryStream(message.Length + extraBytes);
            if (extraBytes <= 0)
            {
                ms.Write(message, 0, message.Length + extraBytes);
            }
            else
            {
                byte[] junk = new byte[extraBytes];
                ms.Write(message, 0, message.Length);
                ms.Write(junk, 0, extraBytes);
            }

            if (!IsSignedIn)
            {
                throw new SGException("Unable to send, please sign in to the SG first");
            }
            XspPacket xsp = new XspPacket(ms.ToArray(), this.authContext.SecKeys, this.SequenceXmit++);
            CheckPortAndSpi(xsp);
            lastSendTime = DateTime.Now;
            xsp.Send(ipServer, authContext.Udp);
            return xsp;
        }

        /// <summary>
        /// Sends an encrypted SECMSG* XSP packet to the SG.
        /// </summary>
        /// <param name="msg">A SecMsg* packet.</param>
        public XspPacket XspSend(SecMsgHeader msg)
        {
            if (!IsSignedIn)
            {
                throw new SGException("Unable to send, please sign in to the SG first");
            }
            //XspPacket xsp = new XspPacket(msg, this.authContext.SecKeys, this.SequenceXmit++);
            XspPacket xsp = XspFactory.Get(msg, this.authContext.SecKeys, this.SequenceXmit++);
            CheckPortAndSpi(xsp);
            lastSendTime = DateTime.Now;
            xsp.Send(ipServer, authContext.Udp);
            return xsp;
        }

        /// <summary>
        /// Sends an encrypted SECMSG* XSP packet to the SG.
        /// </summary>
        /// <param name="msg">A SecMsg* packet.</param>
        public XspPacket XspSend(byte[] msgBytes)
        {
            if (!IsSignedIn)
            {
                throw new SGException("Unable to send, please sign in to the SG first");
            }
            //XspPacket xsp = new XspPacket(msgBytes, this.authContext.SecKeys, this.SequenceXmit++);
            XspPacket xsp = XspFactory.Get(msgBytes, this.authContext.SecKeys, this.SequenceXmit++);
            CheckPortAndSpi(xsp);
            lastSendTime = DateTime.Now;
            xsp.Send(ipServer, authContext.Udp);
            return xsp;
        }

        /// <summary>
        /// Sends an encrypted XSP packet to the SG, does not change the packet at all before sending.
        /// </summary>
        /// <param name="xsp">The packet to send.</param>
        public void XspSend (XspPacket xsp)
        {
            if (!IsSignedIn)
            {
                throw new SGException("Unable to send, please sign in to the SG first");
            }

            CheckPortAndSpi(xsp);
            lastSendTime = DateTime.Now;
            xsp.Send(ipServer, authContext.Udp);
        }

        /// <summary>
        /// Resends an XSP packet. All this really has to do is increment the sequence number
        /// and re-encrypt the packet. 
        /// </summary>
        /// <param name="xsp"></param>
        /// <param name="msgBytes"></param>
        /// <returns></returns>
        public XspPacket XspResend(XspPacket xsp, byte[] msgBytes)
        {
            if (!IsSignedIn)
            {
                throw new SGException("Unable to send, please sign in to the SG first");
            }
            xsp.SequenceNumber = this.SequenceXmit++;
            xsp.Encrypt(msgBytes);
            CheckPortAndSpi(xsp);
            lastSendTime = DateTime.Now;
            xsp.Send(ipServer, authContext.Udp);
            return xsp;
        }

        /// <summary>
        /// Sends an encrypted XSP packet.  Used for sending data through the SG to a service.
        /// You should probably stick to XSP_TYPE_UDP_2 for now.
        /// </summary>
        /// <param name="message">A non-SecMsg* packet converted to a byte array.</param>
        public XspPacket XspSendData(byte[] message, uint xspType, ushort srcPort, ushort dstPort)
        {
            if (!IsSignedIn)
            {
                throw new SGException("Unable to send, please sign in to the SG first");
            }
            if (dstPort == 0)
            {
                Global.RO.Warn("[SgClient] XspSendData is sending to port 0, the SG is going to toss this");
            }
            //XspPacket xsp = new XspPacket(message, xspType, srcPort, dstPort, this.authContext.SecKeys, this.SequenceXmit++);
            XspPacket xsp = XspFactory.Get(message, xspType, srcPort, dstPort, this.authContext.SecKeys, this.SequenceXmit++);
            CheckPortAndSpi(xsp);
            lastSendTime = DateTime.Now;
            xsp.Send(ipServer, authContext.Udp);
            return xsp;
        }

        /// <summary>
        /// Receives anything, useful for clearing out the incoming buffer without bothering to
        /// decrypt the packet or do anything with it.
        /// </summary>
        /// <param name="timeout"></param>
        /// <returns></returns>
        public byte[] AnyRecv(int timeout, out int replysize)
        {
            byte[] reply = authContext.Udp.RecvFast(timeout, out replysize);
            if (replysize > 0)
                lastRecvTime = DateTime.Now;
            return reply;
        }

        /// <summary>
        /// Receives an encrypted XSP packet from the SG.  
        /// </summary>
        /// <param name="timeout">Time out, in milliseconds, to wait for a reply.</param>
        /// <returns>The decrypted byte array, can be turned into a SecMsg* packet</returns>
        public XspPacket XspRecv(int timeout)
        {
            if (authContext.SecKeys == null)
            {
                throw new SGException("No keys have been stored - did you successfully complete a key exchange?");
            }

            //XspPacket xsp = new XspPacket(authContext.SecKeys);
            XspPacket xsp = XspFactory.Get(this.authContext.SecKeys, this.SequenceRecv);
            if (xsp.Recv(timeout, authContext.Udp) == null)
            {
                return null;
                // or throw exception??
            }
            // Read out the sequence number; we should know the high word but the low word is in the packet.
            this.SequenceRecv = xsp.SequenceNumber;
            lastRecvTime = DateTime.Now;
            return xsp;
        }

        /// <summary>
        /// If you are expecting a SecMsg* packet back, use this shortcut function
        /// </summary>
        /// <param name="timeout"></param>
        /// <returns></returns>
        public SecMsgHeader SecMsgRecv(int timeout)
        {
            XspPacket xsp = XspRecv(timeout);
            if (xsp == null)
            {
                return null;
            }
            return xsp.SecMsg;
        }
        /// <summary>
        /// If you are expecting a specific SecMsg* packet back, use this shortcut function.
        /// This should guarantee you get your desired packet back while tossing out the other
        /// things.
        /// </summary>
        /// <param name="timeout"></param>
        /// <returns></returns>
        public SecMsgHeader SecMsgRecv(int timeout, short secmsgType)
        {
            DateTime start = DateTime.Now;
            while ((DateTime.Now - start).TotalMilliseconds < timeout)
            {
                SecMsgHeader hdr = SecMsgRecv(timeout);
                if (hdr == null)
                {
                    //Global.RO.Warn("[SG] Timed out waiting for SecMsg reply or got non-secmsg message");
                    //return null;
                    continue;
                }
                else if (hdr.Type == secmsgType)
                {
                    // Got it
                    return hdr;
                }
                else
                {
                    // Got something else, probably a PULSE, let's try again
                    Global.RO.Debug("[SG] Got SecMsg of wrong type 0x{0:X}, trying again for {1}ms",
                        hdr.Type,
                        (int)(timeout - (DateTime.Now - start).TotalMilliseconds));
                }
            }
            return null;
        }

        public XspPacket XspCreate(byte[] buffer, int bufferSize)
        {
            if (SequenceRecv > 0xFFFF)
            {
                int a = 0;
                a++;
            }
            XspPacket xsp = XspFactory.Get(this.authContext.SecKeys, this.SequenceRecv);
            xsp.ReadBytes(buffer, bufferSize);
            this.SequenceRecv = xsp.SequenceNumber;
            return xsp;
        }

        #endregion

        // SendPulse
        // SendDataPulse
        // SendDataPulseTitleChange
        // SendDelete
        // SendQOS
        // SendChangeUsers
        // SendNatDetect
        // SendChalResponse
        // SendChalAck
        #region XSP message send functions

        /// <summary>
        /// Send a SECMSG_TYPE_PULSE packet
        /// </summary>
        public void SendPulse()
        {
            if (msgPulse == null)
                msgPulse = new SecMsgPulse();
            XspSend(msgPulse);
        }

        /// <summary>
        /// Send a SECMSG_TYPE_XBTOSG_PULSE data pulse packet with no data
        /// </summary>
        public void SendDataPulse()
        {
            if (msgDataPulse == null)
                msgDataPulse = new SecMsgDataPulse();
            XspSend(msgDataPulse);
        }

        /// <summary>
        /// Send a SECMSG_TYPE_XBTOSG_PULSE data pulse packet with a state change message attached
        /// </summary>
        /// <param name="newState"></param>
        public void SendDataPulseStateChange(uint newState)
        {
            SendDataPulseStateChange(newState, GetFirstUserPuid());
        }

        /// <summary>
        /// Send a SECMSG_TYPE_XBTOSG_PULSE data pulse packet with a state change message attached
        /// </summary>
        /// <param name="newState"></param>
        public void SendDataPulseStateChange(uint newState, ulong userpuid1)
        {
            if (msgDataPulseStateChange == null)
                msgDataPulseStateChange = new SecMsgDataPulse_StateChange();

            msgDataPulseStateChange.UserPuid = userpuid1;
            msgDataPulseStateChange.State = newState;
            XspSend(msgDataPulseStateChange);
        }

        /// <summary>
        /// Send a SECMSG_TYPE_XBTOSG_PULSE data pulse packet with a title change message attached
        /// </summary>
        public void SendDataPulseTitleChange(uint newTitleId)
        {
            // Question: should we update the SGClient's TitleID at this point?

            SecMsgDataPulse_TitleChange msg = new SecMsgDataPulse_TitleChange();

            // Need user's PUID
            ulong id = GetFirstUserPuid();

            msg.UserPuid = id;
            msg.TitleId = newTitleId;
            XspSend(msg);

        }

        /// <summary>
        /// Send a SECMSG_TYPE_DELETE packet
        /// </summary>
        public void SendDelete() { SendDelete(SecMsgDelete.SHUTDOWN); }
        public void SendDelete(uint reason)
        {
            if (msgDelete == null)
                msgDelete = new SecMsgDelete();
            msgDelete.Reason = reason;
            XspSend(msgDelete);
            isSignedIn = false;
        }

        /// <summary>
        /// Send a pair of SECMSG_TYPE_XBTOSG_QOS_INIT packets, and return the result from the SG.
        /// </summary>
        /// <returns>QOS class encapsulating all QOS stuff</returns>
        public QOS SendQos() { return SendQos(0); }
        public QOS SendQos(int DelayMs) { return SendQos(DelayMs, true); }
        public QOS SendQos(int DelayMs, bool bRecvReply)
        {
            if (LastQOS == null)
            {
                LastQOS = new QOS(DelayMs);
            }
            else
            {
                // Reset fields
                LastQOS.DelayMs = DelayMs;
                LastQOS.Init1.QosIdx = (ushort)rand.Next();
                LastQOS.Init2.QosIdx = LastQOS.Init1.QosIdx;
            }
            if (bRecvReply)
            {
                LastQOS.SendRecv(this);
            }
            else
            {
                LastQOS.Send(this);
            }
            return LastQOS;
        }            

        /// <summary>
        /// Send a SECMSG_TYPE_CHANGE_USERS_REQ packet based on a new ServiceResult (from the XKDC)
        /// </summary>
        public bool SendChangeUsers()
        {
            // Build AP packet
            byte[] apdata = BuildAP();

            if (msgChangeUsers == null)
                msgChangeUsers = new SecMsgChangeUsersReq();
            msgChangeUsers.Time = System.DateTime.Now.Ticks;
            msgChangeUsers.UserPerm = (uint)this.KeyexRequest.keyexInit.UserPerm;
            msgChangeUsers.APReqData = apdata;

            // Send it
            XspSend(msgChangeUsers);
            
            // Recv it
            SecMsgHeader rep = SecMsgRecv(2000, SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REP);
            
            if (rep == null)
            {
                Global.RO.Warn("No reply from ChangeUsersReq");
                return false;
            }

            // Cool.  Don't know what to do with it now though.
            return true;
        }

        
        public bool SendNatDetect()
        {
            if (msgNatDetect == null)
                msgNatDetect = new SecMsgNatDetReq();
            XspSend(msgNatDetect);

            SecMsgHeader hdr = SecMsgRecv(2000, SecMsgHeader.SECMSG_TYPE_SGTOXB_NATDET_REP);          

            // No payload for this thing
            return hdr != null;
        }

        public void SendXbToXbForward(SGAddress recipient, byte[] message)
        {
            if (msgXbToXbForward == null)
                msgXbToXbForward = new SecMsgXbToXbForward();
            msgXbToXbForward.sgaddr = recipient;
            msgXbToXbForward.message = message;
            XspSend(msgXbToXbForward);
        }
        
        public void SendXbToXbForward2(SGAddress sender, SGAddress recipient, byte[] message)
        {
            if (msgXbToXbForward2 == null)
                msgXbToXbForward2 = new SecMsgXbToXbForward2();
            msgXbToXbForward2.sgaSender = sender;
            msgXbToXbForward2.sgaTarget = recipient;
            msgXbToXbForward2.SetMessage(message);
            XspSend(msgXbToXbForward2);
        }

        public void SendChallengeResponse() { SendChallengeResponse(false); }
        public void SendChallengeResponse(bool bKickMe)
        {
            if (this.msgChalResp == null)
            {
                msgChalResp = new SecMsgXbToSgChalResp2();
                msgChalResp.Execute = new byte[1024];
            }
            if (bKickMe)
            {
                // For the test challenge that is hopefully configured,
                // chalResponse[0] == 0 means don't kick me
                // chalResponse[0] >= 1 means kick me
                msgChalResp.Execute[0] = 1;
            }
            msgChalResp.ChallengeNonce = challengeNonce;
            XspSend(msgChalResp);
        }

        public void SendChallengeAck()
        {
            if (this.msgChalAck == null)
            {
                msgChalAck = new SecMsgXbToSgChalAck();
            }
            msgChalAck.ChallengeNonce = challengeNonce;
            XspSend(msgChalAck);
        }

        #endregion

        protected ulong GetMachinePuid()
        {
            return authContext.Authdata.XboxID;
        }

        protected ulong GetFirstUserPuid()
        {
            for (uint i = 0; i < 4; i++)
            {
                if (authContext.Authdata.GetUser(i).qwUserID != 0)
                {
                    return authContext.Authdata.GetUser(i).qwUserID;
                }
            }
            return 0;
        }

        #region ThroughputTest utility functions

        /// <summary>
        /// Sends XSP packet through SG to our SGFakeService using a common UDP packet format.
        /// </summary>
        /// <param name="message"></param>
        /// <param name="?"></param>
        /// <param name="port"></param>
        /// <returns></returns>
        public XspPacket XspSendData(
            byte[] message, 
            byte serviceSequenceNum, 
            SGFakeService.ActionType action, 
            SGFakeService.IServicePort servicePort)
        {
            return XspSendData(message, serviceSequenceNum, action, 0, servicePort, (ushort)SGFakeService.TEST_SERVICE_ID);
        }

        public XspPacket XspSendData(
            byte[] message, 
            byte serviceSequenceNum, 
            SGFakeService.ActionType action, 
            byte parameter, 
            SGFakeService.IServicePort servicePort)
        {
            return XspSendData(message, serviceSequenceNum, action, parameter, servicePort, (ushort)SGFakeService.TEST_SERVICE_ID);
        }

        public XspPacket XspSendData(
            byte[] message, 
            byte serviceSequenceNum, 
            SGFakeService.ActionType action, 
            byte parameter, 
            SGFakeService.IServicePort servicePort, 
            ushort sourcePort)
        {
            uint seq;
            ulong timestamp;
            return XspSendData(message, serviceSequenceNum, action, parameter, servicePort, sourcePort, out seq, out timestamp);
        }

        public XspPacket XspSendData(
            byte[] message, 
            byte serviceSequenceNum, 
            SGFakeService.ActionType action, 
            byte parameter, 
            SGFakeService.IServicePort servicePort, 
            ushort sourcePort,
            out uint sequence,
            out ulong timestamp)
        {
            return XspSendData(message, serviceSequenceNum, action, parameter, (ushort)servicePort, sourcePort, out sequence, out timestamp);
        }

        public XspPacket XspSendData(
            byte[] message, 
            byte serviceSequenceNum, 
            SGFakeService.ActionType action, 
            byte parameter, 
            ushort servicePort, 
            ushort sourcePort,
            out uint sequence,
            out ulong timestamp)
        {
            if (message == null || message.Length < 3)
                throw new SGException("message must be at least 3 bytes long to contain the header");
            message[0] = (byte)action;
            message[1] = (byte)serviceSequenceNum;
            message[2] = parameter;
            message[3] = 0xFE;

            sequence = SequenceXmit;
            timestamp = (ulong)(DateTime.Now.Ticks - ClientBirth.Ticks);
            if (action == SGFakeService.ActionType.ReflectTimestamp)
            {
                SetTimestamp(message, 4, sequence, timestamp);
            }

            return XspSendData(
                message,
                XspHeader.XSP_TYPE_UDP_2,
                sourcePort,
                (ushort)servicePort);
        }

       #endregion
    }

    public class XspPacketFactory
    {
        protected Hashtable     items;

        public XspPacketFactory()
        {
            this.items = new Hashtable(20);
        }

        public void Reset()
        {
            items.Clear();
        }

        /// <summary>
        /// Use this constructor for receiving Xsp packets
        /// </summary>
        public XspPacket Get(SecReg keys, uint SeqRecv)
        {
            XspPacket xsp = null;
            int key = GetCacheCode();
            if (items.ContainsKey(key))
            {
                xsp = (XspPacket)items[key];
                xsp.Clear();
                xsp.SequenceNumber = SeqRecv;
                xsp.SetSecKeys(keys);
            }
            else
            {
                xsp = new XspPacket(keys);
                xsp.SequenceNumber = SeqRecv;
                items[key] = xsp;
            }
            return xsp;
        }

        /// <summary>
        /// Use this constructor for any SecMsg type message
        /// </summary>
        public XspPacket Get(SecMsgHeader msg, SecReg keys, uint SeqXmit) 
        {
            XspPacket xsp = null;
            int key = GetCacheCode(msg);
            if (items.ContainsKey(key))
            {
                xsp = (XspPacket)items[key];
                xsp.SetSecKeys(keys);
                xsp.SequenceNumber = SeqXmit;
                xsp.SecMsg = msg;
                xsp.Encrypt((byte[])msg);
            }
            else
            {
                xsp = new XspPacket(msg, keys, SeqXmit);
                items[key] = xsp;
            }
            return xsp;
        }

        /// <summary>
        /// Use this constructor for any SecMsg type message. Use for funky messages.
        /// </summary>
        public XspPacket Get(byte[] msgBytes, SecReg keys, uint SeqXmit) 
        {
            XspPacket xsp = null;
            int key = GetCacheCode(msgBytes);
            if (items.ContainsKey(key))
            {
                xsp = (XspPacket)items[key];
                xsp.SetSecKeys(keys);
                xsp.SequenceNumber = SeqXmit;
                xsp.Encrypt((byte[])msgBytes);
            }
            else
            {
                xsp = new XspPacket(msgBytes, keys, SeqXmit);
                items[key] = xsp;
            }

            return xsp;
        }

        /// <summary>
        /// Use this constructor for sending any non-SecMsg type message. This will automatically build
        /// the extra bytes needed for the UDP_1, UDP_2, etc, header.
        /// </summary>
        public XspPacket Get(byte[] msgBytes, uint xspType, int srcPort, int dstPort, SecReg keys, uint SeqXmit)
        {
            XspPacket xsp = null;
            int key = GetCacheCode(xspType, (ushort)msgBytes.Length);
            if (items.ContainsKey(key))
            {
                xsp = (XspPacket)items[key];
                xsp.SetSecKeys(keys);
                xsp.SequenceNumber = SeqXmit;
                xsp.BuildInsideHeaderBytes((ushort)srcPort, (ushort)dstPort);
                xsp.Encrypt((byte[])msgBytes);
            }
            else
            {
                xsp = new XspPacket(msgBytes, xspType, srcPort, dstPort, keys, SeqXmit);
                items[key] = xsp;
            }
            return xsp;
        }

        
        protected int GetCacheCode()
        {
            // Just a blank packet
            return 0;
        }

        protected int GetCacheCode(SecMsgHeader secmsg)
        {
            return GetCacheCodeSecMsg((ushort)secmsg.Type);
        }

        protected int GetCacheCode(byte[] msgBytes)
        {
            uint size = (uint)(msgBytes[0] << 8 + msgBytes[1]);
            return GetCacheCodeSecMsg((ushort)size);
        }
       
        protected int GetCacheCodeSecMsg(ushort msgtype)
        {
            // If SecMsg, use SecMsg type
            //if (xsptype == XspHeader.XSP_TYPE_SEC)
            if (msgtype == 0)
                return -1;
            else
                return (int)msgtype;
        }

        protected int GetCacheCode(uint xsptype, ushort payloadsize)
        {
            // If not SecMsg, XSP_TYPE field and size of encrypted message (payload)
            if (xsptype == XspHeader.XSP_TYPE_SEC)
            {
                // Not supposed to be here
                return -1;
            }
            else
            {
                uint key = (uint)((uint)(xsptype & 0xF) | (uint)(payloadsize << 4));
                return (int)key;
            }
        }

        
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\SGFakeService.cs ===
using System;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService.Auth
{

    /// <summary>
    /// Acts like a fake service running behind the SG.  The SG tests will send data to this service,
    /// which much be configured in the SG. More details later on that. 
    /// 
    /// <sample>
    /// Payload structure:
    ///
    ///   Byte 1: action
    ///   Byte 2: sequence number
    ///   Remaining bytes are payload
    ///
    /// Put the following in an sgconfig.ini file that goes in ...\sgroot\sgcfg\.  This is a bare 
    /// minimum to make this work, the "real" XNetPerf tool needs more.
    /// 
    /// sgconfig.ini:
    ///    ; For XnetPerf
    ///    ; aka SG throughput stress tool
    ///
    ///    Service { Id 1129 Name XONLINE_SG_SITE_1_TEST_SERVICE }
    ///
    ///    ; Service 5 (C# test only)
    ///    Server { Id 334 Service XONLINE_SG_SITE_1_TEST_SERVICE Address { InterfaceId 1 Ip 10.20.201.254 Port 65421 } }
    ///    
    ///    ; Service 6
    ///    Server { Id 337 Service XONLINE_SG_SITE_1_TEST_SERVICE Address { InterfaceId 1 Ip 10.20.201.254 Port 65417 } }
    ///    
    ///    ; Server for testing SG notifications (client state update, title change, and deadxbox)
    ///    Server 
    ///    { 
    ///        Id 1 
    ///        Service XONLINE_SG_SITE_1_TEST_SERVICE 
    ///        NotifyUpdateUrl "/update.ashx"
    ///        NotifyTitleChangeUrl "/titlechange.ashx"
    ///        NotifyDeleteUrl "/delete.ashx"
    ///        Address { InterfaceId 1 Ip 10.20.201.254 Port 65000 }
    ///    }
    /// 
    /// Replace the IP address with the address of the computer in the DMZ running SGFakeService. The example
    /// above is for the re-wired client 17. You'll need the FakeSGService running on that machine listening
    /// on port 65417.  The client should send to port 337.
    /// 
    /// Also, the UODB must be configured so the KDC will authorize a user for service id 1129. Add
    /// rows to:
    ///     t_services
    ///     t_service_instances
    /// 
    /// </sample>
    /// 
    /// </summary>
    public class SGFakeService : IDisposable
    {
        // Our test service
        public const uint TEST_SERVICE_ID = 1129;

        // action is one of the following:
        //   0x80 = server drops packet
        //   0x81 = server reflects packet back to client
        //   0x82 = server drops packet and does fast (no recv) AuthData lookup
        //   0x83 = server reflects back to client and does fast (no recv)AuthData lookup
        //   0x84 = server sends back X packets to client
        //   0x85 = server does full AuthData lookup and sends result back to client
        //   0x86 = server reflects packet back to client. Packet includes timestamp & seq
        //   
        public enum ActionType
        {
            Drop = 0x80,
            Reflect = 0x81,
            DropAuthdata = 0x82,
            ReflectAuthdata = 0x83,
            SendBackX = 0x84,
            AuthdataLookup = 0x85,
            ReflectTimestamp = 0x86,
            ReflectOffset = 0x87,
            ReflectNATData = 0x88,
            TCPConnectTest = 0x89,
            SGInfoLookup = 0x8A,
            SgMsg = 0x8B,
        };

        
        // The client sends to the IServicePort on the SG, where it gets
        // mapped to the ZServicePort and sent to the service.
        public enum IServicePort
        {
            ServiceHttp = 1,        // Don't send to this, just used for notifications
            Service5 = 334,         // C# only
            Service6 = 337,
            Service7 = 340,
            Service8 = 343,
            Service9 = 346,
            Service10 = 349,
            Arbitration = 1000,
            ConnectionService = 26,
            TestRefl = 128,
            TestRefl2 = 129,
        };

        public enum ZServicePort
        {
            ServiceHttp = 65000,    // Http listener here for notifications
            Service5 = 65421,       // 333 for client (C# only)
            Service6 = 65417,       // 337 for client
            Service7 = 65413,       // 340 for client
            Service8 = 65409,       // 343 for client
            Service9 = 65405,       // 346 for client
            Service10 = 65401       // 349 for client
        };

       
        public Socket                   udpSocket       = null;
        public EndPoint                 remoteEP        = null;
        public IPEndPoint               localEP         = null;
        public EndPoint                 sgEP            = null;             // for communicating with the SG (SGMSG*)
        public byte[]                   recvBuffer      = new byte[1500];
        public int                      packetSize      = 0;
        public SimpleUdpSG              sgmsgUdp        = new SimpleUdpSG();
        
        protected SgMsgSpiReq           spireq          = new SgMsgSpiReq();

        // Fields from the packet
        private int                     action;
        private int                     seq;
        private int                     param;
        private uint                    bigseq;
        private ulong                   timestamp;

        // Cache the payload to make it faster when sending back arbitrary-sized payloads.  
        // We can send only a subset of this array for all possible sizes.
        private byte[]                  cachedPayload   = new byte[1500];

        public int TimeoutInMs
        {
            get
            {
                return (int)udpSocket.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout);
            }
            set 
            {
                udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, value);
            }
        }

        public int PacketAction         { get { return action; } }
        public int PacketSequence       { get { return seq; } }
        public int PacketParam          { get { return param; } }
        public uint PacketBigSequence   { get { return bigseq; } }
        public ulong PacketTimestamp    { get { return timestamp; } }

        public ulong ConnectionId 
        {
            get
            {
                byte[] ip = ((IPEndPoint)remoteEP).Address.GetAddressBytes();
                int port = ((IPEndPoint)remoteEP).Port;
                ulong cid = 
                    (ulong)((ip[0] & 0xFF)        ) +
                    (ulong)((ip[1] & 0xFF)   <<  8) +
                    (ulong)((ip[2] & 0xFF)   << 16) +
                    (ulong)((ip[3] & 0xFF)   << 24) +
                    (ulong)((port  & 0xFFFF) << 32);
                return (ulong)cid;
            }
        }

        /// <summary>
        /// Constructor for use as SGINFO lookup only, don't care about listening on a port
        /// </summary>
        /// <param name="sgEPDatacenter">IP address of datacenter-facing NIC on the SG</param>
        public SGFakeService(IPEndPoint sgEPDatacenter) : this(0)
        {
            sgEP = sgEPDatacenter;
        }

        /// <summary>
        /// Constructor for use as a throughput reflector
        /// </summary>
        /// <param name="localPort">Local port to listen on</param>
        public SGFakeService(int localPort)
        {
            udpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            localEP = new IPEndPoint(IPAddress.Any, localPort);
            remoteEP = new IPEndPoint(IPAddress.Any, 0);  // will be filled in by Recv
            udpSocket.Bind(localEP);
            
            // Set options
            // 256K buffers
            // 
            udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, 262144);
            udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, 262144);
        }

        /// <summary>
        /// Default constructor, will listen on Service6 port (65417)
        /// </summary>
        public SGFakeService() : this((int)ZServicePort.Service6)
        {
        }

        public int RecvFast()
        {
            try 
            {
                packetSize = 0;  // set to 0 before the long timeout next
                packetSize = udpSocket.ReceiveFrom(recvBuffer, ref remoteEP);
            }
            catch (System.Net.Sockets.SocketException e)
            {
                // WSAECONNRESET
                // This happens when we receive an ICMP Port Unreachable packet.
                // The SG happens to send one out for every KeyExXbToSgInit message.
                // It does this because of some Netgear router bug. WinSock is kinda
                // stupid here -- this is a *connectionless* protocol after all so it should
                // just swallow a connection reset message -- so let's try it again. 
                // This should succeed and read the reply that actually was sent.
//                if (e.ErrorCode == 10054)
//                {
//                    packetSize = udpSocket.ReceiveFrom(recvBuffer, ref remoteEP);
//                }
                // Timed out
                if (e.ErrorCode == 10060)
                {
                    packetSize = 0;
                }
                else
                {
                    throw;
                }
            }
            return packetSize;
        }

        /// <summary>
        /// Called after Recv to handle the packet and take actions, if necessary
        /// </summary>
        public bool Process()
        {
            bool bRet = true;

            if (packetSize < 4)
                return false;

            action = (int)recvBuffer[0];
            seq = (int)recvBuffer[1];
            param = (int)recvBuffer[2];

            if (action == (int)ActionType.Drop)
            {
                bRet = true;
            }
            else if (action == (int)ActionType.DropAuthdata)
            {
                bRet = SGInfoSendRequest();
            }
            else if (action == (int)ActionType.Reflect)
            {
                // Optional param can specify size of reply instead of a simple reflection
                if (param > 0)
                {
                    // param is size we want divided by 8
                    int bytesToSend = param << 3;
                    int bytesSent = udpSocket.SendTo(cachedPayload, bytesToSend, SocketFlags.None, this.remoteEP);
                    bRet = (bytesSent == bytesToSend);
                }
                else
                {
                    bRet = Reflect();
                }
            }
            else if (action == (int)ActionType.ReflectAuthdata)
            {
                bRet = SGInfoSendRequest();
                Reflect();
            }
            else if (action == (int)ActionType.SendBackX)
            {
                // 3rd byte is count of packets * 10, so we can do up to 2550 per request
                // Return size will be the same as request size
                int numPackets = param * 10;

                // Make copy, cause it could change if another request comes in from a diff client
                EndPoint ep = new IPEndPoint(((IPEndPoint)remoteEP).Address, ((IPEndPoint)remoteEP).Port);

                PacketSender psThread = new PacketSender(this.udpSocket, ep, numPackets, this.packetSize);
                psThread.Go();
            }
            else if (action == (int)ActionType.AuthdataLookup)
            {
                if (param == 1)
                {
                    // Flush the receive buffer, really only useful for functional tests. 
                    // If you don't, the sgmsgUdp receive buffer is full of unread SpiData
                    // replies from the SG.
                    byte[] buffer = null;
                    int s = 0;
                    do
                    {
                        buffer = sgmsgUdp.RecvFast(0, out s);
                    } while (buffer != null);
                 }

                // Send request AND wait for reply, then send the reply back to the original
                // client.
                SgMsgSpiDataRepPacket spidataReply = GetSGInfo();
                if (spidataReply != null)
                {
                    // Bytes should be stored in sgmsgUdp
                    byte[] spirepbytes = (byte[])spidataReply;
                    bRet = Reflect(spirepbytes, spirepbytes.Length);
                }
            }
            else if (action == (int)ActionType.ReflectTimestamp)
            {
                // Optional param can specify size of reply instead of a simple reflection
                if (param > 0)
                {
                    // param is size we want divided by 8
                    int bytesToSend = param << 3;
                    int bytesSent = udpSocket.SendTo(cachedPayload, bytesToSend, SocketFlags.None, this.remoteEP);
                    bRet = (bytesSent == bytesToSend);
                }
                else
                {
                    bRet = Reflect();
                }
                AuthClientBase.GetTimestamp(recvBuffer, 4, out bigseq, out timestamp);
            }
            else if (action == (int)ActionType.ReflectOffset)
            {
                int shift = param << 2;

                if (packetSize <= shift)
                {
                    return false;
                }

                bRet = Reflect(recvBuffer, shift, packetSize - shift);
            }
            else if (action == (int)ActionType.ReflectNATData)
            {
                // write remote endpoint into buffer
                IPEndPoint temp = (IPEndPoint)remoteEP;
                Buffer.BlockCopy(temp.Address.GetAddressBytes(), 0, recvBuffer, 5, 4);
                Buffer.BlockCopy(BitConverter.GetBytes(temp.Port), 0, recvBuffer, 9, 4);
                bRet = Reflect(recvBuffer, 1, 12);
            }
            else if (action == (int)ActionType.TCPConnectTest)
            {
                // pull the ip and port to connect to out
                byte[] ip_bytes = new byte[4];
                Buffer.BlockCopy(recvBuffer, 4, ip_bytes, 0, 4);
                IPAddress ip = new IPAddress(ip_bytes);

                Buffer.BlockCopy(recvBuffer, 8, ip_bytes, 0, 2);
                int port = (int)BitConverter.ToUInt16(ip_bytes, 0);

                recvBuffer[2] = CheckForTCPRST(ip, port);

                Reflect(recvBuffer, 3);
            }
            else
            {
                bRet = false;
            }
            return bRet;
        }

        public SgMsgSpiDataRepPacket GetSGInfo()
        {
            SGInfoSendRequest();
            return SGInfoGetReply();
        }

        public bool SGInfoSendRequest()
        {
            // Verify that we have received something
            if (remoteEP == null)
            {
                throw new Exception("SG endpoint or remote endpoint is null, have you received something from the SG?");
            }

            ushort port = (ushort)((IPEndPoint)remoteEP).Port;
            if (port == 0)
                return false;
            byte[] addrbytes = ((IPEndPoint)remoteEP).Address.GetAddressBytes();
            uint ipaddr = (uint)((addrbytes[3] << 24) | (addrbytes[2] << 16) | (addrbytes[1] << 8) | (addrbytes[0]));
            return SGInfoSendRequest(ipaddr, port);
        }

        public bool SGInfoSendRequest(uint clientIp, ushort clientPort)
        {
            // Request packet
            spireq.ReqNum            = 0;
            spireq.ClientPort        = NetConstants.HTONS((ushort)clientPort);
            spireq.ClientAddr.S_addr = clientIp;

            // Verify that we have received something
            if (remoteEP == null)
            {
                throw new Exception("SG endpoint or remote endpoint is null, have you received something from the SG?");
            }
            // Set endpoint for SG (DMZ NIC), uses port 0xFFFF
            //else if (this.sgEP == null)
            //{   this.sgEP = new IPEndPoint(((IPEndPoint)this.remoteEP).Address, 0xFFFF);
            //}
            this.sgEP = new IPEndPoint(((IPEndPoint)this.remoteEP).Address, 0xFFFF);
            
            // Send it
            //Global.RO.Debug("Making SpiData request to {0}", ((IPEndPoint)sgEP).ToString());
            spireq.Send((IPEndPoint)sgEP, sgmsgUdp);
            return true;
        }

        public SgMsgSpiDataRepPacket SGInfoGetReply()
        {
            // Receive reply packet
            SgMsgSpiDataRepPacket spidataReply = new SgMsgSpiDataRepPacket();
            if (spidataReply.Recv(2000, sgmsgUdp) == null)
            {
                //throw new SGNoReplyException("Timed out waiting for SPIDATA/SGINFO reply");
                return null;
            }
            return spidataReply;
        }

        /// <summary>
        /// Attempts to connect to a given ip and port using TCP.
        /// </summary>
        /// <param name="ip">The ip to connect to.</param>
        /// <param name="port">The port to connect to.</param>
        /// <returns>A byte indicating what happened.</returns>
        public byte CheckForTCPRST (IPAddress ip, int port)
        {
            using (Socket sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))
            {
                try
                {
                    sock.Connect(ip, port);
                }
                catch (SocketException se)
                {
                    if (se.SocketErrorCode == SocketError.ConnectionRefused)
                    {
                        return (byte)0;
                    }
                    else
                    {
                        return (byte)2;
                    }
                }
                catch (Exception)
                {
                    return (byte)2;
                }

                return (byte)1;
            }
        }

        public bool Reflect()
        {
            return Reflect(this.recvBuffer, this.packetSize);
        }

        public bool Reflect(byte[] data, int datasize)
        {
            return udpSocket.SendTo(data, datasize, SocketFlags.None, this.remoteEP) == datasize;
        }

        public bool Reflect (byte[] data, int offset, int datasize)
        {
            return udpSocket.SendTo(data, offset, datasize, SocketFlags.None, this.remoteEP) == datasize;
        }

        public bool DoThroughput()
        {
            // Recv the chunk
            TimeoutInMs = 10000;
            RecvFast();

            if (packetSize == 0)
            {
                return false;
            }


            return Process();
        }

        #region IDisposable Members

        public void Dispose()
        {
            udpSocket.Close();
        }

        #endregion
    }

    class PacketSender : ThreadBase
    {
        public Socket       UdpSocket;
        public EndPoint     RemoteEP;
        public int          NumPackets;
        public int          PacketSize;

        public PacketSender(Socket sock, EndPoint remoteEP, int numPackets, int packetSize)
        {
            UdpSocket = sock;
            RemoteEP = remoteEP;
            NumPackets = numPackets;
            PacketSize = packetSize;
        }

        protected override void ThreadBody()
        {
            byte[] buffer = new byte[PacketSize];
            buffer[0] = (byte)SGFakeService.ActionType.SendBackX;
            buffer[1] = 0;
            for (int i = 0; i < NumPackets; i++)
            {
                UdpSocket.SendTo(buffer, PacketSize, SocketFlags.None, RemoteEP);
                // Increment seq number
                buffer[1] = (byte)((buffer[1] + 1) % 256);
            }            
        }
    }

    public class NotificationListener : XHttpListener
    {
        // "Fake" urls configured in SG
        public const string NotiUrl_Update = "update.ashx";
        public const string NotiUrl_TitleChange = "titlechange.ashx";
        public const string NotiUrl_Delete = "delete.ashx";

        private object CounterLock = new object();

        // How many batched messages (1 connection) from the SG
        public long BatchesUpdate = 0;
        public long BatchesTitleChange = 0;
        public long BatchesDelete = 0;

        public long BatchesTotal = 0;
        public long BytesTotal = 0;
        
        // How many messages total sent by SG (including batches)
        public long CountUpdate = 0;
        public long CountTitleChange = 0;
        public long CountDelete = 0;

        public NotificationListener() : base((int)SGFakeService.ZServicePort.ServiceHttp, -1, -1, false)
        {
        }

        public NotificationListener(int port) : base(port, -1, -1, false)
        {
        }

        public void ResetCounts()
        {
            lock (CounterLock)
            {
                CountUpdate = 0;
                CountTitleChange = 0;
                CountDelete = 0;
                BytesTotal = 0;
            }
        }

        /// <summary>
        /// </summary>
        /// <param name="ReqData">Incoming data</param>
        /// <param name="ConIndex">index in the buffer where the content starts</param>
        /// <param name="conLen">length of data</param>
        /// <returns>if true, returns "200 OK" message; if false, returns "500 bad request"</returns>></returns>
        public override bool ProcessData(byte[] ReqData, int ConIndex, int conLen)
        {
            //Console.WriteLine("NotificationListener: ConIndex={0}, ConLen={1}", ConIndex, conLen);

            System.Threading.Interlocked.Increment(ref BatchesTotal);

            // The header appears to be from ReqData[0] to ReqData[ConIndex-1]
            string header = System.Text.Encoding.ASCII.GetString(ReqData, 0, ConIndex);
            
            // Increment counter for whole batch of messages, plus count of 
            // individual messages.  Remember,
            // ReqData[ConIndex+0] = (WORD)wType
            // ReqData[ConIndex+2] = (WORD)cbEnt
            // Thus ConLen / cbEnt is the count of messages in this batch

            int count = 0;
            if (conLen > 4)
            {
                int size = (ReqData[ConIndex+2]) + (ReqData[ConIndex+3] << 8);
                count = (int)(conLen / size);
            }

            lock (CounterLock)
            {
                BytesTotal += conLen;
                
                if (header.IndexOf(NotiUrl_Update) > 0)
                {
                    BatchesUpdate++;
                    CountUpdate += count;
                }
                if (header.IndexOf(NotiUrl_TitleChange) > 0)
                {
                    BatchesTitleChange++;
                    CountTitleChange += count;
                }
                if (header.IndexOf(NotiUrl_Delete) > 0)
                {
                    BatchesDelete++;
                    CountDelete += count;
                }
            }

            return true;
        }

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\SGConnection.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Threading;

using xonline.common.config;
using ServerTestFramework.Utilities;

using TimeoutException = ServerTestFramework.Utilities.TimeoutException;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary>
    /// Represents a connection to an SG.
    /// 
    /// Now:
    /// Does what is needed for stress.
    /// Uses XspBuffer, XspSession, XspUdp.
    /// Uses AuthContext.
    /// Uses newly static functions from SGClient, LspClient used to override some of them.
    /// 
    /// Hopefully:
    /// Be able to replace SGClient.
    /// Make AuthContext prettier?
    /// Have an equivalent to LspClient.
    /// </summary>
    public class SGConnection
    {
        #region Private Static SecMsgs

        private static byte[] SecMsgPulse = null;

        private static SecMsgDataPulse SecMsgDataPulse = new SecMsgDataPulse();
        private static SecMsgDelete SecMsgDelete = new SecMsgDelete();

        #endregion

        #region Static Constructor

        static SGConnection ()
        {
            SecMsgPulse = new byte[ServerTestFramework.LiveService.Auth.SecMsgPulse.SIZE];
            System.IO.MemoryStream ms = new System.IO.MemoryStream(SecMsgPulse);
            System.IO.BinaryWriter bw = new System.IO.BinaryWriter(ms);
            (new ServerTestFramework.LiveService.Auth.SecMsgPulse()).WriteStream(bw);
        }

        #endregion

        #region Connection State and Timings

        /// <summary>
        /// The current state of the connection.
        /// </summary>
        public enum ConnectionState
        {
            Disconnected,
            ConnectWait,
            Connected,
        }
        
        /// <summary>Backing for State.</summary>
        protected ConnectionState _state = ConnectionState.Disconnected;

        /// <summary>The current state of the connection.</summary>
        public ConnectionState State
        {
            get { return _state; }
        }

        /// <summary>Backing for LastSendTime.</summary>
        protected DateTime _last_send_time = DateTime.MinValue;

        /// <summary>The last time we sent a packet to the SG.</summary>
        public DateTime LastSendTime
        {
            get { return _last_send_time; }
        }

        /// <summary>The last time we attempted to connect.</summary>
        protected DateTime _last_keyex_init = DateTime.MinValue;
        /// <summary>The last machine puid we used to connect with.</summary>
        protected ulong _last_keyex_mpuid = 0;
        /// <summary>The key exchange packet that was last sent.</summary>
        protected KeyExchangeRequestPacket _last_keyex_request_packet = null;
        /// <summary>The last exception to occur during keyex.</summary>
        protected Exception _last_keyex_exception = null;

        /// <summary>The last key exchange init time.</summary>
        public DateTime LastKeyexInitTime
        {
            get { return _last_keyex_init; }
        }

        public TimeSpan SinceLastKeyexInit
        {
            get { return (DateTime.UtcNow - _last_keyex_init); }
        }

        /// <summary>The last key exchange exception that occured.</summary>
        public Exception LastKeyexException
        {
            get { return _last_keyex_exception; }
        }

        /// <summary>Backing for LastReceiveTime.</summary>
        protected DateTime _last_receive_time = DateTime.MinValue;

        /// <summary>The last time we sent a packet to the SG.</summary>
        public DateTime LastReceiveTime
        {
            get { return _last_receive_time; }
        }

        /// <summary>Client side receive timeout.</summary>
        protected readonly TimeSpan ConnectionReceiveTimeout = new TimeSpan(0, 2, 0);

        /// <summary>Client side heartbeat timer.</summary>
        protected readonly TimeSpan XbToSgPulseTimeout = new TimeSpan(0, 0, 20);

        /// <summary>Backing for LastChangeUsersReq.</summary>
        protected DateTime _last_change_users_req = DateTime.MinValue;
        /// <summary>The last time a change users request packet was actually sent.</summary>
        protected DateTime _last_change_users_req_sent = DateTime.MinValue;
        /// <summary>Backing for LastChangeUsersRep.</summary>
        protected DateTime _last_change_users_rep = DateTime.MinValue;
        /// <summary>The change users packet that was last sent.</summary>
        protected SecMsgChangeUsersReq _last_change_users_req_packet = null;
        /// <summary>Change Users Request timeout.</summary>
        protected readonly TimeSpan ChangeUsersRequestTimeout = new TimeSpan(0, 0, 2);

        /// <summary>The last time that we sent a change users secmsg.</summary>
        public DateTime LastChangeUsersReq
        {
            get { return _last_change_users_req; }
        }

        /// <summary>The last time that we received a change users secmsg reply.</summary>
        public DateTime LastChangeUsersRep
        {
            get { return _last_change_users_rep; }
        }

        /// <summary>
        /// True if a change users message is outstanding; false if not.
        /// </summary>
        public bool ChangeUsersPending
        {
            get { return (_last_change_users_req > _last_change_users_rep); }
        }

        /// <summary>The qos packet that was last sent.</summary>
        protected SecMsgQosInit _last_qos_init_packet = null;

        protected long _last_qos_init_time = 0;
        protected long _last_qos_resp_time1 = 0;
        protected long _last_qos_resp_time2 = 0;

        /// <summary>
        /// True if a QoS is outstanding; false if not.
        /// </summary>
        public bool QoSPending
        {
            get { return (_last_qos_init_time != 0 && (_last_qos_resp_time1 == 0 || _last_qos_resp_time2 == 0)); }
        }

        #endregion

        #region Challenge Data

        /// <summary>True if there is a challenge; false otherwise.</summary>
        public bool HasCurrentChallenge { get { return CurrentChallengePacket != null; } }

        /// <summary>The current async challenge that we should be executing.</summary>
        public SecMsgSgToXbChal CurrentChallengePacket { get; protected set; }

        /// <summary>The last time we received the current challenge.</summary>
        public DateTime CurrentChallengeLastReceived { get; protected set; }

        /// <summary>The number of times we have received the current challenge.</summary>
        public int CurrentChallengeReceiveCount { get; protected set; }

        #endregion

        #region Connection Data

        /// <summary>
        /// Storage for most of the connection information, holdover from SGClient and AuthClientBase.
        /// Would like to replace this.  Backing for Context.
        /// </summary>
        protected AuthContext _authcontext;

        /// <summary>
        /// The authorization information that allows us to navigate the gauntlet of signing in.
        /// </summary>
        public AuthContext Context
        {
            get { return _authcontext; }
            set
            {
                if (_state != ConnectionState.Disconnected)
                {
                    throw new InvalidOperationException("Can only change the context while disconnected.");
                }
                _authcontext = value;
            }
        }

        /// <summary>
        /// The machine puid being used in the authdata.
        /// </summary>
        public ulong MachinePuid
        {
            get
            {
                if (_authcontext != null && _authcontext.Authdata != null)
                {
                    return _authcontext.Authdata.XboxID;
                }

                return 0;
            }
        }

        /// <summary>Backing for Transport.</summary>
        protected XspUdp _transport;

        /// <summary>
        /// Transport to the SG.
        /// </summary>
        public XspUdp Transport
        {
            get { return _transport; }
            set
            {
                if (_state != ConnectionState.Disconnected)
                {
                    throw new InvalidOperationException("Can only change the transport while disconnected.");
                }
                _transport = value;
                SetupPacketReceive();
            }
        }

        /// <summary>Contains what we need to communicate with the SG.</summary>
        protected XspSession _session;

        /// <summary>The session used for communicating with the SG.</summary>
        public XspSession Session { get { return _session; } }

        /// <summary>
        /// The SPI that we generated to receive on before key-exchange is complete.  Used by Connect to XspUdp.Close on a failed attempt
        /// before _session is created.
        /// </summary>
        private uint _pre_keyex_recv_spi = 0;

        #endregion

        #region Fields/Properties - Control

        /// <summary>When connecting to the SG, should we use a real ticket from the XKDC?</summary>
        public bool UseRealXKDC = false;

        /// <summary>If using real XKDC, should we use the provided IP to connect to the SG?</summary>
        public bool UseSGIPFromKDC = false;

        /// <summary>Use connection services when logging in, should be used when at least 1 user is present.</summary>
        public bool UseConnectionServices = true;

        /// <summary>Backing for HandleSecMsgs.</summary>
        private bool _HandleSecMsgs = true;

        /// <summary>If true, the SGConnection will handle SecMsgs instead of passing them to the user.</summary>
        public bool HandleSecMsgs
        {
            get { return _HandleSecMsgs; }
            set { _HandleSecMsgs = value; }
        }

        /// <summary>Delegate for the user handling sec msgs.</summary>
        public delegate bool UserSecMsgHandlerDelegate (int type, XspBuffer packet);

        /// <summary>When a function is supplied, secmsgs will be passed to it for the user to handle.</summary>
        public UserSecMsgHandlerDelegate UserSecMsgHandler;

        /// <summary>The endpoint of the SG to connect to.</summary>
        public IPEndPoint RemoteEndpoint;

        /// <summary>The amount of time to wait for a key exchange response, in milliseconds.</summary>
        public int KeyExchangeTimeoutInMs = 5000;

        /// <summary>The amount of time to wait for any data packet when receiving.</summary>
        public int ReceiveTimeoutInMs = 5000;

        /// <summary>The minimum amount of time between key exchange retries.</summary>
        public TimeSpan KeyExchangeMinRetryTime = new TimeSpan(0, 0, 1);

        #endregion

        #region Connect

        #region Shared Connect Workers

        /// <summary>
        /// Does all of the setup required to be ready to send a key-exchange packet to the SG.
        /// It may block for a time if using the real XKDC, as there is no asynchronous connect to it.
        /// </summary>
        protected void PreConnect (out KeyExchangeRequestPacket KeyexRequest, out XspBuffer buffer)
        {
            Debug.Assert(_authcontext != null);
            Debug.Assert(_transport != null);

            if (_state != ConnectionState.Disconnected)
            {
                throw new InvalidOperationException("Must be in ConnectionState.Disconnected in order to connect.");
            }

            // make sure we can sign in, setting defaults if we have to
            EnsureDefaults();

            // if we try to key ex less than 1 second later, we will fail
            if (DateTime.UtcNow.Subtract(_last_keyex_init) < KeyExchangeMinRetryTime && _last_keyex_mpuid == MachinePuid)
            {
                throw new SGConnectionException("Cannot connect with the same machine puid more than once per second.");
            }

            // Sign in to the XKDC automagically
            if (!_authcontext.IsSignedInXkdc)
            {
                if (UseRealXKDC)
                {
                    XkdcClient xkdc = new XkdcClient(_authcontext);
                    xkdc.SignInXkdc();
                }
                else
                {
                    SgClient.FakeSignInXkdc(_authcontext);
                }
            }

            // Construct the request packet
            _pre_keyex_recv_spi = 0;
            KeyexRequest = new KeyExchangeRequestPacket();

            // see if we can use the Spi that was generated, don't want to step on another connection
            for (int i = 0; i < 10; ++i)
            {
                if (_transport.CheckSpiAvailability(KeyexRequest.keyexInit.SpiInit))
                {
                    // save the spi for later
                    _pre_keyex_recv_spi = KeyexRequest.keyexInit.SpiInit;
                    break;
                }
                else
                {
                    KeyexRequest.keyexInit.SpiInit = AuthUtils.GetNewSpi();
                }
            }

            // we tried 10 times to generate a spi, time to bail
            if (_pre_keyex_recv_spi == 0)
            {
                throw new SGConnectionException("Unable to find an unused Spi after 10 attempts.");
            }

            // Set Connection Services if necessary
            if (UseConnectionServices)
            {
                // If we're logging in with at least 1 user (versus a machine-only login), then we should
                // request connection services (CS).  This is required for the data pulses (such as
                // presence uses).
                KeyexRequest.keyexInit.wFlags = KeyExchangeInit.XSIF_CONNECTION_SERVICE;
            }

            // Use SG IP from XKDC?    
            if (UseRealXKDC && UseSGIPFromKDC)
            {
                RemoteEndpoint = _authcontext.GetSGSiteIP();
            }
            // Overridden ip address from the site info?
            else if (_authcontext.Site.siteIp != null)
            {
                RemoteEndpoint = _authcontext.Site.siteIp;
            }
            Debug.Assert(RemoteEndpoint != null);

            // Build AP            
            // This must be done for every key exchange packet that is sent, or else the SG logs 
            // event #50052, EVENT_SG_REPLAYED_KERBEROS_AUTHENTICATOR.
            KeyexRequest.keyexAPReq.Data = KeyexRequest.BuildAP(_authcontext);

            // Send
            buffer = (XspBuffer)KeyexRequest;
        }

        /// <summary>
        /// After the send/receive, this handles the processing to be able to communicate with the SG.
        /// </summary>
        protected void PostConnect (KeyExchangeRequestPacket KeyexRequest, XspBuffer response)
        {
            Debug.Assert(response.DecodeSpi() == 0);
            Debug.Assert(response.DecodeSpiFromKeyExPacket() == KeyexRequest.keyexInit.SpiInit);

            // it would be bad if we got non-keyex packets here
            // it could happen if we used the same SPI as another connection
            ushort type = response.GetUInt16(4);
            if (((int)type) != KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP)
            {
                throw new SGException("Received a non-keyex packet while attempting to connect.");
            }

            // Process it
            KeyExchangeResponsePacket KeyexResult = new KeyExchangeResponsePacket(KeyexRequest.SPI);
            KeyexResult.ReadBytes(response.RawBuffer, (int)response.RawBufferLength);

            // now that we have read the buffer into KeyexResult, we are done with it
            XspBufferManager.Free(response);

            // Check the nonces against each other, could we possibly have sent two key-exchanges with the same SPI?
            byte[] reqnonce = KeyexRequest.keyexInit.NonceInit;
            byte[] respnonce = KeyexResult.keyexResp.NonceInit;

            Debug.Assert(reqnonce.Length == respnonce.Length);
            for (int i = 0; i < reqnonce.Length; ++i)
            {
                if (reqnonce[i] != respnonce[i])
                {
                    throw new SGException("Nonce mismatch in keyex response, Request nonce={0}, Response nonce={1}",
                        Hexer.tohex(reqnonce), Hexer.tohex(respnonce));
                }
            }

            // TODO: In order to write 100% good NAT detection tests, we will have to be able to get at the
            //       encrypted portion of the key exchange response
            // KeyexResult.keyexResp.Decrypt(authContext.SecKeys);

            // TODO: At this point we might want to decrypt the challenge and kick off a callback
            //       maybe the callback function could be a member of this class, also a parameter override
            // if (KeyexResult.keyexChal != null)
            //     KeyexResult.keyexChal.Decrypt(authContext.SecKeys);

            // the money line(s)
            _authcontext.SecKeys = new SecReg(true, KeyexResult, _authcontext.GetSessionKey());
            _session = new XspSession(_authcontext.SecKeys);

            // we are now connected
            _state = ConnectionState.Connected;

            // Send heartbeat back to acknowledge
            Send(SecMsgDataPulse);
        }

        #endregion

        /// <summary>
        /// Connects to the SG, doing whatever is needed to complete the connection.
        /// </summary>
        public void Connect ()
        {
            // first we kick off the key exchange
            ConnectAsync();

            // then we wait for it
            EndConnect();
        }

        /// <summary>
        /// Connects to the SG asynchronously, doing whatever is needed to complete the connection.
        /// ProcessReceiveQueue must be called at some point in order to transition to a connected state.
        /// </summary>
        public void ConnectAsync ()
        {
            KeyExchangeRequestPacket KeyexRequest;
            XspBuffer buffer;

            // Construct key-ex packet, send it, free the buffer
            PreConnect(out KeyexRequest, out buffer);

            Send(buffer);

            // save keyex info for later
            _last_keyex_init = _last_send_time;
            _last_keyex_mpuid = MachinePuid;
            _last_keyex_request_packet = KeyexRequest;
            _last_keyex_exception = null;
            _state = ConnectionState.ConnectWait;

            // start listening
            _transport.AttachForSpi(KeyexRequest.keyexInit.SpiInit, ReceiveCallback);

            // free the send buffer
            XspBufferManager.Free(buffer);
        }

        /// <summary>
        /// Waits for the successful completion of a connection that was begun with ConnectAsync.
        /// </summary>
        public void EndConnect ()
        {
            try
            {
                while (true)
                {
                    // sleep for a small amount of time
                    Thread.Sleep(10);

                    // process queue if we see anything on it
                    if (_receive_queue_head != null)
                    {
                        ProcessReceiveQueue();
                    }

                    // yay!
                    if (_state == ConnectionState.Connected) { return; }

                    // something happened, not sure what
                    if (_state != ConnectionState.ConnectWait)
                    {
                        throw new SGConnectionException("A problem occured while trying to connect.",
                            _last_keyex_exception);
                    }

                    // check for a timeout
                    if (DateTime.UtcNow.Subtract(_last_keyex_init).TotalMilliseconds >= KeyExchangeTimeoutInMs)
                    {
                        _state = ConnectionState.Disconnected;
                        _last_keyex_request_packet = null;

                        Global.RO.Debug("Keyex timeout: qwXboxID: " + MachinePuid.ToString("X8"));
                        throw new TimeoutException(String.Format("{0} -> {1}/{2} timed out in {3}ms",
                            _transport.LocalEndpoint, _authcontext.Site.serverName, RemoteEndpoint, KeyExchangeTimeoutInMs));
                    }
                }
            }
            catch
            {
                // after a successful PreConnect, we can assume that this value is correct
                // plus it doesn't hurt to call this on 0 (or any value that isn't there)
                _transport.Close(_pre_keyex_recv_spi);
                throw;
            }
        }

        #endregion

        #region Disconnect

        /// <summary>
        /// Disconnects from the SG.
        /// Closes the transport layer down, which drops any waiting packets and returns nulls to any waiting receives.
        /// </summary>
        public void Disconnect ()
        {
            if (_state == ConnectionState.Connected)
            {
                Send(SecMsgDelete);
            }

            SetDisconnected();
        }

        /// <summary>
        /// Sets us to the disconnected state, without sending a delete message.
        /// </summary>
        public void SetDisconnected ()
        {
            _state = ConnectionState.Disconnected;
            _transport.Close(_pre_keyex_recv_spi);
        }

        /// <summary>
        /// Removes any cached ticket data that may be held by the connection.
        /// </summary>
        public void ClearTicketCache ()
        {
            _authcontext.ClearXkdc();
            _authcontext.ClearAskdc();
            _authcontext.ClearXmacs();
        }

        #endregion

        #region Helpers

        /// <summary>
        /// This function should make sure that Connect has what it needs to be able to succeed.
        /// </summary>
        protected void EnsureDefaults ()
        {
            if (_authcontext.Site == null)
            {
                _authcontext.Site = SiteInfoManager.GetDefaultSgSite();
            }

            if (RemoteEndpoint == null)
            {
                RemoteEndpoint = Global.XEnv.GetVirtualInterface(VirtualInterface.sgsvc);
            }
        }

        /// <summary>Sets up the default receive for handling secmsgs.</summary>
        private void SetupPacketReceive ()
        {
            if (_transport != null && _session != null)
            {
                if (_state != ConnectionState.Disconnected)
                {
                    _transport.AttachForSpi(_session.ReceiveSPI, ReceiveCallback);
                }
                else
                {
                    _transport.Close(_session.ReceiveSPI);
                }
            }
        }

        /// <summary>Removes all data packets from the queues.</summary>
        public void FlushDataPackets ()
        {
            lock (_port_mapping)
            {
                foreach (KeyValuePair<uint, PortMapping> kvp in _port_mapping)
                {
                    XspBuffer buffer = kvp.Value.Head;

                    while (buffer != null)
                    {
                        XspBuffer temp = buffer;
                        buffer = buffer.Next;
                        XspBufferManager.Free(temp);
                    }
                }

                _port_mapping.Clear();
            }
        }

        #endregion

        #region Send

        #region Send SecMsgs

        /// <summary>
        /// Sends the SecMsg to the SG.
        /// </summary>
        /// <param name="secMsg">The SecMsg to send.</param>
        public void Send (SecMsgHeader secMsg)
        {
            if (_session == null)
            {
                throw new SGConnectionException("Cannot send without a session.");
            }

            XspBuffer buffer = _session.EncodeSecMsg(secMsg);
            Send(buffer);
            XspBufferManager.Free(buffer);
        }

        /// <summary>
        /// Sends a simple heartbeat to the SG.
        /// </summary>
        /// <param name="onlyIfNeeded">Only sends if needed based on the last send time.</param>
        public void SendHeartbeat (bool onlyIfNeeded)
        {
            if (_session == null)
            {
                throw new SGConnectionException("Cannot send without a session.");
            }

            if (!onlyIfNeeded || ((DateTime.UtcNow - _last_send_time) > XbToSgPulseTimeout))
            {
                XspBuffer buffer = _session.EncodeSecMsg(SecMsgPulse, (uint)(SecMsgPulse.Length));
                Send(buffer);
                XspBufferManager.Free(buffer);
            }
        }

        #region Change Users SecMsg

        /// <summary>
        /// Sends a change users sec msg based on the current authdata.
        /// </summary>
        public void SendChangeUsers ()
        {
            if (_authcontext == null)
            {
                throw new SGConnectionException("Cannot send without any authdata.");
            }

            if (_last_keyex_request_packet == null)
            {
                throw new SGConnectionException("Cannot send without a key exchange history.");
            }

            // create new ticket
            SgClient.BuildFakeTicket(_authcontext, _authcontext.Authdata, _authcontext.Site.serverName,
                _authcontext.Site.siteName, _authcontext.Site.siteKey);

            // create secmsg
            if (_last_change_users_req_packet == null)
            {
                _last_change_users_req_packet = new SecMsgChangeUsersReq();
            }

            // fill out sec msg
            DateTime dt = DateTime.UtcNow;
            _last_change_users_req_packet.Time = dt.Ticks;
            _last_change_users_req_packet.UserPerm = (uint)(KeyExchangeInit.DefaultUserPermutation);
            _last_change_users_req_packet.APReqData = _last_keyex_request_packet.BuildAP(_authcontext);

            Send(_last_change_users_req_packet);

            // hold on this until after we send successfully
            _last_change_users_req = dt;
            _last_change_users_req_sent = dt;
        }

        /// <summary>
        /// If it has been too long since we sent a change users request, we will send it again.
        /// </summary>
        public void ProdChangeUsers ()
        {
            if (ChangeUsersPending && ((DateTime.UtcNow - _last_change_users_req_sent) > ChangeUsersRequestTimeout))
            {
                if (_last_change_users_req_packet == null)
                {
                    throw new SGConnectionException("Cannot prod without first sending a ChangeUsersReq.");
                }

                Send(_last_change_users_req_packet);
                _last_change_users_req_sent = DateTime.UtcNow;
            }
        }

        #endregion

        #region QoS SecMsg

        /// <summary>
        /// Sends the standard QoS packet pair.
        /// </summary>
        public void SendQoS ()
        {
            // create secmsg
            if (_last_qos_init_packet == null)
            {
                _last_qos_init_packet = new SecMsgQosInit();
            }

            // fill out sec msg
            _last_qos_init_packet.Nonce = AuthUtils.GetNewNonce();
            _last_qos_init_packet.QosIdx = (ushort)RandomEx.GlobalRandGen.Next();
            _last_qos_init_packet.PktIdx = 0;
            _last_qos_init_packet.Flags = SecMsgHeader.QPF_EMPTY_FLAGS;

            // send the first packet
            _last_qos_init_time = Timing.QueryPerformanceCounter();
            _last_qos_resp_time1 = 0;
            _last_qos_resp_time2 = 0;
            Send(_last_qos_init_packet);

            // update for the second packet and send it also
            _last_qos_init_packet.Flags = SecMsgHeader.QPF_PAIR_TWO;
            Send(_last_qos_init_packet);
        }

        #endregion

        #endregion

        /// <summary>
        /// Sends the XspBuffer to the SG.
        /// </summary>
        /// <param name="secMsg">The XspBuffer to send.</param>
        public void Send (XspBuffer buffer)
        {
            _transport.Send(buffer, RemoteEndpoint);
            _last_send_time = DateTime.UtcNow;
        }

        #endregion

        #region Receive

        /// <summary>The head of the queue of received packets.</summary>
        private XspBuffer _receive_queue_head = null;
        /// <summary>The tail of the queue of received packets.</summary>
        private XspBuffer _receive_queue_tail = null;
        /// <summary>The time that the queue head was received.</summary>
        private DateTime _receive_queue_first;
        /// <summary>The time that the queue tail was received.</summary>
        private DateTime _receive_queue_last;
        /// <summary>The lock used to protect access to the receive queue.</summary>
        private readonly object _receive_queue_lock = new object();
        /// <summary>The number of connection resets since the last keyex packet was received.</summary>
        private int _receive_connection_resets = 0;

        /// <summary>The port mapping information.</summary>
        private class PortMapping
        {
            public XspBuffer Head;
            public XspBuffer Tail;
        }

        /// <summary>Incoming packet store with separate lists for each port.</summary>
        private Dictionary<uint, PortMapping> _port_mapping = new Dictionary<uint, PortMapping>();

        /// <summary>
        /// Receives packets as they are pulled from the socket.  This is run on the polling thread,
        /// so it needs to be fast.
        /// </summary>
        /// <param name="packet">The packet that was received.</param>
        /// <param name="connResets">
        /// The number of connection resets since the last keyex packet was received.
        /// Only valid for keyex packets.
        /// </param>
        private void ReceiveCallback (XspBuffer packet, int connResets)
        {
            try
            {
                // just to make sure
                packet.Next = null;

                // check if its a keyex packet and save connResets
                if (packet.DecodeSpi() == 0)
                {
                    _receive_connection_resets = connResets;
                }

                // get current time outside of lock
                DateTime temp_time = DateTime.UtcNow;

                // we don't even care if these packets are for us, we just want to put them in our queue
                lock (_receive_queue_lock)
                {
                    // means the queue is empty
                    if (_receive_queue_head == null)
                    {
                        _receive_queue_head = _receive_queue_tail = packet;
                        _receive_queue_first = _receive_queue_last = temp_time;
                    }
                    else
                    {
                        _receive_queue_tail.Next = packet;
                        _receive_queue_tail = packet;
                        _receive_queue_last = temp_time;
                    }
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("An exception occured in SGConnection.ReceiveCallback:\n" + e.ToString());
            }
        }

        /// <summary>
        /// Processes the queue of packets that we have received.
        /// Must be called regularly in order for the connection to work.
        /// </summary>
        public void ProcessReceiveQueue ()
        {
            XspBuffer queue = null;
            DateTime head_time, tail_time;

            // grab the whole packet queue
            lock (_receive_queue_lock)
            {
                queue = _receive_queue_head;
                _receive_queue_head = _receive_queue_tail = null;
                head_time = _receive_queue_first;
                tail_time = _receive_queue_last;
            }

            // process queue
            try
            {
                // empty queue
                if (queue == null) return;

                while (queue != null)
                {
                    bool packet_good = false;

                    // pull off head and advance
                    XspBuffer cursor = queue;
                    queue = queue.Next;
                    cursor.Next = null;

                    // is the packet for us?
                    if (_session != null && _session.Decode(cursor, true))
                    {
                        // gives sec msgs to our internal handler
                        if (_HandleSecMsgs && cursor.XspType == XspHeader.XSP_TYPE_SEC)
                        {
                            if (HandleSecMsg(cursor))
                            {
                                XspBufferManager.Free(cursor);
                                goto our_packet_handled;
                            }
                        }

                        uint port = MapPortForIncoming(cursor.XspType, cursor.DestPort);
                        PortMapping pm = null;

                        lock (_port_mapping)
                        {
                            if (_port_mapping.TryGetValue(port, out pm))
                            {
                                Debug.Assert(pm != null, "PortMapping should not be null if it is in the Dictionary");
                                if (pm.Head == null)
                                {
                                    pm.Head = cursor;
                                    pm.Tail = cursor;
                                }
                                else
                                {
                                    pm.Tail.Next = cursor;
                                    pm.Tail = cursor;
                                }
                            }
                            else
                            {
                                pm = new PortMapping();
                                pm.Head = cursor;
                                pm.Tail = cursor;
                                _port_mapping.Add(port, pm);
                            }
                        }

                    our_packet_handled:
                        packet_good = true;
                    }
                    else
                    {
                        // to make sure IsKeyExchangeResponse works
                        if (_session == null)
                        {
                            cursor.DecodeSpiAndFlags();
                        }

                        // is keyex packet or not for us
                        if (cursor.IsKeyExchangeResponse)
                        {
                            // we are expecting a packet and this one is it
                            if (_state == ConnectionState.ConnectWait && cursor.DecodeSpiFromKeyExPacket() == _pre_keyex_recv_spi)
                            {
                                try
                                {
                                    PostConnect(_last_keyex_request_packet, cursor);

                                    // clean up
                                    // don't clean up, as we need some of this data later
                                    // it might be better to save a smaller subset of the data though
                                    //_last_keyex_request_packet = null;

                                    packet_good = true;
                                }
                                catch (Exception e)
                                {
                                    _state = ConnectionState.Disconnected;
                                    _transport.Close(_pre_keyex_recv_spi);
                                    _last_keyex_exception = e;
                                }
                            }
                            else
                            {
                                // @@@TODO: RECORD THIS AND DISPLAY IT SOMEWHERE
                                // Or send it to the junk pile, or both
                            }
                        }
                        else
                        {
                            // @@@TODO: RECORD THIS AND DISPLAY IT SOMEWHERE
                            // Or send it to the junk pile, or both
                        }
                    }

                    // record time
                    if (packet_good)
                    {
                        if (queue == null)
                        {
                            // last packet is good, use tail time
                            _last_receive_time = tail_time;
                        }
                        else
                        {
                            // all packets were received at head time or after
                            _last_receive_time = head_time;
                        }
                    }
                }
            }
            catch
            {
                // requeue the remaining packets, hopefully this never happens
                if (queue != null)
                {
                    // find our tail
                    XspBuffer queue_tail = queue;
                    while (queue_tail.Next != null)
                    {
                        queue_tail = queue_tail.Next;
                    }

                    lock (_receive_queue_lock)
                    {
                        if (_receive_queue_head == null)
                        {
                            _receive_queue_head = queue;
                            _receive_queue_tail = queue_tail;
                            _receive_queue_first = head_time;
                            _receive_queue_last = tail_time;
                        }
                        else
                        {
                            queue_tail.Next = _receive_queue_head;
                            _receive_queue_head = queue;
                            _receive_queue_first = head_time;
                        }
                    }
                }

                throw;
            }
            finally
            {
                // check for a connection timeout based on receive time
                // make sure we have at least received something before this
                if (DateTime.MinValue != _last_receive_time && 
                    DateTime.UtcNow.Subtract(_last_receive_time) >= ConnectionReceiveTimeout)
                {
                    SetDisconnected();
                }
            }
        }

        /// <summary>
        /// Gets the port mapping for an incoming connection.
        /// </summary>
        /// <param name="xspType">The XSP type of the packet.</param>
        /// <param name="clientPort">The client side port.</param>
        /// <returns>The mapping for a XSP type/port.</returns>
        public static uint MapPortForIncoming (uint xspType, uint clientPort)
        {
            uint type = (xspType < XspHeader.XSP_TYPE_UDP_0 ? XspHeader.XSP_TYPE_TCP_0 : XspHeader.XSP_TYPE_UDP_0);
            return (xspType == XspHeader.XSP_TYPE_SEC ? 0 : ((type << 16) | (clientPort & 0xFFFF)));
        }

        /// <summary>
        /// Gets the incoming packets that are queued up for a given port.
        /// </summary>
        /// <param name="xspType">The XSP type of the packet.</param>
        /// <param name="clientPort">The client side port.</param>
        /// <returns>The head of a buffer list of packets for that port.</returns>
        public XspBuffer GetPacketsOnPort (uint xspType, uint clientPort)
        {
            return GetPacketsOnPort(MapPortForIncoming(xspType, clientPort));
        }

        /// <summary>
        /// Gets the incoming packets that are queued up for a given port.
        /// </summary>
        /// <param name="mappedPort">The mapped port.</param>
        /// <returns>The head of a buffer list of packets for that port.</returns>
        public XspBuffer GetPacketsOnPort (uint mappedPort)
        {
            PortMapping pm = null;
            XspBuffer ans = null;

            lock (_port_mapping)
            {
                if (_port_mapping.TryGetValue(mappedPort, out pm))
                {
                    Debug.Assert(pm != null, "PortMapping should not be null if it is in the Dictionary");
                    ans = pm.Head;
                    pm.Head = null;
                    pm.Tail = null;
                }
            }

            return ans;
        }

        /// <summary>
        /// Gets the first incoming packet that is queued up for a given port.
        /// </summary>
        /// <param name="mappedPort">The mapped port.</param>
        /// <returns>The first packet that is queued for that port.</returns>
        public XspBuffer GetPacketOnPort (uint mappedPort)
        {
            PortMapping pm = null;
            XspBuffer ans = null;

            lock (_port_mapping)
            {
                if (_port_mapping.TryGetValue(mappedPort, out pm))
                {
                    Debug.Assert(pm != null, "PortMapping should not be null if it is in the Dictionary");

                    if (pm.Head != null)
                    {
                        ans = pm.Head;

                        if (pm.Head == pm.Tail)
                        {
                            pm.Head = null;
                            pm.Tail = null;
                        }
                        else
                        {
                            pm.Head = pm.Head.Next;
                        }

                        // break any chain that was present
                        ans.Next = null;
                    }
                }
            }

            return ans;
        }

        /// <summary>
        /// Takes the appropriate actions for SecMsgs.  Should do the same thing regardless of the value of HandleSecMsgs.
        /// </summary>
        /// <returns>True if the SecMsg was handled; false if not.</returns>
        private bool HandleSecMsg (XspBuffer buffer)
        {
            int secMsgType = (int)(buffer.GetUInt16(4));

            if (UserSecMsgHandler != null && UserSecMsgHandler(secMsgType, buffer))
            {
                // the user handled the secmsg
                return true;
            }

            switch (secMsgType)
            {
                case SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REP:
                    if (ChangeUsersPending)
                    {
                        SecMsgChangeUsersRep cup = (SecMsgChangeUsersRep)SecMsgHeader.CreatePacket(buffer.RawBuffer, 
                            4, (int)(buffer.RawBufferLength - 4), SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REP);
                        DateTime time = new DateTime(cup.Time);

                        // time in packet matches time of last request
                        if (time == _last_change_users_req)
                        {
                            _last_change_users_rep = time;
                        }
                    }
                    break;

                case SecMsgHeader.SECMSG_TYPE_PULSE:
                    // this is simply a keep alive, timer will be updated in ProcessReceiveQueue
                    break;

                case SecMsgHeader.SECMSG_TYPE_DELETE:
                    // we got kicked!
                    SetDisconnected();
                    break;

                case SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP:
                    if (_last_qos_init_packet != null)
                    {
                        SecMsgQosResp qr = (SecMsgQosResp)SecMsgHeader.CreatePacket(buffer.RawBuffer,
                            4, (int)(buffer.RawBufferLength - 4), SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP);

                        if (_last_qos_init_packet.QosIdx == qr.QosIdx &&
                            _last_qos_init_packet.PktIdx == qr.PktIdx &&
                            System.Linq.Enumerable.SequenceEqual(_last_qos_init_packet.Nonce, qr.Nonce))
                        {
                            // good qos response
                            if ((qr.Flags & SecMsgHeader.QPF_PAIR_TWO) == SecMsgHeader.QPF_PAIR_TWO)
                            {
                                _last_qos_resp_time2 = Timing.QueryPerformanceCounter();
                            }
                            else
                            {
                                _last_qos_resp_time1 = Timing.QueryPerformanceCounter();
                            }
                        }
                    }
                    break;

                case SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2:
                    // will contain qval data, would need to save it out to a list
                    // for now we need to just discard them
                    break;

                case SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD:
                case SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD2:
                    // will contain some binary data, would need to save the messages out to a list
                    return false;

                case SecMsgHeader.SECMSG_TYPE_SGTOXB_NATDET_REP:
                    // no body, would need to save last time and source of the packet
                    return false;

                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL:
                    {
                        SecMsgSgToXbChal chal = (SecMsgSgToXbChal)SecMsgHeader.CreatePacket(buffer.RawBuffer,
                            4, (int)(buffer.RawBufferLength - 4), SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL);

                        if (CurrentChallengePacket == null || CurrentChallengePacket.ChallengeNonce != chal.ChallengeNonce)
                        {
                            // new challenge
                            CurrentChallengeReceiveCount = 1;
                        }
                        else
                        {
                            ++CurrentChallengeReceiveCount;
                        }

                        // can always update these
                        CurrentChallengePacket = chal;
                        CurrentChallengeLastReceived = DateTime.UtcNow;

                        // send an ack
                        SecMsgXbToSgChalAck ack = new SecMsgXbToSgChalAck() { ChallengeNonce = chal.ChallengeNonce };
                        Send(ack);
                    }
                    break;

                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK:
                    // clear out the current challenge, as the server has confirmed receiving it
                    {
                        SecMsgSgToXbChalRespAck ack = (SecMsgSgToXbChalRespAck)SecMsgHeader.CreatePacket(buffer.RawBuffer,
                            4, (int)(buffer.RawBufferLength - 4), SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK);

                        if (CurrentChallengePacket != null && CurrentChallengePacket.ChallengeNonce == ack.ChallengeNonce)
                        {
                            CurrentChallengePacket = null;
                            CurrentChallengeLastReceived = DateTime.MinValue;
                            CurrentChallengeReceiveCount = 0;
                        }
                    }
                    break;

                default:
                    return false;
            }

            return true;
        }

        #endregion

        #region UserData

        /// <summary>Backing for *UserData.</summary>
        private Dictionary<string, object> _userdata = new Dictionary<string,object>();

        /// <summary>
        /// Sets a user data value for the connection.
        /// </summary>
        /// <param name="index">The name of the user data object.</param>
        /// <param name="value">The user data object.</param>
        public void SetUserData (string index, object value)
        {
            lock (_userdata)
            {
                if (_userdata.ContainsKey(index))
                {
                    _userdata[index] = value;
                }
                else
                {
                    _userdata.Add(index, value);
                }
            }
        }

        /// <summary>
        /// Gets a user data value for the connection.
        /// </summary>
        /// <param name="index">The name of the user data object.</param>
        /// <returns>The user data object.</returns>
        public object GetUserData (string index)
        {
            lock (_userdata)
            {
                object ans;
                _userdata.TryGetValue(index, out ans);
                return ans;
            }
        }

        #endregion
    }

    /// <summary>
    /// An exception generated by SGConnection.
    /// </summary>
    public class SGConnectionException : Exception
    {
        public SGConnectionException (string message) : base(message) { }
        public SGConnectionException (string message, Exception exc) : base(message, exc) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\TcpForSG.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService.Auth
{

/// <summary>
/// Generates TCP header data for use when communicating through the SG.
/// A single instance should be used for a single connection, then discarded.
/// </summary>
public class TcpForSG
{
    #region Local State

    /// <summary>The local sequence number.</summary>
    protected uint _localSeq = 0;

    /// <summary>The local ack number.</summary>
    protected uint _localAck = 0;

    /// <summary>Backing for State.</summary>
    protected ConnectionState _state = ConnectionState.Closed;

    /// <summary>The connection state.</summary>
    public ConnectionState State
    {
        get { return _state; }
    }

    /// <summary>The local window size.</summary>
    protected ushort _localWindow = DefaultWindowSize;

    /// <summary>True if we have received a FIN, false if not.</summary>
    protected bool _receivedFin = false;

    /// <summary>The sequence number of the last byte on the receive stream.</summary>
    protected uint _localFinSeq = 0;

    #endregion

    #region Remote State

    /// <summary>Backing for RemoteMSS.</summary>
    protected int _remoteMSS = 1264;

    /// <summary>The MSS of the other side of the connection.</summary>
    public int RemoteMSS
    {
        get { return _remoteMSS; }
    }

    /// <summary>Backing for RemoteWindow.</summary>
    protected int _remoteWindow = 0;

    /// <summary>The current window size of the other side of the connection.</summary>
    public int RemoteWindow
    {
        get { return _remoteWindow; }
    }

    #endregion

    #region Types

    /// <summary>
    /// The connection state.
    /// </summary>
    public enum ConnectionState
    {
        SynSent,
        Established,
        //FinWait1,
        //FinWait2,
        //CloseWait,
        //Closing,
        //LastAck,
        //TimeWait,
        Closed
    }

    /// <summary>
    /// TCP flags for the header.
    /// </summary>
    [Flags]
    public enum TcpFlags : byte
    {
        Fin = 0x01,
        Syn = 0x02,
        Rst = 0x04,
        Psh = 0x08,
        Ack = 0x10,
        Urg = 0x20,
        Ece = 0x40,
        Cwr = 0x80
    }

    /// <summary>
    /// The result of an update.
    /// </summary>
    public enum UpdateResult
    {
        ConnectionClosed,
        SendHeader,
        Good,
        NonTcpPacket,
        BadHeaderSize,
        Duplicate,
    }

    #endregion

    #region Consts

    /// <summary>The default window size used by our side of the TCP connection.</summary>
    public const int DefaultWindowSize = 16432;

    /// <summary>The standard header options set the MSS to.</summary>
    public static readonly byte[] StandardSynHeaderOptions = new byte[] { 0x2, 0x4, 0x4, 0xF0 };

    #endregion

    #region Public Interface

    /// <summary>
    /// Creates a new TcpForSG object, which should be used for only one connection.
    /// </summary>
    public TcpForSG ()
    {
    }

    /// <summary>
    /// Creates the SYN header and sets the state of the connection.
    /// </summary>
    public XspTcpInfo CreateSyn (int headerOptionsSize)
    {
        _state = ConnectionState.SynSent;

        XspTcpInfo ans = new XspTcpInfo();

        ans._SeqNum = _localSeq = (uint)RandomEx.GlobalRandGen.Next();
        ans._AckNum = 0;
        ans._HdrLen = (byte)((((20 + headerOptionsSize) >> 2) << 4) & 0xFF);
        ans._Flags = (byte)TcpFlags.Syn;
        ans._Window = _localWindow;

        return ans;
    }

    /// <summary>
    /// Creates an ACK header for sending back to the remote server.
    /// </summary>
    public XspTcpInfo CreateAck (int headerOptionsSize)
    {
        bool ackFin = (_localAck == _localFinSeq) && _receivedFin;
        if (ackFin)
        {
            _state = ConnectionState.Closed;
        }

        XspTcpInfo ans = new XspTcpInfo();

        ans._SeqNum = _localSeq;
        ans._AckNum = (ackFin ? SafeAdd(_localFinSeq, 1) : _localAck);
        ans._HdrLen = (byte)((((20 + headerOptionsSize) >> 2) << 4) & 0xFF);
        ans._Flags = (byte)(ackFin ? TcpFlags.Fin | TcpFlags.Ack : TcpFlags.Ack);
        ans._Window = _localWindow;

        return ans;
    }

    #region Data In

    /// <summary>Send an ACK for every other packet.</summary>
    protected int _packetsSinceAck = 0;

    /// <summary>Container for inbound packet data.</summary>
    public class InboundPacket
    {
        public byte[] Data;
        public int Offset;
        public int Count;
        public uint Sequence;
    }

    /// <summary>List of inbound data segments.</summary>
    protected SortedList<uint, InboundPacket> _inQueue = new SortedList<uint, InboundPacket>();

    /// <summary>The index of the next data packet.</summary>
    protected int _currentReadIndex = 0;

    /// <summary>The sequence number of the next byte to be read.</summary>
    protected uint _currentReadSequence = 0;

    /// <summary>
    /// Receives external packets, storing them in our data buffer if needed.
    /// The caller no longer owns the XspBuffer, and should not free it.
    /// </summary>
    public UpdateResult ReceiveData (XspBuffer xspBuff)
    {
        return ReceiveData(xspBuff.TcpInfo, xspBuff.RawBuffer, XspBuffer.DATA_START_OFFSET, (int)xspBuff.DataBufferLength);
    }

    /// <summary>
    /// Receives external packets, storing them in our data buffer if needed.
    /// The caller no longer owns the XspBuffer, and should not free it.
    /// </summary>
    public UpdateResult ReceiveData (XspTcpInfo remote, byte[] buffer, int offset, int count)
    {
        // check for non-tcp packet, we should never get them, but we do
        if (remote == null)
        {
            return UpdateResult.NonTcpPacket;
        }

        TcpFlags rf = (TcpFlags)remote._Flags;

        switch (_state)
        {
            case ConnectionState.SynSent:
                {
                    // Check flags for SYN | ACK
                    // Ack for our Seq + 1
                    // and size needs to equal the header options
                    if (rf != (TcpFlags.Syn | TcpFlags.Ack) ||
                        remote._AckNum != SafeAdd(_localSeq, 1) ||
                        count != CalcHeaderOptionSize(remote))
                    {
                        _state = ConnectionState.Closed;
                        return UpdateResult.ConnectionClosed;
                    }

                    // we could read the options from the other side if we cared...

                    _localSeq = remote._AckNum;
                    _localAck = SafeAdd(remote._SeqNum, 1);
                    _currentReadSequence = _localAck;

                    _state = ConnectionState.Established;
                    return UpdateResult.SendHeader;
                }

            case ConnectionState.Established:
                {
                    // check for RST
                    if (FlagsContains(rf, TcpFlags.Rst))
                    {
                        _state = ConnectionState.Closed;
                        return UpdateResult.ConnectionClosed;
                    }

                    // check for bad header size
                    int headerSize = CalcHeaderOptionSize(remote);
                    if (count < (uint)headerSize)
                    {
                        return UpdateResult.BadHeaderSize;
                    }

                    uint endSeq = SafeAdd(remote._SeqNum, (uint)(count - headerSize));

                    // do we have data to save?
                    if (remote._SeqNum != endSeq)
                    {
                        // check for duplicate data
                        if (SafeGreaterThanOrEqual(_localAck, endSeq))
                        {
                            // old dup, discard
                            return UpdateResult.Duplicate;
                        }

                        // add data to queue and update ACK if necessary
                        InboundPacket nbound = new InboundPacket()
                        {
                            Data = buffer,
                            Offset = offset + headerSize,
                            Count = count - headerSize,
                            Sequence = remote._SeqNum
                        };
                        InboundPacket prevPack;
                        bool adjustAck = true;

                        if (_inQueue.TryGetValue(nbound.Sequence, out prevPack))
                        {
                            // check if the current packet has more data than the previous one
                            if (nbound.Count > prevPack.Count)
                            {
                                _inQueue[nbound.Sequence] = nbound;
                            }
                            else
                            {
                                // it had the same or less data, discard
                                adjustAck = false;
                            }
                        }
                        else
                        {
                            _inQueue.Add(nbound.Sequence, nbound);
                        }

                        // adjust local ack
                        if (adjustAck)
                        {
                            if (SafeGreaterThanOrEqual(_localAck, nbound.Sequence))
                            {
                                // If every packet before us has done this, then there is no way we have packets
                                // sitting in the queue before us that have not pushed ACK ahead
                                _localAck = endSeq;
                            }

                            // this packet brought the ack up to it, check for more after
                            if (_localAck == endSeq)
                            {
                                // increment packet ack counter
                                _packetsSinceAck += (FlagsContains(rf, TcpFlags.Psh) ? 2 : 1);

                                for (int i = _inQueue.IndexOfKey(nbound.Sequence) + 1; i < _inQueue.Count; ++i)
                                {
                                    InboundPacket temp = _inQueue.Values[i];
                                    if (!SafeGreaterThanOrEqual(_localAck, temp.Sequence))
                                    {
                                        break;
                                    }

                                    _localAck = SafeAdd(temp.Sequence, (uint)temp.Count);
                                    ++_packetsSinceAck;
                                }
                            }
                        }
                    }

                    // remove packets from outbound queue based on remote ack num
                    while (_outQueue.Count > 0)
                    {
                        OutboundPacket next = _outQueue.Peek();

                        if (SafeGreaterThanOrEqual(remote._AckNum, SafeAdd(next.Header._SeqNum, (uint)next.Data.Length)))
                        {
                            _outQueue.Dequeue();
                        }
                        else
                        {
                            break;
                        }
                    }

                    // fin flags shuts us down too
                    if (FlagsContains(rf, TcpFlags.Fin))
                    {
                        _localFinSeq = endSeq;
                        _receivedFin = true;
                        return UpdateResult.SendHeader;
                    }

                    // check for the need to send an ACK
                    if (_packetsSinceAck >= 2)
                    {
                        _packetsSinceAck = 0;
                        return UpdateResult.SendHeader;
                    }
                    else
                    {
                        return UpdateResult.Good;
                    }
                }

            case ConnectionState.Closed:
                return UpdateResult.ConnectionClosed;

            default:
                throw new TcpForSGConnectionException("Illegal connection state: " + _state);
        }
    }

    /// <summary>
    /// Reads data from the inbound queue.
    /// </summary>
    public int ReadData (byte[] buffer, int offset, int count)
    {
        try
        {
            int ans = 0;

            while (_currentReadIndex < _inQueue.Count)
            {
                InboundPacket current = _inQueue.Values[_currentReadIndex];

                if (current == null)
                {
                    ++_currentReadIndex;
                    continue;
                }

                // check for data being beyond our limit
                if (!SafeGreaterThanOrEqual(_currentReadSequence, current.Sequence))
                {
                    break;
                }

                uint endSeq = SafeAdd(current.Sequence, (uint)current.Count);
                if (SafeGreaterThanOrEqual(_currentReadSequence, endSeq))
                {
                    goto nextIndex;
                }

                // the read sequence should always be >= the current sequence
                uint seqOff = _currentReadSequence - current.Sequence;
                int len = Math.Min(current.Count - (int)seqOff, count);

                // copy the data
                Buffer.BlockCopy(current.Data, current.Offset + (int)seqOff, buffer, offset + ans, len);

                // update counters
                _currentReadSequence += (uint)len;
                count -= len;
                ans += len;

                if (count == 0)
                {
                    return ans;
                }

            nextIndex:
                _inQueue[current.Sequence] = null;
                ++_currentReadIndex;
            }

            return ans;
        }
        finally
        {
            if (_currentReadIndex >= _inQueue.Count && _currentReadIndex > 0)
            {
                _inQueue.Clear();
                _currentReadIndex = 0;
            }
        }
    }

    /// <summary>
    /// True if there is data that is currently available for reading; false otherwise.
    /// </summary>
    public bool DataAvailable
    {
        get
        {
            try
            {
                while (_currentReadIndex < _inQueue.Count)
                {
                    InboundPacket current = _inQueue.Values[_currentReadIndex];

                    if (current == null)
                    {
                        ++_currentReadIndex;
                        continue;
                    }

                    // check for data being beyond our limit
                    if (!SafeGreaterThanOrEqual(_currentReadSequence, current.Sequence))
                    {
                        break;
                    }

                    uint endSeq = SafeAdd(current.Sequence, (uint)current.Count);
                    if (SafeGreaterThanOrEqual(_currentReadSequence, endSeq))
                    {
                        goto nextIndex;
                    }

                    return true;

                nextIndex:
                    _inQueue[current.Sequence] = null;
                    ++_currentReadIndex;
                }

                return false;
            }
            finally
            {
                if (_currentReadIndex >= _inQueue.Count && _currentReadIndex > 0)
                {
                    _inQueue.Clear();
                    _currentReadIndex = 0;
                }
            }
        }
    }

    #endregion

    #region Data Out

    /// <summary>Container for outbound packet data.</summary>
    public class OutboundPacket
    {
        public byte[] Data;
        public XspTcpInfo Header;
        public DateTime LastSend = DateTime.MinValue;
    }

    /// <summary>The queue of outbound packets that have not been acked yet.</summary>
    protected Queue<OutboundPacket> _outQueue = new Queue<OutboundPacket>();

    /// <summary>The queue of packets that need to be sent.</summary>
    public IEnumerable<OutboundPacket> PacketQueue
    {
        get { return _outQueue; }
    }

    /// <summary>Constructs the packets necessary to send the given data.</summary>
    public IEnumerable<OutboundPacket> SendData (byte[] buffer, int offset, int count)
    {
        int i = 0;

        while (i < count)
        {
            OutboundPacket next = new OutboundPacket();

            int len = Math.Min(count - i, _remoteMSS);
            next.Data = new byte[len];
            Buffer.BlockCopy(buffer, offset + i, next.Data, 0, len);

            next.Header = new XspTcpInfo();
            next.Header._AckNum = _localAck;
            next.Header._Flags = (byte)((i + len == count) ? TcpFlags.Psh | TcpFlags.Ack : TcpFlags.Ack);
            next.Header._HdrLen = 0x50;
            next.Header._SeqNum = _localSeq;
            next.Header._Window = _localWindow;

            _outQueue.Enqueue(next);

            _localSeq = SafeAdd(_localSeq, (uint)len);
            i += len;
        }

        return _outQueue;
    }

    #endregion

    #endregion

    #region Helpers

    /// <summary>
    /// Calculates the size of the header options for a given TCP header.
    /// </summary>
    public static int CalcHeaderOptionSize (XspTcpInfo xti)
    {
        return ((xti._HdrLen >> 4) << 2) - 20;
    }

    /// <summary>
    /// Safely adds two uints with wrapping.
    /// </summary>
    public static uint SafeAdd (uint a, uint b)
    {
        return a + b;
    }

    /// <summary>
    /// Safely compares two uints with wrapping.
    /// </summary>
    public static bool SafeGreaterThanOrEqual (uint a, uint b)
    {
        return (a - b <= b - a);
    }

    /// <summary>
    /// Checks if a set of TCP flags fully contains another set.
    /// </summary>
    public static bool FlagsContains (TcpFlags flags, TcpFlags test)
    {
        return ((flags & test) == test);
    }

    #endregion
}

/// <summary>
/// A TCP client for use with an SGConnection.
/// </summary>
public class TcpForSGConnection : System.IO.Stream
{
    #region Connection Data

    /// <summary>Our SGConnection.</summary>
    protected SGConnection _conn = null;

    /// <summary>Our TCP header fields.</summary>
    protected TcpForSG _tcpHeader = null;

    /// <summary>The source port that we last connected on.</summary>
    protected uint _sourcePort = 0;

    /// <summary>The destination port that we last connected on.</summary>
    protected uint _destPort = 0;

    #endregion

    #region Packet Capture

    /// <summary>Container for packet that we are keeping.</summary>
    protected class PacketCap
    {
        public XspBuffer Packet;
        public bool Outbound;
        public TcpForSG.UpdateResult Result;
        public DateTime Time;
    }

    /// <summary>Packets that have flowed through this connection.</summary>
    protected List<PacketCap> _capturedPackets = new List<PacketCap>();

    /// <summary>Saves a packet onto the capture list.</summary>
    protected void CapturePacket (XspBuffer packet, bool outbound, TcpForSG.UpdateResult result)
    {
        lock (_capturedPackets)
        {
            _capturedPackets.Add(new PacketCap() { Packet = packet, Outbound = outbound, Result = result, Time = DateTime.UtcNow });
        }
    }

    #endregion

    #region Consts

    /// <summary>The time we sleep for when spin waiting.</summary>
    public const int SpinWaitSleepTime = 10;

    /// <summary>The base amount of time we will spend waiting for a TCP connection request to timeout.</summary>
    public const int ConnectWaitBaseTime = 500;

    /// <summary>The base amount of time we will spend waiting for data to be acknowledged.</summary>
    public const int SendDataWaitBaseTime = 500;

    #endregion

    #region Public Interface

    /// <summary>Creates a new TcpForSGConnection object.</summary>
    public TcpForSGConnection (SGConnection connection)
    {
        _conn = connection;
    }

    /// <summary>
    /// Connects to a destination server through the SGConnection.
    /// </summary>
    /// <param name="sourcePort">The source port to use.</param>
    /// <param name="destPort">The destination port to use.</param>
    public void Connect (ushort sourcePort, ushort destPort)
    {
        if (_conn.State != SGConnection.ConnectionState.Connected)
        {
            throw new TcpForSGConnectionException("Not connected to the SG.");
        }

        // create a new state manager
        _tcpHeader = new TcpForSG();

        // save these
        _sourcePort = sourcePort;
        _destPort = destPort;

        XspBuffer packet = null;

        // create SYN packet
        XspTcpInfo tcpInfo = _tcpHeader.CreateSyn(TcpForSG.StandardSynHeaderOptions.Length);
        int waitMult = 1;

    retry:
        packet = _conn.Session.EncodeTcp(_sourcePort, _destPort, tcpInfo,
            TcpForSG.StandardSynHeaderOptions, (uint)TcpForSG.StandardSynHeaderOptions.Length);

        // save time
        DateTime now = DateTime.UtcNow;

        _conn.Send(packet);
        CapturePacket(packet, true, (waitMult == 1 ? TcpForSG.UpdateResult.Good : TcpForSG.UpdateResult.Duplicate));

        // wait for response
        do
        {
            System.Threading.Thread.Sleep(SpinWaitSleepTime);

            // pump the tubes
            _conn.ProcessReceiveQueue();

            XspBuffer inbound = _conn.GetPacketsOnPort(XspHeader.XSP_TYPE_TCP_0, _sourcePort);

            if (inbound != null)
            {
                TcpForSG.UpdateResult result = _tcpHeader.ReceiveData(inbound);
                CapturePacket(inbound, false, result);

                if (result == TcpForSG.UpdateResult.ConnectionClosed)
                {
                    throw new TcpForSGConnectionException("Remote server failed to respond correctly to our connection request.");
                }

                if (result != TcpForSG.UpdateResult.SendHeader)
                {
                    throw new TcpForSGConnectionException("Unexpected response from the TcpForSG.");
                }

                // result is SendHeader, meaning we need to send the ACK
                packet = _conn.Session.EncodeTcp(_sourcePort, _destPort, _tcpHeader.CreateAck(0), null, 0);
                _conn.Send(packet);
                CapturePacket(packet, true, TcpForSG.UpdateResult.Good);

                if (inbound.Next != null)
                {
                    AddQueuedPackets(inbound.Next);
                }

                return;
            }
        } while ((DateTime.UtcNow - now).TotalMilliseconds < (ConnectWaitBaseTime * waitMult));

        waitMult = waitMult << 1;

        if (waitMult < 0x10)
        {
            goto retry;
        }

        throw new TcpForSGConnectionException("Timed out waiting for a response from remote server.");
    }

    /// <summary>The time to wait for a send to complete.</summary>
    public int SendTimeout { get; set; }

    /// <summary>The time to wait for a receive to complete.</summary>
    public int ReceiveTimeout { get; set; }

    /// <summary>
    /// True if there is data that is currently available for non-blocking receive; false otherwise.
    /// </summary>
    public bool DataAvailable
    {
        get
        {
            if (!CanRead)
            {
                return false;
            }

            return _tcpHeader.DataAvailable;
        }
    }

    /// <summary>
    /// Reads and writes from/to the streams as necessary.
    /// </summary>
    public void PumpStreams ()
    {
        if (CanRead)
        {
            // pump the tubes
            _conn.ProcessReceiveQueue();
            AddQueuedPackets(_conn.GetPacketsOnPort(XspHeader.XSP_TYPE_TCP_0, _sourcePort));

            // this means that the queue is not empty, presumably because we have not received an ack for every
            // packet in it
            if (CanWrite && _tcpHeader.PacketQueue.GetEnumerator().MoveNext())
            {
                SendTcpPacketQueue(_tcpHeader.PacketQueue, true);
            }
        }
    }

    #endregion

    #region Protected Interface

    /// <summary>
    /// Adds a packet list to the queue.
    /// </summary>
    /// <param name="packet">The packets to add to the queue.</param>
    protected void AddQueuedPackets (XspBuffer packet)
    {
        while (packet != null)
        {
            TcpForSG.UpdateResult result = _tcpHeader.ReceiveData(packet);
            CapturePacket(packet, false, result);

            if (result == TcpForSG.UpdateResult.SendHeader)
            {
                XspBuffer temp = _conn.Session.EncodeTcp(_sourcePort, _destPort, _tcpHeader.CreateAck(0), null, 0);
                _conn.Send(temp);
                CapturePacket(temp, true, TcpForSG.UpdateResult.Good);
            }

            packet = packet.Next;
        }
    }

    /// <summary>
    /// Sends the given queue of packets.
    /// </summary>
    protected void SendTcpPacketQueue (IEnumerable<TcpForSG.OutboundPacket> q, bool checkLastSend)
    {
        DateTime now = DateTime.UtcNow;

        foreach (TcpForSG.OutboundPacket packet in q)
        {
            if (!checkLastSend || (now - packet.LastSend).TotalMilliseconds >= SendDataWaitBaseTime)
            {
                XspBuffer current = _conn.Session.EncodeTcp(_sourcePort, _destPort, packet.Header, packet.Data, (uint)packet.Data.Length);
                _conn.Send(current);
                CapturePacket(current, true, TcpForSG.UpdateResult.Good);
                packet.LastSend = now;
            }
        }
    }

    #endregion

    #region Stream Members

    /// <summary>True if we are connected to the SG and the TCP connection has been established.</summary>
    public override bool CanRead
    {
        get
        {
            return _conn.State == SGConnection.ConnectionState.Connected;
        }
    }

    /// <summary>Can not seek.</summary>
    public override bool CanSeek
    {
        get { return false; }
    }

    /// <summary>True if we are connected to the SG and the TCP connection has been established.</summary>
    public override bool CanWrite
    {
        get
        {
            return (_tcpHeader == null ? false :
                _conn.State == SGConnection.ConnectionState.Connected && _tcpHeader.State == TcpForSG.ConnectionState.Established);
        }
    }

    /// <summary>This method is reserved for future use.</summary>
    public override void Flush ()
    {
    }

    /// <summary>Can not seek.</summary>
    public override long Length
    {
        get
        {
            throw new NotSupportedException();
        }
    }

    /// <summary>Can not seek.</summary>
    public override long Position
    {
        get
        {
            throw new NotSupportedException();
        }
        set
        {
            throw new NotSupportedException();
        }
    }

    public override int Read (byte[] buffer, int offset, int count)
    {
        if (!CanRead)
        {
            throw new TcpForSGConnectionException("Cannot read from the stream at this time.");
        }

        // save time
        DateTime now = DateTime.UtcNow;
        
        // wait for response
        do
        {
            // pump the tubes
            _conn.ProcessReceiveQueue();

            AddQueuedPackets(_conn.GetPacketsOnPort(XspHeader.XSP_TYPE_TCP_0, _sourcePort));
            int read = _tcpHeader.ReadData(buffer, offset, count);

            if (read > 0)
            {
                return read;
            }

            // if we didn't get any data and the connection is closed, we won't be getting any more
            if (_tcpHeader.State == TcpForSG.ConnectionState.Closed)
            {
                return 0;
            }

            System.Threading.Thread.Sleep(SpinWaitSleepTime);

        } while (ReceiveTimeout == 0 || (DateTime.UtcNow - now).TotalMilliseconds < ReceiveTimeout);

        throw new TcpForSGConnectionException("Timed out waiting for the server to send data to us.");
    }

    /// <summary>Can not seek.</summary>
    public override long Seek (long offset, System.IO.SeekOrigin origin)
    {
        throw new NotSupportedException();
    }

    /// <summary>Can not seek.</summary>
    public override void SetLength (long value)
    {
        throw new NotSupportedException();
    }

    /// <summary>
    /// Very simplistic version of a TCP stream write.  Currently its _very_ synchronous.
    /// </summary>
    public override void Write (byte[] buffer, int offset, int count)
    {
        if (!CanWrite)
        {
            throw new TcpForSGConnectionException("Cannot write to the stream at this time.");
        }

        SendTcpPacketQueue(_tcpHeader.SendData(buffer, offset, count), false);

        // if we aren't told to wait, don't
        if (SendTimeout <= 0)
        {
            return;
        }

        // save time
        DateTime now = DateTime.UtcNow;
        TimeSpan passed;
        int waitMult = 1;

        // wait for response
        do
        {
            System.Threading.Thread.Sleep(SpinWaitSleepTime);

            // pump the tubes
            _conn.ProcessReceiveQueue();

            AddQueuedPackets(_conn.GetPacketsOnPort(XspHeader.XSP_TYPE_TCP_0, _sourcePort));

            // this means that the queue is empty, presumably because we have received an ack for every
            // packet in it
            if (!_tcpHeader.PacketQueue.GetEnumerator().MoveNext())
            {
                return;
            }

            passed = DateTime.UtcNow - now;
            if (passed.TotalMilliseconds >= (SendDataWaitBaseTime * waitMult))
            {
                SendTcpPacketQueue(_tcpHeader.PacketQueue, false);
                waitMult = waitMult << 1;
            }

        } while (passed.TotalMilliseconds < SendTimeout);

        throw new TcpForSGConnectionException("Timed out waiting for the server to acknowledge our request.");
    }

    protected override void Dispose (bool disposing)
    {
        lock (_capturedPackets)
        {
            foreach (PacketCap pc in _capturedPackets)
            {
                XspBufferManager.Free(pc.Packet);
            }

            _capturedPackets.Clear();
        }

        base.Dispose(disposing);
    }

    #endregion
}

public class TcpForSGConnectionException : Exception
{
    public TcpForSGConnectionException (string message) : base(message) { }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\SgServerInfo.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;

using xonline.common.config;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary>
    /// Represents information about an SG server. This includes the name, xmgmt ip (not 
    /// the datacenter ip in NPDB), and the network path to the SGCFG directory.
    /// </summary>
    public class SgServerInfo
    {
        #region Public Fields

        /// <summary>Machine name of the server.</summary>
        public string Name;
        /// <summary>IP and port of the internet side of the SG.</summary>
        public IPEndPoint InternetIp;
        /// <summary>IP and port of the datacenter side of the SG.</summary>
        public IPEndPoint DatacenterIp;
        /// <summary>IP and port of the Xmgmt service on the server.</summary>
        public IPEndPoint XmgmtIp;
        /// <summary>Path to the SGCFG directory on the server.</summary>
        public string SgcfgPath;

        #endregion

        #region Static singleton

        #region Server List

        private static List<SgServerInfo> _Servers = new List<SgServerInfo>();
        private static volatile bool _ServersInitialized = false;

        /// <summary>
        /// The number of servers that we know of.
        /// </summary>
        public static int NumServers
        {
            get
            {
                if (_ServersInitialized)
                {
                    return _Servers.Count;
                }

                return Servers.Length;
            }
        }

        /// <summary>
        /// The list of servers that we know of.
        /// </summary>
        public static SgServerInfo[] Servers
        {
            get
            {
                if (_ServersInitialized)
                {
                    return _Servers.ToArray();
                }

                lock (_Servers)
                {
                    if (!_ServersInitialized)
                    {
                        string[] serverNames = Global.XEnv.GetServerListByInterface(Interface.sgsvc_int);

                        for (int i = 0; i < serverNames.Length; i++)
                        {
                            // Skip the NAT detection servers
                            if (serverNames[i].ToUpper().Contains("SECUNAT"))
                                continue;

                            // Look up the IP address associated with the server name 
                            // ("XESECUINH001", for instance). Looking up the interface ips of 
                            // "sgsvc_int" does not work. ConfigDB returns the SGMSG 
                            // interface, which XMGMT does not use.
                            IPHostEntry host = null;

                            try
                            {
                                host = Dns.GetHostEntry(serverNames[i]);
                            }
                            catch (SocketException se)
                            {
                                Global.RO.Warn("Could not resolve the server name '{0}': {1}",
                                    serverNames[i], se.Message);
                                continue;
                            }

                            // find the first IPv4 address
                            IPEndPoint ip = null;

                            foreach (IPAddress ipa in host.AddressList)
                            {
                                if (ipa.AddressFamily == AddressFamily.InterNetwork)
                                {
                                    ip = new IPEndPoint(ipa, 4100);
                                }
                            }

                            if (ip == null)
                            {
                                Global.RO.Warn("Could not find an IPv4 address for server '{0}'",
                                    serverNames[i]);
                                continue;
                            }

                            // Try to determine the path to \sgcfg\
                            string path = "";
                            string a = "d$\\webroot\\sgcfg\\";          // typical Testnet
                            string b = "c$\\esp\\webroot\\sgsvc\\sgcfg\\";   // typical Xblob
                            string c = "d$\\esp\\webroot\\sgsvc\\sgcfg\\";   // alternate Xblob
                            if (Directory.Exists("\\\\" + serverNames[i] + "\\" + a))
                                path = a;
                            else if (Directory.Exists("\\\\" + serverNames[i] + "\\" + b))
                                path = b;
                            else if (Directory.Exists("\\\\" + serverNames[i] + "\\" + c))
                                path = c;
                            else
                                path = null; // can't find one, throw an exception on use

                            //ro.Debug("Adding server {0}, ip {1}, path {2}", serverNames[i], 
                            //ip, path);
                            SgServerInfo temp_ssi = new SgServerInfo(serverNames[i], ip, path);

                            // use config to get IPs
                            temp_ssi.InternetIp = Global.XEnv.GetInterface(Interface.sgsvc, temp_ssi.Name);
                            temp_ssi.DatacenterIp = Global.XEnv.GetInterface(Interface.sgsvc_int, temp_ssi.Name);

                            _Servers.Add(temp_ssi);
                        }

                        _ServersInitialized = true;
                    }
                }

                return _Servers.ToArray();
            }
        }

        /// <summary>
        /// The names of the servers that we know of.
        /// Created each call, so reuse if possible.
        /// </summary>
        public static string[] ServerNames
        {
            get
            {
                SgServerInfo[] servers = Servers;
                string[] ans = new string[servers.Length];

                for (int i = 0; i < servers.Length; ++i)
                {
                    ans[i] = servers[i].Name;
                }

                return ans;
            }
        }

        #endregion

        #region Xmgmt and Configuration Reload

        /// <summary>
        /// Executes an Xmgmt command against the endpoint.
        /// </summary>
        /// <param name="command">The command to execute.</param>
        /// <param name="server">The server to execute the command on.</param>
        /// <param name="response">The response from running the command.</param>
        /// <returns>True if the command succeeded; false otherwise.</returns>
        public static bool Execute (string command, IPEndPoint server, out string response)
        {
            return Execute(command, server, out response, 10000);
        }

        /// <summary>
        /// Executes an Xmgmt command against the endpoint.
        /// </summary>
        /// <param name="command">The command to execute.</param>
        /// <param name="server">The server to execute the command on.</param>
        /// <param name="response">The response from running the command.</param>
        /// <param name="timeoutInMS">The timeout for running the command.</param>
        /// <returns>True if the command succeeded; false otherwise.</returns>
        public static bool Execute (string command, IPEndPoint server, out string response, int timeoutInMS)
        {
            bool bSuccess = false;
            response = "";
            try
            {
                ManagementConsole.sendTimeout = timeoutInMS;
                ManagementConsole.receiveTimeout = timeoutInMS;
                bSuccess = ManagementConsole.Execute(server, command, out response);
            }
            catch (System.IO.IOException e)
            {
                Global.RO.Warn("Error executing \"{0}\" on {1}: {2}", command, server, e.Message);
            }
            catch (System.Net.Sockets.SocketException e)
            {
                Global.RO.Warn("Error executing \"{0}\" on {1}: {2}", command, server, e.Message);
            }
            return bSuccess;
        }

        /// <summary>
        /// Executes xmgmt command "reload_config" against all known SG servers.
        /// </summary>
        public static void ReloadConfiguration ()
        {
            ReloadConfiguration(10000, true);
        }

        /// <summary>
        /// Executes xmgmt command "reload_config" against all known SG servers.
        /// </summary>
        public static void ReloadConfiguration (int timeoutInMS, bool waitForFinish)
        {
            bool lsf;
            ReloadConfiguration(timeoutInMS, waitForFinish, out lsf);
        }

        /// <summary>
        /// Calls 'e :sg reload_config' on the SGs.
        /// </summary>
        /// <param name="timeoutInMS">
        /// The maximum amount of time to wait for the reload to finish.
        /// The actual maximum could be up to twice this value.
        /// </param>
        /// <param name="waitForFinish">
        /// If true, waits for the asynchronous reload to finish; if false, returns immediately.
        /// </param>
        /// <param name="luaScriptFailure">
        /// Will be true if a lua script load failure is detected; false otherwise.
        /// </param>
        public static void ReloadConfiguration (int timeoutInMS, bool waitForFinish, out bool luaScriptFailure)
        {
            // start out false
            luaScriptFailure = false;

            SgServerInfo[] sgs = Servers;
            ServerTestFramework.Utilities.Events eventCheck = null;

            if (waitForFinish)
            {
                eventCheck = new ServerTestFramework.Utilities.Events(ServerNames);
                eventCheck.Init();
            }

            string response;
            foreach (SgServerInfo server in sgs)
            {
                if (Execute("e :sg reload_config", server.XmgmtIp, out response, timeoutInMS))
                {
                    //ro.Debug("Successfully reloaded the config on {0}. Response: {1}", 
                    //server.XmgmtIp.ToString(), response.Trim());
                }
                else
                {
                    throw new SgReloadConfigException("Failed to reload config with xmgmt on " + server.Name);
                }
            }

            if (waitForFinish)
            {
                bool reloadFailed = false;

                // wait 2 seconds for scheduled reload to begin
                System.Threading.Thread.Sleep(2000);

                int maxtime = (timeoutInMS - 2000) / 1000;
                for (int i = 0; i < maxtime; ++i)
                {
                    System.Threading.Thread.Sleep(1000);

                    // check for initial failure
                    if (!eventCheck.TestForChangeAll("SgConfig failed using new configuration", false, false))
                    {
                        reloadFailed = true;
                        break;
                    }

                    // check for Lua script failure, finding this multiple times doesn't matter
                    if ((!eventCheck.TestForChangeAll("Configuration error: Failed to load script file", false, false)) ||
                        (!eventCheck.TestForChangeAll("Configuration error: LUA operation failed for script", false, false)))
                    {
                        luaScriptFailure = true;
                    }

                    if (eventCheck.TestForChangeAll("Configuration successfully reloaded", true, false) ||
                        eventCheck.TestForChangeAll("Configuration loaded successfully", true, false))
                    {
                        return;
                    }
                }

                // check for reload error
                if (reloadFailed)
                {
                    if (!eventCheck.TestForChangeAll("SgConfig failed using last known good configuration", false))
                    {
                        Global.RO.Error("In case the test absorbed the exception, the fallback config on the SG failed to reload.  This is very bad (unless Lua caused it).");
                        throw new SgReloadConfigException("Fallback configuration failed, this is a very bad failure (unless Lua caused it).");
                    }

                    throw new SgReloadConfigException("New config failed to load, check the event log of the SGs for more information.");
                }

                throw new SgReloadConfigException("Waited for reload to finish, it did not happen within the timeout.");
            }
        }

        /// <summary>
        /// Executes xmgmt command "reload_challenges" against all known SG servers.
        /// </summary>
        public static void ReloadChallenges ()
        {
            SgServerInfo[] sgs = Servers;

            string response;
            foreach (SgServerInfo server in sgs)
            {
                if (!Execute("e :sg reload_challenges", server.XmgmtIp, out response))
                {
                    throw new SgReloadConfigException("Failed to reload challenges with xmgmt on " + server.Name);
                }
            }
        }

        #endregion

        #region Properties

        /// <summary>Backing for BestInterfaceForVip.</summary>
        private static IPAddress _BestInterfaceForVip;

        /// <summary>The best interface to </summary>
        public static IPAddress BestInterfaceForVip
        {
            get
            {
                if (_BestInterfaceForVip == null)
                {
                    _BestInterfaceForVip = ServerTestFramework.Utilities.IpHelper.GetBestInterface(
                        Global.XEnv.GetVirtualInterface(VirtualInterface.sgsvc).Address);
                }

                return _BestInterfaceForVip;
            }
        }

        #endregion

        #endregion

        #region Individual methods for each server

        public SgServerInfo (string serverName, IPEndPoint xmgmtIp) :
            this(serverName, xmgmtIp, @"d$\webroot\sgcfg")
        {
        }

        public SgServerInfo (string serverName, IPEndPoint xmgmtIp, string pathToSgcfg)
        {
            Name = serverName;
            XmgmtIp = xmgmtIp;
            XmgmtIp.Port = 4100;
            SgcfgPath = pathToSgcfg;
        }

        /// <summary>
        /// Gets a string that is the URL of the requested file on the server.
        /// </summary>
        /// <param name="configFilename">The file to get the URL for.</param>
        /// <returns>A string that is the URL of the requested file on the server.</returns>
        public string URL (string configFilename)
        {
            if (SgcfgPath == null)
            {
                throw new Exception("Unable to find a suitable \\sgcfg\\ directory on server " + Name);
            }

            return "\\\\" + Name + "\\" + SgcfgPath + "\\" + configFilename;
        }

        #endregion
    }

    /// <summary>
    /// Thrown when an error occurs during a configuration reload.
    /// </summary>
    public class SgReloadConfigException : Exception
    {
        public SgReloadConfigException (string message)
            : base(message)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\XkdcClient.cs ===
using System;
using System.Net;
using System.Diagnostics;
using System.Text;
using System.Runtime.InteropServices;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Auth
{
    public class XkdcClient : AuthClientBase
    {
        //enables overly verbose output result
        public static bool EnableOverlyVerboseOutput = false;

        //Sets all implemented client behavioral emulation.
        public bool EmulateClientBehavior
        {
            set {EmulateClientRetryAndTimingBehavior=EmulateClientMultirequestBehavior=value;}
        }

        //We used to only make a single request and fail if that times out (after 5s by default).  Set this to true to go back to that old behaviour.
        //If this is true, then we will use timeout values (replacing TimeoutInMs) and retry timedout requests similar to how a real client would do it.
        public bool EmulateClientRetryAndTimingBehavior = true;

        //By default we just make a single request and return the result of that.
        //Setting this to true will make repeated requests for each service that returned as being on a different site until all services have been obtained.  Only the last request's result is stored though.
        public bool EmulateClientMultirequestBehavior = false;

        /// <summary>
        /// XKDC constructor.
        /// </summary>
        /// <param name="ctx">AuthContext state</param>
        /// <param name="ip">IP address of the XKDC server. May be null.</param>
        /// <param name="manualSetup">If false, use default values. If true, user will set all values.</param>
        public XkdcClient(AuthContext ctx, IPEndPoint ip, bool manualSetup)
            : base(ctx, ip, manualSetup)
        {
            Initialize(ctx);
        }

        public XkdcClient(AuthContext ctx)
            : base(ctx, null, false)
        {
            Initialize(ctx);
        }

        /// <summary>
        /// Common constructor code to intialize various members and member of AuthContext
        /// </summary>
        protected override void Initialize(AuthContext ctx)
        {
            // Default IP
            if (ipServer == null)
            {
                ipServer = Global.XEnv.GetVirtualInterface(VirtualInterface.kdcsvc);
            }

            if ((ctx.IsXenonTitle || ctx.IsPanorama) && ctx.ServiceCtxXe == null)
            {
                ctx.ServiceCtxXe = new ServiceContextXe();
            }
            else if (!ctx.IsXenonTitle && ctx.ServiceCtxXbox == null)
            {
                ctx.ServiceCtxXbox = new ServiceContextXbox();
            }
        }

        /// <summary>
        /// Reset everything to valid default values. You should be able to sign in with 
        /// just these values.  Think of this as the most basic, simple, valid request possible.
        /// </summary>
        public static void SetDefaults(AuthContext ctx)
        {
            int i;

            // Normally the creation of this structure would go in Initialize(),
            // but I want to duplcate it here since it is quite possible
            // this XkdcClient object will be reused with different flags
            // set in the AuthContext.
            if ((ctx.IsXenonTitle || ctx.IsPanorama) && ctx.ServiceCtxXe == null)
            {
                ctx.ServiceCtxXe = new ServiceContextXe();
            }
            else if (!ctx.IsXenonTitle && ctx.ServiceCtxXbox == null)
            {
                ctx.ServiceCtxXbox = new ServiceContextXbox();
            }

            if (ctx.IsXenonTitle || ctx.IsPanorama)
            {
                // Prep Xenon

                ServiceContextXe sc = ctx.ServiceCtxXe;
                // Should set title info deep within CXoTest object.. ?
                sc.dwNumServices = 0;

                for (i = 0; i < sc.bServiceID3.Length; i++)
                {
                    sc.bServiceID3[i] = 0;          // XONLINE_INVALID_SERVICE
                    sc.hrServiceBytes3[i] = 1;      // S_FALSE
                }
                for (i = 0; i < sc.bServiceID4.Length; i++)
                {
                    sc.bServiceID4[i] = 0;          // XONLINE_INVALID_SERVICE
                    sc.hrServiceBytes4[i] = 1;      // S_FALSE
                }
                for (i = 0; i < sc.dwServiceID3.Length; i++)
                {
                    sc.dwServiceID3[i] = 0;         // XONLINE_INVALID_SERVICE
                    sc.hrServiceDwords3[i] = 1;     // S_FALSE
                }

                // Iterate through our desired requested services.  Place them
                // into either bServiceID3 or dwServiceID3 as appropriate.

                // PUIDs for machine and users should come from the TGT,
                // which isn't possible at the moment. 
                // TODO: do this in the DLL
                //sc.MachineID = ctx.CombinedTgt.MachineID
                //sc.MachineID = ctx.UsersMachine.xuid.qwUserID;

                // By default, we don't set services, let auto-discover do its thing.
                sc.wAutoDiscoverServices = 1;

            }
            else
            {
                // Prep Xbox

                // Should be all zeroes at this point
                ServiceContextXbox sc = ctx.ServiceCtxXbox;

                // Since we don't have auto-discover, we need to set some default services
                // to request.  
                sc.dwNumServices = 1;
                sc.dwServiceID1[0] = (uint)XOService.Signature_Server;

                // Rest are 0
                for (i = (int)sc.dwNumServices; i < sc.dwServiceID1.Length; i++)
                {
                    sc.dwServiceID1[i] = 0;         // XONLINE_INVALID_SERVICE
                    sc.hrService1[i] = 1;           // S_FALSE
                }

                // PUIDs for machine and users should come from the TGT,
                // which isn't possible at the moment. 
                // TODO: do this in the DLL
                //sc.MachineID = ctx.CombinedTgt.MachineID
                //sc.MachineID = ctx.UsersMachine.xuid.qwUserID;

            }
        }

        /// <summary>
        /// Helper function for setting up a Xenon TGS request
        /// </summary>
        /// <param name="services">Array of service ids to request. May be null.</param>
        /// <param name="bAutoDiscoverServices">True for auto-discover of services, false if they are explicitly requested</param>
        public void SetRequest(uint[] services, bool bAutoDiscoverServices)
        {
            SetRequest(services, bAutoDiscoverServices ? (ushort)1 : (ushort)0);
        }
        public void SetRequest(uint[] services, ushort autoDiscoverValue)
        {
            // Requires Xenon
            if (!authContext.IsXenonTitle && !authContext.IsPanorama)
                throw new Exception("AuthContext must be a Xenon client");

            // Set defaults, then override them with passed in params. This negates the non-manual setup,
            // as we don't want to reset the overridden values when we sign in.
            SetDefaults(authContext);
            isManualSetup = true;

            ServiceContextXe sc = authContext.ServiceCtxXe;
            sc.wAutoDiscoverServices = autoDiscoverValue;
            sc.FlowToken=authContext.FlowToken;
            if (services != null)
            {
                sc.dwNumServices = (uint)services.Length;
                int bIdx = 0;
                int dwIdx = 0;
                for (int i = 0; i < services.Length; i++)
                {
                    // TODO:
                    // Should we limit services in the byte array to under 32 or under 256?  In other words, 
                    // should we put services greater than 32 or greater than 256 in the DWORD array?
                    if (services[i] < 256 && bIdx < ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS_2)
                    {
                        if (bIdx < ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS) //first 32 block
                        {
                            sc.bServiceID3[bIdx] = (byte)services[i];
                            bIdx++;
                        }
                        else //last 96 block
                        {
                            sc.bServiceID4[bIdx-ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS] = (byte)services[i];
                            bIdx++;
                        }
                    }
                    else if (dwIdx < ServiceContextXe.XONLINE_MAX_DWORD_SERVICEIDS)
                    {
                        sc.dwServiceID3[dwIdx] = (uint)services[i];
                        dwIdx++;
                    }
                    else
                    {
                        // TODO:
                        // error, probably too many service ids >= 256
                        // What's the right action to take here?  Ignore?
                    }
                }
            }
        }

        /// <summary>
        /// Helper function for setting up a TGS request
        /// </summary>
        /// <param name="services">Array of service ids to request</param>
        public void SetRequest(uint[] services)
        {
            if (authContext.IsXenonTitle || authContext.IsPanorama)
            {
                SetRequest(services, false);
                return;
            }

            // Continue with Xbox request

            // Set defaults, then override them with passed in params. This negates the non-manual setup,
            // as we don't want to reset the overridden values when we sign in.
            SetDefaults(authContext);
            isManualSetup = true;

            ServiceContextXbox sc = authContext.ServiceCtxXbox;

            if (services != null)
            {
                if (services.Length > sc.dwServiceID1.Length)
                {
                    // TODO: need to implement ServiceContextXbox2 for this situation. Grumble.
                    // For now let's toss an exception
                    throw new Exception("You specified over 12 services for an Xbox request, this requires ServiceContextXbox2, which is not implemented yet");
                }
                sc.dwNumServices = (uint)services.Length;
                for (int i = 0; i < services.Length; i++)
                {
                    sc.dwServiceID1[i] = services[i];
                }
            }
        }

        /// <summary>
        /// Sign in to the XKDC server.
        /// </summary>
        public void SignInXkdc()
        {
            isSignedIn = false;

            // First make sure we have a valid combined TGT (from ASKDC)
            if (!authContext.IsSignedInAskdc)
            {
                AskdcClient askdc = new AskdcClient(authContext);
                askdc.EmulateClientBehavior=EmulateClientRetryAndTimingBehavior;
                askdc.SignInAskdc();
            }

            // Then set defaults if necessary
            if (!isManualSetup)
            {
                SetDefaults(authContext);
            }

            bool origIsManualSetup=isManualSetup;

            //do it
            XkdcResult lastResult=null;
            int maxTries=(EmulateClientRetryAndTimingBehavior?MAX_KERB_RETRIES:1);
            for (int curTry=0; curTry<maxTries; ++curTry)
            {
                if (EmulateClientRetryAndTimingBehavior)
                {
                    TimeoutInMs=c_dwDefaultKerbRetryDelayInMilliSeconds[curTry];
                }

                System.DateTime requestStartTime=System.DateTime.Now;
                try
                {
                    if (EmulateClientMultirequestBehavior) //make requests until we have all services
                    {
                        while (true)
                        {
                            //do a request
                            DoSignIn();
                            if (lastResult!=null && lastResult.ServiceHRs.Length>0 && lastResult.ServiceHRs[0]==1) //Note that we should never get told to try again for the first service in the list.
                            {
                                throw new Exception("Server did not return a success or explicit error code for first service ID previously requested: "+lastResult.ServiceIDs[0]);
                            }
                            lastResult=authContext.GetXkdcResult();

                            //check if we need to do another one, and set up for it if we do
                            uint []missingServices=new uint[authContext.ServiceCtxXe!=null?ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS+ServiceContextXe.XONLINE_MAX_DWORD_SERVICEIDS:ServiceContextXbox.XONLINE_LEGACY_MAX_NUMBER_SERVICE];
                            int numMissingServices=0;
                            for (int i=0; i<lastResult.NumServices; ++i)
                            {
                                if (lastResult.ServiceHRs[i]==1)
                                {
                                    missingServices[numMissingServices++]=lastResult.ServiceIDs[i];
                                }
                            }

                            if (numMissingServices>0)
                            {
                                SetRequest(missingServices);
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    else //single request
                    {
                        DoSignIn();
                    }
                    break;
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    Global.RO.Warn("Xkdc TimeoutException on attempt "+(curTry+1)+" of "+maxTries+" after "+(System.DateTime.Now-requestStartTime).TotalMilliseconds+"ms");
                    if (curTry==maxTries-1) throw;
                }
                finally
                {
                    if (EmulateClientMultirequestBehavior)
                    {
                        isManualSetup=origIsManualSetup;

                        //TODO: fill in hr information somewhere from all the requests we just did?
                    }
                }
            }

            isSignedIn = true;
        }

        //performs the actual build+send+receive after everything has been set up
        protected void DoSignIn()
        {
            try
            {
                SignInXkdcXenon();
            }
            catch (COMException e)
            {
                if (KerbErr.IsKerbErr(e.ErrorCode))
                    throw new KerbErrException(e.ErrorCode, e);
                if ((uint)e.ErrorCode == 0xD000006D || (uint)e.ErrorCode == 0xC000006D)
                    throw new LogonException("Xkdc returned 0x{0:X}, UDP port is {1}", 
                        e.ErrorCode,
                        ((IPEndPoint)Context.Udp.udpSocket.LocalEndPoint).Port);
                throw;
            }
            finally
            {
                SpewKerbclientDebug();
            }
        }

        /// <summary>
        /// Sign in Xenon-style
        /// </summary>
        protected void SignInXkdcXenon()
        {
            //verbose output for what we're about to do
            if (EnableOverlyVerboseOutput)
            {
                Global.RO.Debug("Making xkdc request:");

                //build user list
                string usersString="";
                if (authContext.Users!=null)
                {
                    for (int i=0; i<authContext.Users.Length; ++i)
                    {
                        if (authContext.Users[i]!=null && authContext.Users[i].GetGamertag().Length>0)
                        {
                            if (usersString.Length!=0)
                            {
                                usersString+=", ";
                            }
                            usersString+="User["+i+"]="+authContext.Users[i].GetGamertag();
                        }
                    }
                }

                //spit out
                Global.RO.Debug("title="+string.Format("0x{0:X}, version {1}, flash {2}", authContext.TitleInfo.TitleId, authContext.TitleInfo.TitleVersion, authContext.TitleInfo.FlashVersion));
                Global.RO.Debug("machine="+string.Format("0x{0:X}", authContext.UsersMachine.xuid.qwUserID)+"  -  "+(usersString.Length>0?usersString:"No users"));

                ServiceContextXe sc=authContext.ServiceCtxXe;
                string services="Autodiscover="+sc.wAutoDiscoverServices;
                services+="  Services:";
                for (int s=0; s<ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS; ++s)
                {
                    if (sc.bServiceID3[s]!=0)
                    {
                        services+=" "+sc.bServiceID3[s];
                    }
                }
                for (int s=ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS; s<ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS_2; ++s)
                {
                    if (sc.bServiceID4[s-ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS]!=0)
                    {
                        services+=" "+sc.bServiceID4[s-ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS];
                    }
                }
                for (int s=0; s<ServiceContextXe.XONLINE_MAX_DWORD_SERVICEIDS; ++s)
                {
                    if (sc.dwServiceID3[s]!=0)
                    {
                        services+=" "+sc.dwServiceID3[s];
                    }
                }
                Global.RO.Debug(services);
            }

            // Set some stuff.  These are not used in the TGS anywhere that I know of, 
            // but it seems useful to set the field here.
            authContext.ServiceCtxXe.MachineID = authContext.UsersMachine.xuid.qwUserID;

            // Each new request should clear the ctNumNonces field, or else it will start 
            // trouncing memory by incrementing beyond the array.
            authContext.ServiceCtxXe.ctNumNonces = 0;

            // Store bytes 
            byte[] bytesTitleInfo = (byte[])authContext.TitleInfo;
            byte[] bytesServiceCtx = (byte[])authContext.ServiceCtxXe;

            // Set up a default preauth list if none was provided
            uint serviceRequestPerauthNumber=PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST2;
            if (authContext.XenonPreauthVersion==5)
            {
                serviceRequestPerauthNumber=PreAuthType.KRB5_PADATA_XENON_SERVICE_REQUEST3;
            }

            uint []preauthList=authContext.PreAuthListXkdc;
            if (preauthList==null)
            {
                preauthList = new uint[] {
                    PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                    serviceRequestPerauthNumber };
            }

            // Build it
            packetLength = packet.Length;
            try
            {
                DLL_BuildXenonTgs(
                    bytesTitleInfo,
                    authContext.CombinedTgt.tgtToken,
                    preauthList,
                    (uint)preauthList.Length,
                    packet,
                    ref packetLength,
                    bytesServiceCtx
                    );
            }
            finally
            {
                SpewKerbclientDebug();
            }

            // Send and receive
            SendRecv("Xkdc");

            if (packetLength < 100)
            {
                Global.RO.Warn("SignInXkdcXenon: returned packet is {0} bytes long, this is too short", packetLength);
                return;
            }

            // Process it
            byte []sessionKeyFromTgt=new byte[16];
            try
            {
                DLL_VerifyXenonTgs(
                    authContext.CombinedTgt.tgtToken,
                    packetRecv,
                    packetRecvLength,
                    bytesServiceCtx,
                    sessionKeyFromTgt
                    );
            }
            finally
            {
                SpewKerbclientDebug();
            }

            // Retrieve Authdata from the encrypted and packed ticket inside the ServiceContext
            authContext.Authdata = GetAuthDataStruct(bytesServiceCtx);

            // Results from the TGS should be stored in the ServiceContext
            authContext.ServiceCtxXe.ReadBytes(bytesServiceCtx);

            //verbose result
            if (EnableOverlyVerboseOutput)
            {
                Global.RO.Debug("Got xkdc response:");
                bool fallbackToOldMethod=false;

                try
                {
                    long bytesUsed;
                    ServerTestFramework.LiveService.Auth.Asn.AsnValueBase asn=ServerTestFramework.LiveService.Auth.Asn.Compound.AsnValueParser.Parse(packetRecv, 0, packetRecvLength, out bytesUsed);
                    XkdcGenericReply reply=XkdcGenericReply.CreateFromAsnForClientType(asn, authContext.ClientType);
                    if (authContext.ServiceCtxXe!=null)
                    {
                        byte []site1SgKey=ServiceKeys.GetServiceKey(ServiceKeys.Key_SG, "sg", "site1");
                        reply.Decrypt(sessionKeyFromTgt, site1SgKey, authContext.ServiceCtxXe.Nonce[0]);
                    }

                    Global.RO.Debug(reply.ToString());

                    if (reply.Output==null)
                    {
                        fallbackToOldMethod=true;
                        Global.RO.Debug("Managed client failed to decrypt response.");
                    }
                }
                catch (System.Exception e)
                {
                    fallbackToOldMethod=true;
                    Global.RO.Debug("Exception parsing native xkdc client response using managed client ("+e.Message+").");
                }

                if (fallbackToOldMethod)
                {
                    Global.RO.Debug("Falling back to old native verbose output.");
                    XkdcResult localresult=null;
                    if (authContext.ServiceCtxXe!=null) localresult=authContext.ServiceCtxXe.GetXkdcResult();
                    else if (authContext.ServiceCtxXbox!=null) localresult=authContext.ServiceCtxXbox.GetXkdcResult();

                    if (localresult!=null)
                    {
                        //services and overall sr
                        string servs="Overall sr"+string.Format("=0x{0:X}",localresult.ServiceHR)+".  "+(localresult.authData==null?"authData is null":"authData is set")+".  Service HRs:";
                        for (int s=0; s<localresult.ServiceIDs.Length; ++s)
                        {
                            if (localresult.ServiceIDs[s]!=0)
                            {
                                servs+="  "+localresult.ServiceIDs[s]+string.Format("=0x{0:X}",localresult.ServiceHRs[s]);
                            }
                        }
                        Global.RO.Debug(servs);

                        //user privilege bits and info
                        string userInfo="";
                        for (int userNum=0; userNum<4; ++userNum)
                        {
                            //privs
                            string privs="";

                            for (int privNum=0; privNum<=255; ++privNum)
                            {
                                int whichDword=privNum/32;
                                int whichBit=privNum%32;
                                bool offered=(localresult.Privileges[userNum, whichDword] & (1<<whichBit)) != 0;

                                if (offered)
                                {
                                    if (privs.Length>0) privs+=",";
                                    privs+=privNum;
                                }
                            }

                            if (privs.Length>0)
                            {
                                Global.RO.Debug("Privelege bits for user "+userNum+": "+privs);
                            }

                            //info
                            userInfo+=(userInfo.Length>0?",  ":"")+"User["+userNum+string.Format("] hr=0x{0:X}", localresult.UserHRs[userNum])+string.Format(" flags=0x{0:X}", localresult.UserFlags[userNum]);
                        }
                        Global.RO.Debug(userInfo);
                    }
                    else
                    {
                        Global.RO.Debug("No usable result returned from xkdc.");
                    }
                }
            }

            //Verify some common response properties
            int requestVersion=0;
            if (authContext.XenonPreauthVersion==5 && authContext.TitleInfo.OverrideDefaultServiceRequest!=0 && authContext.TitleInfo.OverrideDefaultServiceRequestVersion>=6) //v6+ request
            {
                requestVersion=authContext.TitleInfo.OverrideDefaultServiceRequestVersion;
            }
            else
            {
                requestVersion=authContext.XenonPreauthVersion;
            }
            bool gotTicket=(authContext.ServiceCtxXe.siteIPAddress.S_addr!=0);
            bool isAutoDiscover=(authContext.ServiceCtxXe.wAutoDiscoverServices!=0);
            AuthClientBase.VerifyXkdcResponseCommon(requestVersion, authContext.ServiceCtxXe.ServiceAddressPreauthVersion==6, gotTicket, authContext.ExpectXkdcServiceAddressFailed, authContext.ServiceCtxXe.hr, authContext.ServiceCtxXe.hrUser, isAutoDiscover, authContext.ExpectXkdcValidTicket);
        }

        protected Authdata_Base GetAuthDataStruct(byte[] bytesServiceCtx)
        {
            byte[] recvBuff = new byte[1024];  // 1024 is max ticket length, so AD should never be larger than this
            uint adSize = (uint)recvBuff.Length;
            ushort adVersionShort = 0;
            try
            {
                byte []site1SgKey=ServiceKeys.GetServiceKey(ServiceKeys.Key_SG, "sg", "site1");

                DLL_GetAuthDataStruct(
                    site1SgKey,
                    bytesServiceCtx,
                    recvBuff,
                    out adSize,
                    out adVersionShort);

                // Determine version and create appropriate structure
                uint adVersion = (uint)adVersionShort;
                if (adVersion == 4)
                {
                    Authdata_Xenon2 ad = new Authdata_Xenon2();
                    ad.ReadBytes(recvBuff);
                    return (Authdata_Base)ad;
                }
                else if (adVersion == 3)
                {
                    Authdata_Xenon ad = new Authdata_Xenon();
                    ad.ReadBytes(recvBuff);
                    return (Authdata_Base)ad;
                }
                else if (adVersion == 2)
                {
                    Authdata_Xbox2 ad = new Authdata_Xbox2();
                    ad.ReadBytes(recvBuff);
                    return (Authdata_Base)ad;
                }
                else
                {
                    return null;
                }
            }
            catch (Exception)
            {
                // An exception here likely means we couldn't decrypt the ticket. This means that after
                // decrypting, the checksums didn't match.  I suspect this means when we don't successfully
                // log in -- thus, we don't get a valid ticket back (or a ticket we expect?  or any ticket at all?)
                // and it fails.  
                //Global.RO.Warn("GetAuthDataStruct failed");

                //Global.RO.Warn("Exception while calling DIGetAuthDataStruct(): " + e.Message);
            }
            finally
            {
                SpewKerbclientDebug();
            }
            return null;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\XmacsClient.cs ===
using System;
using System.Net;
using System.Diagnostics;
using System.Text;
using System.Runtime.InteropServices;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Auth
{
    public class XmacsClient : AuthClientBase
    {
        //static constructor, hook us up to callback for environment changes
        static XmacsClient()
        {
            Global.Singleton.EnvironmentChangedSuccessEvent+=EnvironmentChangedCallback;
            EnvironmentChangedCallback(null);
        }

        /// <summary>
        /// Xenon constructor, allows for custom console certificates to be used
        /// </summary>
        /// <param name="ctx">AuthContext state</param>
        /// <param name="cert">Your own custom ConsoleCertificate. May be null.</param>
        /// <param name="ip">IP address of the XMACS server. May be null.</param>
        /// <param name="manualSetup">If false, use default values. If true, user will set all values.</param>
        public XmacsClient (AuthContext ctx, ConsoleCertificate cert, IPEndPoint ip, bool manualSetup)
            : base(ctx, ip, manualSetup)
        {
            authContext.ConsoleCert = cert;
            Initialize(ctx);
        }

        public XmacsClient (AuthContext ctx)
            : base(ctx, null, false)
        {
            Initialize(ctx);
        }

        public XmacsClient (MachineEditor medit)
            : base(new AuthContext(ClientTypeFromMachinePuid(medit.Id)), null, false)
        {
            Initialize(authContext);

            //set info for the machine
            string consoleId=medit.ConsoleId;
            authContext.MachineUser.SetGamertag(consoleId);
            authContext.ConsoleCert = new ConsoleCertificate();
            authContext.ConsoleCert.SetConsoleIdFromGamertag(consoleId);
        }

        private static object lockCreateToken = new object();

        //We used to only make a single request and fail if that times out (after 5s by default).  Set this to true to go back to that old behaviour.
        //If this is true, then we will use timeout values (replacing TimeoutInMs) and retry timedout requests similar to how a real client would do it.
        public bool EmulateClientBehavior = true;

        /// <summary>
        /// Return the console id, which is really the gamertag
        /// </summary>
        public string ConsoleId 
        {
            get 
            {
                if (Context == null || Context.MachineUser == null)
                    return null;
                // Gamertag is XE.nnnnnnnnnnnn, so strip off the "XE."
                return AuthClientBase.BytesToString(Context.MachineUser.Gamertag).Substring(3);
            }
        }

        /// <summary>
        /// Return the machine puid, which is only known after the account is created 
        /// </summary>
        public ulong MachinePuid 
        {
            get 
            {
                if (Context == null || Context.UsersMachine == null)
                    return 0;
                return Context.UsersMachine.xuid.qwUserID;
            }
        }

        /// <summary>
        /// Common constructor code to intialize various members and member of AuthContext
        /// </summary>
        protected override void Initialize (AuthContext ctx)
        {
            // Default IP
            if(ipServer == null)
            {
                ipServer = Global.XEnv.GetVirtualInterface(VirtualInterface.kdcsvc);
            }

            // machine request
            if(ctx.MachineUser == null)
                ctx.MachineUser = new XonlinepUser();

            // Default cert
            if(ctx.IsXenonConsole && ctx.ConsoleCert == null)
            {
                // Use default one
                ctx.ConsoleCert = new ConsoleCertificate();
            }

            //set a serial number so that we'll use request2 by default
            if (ctx.IsXenonConsole && ctx.ConsoleSerialNumber==null && ctx.UseXenonMac2)
            {
                ctx.ConsoleSerialNumber=ServerTestFramework.LiveService.Auth.Asn.Kerberos.PreauthXenonMacRequest2.GenerateRandomConsoleSerialNumber();
            }
        }

        /// <summary>
        /// Reset everything to valid default values. You should be able to sign in with 
        /// just these values.  Think of this as the most basic, simple, valid request possible.
        /// </summary>
        public static void SetDefaults (AuthContext ctx)
        {
            if(ctx.IsXenonConsole)
            {
                // Default cert
                if(ctx.IsXenonConsole && ctx.ConsoleCert == null)
                {
                    // Use default one
                    ctx.ConsoleCert = new ConsoleCertificate();
                }

                // XMACS Key - do we really want random?
                rand.NextBytes(ctx.MachineUser.Key);

                // XMACS Principal (gamertag), make a new one
                string principal = GenerateXenonPrincipal();
                // set console cert then set machine user gamertag. important to do both.
                ctx.ConsoleCert.SetConsoleIdFromGamertag(principal);
                BuildXenonConsolePrincipal(ctx.ConsoleCert.ConsoleId, ctx.MachineUser.Gamertag);

                //set a serial number so that we'll use request2 by default
                if (ctx.ConsoleSerialNumber==null && ctx.UseXenonMac2)
                {
                    ctx.ConsoleSerialNumber=ServerTestFramework.LiveService.Auth.Asn.Kerberos.PreauthXenonMacRequest2.GenerateRandomConsoleSerialNumber();
                }
            }
            else if(ctx.IsPanorama)
            {
                // The new AuthContext.PassportAuthenticate() will automatically create a 
                // new Passport user for you.  The DoS2 caches in xmacs and askdc 
                // necessitate this.
                //ctx.PassportMemberName = "kdctest@xboxtest.com";
                //ctx.PassportPassword   = "SuperSecret1";
                ctx.PcId               = new byte[8];
                rand.NextBytes(ctx.PcId);
                if (ctx.SponsorToken==null) ctx.SponsorToken = "PPPPP-PPPPP-PPPPP-PPPPP-PPPPP";
            }
            else
            {
                // XMACS Key - don't use random
                string key = "0xB274D292FE16A0175870DB617B02D0AD";
                ctx.MachineUser.Key = Hexer.unhex(key);

                // XMACS Principal (gamertag), make a new one
                string serial = GenerateDevkitSerial();
                AuthClientBase.StringToBytes(ctx.MachineUser.Gamertag, serial);
            }

            // Clear out results from last XMACS and ASKDC result, if any
            ctx.UsersMachine = null;
            ctx.CombinedTgt = null;

            SetDefaults(ctx.MachineUser);
        }

        /// <summary>
        /// Set defaults for machine for Key, KerberosRealm, and Domain. 
        /// Does not set the gamertag since it depends on Xenon/Xbox.
        /// </summary>
        /// <param name="machine"></param>
        public static void SetDefaults (XonlinepUser machine)
        {
            // XMACS Kerberos Realm
            AuthClientBase.StringToBytes(machine.KerberosRealm, "MACS.XBOX.COM");

            // XMACS Domain is null (is this important? need to overwrite ASKDC's stuff?)
            AuthClientBase.StringToBytes(machine.Domain, null);

            // Hmm, I saw this in kerbclient
            machine.xuid.qwUserID = 1;
        }

        public TgtContext tgtContext = null;
        private byte[] bytesMachineUser;

        /// <summary>
        /// Sign in to the XMACS server.  You should tweak the values in TitleInfo,
        /// machineUser, and consoleCert before calling this, if you want anything but 
        /// the default request.
        /// </summary>
        /// <returns></returns>
        public void SignInXmacs ()
        {
            //decrement uses left for limited machine on the same token (this is for informational purposes only)
            if (authContext.IsPCLimited)
            {
                if (authContext.LimitedMacsLeft>0)
                    --authContext.LimitedMacsLeft;
            }

            //do request
            int maxTries=(EmulateClientBehavior?MAX_KERB_RETRIES:1);
            for (int curTry=0; curTry<maxTries; ++curTry)
            {
                if (EmulateClientBehavior)
                {
                    TimeoutInMs=c_dwDefaultMACSRetryDelayInMilliSeconds[curTry];
                }

                System.DateTime requestStartTime=System.DateTime.Now;
                try
                {
                    BuildRequest();
                    SendRecv("Xmacs");
                    break;
                }
                catch (ServerTestFramework.Utilities.TimeoutException)
                {
                    Global.RO.Warn("Xmacs TimeoutException on attempt "+(curTry+1)+" of "+maxTries+" after "+(System.DateTime.Now-requestStartTime).TotalMilliseconds+"ms");
                    if (curTry==maxTries-1) throw;
                }
            }

            //
            VerifyResponse();
        }

        /// <summary>
        /// Signs into the xmacs using a specific machine puid.
        /// </summary>
        /// <param name="machinePuid"></param>
        public void SignInXmacsWithMachinePuid(ulong puid)
        {
            //look up machine gamertag for this puid
            string machGamerTag = UodbWS.LookupConsoleIDFromMachineID(puid);
            if (machGamerTag==null || machGamerTag.Length==0)
            {
                throw new System.Exception("Failed to look up machine gamertag for the puid " + puid);
            }

            //
            SignInXmacsWithConsoleID(machGamerTag);
        }

        /// <summary>
        /// Signs into the xmacs using a specific consoleID.
        /// </summary>
        /// <param name="machinePuid"></param>
        public void SignInXmacsWithConsoleID(string cid)
        {
            if (!authContext.IsSignedInXmacs)
            {
                SetDefaults(this.authContext);
                this.isManualSetup = true;
            }
            authContext.MachineUser.SetGamertag(cid);
            authContext.ConsoleCert = new ConsoleCertificate();
            authContext.ConsoleCert.SetConsoleIdFromGamertag(cid);

            SignInXmacs();
        }

        /// <summary>
        ///  Builds up an XMACS request based on the ClientType of the 
        ///  AuthContext
        /// </summary>
        public void BuildRequest()
        {
            isSignedIn = false;

            if (!isManualSetup && !authContext.IsSignedInXmacs)
            {
                SetDefaults(authContext);
            }

            tgtContext = new TgtContext();

            bytesMachineUser = (byte[])authContext.MachineUser;

            try
            {
                if(authContext.IsPanorama)
                    BuildPanoramaRequest();

                else if(authContext.IsXenonConsole)
                    BuildXenonRequest();

                else
                    BuildXboxRequest();
            }
            catch(Exception)
            {
                tgtContext.Dispose();
                tgtContext = null;
                throw;
            }
            finally
            {
                SpewKerbclientDebug();
            }
        }


        private void BuildXboxRequest()
        {
            byte[] bytesTitleInfo = (byte[])authContext.TitleInfo;

            // Set up a default preauth list if none was provided
            uint []preauthList=authContext.PreAuthListXmacs; //default here is same as askdc since internal code path is same-ish in kerbclient
            if (preauthList==null)
            {
                preauthList = new uint[] {
                    PreAuthType.KRB5_PADATA_COMPOUND_IDENTITY,
                    PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                    PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                    PreAuthType.KRB5_PADATA_XBOX_ECHO };
            }

            // Build it
            packetLength = packet.Length;
            DLL_BuildXboxMachine(
                bytesTitleInfo,         // in
                (byte[])authContext.MachineUser,       // in
                preauthList,
                (uint)preauthList.Length,
                packet,
                ref packetLength,
                tgtContext.tgtToken);
        }


        private void BuildXenonRequest()
        {
            byte[] bytesTitleInfo = (byte[])authContext.TitleInfo;

            byte[] bytesConsoleCert;
            int bSignConsoleCert=1;

            bytesConsoleCert = (byte[])authContext.ConsoleCert;

            //serialize serial number
            byte []serialNumber=null;
            if (authContext.UseXenonMac2)
            {
                if (authContext.ConsoleSerialNumber!=null)
                {
                    serialNumber=ServerTestFramework.Utilities.ByteEncoding.Instance.GetBytes(authContext.ConsoleSerialNumber);
                    if (serialNumber.Length!=12)
                    {
                        throw new System.Exception("Console serial number must be exactly 12 bytes.");
                    }
                }
                else //make one up
                {
                    serialNumber=ServerTestFramework.Utilities.ByteEncoding.Instance.GetBytes(ServerTestFramework.LiveService.Auth.Asn.Kerberos.PreauthXenonMacRequest2.GenerateRandomConsoleSerialNumber());
                }
            }
            else //just pass blank
            {
                serialNumber=new byte[12];
            }

            // Set up a default preauth list if none was provided
            uint []preauthList=authContext.PreAuthListXmacs;
            if (preauthList==null)
            {
                if (authContext.UseXenonMac2)
                {
                    preauthList = new uint[] {
                        PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                        PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                        PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST2 };
                }
                else
                {
                    preauthList = new uint[] {
                        PreAuthType.KRB5_PADATA_PAC_REQUEST_EX,
                        PreAuthType.KRB5_PADATA_ENC_TIMESTAMP,
                        PreAuthType.KRB5_PADATA_XBOX_CLIENT_VERSION,
                        PreAuthType.KRB5_PADATA_XENON_MAC_REQUEST };
                }
            }

            //
            packetLength = packet.Length;
            DLL_BuildXenonMachine(
                bytesConsoleCert,
                bSignConsoleCert,       // 1 or 0
                authContext.UseXmacsTestKey ? 1 : 0,
                bytesTitleInfo,         // in
                bytesMachineUser, // in
                preauthList,
                (uint)preauthList.Length,
                packet,
                ref packetLength,
                tgtContext.tgtToken,
                serialNumber);
        }

        private static object buildPanLock=new object();

        private void BuildPanoramaRequest()
        {
            // Get a Passport ticket for Panorama sign-ins automatically, but only if we 
            // need to and only if the user is not using manual setup. Presumably, only 
            // the KDC tests will use manual setup.
            if(authContext.PassportTicket == null || authContext.PassportSessionKey == null)
            {
                if(!isManualSetup)
                {
                    if (authContext.DefaultPcXmacsPreauth==2)
                    {
                        authContext.PassportAuthenticate("MBI", AuthClientBase.PassportSite.KdcPanorama);
                    }
                    else
                    {
                        authContext.PassportAuthenticate("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
                    }
                }
                else
                {
                    Global.RO.Warn("Your PassportTicket in authContext is null, maybe you want to call PassportAuthenticate()?");
                }
            }

            // Set up a default preauth list if none was provided
            uint []preauthList=authContext.PreAuthListXmacs;
            if (preauthList==null)
            {
                if (authContext.DefaultPcXmacsPreauth==2)
                {
                    preauthList = new uint[] {
                        PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION2,
                        PreAuthType.KRB5_PADATA_ENC_TIMESTAMP };
                }
                else
                {
                    preauthList = new uint[] {
                        PreAuthType.KRB5_PADATA_PC_ACCOUNT_CREATION,
                        PreAuthType.KRB5_PADATA_ENC_TIMESTAMP };
                }
            }

            // Build it
            packetLength = packet.Length;

            lock (buildPanLock)
            {
                DLL_BuildPcMachineRequest(
                    authContext.PassportTicket,
                    authContext.PassportTicket != null ? authContext.PassportTicket.Length : 0,
                    authContext.PcId,
                    authContext.PcId != null ? authContext.PcId.Length : 0,
                    authContext.SponsorToken,
                    authContext.PassportSessionKey,
                    authContext.PassportSessionKey != null ? authContext.PassportSessionKey.Length : 0,
                    authContext.k_PcMachineName,        // pc.@xbox.com
                    authContext.k_XboxKerberosRealm,    // xbox.com
                    authContext.k_MacsKerberosRealm,    // macs.xbox.com
                    preauthList,
                    (uint)preauthList.Length,
                    authContext.UseXmacsTestKey,
                    packet,
                    out packetLength,
                    tgtContext.tgtToken);
            }
        }


        /// <summary>
        ///  Verifies the integrity of the response of the XMACS.
        /// </summary>
        public void VerifyResponse ()
        {
            if(tgtContext == null)
                throw new FieldAccessException("The TgtContext is null. This can occur if BuildRequest was not called before calling VerifyResponse, or if BuildRequest encountered an exception.");

            try
            {
                if(authContext.IsPanorama)
                    VerifyPanoramaResponse();

                else if(authContext.IsXenonConsole)
                    VerifyXenonResponse();

                else
                    VerifyXboxResponse();
            }
            catch(COMException e)
            {
                if(KerbErr.IsKerbErr(e.ErrorCode))
                    throw new KerbErrException(e.ErrorCode, e);
                throw;

            }
            finally
            {
                SpewKerbclientDebug();

                tgtContext.Dispose();
                tgtContext = null;
            }

            // Result from XMACS will now be stored in the UsersMachine member.
            authContext.UsersMachine = new XonlinepUser();
            authContext.UsersMachine.ReadBytes(bytesMachineUser);

            // Update the realm to prepare for ASKDC sign in
            if(authContext.UsersMachine != null)
            {
                StringToBytes(authContext.UsersMachine.Domain, authContext.k_XboxKerberosRealm);

                // Upates from MACS.XBOX.COM to PASSPORT.NET
                StringToBytes(authContext.UsersMachine.KerberosRealm, authContext.k_PassportKerberosRealm);
            }

            isSignedIn = true;
        }


        private void VerifyXboxResponse ()
        {
            DLL_VerifyMachine(
                    packetRecv,
                    packetRecvLength,
                    tgtContext.tgtToken,
                    bytesMachineUser); // out
        }

        private void VerifyXenonResponse ()
        {
            DLL_VerifyMachine(
                    packetRecv,
                    packetRecvLength,
                    tgtContext.tgtToken,
                    bytesMachineUser); // out
        }

        private void VerifyPanoramaResponse ()
        {
            DLL_VerifyPcMachine(
                    packetRecv,
                    packetRecvLength,
                    tgtContext.tgtToken,
                    bytesMachineUser); // out
        }

        private static AuthContext.ClientTypes ClientTypeFromMachinePuid(ulong puid)
        {
            if ((puid&0xfa00000000000000) == 0xfa00000000000000)
            {
                return AuthContext.ClientTypes.Xenon;
            }
            else if ((puid&0xfb00000000000000) == 0xfb00000000000000)
            {
                return AuthContext.ClientTypes.Panorama;
            }
            else
            {
                return AuthContext.ClientTypes.Xbox;
            }
        }

        public ulong GetMachinePuid()
        {
            // Gotta be signed in
            if (!authContext.IsSignedInXmacs)
                throw new Exception("Must be signed in to XMACS to get the machine puid");

            // Have we already retrieved the puid?
            if (authContext.UsersMachine.xuid.qwUserID != 0)
                return authContext.UsersMachine.xuid.qwUserID;

            // Talk to uodb to get the puid and store it in UsersMachine
            string gamertag = AuthClientBase.BytesToString(authContext.UsersMachine.Gamertag);
            ulong machinepuid = UodbWS.GetUserIDFromGamerTag(gamertag);
            authContext.UsersMachine.xuid.qwUserID = machinepuid;
            return machinepuid;
        }

        public static bool ResetToken(string token, int useCount, int tokenStatus, bool bDeleteUseAccounts)
        {
            // token:
            //   "nnnnn-nnnnn-nnnnn-nnnnn-nnnnn"
            // status:
            //   0 valid
            //   1 invalid
            //   2 banned

            // First convert string token to hash
            byte[] hash = Ppa.CalculateVoucherSha(token);

            string cmd = String.Format(
                "update t_vouchers set i_use_count={0}, i_voucher_status_id={1} where bin_voucher_hash=0x{2}",
                useCount, tokenStatus, Hexer.tohex(hash));
            int count = TokendbWS.ExecuteSQLNonQuery(cmd, BitConverter.ToInt64(hash, 0));
            if (count < 1)
            {
                throw new StfException("Failed to update voucher token {0}, ExecuteSQLUpdate returned {1}", token, count);
            }

            // Delete rows in t_pc_accounts that use this voucher?  This is how the 
            // use_count is actually trcked, the i_use_count field is never decremented.
            if (bDeleteUseAccounts)
            {
                UodbTable dbtable2 = new UodbTable("t_pc_accounts", "bin_voucher_hash");
                dbtable2.SetConstraint("bin_voucher_hash", hash);
                count = UodbWS.ExecuteSQLDelete(dbtable2);
                // we may delete 0, 1, or more.. can't check anything.
            }

            return true;
        }


        /// <summary>
        /// Generate Xbox (not Xenon) serial # for gamertag.
        /// </summary>
        /// <returns></returns>
        public static string GenerateDevkitSerial ()
        {
            // 12 byte string of numbers
            // Indices 8 and 9 should be "99", i.e.
            // ________99__

            StringBuilder sb = new StringBuilder();
            for(int i = 0; i < 12; i++)
            {
                if(i == 8 || i == 9)
                {
                    sb.Append("9");
                }
                else
                {
                    int n = rand.Next(10);
                    sb.Append(n.ToString());
                }
            }
            System.Diagnostics.Debug.Assert(sb.Length == 12, "xbox devkit serial string length");
            return sb.ToString();
        }

        /// <summary>
        /// Generate Xenon (not Xbox) principal for gamertag. This is an encoded version of the
        /// console id, which is a 5 byte array with a 4 bit checksum on the end. Thus the 
        /// principal is a bit tricky to generate correctly.
        /// </summary>
        /// <returns></returns>
        public static string GenerateXenonPrincipal ()
        {
            // First generate a totally random 5 byte array
            byte[] id = new byte[5];
            rand.NextBytes(id);

            // Encode to a string (as byte array). The checksum will be wrong.
            byte[] principal = new byte[15];
            AuthClientBase.BuildXenonConsolePrincipal(id, principal);

            // Calculate correct checksum
            int chksum = 0;
            int digit = 0;
            for(int i = 3; i < principal.Length - 1; i++)
            {
                digit = principal[i] - '0';
                chksum += digit;
            }

            // Very last digit/byte/character is the checksum mod 10.
            principal[14] = (byte)((chksum % 10) + '0');

            // Convert to string, return
            return AuthClientBase.BytesToString(principal);
        }

        //returns whether to use the real or test xmacs key by default
        public static bool UseXmacsTestKey ()
        {
            if (GlobalOverrideUsingXmacsTestKey!=-1)
            {
                return GlobalOverrideUsingXmacsTestKey>0;
            }
            else if (XmlOverrideUseXmacsTestKey==-1) //need to check xml
            {
                XmlOverrideUseXmacsTestKey=-2;

                // Check if overriden in xml
                // Sample: <setting name=UseXmacsTestKey value=1 />
                XmlElement el = Global.GetEnvironmentSettingsGroup();
                if(el != null)
                {
                    string xpath = "//setting[@name=\"UseXmacsTestKey\"]";
                    XmlElement elSetting = el.SelectSingleNode(xpath) as XmlElement;
                    if(elSetting != null)
                    {
                        string boolvalue = elSetting.GetAttribute("value").ToLower();
                        if(boolvalue != null)
                        {
                            if(boolvalue.ToLower() == "true" || boolvalue.ToLower() == "1")
                                XmlOverrideUseXmacsTestKey=1;
                            else if(boolvalue.ToLower() == "false" || boolvalue.ToLower() == "0")
                                XmlOverrideUseXmacsTestKey=0;
                            Global.RO.Info("UseXmacsTestKey={0} from XML file", XmlOverrideUseXmacsTestKey);
                        }
                    }
                }
            }

            if (XmlOverrideUseXmacsTestKey>=0)
            {
                return XmlOverrideUseXmacsTestKey>0;
            }

            return  (ncipherIsPresent?false:true);
        }

        //-1 = use default, 0 = don't use, 1 = use.  -2 = already checked xml and use default
        public static int GlobalOverrideUsingXmacsTestKey=-1;
        private static int XmlOverrideUseXmacsTestKey=-1;

        private static bool ncipherIsPresent=true; //whether we have ncipher in the current environment

        //called when the environment changes
        private static void EnvironmentChangedCallback(string name)
        {
            if (Global.CurrentEnvironment==null || Global.CurrentEnvironment.NpdbIp==null || Global.CurrentEnvironment.NpdbIp.Length==0) //change to empty environment
            {
                Global.RO.Debug("XmacsClient: No environment set, so defaulting to the real key.");
                ncipherIsPresent=true;
                return;
            }

            //normal environment change
            try
            {
                bool currentNcipherSetting=Global.XEnv.GetBoolSetting("kdcsvc_xmacs_useNCipher");
                if (currentNcipherSetting!=ncipherIsPresent)
                {
                    ncipherIsPresent=currentNcipherSetting;

                    if (GlobalOverrideUsingXmacsTestKey==-1)
                    {
                        Global.RO.Debug("XmacsClient: Default is now the "+(ncipherIsPresent?"Real":"Test")+" key, based on kdcsvc_xmacs_useNCipher.");
                    }
                }
            }
            catch (System.Exception e)
            {
                if (GlobalOverrideUsingXmacsTestKey==-1)
                {
                    Global.RO.Warn("XmacsClient: Unable to determine if ncipher is present, so assuming that it is.  Exception:\n"+e);
                }
                ncipherIsPresent=true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\SiteInfo.cs ===
using System;
using System.Collections;
using System.Text;
using System.IO;
using System.Xml;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Auth
{

    /// <summary>
    /// Holds information about both SG and LSP sites
    /// </summary>
    public class SiteInfo
    {
        public string       serverName;         // either "sg" or "ts"
        public uint         siteId;
        public byte[]       siteKey;
        public IPEndPoint   siteIp;             // real ip of server
        public IPEndPoint   siteVip;            // ip of vip in front of server
        public int          authdataVersion;    // typically 3

        // For LSP only
        public byte[]       tsXnKid;            // 8 bytes
        public byte[]       tsXnKey;            // 16 bytes (not transmitted in keyex)
        public byte[]       tsKeyExchangeKey;   // Hmac-Sha1(xnkey, xnkid | xnkey)

        public string siteName
        {
            get { return "site" + siteId.ToString(); }
        }

        public bool IsLsp
        {
            get { return (serverName == "ts"); }
        }

        public bool IsSg
        {
            get { return (serverName == "sg"); }
        }

        public SiteInfo(string servername, uint siteid, byte[] sitekey, string sitevip, string siteip, int authdataversion, byte[] tsxnkid, byte[] tsxnkey)
        {
            serverName          = servername;
            siteId              = siteid;
            siteKey             = sitekey;
            authdataVersion     = authdataversion;
            tsXnKid             = tsxnkid;
            tsXnKey             = tsxnkey;

            Init(sitevip, siteip);  // no ip override
        }

        public SiteInfo (string servername, uint siteid, byte[] sitekey, IPEndPoint sitevip, IPEndPoint siteip, int authdataversion, byte[] tsxnkid, byte[] tsxnkey, byte[] tskek)
        {
            serverName = servername;
            siteId = siteid;
            siteKey = sitekey;
            siteVip = sitevip;
            siteIp = siteip;
            authdataVersion = authdataversion;
            tsXnKid = tsxnkid;
            tsXnKey = tsxnkey;
            tsKeyExchangeKey = tskek;
        }

        public SiteInfo(XmlNode node)
        {
            serverName          = GetStringAttr(node, "servername", false);
            siteId              = GetUintAttr(node, "siteid", false);
            siteKey             = GetByteArrayAttr(node, "sitekey", false);
            if (IsLsp)
            {
                // Old style?
                bool bOldLsp  = (null != GetStringAttr(node, "xnkid", true));
                if (bOldLsp)
                {
                    tsXnKid             = GetByteArrayAttr(node, "xnkid", false);
                    tsXnKey             = GetByteArrayAttr(node, "xnkey", false);
                }
            }
            authdataVersion     = GetIntAttr(node, "authdataversion", true);
            string sitevip      = GetStringAttr(node, "vip", true);
            string siteip       = GetStringAttr(node, "ip", true);
            Init(sitevip, siteip);
        }

        /// <summary>
        /// Finish doing common constructor things, cleaning up defaults, etc
        /// </summary>
        /// <param name="sitevip">VIP address for site; optional for SG, required for LSP</param>
        /// <param name="siteip">IP address for site; optional for SG, optional for LSP</param>
        private void Init(string sitevip, string siteip)
        {
            if (authdataVersion == 0)
                authdataVersion = 3;

            // The VIP what we will base the Xnkid off of.
            if (sitevip != null)
            {
                IpAddr ipaddr = new IpAddr(sitevip);
                siteVip = ipaddr.GetIPEndPoint();
                siteVip.Port = 3074;
            }
            else if (IsSg)
            {
                // Use either NPDB or a local override for the SG IP address
                siteVip = Global.XEnv.GetVirtualInterface(VirtualInterface.sgsvc);
            }
            else if (IsLsp)
            {
                throw new Exception("Must specify a site VIP address for an LSP site");
            }
            
            // The site IP is what we will connect to. By default, it is the VIP, but 
            // can be overridden.
            if (siteip != null)
            {
                IpAddr ipaddr = new IpAddr(siteip);
                siteIp = ipaddr.GetIPEndPoint();
                siteIp.Port = 3074;
            }
            else
            {
                siteIp = siteVip;
            }


            // If LSP, we need to build some keys so we don't have to talk to the datacenter
            // to retrieve them.  Must use the advertised IP address, which would be the VIP
            // address in the UDP load-balancing scenario.
            if (IsLsp)
            {
                // For the new SG in back-compat mode, we need to generate the xnkid and 
                // xnkeys.  We can do this based on the IP address.
                if (tsXnKid == null || tsXnKey == null)
                {
                    BuildTSKey(siteKey, siteVip.Address.GetAddressBytes(), out tsXnKid, out tsXnKey);
                }

                // For the old SG, we have to grab the keys from the querydb. They can be 
                // provided in the XML config file. 
                
                // For both TS-style SGs, we need to generate the key exchange key, which 
                // is:
                // Hmac-Sha1(xnkey, xnkid | xnkey)
                BuildKeyExchangeKey(tsXnKid, tsXnKey, out tsKeyExchangeKey);
            }
        }

        /// <summary>
        /// Outputs an 8 byte TS session key, the same one that is advertised by the LSPSG
        /// to query.  
        /// </summary>
        /// <param name="siteKey">16 byte key site key of LSP server</param>
        /// <param name="ipBytes">IP address of LSP server</param>
        /// <returns>8 byte TS session key</returns>
        public static void BuildTSKey(byte[] siteKey, byte[] ipBytes, 
            out byte[] xnkid, out byte[] xnkey)
        {
            byte[] salt_xnkid = new byte[] {(byte)'X',(byte)'K',(byte)'I',(byte)'D'};
            byte[] salt_xnkey = new byte[] {(byte)'X',(byte)'K',(byte)'E',(byte)'Y'};

            byte[] hash = new byte[20];

            // generate xnkid

            AuthClientBase.XcHmac4(
                siteKey,     siteKey.Length,
                salt_xnkid,  salt_xnkid.Length,
                ipBytes,     ipBytes.Length,
                null,        0,
                null,        0,
                hash,        hash.Length);
            
            xnkid = new byte[8];
            Array.Copy(hash, xnkid, xnkid.Length);
            xnkid[0] = 0xE0; // XNET_XNKID_ONLINE_TITLESERVER
            
            // generate xnkey
            
            AuthClientBase.XcHmac4(
                siteKey,     siteKey.Length,
                salt_xnkey,  salt_xnkey.Length,
                ipBytes,     ipBytes.Length,
                null,        0,
                null,        0,
                hash,        hash.Length);

            xnkey = new byte[16];
            Array.Copy(hash, xnkey, xnkey.Length);
        }

        public static void BuildKeyExchangeKey(byte[] xnkid, byte[] xnkey, out byte[] keyExchangeKey)
        {
            // the XNKID and the XNKEY is what we send up the wire, but what 
            // it's really used in the key-exchange is Hmac-Sha1(xnkey, xnkid | 
            // xnkey)

            byte[] hash = new byte[20];

            AuthClientBase.XcHmac4(
                xnkey,       xnkey.Length,
                xnkid,       xnkid.Length,
                xnkey,       xnkey.Length,
                null,        0,
                null,        0,
                hash,        hash.Length);

            keyExchangeKey = new byte[16];
            Array.Copy(hash, keyExchangeKey, keyExchangeKey.Length);
        }

        public override string ToString()
        {
            string s = String.Format("SiteInfo[{0}]: site={1} (0x{2:X8}), ip={3}, vip={4}, authdataver={5}, sitekey={6}",
                serverName,
                siteId,
                siteId,
                siteIp.ToString(),
                siteVip.ToString(),
                authdataVersion,
                Hexer.tohex(siteKey));
            if (IsLsp)
            {
                s += String.Format(", xnkid={0}, keyexchangekey={1}", 
                    (tsXnKid != null ? Hexer.tohex(tsXnKid) : ""),
                    (tsKeyExchangeKey != null ? Hexer.tohex(tsKeyExchangeKey) : ""));
            }
            return s;
        }

        public SiteInfo CloneDeep()
        {
            SiteInfo s = new SiteInfo(
                serverName, 
                siteId, 
                siteKey == null ? null : (byte[])siteKey.Clone(), 
                siteVip == null ? null : new IPEndPoint(siteVip.Address, siteVip.Port),
                siteIp == null ? null : new IPEndPoint(siteIp.Address, siteIp.Port), 
                authdataVersion,
                tsXnKid == null ? null : (byte[])tsXnKid.Clone(),
                tsXnKey == null ? null : (byte[])tsXnKey.Clone(),
                tsKeyExchangeKey == null ? null : (byte[])tsKeyExchangeKey.Clone());
            return s;
        }

        #region XML parsing aids....

        private static string GetStringAttr(XmlNode n, string attr, bool bOptional)
        {
            XmlAttribute a = n.Attributes[attr];
            if (a == null || a.Value == null)
            {
                if (!bOptional)
                    throw new Exception(String.Format("Need to specify a <siteinfo {0}=...> attribute in <settingsgroup name=\"Auth\"> section in your XML file", attr));
                else
                    return null;
            }
            return a.Value;
        }

        private static int GetIntAttr(XmlNode n, string attr, bool bOptional)
        {
            string a = GetStringAttr(n, attr, bOptional);
            if (a == null)
            {
                return 0;
            }

            // Default number style is base 10 integer
            System.Globalization.NumberStyles numberStyle = System.Globalization.NumberStyles.Integer;

            // is this a hex number?
            if (a.ToLower().IndexOf("0x") >= 0)
            {
                // Strip trailing "0x"
                a = a.Substring(2);
                numberStyle = System.Globalization.NumberStyles.HexNumber;
            }
            else if (a.ToLower().IndexOfAny(new char[] {'a', 'b', 'c', 'd', 'e', 'f'}) > 0)
            {
                numberStyle = System.Globalization.NumberStyles.HexNumber;
            }
            return int.Parse(a, numberStyle);
        }

        private static uint GetUintAttr(XmlNode n, string attr, bool bOptional)
        {
            string a = GetStringAttr(n, attr, bOptional);
            if (a == null)
            {
                return 0;
            }
            // Default number style is base 10 integer
            System.Globalization.NumberStyles numberStyle = System.Globalization.NumberStyles.Integer;

            // is this a hex number?
            if (a.ToLower().IndexOf("0x") >= 0)
            {
                // Strip trailing "0x"
                a = a.Substring(2);
                numberStyle = System.Globalization.NumberStyles.HexNumber;
            }
            else if (a.ToLower().IndexOfAny(new char[] {'a', 'b', 'c', 'd', 'e', 'f'}) > 0)
            {
                numberStyle = System.Globalization.NumberStyles.HexNumber;
            }
            return uint.Parse(a, numberStyle);        
        }

        private static byte[] GetByteArrayAttr(XmlNode n, string attr, bool bOptional)
        {
            string a = GetStringAttr(n, attr, bOptional);
            if (a == null)
            {
                return null;
            }
            return Hexer.unhex(a);
        }

        #endregion


    }

    public class SiteInfoManager
    {
        private static ArrayList LspSites = null;
        private static ArrayList SgSites = null;

        public static SiteInfo GetDefaultLspSite()
        {
            Check();
            if (LspSites.Count == 0)
            {
                throw new Exception("No LSP sites are defined");
            }
            
            // Just return the first one for now
            return (SiteInfo)LspSites[0];
        }

        public static SiteInfo GetDefaultSgSite()
        {
            Check();
            if (SgSites.Count == 0)
            {
                throw new Exception("No SG sites are defined");
            }
            
            // Just return the first one for now
            return (SiteInfo)SgSites[0];
        }

        public static SiteInfo GetLspSite(uint siteId)
        {
            Check();
            if (LspSites.Count == 0)
            {
                throw new Exception("No LSP sites are defined");
            }
            
            foreach (object o in LspSites)
            {
                SiteInfo site = (SiteInfo)o;
                if (site.siteId == siteId)
                {
                    return site;
                }
            }
            return null;
        }

        public static SiteInfo GetSgSite(uint siteId)
        {
            Check();
            if (SgSites.Count == 0)
            {
                throw new Exception("No SG sites are defined");
            }
            
            foreach (object o in SgSites)
            {
                SiteInfo site = (SiteInfo)o;
                if (site.siteId == siteId)
                {
                    return site;
                }
            }
            return null;
        }

        private static object initLocker=new object(); //used to prevent several threads from trying to call init at the same time
        private static string initEnv=null; //env we were inited for
        
        public static void Initialize()
        {
            lock(initLocker)
            {
                //if it was already done by another thread, stop
                if ((LspSites != null && SgSites != null))
                {
                    return;
                }

                initEnv=Global.CurrentEnvironment.Environment;
            
                // Force it to re-initialize
                SgSites = new ArrayList();
                LspSites = new ArrayList();

                XmlElement el = Global.GetEnvironmentSettingsGroup();
                if (el == null)
                {
                    Global.RO.Warn("[SiteInfo] No <settingsgroup environment=\"" + initEnv + "\"> section found in your XML file, trying Auth");
                    el = Global.GetSettingsGroup("Auth");
                    if (el == null)
                    {
                        Global.RO.Warn("[SiteInfo] No <settingsgroup name=\"Auth\" found in your XML file");
                        AddDefaultSgSite();
                        return;
                    }
                }
                XmlNodeList nodes = el.SelectNodes("siteinfo");
                if (nodes == null || nodes.Count == 0)
                {
                    Global.RO.Debug("[SiteInfo] No <siteinfo> section found in your XML file, LSP probably won't work now");
                    AddDefaultSgSite();
                    return;
                }

                foreach (XmlNode node in nodes)
                {
                    SiteInfo site = new SiteInfo(node);
                    if (site.IsLsp)
                        LspSites.Add(site);
                    else
                        SgSites.Add(site);
                    Global.RO.Debug("[SiteInfo] Added {0}", site.ToString());
                }

                // SG site1 is common enough that we should add it by default IF no other SG site
                // has been configured.
                if (SgSites.Count == 0)
                {
                    AddDefaultSgSite();
                }
            }
        }

        /// <summary>
        /// Lazy initialization, will do it upon first request
        /// </summary>
        private static void Check()
        {
            lock(initLocker)
            {
                if (initEnv!=Global.CurrentEnvironment.Environment)
                {
                    LspSites=null;
                    SgSites=null;
                }

                if (LspSites == null || SgSites == null)
                {
                    Initialize();
                }
            }
        }

        /// <summary>
        /// Add essential basic info about SG site1.. for the lazy..
        /// </summary>
        private static void AddDefaultSgSite()
        {
            byte []site1SgKey=ServiceKeys.GetServiceKey(ServiceKeys.Key_SG, "sg", "site1");
            SiteInfo site = new SiteInfo("sg", 1, site1SgKey, (string)null, (string)null, 4, null, null);
            SgSites.Add(site);
        }

        public static new string ToString()
        {
            StringBuilder sb = new StringBuilder(2000);
            foreach (object o in SgSites)
            {
                sb.Append((o as SiteInfo).ToString());
            }
            foreach (object o in LspSites)
            {
                sb.Append((o as SiteInfo).ToString());
            }
            return sb.ToString();            
        }
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\XspUdp.cs ===
//#define UDPSOCKETPOLLING_DEBUG

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary>
    /// This class is a replacement for <c>SimpleUdpSG</c> which uses <c>XspBuffer</c> to store packets not meant
    /// for the caller of the Receive methods.  The buffers are then stored until the owner calls Receive.
    /// </summary>
    public class XspUdp
    {
        #region Nested Types

        /// <summary>
        /// A callback for receiving a packet.
        /// It is expected that this execute quickly, such as simply queueing the packet for later processing.
        /// </summary>
        /// <param name="packet">The packet that was received.</param>
        /// <param name="connResets">
        /// The number of connection resets seen since the last key exchange packet.
        /// Only valid when packet is a key exchange packet.
        /// </param>
        public delegate void ReceiveCallback (XspBuffer packet, int connResets);

        #endregion

        #region Protected Fields

        /// <summary>The Socket to be used.</summary>
        protected Socket _socket = null;

        /// <summary>A dictionary keyed by Spi (uint) containing a Queue of results.</summary>
        protected Dictionary<uint, ReceiveCallback> _callbacks = new Dictionary<uint, ReceiveCallback>();

        /// <summary>The number of connection resets since the last key exchange packet was received.</summary>
        private int _conn_resets = 0;

        #endregion

        #region Protected Properties

        /// <summary>Wrapper for _socket that will create it if needed.</summary>
        protected Socket MySocket
        {
            get
            {
                Socket ans = _socket;

                if (ans == null)
                {
                    Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

                    // try to use 3074 first
                    EndPoint epLocal = new IPEndPoint(IPAddress.Any, 3074);

                    try
                    {
                        s.Bind(epLocal);
                    }
                    catch (SocketException e)
                    {
                        if (e.SocketErrorCode == SocketError.AddressAlreadyInUse)
                        {
                            // if that didn't work, we'll take any port
                            ((IPEndPoint)epLocal).Port = 0;
                            s.Bind(epLocal);
                        }
                        else
                        {
                            throw;
                        }
                    }

                    // set some options
                    s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, 
                        (int)DefaultSocketSendBuffer);
                    s.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, 
                        (int)DefaultSocketReceiveBuffer);

                    ans = Interlocked.CompareExchange<Socket>(ref _socket, s, null);

                    if (ans == null)
                    {
                        // ans is null, meaning _socket was null, meaning s got swapped in
                        // register for polling now
                        UdpSocketPolling.Register(s, PollingCallback);

                        return s;
                    }
                    else
                    {
                        // oops, we failed to be the chosen one, get rid of s
                        // ans isn't null, so let it be returned outside
                        s.Close();
                    }
                }

                return ans;
            }
        }

        #endregion

        #region Public Properties

        /// <summary>
        /// The endpoint of the local socket.  May not be correct until the first send or receive completes
        /// successfully.
        /// </summary>
        public IPEndPoint LocalEndpoint
        {
            get { return (IPEndPoint)MySocket.LocalEndPoint; }
        }

        #endregion

        #region Static Fields

        /// <summary>The default send buffer size for new sockets.</summary>
        public static uint DefaultSocketSendBuffer = 16384;
        /// <summary>The default receive buffer size for new sockets.</summary>
        public static uint DefaultSocketReceiveBuffer = 16384;

        #endregion

        #region Constructor / Deconstructor

        /// <summary>
        /// Creates a new XspUdp.
        /// </summary>
        public XspUdp () { }

        /// <summary>
        /// Unregister the socket if need be.
        /// </summary>
        ~XspUdp ()
        {
            try
            {
                Close();
            }
            catch { }
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Called when our socket is polled and packets are received.  We then use our dictionary
        /// to multiplex them out the the proper owners.
        /// </summary>
        /// <param name="packetList">The list of packets that were received.</param>
        /// <param name="exc">The exception that occured.</param>
        private void PollingCallback (XspBuffer packetList, Exception exc)
        {
            try
            {
                // handle the packet list
                while (packetList != null)
                {
                    uint spi = packetList.DecodeSpi();
                    int connResets = 0;

                    // tis a key exchange packet, we have to dig deeper to get the spi
                    if (spi == 0)
                    {
                        spi = packetList.DecodeSpiFromKeyExPacket();
                        connResets = Interlocked.Exchange(ref _conn_resets, 0);
                    }

                    // get the callback
                    ReceiveCallback callback = null;

                    lock (_callbacks)
                    {
                        if (!_callbacks.TryGetValue(spi, out callback))
                        {
                            // we don't know about that spi, drop that packet
                            // @@@TODO: RECORD THIS AND DISPLAY IT!!!
                            XspBuffer temp = packetList;
                            packetList = packetList.Next;
                            XspBufferManager.Free(temp);
                            continue;
                        }
                    }

                    // save the head out and advance down the list
                    XspBuffer output = packetList;
                    packetList = packetList.Next;
                    output.Next = null;

                    try
                    {
                        callback(output, connResets);
                    }
                    catch (Exception e)
                    {
                        Global.RO.Warn("An exception occured in a XspUdp.PollingCallback callback:\n" + e.ToString());
                    }
                }

                // handle exceptions
                if (exc == null)
                {
                    // no exception
                    return;
                }
                else if (exc is SocketException)
                {
                    SocketException se = (SocketException)exc;

                    // WSAECONNRESET
                    // This happens when we receive an ICMP Port Unreachable packet.
                    // The SG happens to send one out for every KeyExXbToSgInit message.
                    // It does this because of some Netgear router bug. WinSock is kinda
                    // stupid here -- this is a *connectionless* protocol after all so it should
                    // just swallow a connection reset message -- so let's try it again. 
                    // This should succeed and read the reply that actually was sent.
                    if (se.ErrorCode == 10054)
                    {
                        Interlocked.Increment(ref _conn_resets);
                        return;
                    }

                    // socket got closed, just bail
                    if (se.ErrorCode == 995)
                    {
                        return;
                    }

                    Global.RO.Debug("A SocketException(" + se.ErrorCode.ToString() +
                        ") was passed to XspUdp.PollingCallback:\n" + se.ToString());
                }
                else if (exc is ObjectDisposedException)
                {
                    // most likely means that the socket got closed, just bail
                    return;
                }
                else if (exc is ArgumentException)
                {
                    // most likely means that the socket got closed, just bail
                    return;
                }
                else
                {
                    Global.RO.Debug("An unrecognized exception was passed to XspUdp.PollingCallback:\n" + exc.ToString());
                }
            }
            catch (Exception e)
            {
                Global.RO.Debug("An exception occured in XspUdp.PollingCallback, this XspUdp may be broken:\n" +
                    e.ToString());
            }
        }

        #endregion

        #region Public Methods

        #region Utility

        /// <summary>
        /// Shuts down everything, essentially reseting to a fresh state as if this XspUdp were just constructed.
        /// It should be completely usable afterwards.
        /// </summary>
        public void Close ()
        {
            // this might kill some other threads that are using the socket, oh well
            Socket old_socket = Interlocked.Exchange<Socket>(ref _socket, null);

            if (old_socket != null)
            {
                // unregister the socket
                UdpSocketPolling.Unregister(old_socket);

                old_socket.Close();
            }

            lock (_callbacks)
            {
                _callbacks.Clear();

                // random little bits
                _conn_resets = 0;
            }
        }

        /// <summary>
        /// Removes the callback for the given Spi, releasing all associated resources.
        /// </summary>
        /// <param name="spi">The Spi to close.</param>
        public void Close (uint spi)
        {
            lock (_callbacks)
            {
                _callbacks.Remove(spi);

                // if no more users, shut down the socket
                if (_callbacks.Count == 0)
                {
                    Close();
                }
            }
        }

        /// <summary>
        /// Checks to see if the requested Spi is available.  If there are packets waiting on the Spi, they will be dropped if old.
        /// </summary>
        /// <param name="spi">The Spi to check.</param>
        /// <returns>True if the Spi is available; false if it is actively in use.</returns>
        /// <remarks>
        /// If two connections attempt to use the same Spi at the same time, this will not prevent them from interfering with each other.
        /// </remarks>
        public bool CheckSpiAvailability (uint spi)
        {
            lock (_callbacks)
            {
                return (!_callbacks.ContainsKey(spi));
            }
        }

        #endregion

        #region Send

        /// <summary>
        /// Sends the bytes to the remote host.
        /// </summary>
        /// <param name="pb">The buffer to send.</param>
        /// <param name="host">The location to send to.</param>
        /// <exception cref="XspUdpException">
        /// Thrown if the total bytes sent is not pb.Length.
        /// </exception>
        public void Send (byte[] pb, IPEndPoint host)
        {
            int sentBytes = SendToWithRetry(pb, 0, pb.Length, SocketFlags.None, host);
            if (sentBytes != pb.Length)
            {
                throw new XspUdpException("UDP send failed: sent {0} byte(s) out of {1}", sentBytes, pb.Length);
            }
        }

        /// <summary>
        /// Sends the subset of bytes to the remote host.
        /// </summary>
        /// <param name="pb">The buffer to send.</param>
        /// <param name="cb">The number of bytes to send from the start of the buffer.</param>
        /// <param name="host">The location to send to.</param>
        /// <exception cref="XspUdpException">
        /// Thrown if the total bytes sent is not cb.
        /// </exception>
        /// <remarks>The was called SendFast in SimpleUdpSG, for what reason I do not know.</remarks>
        public void Send (byte[] pb, int cb, IPEndPoint host)
        {
            int sentBytes = SendToWithRetry(pb, 0, cb, SocketFlags.None, host);
            if (sentBytes != cb)
            {
                throw new XspUdpException("UDP send failed: sent {0} byte(s) out of {1}", sentBytes, cb);
            }
        }

        /// <summary>
        /// Sends the XspBuffer to the remote host.
        /// </summary>
        /// <param name="buffer">The buffer to send.</param>
        /// <param name="host">The location to send to.</param>
        /// <exception cref="XspUdpException">
        /// Thrown if the total bytes sent is not buffer.RawBufferLength.
        /// </exception>
        public void Send (XspBuffer buffer, IPEndPoint host)
        {
            Send(buffer.RawBuffer, (int)buffer.RawBufferLength, host);
        }

        /// <summary>
        /// Contains code to record and retry a failed SendTo due to WSAECONNRESET.
        /// </summary>
        private int SendToWithRetry (byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP)
        {
            #region Begin Single WSAECONNRESET Retry
            bool __reset = false;
            do
            {
                try
                {
            #endregion
                    return MySocket.SendTo(buffer, offset, size, socketFlags, remoteEP);
            #region End Single WSAECONNRESET Retry
                }
                catch (SocketException se)
                {
                    // WSAECONNRESET
                    if (!__reset && se.ErrorCode == 10054)
                    {
                        Interlocked.Increment(ref _conn_resets);
                        __reset = true;
                    }
                    else
                    {
                        throw;
                    }
                }
            } while (__reset);
            #endregion

            throw new XspUdpException("SendToWithRetry failed utterly.  But this can't happen...");
        }

        #endregion

        #region Callbacks

        /// <summary>
        /// Registers the callback for the given spi.
        /// </summary>
        /// <param name="spi">The spi to register the callback under.</param>
        /// <param name="callback">The callback for the spi.</param>
        public void AttachForSpi (uint spi, ReceiveCallback callback)
        {
            lock (_callbacks)
            {
                _callbacks[spi] = callback;
            }
        }

        #endregion

        #endregion
    }

    /// <summary>
    /// An exception generated by the XspUdp class that is used when a system defined exception did not fit.
    /// </summary>
    public class XspUdpException : Exception
    {
        internal XspUdpException (string message) : base(message) { }
        internal XspUdpException (string format, params object[] args) : base(string.Format(format, args)) { }
    }

    /// <summary>
    /// Manages a set of XspBuffers.  Allows the user to allocate and free them for improved performance.
    /// The goal is to limit the number of news and eventual garbage collections, not to be a perfect list.
    /// Speed is the most important factor.
    /// </summary>
    public static class XspBufferManager
    {
        /// <summary>The head of the free list.</summary>
        private static XspBuffer FreeListHead = null;

#if true
        /// <summary>Locking object for FreeListHead access.</summary>
        private static object FreeListLock = new object();

        /// <summary>
        /// Allocates an XspBuffer, which means either giving a free one back or making a new one.
        /// </summary>
        /// <returns>An XspBuffer.</returns>
        public static XspBuffer Allocate ()
        {
            XspBuffer head = null;

            // minimize lock time
            lock (FreeListLock)
            {
                
#if XSPBUFFER_DEBUG
                // Useful for debugging
                PrintFreeList("Alloc: ");
#endif

                head = FreeListHead;
                FreeListHead = (head == null ? null : head.Next);
            }

            if (head == null)
            {
                // we need more then, make one
                return new XspBuffer();
            }
            else
            {
                head.IsFree = 0;
                head.Next = null;
                return head;
            }
        }

        /// <summary>
        /// Frees an XspBuffer, making it available for a later allocate.  The XspBuffer need not have been Allocated
        /// with the XspBufferManager.
        /// </summary>
        /// <param name="buffer">The buffer to free.</param>
        public static void Free (XspBuffer buffer)
        {
            // mark this buffer as free, if buffer.IsFree was:
            // 0 : then it was not free and we just marked it as such
            // 1 : it was already free and we didn't change the value
            int was_free = Interlocked.Exchange(ref buffer.IsFree, 1);

            // double frees make a bad, bad circular list
            if (was_free == 1)
            {
                throw new ArgumentException("Cannot free the buffer, as it is already free.", "buffer");
            }

            // minimize lock time
            lock (FreeListLock)
            {
                buffer.Next = FreeListHead;
                FreeListHead = buffer;
                
#if XSPBUFFER_DEBUG
                // Useful for debugging
                PrintFreeList("Free: ");
#endif
            }
        }
        
#if XSPBUFFER_DEBUG
        /// <summary>
        /// Prints the free list.  Must hold the lock while calling this to get good results.
        /// </summary>
        private static void PrintFreeList (string prepend)
        {
            System.Text.StringBuilder buff = new System.Text.StringBuilder(prepend);

            XspBuffer val = FreeListHead;

            while (val != null)
            {
                buff.Append(val.MyCounter);
                buff.Append(val.IsFree == 1 ? "(F) -> " : "(A) -> ");

                val = val.Next;
            }

            buff.Append("null");

            Global.RO.Debug(buff.ToString());
        }
#endif
#else
        // This code does not work as there is a bug in Allocate because head.Next is dereferenced before the
        // CompareExchange, making the swap not quite atomic

        /// <summary>
        /// Allocates an XspBuffer, which means either giving a free one back or making a new one.
        /// </summary>
        /// <returns>An XspBuffer.</returns>
        public static XspBuffer Allocate ()
        {
            // pull the head off and give it back
            // spin lock here to make sure that we don't dereference null
            while (true)
            {
                // grab the head in a local because we need to reference it a few times
                XspBuffer head = FreeListHead;

                // we need more then, make one
                if (head == null) { return new XspBuffer(); }

                // the point of this is to basically do this all atomically:
                // if (FreeListHead == head) {  // it could have changed since we last read FreeListHead
                //   FreeListHead = head.Next;
                // }
                // it also returns what FreeListHead was before the call...
                XspBuffer old_head = Interlocked.CompareExchange<XspBuffer>(ref FreeListHead, head.Next, head);

                // ... which we will check here to make sure that the swap happened
                // if we did swap, well then return that guy, otherwise some other thread beat us and
                // we go back through the process
                if (object.ReferenceEquals(old_head, head))
                {
                    return head;
                }
            }
        }

        /// <summary>
        /// Frees an XspBuffer, making it available for a later allocate.  The XspBuffer need not have been Allocated
        /// with the XspBufferManager.
        /// </summary>
        /// <param name="buffer">The buffer to free.</param>
        public static void Free (XspBuffer buffer)
        {
            // push the given buffer onto the front of the free list
            // again, we have to spin lock here
            while (true)
            {
                // point the newly free buffer at the head
                // save it to a local to make that last check work properly
                XspBuffer head = FreeListHead;
                buffer.Next = head;

                // similar to allocate, but opposite...
                // the point of this is to basically do this all atomically:
                // if (FreeListHead == buffer.Next) {  // it could have changed since we last read FreeListHead
                //   FreeListHead = buffer;
                // }
                // it also returns what FreeListHead was before the call...
                XspBuffer old_head = Interlocked.CompareExchange<XspBuffer>(ref FreeListHead, buffer, head);

                // ... which we will check here to make sure that the swap happened
                // if we did swap, well then we are done, otherwise some other thread beat us and
                // we go back through the process
                if (object.ReferenceEquals(old_head, head))
                {
                    return;
                }
            }
        }
#endif
    }

    /// <summary>
    /// Polls registered sockets for received packets, passing them back to the respective callback.
    /// </summary>
    internal static class UdpSocketPolling
    {
        #region Nested Types

        /// <summary>
        /// A registered socket to poll.
        /// </summary>
        private struct Unit
        {
            public Socket Socket;
            public ReceiveCallback Callback;
        }

        /// <summary>
        /// A callback used whenever packets are received.
        /// </summary>
        /// <param name="packetList">A list of packets.</param>
        /// <param name="exc">An exception that occured when receiving.</param>
        /// <remarks>
        /// Either packetList or exc may be null.  If both are non-null, the exception occured after the packets in the list.
        /// The first packet received will be the head of the list.
        /// </remarks>
        public delegate void ReceiveCallback (XspBuffer packetList, Exception exc);

        #endregion

        #region Fields

        /// <summary>Array of sockets to poll.</summary>
        private static Unit[] _registered = null;
        /// <summary>Total occupied slots in _registered.</summary>
        private static int _count = 0;

        /// <summary>The minimum size of _registered.</summary>
        private const int MinSize = 64;
        /// <summary>Growth factor for array expansion.  Also determines collapse value (inverse squared).</summary>
        private const int GrowthFactor = 2;

        /// <summary>Thread that does the polling.</summary>
        private static Thread _pollster = null;

        /// <summary>Minimum sleep time for the poll thread after no receives.</summary>
        private const int MinSleep = 0;
        /// <summary>Maximum sleep time for the poll thread after no receives.</summary>
        private const int MaxSleep = 10;
        /// <summary>Sleep time increment for the poll thread after no receives.</summary>
        private const int SleepIncr = 10;

        #endregion

        #region Public Methods

        /// <summary>
        /// Put a socket into the polling rotation.
        /// </summary>
        /// <param name="socket">The socket to poll.</param>
        /// <param name="callback">The callback to use when data is received.</param>
        public static void Register (Socket socket, ReceiveCallback callback)
        {
            // this should be safe as its a private type
            lock (typeof(Unit))
            {
                if (_registered == null)
                {
                    _registered = new Unit[MinSize];
                }
                else if (_count == _registered.Length)
                {
                    // need to expand
                    Unit[] destination = new Unit[_count * GrowthFactor];
                    Array.Copy(_registered, destination, _count);
                    _registered = destination;
                }

                // do the actual add
                _registered[_count].Socket = socket;
                _registered[_count].Callback = callback;
                ++_count;

                // start the thread?
                if (_pollster == null)
                {
                    _pollster = new Thread(Poll);
                    _pollster.IsBackground = true;
                    _pollster.Name = "UdpSocketPolling Thread";

                    _pollster.Start();
                }
            }
        }

        /// <summary>
        /// Removes a registered socket.  This call guarantees an array copy, linear search, then another copy to remove.
        /// Keep calls to a minimum.
        /// </summary>
        /// <param name="socket">The socket to remove.</param>
        public static void Unregister (Socket socket)
        {
            // this should be safe as its a private type
            lock (typeof(Unit))
            {
                if (_registered == null)
                {
                    throw new InvalidOperationException("Registered array is null.");
                }

                // determine if we will shrink
                int copy_size = _registered.Length;

                if (_count < (copy_size / (GrowthFactor * GrowthFactor)))
                {
                    copy_size /= GrowthFactor;
                }

                // copy
                Unit[] destination = new Unit[copy_size];
                Array.Copy(_registered, destination, _count);

                // search
                int location = -1;

                for (int i = 0; i < _count; ++i)
                {
                    if (object.ReferenceEquals(destination[i].Socket, socket))
                    {
                        location = i;
                        break;
                    }
                }

                if (location == -1)
                {
                    // not found, exit silently
                    return;
                }

                // shift
                if (location + 1 < _count)
                {
                    Array.Copy(destination, location + 1, destination, location, _count - location - 1);
                }

                // update, its ok if we decrement _count before swapping in the
                // new array, at worst it makes us skip a socket for that poll rotation
                --_count;
                _registered = destination;

                // stop polling thread
                if (_count == 0 && _pollster != null)
                {
                    // poll thread is likely in a sleep at this point
                    _pollster.Interrupt();
                    // sleep for a short time to let the thread quit
                    Thread.Sleep(10);

                    try
                    {
                        // try to limit the number of exception cases
                        if (_pollster != null)
                        {
                            if (_pollster.IsAlive)
                            {
                                Global.RO.Warn("UdpSocketPolling thread is still alive, aborting.");
                                _pollster.Abort();
                            }

                            // this is done by Poll, but doesn't hurt to do it here as well
                            _pollster = null;
                        }
                    }
                    catch (NullReferenceException)
                    {
                        // we may get an exception because Poll set _pollster to null on us
                    }
                }
            }
        }

        #endregion

        #region Polling Thread

        /// <summary>
        /// Polls the registered sockets.
        /// Remember that _count and _registered can change at any time.
        /// </summary>
        private static void Poll ()
        {
            try
            {
                IPEndPoint ipep = new IPEndPoint(IPAddress.Any, 0);
                EndPoint ipepasep = (EndPoint)ipep;

                int sleep_time = MinSleep;

#if UDPSOCKETPOLLING_DEBUG
                DateTime timer = DateTime.UtcNow;
                uint timer_counter = 0;
                uint timer_batch_counter = 0;
                uint timer_sleep_counter = 0;
                uint[] timer_sleep_breakdown = new uint[11];
#endif

                while (true)
                {
                    int current = 0;
                    bool received = false;

                    // this entire loop is 1 time through the registered sockets
                    while (true)
                    {
                        Unit sock;

                        // _count could decrement on us suddenly
                        if (current < _count)
                        {
                            try
                            {
                                sock = _registered[current];
                            }
                            catch (IndexOutOfRangeException)
                            {
                                // this case is so unlikely that its almost not worth including
                                break;
                            }
                        }
                        else
                        {
                            break;
                        }

                        // do some receivin'
                        XspBuffer head = null;
                        XspBuffer buffer = null;
                        bool last_buffer_bad = false;
                        Exception socket_exception = null;

                        try
                        {
                            // make sure socket is still valid
                            if (sock.Socket.IsBound)
                            {
                                while (sock.Socket.Available > 0)
                                {
                                    // mark us as having seen something
                                    received = true;
#if UDPSOCKETPOLLING_DEBUG
                                    ++timer_counter;
#endif

                                    if (head == null)
                                    {
                                        head = buffer = XspBufferManager.Allocate();
                                    }
                                    else
                                    {
                                        buffer.Next = XspBufferManager.Allocate();
                                        buffer = buffer.Next;
                                    }

                                    try
                                    {
                                        // reset for this receive
                                        ipep.Address = IPAddress.Any;
                                        ipep.Port = 0;

                                        int recv_amount = sock.Socket.ReceiveFrom(buffer.RawBuffer, ref ipepasep);

                                        // a tiny packet somehow
                                        if (recv_amount < 4)
                                        {
                                            last_buffer_bad = true;
                                            break;
                                        }

                                        buffer.RawBufferLength = (uint)recv_amount;
                                    }
                                    catch (Exception e)
                                    {
                                        last_buffer_bad = true;
                                        socket_exception = e;
                                        break;
                                    }
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            // we can get here if the allocation fails, but then there is no reason
                            // to worry about the last buffer being bad
                            socket_exception = e;
                        }

                        // free the last buffer if it is bad
                        if (last_buffer_bad && head != null)
                        {
                            // this means that we only had one buffer
                            if (object.ReferenceEquals(head, buffer))
                            {
                                XspBufferManager.Free(head);
                                head = null;
                            }
                                // we had a lot, cut off the last one
                            else
                            {
                                // prev    buffer       buffer.Next
                                // head -> head.Next -> etc
                                XspBuffer prev = head;
                                buffer = head.Next;

                                while (buffer.Next != null)
                                {
                                    prev = buffer;
                                    buffer = buffer.Next;
                                }

                                prev.Next = null;
                                XspBufferManager.Free(buffer);
                            }
                        }

                        // now we have some number of packets and an exception (maybe)
                        if (head != null || socket_exception != null)
                        {
                            try
                            {
                                sock.Callback(head, socket_exception);
                            }
                            catch (Exception exc)
                            {
                                // best we can do is this
                                Global.RO.Warn("Exception occured in UdpSocketPolling.Poll callback:\n" + exc.ToString());
                            }
                        }

                        // advance to next socket
                        ++current;
                    }
                    
#if UDPSOCKETPOLLING_DEBUG
                    ++timer_batch_counter;

                    // check timer
                    DateTime timer_temp = DateTime.UtcNow;
                    double time_diff = timer_temp.Subtract(timer).TotalSeconds;
                    if (time_diff >= 1.0)
                    {
                        Global.RO.Debug("{0} packets | {2} batches | {3}[{4}|{5}|{6}|{7}] sleeps | {1} seconds.",
                            timer_counter, time_diff, timer_batch_counter, timer_sleep_counter,
                            timer_sleep_breakdown[0], timer_sleep_breakdown[1], timer_sleep_breakdown[2], timer_sleep_breakdown[3]);
                        timer = timer_temp;
                        timer_counter = 0;
                        timer_batch_counter = 0;
                        timer_sleep_counter = 0;
                        for (int i = 0; i < timer_sleep_breakdown.Length; ++i) { timer_sleep_breakdown[i] = 0; }
                    }
#endif

                    // check for any receives
                    if (received)
                    {
                        sleep_time = MinSleep;
                    }
                    else
                    {
                        Thread.Sleep(sleep_time);
#if UDPSOCKETPOLLING_DEBUG
                        ++timer_sleep_counter;
                        ++(timer_sleep_breakdown[sleep_time / SleepIncr]);
#endif

                        if (sleep_time < MaxSleep)
                        {
                            sleep_time += SleepIncr;
                        }
                    }
                }
            }
            catch (ThreadInterruptedException)
            {
                // we were trying to sleep, now we should exit
            }
            catch (ThreadAbortException)
            {
                // we didn't get out fast enough, just exit, but not in a nasty abort throwing way
                Thread.ResetAbort();
            }
            catch (Exception exc)
            {
                Global.RO.Warn("Exception occured in UdpSocketPolling.Poll:\n" + exc.ToString());
                throw;
            }
            finally
            {
                // by doing this here, we 'guarantee' that the thread won't mysteriously vanish
                _pollster = null;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\XspProtocol.cs ===
using System;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Text;
using System.Diagnostics;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService.Auth
{

// The following diagram, stolen from ip.cpp in the client tree, shows the layout of the 
// secure packet format. Note that the CryptPad is 0 to 7 for DES/DES3, or 0 to 15 for 
// AES.
//
//    +CXspHdr----------+cbDat-------------+      +cbTvo+CXspTail--------------------------+ 
// +---------------------------------------------------------------------------------------+
// |IP|UDP|dwSpiAndFlags|CryptData|CryptPad|      |Voice|wSeqLo|abHash                     |
// |20|8  |4            |Var      |0 thru 7|      |Var  |2     |10                         |
// |      |bFlags                   |Ports|TcpInfo|     |      |wSeqHi|dwSpiAndFlags|dwZero|
// |      |1                        |0/2/4|12     |     |      |2     |4            |4     |
// +---------------------------------------------------------------------------------------+
//                                +cbPad---+      |
//                                  +cbTov-+      |
//                                  +cbTex--------+
//
// The max allowed UDP or TCP packet that a client is allowed to send is 1264 bytes. The 
// true max is a bit larger, 1400 bytes.
//
// Our XspPacket class does not have to worry about IP or UDP headers. It only has to 
// worry about:
//
//     SpiAndFlags               [4 bytes]
//     Encrypted data            [var]
//     Extra data (ports, voice) [var]
//     Tail                      [12 bytes]
//


// ----------------------------------------------------------------------------------
// class XspBuffer 
//
// This class should be used to represent an xsp packet. It contains a single buffer that 
// is the size of the max udp payload size (1472 bytes). 
// 
// The Encode() method will encode a payload into this buffer and set up all the various 
// xsp offsets and sizes. The Encrypt() method will take this encoding information and 
// actually encrypt the packet in place. Using your own transport, you can then send this 
// buffer as a udp packet using the "RawBuffer" and "RawBufferLength" properties.
//
// Receiving should be done similarly. It's recommended to receive directly into 
// "RawBuffer", then set "RawBufferLength" correctly. Then call Decode() to make sense of 
// the packet, then call Decrypt() to decrypt it in place. Decrypt() is optional, of 
// course.
//
// Memory is only allocated once by this class. All work is done in place. The only copy 
// is when encoding a payload into the buffer.
//
// Using the properties to access the various chunks of the xsp packet will also allocate 
// and copy memory, so if you are going to re-use them, please cache the results.
//
// ----------------------------------------------------------------------------------
public class XspBuffer
{

    public const uint PAYLOAD_MAXUNSAFESIZE = 1440;  // max payload possible to send
    public const uint PAYLOAD_MAXSAFESIZE   = 1264;  // max payload client will send
    public const uint XSPBUFFER_MAXSIZE     = 1472;  // 1500 max enet - ip hdr - udp hdr

    public const int DATA_START_OFFSET = 4;

    private static readonly byte[] _ZeroArray = new byte[15];  // max block size minus 1

    /// <summary>The value of the port is unknown.</summary>
    private const uint UNKNOWN_PORT = 0x10000;
    /// <summary>The port used for SecMsg traffic.</summary>
    private const uint SECMSG_PORT = 0;

    private byte[]      _Buffer;
    private uint        _BufferLength;

    private uint        _SpiAndFlags;       // helper
    private uint        _SourcePort;
    private uint        _DestPort;
    private bool        _fEncrypted;

    private uint        _cbData;
    private uint        _cbPad;
    private uint        _cbTov;
    private uint        _cbTex;
    private uint        _cbVoi;
    private uint        _cbTvo;

    private int         _SequenceNumber;

    /// <summary>Used by the XspBufferManager to create a linked list.</summary>
    public XspBuffer Next = null;
    /// <summary>Used by the XspBufferManager to prevent double frees.</summary>
    internal int IsFree = 0;

#if XSPBUFFER_DEBUG
    // useful for debugging
    private static int _counter = 0;
    public int MyCounter;
#endif

    public XspBuffer()
    {
        _Buffer = null;
        _BufferLength = 0;
        _SpiAndFlags = 0;
        _SourcePort = 0;
        _DestPort = 0;
        _fEncrypted = false;
        _cbData = 0;
        _cbPad = 0;
        _cbTov = 0;
        _cbTex = 0;
        _cbVoi = 0;
        _cbTvo = 0;
        
#if XSPBUFFER_DEBUG
        MyCounter = Interlocked.Increment(ref _counter);
#endif
    }

    public byte[] RawBuffer
    {
        get 
        { 
            if (_Buffer == null)
            {
                _Buffer = new byte[XSPBUFFER_MAXSIZE];
            }
            return _Buffer; 
        }
    }

    public uint RawBufferLength
    {
        get { return _BufferLength; }
        set { _BufferLength = value; }
    }

    public uint Spi
    {
        get { return _SpiAndFlags & XspHeader.XSP_SPI_MASK; }
    }

    public uint XspType
    {
        get { return _SpiAndFlags & XspHeader.XSP_TYPE_MASK; }
    }

    public uint XspPadding
    {
        get 
        { 
            return ((_SpiAndFlags & XspHeader.XSP_DATPAD_MASK) >> XspHeader.XSP_DATPAD_SHIFT) |
                   ((_SpiAndFlags & XspHeader.XSP_DATPADEX_MASK) >> XspHeader.XSP_DATPADEX_SHIFT); 
        }
    }

    public bool IsKeyExchangeResponse
    {
        get
        {
            return (_SpiAndFlags == 0);
        }
    }

    public uint SourcePort
    {
        get { return _SourcePort; }
    }

    public uint DestPort
    {
        get { return _DestPort; }
    }

    /// <summary>
    /// The sequence number given for the last Encode or determined from the last Decode.
    /// </summary>
    public int SequenceNumber
    {
        get { return _SequenceNumber; }
    }

    public byte[] DataBuffer
    {
        get 
        {
            byte[] b = new byte[_cbData];
            uint idx = 4;
            Array.Copy(_Buffer, idx, b, 0, _cbData);
            return b;
        }
    }

    public uint DataBufferLength
    {
        get
        {
            return _cbData;
        }
        set
        {
            _cbData = value;
        }
    }

    public byte[] TexBuffer
    {
        get
        {
            byte[] b = new byte[_cbTex];
            uint idx = 4 + _cbData + _cbPad - _cbTov;
            Array.Copy(_Buffer, idx, b, 0, _cbTex);
            return b;
        }
    }
    
    public XspTcpInfo TcpInfo
    {
        get 
        { 
            if (_cbTex < XspTcpInfo.SIZE || 
                XspType < XspHeader.XSP_TYPE_TCP_0 ||
                XspType > XspHeader.XSP_TYPE_TCP_2)
            {
                // not tcp
                return null;
            }
            uint idx = TcpInfoOffset;
            if (idx + XspTcpInfo.SIZE >= _BufferLength)
            {
                // not yet parsed?
                return null;
            }
            XspTcpInfo tcpInfo = new XspTcpInfo();
            BinaryReader br = new BinaryReader(new MemoryStream(_Buffer));
            br.BaseStream.Position = idx;
            tcpInfo.ReadFromStream(br);
            return tcpInfo;
        }
    }

    public uint TcpInfoOffset
    {
        get
        {
            uint bytesPerPort = (XspType - XspHeader.XSP_TYPE_TCP_0) % 3;
            return (4 + _cbData + _cbPad - _cbTov + bytesPerPort * 2);
        }
    }

    public byte[] VoiceBuffer
    {
        get 
        {
            byte[] b = new byte[_cbVoi];
            uint idx = 4 + _cbData + _cbPad - _cbTov + _cbTex;
            Array.Copy(_Buffer, idx, b, 0, _cbVoi);
            return b;
        }
    }

    public byte[] TailBuffer
    {
        get 
        {
            byte[] b = new byte[12];
            uint idx = _BufferLength - 12;
            Array.Copy(_Buffer, idx, b, 0, 12);
            return b;
        }
    }

    #region Encode and writing to the buffer

    /// <summary>
    /// Fills the buffer with the provided information, ready for encryption.
    /// </summary>
    public void Encode(
        uint        blockSize,
        uint        baseXspType,
        uint        spi,
        byte[]      data,
        uint        dataIdx,
        uint        dataLength,
        byte[]      voice,
        uint        voiceIdx,
        uint        voiceLength,
        uint        sourcePort,
        uint        destPort,
        XspTcpInfo  tcpInfo,
        int         sequenceNumber)
    {
        if (data != null && dataLength > 0)
        {
            Buffer.BlockCopy(data, (int)dataIdx, RawBuffer, DATA_START_OFFSET, (int)dataLength);
        }
        EncodeWithDataInPlace(blockSize, baseXspType, spi, dataLength, voice, voiceIdx, voiceLength, sourcePort,
            destPort, tcpInfo, 0, sequenceNumber);
    }

    /// <summary>
    /// Fills the buffer with the provided information, ready for encryption.
    /// Uses the data that is already in the buffer.
    /// </summary>
    public void EncodeWithDataInPlace (
        uint        blockSize,
        uint        baseXspType,
        uint        spi,
        uint        dataLength,
        byte[]      voice,
        uint        voiceIdx,
        uint        voiceLength,
        uint        sourcePort,
        uint        destPort,
        object      tcpInfo,
        uint        tcpInfoIdx,
        int         sequenceNumber)
    {

        _fEncrypted = false;
        _SourcePort = sourcePort;
        _DestPort = destPort;

        //
        // Prep work
        //

        // How many bytes per port?
        // Sec Msgs don't use the ports, so always default to 0 bytes here
        uint bytesPerPort;
        if ((baseXspType == XspHeader.XSP_TYPE_SEC) || (sourcePort == 1000 && destPort == 1000))
        {
            bytesPerPort = 0;
        }
        else if (sourcePort > 1000 && sourcePort <= 1255 &&
                 destPort   > 1000 && destPort   <= 1255)
        {
            bytesPerPort = 1;
        }
        else
        {
            bytesPerPort = 2;
        }

        // Streams
        MemoryStream ms = new MemoryStream(RawBuffer);
        BinaryWriter bw = new BinaryWriter(ms);

        //
        // Adjust pointers and sizes
        //

        _cbData = dataLength;
        _cbPad = dataLength % blockSize;
        _cbPad = (_cbPad > 0) ? blockSize - _cbPad : 0;
        _cbTex = bytesPerPort * 2 + (tcpInfo == null ? 0 : XspTcpInfo.SIZE);
        _cbTov = Math.Min(_cbPad, _cbTex);
        _cbVoi = voiceLength;
        _cbTvo = (uint)(voiceLength + ((voiceLength > 0 && dataLength > 0) ? 1 : 0)); // that extra byte before tail

        Debug.Assert(((_cbData + _cbPad) % blockSize) == 0, "Data plus pad is not a multiple of block size.");
        // This Assert is invalid as a TCP ACK packet will often have no data
        //Debug.Assert(dataLength > 0 || voiceLength > 0, "No data!");

        // SpiAndFlags - spi, type, pad
        _SpiAndFlags = 0;
        _SpiAndFlags = spi & XspHeader.XSP_SPI_MASK;
        _SpiAndFlags |= baseXspType + bytesPerPort;
        _SpiAndFlags |= (_cbPad << XspHeader.XSP_DATPAD_SHIFT) & XspHeader.XSP_DATPAD_MASK |
                        (_cbPad << XspHeader.XSP_DATPADEX_SHIFT) & XspHeader.XSP_DATPADEX_MASK;


        //
        // Begin encoding
        //
       
        // spi
        bw.Write(_SpiAndFlags);
       
        // data
        if (_cbData > 0)
        {
            bw.Seek((int)_cbData, SeekOrigin.Current);
        }
       
        // unused padding
        uint cbPadUnused = _cbPad - _cbTov;
        if (cbPadUnused > 0)
        {
            bw.Write(_ZeroArray, 0, (int)(cbPadUnused));  // unused padding must be zeroed
        }
       
        // ports
        if (bytesPerPort == 1)
        {
            bw.Write((byte)(sourcePort - 1000));
            bw.Write((byte)(destPort - 1000));
        }
        else if (bytesPerPort == 2)
        {
            bw.Write((ushort)NetConstants.HTONS((ushort)sourcePort));
            bw.Write((ushort)NetConstants.HTONS((ushort)destPort));
        }

        // tcpinfo, it can be an XspTcpInfo or a byte array
        if (tcpInfo != null)
        {
            XspTcpInfo xti = tcpInfo as XspTcpInfo;

            if (xti != null)
            {
                xti.WriteToStream(bw);
            }
            else
            {
                byte[] tcpinfo_bytes = tcpInfo as byte[];

                if (tcpinfo_bytes != null)
                {
                    bw.Write(tcpinfo_bytes, (int)tcpInfoIdx, (int)(XspTcpInfo.SIZE));
                }
            }
        }

        // voice data
        if (_cbVoi > 0)
        {
            bw.Write(voice, (int)voiceIdx, (int)_cbVoi);
        }

        // extra byte for VDP packets specifying data size in blocks
        if (_cbTvo > _cbVoi)
        {
            byte numDataBlocks = (byte)((blockSize >> 3) * ((_cbData + (blockSize - 1)) / blockSize));
            bw.Write(numDataBlocks);
        }

        // tail
        // Does this work out to loword first then hiword?
        bw.Write(sequenceNumber);
        bw.Write(_SpiAndFlags);
        bw.Write(_ZeroArray, 0, 4);

        _BufferLength = (uint)bw.BaseStream.Position;
        _SequenceNumber = sequenceNumber;

        Debug.Assert(_BufferLength <= XSPBUFFER_MAXSIZE);
        Debug.Assert(4 + _cbData + _cbPad + (_cbTex - _cbTov) + _cbTvo + 12 == _BufferLength);
    }

    /// <summary>
    /// Creates a <c>BinaryWriter</c> for directly writing XSP body data to the buffer.
    /// </summary>
    /// <returns>A BinaryWriter that can be used to write data for use by EncodeWithDataInPlace.</returns>
    public BinaryWriter GetBinaryWriter ()
    {
        return new BinaryWriter(new MemoryStream(RawBuffer, DATA_START_OFFSET, 
            (int)XSPBUFFER_MAXSIZE - DATA_START_OFFSET));
    }

    #endregion

    #region Decode and reading from the buffer

    // ----------------------------------------------------------------------------------
    // Decode
    //
    // Decodes a buffer into meaningful xsp-related points and sizes. Does not decrypt or 
    // copy any memory.
    //
    // You must pass in the receive sequence number, and this method will update that 
    // number for you based on the loword exposed in the tail.
    // ----------------------------------------------------------------------------------
    public void Decode(
        uint        blockSize,
        ref int     sequenceNumber)
    {
        _fEncrypted = true;
        _cbData = 0;
        _cbPad = 0;
        _cbTov = 0;
        _cbTex = 0;
        _cbVoi = 0;
        _cbTvo = 0;
        _SourcePort = UNKNOWN_PORT;
        _DestPort = UNKNOWN_PORT;

        MemoryStream ms = new MemoryStream(_Buffer); 
        BinaryReader br = new BinaryReader(ms);

        _SpiAndFlags = br.ReadUInt32();

        if (_SpiAndFlags == 0)
        {
            // keyex packet, none of the normal XSP applies here
            return;
        }

        _cbPad = XspPadding;

        if (XspType == XspHeader.XSP_TYPE_SEC)
        {
            // tail is 12, spi is 4
            _cbData = _BufferLength - 12 - 4 - _cbPad;

            // set the ports
            _SourcePort = SECMSG_PORT;
            _DestPort = SECMSG_PORT;
        }
        else
        {
            uint bytesPerPort = (XspType - XspHeader.XSP_TYPE_TCP_0) % 3;
            uint baseXspType = XspType - bytesPerPort;

            _cbTex += 2 * bytesPerPort;
            if (baseXspType == XspHeader.XSP_TYPE_TCP_0)
            {
                _cbTex += XspTcpInfo.SIZE;
            }

            _cbTov = Math.Min(_cbPad, _cbTex);
            Debug.Assert(_BufferLength >= 4 + _cbPad + (_cbTex - _cbTov) + 12);

            // data + voice 
            _cbData = _BufferLength - 4 - _cbPad - (_cbTex - _cbTov) - 12; 
            
            // voice packet of some kind?
            if (baseXspType >= XspHeader.XSP_TYPE_VDP_0)
            {
                if (baseXspType == XspHeader.XSP_TYPE_VDP_0)
                {
                    // Read that bloody extra byte. It's always a multiple of 8 bytes, 
                    // even for AES.
                    byte numDataBlocks = _Buffer[_BufferLength - 12 - 1];
                    _cbData = (uint)(numDataBlocks * 8 - _cbPad);
                        
                    // Must have voice data present
                    Debug.Assert(_BufferLength >= 4 + _cbData + _cbPad + (_cbTex - _cbTov) + 1 + 12);
                    
                    _cbTvo = _BufferLength - 4 - _cbData - _cbPad - (_cbTex - _cbTov) - 12;
                    _cbVoi = _cbTvo - 1;
                }
                else if (baseXspType == XspHeader.XSP_TYPE_VDP_VO_0)
                {
                    _cbTvo = _cbData;
                    _cbVoi = _cbData;
                    _cbData = 0;
                }
            }

            // Grab the ports now, if we can
            uint idx = 4 + _cbData + _cbPad - _cbTov;
            if (bytesPerPort == 0)
            {
                _SourcePort = 1000;
                _DestPort = 1000;
            }
            if (bytesPerPort == 1)
            {
                // its the first byte in cbTex, any padding encrypts it
                if (_cbPad == 0)
                {
                    _SourcePort = (uint)(_Buffer[idx] + 1000);
                }
                if (_cbPad <= 1)
                {
                    _DestPort = (uint)(_Buffer[idx + 1] + 1000);
                }
            }
            else
            {
                // its the first two bytes in cbTex, any padding encrypts it
                if (_cbPad == 0)
                {
                    _SourcePort = (uint)NetConstants.HTONS(BitConverter.ToUInt16(_Buffer, (int)idx));
                }
                if (_cbPad <= 2)
                {
                    _DestPort = (uint)NetConstants.HTONS(BitConverter.ToUInt16(_Buffer, (int)idx + 2));
                }
            }
        }

        Debug.Assert(((_cbData + _cbPad) % blockSize) == 0);
        Debug.Assert(_BufferLength == 4 + _cbData + _cbPad + (_cbTex - _cbTov) + _cbTvo + 12);

        // Decode that sequence number. Ugh.
        uint seqLo = (uint)(sequenceNumber & 0x0000FFFF);
        uint xspSeq = (uint)BitConverter.ToUInt16(_Buffer, (int)_BufferLength - 12);
        if (xspSeq < seqLo && (xspSeq - seqLo) < 0x8000)
        {
            xspSeq += 0x10000;
        }
        xspSeq += (uint)(sequenceNumber & 0xFFFF0000);
        sequenceNumber = _SequenceNumber = (int)xspSeq;
    }

    /// <summary>
    /// Reads the Spi directly from the buffer.
    /// </summary>
    /// <returns>The Spi from the buffer.</returns>
    public uint DecodeSpi ()
    {
        if (RawBufferLength < 4)
        {
            throw new InvalidOperationException("The buffer is not long enough to contain a Spi and flags.");
        }

        return GetUInt32(0) & XspHeader.XSP_SPI_MASK;
    }

    /// <summary>
    /// Reads the Spi and flags directly from the buffer, saving them into the instance.
    /// </summary>
    /// <returns>The value of the Spi and flags.</returns>
    public uint DecodeSpiAndFlags ()
    {
        if (RawBufferLength < 4)
        {
            throw new InvalidOperationException("The buffer is not long enough to contain a Spi and flags.");
        }

        _SpiAndFlags = GetUInt32(0);
        return _SpiAndFlags;
    }

    /// <summary>
    /// Reads the Spi directly from the inner buffer of a key exchange packet.
    /// </summary>
    /// <returns>The Spi from the buffer.</returns>
    public uint DecodeSpiFromKeyExPacket ()
    {
        if (RawBufferLength < 16)
        {
            throw new InvalidOperationException("The buffer is not long enough to contain a Spi and flags in the key exchange area.");
        }

        return GetUInt32(12) & XspHeader.XSP_SPI_MASK;
    }

    /// <summary>
    /// Reads the Xsp type directly from the buffer.
    /// </summary>
    /// <returns>The Xsp type of the buffer.</returns>
    public uint DecodeXspType ()
    {
        if (RawBufferLength < 4)
        {
            throw new InvalidOperationException("The buffer is not long enough to contain a Spi and flags.");
        }

        return GetUInt32(0) & XspHeader.XSP_TYPE_MASK;
    }

    /// <summary>
    /// Gets a uint value from the buffer, correcting any endianess issues.
    /// </summary>
    /// <param name="startIndex">The first of the bytes to convert.</param>
    /// <returns>A uint value read from the buffer.</returns>
    public uint GetUInt32 (int startIndex)
    {
        if (startIndex < 0 || RawBufferLength < ((uint)startIndex) + 4)
        {
            throw new ArgumentOutOfRangeException("startIndex");
        }
        return BitConverter.ToUInt32(RawBuffer, startIndex);
    }

    /// <summary>
    /// Gets a uint value from the buffer, correcting any endianess issues.
    /// </summary>
    /// <param name="startIndex">The first of the bytes to convert.</param>
    /// <returns>A uint value read from the buffer.</returns>
    public ushort GetUInt16 (int startIndex)
    {
        if (startIndex < 0 || RawBufferLength < ((uint)startIndex) + 2)
        {
            throw new ArgumentOutOfRangeException("startIndex");
        }
        return BitConverter.ToUInt16(RawBuffer, startIndex);
    }

    /// <summary>
    /// Sets a uint value into the buffer, correcting any endianess issues.
    /// </summary>
    /// <param name="startIndex">The index of the first byte to write.</param>
    /// <param name="value">The uint value to write into the buffer.</param>
    public unsafe void SetUInt32 (int startIndex, uint value)
    {
        if (startIndex < 0 || startIndex > XSPBUFFER_MAXSIZE - 4)
        {
            throw new ArgumentOutOfRangeException("startIndex");
        }
        // copying what BitConverter does for GetBytes, just don't want to allocate a new tiny array
        fixed (byte* numRef = &(RawBuffer[startIndex]))
        {
            *((uint*)numRef) = value;
        }
    }

    #endregion

    #region Encryption/Decryption

    // ----------------------------------------------------------------------------------
    // Encrypt 
    //
    // Encrypts and hashes (the xsp tail stuff) the buffer in place. Must pass in the 
    // correct xsp send sequence number.
    // ----------------------------------------------------------------------------------
    public void Encrypt(SecReg secKeys, int sequenceNumber)
    {
        if (_fEncrypted || _BufferLength == 0)
        {
            // Already encrypted
            return;
        }

        unsafe 
        {
            fixed (byte *pb1 = &_Buffer[4])
            {
                // Any data to encrypt? a voice-only packet would have none.
                if (_cbData + _cbPad > 0)
                {
                    byte[] iv = secKeys.CalcIvAtSeq(secKeys.IvXmit, (uint)sequenceNumber);

                    // Encrypt it

                    secKeys.CryptUnsafe(
                        true, 
                        iv, 
                        pb1, _cbData + _cbPad, 
                        null, 0);
                }
               
                // Hash it, fill last 10 bytes of tail with hash. Hash the data + pad 
                // (pb2) and the rest (pb1). This is how the SG verifies it:
                //
                // cb1 = ROUNDUP4((_cbTex - _cbTov) + _cbTvo + offsetof(CXspTail, _dwZero));
                //
                // This is basically the entire packet length, minues the 4 byte spi at 
                // the beginning, minus the 4 byte dwZero at the end, rounded up to a 4 
                // byte boundary. Notice, though, that is hashed in the order of pb1 | 
                // pb2, or (rest of data) | (data).
                //

                uint dataLen = _cbData + _cbPad;
                uint nondataLen = (_cbTex - _cbTov) + _cbTvo + 8;
                nondataLen = (uint)((nondataLen + 3) & ~3);  // ROUNDUP4

                Debug.Assert(dataLen + nondataLen == (uint)((_BufferLength - 4 - 4 + 3) & ~3));

                byte[] hmacData = new byte[10];
                secKeys.HmacUnsafe(
                    true, 
                    pb1 + dataLen, nondataLen,
                    pb1, dataLen,
                    null, 0,
                    null, 0,
                    hmacData, 10);
                Array.Copy(hmacData, 0, _Buffer, _BufferLength - 10, 10);
            }
        }
    }

    // ----------------------------------------------------------------------------------
    // Decrypt 
    //
    // Decrypts the buffer in place using the supplied receive sequence number, which 
    // should have been derived from the Decode() method.
    // 
    // Does not verify the signature of the packet. It could, which may save you the cost 
    // of a decryption. Meh.
    // ----------------------------------------------------------------------------------
    public void Decrypt(SecReg secKeys, int sequenceNumber)
    {
        if (!_fEncrypted || _BufferLength == 0)
        {
            // Already decrypted
            return;
        }
        
        unsafe 
        {
            fixed (byte *pb1 = &_Buffer[4])
            {
                // Verify hash?
                //
                // don't care. too slow.


                // Decrypt it

                // Any data to decrypt?
                if (_cbData + _cbPad > 0)
                {
                    byte[] iv = secKeys.CalcIvAtSeq(secKeys.IvRecv, (uint)sequenceNumber);

                    secKeys.CryptUnsafe(
                        false,
                        iv, 
                        pb1, _cbData + _cbPad, 
                        null, 0);
                }
            }
        }

        // mark as unencrypted
        _fEncrypted = false;

        // Grab the ports now
        uint idx = 4 + _cbData + _cbPad - _cbTov;
        uint bytesPerPort = (XspType - XspHeader.XSP_TYPE_TCP_0) % 3;
        if (XspType == XspHeader.XSP_TYPE_SEC)
        {
            _SourcePort = SECMSG_PORT;
            _DestPort = SECMSG_PORT;
        }
        else if (bytesPerPort == 0)
        {
            _SourcePort = 1000;
            _DestPort = 1000;
        }
        else if (bytesPerPort == 1)
        {
            _SourcePort = (uint)(_Buffer[idx] + 1000);
            _DestPort = (uint)(_Buffer[idx + 1] + 1000);
        }
        else
        {
            _SourcePort = (uint)NetConstants.HTONS(BitConverter.ToUInt16(_Buffer, (int)idx));
            _DestPort = (uint)NetConstants.HTONS(BitConverter.ToUInt16(_Buffer, (int)idx + 2));
        }
    }

    #endregion
}


// ----------------------------------------------------------------------------------
// class XspTcpInfo
//
// This is the "tcp header" encapsulated inside xsp packets. It's quite dumb now and 
// serves as a placeholder for the user to fill in.
//
// ----------------------------------------------------------------------------------
public class XspTcpInfo
{
    public const uint SIZE = 12;

    public UInt32      _SeqNum;
    public UInt32      _AckNum;
    public byte        _HdrLen;  // number of DWORDS in TCP header, high 4 bits
    public byte        _Flags;
    public UInt16      _Window;

    public XspTcpInfo()
    {
        _SeqNum = 0;
        _AckNum = 0;
        _HdrLen = 0;
        _Flags = 0;
        _Window = 0;
    }

    public void WriteToStream(BinaryWriter bw)
    {
        bw.Write(IPAddress.HostToNetworkOrder((int)_SeqNum));
        bw.Write(IPAddress.HostToNetworkOrder((int)_AckNum));
        bw.Write(_HdrLen);
        bw.Write(_Flags);
        bw.Write(IPAddress.HostToNetworkOrder((short)_Window));
    }

    public void ReadFromStream(BinaryReader br)
    {
        _SeqNum = (uint)IPAddress.NetworkToHostOrder(br.ReadInt32());
        _AckNum = (uint)IPAddress.NetworkToHostOrder(br.ReadInt32());
        _HdrLen = br.ReadByte();
        _Flags = br.ReadByte();
        _Window = (ushort)IPAddress.NetworkToHostOrder(br.ReadInt16());
    }

    public override string ToString()
    {
        return String.Format(
            "[len={0} seq={1} ack={2} win={3} flags={4}]",
            _HdrLen,
            _SeqNum,
            _AckNum,
            _Window,
            _Flags);
    }



}

/// <summary>
/// Manages an xsp session with the SG.
///
/// The idea is this class manages the low-ish level xsp session information. It should not 
/// be aware of key exchanges, ip addresses, heartbeats, secmsgs, key information, 
/// kerberos, etc. It does one task (encode/decode & encrypt/decrypt XspBuffers) and does 
/// it well.
/// </summary>
public class XspSession 
{

    // ----------------------------------------------------------------------------------
    // Private members
    // ----------------------------------------------------------------------------------
    #region Private Members

    private SecReg      _SecKeys;

    // SequenceXmit will be the next seqnum to use; SequenceRecv is the expected seqnum.
    private int         _SequenceXmit;
    private int         _SequenceRecv;

    #endregion

    // ----------------------------------------------------------------------------------
    // Constructors
    // ----------------------------------------------------------------------------------
    #region Constructors

    /// <summary>
    /// Creates a new XSP session.
    /// </summary>
    /// <param name="secKeys">The security information necessary to encrypt/decrypt.</param>
    public XspSession(SecReg secKeys)
    {
        _SecKeys        = secKeys;
        _SequenceXmit   = 0;
        _SequenceRecv   = 1;
    }

    #endregion

    #region Private Helpers

    private int GetNextSequenceXmit ()
    {
        return Interlocked.Increment(ref _SequenceXmit);
    }

    #endregion

    #region Public Properties

    /// <summary>The next sequence number that will be used when transmitting.</summary>
    public int SequenceXmit { get { return _SequenceXmit + 1; } }

    /// <summary>The last sequence number received and decoded.</summary>
    public int SequenceRecv { get { return _SequenceRecv; } }

    /// <summary>The SPI that this session is receiving on.</summary>
    /// <remarks>The names are reversed in the SecKeys, just to make things harder...</remarks>
    public uint ReceiveSPI { get { return _SecKeys.SpiXmit; } }

    /// <summary>The SPI that this session is transmitting on.</summary>
    /// <remarks>The names are reversed in the SecKeys, just to make things harder...</remarks>
    public uint TransmitSPI { get { return _SecKeys.SpiRecv; } }

    #endregion

    #region Public Functions

    // ----------------------------------------------------------------------------------
    // SyncSequenceNumbers
    //
    // This is a dirty hack, since XspSession currently lives outside the SgClient world, 
    // but yet they share the same XSP session. Once XspSession replaces XspPacket in 
    // SgClient, this hack should be removed.
    //
    // Sigh, allow the hack to continue living for my own convenience.
    // ----------------------------------------------------------------------------------
    public void SyncSequenceNumbers(SgClient sg)
    {
        if (_SequenceXmit > sg.SequenceXmit)
            sg.SequenceXmit = (uint)_SequenceXmit;
        else
            _SequenceXmit = (int)sg.SequenceXmit;

        if (_SequenceRecv > sg.SequenceRecv)
            sg.SequenceRecv = (uint)_SequenceRecv;
        else
            _SequenceRecv = (int)sg.SequenceRecv;
    }


    /// <summary>
    /// Allocates a new XspBuffer to be used by the encoding functions. Possible allocation 
    /// options one could implement here:
    ///
    ///   * Allocate a new one each call.  
    ///   * Better would be to use a free list of buffers to save the memory allocation.  
    ///   * Or if you know your app is synchronous and/or thread-safe, it could cache a 
    ///   single instance of a buffer and keep re-using it.  
    ///   * Or make it configurable!
    /// 
    /// I think we'll go with #3 for now. Just cause.
    /// 
    /// UPDATE: Was 3, switched to use XspBufferManager, so make that a #2.
    /// </summary>
    /// <returns>An XspBuffer.</returns>
    /// <remarks>Why is this public?</remarks>
    public XspBuffer AllocateXspBuffer()
    {
        return XspBufferManager.Allocate();
    }


    // ----------------------------------------------------------------------------------
    // Encode*
    //
    // These functions take a bunch of inputs and return an encoded and encrypted 
    // XspBuffer. The SequenceXmit member will be incremented. These are very convenient 
    // wrappers around the XspBuffer.Encode() method.
    // ----------------------------------------------------------------------------------

    #region EncodeSecMsg*

    public XspBuffer EncodeSecMsg (byte[] payload, uint payloadLength)
    {
        XspBuffer xspBuffer = AllocateXspBuffer();
        EncodeSecMsg(xspBuffer, payload, payloadLength);
        return xspBuffer;
    }

    public void EncodeSecMsg(
        XspBuffer xspBuffer,
        byte[]  payload, 
        uint    payloadLength)
    {
        int seq = GetNextSequenceXmit();

        xspBuffer.Encode(
            _SecKeys.BlockSize,
            XspHeader.XSP_TYPE_SEC,
            _SecKeys.SpiRecv,
            payload, 0, payloadLength,
            null, 0, 0,
            0, 0,
            null,
            seq);

        xspBuffer.Encrypt(_SecKeys, seq);
    }

    public XspBuffer EncodeSecMsg (SecMsgHeader secMsg)
    {
        XspBuffer xspBuffer = AllocateXspBuffer();
        EncodeSecMsg(xspBuffer, secMsg);
        return xspBuffer;
    }

    public void EncodeSecMsg (XspBuffer xspBuffer, SecMsgHeader secMsg)
    {
        int seq = GetNextSequenceXmit();

        BinaryWriter bw = xspBuffer.GetBinaryWriter();
        secMsg.WriteStream(bw);

        xspBuffer.EncodeWithDataInPlace(
            _SecKeys.BlockSize,
            XspHeader.XSP_TYPE_SEC,
            _SecKeys.SpiRecv,
            (uint)bw.BaseStream.Position,
            null, 0, 0,
            0, 0,
            null, 0,
            seq);

        xspBuffer.Encrypt(_SecKeys, seq);
    }

    #endregion

    #region EncodeUdp*

    public XspBuffer EncodeUdp (uint sourcePort, uint destPort, byte[] payload, uint payloadLength)
    {
        XspBuffer xspBuffer = AllocateXspBuffer();
        EncodeUdp(xspBuffer, sourcePort, destPort, payload, payloadLength);
        return xspBuffer;
    }
        
    public void EncodeUdp(
        XspBuffer xspBuffer,
        uint    sourcePort,
        uint    destPort,
        byte[]  payload, 
        uint    payloadLength)
    {
        int seq = GetNextSequenceXmit();

        xspBuffer.Encode(
            _SecKeys.BlockSize,
            XspHeader.XSP_TYPE_UDP_0,
            _SecKeys.SpiRecv,
            payload, 0, payloadLength,
            null, 0, 0,
            sourcePort, destPort,
            null,
            seq);

        xspBuffer.Encrypt(_SecKeys, seq);
    }

    public void EncodeUdpWithDataInPlace (
        XspBuffer xspBuffer,
        uint sourcePort,
        uint destPort,
        uint payloadLength)
    {
        int seq = GetNextSequenceXmit();

        xspBuffer.EncodeWithDataInPlace(
            _SecKeys.BlockSize,
            XspHeader.XSP_TYPE_UDP_0,
            _SecKeys.SpiRecv,
            payloadLength,
            null, 0, 0,
            sourcePort, destPort,
            null, 0,
            seq);

        xspBuffer.Encrypt(_SecKeys, seq);
    }

    #endregion

    #region EncodeTcp*

    public XspBuffer EncodeTcp (uint sourcePort, uint destPort, XspTcpInfo tcpInfo, byte[] payload, uint payloadLength)
    {
        XspBuffer xspBuffer = AllocateXspBuffer();
        EncodeTcp(xspBuffer, sourcePort, destPort, tcpInfo, payload, payloadLength);
        return xspBuffer;
    }

    public void EncodeTcp(
        XspBuffer xspBuffer,
        uint       sourcePort,
        uint       destPort,
        XspTcpInfo tcpInfo,
        byte[]     payload, 
        uint       payloadLength)
    {
        int seq = GetNextSequenceXmit();

        xspBuffer.Encode(
            _SecKeys.BlockSize,
            XspHeader.XSP_TYPE_TCP_0,
            _SecKeys.SpiRecv,
            payload, 0, payloadLength,
            null, 0, 0,
            sourcePort, destPort,
            tcpInfo,
            seq);

        xspBuffer.Encrypt(_SecKeys, seq);
    }

    public void EncodeTcpWithDataInPlace (
        XspBuffer xspBuffer,
        uint sourcePort,
        uint destPort,
        XspTcpInfo tcpInfo,
        uint payloadLength)
    {
        int seq = GetNextSequenceXmit();

        xspBuffer.EncodeWithDataInPlace(
            _SecKeys.BlockSize,
            XspHeader.XSP_TYPE_TCP_0,
            _SecKeys.SpiRecv,
            payloadLength,
            null, 0, 0,
            sourcePort, destPort,
            tcpInfo, 0,
            seq);

        xspBuffer.Encrypt(_SecKeys, seq);
    }

    public void EncodeTcpWithDataInPlace (
        XspBuffer xspBuffer,
        uint sourcePort,
        uint destPort,
        byte[] tcpInfo,
        uint tcpInfoOffset,
        uint payloadLength)
    {
        int seq = GetNextSequenceXmit();

        xspBuffer.EncodeWithDataInPlace(
            _SecKeys.BlockSize,
            XspHeader.XSP_TYPE_TCP_0,
            _SecKeys.SpiRecv,
            payloadLength,
            null, 0, 0,
            sourcePort, destPort,
            tcpInfo, tcpInfoOffset,
            seq);

        xspBuffer.Encrypt(_SecKeys, seq);
    }

    #endregion

    #region EncodeVdp*

    public XspBuffer EncodeVdp (uint sourcePort, uint destPort, byte[] payload, uint payloadLength)
    {
        XspBuffer xspBuffer = AllocateXspBuffer();
        EncodeVdp(xspBuffer, sourcePort, destPort, payload, payloadLength);
        return xspBuffer;
    }

    public void EncodeVdp(
        XspBuffer xspBuffer,
        uint       sourcePort,
        uint       destPort,
        byte[]     payload, 
        uint       payloadLength)
    {
        if (payloadLength <= 2)
            throw new ArgumentException("Payload must be at least 2 bytes for VDP packets");
        
        ushort cbDat = BitConverter.ToUInt16(payload, 0);
        payloadLength -= 2;

        if (cbDat > payloadLength)
            throw new ArgumentException("Data size exceeds size of payload");
        
        uint baseXspType;
        if (cbDat == payloadLength)
        {
            baseXspType = XspHeader.XSP_TYPE_VDP_DO_0;
        }
        else if (cbDat == 0)
        {
            baseXspType = XspHeader.XSP_TYPE_VDP_VO_0;
        }
        else
        {
            baseXspType = XspHeader.XSP_TYPE_VDP_0;
        }

        int seq = GetNextSequenceXmit();

        xspBuffer.Encode(
            _SecKeys.BlockSize,
            baseXspType,
            _SecKeys.SpiRecv,
            payload, 2, cbDat,
            payload, (uint)2 + cbDat, (uint)(payloadLength - cbDat),
            sourcePort, destPort,
            null,
            seq);

        xspBuffer.Encrypt(_SecKeys, seq);
    }

    #endregion

    // ----------------------------------------------------------------------------------
    // Decode
    //
    // Decodes an XspBuffer and optionally decrypts it. Since decryption is expensive 
    // (decoding is cheap), it's optional -- maybe you don't care about the actual data.
    //
    // Returns true if decoding succeeded and the packet matches our spi, or else false if 
    // the spi mismatches. This means the packet belongs to some other XspSession. If 
    // false is returned, the packet will be decoded but not decrypted. 
    //
    // NOTE: the sequence number will be wrong when false is returned; maybe we should 
    // make a lighter-weight Decode() function that simply updates the receive sequence 
    // number.  Or maybe Decrypt() could do that, since it is the only thing that really 
    // cares about the sequence number anyway.
    // ----------------------------------------------------------------------------------
    public bool Decode (XspBuffer xspBuffer, bool fDecrypt)
    {
        if (Decode(xspBuffer))
        {
            if (fDecrypt)
            {
                Decrypt(xspBuffer);
            }
        }
        else
        {
            return false;
        }

        return true;
    }

    /// <summary>
    /// Decodes a received XspBuffer, updating the receive sequence number.
    /// </summary>
    /// <param name="xspBuffer">The XspBuffer to decode.</param>
    /// <returns>
    /// Returns true if decoding succeeded and the packet matches our spi, or else false if 
    /// the spi mismatches. This means the packet belongs to some other XspSession. If 
    /// false is returned, the sequence number for the session will not have been updated. 
    /// </returns>
    public bool Decode (XspBuffer xspBuffer)
    {
        if (xspBuffer.RawBufferLength == 0)
            return false;

        int seqRecv = _SequenceRecv;
        xspBuffer.Decode(_SecKeys.BlockSize, ref seqRecv);

        if (xspBuffer.Spi != _SecKeys.SpiXmit)
            return false;

        // @@@ Maybe do validation on seqRecv to make sure it's within a reasonable 
        // window?
        _SequenceRecv = seqRecv;

        return true;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="xspBuffer"></param>
    public void Decrypt (XspBuffer xspBuffer)
    {
        xspBuffer.Decrypt(_SecKeys, xspBuffer.SequenceNumber);
    }

    #endregion
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\AskdcXbox360.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with. </summary>
    public class AskdcXbox360RequestInput: AskdcGenericRequestInput
    {
        //ConsoleOrUserName     Console ID of the machine in the form of XE.123456789012 OR gamertag of a user.  (note that this gets sent in both the PreauthXboxPPA and the request body)
        //IndividualKey         16 byte key chosen by the service returned in the XboxAccountCreation preauth from xmacs OR 16 byte key obtained from user creation or recovery.
        //CompoundKey           16 byte key computed from previous user keys and the current IndividualKey
        //Realm                 Normally PASSPORT.NET
        //ServerNames           Normally krbtgt and XBOX.COM
        //RequestTime           Time that the request was made
        //NOnce                 Value unique to this particular request
        //PreviousTickets       Used for the compound identity preauth
        //ConsoleCert           Used to distinguish between consoles with the same console ID.  If present the Xenon PPA preauth will be added automatically.
        //PlainPassport         Passport user and ticket information.  Used to authenticate a user.  If present then include the old unencrypted passport ticket preauth.
        //EncryptedPassport     Passport user and ticket information.  Used to authenticate a user.  If present then include the new encrypted passport ticket preauth.
        //EchoPreauthBytes      Includes the echo preauth with this data if present.

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public override System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate()
        {
            System.Collections.Generic.LinkedList<int> defaultPreauths=new System.Collections.Generic.LinkedList<int>();
            if (EchoPreauthBytes!=null)
            {
                defaultPreauths.AddLast(205); //PADATA_XBOX_ECHO
            }
            if (ConsoleCert!=null)
            {
                defaultPreauths.AddLast(216); //PADATA_XENON_PPA
            }

            defaultPreauths.AddLast(206); //PADATA_XBOX_CLIENT_VERSION

            if (PlainPassport!=null)
            {
                defaultPreauths.AddLast(213); //PADATA_PASSPORT_AUTHENTICATION
            }
            if (EncryptedPassport!=null)
            {
                defaultPreauths.AddLast(218); //PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION
            }

            defaultPreauths.AddLast(2); //PADATA_ENC_TIMESTAMP

            if (PreviousTicket!=null)
            {
                defaultPreauths.AddLast(130); //PADATA_COMPOUND_IDENTITY
            }

            return defaultPreauths;
        }

        /// <summary> Creates all the preauths required for the request, based on the other input fields. </summary>
        public override void GeneratePreauths()
        {
            ClearPreauths();

            System.Collections.Generic.IEnumerable<int> preauthsToAdd=PreauthsToGenerate;
            if (preauthsToAdd==null)
            {
                preauthsToAdd=GetDefaultPreauthsToGenerate();
            }

            System.Collections.Generic.List<Kerberos.Preauth> preauths=new System.Collections.Generic.List<Kerberos.Preauth>();
            preauths.Add(null); //reserve slot 0 for echo
            foreach (int paNumber in preauthsToAdd)
            {
                Kerberos.Preauth pa=PreauthHelpers.GenerateDefaultPreauth(paNumber, CompoundKey??IndividualKey, RequestTime, ConsoleOrUserName, PreviousTicket, NOnce, 0xfffe07d1, 0x12345678, 0x9abcdef0, PCNOnce, PlainPassport, EncryptedPassport, ConsoleCert, true, EchoPreauthBytes);
                preauths.Add(pa);
            }

            Preauths=preauths.ToArray();
        }

        /// <summary> Sets defaults for a machine request.  If previousTickets is not null then previous authentication is carried over. </summary>
        public override void SetMachineDefaults(XmacsGenericReplyOutput xmacsOutput, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            if (previousTicket==null) //initial request
            {
                SetDefaults(xmacsOutput.ConsoleId, xmacsOutput.MachineKey);
            }
            else //compound request
            {
                SetCompoundDefaults(xmacsOutput.ConsoleId, xmacsOutput.MachineKey, sessionKey, previousTicket);
            }
        }

        /// <summary> Sets defaults for a user request.  If previousTickets is not null then previous authentication is carried over. </summary>
        public override void SetUserDefaults(KdcUser user, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            if (previousTicket==null) //initial request
            {
                SetDefaults(user.Gamertag, user.XenonKey);
            }
            else //compound request
            {
                SetCompoundDefaults(user.Gamertag, user.XenonKey, sessionKey, previousTicket);
            }
        }

        /// <summary> Sets defaults for an initial machine or user request. consoleOrUserName should be either a console id of the form XE.012345678901, or a gamertag.  If the key is not specified, it is calculated based soley on consoleOrUserName. </summary>
        public void SetDefaults(string consoleOrUserName, byte []key)
        {
            ConsoleOrUserName=consoleOrUserName;
            IndividualKey=key;
            CompoundKey=null;

            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (IndividualKey==null)
            {
                IndividualKey=AuthContext.CalculateKeyFromGamertag(ConsoleOrUserName, true);
            }

            //set the basics
            base.SetDefaultBasics();
        }

        /// <summary> Sets the defaults for a request that contains a compound identity.   consoleOrUserName should be either a console id of the form XE.012345678901, or a gamertag.  If the client key is not specified, it is calculated based based on consoleOrUserName.  previousTicket MUST be specified.  If sessionKey isn't specified, it is taken from the previous ticket. </summary>
        public void SetCompoundDefaults(string consoleOrUserName, byte []clientKey, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (clientKey==null)
            {
                clientKey=AuthContext.CalculateKeyFromGamertag(consoleOrUserName, true);
            }

            //if session key isn't specified, take it from the previous ticket
            if (sessionKey==null)
            {
                sessionKey=previousTicket.EncryptedBody.Key.Key.Bytes;
            }

            //compute the compound identity key which is what is actually used for the request
            byte []key=KdcCrypto.ComputeCompoundIdentityKey(clientKey, sessionKey);

            //store previous the ticket and set defaults like normal now
            PreviousTicket=previousTicket;

            SetDefaults(consoleOrUserName, clientKey);
            CompoundKey=key;
        }
    };

    /// <summary> Used to build an Xbox360 Askdc Request. </summary>
    public class AskdcXbox360Request: AskdcGenericRequest
    {
        public AskdcXbox360Request()
        {
            ((KerberosRequestWithInput)this).Input=new AskdcXbox360RequestInput();
        }

        /// <summary> Casts the base Input as input for the current platform. </summary>
        public new AskdcXbox360RequestInput Input { get { return (AskdcXbox360RequestInput)base.Input; } }

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public override void SetRequest()
        {
            //put preauths into the request
            Preauths=Input.Preauths;

            //fill in the request body
            Version=new Raw.Integer();
            Version.Int64=5;

            MessageType=new Raw.Integer();
            MessageType.Int64=10;

            Options=new Kerberos.KerberosFlags();
            Options.Canonicalize=true;

            ClientName=new Kerberos.PrincipalName();
            ClientName.Type.Int64=10;
            ClientName.Names=new Compound.TagLengthValue<Raw.GeneralString>[1];
            ClientName.Names[0]=new Compound.TagLengthValue<Raw.GeneralString>();
            ClientName.Names[0].Value.String=Input.ConsoleOrUserName+"@xbox.com";

            Realm=new Raw.GeneralString();
            Realm.String=Input.Realm;

            ServerName=new Kerberos.PrincipalName();
            ServerName.Type.Int64=2;
            ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[Input.ServerNames.Length];
            for (int i=0; i<Input.ServerNames.Length; ++i)
            {
                ServerName.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                ServerName.Names[i].Value.String=Input.ServerNames[i];
            }

            UntilTime=new Kerberos.Time();
            UntilTime.DateTime=new System.DateTime(2037, 09, 13, 02, 48, 05); //the day the world ends?  I hope not.

            NOnce=new Raw.Integer();
            NOnce.Int64=unchecked((int)Input.NOnce); //we deviate from the standard here, as our nonce uses the range of a signed 32 bit int rather than unsigned

            EncryptionTypes=new Raw.Integer[1];
            EncryptionTypes[0]=new Raw.Integer();
            EncryptionTypes[0].Int64=0x17;
        }
    };

    /// <summary> Used to parse an Xbox360 Askdc Reply. </summary>
    public class AskdcXbox360Reply: AskdcGenericReply
    {
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\AskdcGeneric.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the base KerberosRequest.  This contains fields for all platforms, though not all platforms use all fields. </summary>
    public abstract class AskdcGenericRequestInput: RequestInputCommon
    {
        //See platform-specific file for details.      Used by:
        public string             ConsoleOrUserName; // All
        public byte             []IndividualKey;     // All
        public byte             []CompoundKey;       // All
        public string             Realm;             // All
        public string           []ServerNames;       // All
        public System.DateTime    RequestTime;       // All
        public uint               NOnce;             // All
        public Kerberos.Ticket    PreviousTicket;    // All
        public ulong              PCNOnce;           // PC
        public PassportTicket     PlainPassport;     // PC, Xbox360 (for testing only on Xbox360)
        public PassportTicket     EncryptedPassport; // PC, Xbox360
        public ConsoleCertificate ConsoleCert;       // Xbox360
        public byte               []EchoPreauthBytes;// All

        /// <summary> Sets defaults for a machine request.  If previousTickets is not null then previous authentication is carried over. </summary>
        public abstract void SetMachineDefaults(XmacsGenericReplyOutput xmacsOutput, byte []sessionKey, Kerberos.Ticket previousTicket);

        /// <summary> Sets defaults for a user request.  If previousTickets is not null then previous authentication is carried over. </summary>
        public abstract void SetUserDefaults(KdcUser user, byte []sessionKey, Kerberos.Ticket previousTicket);

        //set stuff common to the different types of askdc requests
        protected void SetDefaultBasics()
        {
            //realm and server names
            Realm="PASSPORT.NET";
            ServerNames=new string[2]{"krbtgt", "XBOX.COM"};

            //request was generated now
            RequestTime=System.DateTime.UtcNow;

            //generate a nonce
            SetRandomNOnce();
        }

        /// <summary> Sets the request time. </summary>
        public override void SetRequestTime(System.DateTime newTime)
        {
            RequestTime=newTime;
        }

        /// <summary> Gets the current requset time. </summary>
        public override System.DateTime GetRequestTime()
        {
            return RequestTime;
        }

        /// <summary> Sets a new random nonce. </summary>
        public override void SetRandomNOnce()
        {
            NOnce=unchecked((uint)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong());
        }

        /// <summary> Gets the current nonce. </summary>
        public override uint GetNOnce()
        {
            return NOnce;
        }

        /// <summary> Sets the echo preauth data from a kerberos preauth required error response.  Optionally attempts to decrypt it (failure is ignored). </summary>
        public void SetEchoPreauth(KerberosError kerbErr, bool decryptIfAble)
        {
            if (kerbErr.ErrorCode.Int64!=(long)KerbErrCode.KDC_ERR_PREAUTH_REQUIRED)
            {
                throw new KerberosAsnException("Cannot set echo data from kerberos error because it is not KDC_ERR_PREAUTH_REQUIRED.  Error:\n"+kerbErr);
            }

            SetEchoPreauth(kerbErr.ErrorData.Bytes, decryptIfAble);
        }

        /// <summary> Creates the echo preauth and sets the data it contains.  Optionally attempts to decrypt it (failure is ignored).</summary>
        public void SetEchoPreauth(byte []echoData, bool decryptIfAble)
        {
            EchoPreauthBytes=echoData;

            Kerberos.Preauth<Kerberos.PreauthXboxEcho> pa=new Kerberos.Preauth<Kerberos.PreauthXboxEcho>();
            pa.Data.Bytes=echoData;

            if (Preauths!=null)
            {
                Preauths[0]=pa; //slot 0 in the array is always reserved for automatically handling the echo in askdc
            }

            if (decryptIfAble)
            {
                try
                {
                    pa.Data.EncryptionKey=ServiceKeys.GetServiceKey(ServiceKeys.Key_AskdcEcho);
                    pa.Data.Decrypt();
                }
                catch
                {
                    Global.RO.Warn("Failed to decrypt echo preauth data.");
                }
            }
        }
    };

    /// <summary> Used to build an Generic Askdc Request. </summary>
    public abstract class AskdcGenericRequest: KerberosRequestWithInput
    {
        /// <summary> Data used to populate the base KerberosRequest. </summary>
        public new AskdcGenericRequestInput Input { get { return (AskdcGenericRequestInput)base.Input; } }

        /// <summary> Creates an askdc request object for a specific platform. </summary>
        public static AskdcGenericRequest CreateForClientType(AuthContext.ClientTypes clientType)
        {
            if (clientType==AuthContext.ClientTypes.Xenon) //xbox360
            {
                return new AskdcXbox360Request();
            }
            else if (clientType==AuthContext.ClientTypes.Panorama) //PC
            {
                return new AskdcPCRequest();
            }
            else if (clientType==AuthContext.ClientTypes.Xbox || clientType==AuthContext.ClientTypes.XenonBackCompat) //xbox1
            {
                return new AskdcXbox1Request();
            }
            else
            {
                throw new System.Exception("Unknown client type: "+clientType);
            }
        }
    };

    /// <summary> Output from askdc needed for further use by askdc or for use by xkdc. </summary>
    public class AskdcGenericReplyOutput
    {
        public Kerberos.Ticket Ticket;            //ticket from the askdc, to be passed back to the askdc or to the xkdc
        public string          ConsoleOrUserName; //name of the user or machine just authenticated
        public byte          []SessionKey;        //key from the encrypted reply body

        public ulong         []UserIds;           //list of users from previous authentications (important: this is only populated automatically if the askdc ticket is decrypted, otherwise you must populate this yourself)
        public ulong           MachineId;         //machine from previous authentication (important: this is only populated automatically if the askdc ticket is decrypted)

        // -- Code to synthesize a the resulting output from askdc

        public enum AuthDataToSynthesize
        {
            CompoundIdentity,
            XboxIdentity
        };

        //synthesize valid output based on input (will use testnet ticket key)
        //todo: most of this really should be moved into helper functions of the appropriate classes, but we don't have time to "do the right thing" at the moment.
        public void PopulateFromInput(AskdcGenericRequestInput input, AuthDataToSynthesize adType)
        {
            if (input.PlainPassport!=null && input.ConsoleOrUserName=="PC.USER")
            {
                Global.RO.Warn("Plain Passport Auth not implemented for askdc ticket generation.");
            }

            //walk the previous tickets and look at the current request and set the user IDs appropriately
            WindowsPacAuthData prevAdPac=null;
            System.Collections.Generic.List<ulong> prevPuids=new System.Collections.Generic.List<ulong>();
            byte []prevUserAuthCredentials=new byte[4]{2, 2, 2, 2}; //default to random key, which is what everything previously was
            if (input.PreviousTicket!=null)
            {
                System.Collections.Generic.List<ulong> userPuids=new System.Collections.Generic.List<ulong>();

                //the only authdata should be pac
                prevAdPac=(WindowsPacAuthData)input.PreviousTicket.EncryptedBody.AuthorizationData.List.Values[0];

                if (prevAdPac.XboxIdentity!=null) //new KDCs should always have this
                {
                    MachineId=prevAdPac.XboxIdentity.MachineId;

                    for (int u=0; u<4; ++u)
                    {
                        if (prevAdPac.XboxIdentity.UserId[u]!=0)
                        {
                            userPuids.Add(prevAdPac.XboxIdentity.UserId[u]);
                            prevPuids.Add(prevAdPac.XboxIdentity.UserId[u]);
                            prevUserAuthCredentials[u]=prevAdPac.XboxIdentity.UserIdCredential[u];
                        }
                    }

                    prevPuids.Add(MachineId);
                }
                else //for backcompat with older KDCs, accept compound identity
                {
                    MachineId=prevAdPac.Identity.Puid;
                    prevPuids.Add(MachineId);

                    if (prevAdPac.CompoundIdentity!=null)
                    {
                        foreach (WindowsPacAuthData.IdentityStructure pacId in prevAdPac.CompoundIdentity.Identities)
                        {
                            userPuids.Add(pacId.Puid);
                            prevPuids.Add(pacId.Puid);
                        }
                    }
                }

                UserIds=userPuids.ToArray();
            }

            //get the puid for what we're about to pretent to authenticate
            ulong newAuthPuid;
            if (input.ConsoleOrUserName.ToLower().StartsWith("xe.")) //xbox360 machines are in a separate table
            {
                newAuthPuid=ServerTestFramework.Database.MachineEditor.FromName(input.ConsoleOrUserName).Id;
            }
            else //this works for machine and users since both are stored in t_user_names
            {
                newAuthPuid=ServerTestFramework.Database.UserEditor.FromGamerTag(input.ConsoleOrUserName).Puid;
            }

            //build the authdata
            WindowsPacAuthData adPac=new WindowsPacAuthData();
            adPac.Type.Int64=1;
            adPac.ADType=128;

            if (adType==AuthDataToSynthesize.CompoundIdentity)
            {
                adPac.Identity=new WindowsPacAuthData.IdentityStructure(newAuthPuid);

                if (prevPuids.Count>0)
                {
                    adPac.CompoundIdentity=new WindowsPacAuthData.CompoundIdentityStructure();
                    adPac.CompoundIdentity.NumberOfIdentities=(ushort)prevPuids.Count;
                    adPac.CompoundIdentity.Identities=new WindowsPacAuthData.IdentityStructure[prevPuids.Count];
                    for (int i=0; i<prevPuids.Count; ++i)
                    {
                        adPac.CompoundIdentity.Identities[i]=new WindowsPacAuthData.IdentityStructure(prevPuids[i]);
                    }
                }

                adPac.ServerSignature=new WindowsPacAuthData.PacSignatureStructure();
                adPac.ServerSignature.SignatureType=4294967158; //no idea what this means, was pulled out of a KDC in a debugger
                adPac.ServerSignature.Signature=new byte[16];
            }
            else if (adType==AuthDataToSynthesize.XboxIdentity) //use XboxIdentity
            {
                adPac.XboxIdentity=new WindowsPacAuthData.XboxIdentityStructure();

                //populate the new identity from the old data first
                if (prevAdPac!=null)
                {
                    adPac.XboxIdentity.MachineId=prevAdPac.XboxIdentity.MachineId;
                    adPac.XboxIdentity.MachineIdCredential=prevAdPac.XboxIdentity.MachineIdCredential;

                    for (int u=0; u<4; ++u)
                    {
                        adPac.XboxIdentity.UserId[u]=prevAdPac.XboxIdentity.UserId[u];
                        adPac.XboxIdentity.UserIdCredential[u]=prevAdPac.XboxIdentity.UserIdCredential[u];
                    }
                }

                //add in the new entry
                bool newEntryIsMachine=(input.ConsoleOrUserName.ToLower().StartsWith("xe.") || input.ConsoleOrUserName.ToLower().StartsWith("pc.") && input.ConsoleOrUserName!="PC.USER");
                byte newEntryCredType=(byte)WindowsPacAuthData.CT_RandomKey;

                if (newEntryIsMachine)
                {
                    adPac.XboxIdentity.MachineId=newAuthPuid;
                    adPac.XboxIdentity.MachineIdCredential=newEntryCredType;
                }
                else
                {
                    if (input.PlainPassport!=null)
                    {
                        newEntryCredType=(byte)WindowsPacAuthData.CT_RawPassport;
                    }
                    else if (input.EncryptedPassport!=null)
                    {
                        newEntryCredType=(byte)WindowsPacAuthData.CT_EncryptedPassport;
                    }

                    //find a slot to put it
                    int u=0;
                    for (; u<4; ++u)
                    {
                        if (adPac.XboxIdentity.UserId[u]==0)
                        {
                            break;
                        }
                    }

                    if (u==4)
                    {
                        throw new System.Exception("No room in authdata for additional identity.");
                    }

                    adPac.XboxIdentity.UserId[u]=newAuthPuid;
                    adPac.XboxIdentity.UserIdCredential[u]=newEntryCredType;
                }
            }

            adPac.PrivServerSignature=new WindowsPacAuthData.PacSignatureStructure();
            adPac.PrivServerSignature.SignatureType=4294967158; //no idea what this means, was pulled out of a KDC in a debugger
            adPac.PrivServerSignature.Signature=new byte[16];

            adPac.RebuildHeaders();
            adPac.SetupAndCopyToBase();
            adPac.RecalculateLengths(true);

            //build the encrypted ticket body
            Kerberos.EncryptedTicketBody ticketBody=new Kerberos.EncryptedTicketBody();
            ticketBody.EncryptionKey=ServiceKeys.GetServiceKey(ServiceKeys.Key_KdcXboxCom);

            ticketBody.TicketFlags=new Kerberos.KerberosFlags();
            ticketBody.TicketFlags.Initial=true;
            ticketBody.TicketFlags.Preauthenticate=true;

            ticketBody.Key=new Kerberos.EncryptionKey();
            ticketBody.Key.Type.Int64=23;
            ticketBody.Key.Key=new Raw.OctetString();
            ticketBody.Key.Key.Bytes=input.IndividualKey; //todo: generate something random to use?

            ticketBody.ClientRealm=new Raw.GeneralString();
            ticketBody.ClientRealm.String=input.Realm;

            ticketBody.ClientName=new Kerberos.PrincipalName();
            ticketBody.ClientName.Type.Int64=2;
            ticketBody.ClientName.Names=new Compound.TagLengthValue<Raw.GeneralString>[2]{new Compound.TagLengthValue<Raw.GeneralString>(), new Compound.TagLengthValue<Raw.GeneralString>()};
            ticketBody.ClientName.Names[0].Value.String=input.ConsoleOrUserName;
            ticketBody.ClientName.Names[1].Value.String=input.Realm;

            ticketBody.Transite=new Kerberos.TransitedEncoding();
            ticketBody.Transite.Type.Int64=0;

            ticketBody.AuthTime=new Kerberos.Time();
            ticketBody.AuthTime.DateTime=input.RequestTime;

            ticketBody.StartTime=new Kerberos.Time();
            ticketBody.StartTime.DateTime=input.RequestTime;

            ticketBody.EndTime=new Kerberos.Time();
            ticketBody.EndTime.DateTime=input.RequestTime+new System.TimeSpan(365, 0, 0, 0); //year duration

            ticketBody.AuthorizationData=new Kerberos.AuthorizationData();
            ticketBody.AuthorizationData.List.Values=new AsnValueBase[1];
            ticketBody.AuthorizationData.List.Values[0]=adPac;

            ticketBody.OverallTag.RecalculateLengths(true);
            ticketBody.Encrypt();
            ticketBody.RecalculateLengths(true);

            //build the ticket
            Ticket=new Kerberos.Ticket();
            Ticket.Version.Int64=5;

            Ticket.Realm.String=input.Realm;

            Ticket.ServerName=new Kerberos.PrincipalName();
            Ticket.ServerName.Type.Int64=2;
            Ticket.ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[2]{new Compound.TagLengthValue<Raw.GeneralString>(), new Compound.TagLengthValue<Raw.GeneralString>()};
            Ticket.ServerName.Names[0].Value.String=input.ServerNames[0];
            Ticket.ServerName.Names[1].Value.String=input.ServerNames[1];

            Ticket.EncryptedBody=ticketBody;

            Ticket.RecalculateLengths(true);

            //set other relevent fields
            ConsoleOrUserName=input.ConsoleOrUserName;
            SessionKey=input.IndividualKey; //todo: generate something random to use?
        }
    };

    /// <summary> Used to parse an Generic Askdc Reply. </summary>
    public class AskdcGenericReply: KerberosReply
    {
        //common output from askdc
        public AskdcGenericReplyOutput Output;

        //AuthData from the decrypted askdc ticket for easy reference
        public WindowsPacAuthData AuthData=null;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates some of the generic Output member.  Returns true only if everything possible was fully decrypted. </summary>
        public virtual bool Decrypt(byte []sessionKey, byte []ticketKey)
        {
            bool failures=false;

            if (sessionKey!=null)
            {
                try
                {
                    DecryptBody(sessionKey);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt body of a "+GetType().ToString()+" with session key: "+e.Message);
                    failures=true;
                }

                if (Body!=null && Body.Key!=null)
                {
                    //we only have output if we successfully decrypted the response
                    Output=new AskdcGenericReplyOutput();
                    Output.Ticket=Ticket;
                    Output.ConsoleOrUserName=ClientName.Names[0].Value.ToString();
                    Output.SessionKey=Body.Key.Key.Bytes;
                }
            }

            if (Ticket!=null && ticketKey!=null)
            {
                Ticket.EncryptedBody.EncryptionKey=ticketKey;
                bool decryptedTicket=false;
                try
                {
                    Ticket.EncryptedBody.Decrypt();
                    decryptedTicket=true;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt ticket of a "+GetType().ToString()+" with ticket key: "+e.Message);
                    failures=true;
                }

                if (decryptedTicket && Ticket.EncryptedBody.AuthorizationData!=null)
                {
                    for (int i=0; i<Ticket.EncryptedBody.AuthorizationData.List.Values.Length; ++i)
                    {
                        Kerberos.CommonTypeDataSequence ctds=(Kerberos.CommonTypeDataSequence)Ticket.EncryptedBody.AuthorizationData.List.Values[i];
                        if (ctds.Type.Int64==1) //this is windows server pac auth data
                        {
                            AuthData=WindowsPacAuthData.Create(ctds);
                            Ticket.EncryptedBody.AuthorizationData.List.Values[i]=AuthData;
                        }
                    }
                }
            }

            if (Output!=null && AuthData!=null) //populate output from authdata
            {
                if (AuthData.XboxIdentity!=null) //newer KDCs always use this
                {
                    Output.MachineId=AuthData.XboxIdentity.MachineId;

                    Output.UserIds=new ulong[4];
                    for (int u=0; u<4; ++u)
                    {
                        Output.UserIds[u]=AuthData.XboxIdentity.UserId[u];
                    }
                }
                else //fall back to older KDC behaviour
                {
                    if (AuthData.CompoundIdentity!=null)
                    {
                        Output.UserIds=new ulong[AuthData.CompoundIdentity.NumberOfIdentities];
                        for (int i=0; i<AuthData.CompoundIdentity.NumberOfIdentities; ++i)
                        {
                            Output.UserIds[i]=AuthData.CompoundIdentity.Identities[i].Puid;
                        }
                    }

                    if (AuthData.Identity!=null)
                    {
                        Output.MachineId=AuthData.Identity.Puid;
                    }
                }
            }

            return !failures;
        }

        /// <summary> Verifies that various basic fields common to all askdc replies are correct. </summary>
        public void VerifyBasics()
        {
            ServerTestFramework.Utilities.ValueCheck.Test("AskdcReply Version", 5, Version.Int64);
            ServerTestFramework.Utilities.ValueCheck.Test("AskdcReply MessageType", 11, MessageType.Int64);
            ServerTestFramework.Utilities.ValueCheck.Test("AskdcReply ClientRealm", "PASSPORT.NET", ClientRealm.String);

            if (Body!=null)
            {
                ServerTestFramework.Utilities.ValueCheck.Test("AskdcReply EncryptedBody ServerRealm", "PASSPORT.NET", Body.ServerRealm.String);
                ServerTestFramework.Utilities.ValueCheck.Test("AskdcReply EncryptedBody ServerName Count", 2, Body.ServerName.Names.Length);
                ServerTestFramework.Utilities.ValueCheck.Test("AskdcReply EncryptedBody ServerName[0]", "krbtgt", Body.ServerName.Names[0].Value.String);
                ServerTestFramework.Utilities.ValueCheck.Test("AskdcReply EncryptedBody ServerName[1]", "XBOX.COM", Body.ServerName.Names[1].Value.String);
            }
        }

        /// <summary> Calls the base CreateFromAsn for a specific platform.
        public static AskdcGenericReply CreateFromAsnForClientType(AsnValueBase asn, AuthContext.ClientTypes clientType)
        {
            if (clientType==AuthContext.ClientTypes.Xenon) //xbox360
            {
                return AskdcXbox360Reply.CreateFromAsn<AskdcXbox360Reply>(asn);
            }
            else if (clientType==AuthContext.ClientTypes.Panorama) //PC
            {
                return AskdcPCReply.CreateFromAsn<AskdcPCReply>(asn);
            }
            else if (clientType==AuthContext.ClientTypes.Xbox || clientType==AuthContext.ClientTypes.XenonBackCompat) //xbox1
            {
                return AskdcXbox1Reply.CreateFromAsn<AskdcXbox1Reply>(asn);
            }
            else
            {
                throw new System.Exception("Unknown client type: "+clientType);
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\AskdcXbox1.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with. </summary>
    public class AskdcXbox1RequestInput: AskdcGenericRequestInput
    {
        //ConsoleOrUserName     Console ID of the machine in the form of SN.123456789012 OR gamertag of a user.  (note that this gets sent in both the PreauthXboxPPA and the request body)
        //IndividualKey         16 byte key chosen by the service returned in the XboxAccountCreation preauth from xmacs OR 16 byte key obtained from user creation or recovery.
        //CompoundKey           16 byte key computed from previous user keys and the current IndividualKey
        //Realm                 Normally PASSPORT.NET
        //ServerNames           Normally krbtgt and XBOX.COM
        //RequestTime           Time that the request was made
        //NOnce                 Value unique to this particular request
        //PreviousTickets       Used for the compound identity preauth
        //EchoPreauthBytes      Includes the echo preauth with this data if present.

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public override System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate()
        {
            System.Collections.Generic.LinkedList<int> defaultPreauths=new System.Collections.Generic.LinkedList<int>();
            if (EchoPreauthBytes!=null)
            {
                defaultPreauths.AddLast(205); //PADATA_XBOX_ECHO
            }
            if (PreviousTicket!=null)
            {
                defaultPreauths.AddLast(130); //PADATA_COMPOUND_IDENTITY
            }
            defaultPreauths.AddLast(131); //PADATA_PAC_REQUEST_EX
            defaultPreauths.AddLast(2); //PADATA_ENC_TIMESTAMP
            defaultPreauths.AddLast(206); //PADATA_XBOX_CLIENT_VERSION
            defaultPreauths.AddLast(204); //PADATA_XBOX_PPA

            return defaultPreauths;
        }

        /// <summary> Creates all the preauths required for the request, based on the other input fields. </summary>
        public override void GeneratePreauths()
        {
            ClearPreauths();

            System.Collections.Generic.IEnumerable<int> preauthsToAdd=PreauthsToGenerate;
            if (preauthsToAdd==null)
            {
                preauthsToAdd=GetDefaultPreauthsToGenerate();
            }

            System.Collections.Generic.List<Kerberos.Preauth> preauths=new System.Collections.Generic.List<Kerberos.Preauth>();
            preauths.Add(null); //reserve slot 0 for echo
            foreach (int paNumber in preauthsToAdd)
            {
                Kerberos.Preauth pa=PreauthHelpers.GenerateDefaultPreauth(paNumber, CompoundKey??IndividualKey, RequestTime, ConsoleOrUserName, PreviousTicket, NOnce, 0xfffe0000, 0x12345678, 0x9abcdef0, PCNOnce, PlainPassport, EncryptedPassport, ConsoleCert, true, EchoPreauthBytes);
                preauths.Add(pa);
            }

            Preauths=preauths.ToArray();
        }

        /// <summary> Sets defaults for a machine request.  If previousTickets is not null then previous authentication is carried over. </summary>
        public override void SetMachineDefaults(XmacsGenericReplyOutput xmacsOutput, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            if (previousTicket==null) //initial request
            {
                SetDefaults(xmacsOutput.ConsoleId, xmacsOutput.MachineKey);
            }
            else //compound request
            {
                SetCompoundDefaults(xmacsOutput.ConsoleId, xmacsOutput.MachineKey, sessionKey, previousTicket);
            }
        }

        /// <summary> Sets defaults for a user request.  If previousTickets is not null then previous authentication is carried over. </summary>
        public override void SetUserDefaults(KdcUser user, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            if (previousTicket==null) //initial request
            {
                SetDefaults(user.Gamertag, user.XboxKey);
            }
            else //compound request
            {
                SetCompoundDefaults(user.Gamertag, user.XboxKey, sessionKey, previousTicket);
            }
        }

        /// <summary> Sets defaults for an initial machine or user request. consoleOrUserName should be either a console id of the form XE.012345678901, or a gamertag.  If the key is not specified, it is calculated based soley on consoleOrUserName. </summary>
        public void SetDefaults(string consoleOrUserName, byte []key)
        {
            ConsoleOrUserName=consoleOrUserName;
            IndividualKey=key;
            CompoundKey=null;

            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (IndividualKey==null)
            {
                IndividualKey=AuthContext.CalculateKeyFromGamertag(ConsoleOrUserName, true);
            }

            //set the basics
            base.SetDefaultBasics();
        }

        /// <summary> Sets the defaults for a request that contains a compound identity.   consoleOrUserName should be either a console id of the form XE.012345678901, or a gamertag.  If the client key is not specified, it is calculated based based on consoleOrUserName.  previousTicket MUST be specified.  If sessionKey isn't specified, it is taken from the previous ticket. </summary>
        public void SetCompoundDefaults(string consoleOrUserName, byte []clientKey, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (clientKey==null)
            {
                clientKey=AuthContext.CalculateKeyFromGamertag(consoleOrUserName, true);
            }

            //if session key isn't specified, take it from the previous ticket
            if (sessionKey==null)
            {
                sessionKey=previousTicket.EncryptedBody.Key.Key.Bytes;
            }

            //compute the compound identity key which is what is actually used for the request
            byte []key=KdcCrypto.ComputeCompoundIdentityKey(clientKey, sessionKey);

            //store previous the ticket and set defaults like normal now
            PreviousTicket=previousTicket;

            SetDefaults(consoleOrUserName, clientKey);
            CompoundKey=key;
        }
    };

    /// <summary> Used to build an Xbox1 Askdc Request. </summary>
    public class AskdcXbox1Request: AskdcGenericRequest
    {
        public AskdcXbox1Request()
        {
            ((KerberosRequestWithInput)this).Input=new AskdcXbox1RequestInput();
        }

        /// <summary> Casts the base Input as input for the current platform. </summary>
        public new AskdcXbox1RequestInput Input { get { return (AskdcXbox1RequestInput)base.Input; } }

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public override void SetRequest()
        {
            //put preauths into the request
            Preauths=Input.Preauths;

            //fill in the request body
            Version=new Raw.Integer();
            Version.Int64=5;

            MessageType=new Raw.Integer();
            MessageType.Int64=10;

            Options=new Kerberos.KerberosFlags();
            Options.Canonicalize=true;

            ClientName=new Kerberos.PrincipalName();
            ClientName.Type.Int64=10;
            ClientName.Names=new Compound.TagLengthValue<Raw.GeneralString>[1];
            ClientName.Names[0]=new Compound.TagLengthValue<Raw.GeneralString>();
            ClientName.Names[0].Value.String=Input.ConsoleOrUserName+"@xbox.com";

            Realm=new Raw.GeneralString();
            Realm.String=Input.Realm;

            ServerName=new Kerberos.PrincipalName();
            ServerName.Type.Int64=2;
            ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[Input.ServerNames.Length];
            for (int i=0; i<Input.ServerNames.Length; ++i)
            {
                ServerName.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                ServerName.Names[i].Value.String=Input.ServerNames[i];
            }

            UntilTime=new Kerberos.Time();
            UntilTime.DateTime=new System.DateTime(2037, 09, 13, 02, 48, 05); //the day the world ends?  I hope not.

            NOnce=new Raw.Integer();
            NOnce.Int64=unchecked((int)Input.NOnce); //we deviate from the standard here, as our nonce uses the range of a signed 32 bit int rather than unsigned

            EncryptionTypes=new Raw.Integer[1];
            EncryptionTypes[0]=new Raw.Integer();
            EncryptionTypes[0].Int64=0x17;
        }
    };

    /// <summary> Used to parse an Xbox1 Askdc Reply. </summary>
    public class AskdcXbox1Reply: AskdcGenericReply
    {
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\AskdcPC.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with. </summary>
    public class AskdcPCRequestInput: AskdcGenericRequestInput
    {
        //ConsoleOrUserName     Console ID of the machine in the form of PC.123456789012@XBOX.COM, OR PC.USER.
        //IndividualKey         16 byte key chosen by the service returned in the PCAccountCreation preauth from xmacs, OR a Principal Key computed from the passport ticket session key and a pc nonce.
        //CompoundKey           16 byte key computed from previous user keys and the current IndividualKey
        //Realm                 Normally PASSPORT.NET
        //ServerNames           Normally krbtgt and XBOX.COM
        //RequestTime           Time that the request was made
        //NOnce                 Value unique to this particular request
        //PreviousTickets       Used for the compound identity preauth
        //PCNOnce               NOnce for the PC preauth (unrelated to the NOnce in the kerberos request)
        //PlainPassport         Passport user and ticket information.  Used to authenticate a user.  If present then include the old unencrypted passport ticket preauth.
        //EncryptedPassport     Passport user and ticket information.  Used to authenticate a user.  If present then include the new encrypted passport ticket preauth.
        //EchoPreauthBytes      Includes the echo preauth with this data if present.

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public override System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate()
        {
            System.Collections.Generic.LinkedList<int> defaultPreauths=new System.Collections.Generic.LinkedList<int>();
            if (EchoPreauthBytes!=null)
            {
                defaultPreauths.AddLast(205); //PADATA_XBOX_ECHO
            }
            if (PlainPassport!=null)
            {
                defaultPreauths.AddLast(213); //PADATA_PASSPORT_AUTHENTICATION
                defaultPreauths.AddLast(131); //PADATA_PAC_REQUEST_EX - The old client that uses this preauth includes this, so we will by default in this case
            }
            if (EncryptedPassport!=null)
            {
                defaultPreauths.AddLast(218); //PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION
            }
            if (ConsoleOrUserName!="PC.USER")
            {
                defaultPreauths.AddLast(206); //PADATA_XBOX_CLIENT_VERSION
            }

            defaultPreauths.AddLast(2); //PADATA_ENC_TIMESTAMP

            if (PreviousTicket!=null)
            {
                defaultPreauths.AddLast(130); //PADATA_COMPOUND_IDENTITY
            }

            return defaultPreauths;
        }

        /// <summary> Creates all the preauths required for the request, based on the other input fields. </summary>
        public override void GeneratePreauths()
        {
            //compute the principal key if needed
            if (PlainPassport!=null)
            {
                if (IndividualKey==null)
                {
                    IndividualKey=KdcCrypto.ComputePCPrincipalKey(PlainPassport.Key, PCNOnce);
                }
            }

            ClearPreauths();

            System.Collections.Generic.IEnumerable<int> preauthsToAdd=PreauthsToGenerate;
            if (preauthsToAdd==null)
            {
                preauthsToAdd=GetDefaultPreauthsToGenerate();
            }

            System.Collections.Generic.List<Kerberos.Preauth> preauths=new System.Collections.Generic.List<Kerberos.Preauth>();
            preauths.Add(null); //reserve slot 0 for echo
            foreach (int paNumber in preauthsToAdd)
            {
                Kerberos.Preauth pa=PreauthHelpers.GenerateDefaultPreauth(paNumber, CompoundKey??IndividualKey, RequestTime, ConsoleOrUserName, PreviousTicket, NOnce, 0x585207d1, 0x12345678, 0x9abcdef0, PCNOnce, PlainPassport, EncryptedPassport, ConsoleCert, true, EchoPreauthBytes);
                preauths.Add(pa);
            }

            Preauths=preauths.ToArray();
        }

        /// <summary> Sets defaults for a machine request.  If previousTickets is not null then previous authentication is carried over. </summary>
        public override void SetMachineDefaults(XmacsGenericReplyOutput xmacsOutput, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            if (previousTicket==null) //initial request
            {
                SetDefaults(xmacsOutput.ConsoleId, xmacsOutput.MachineKey);
            }
            else //compound request
            {
                SetCompoundDefaults(xmacsOutput.ConsoleId, xmacsOutput.MachineKey, sessionKey, previousTicket);
            }
        }

        /// <summary> Sets defaults for a user request.  If previousTickets is not null then previous authentication is carried over. </summary>
        public override void SetUserDefaults(KdcUser user, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            if (user.Passport==null) //give the user a passport if needed
            {
                user.LinkPassport(null);
            }

            if (user.Passport.EncryptForPanoramaByDefault)
            {
                if (previousTicket==null) //initial request
                {
                    SetDefaultsEncryptedPassport(user.Passport, user.Gamertag, user.XenonKey);
                }
                else //compound request
                {
                    SetCompoundDefaultsEncryptedPassport(user.Passport, user.Gamertag, user.XenonKey, sessionKey, previousTicket);
                }
            }
            else
            {
                if (previousTicket==null) //initial request
                {
                    SetDefaultsPlainPassport(user.Passport);
                }
                else //compound request
                {
                    SetCompoundDefaultsPlainPassport(user.Passport, null, sessionKey, previousTicket);
                }
            }
        }

        /// <summary> Sets defaults for an initial machine-only request. consoleId should be computed from the machine id in the form PC.012345678901@XBOX.COM.  If the key is not specified, it is calculated based soley on consoleId. </summary>
        public void SetDefaults(string consoleId, byte []key)
        {
            ConsoleOrUserName=consoleId;
            IndividualKey=key;
            CompoundKey=null;

            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (IndividualKey==null)
            {
                IndividualKey=AuthContext.CalculateKeyFromGamertag(ConsoleOrUserName, true);
            }

            //
            if (PCNOnce==0)
            {
                PCNOnce=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
            }

            //set the basics
            base.SetDefaultBasics();
        }

        /// <summary> Sets the defaults for an initial passport user request using the old unencrypted preauth. </summary>
        public void SetDefaultsPlainPassport(PassportAuth passport)
        {
            //get passport info if needed
            PlainPassport=passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

            //console id is special
            ConsoleOrUserName="PC.USER";

            //
            if (PCNOnce==0)
            {
                PCNOnce=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
            }

            //set the basics
            base.SetDefaultBasics();
        }

        /// <summary> Sets the defaults for an initial passport user request using the new encrypted preauth. </summary>
        public void SetDefaultsEncryptedPassport(PassportAuth passport, string gamerTag, byte []key)
        {
            ConsoleOrUserName=gamerTag;
            IndividualKey=key;
            CompoundKey=null;

            //get passport info if needed
            EncryptedPassport=passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            //generate a key from the gamertag, in a way that can be easily reproduced by other code later
            if (IndividualKey==null)
            {
                IndividualKey=AuthContext.CalculateKeyFromGamertag(ConsoleOrUserName, true);
            }

            //
            if (PCNOnce==0)
            {
                PCNOnce=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
            }

            //set the basics
            base.SetDefaultBasics();
        }

        /// <summary> Sets the defaults for a machine request that contains a compound identity.   consoleId should be computed from the machine id in the form PC.012345678901@XBOX.COM.  If the client key is not specified, it is calculated based based on consoleId.  previousTicket MUST be specified.  If sessionKey isn't specified, it is taken from the previous ticket. </summary>
        public void SetCompoundDefaults(string consoleId, byte []clientKey, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (clientKey==null)
            {
                clientKey=AuthContext.CalculateKeyFromGamertag(consoleId, true);
            }

            //if session key isn't specified, take it from the previous ticket
            if (sessionKey==null)
            {
                sessionKey=previousTicket.EncryptedBody.Key.Key.Bytes;
            }

            //compute the compound identity key which is what is actually used for the request
            byte []key=KdcCrypto.ComputeCompoundIdentityKey(clientKey, sessionKey);

            //store previous the ticket and set defaults like normal now
            PreviousTicket=previousTicket;

            SetDefaults(consoleId, clientKey);
            CompoundKey=key;
        }

        /// <summary> Sets the defaults for a user request that contains a compound identity.   If the principalKey is not specified, it is calculated normally.  previousTicket MUST be specified.  If sessionKey isn't specified, it is taken from the previous ticket. </summary>
        public void SetCompoundDefaultsPlainPassport(PassportAuth passport, byte []principalKey, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            //get passport info if needed
            PlainPassport=passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);

            //get principal key if needed.  we need the pc nonce for this so set that too
            PCNOnce=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();

            if (principalKey==null)
            {
                principalKey=KdcCrypto.ComputePCPrincipalKey(PlainPassport.Key, PCNOnce);
            }

            //if session key isn't specified, take it from the previous ticket
            if (sessionKey==null)
            {
                sessionKey=previousTicket.EncryptedBody.Key.Key.Bytes;
            }

            //compute the compound identity key which is what is actually used for the request
            byte []key=KdcCrypto.ComputeCompoundIdentityKey(principalKey, sessionKey);

            //store previous the ticket and set defaults like normal now
            PreviousTicket=previousTicket;

            SetDefaults("PC.USER", principalKey);
            CompoundKey=key;
        }

        /// <summary> Sets the defaults for a user request that contains a compound identity.   If the principalKey is not specified, it is calculated normally.  previousTicket MUST be specified.  If sessionKey isn't specified, it is taken from the previous ticket. </summary>
        public void SetCompoundDefaultsEncryptedPassport(PassportAuth passport, string gamerTag, byte []principalKey, byte []sessionKey, Kerberos.Ticket previousTicket)
        {
            //get passport info if needed
            EncryptedPassport=passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);

            //get principal key if needed.  we need the pc nonce for this so set that too
            PCNOnce=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();

            if (principalKey==null)
            {
                principalKey=KdcCrypto.ComputePCPrincipalKey(EncryptedPassport.Key, PCNOnce);
            }

            //if session key isn't specified, take it from the previous ticket
            if (sessionKey==null)
            {
                sessionKey=previousTicket.EncryptedBody.Key.Key.Bytes;
            }

            //compute the compound identity key which is what is actually used for the request
            byte []key=KdcCrypto.ComputeCompoundIdentityKey(principalKey, sessionKey);

            //store previous the ticket and set defaults like normal now
            PreviousTicket=previousTicket;

            SetDefaults(gamerTag, principalKey);
            CompoundKey=key;
        }

        /// <summary> Builds the ClientName field from a pc machine id.  This will look something like: PC.00000022EF3D@XBOX.COM </summary>
        public static string CalculateClientNameFromMachineID(ulong machineId)
        {
            return string.Format("PC.{0:X12}@XBOX.COM", machineId&0x0000ffffffffffff);
        }
    };

    /// <summary> Used to build an PC Askdc Request. </summary>
    public class AskdcPCRequest: AskdcGenericRequest
    {
        public AskdcPCRequest()
        {
            ((KerberosRequestWithInput)this).Input=new AskdcPCRequestInput();
        }

        /// <summary> Casts the base Input as input for the current platform. </summary>
        public new AskdcPCRequestInput Input { get { return (AskdcPCRequestInput)base.Input; } }

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public override void SetRequest()
        {
            //put preauths into the request
            Preauths=Input.Preauths;

            //fill in the request body
            Version=new Raw.Integer();
            Version.Int64=5;

            MessageType=new Raw.Integer();
            MessageType.Int64=10;

            Options=new Kerberos.KerberosFlags();
            Options.Canonicalize=true;

            ClientName=new Kerberos.PrincipalName();
            ClientName.Type.Int64=10;
            ClientName.Names=new Compound.TagLengthValue<Raw.GeneralString>[1];
            ClientName.Names[0]=new Compound.TagLengthValue<Raw.GeneralString>();
            ClientName.Names[0].Value.String=Input.ConsoleOrUserName+"@xbox.com";

            Realm=new Raw.GeneralString();
            Realm.String=Input.Realm;

            ServerName=new Kerberos.PrincipalName();
            ServerName.Type.Int64=2;
            ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[Input.ServerNames.Length];
            for (int i=0; i<Input.ServerNames.Length; ++i)
            {
                ServerName.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                ServerName.Names[i].Value.String=Input.ServerNames[i];
            }

            UntilTime=new Kerberos.Time();
            UntilTime.DateTime=new System.DateTime(2037, 09, 13, 02, 48, 05); //the day the world ends?  I hope not.

            NOnce=new Raw.Integer();
            NOnce.Int64=unchecked((int)Input.NOnce); //we deviate from the standard here, as our nonce uses the range of a signed 32 bit int rather than unsigned

            EncryptionTypes=new Raw.Integer[1];
            EncryptionTypes[0]=new Raw.Integer();
            EncryptionTypes[0].Int64=0x17;
        }
    };

    /// <summary> Used to parse an PC Askdc Reply. </summary>
    public class AskdcPCReply: AskdcGenericReply
    {
        //Response to a passport user authentication request
        public Kerberos.Preauth<Kerberos.PreauthPassportAuthenticationReply> PreauthPassportAuthenticationReply;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates some of the generic Output member.  Returns true only if everything possible was fully decrypted. </summary>
        public override bool Decrypt(byte []principalKey, byte []ticketKey)
        {
            bool failures=!base.Decrypt(principalKey, ticketKey);

            if (PreauthPassportAuthenticationReply!=null && principalKey!=null)
            {
                try
                {
                    PreauthPassportAuthenticationReply.Data.Decrypt(principalKey);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthPassportAuthenticationReply of a "+GetType().ToString()+" with principal key: "+e.Message);
                    failures=true;
                }
            }

            return !failures;
        }

        //called after a reply has been build from asn
        protected override void AfterCreatefromAsn()
        {
            base.AfterCreatefromAsn();

            //find our preauths to store locally for more convenient access
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa is Kerberos.Preauth<Kerberos.PreauthPassportAuthenticationReply>)
                    {
                        PreauthPassportAuthenticationReply=(Kerberos.Preauth<Kerberos.PreauthPassportAuthenticationReply>)pa;
                    }
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\Asn.cs ===
//#define DEBUG_BAD_LENGTHS

using System.IO;

/// <summary> ASN.1 DER.  Currently only used by the KDC. </summary>
namespace ServerTestFramework.LiveService.Auth.Asn
{
    /// <summary> Used to build up a collection of asn encoded bytes. </summary>
    public abstract class AsnValueBase
    {
        //When this is called, the type should append all of its bytes to byteList.
        public abstract void AppendBytesTo(MemoryStream byteList);

        //Calls AppendBytesTo and returns the result as a byte array (the returned byte array does not share memory with the existing structure).
        public byte[] GetBytes()
        {
            MemoryStream byteList=new MemoryStream();
            AppendBytesTo(byteList);
            return byteList.ToArray();
        }

        //Assigns a value from an incoming set of bytes.  Returns how many bytes were actually used.
        public virtual long SetBytes(byte []data, long dataStart, long dataLength)
        {
            throw new System.Exception("AsnValueBase type "+GetType().ToString()+" does not implement SetBytes().");
        }

        public long SetBytes(byte []data)
        {
            return SetBytes(data, 0, data.Length);
        }

        //Recalculates every asn raw Length field in the structure (if applicable), optionally including recursing into all nested structures.  Also returns the number of bytes needed to store it.
        public long RecalculateLengths(bool updateNestedStructures)
        {
            return ProcessLengths(true, updateNestedStructures);
        }

        //Returns the number of bytes needed to store the data as it currently stands.  This may not reflect an accurate valid encoding if data has changed and all lengths were not updated.
        public long GetLength()
        {
            return ProcessLengths(false, false);
        }

        //Returns the number of bytes needed to store an asn value as it currently stands.  Optionally updates the Length field in a structure and in nested structures (this may affect the length).  Intended only for use by asn encoding implementations.
        public abstract long ProcessLengths(bool updateLengthFields, bool updateNestedStructures);
    };

    /// <summary> An AsnValueBase that is an array of stored bytes. </summary>
    public class AsnBytes: AsnValueBase
    {
        public byte []Bytes=new byte[0];

        public override long SetBytes(byte []data, long dataStart, long dataLength)
        {
            Bytes=new byte[dataLength];
            System.Array.Copy(data, dataStart, Bytes, 0, dataLength);
            return dataLength;
        }

        public override void AppendBytesTo(MemoryStream byteList)
        {
            byteList.Write(Bytes, 0, Bytes.Length);
        }

        public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
        {
            return Bytes.LongLength;
        }

        public override string ToString()
        {
            return "0x"+ServerTestFramework.Utilities.Hexer.tohex(Bytes);
        }
    };

    /// <summary> This may be used by the ASN parser to represent bytes that failed to parse. </summary>
    public class BadAsnBytes: AsnBytes
    {
        public System.Exception Error;  //exception from parsing

        public BadAsnBytes(System.Exception e, byte []data, long dataStart, long dataLength)
        {
            Error=e;
            try
            {
                Bytes=new byte[dataLength];
                System.Array.Copy(data, dataStart, Bytes, 0, dataLength);
            }
            catch (System.Exception)
            {
                Error=new System.Exception("Error storing bytes in BadAsnBytes, start="+dataStart+" length="+dataLength+" data.Length="+(data==null?"null":data.Length.ToString()), e);
            }
        }

        public override string ToString()
        {
            string s="";
            if (Error!=null)
            {
                s+=Error.ToString()+"\n";
            }

            s+="Bytes: "+base.ToString();
            return s;
        }
    };

    /// <summary> Returns an asn tag that identifies an object. </summary>
    public interface IGetDefaultTag
    {
        Raw.Tag GetDefaultTag();
    };

    /// <summary> Thrown by accessors if a conversion to or from a set of bytes is not possible. </summary>
    public class CannotRepresentValueException: AsnException
    {
    };

    /// <summary> Thrown for asn related errors. </summary>
    public class AsnException: System.Exception
    {
        public AsnException() {}
        public AsnException(string msg): base(msg) {}
        public AsnException(string msg, System.Exception e): base(msg, e) {}
    };

    /// <summary> Possible classes of tags.  This lives in the upper 2 bits of a tag. </summary>
    public enum TagClasses: byte
    {
        Universal=0,   //00
        Application=1, //01
        Context=2,     //10
        Private=3      //11
    };

    /// <summary> Basic raw ASN values, which are not part of a structured type or type-length-value form. </summary>
    public class Raw
    {
        /// <summary> An arbitrary-length positive integer encoded in septets with the most significant bit set to indicate another octet of data follows.  This is mostly used internally as part of encoding other tags. </summary>
        public class VariableLengthPositiveInteger: AsnBytes
        {
            public ulong UInt64
            {
                set
                {
                    //figure out how many bytes we need to store this
                    if      (value<(ulong)128) Bytes=new byte[1];
                    else if (value<(ulong)128*128) Bytes=new byte[2];
                    else if (value<(ulong)128*128*128) Bytes=new byte[3];
                    else if (value<(ulong)128*128*128*128) Bytes=new byte[4];
                    else if (value<(ulong)128*128*128*128*128) Bytes=new byte[5];
                    else if (value<(ulong)128*128*128*128*128*128) Bytes=new byte[6];
                    else if (value<(ulong)128*128*128*128*128*128*128) Bytes=new byte[7];
                    else if (value<(ulong)128*128*128*128*128*128*128*128) Bytes=new byte[8];
                    else if (value<(ulong)128*128*128*128*128*128*128*128*128) Bytes=new byte[9];
                    else Bytes=new byte[10];

                    //break the number into septets and store each one in an octet, leaving the high bit empty
                    ulong accum=value;
                    for (int i=Bytes.Length-1; i>=0; --i)
                    {
                        Bytes[i]=(byte)(accum&(ulong)0x7f);
                        accum>>=7;
                    }

                    //mark the high bits as "more" for all but the last octet
                    for (int i=0; i<Bytes.Length-1; ++i)
                    {
                        Bytes[i]|=0x80;
                    }
                }

                get
                {
                    //extract a septet from each octet
                    ulong val=0;
                    for (int i=0; i<Bytes.Length; ++i)
                    {
                        if ((val&0xfe00000000000000)!=0)
                        {
                            throw new CannotRepresentValueException();
                        }

                        val<<=7;
                        val|=(ulong)Bytes[i]&(ulong)0x7f;
                    }
                    return val;
                }
            }

            //this is variable length, so only consume what we need
            public override long SetBytes(byte []data, long dataStart, long dataLength)
            {
                long len=0;
                for (long i=0; i<dataLength; ++i)
                {
                    len=i+1;
                    if ((data[dataStart+i]&0x80) == 0)
                    {
                        break;
                    }
                }

                Bytes=new byte[len];
                System.Array.Copy(data, dataStart, Bytes, 0, len);
                return len;
            }

            public override string ToString()
            {
                if (Bytes==null || Bytes.Length==0)
                {
                    return "";
                }

                return UInt64.ToString();
            }
        };

        /// <summary> A tag. </summary>
        public class Tag: AsnBytes, System.IComparable<Tag>
        {
            //the tag number
            public ulong Number
            {
                set
                {
                    //save the class/constructed bits
                    TagClasses classes=TagClasses.Private;
                    bool constructed=false;

                    if (Bytes.Length>0)
                    {
                        classes=Class;
                        constructed=Constructed;
                    }

                    if (value<0x1f) //short form
                    {
                        Bytes=new byte[1];
                        Bytes[0]=(byte)value;
                    }
                    else //long form
                    {
                        VariableLengthPositiveInteger asnint=new VariableLengthPositiveInteger();
                        asnint.UInt64=value;

                        Bytes=new byte[1+asnint.Bytes.Length];
                        Bytes[0]=0x1f;
                        System.Array.Copy(asnint.Bytes, 0, Bytes, 1, asnint.Bytes.Length);
                    }

                    //restore class/constructed bits
                    Class=classes;
                    Constructed=constructed;
                }

                get
                {
                    //see if it's in short form
                    byte shortFormValue=(byte)(Bytes[0]&0x1f);
                    if (shortFormValue<=0x1e)
                    {
                        return shortFormValue;
                    }

                    //nope, long form
                    if (Bytes.Length==1)
                    {
                        throw new CannotRepresentValueException();
                    }

                    //the rest of the bytes are a regular asn int for the tag number
                    VariableLengthPositiveInteger asnint=new VariableLengthPositiveInteger();
                    asnint.Bytes=new byte[Bytes.Length-1];
                    System.Array.Copy(Bytes, 1, asnint.Bytes, 0, asnint.Bytes.Length);
                    return asnint.UInt64;
                }
            }

            //the class of the tag (upper 2 bits)
            public TagClasses Class
            {
                set
                {
                    if (Bytes.Length==0)
                    {
                        Bytes=new byte[1];
                    }

                    Bytes[0]=(byte)((Bytes[0]&0x3f) | ((((byte)value)<<6)&0xc0));
                }

                get
                {
                    return (TagClasses)(Bytes[0]>>6);
                }
            }

            //whether it is in constructed form (3rd bit from the top) - this is true if the value of a tlv is itself another tlv
            public bool Constructed
            {
                set
                {
                    if (Bytes.Length==0)
                    {
                        Bytes=new byte[1];
                    }

                    Bytes[0]=(byte)((Bytes[0]&0xdf) | (value?0x20:0));
                }
                get
                {
                    return (Bytes[0]&0x20)!=0;
                }
            }

            //we override this to only pull what we need, since it makes up a part of a Tag-Length-Value container
            public override long SetBytes(byte []data, long dataStart, long dataLength)
            {
                byte shortFormValue=(byte)(data[dataStart]&0x1f);
                if (shortFormValue<=0x1e) //it's in short form
                {
                    Bytes=new byte[1];
                    Bytes[0]=data[dataStart];
                    return 1;
                }
                else //it's in long form
                {
                    VariableLengthPositiveInteger vlint=new VariableLengthPositiveInteger();
                    long vlintLength=vlint.SetBytes(data, dataStart+1, dataLength-1);
                    Bytes=new byte[vlint.Bytes.Length+1];
                    Bytes[0]=data[dataStart];
                    System.Array.Copy(vlint.Bytes, 0, Bytes, 1, vlint.Bytes.Length);
                    return Bytes.Length;
                }
            }

            //
            public Tag()
            {
            }

            public Tag(ulong tagNumber, TagClasses tagClass, bool isConstructed)
            {
                Number=tagNumber;
                Class=tagClass;
                Constructed=isConstructed;
            }

            public override string ToString()
            {
                if (Bytes.Length==0) return "Bad Tag (0 bytes)";

                string s="";
                s+=(Constructed?"Constructed":"Nonconstructed");
                s+=" Class="+Class;
                s+=" Number=";
                try
                {
                    s+=Number.ToString();
                }
                catch
                {
                    s+="Error";
                }

                return s;
            }

            public int CompareTo(Tag other)
            {
                TagClasses myClass=Class;
                TagClasses theirClass=other.Class;
                if (myClass!=theirClass)
                {
                    return myClass<theirClass?-1:1;
                }

                ulong myNumber=Number;
                ulong theirNumber=other.Number;
                if (myNumber!=theirNumber)
                {
                    return myNumber<theirNumber?-1:1;
                }

                bool myConstructed=Constructed;
                bool theirConstructed=other.Constructed;
                if (myConstructed!=theirConstructed)
                {
                    return myConstructed?1:-1;
                }

                return 0;
            }
        };

        /// <summary> A length in the range of 0 through 2^1008-1. </summary>
        public class Length: AsnBytes
        {
            public ulong UInt64
            {
                set
                {
                    if (value<0x80) //short form
                    {
                        Bytes=new byte[1];
                        Bytes[0]=(byte)value;
                    }
                    else //long form
                    {
                        //see how many bytes we need to store this length
                        byte bytesNeeded;
                        if (value<(ulong)256) bytesNeeded=1;
                        else if (value<(ulong)256*256) bytesNeeded=2;
                        else if (value<(ulong)256*256*256) bytesNeeded=3;
                        else if (value<(ulong)256*256*256*256) bytesNeeded=4;
                        else if (value<(ulong)256*256*256*256*256) bytesNeeded=5;
                        else if (value<(ulong)256*256*256*256*256*256) bytesNeeded=6;
                        else if (value<(ulong)256*256*256*256*256*256*256) bytesNeeded=7;
                        else bytesNeeded=8;

                        //set up the length-of-length octet
                        Bytes=new byte[1+bytesNeeded];
                        Bytes[0]=(byte)(0x80 | bytesNeeded);

                        //store the length as a series of octets
                        ulong accum=value;
                        for (int i=bytesNeeded+1-1; i>=1; --i)
                        {
                            Bytes[i]=(byte)(accum&0xff);
                            accum>>=8;
                        }
                    }
                }

                get
                {
                    //see if it's in short form
                    if ((Bytes[0]&0x80)==0)
                    {
                        if (Bytes.Length>1)
                        {
                            throw new CannotRepresentValueException();
                        }

                        return Bytes[0];
                    }

                    //it's in long form, so see how many octets we have
                    byte bytesNeeded=(byte)(Bytes[0]&0x7f);
                    if (Bytes.Length-1!=bytesNeeded || bytesNeeded>8)
                    {
                        throw new CannotRepresentValueException();
                    }

                    //read the octets out
                    ulong accum=0;
                    for (int i=1; i<Bytes.Length; ++i)
                    {
                        accum<<=8;
                        accum|=Bytes[i];
                    }

                    return accum;
                }
            }

            //we override this to only pull what we need, since it makes up a part of a Tag-Length-Value container
            public override long SetBytes(byte []data, long dataStart, long dataLength)
            {
                if (data[dataStart]<0x80) //it's in short form
                {
                    Bytes=new byte[1];
                    Bytes[0]=data[dataStart];
                    return 1;
                }
                else //it's in long form
                {
                    byte bytesTotal=(byte)((data[dataStart]&0x7f)+1);
                    Bytes=new byte[bytesTotal];
                    System.Array.Copy(data, dataStart, Bytes, 0, bytesTotal);
                    return bytesTotal;
                }
            }

            //if enabled, we'll throw if they try to encode a length comprised of no bytes, as this is totally invalid but a common mistake
            #if DEBUG_BAD_LENGTHS
            public override void AppendBytesTo(MemoryStream byteList)
            {
                if (Bytes.Length==0)
                {
                    throw new AsnException("DEBUG_BAD_LENGTHS: Attempt to encode a length made up of 0 bytes.");
                }

                byteList.Write(Bytes, 0, Bytes.Length);
            }
            #endif

            public override string ToString()
            {
                if (Bytes==null || Bytes.Length==0)
                {
                    return "";
                }

                return UInt64.ToString();
            }
        };

        /// <summary> A true-or-false value. (0x01) </summary>
        public class Boolean: AsnBytes, IGetDefaultTag
        {
            public bool Bool
            {
                set
                {
                    Bytes=new byte[1];
                    Bytes[0]=(byte)(value?0xff:0x00);
                }

                get
                {
                    return Bytes[0]!=0;
                }
            }

            public override string ToString()
            {
                return (Bool?"True":"False");
            }

            //IGetDefaultTag
            public Raw.Tag GetDefaultTag()
            {
                return new Raw.Tag(0x01, TagClasses.Universal, false);
            }
        };

        /// <summary> An arbitrary-length two's compliment integer for storing positive or negative values. (0x02) </summary>
        public class Integer: AsnBytes, IGetDefaultTag
        {
            public long Int64
            {
                set
                {
                    //figure out how many redundant bytes are prefixed to the value
                    int redundantBytes=0;
                    if (value<0)
                    {
                        for (int i=7; i>=1; --i)
                        {
                            if ((((value>>(i*8))&0xff)==0xff) && (((value>>((i-1)*8))&0x80)==0x80))
                            {
                                ++redundantBytes;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    else //value>0
                    {
                        for (int i=7; i>=1; --i)
                        {
                            if (((value&((long)0xff<<(i*8))) == 0) && ((value&((long)0x80<<(i-1)*8)) == 0))
                            {
                                ++redundantBytes;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }

                    //store the relevent bytes
                    int usefulBytes=8-redundantBytes;
                    Bytes=new byte[usefulBytes];
                    for (int i=0; i<usefulBytes; ++i)
                    {
                        Bytes[i]=(byte)(value>>((usefulBytes-i-1)*8));
                    }
                }

                get
                {
                    if (Bytes.Length>8)
                    {
                        throw new CannotRepresentValueException();
                    }

                    //copy what we have
                    long accum=0;
                    for (int i=0; i<Bytes.Length; ++i)
                    {
                        accum<<=8;
                        accum|=Bytes[i];
                    }

                    //sign-extend if needed
                    if ((Bytes[0]&0x80)!=0)
                    {
                        for (int i=Bytes.Length; i<8; ++i)
                        {
                            accum|=(long)0xff<<(i*8);
                        }
                    }

                    return accum;
                }
            }

            public override string ToString()
            {
                if (Bytes==null || Bytes.Length==0)
                {
                    return "";
                }

                return Int64.ToString();
            }

            //IGetDefaultTag
            public Raw.Tag GetDefaultTag()
            {
                return new Raw.Tag(0x02, TagClasses.Universal, false);
            }
        };

        /// <summary> A string of 8-bit binary values. (0x04) </summary>
        public class OctetString: AsnBytes, IGetDefaultTag
        {
            //IGetDefaultTag
            public Raw.Tag GetDefaultTag()
            {
                return new Raw.Tag(0x04, TagClasses.Universal, false);
            }
        };

        /// <summary> A string of bits.  The first octet contains the count of the number of unused bits in the last octet. (0x03) </summary>
        public class BitString: AsnBytes, IGetDefaultTag
        {
            //number of bits actually stored
            public ulong Count
            {
                get
                {
                    if (Bytes.Length==0)
                    {
                        return 0;
                    }

                    return ((ulong)Bytes.LongLength-1)*8 - Bytes[0];
                }

                set
                {
                    if (Count!=value)
                    {
                        int bytesNeeded=(int)(value/8);
                        int spareBits=(int)(8-value%8);
                        if (spareBits==8)
                        {
                            spareBits=0;
                        }
                        if (spareBits>0)
                        {
                            ++bytesNeeded;
                        }

                        System.Array.Resize(ref Bytes, bytesNeeded+1);
                        Bytes[0]=(byte)spareBits;
                    }
                }
            }

            //retrieves a specific bit number
            public bool GetBit(ulong bitNumber)
            {
                int byteInd=(int)(1+bitNumber/8);
                int bitInd=(int)(7-bitNumber%8);

                return (Bytes[byteInd]&(1<<bitInd)) != 0;
            }

            //sets a specific bit number on or off
            public void SetBit(ulong bitNumber, bool value)
            {
                int byteInd=(int)(1+bitNumber/8);
                int bitInd=(int)(7-bitNumber%8);

                if (value)
                {
                    Bytes[byteInd]|=(byte)(1<<bitInd);
                }
                else
                {
                    Bytes[byteInd]&=(byte)~(1<<bitInd);
                }
            }

            //Get or set from a series of 1's and 0's.
            public string String
            {
                get
                {
                    if (Bytes.LongLength==0)
                    {
                        return "EmptyBitString";
                    }

                    ulong count=Count;
                    if (count>((ulong)Bytes.LongLength-1)*8) //if it's not a valid bitstring, default to byte representation
                    {
                        return "InvalidBitString("+base.ToString()+")";
                    }

                    string s="";
                    for (ulong i=0; i<count; ++i)
                    {
                        s+=GetBit(i)?"1":"0";
                    }
                    return s;
                }

                set
                {
                    Count=(ulong)value.Length;
                    for (int i=0; i<value.Length; ++i)
                    {
                        if (value[i]=='0')
                        {
                            SetBit((ulong)i, false);
                        }
                        else if (value[i]=='1')
                        {
                            SetBit((ulong)i, true);
                        }
                        else
                        {
                            throw new CannotRepresentValueException();
                        }
                    }
                }
            }

            public override string ToString()
            {
                return String;
            }

            //IGetDefaultTag
            public Raw.Tag GetDefaultTag()
            {
                return new Raw.Tag(0x03, TagClasses.Universal, false);
            }
        };

        /// <summary> A general string with 8-bit characters.  TODO: Control characters? (0x1B) </summary>
        public class GeneralString: AsnBytes, IGetDefaultTag
        {
            public string String
            {
                get
                {
                    return ServerTestFramework.Utilities.ByteEncoding.Instance.GetString(Bytes);
                }

                set
                {
                    Bytes=ServerTestFramework.Utilities.ByteEncoding.Instance.GetBytes(value);
                }
            }

            public GeneralString()
            {
                Bytes=new byte[0];
            }

            public override string ToString()
            {
                return String.Replace("\0", "");
            }

            //IGetDefaultTag
            public Raw.Tag GetDefaultTag()
            {
                return new Raw.Tag(0x1B, TagClasses.Universal, false);
            }
        };

        /// <summary> Represents a date and time. (0x18) </summary>
        public class GeneralizedTime: GeneralString
        {
            public System.DateTime DateTime
            {
                get
                {
                    string s=String;
                    if (s.EndsWith("Z"))
                    {
                        s=s.Substring(0, s.Length-1); //strip the Z
                    }

                    if (s.Length<14 || (s.Length>=16 && s[15]!='.'))
                    {
                        throw new CannotRepresentValueException();
                    }

                    int year=int.Parse(s.Substring(0,4));
                    int month=int.Parse(s.Substring(4,2));
                    int day=int.Parse(s.Substring(6,2));
                    int hour=int.Parse(s.Substring(8,2));
                    int minute=int.Parse(s.Substring(10,2));
                    int second=int.Parse(s.Substring(12,2));
                    double subsecond=0;
                    if (s.Length>14)
                    {
                        subsecond=double.Parse(s.Substring(14));
                    }

                    return new System.DateTime(year, month, day, hour, minute, second, (int)(subsecond*1000));
                }

                set
                {
                    //format is YYYYMMDDHHMMSS.sZ, with the .s portion (an arbitrary number of digits for the fractional second) optional
                    string s="";
                    s+=string.Format("{0:D4}", value.Year);
                    s+=string.Format("{0:D2}", value.Month);
                    s+=string.Format("{0:D2}", value.Day);
                    s+=string.Format("{0:D2}", value.Hour);
                    s+=string.Format("{0:D2}", value.Minute);
                    s+=string.Format("{0:D2}", value.Second);
                    if (value.Millisecond>0)
                    {
                        s+="."+value.Second;
                    }
                    s+="Z";
                    String=s;
                }
            }

            public override string ToString()
            {
                return String;
            }

            //IGetDefaultTag
            public new Raw.Tag GetDefaultTag()
            {
                return new Raw.Tag(0x18, TagClasses.Universal, false);
            }
        };

        public class Oid : AsnBytes, IGetDefaultTag
        {
            public System.Security.Cryptography.Oid GetOid ()
            {
                return new System.Security.Cryptography.Oid(ToString());
            }

            public override string ToString ()
            {
                if (Bytes == null || Bytes.Length == 0)
                {
                    return "";
                }

                System.Text.StringBuilder ans = new System.Text.StringBuilder();

                VariableLengthPositiveInteger vlint = new VariableLengthPositiveInteger();
                int pos = 0;
                int len = Bytes.Length;

                while (len > 0)
                {
                    long vlintLength = vlint.SetBytes(Bytes, pos, len);
                    ulong val = vlint.UInt64;

                    if (pos == 0)
                    {
                        if (val < 40)
                        {
                            ans.Append('0');
                        }
                        else if (val < 80)
                        {
                            ans.Append('1');
                            val -= 40;
                        }
                        else
                        {
                            ans.Append('2');
                            val -= 80;
                        }
                    }

                    ans.Append('.');
                    ans.Append(val);

                    pos += (int)vlintLength;
                    len -= (int)vlintLength;
                }

                return ans.ToString();
            }

            //IGetDefaultTag
            public Raw.Tag GetDefaultTag ()
            {
                return new Raw.Tag(0x06, TagClasses.Universal, false);
            }
        }
    }; //class Raw

    /// <summary> Basic ASN encodings that are made up of either multiple or nested ASN types. </summary>
    public class Compound
    {
        /// <summary> A Tag-Length-Value.  This is the basis for most ASN encoding.  Note that the value itself might be another TagLengthValue, or some other ASN type. </summary>
        public class TagLengthValue: AsnValueBase
        {
            public Raw.Tag Tag=new Raw.Tag();
            public Raw.Length Length=new Raw.Length();
            public AsnValueBase Value=null;

            public override void AppendBytesTo(MemoryStream byteList)
            {
                if (Tag!=null)
                {
                    Tag.AppendBytesTo(byteList);
                }
                if (Length!=null)
                {
                    Length.AppendBytesTo(byteList);
                }
                if (Value!=null)
                {
                    Value.AppendBytesTo(byteList);
                }
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                long len=0;
                if (Value!=null)
                {
                    if (updateNestedStructures)
                    {
                        len=Value.ProcessLengths(updateLengthFields, updateNestedStructures);
                    }
                    else
                    {
                        len=Value.GetLength();
                    }

                    if (updateLengthFields)
                    {
                        Length.UInt64=(ulong)len;
                    }
                }
                else if (updateLengthFields)
                {
                    Length.UInt64=0;
                }

                if (Tag!=null)
                {
                    len+=Tag.GetLength();
                }

                if (Length!=null)
                {
                    len+=Length.GetLength();
                }
                return len;
            }

            public override long SetBytes(byte []data, long dataStart, long dataLength)
            {
                long tagLength=0;
                long lengthLength=0;
                long valueLength=0;
                long describedValueLength=0;

                //parse tag, length, and value
                try
                {
                    tagLength=Tag.SetBytes(data, dataStart, dataLength);

                    lengthLength=Length.SetBytes(data, dataStart+tagLength, dataLength-tagLength);

                    describedValueLength=(long)Length.UInt64;
                    Value=AsnValueParser.ParseTagValue(Tag, data, dataStart+tagLength+lengthLength, describedValueLength, out valueLength);
                }
                catch (System.Exception e)
                {
                    throw new AsnException("Exception parsing TagLengthValue with Tag("+(Tag==null?"null":Tag.ToString())+")", e);
                }

                //verify and return
                if (describedValueLength!=valueLength)
                {
                    //todo: investigate what ASN keyword this corresponds to.  From looking at the bytes it should obviously be a sequence even though its not contained in a sequence tag, so make it a sequence.
                    //todo: this is the simplest implementation but causes the first element of the sequence to be re-parsed.  We should use what we already parsed instead.
                    Sequence seq=new Sequence();
                    seq.SetBytes(data, dataStart+tagLength+lengthLength, describedValueLength);
                    Value=seq;
                }

                return tagLength+lengthLength+describedValueLength;
            }

            public void SetFrom(TagLengthValue tlv)
            {
                Tag=tlv.Tag;
                Length=tlv.Length;
                Value=tlv.Value;
            }

            public override string ToString()
            {
                return "Tag("+Tag+") Length("+Length+") Value("+Value+")";
            }
        };

        /// <summary> A typed version of the generic TagLengthValue.  Value and Tag are initally set a new instance and that instance's default tag. </summary>
        public class TagLengthValue<ValueType>: TagLengthValue where ValueType: AsnValueBase, IGetDefaultTag, new()
        {
            public new ValueType Value
            {
                get { return (ValueType)base.Value; }
                set { base.Value=value; }
            }

            public TagLengthValue()
            {
                Value=new ValueType();
                Tag=Value.GetDefaultTag();
            }
        };

        /// <summary> This is a TagLengthValue contained within another Tag-Length pair, which is how explicit tagging is done. </summary>
        public class ExplicitTagLengthValue: AsnValueBase
        {
            public Raw.Tag ExplicitTag
            {
                get { return outterTLV.Tag; }
                set { outterTLV.Tag=value; }
            }

            public Raw.Length ExplicitLength
            {
                get { return outterTLV.Length; }
                set { outterTLV.Length=value; }
            }

            public Raw.Tag ValueTag
            {
                get { return innerTLV.Tag; }
                set { innerTLV.Tag=value; }
            }

            public Raw.Length ValueLength
            {
                get { return innerTLV.Length; }
                set { innerTLV.Length=value; }
            }

            public AsnValueBase Value
            {
                get { return innerTLV.Value; }
                set { innerTLV.Value=value; }
            }

            public ExplicitTagLengthValue()
            {
                outterTLV.Value=innerTLV;
            }

            public override void AppendBytesTo(MemoryStream byteList)
            {
                outterTLV.AppendBytesTo(byteList);
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                return outterTLV.ProcessLengths(updateLengthFields, updateNestedStructures);
            }

            public override string ToString()
            {
                return "ExplicitTag("+ExplicitTag+") ExplicitLength("+ExplicitLength+") ValueTag("+ValueTag+") ValueLength("+ValueLength+") Value("+Value+")";
            }

            public TagLengthValue GetExplicitTagLengthValue()
            {
                return outterTLV;
            }

            public TagLengthValue GetValueTagLengthValue()
            {
                return innerTLV;
            }

            public void SetValueTagLengthValue(TagLengthValue tlv)
            {
                innerTLV=tlv;
                outterTLV.Value=innerTLV;
            }

            public void SetFrom(ExplicitTagLengthValue etlv)
            {
                outterTLV=etlv.GetExplicitTagLengthValue();
                innerTLV=etlv.GetValueTagLengthValue();
                outterTLV.Value=innerTLV;
            }

            //the nested tag-length-values
            private TagLengthValue outterTLV=new TagLengthValue();
            private TagLengthValue innerTLV=new TagLengthValue();
        };

        /// <summary> A sequence or sequence of. (0x10) </summary>
        public class Sequence: AsnValueBase, IGetDefaultTag
        {
            public AsnValueBase []Values=new AsnValueBase[0]; //normally these are always each a TLV

            public override void AppendBytesTo(MemoryStream byteList)
            {
                foreach (AsnValueBase value in Values)
                {
                    if (value!=null)
                    {
                        value.AppendBytesTo(byteList);
                    }
                }
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                long len=0;
                foreach (AsnValueBase value in Values)
                {
                    if (value!=null)
                    {
                        if (updateNestedStructures)
                        {
                            len+=value.ProcessLengths(updateLengthFields, updateNestedStructures);
                        }
                        else
                        {
                            len+=value.GetLength();
                        }
                    }
                }
                return len;
            }

            public override long SetBytes(byte []data, long dataStart, long dataLength)
            {
                 System.Collections.Generic.List<AsnValueBase> list=new System.Collections.Generic.List<AsnValueBase>();
                 long totalLength=0;

                 while (totalLength<dataLength)
                 {
                    try
                    {
                        long bytesUsed=0;
                        list.Add(AsnValueParser.Parse(data, dataStart+totalLength, dataLength-totalLength, out bytesUsed));
                        totalLength+=bytesUsed;
                    }
                    catch (System.Exception e)
                    {
                        throw new AsnException("Exception parsing Sequence index "+list.Count, e);
                    }
                 }

                 Values=list.ToArray();
                 return totalLength;
            }

            public override string ToString()
            {
                if (Values==null) return "Empty Sequence";
                return "Sequence of "+Values.Length+" values";
            }

            //IGetDefaultTag
            public Raw.Tag GetDefaultTag()
            {
                return new Raw.Tag(0x10, TagClasses.Universal, true);
            }
        };

        /// <summary> A string of 8-bit binary values, which are taken from a nested asn value. (0x04) </summary>
        public class OctetString: AsnValueBase, IGetDefaultTag
        {
            public AsnValueBase Value=null;

            public override void AppendBytesTo(MemoryStream byteList)
            {
                if (Value!=null)
                {
                    Value.AppendBytesTo(byteList);
                }
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                long len=0;
                if (Value!=null)
                {
                    if (updateNestedStructures)
                    {
                        len=Value.ProcessLengths(updateLengthFields, updateNestedStructures);
                    }
                    else
                    {
                        len=Value.GetLength();
                    }
                }
                return len;
            }

            public override long SetBytes(byte []data, long dataStart, long dataLength)
            {
                 System.Collections.Generic.List<AsnValueBase> list=new System.Collections.Generic.List<AsnValueBase>();
                 long usedLength=0;

                try
                {
                    Value=AsnValueParser.Parse(data, dataStart, dataLength, out usedLength);
                }
                catch (System.Exception e)
                {
                    throw new AsnException("Exception parsing contents of Compound.OctetString", e);
                }

                return usedLength;
            }

            public override string ToString()
            {
                return "OctetString("+Value+")";
            }

            //IGetDefaultTag
            public Raw.Tag GetDefaultTag()
            {
                return new Raw.Tag(0x04, TagClasses.Universal, true);
            }
        };

        /// <summary> Processes asn TLVs or universal tag values. </summary>
        public class AsnValueParser
        {
            /// <summary> Controls whether the parser will throw when parsing bad ASN or whether it instead places a BadAsnBytes structure into the tree. </summary>
            public static bool ThrowOnBadAsn=true;

            /// <summary> Controls whether a TagLengthValue of a TagLengthValue gets converted to an ExplicitTagLengthValue. </summary>
            public static bool ConvertExplicitTags=true;

            /// <summary> Processes an asn tag-length-value into the appropriate asn structure (including all nested structures). </summary>
            public static AsnValueBase Parse(byte []data, long dataStart, long dataLength, out long dataLengthUsed)
            {
                //parse it as a simple tlv first
                TagLengthValue outterTlv=new TagLengthValue();

                try
                {
                    dataLengthUsed=outterTlv.SetBytes(data, dataStart, dataLength);
                }
                catch (System.Exception e)
                {
                    if (ThrowOnBadAsn)
                    {
                        throw;
                    }

                    dataLengthUsed=dataLength; //we have to set this, so pretend we consumed it all
                    return new BadAsnBytes(e, data, dataStart, dataLength);
                }

                //if the value is a tlv itself, then we will convert it to an ExplicitTagLengthValue instead
                if (outterTlv.Value!=null && ConvertExplicitTags)
                {
                    TagLengthValue innerTlv=outterTlv.Value as TagLengthValue;
                    if (innerTlv!=null)
                    {
                        ExplicitTagLengthValue expTlv=new ExplicitTagLengthValue();
                        expTlv.ExplicitTag=outterTlv.Tag;
                        expTlv.ExplicitLength=outterTlv.Length;
                        expTlv.ValueTag=innerTlv.Tag;
                        expTlv.ValueLength=innerTlv.Length;
                        expTlv.Value=innerTlv.Value;
                        return expTlv;
                    }
                }

                return outterTlv;
            }

            /// <summary> Creates as asn structure for a specific tag type and parses data into it. </summary>
            public static AsnValueBase ParseTagValue(Raw.Tag tag, byte []data, long dataStart, long dataLength, out long dataLengthUsed)
            {
                try
                {
                    //see if we have a private or a nested type inside
                    if (tag.Class!=TagClasses.Universal)
                    {
                        if (tag.Constructed) //other asn data is nested inside
                        {
                            TagLengthValue innerTlv=new TagLengthValue();
                            dataLengthUsed=innerTlv.SetBytes(data, dataStart, dataLength);
                            return innerTlv;
                        }
                        else //some sort of private data type?  represent it with just its bytes
                        {
                            AsnBytes unknown=new AsnBytes();
                            dataLengthUsed=unknown.SetBytes(data, dataStart, dataLength);
                            return unknown;
                        }
                    }

                    //parse it to one of the universal tag types
                    AsnValueBase value;
                    int tagNumber=(int)tag.Number;
                    switch (tagNumber)
                    {
                        case 0x01: //boolean (1)
                            value=new Raw.Boolean();
                            break;
                        case 0x02: //integer (2)
                            value=new Raw.Integer();
                            break;
                        case 0x03: //bit string (3)
                            value=new Raw.BitString();
                            break;
                        case 0x04: //octet string (4)
                        {
                            if (tag.Constructed)
                            {
                                value=new Compound.OctetString();
                            }
                            else
                            {
                                value=new Raw.OctetString();
                            }
                            break;
                        }
                        case 0x06: // oid (6)
                            value = new Raw.Oid();
                            break;
                        case 0x10: //sequence (16)
                        case 0x11: //set (17)
                            value=new Compound.Sequence();
                            break;
                        case 0x18: //generalized time (24)
                            value=new Raw.GeneralizedTime();
                            break;
                        case 0x1b: //general string (27)
                            value=new Raw.GeneralString();
                            break;
                        default:
                            throw new AsnException("Parsing of universal tag "+tagNumber+" is not implemented.");
                    };

                    dataLengthUsed=value.SetBytes(data, dataStart, dataLength);
                    return value;
                }
                catch (System.Exception e)
                {
                    if (ThrowOnBadAsn)
                    {
                        throw;
                    }

                    dataLengthUsed=dataLength; //we have to set this, so pretend we consumed it all
                    return new BadAsnBytes(e, data, dataStart, dataLength);
                }
            }
        };
    }; //class Compound
} //namespace ServerTestFramework.LiveService.Auth.Asn
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\AuthData.cs ===
using System;
using ServerTestFramework.LiveService.Auth.Asn;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;

namespace ServerTestFramework.LiveService.Auth
{
    public class AuthDataBuilder
    {
        public static Kerberos.CommonTypeDataSequence CreateFrom(Kerberos.CommonTypeDataSequence cdts)
        {
            long type = cdts.Type.Int64;

            switch(type)
            {
                case 1:
                    return WindowsPacAuthData.Create(cdts);
                case 200:
                    return new Xbox2XkdcAuthData(cdts);
                case 300:
                    return new XenonXkdcAuthData(cdts);
                case 400:
                    return new Xenon2XkdcAuthData(cdts);
            }

            // If we don't get a valid type from sequence, just return the same thing
            return cdts;
        }
    }

    /// <summary> Windows server PAC Authdata.  This is used by both askdc and xkdc. </summary>
    public class WindowsPacAuthData: Kerberos.CommonTypeDataSequence
    {
        public const uint CT_Unknown=0;
        public const uint CT_Password=1;
        public const uint CT_RandomKey=2;
        public const uint CT_Certificate=3;
        public const uint CT_PIN=4;
        public const uint CT_SID=5;
        public const uint CT_RawPassport=6;
        public const uint CT_EncryptedPassport=7;

        public int ADType; //taken from the inner type data pair

        public struct PacTypeStructure
        {
            public uint BufferCount; //number of PacInfoBufferStructure
            public uint Version;     //currently always 0

            public byte[] GetBytes()
            {
                byte []blob=new byte[8];
                System.Array.Copy(System.BitConverter.GetBytes(BufferCount), 0, blob, 0, 4);
                System.Array.Copy(System.BitConverter.GetBytes(Version), 0, blob, 4, 4);
                return blob;
            }
        }
        public PacTypeStructure PacType=new PacTypeStructure();

        public struct PacInfoBufferStructure
        {
            public uint Type;        //type of structure
            public uint BufferSize;  //size of structure
            public ulong Offset;     //offset (from the very start of PacTypeStructure) in bytes of the start of the structure

            public byte[] GetBytes()
            {
                byte []blob=new byte[16];
                System.Array.Copy(System.BitConverter.GetBytes(Type), 0, blob, 0, 4);
                System.Array.Copy(System.BitConverter.GetBytes(BufferSize), 0, blob, 4, 4);
                System.Array.Copy(System.BitConverter.GetBytes(Offset), 0, blob, 8, 8);
                return blob;
            }
        }
        public PacInfoBufferStructure []PacInfo;

        //we normally have 1 of these in the old kdc, 0 in the new
        public class IdentityStructure
        {
            public uint  LengthOfIdentity;   //Should be 24.
            public uint  IdentityAttributes; //We set this to 0.
            public uint  IdentityType;       //We only use ID_PUID, or value 0.
            public uint  CredentialIdType;   //We use 2, 6, and 7.
            public ulong Puid;

            public IdentityStructure() {}
            public IdentityStructure(ulong puid)
            {
                LengthOfIdentity=24;
                IdentityAttributes=0;
                IdentityType=0;
                CredentialIdType=2;
                Puid=puid;
            }

            public byte[] GetBytes()
            {
                byte []blob=new byte[24];
                System.Array.Copy(System.BitConverter.GetBytes(LengthOfIdentity), 0, blob, 0, 4);
                System.Array.Copy(System.BitConverter.GetBytes(IdentityAttributes), 0, blob, 4, 4);
                System.Array.Copy(System.BitConverter.GetBytes(IdentityType), 0, blob, 8, 4);
                System.Array.Copy(System.BitConverter.GetBytes(CredentialIdType), 0, blob, 12, 4);
                System.Array.Copy(System.BitConverter.GetBytes(Puid), 0, blob, 16, 8);
                return blob;
            }

            public override string ToString()
            {
                return "Identity(Puid=0x"+ServerTestFramework.Utilities.Hexer.tohex(Puid)+" Attributes="+IdentityAttributes+" Type="+IdentityType+" CredentialId="+CredentialIdType+")";
            }
        }
        public IdentityStructure Identity;

        //we normally have 0-1 of these in the old kdc, 0 in the new
        public class CompoundIdentityStructure
        {
            public ushort NumberOfIdentities;
            public IdentityStructure []Identities;

            public byte[] GetBytes()
            {
                byte []blob=new byte[4+24*Identities.Length];
                System.Array.Copy(System.BitConverter.GetBytes(NumberOfIdentities), 0, blob, 0, 2); //skip 2 bytes
                for (int i=0; i<Identities.Length; ++i)
                {
                    System.Array.Copy(Identities[i].GetBytes(), 0, blob, 4+i*24, 24); //skip 2 bytes
                }
                return blob;
            }
        }
        public CompoundIdentityStructure CompoundIdentity;

        //we normally have 0 of these in the old kdc, 1 in the new
        public class XboxIdentityStructure
        {
            public ulong MachineId;
            public ulong []UserId=new ulong[4];
            public byte MachineIdCredential;
            public byte []UserIdCredential=new byte[4];

            public byte[] GetBytes()
            {
                byte []blob=new byte[45];
                System.Array.Copy(System.BitConverter.GetBytes(MachineId), 0, blob, 0, 8);
                for (int i=0; i<4; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(UserId[i]), 0, blob, 8+i*8, 8);
                }
                blob[40]=MachineIdCredential;
                for (int i=0; i<4; ++i)
                {
                    blob[41+i]=UserIdCredential[i];
                }
                return blob;
            }

            public override string ToString()
            {
                return "XboxIdentity("+
                    "MachineId=0x"+ServerTestFramework.Utilities.Hexer.tohex(MachineId)+" Cred="+MachineIdCredential+", "+
                    "User0Id=0x"+ServerTestFramework.Utilities.Hexer.tohex(UserId[0])+" Cred="+UserIdCredential[0]+", "+
                    "User1Id=0x"+ServerTestFramework.Utilities.Hexer.tohex(UserId[1])+" Cred="+UserIdCredential[1]+", "+
                    "User2Id=0x"+ServerTestFramework.Utilities.Hexer.tohex(UserId[2])+" Cred="+UserIdCredential[2]+", "+
                    "User3Id=0x"+ServerTestFramework.Utilities.Hexer.tohex(UserId[3])+" Cred="+UserIdCredential[3]+
                    ")";
            }
        };

        public XboxIdentityStructure XboxIdentity;

        //we normally have 2 different signatures in the old kdc, 1 in the new
        public class PacSignatureStructure
        {
            public uint SignatureType;
            public byte []Signature;

            public byte[] GetBytes()
            {
                byte []blob=new byte[20];
                System.Array.Copy(System.BitConverter.GetBytes(SignatureType), 0, blob, 0, 4);
                System.Array.Copy(Signature, 0, blob, 4, 16);
                return blob;
            }
        }
        public PacSignatureStructure ServerSignature;
        public PacSignatureStructure PrivServerSignature;

        //This was found in the pc xmacs response ticket, and is a bug (but has long since been fixed, so should never be seen again)
        byte []ValidationSamInfo3Blob;  //supposedly contains an NDR encoded _PAC_NETLOGON_VALIDATION_SAM_INFO3 structure.

        /// <summary> Loads all fields from auth data bytes. </summary>
        public static WindowsPacAuthData Create(Kerberos.CommonTypeDataSequence genericAD)
        {
            WindowsPacAuthData ad=new WindowsPacAuthData();

            //copy to base first
            ad.SetFromAsn(genericAD);

            //The data in there is another CommonTypeDataSequence, which we need to parse out
            long used=0;
            AsnValueBase innerAsn=Compound.AsnValueParser.Parse(ad.Data.Bytes, 0, ad.Data.Bytes.Length, out used);
            Compound.TagLengthValue innerTlv=(Compound.TagLengthValue)innerAsn; //this is actually for an outter sequence of the inner data
            Compound.Sequence innerSeq=(Compound.Sequence)innerTlv.Value;
            Compound.TagLengthValue innerInnerTlv=(Compound.TagLengthValue)innerSeq.Values[0]; //this is the actual CommonTypeDataSequence
            Kerberos.CommonTypeDataSequence innerTypeDataPair=Kerberos.CommonTypeDataSequence.CreateFromAsn<Kerberos.CommonTypeDataSequence>(innerInnerTlv);

            //now we'll interpret the bytes into ourself
            ad.ADType=(int)innerTypeDataPair.Type.Int64;
            byte []data=innerTypeDataPair.Data.Bytes;

            //first grab the PacType structure
            ad.PacType.BufferCount=System.BitConverter.ToUInt32(data, 0);
            ad.PacType.Version=System.BitConverter.ToUInt32(data, 4);

            //now grab the series of PacInfo
            int offset=8;
            ad.PacInfo=new PacInfoBufferStructure[ad.PacType.BufferCount];
            for (int i=0; i<ad.PacType.BufferCount; ++i)
            {
                ad.PacInfo[i]=new PacInfoBufferStructure();
                ad.PacInfo[i].Type=System.BitConverter.ToUInt32(data, offset+0);
                ad.PacInfo[i].BufferSize=System.BitConverter.ToUInt32(data, offset+4);
                ad.PacInfo[i].Offset=System.BitConverter.ToUInt64(data, offset+8);
                offset+=16;
            }

            //now grab the actual meaningful data out
            foreach (PacInfoBufferStructure pib in ad.PacInfo)
            {
                if (pib.Type==88) //'X' - XboxIdentity
                {
                    if (ad.XboxIdentity!=null)
                    {
                        throw new UnexpectedTestResultException("Multiple XboxIdentity structures found in PAC AuthData.");
                    }

                    ServerTestFramework.Utilities.ValueCheck.Test("XboxIdentity Size", 45, pib.BufferSize);

                    ad.XboxIdentity=new XboxIdentityStructure();
                    ad.XboxIdentity.MachineId=System.BitConverter.ToUInt64(data, (int)pib.Offset+0);
                    ad.XboxIdentity.UserId[0]=System.BitConverter.ToUInt64(data, (int)pib.Offset+8);
                    ad.XboxIdentity.UserId[1]=System.BitConverter.ToUInt64(data, (int)pib.Offset+16);
                    ad.XboxIdentity.UserId[2]=System.BitConverter.ToUInt64(data, (int)pib.Offset+24);
                    ad.XboxIdentity.UserId[3]=System.BitConverter.ToUInt64(data, (int)pib.Offset+32);
                    ad.XboxIdentity.MachineIdCredential=data[pib.Offset+40];
                    ad.XboxIdentity.UserIdCredential[0]=data[pib.Offset+41];
                    ad.XboxIdentity.UserIdCredential[1]=data[pib.Offset+42];
                    ad.XboxIdentity.UserIdCredential[2]=data[pib.Offset+43];
                    ad.XboxIdentity.UserIdCredential[3]=data[pib.Offset+44];
                }
                else if (pib.Type==13) //PAC_CLIENT_IDENTITY
                {
                    ad.Identity=ParseIdentity(data, (int)pib.Offset);
                }
                else if (pib.Type==14) //PAC_COMPOUND_IDENTITY
                {
                    ad.CompoundIdentity=new CompoundIdentityStructure();
                    ad.CompoundIdentity.NumberOfIdentities=System.BitConverter.ToUInt16(data, (int)pib.Offset);
                    ad.CompoundIdentity.Identities=new IdentityStructure[ad.CompoundIdentity.NumberOfIdentities];
                    offset=(int)pib.Offset+4; //its 2 bytes, but due sloppy network coding it is padded like a C struct on a 32-bit machine, so it actually consumes 4 bytes
                    for (int i=0; i<ad.CompoundIdentity.NumberOfIdentities; ++i)
                    {
                        ad.CompoundIdentity.Identities[i]=ParseIdentity(data, offset);
                        offset+=(int)ad.CompoundIdentity.Identities[i].LengthOfIdentity;
                    }
                }
                else if (pib.Type==6) //PAC_SERVER_CHECKSUM
                {
                    ad.ServerSignature=new PacSignatureStructure();
                    ad.ServerSignature.SignatureType=System.BitConverter.ToUInt32(data, (int)pib.Offset+0);
                    ad.ServerSignature.Signature=new byte[pib.BufferSize-4];
                    System.Array.Copy(data, (int)pib.Offset+4, ad.ServerSignature.Signature, 0, ad.ServerSignature.Signature.Length);
                }
                else if (pib.Type==7) //PAC_PRIVSVR_CHECKSUM
                {
                    ad.PrivServerSignature=new PacSignatureStructure();
                    ad.PrivServerSignature.SignatureType=System.BitConverter.ToUInt32(data, (int)pib.Offset+0);
                    ad.PrivServerSignature.Signature=new byte[pib.BufferSize-4];
                    System.Array.Copy(data, (int)pib.Offset+4, ad.PrivServerSignature.Signature, 0, ad.PrivServerSignature.Signature.Length);
                }
                else if (pib.Type==1) //PAC_LOGON_INFO
                {
                    ad.ValidationSamInfo3Blob=new byte[pib.BufferSize];
                    System.Array.Copy(data, (int)pib.Offset, ad.ValidationSamInfo3Blob, 0, ad.ValidationSamInfo3Blob.Length);
                }
                else
                {
                    Global.RO.Warn("WindowsPacAuthData.Create: Unsupported pac info type "+pib.Type+" ignored.");
                }
            }

            if (ad.XboxIdentity!=null && (ad.Identity!=null || ad.CompoundIdentity!=null))
            {
                throw new UnexpectedTestResultException("Both XboxIdentity and old PAC Identities should not be present at the same time.");
            }

            return ad;
        }

        //We really should integrate this better with the AsnValueBase so it can be automatically serialized/deserialized like everything else.  We don't have time to do the right thing now, so this is a quick hack to copy the data in this structure back into the base class so it gets picked up when serialized later.
        public void SetupAndCopyToBase()
        {
            //convert the pieces to a blob of bytes
            byte []blob=GetStructBytes();

            //pack the bytes into asn containers and stuff that into the base
            Kerberos.CommonTypeDataSequence innerSeq=new Kerberos.CommonTypeDataSequence();
            innerSeq.Type.Int64=ADType;
            Raw.OctetString blobOs=new Raw.OctetString();
            blobOs.Bytes=blob;
            innerSeq.Data=blobOs;
            innerSeq.RecalculateLengths(true);

            Raw.OctetString outterOs=new Raw.OctetString();
            outterOs.Bytes=innerSeq.GetBytes();

            Compound.TagLengthValue outterTag=new Compound.TagLengthValue();
            outterTag.Tag=(new Compound.Sequence()).GetDefaultTag();
            outterTag.Value=outterOs;
            outterTag.RecalculateLengths(true);

            Raw.OctetString containingOs=new Raw.OctetString();
            containingOs.Bytes=outterTag.GetBytes();
            Data=containingOs;
        }

        //gets the bytes that represent the pac authdata blob (not including the asn container)
        protected byte[] GetStructBytes()
        {
            System.Collections.Generic.List<byte> blob=new System.Collections.Generic.List<byte>();

            blob.AddRange(PacType.GetBytes());

            foreach (PacInfoBufferStructure pi in PacInfo)
            {
                blob.AddRange(pi.GetBytes());
            }

            if (Identity!=null)
            {
                blob.AddRange(Identity.GetBytes());
            }

            if (CompoundIdentity!=null)
            {
                blob.AddRange(CompoundIdentity.GetBytes());
            }

            if (XboxIdentity!=null)
            {
                blob.AddRange(XboxIdentity.GetBytes());
            }

            if (ServerSignature!=null)
            {
                blob.AddRange(ServerSignature.GetBytes());
            }

            if (PrivServerSignature!=null)
            {
                blob.AddRange(PrivServerSignature.GetBytes());
            }

            return blob.ToArray();
        }

        //Recreates PacType and PacInfo and fills them in with valid stuff based on the other fields.  Also recomputes the signatures.
        public void RebuildHeaders()
        {
            //infos (this assumes the structure is ordered 13,14,6,7
            System.Collections.Generic.List<PacInfoBufferStructure> pibsList=new System.Collections.Generic.List<PacInfoBufferStructure>();

            //figure out the start of the actual buffers
            uint offset=0;
            offset+=8; //PacTypeStructure

            if (Identity!=null)
            {
                offset+=16; //PacInfoBufferStructure
            }

            if (CompoundIdentity!=null)
            {
                offset+=16; //PacInfoBufferStructure
            }

            if (XboxIdentity!=null)
            {
                offset+=16; //PacInfoBufferStructure
            }

            if (ServerSignature!=null)
            {
                offset+=16; //PacInfoBufferStructure
            }

            if (PrivServerSignature!=null)
            {
                offset+=16; //PacInfoBufferStructure
            }

            //fill in the info headers
            uint serverSignatureOffset=0, privServerSignatureOffset=0;

            if (Identity!=null)
            {
                PacInfoBufferStructure pibs=new PacInfoBufferStructure();
                pibs.Type=13;
                pibs.Offset=offset;
                pibs.BufferSize=24;
                offset+=24;
                pibsList.Add(pibs);
            }

            if (CompoundIdentity!=null)
            {
                uint bytesUsed=4+(uint)CompoundIdentity.Identities.Length*24;

                PacInfoBufferStructure pibs=new PacInfoBufferStructure();
                pibs.Type=14;
                pibs.Offset=offset;
                pibs.BufferSize=bytesUsed;
                offset+=bytesUsed;
                pibsList.Add(pibs);
            }

            if (XboxIdentity!=null)
            {
                uint bytesUsed=45;

                PacInfoBufferStructure pibs=new PacInfoBufferStructure();
                pibs.Type=88; //'X'
                pibs.Offset=offset;
                pibs.BufferSize=bytesUsed;
                offset+=bytesUsed;
                pibsList.Add(pibs);
            }

            if (ServerSignature!=null)
            {
                PacInfoBufferStructure pibs=new PacInfoBufferStructure();
                pibs.Type=6;
                pibs.Offset=offset;
                serverSignatureOffset=offset;
                pibs.BufferSize=20;
                offset+=20;
                pibsList.Add(pibs);
            }

            if (PrivServerSignature!=null)
            {
                PacInfoBufferStructure pibs=new PacInfoBufferStructure();
                pibs.Type=7;
                pibs.Offset=offset;
                privServerSignatureOffset=offset;
                pibs.BufferSize=20;
                offset+=20;
                pibsList.Add(pibs);
            }

            PacInfo=pibsList.ToArray();

            //type
            PacType=new PacTypeStructure();
            PacType.BufferCount=(uint)PacInfo.Length;
            PacType.Version=0;

            //now recompute the signatures
            byte []blob=GetStructBytes();

            if (privServerSignatureOffset!=0)
            {
                //zero out the existing signature in the blob so we don't checksum an old checksum
                System.Array.Copy(new byte[16], 0, blob, privServerSignatureOffset+4, 16);

                //it's all a lie.  contrary to what all the higher level kdc code says, it's not encrypted with a key or salt at all, it's just a md5 hash
                /*uint cksumType=7;
                uint salt=KERB_NON_KERB_CKSUM_SALT;  //17: KdcCrypo.NON_CKSUM_SALT
                byte []key=rgKey_XboxCom_Testnet;
                byte []checksum;
                m_pIKerbCrypt->Checksum(..., out checksum);  //CKerbCryptDll::Checksum(  //pcsChecksum->Sum   //md5Sum
                PrivServerSignature.Signature=checksum;*/

                PrivServerSignature.Signature=System.Security.Cryptography.MD5.Create().ComputeHash(blob);
            }

            if (serverSignatureOffset!=0)
            {
                //zero out the existing signature in the blob so we don't checksum an old checksum
                System.Array.Copy(new byte[16], 0, blob, serverSignatureOffset+4, 16);

                //plain old md5
                ServerSignature.Signature=System.Security.Cryptography.MD5.Create().ComputeHash(blob);
            }
        }

        private static IdentityStructure ParseIdentity(byte []data, int offset)
        {
            IdentityStructure id=new IdentityStructure();
            id.LengthOfIdentity=System.BitConverter.ToUInt32(data, offset+0);
            id.IdentityAttributes=System.BitConverter.ToUInt32(data, offset+4);
            id.IdentityType=System.BitConverter.ToUInt32(data, offset+8);
            id.CredentialIdType=System.BitConverter.ToUInt32(data, offset+12);
            if (id.IdentityType!=0) //we only know puid
            {
                Global.RO.Warn("WindowsPacAuthData.ParseIdentity: Non-puid identity is not supported.");
            }
            else
            {
                id.Puid=System.BitConverter.ToUInt64(data, offset+16);
            }

            return id;
        }

        public uint FindPuidCredentialType(ulong puid)
        {
            if (XboxIdentity!=null)
            {
                if (XboxIdentity.MachineId==puid)
                {
                    return XboxIdentity.MachineIdCredential;
                }

                for (int u=0; u<4; ++u)
                {
                    if (XboxIdentity.UserId[u]==puid)
                    {
                        return XboxIdentity.UserIdCredential[u];
                    }
                }
            }
            else
            {
                if (Identity!=null && Identity.Puid==puid)
                {
                    return Identity.CredentialIdType;
                }

                if (CompoundIdentity!=null)
                {
                    foreach (IdentityStructure iden in CompoundIdentity.Identities)
                    {
                        if (iden.Puid==puid)
                        {
                            return iden.CredentialIdType;
                        }
                    }
                }
            }

            throw new UnexpectedTestResultException("Unable to find puid in authdata: 0x"+ServerTestFramework.Utilities.Hexer.tohex(puid));
        }

        public override string ToString()
        {
            string s="WindowsPacAD - ASN Type "+Type+":";
            s+=" ADType("+ADType+")";

            if (Identity!=null)
            {
                s+=" Single"+Identity.ToString();
            }

            if (CompoundIdentity!=null)
            {
                s+=" Compound(";
                bool first=true;
                foreach (IdentityStructure id in CompoundIdentity.Identities)
                {
                    if (!first)
                    {
                        s+=" ";
                    }
                    first=false;

                    s+=id.ToString();
                }
                s+=")";
            }

            if (XboxIdentity!=null)
            {
                s+=" "+XboxIdentity.ToString();
            }

            //don't care about the signatures, so only indicating if they are present
            if (ServerSignature!=null)
            {
                s+=" ServerSignature(Type "+ServerSignature.SignatureType+", "+ServerSignature.Signature.Length+" bytes)";
            }
            if (PrivServerSignature!=null)
            {
                s+=" PrivServerSignature(Type "+PrivServerSignature.SignatureType+", "+PrivServerSignature.Signature.Length+" bytes)";
            }

            //the sam3 info blob
            if (ValidationSamInfo3Blob!=null)
            {
                s+=" ValidationSamInfo3Blob(0x"+ServerTestFramework.Utilities.Hexer.tohex(ValidationSamInfo3Blob)+")";
            }

            return s;
        }
    }

    /// <summary>
    /// Represents a user information object contained in an authdata struct
    /// </summary>
    public class Xuid
    {
        public ulong UserID;
        public uint UserFlags;

        public Xuid(ulong userId, uint userFlags)
        {
            this.UserID = userId;
            this.UserFlags = userFlags;
        }

        public Xuid(byte[] bytes, int offset)
        {
            UserID = System.BitConverter.ToUInt64(bytes, offset + 0);
            UserFlags = System.BitConverter.ToUInt32(bytes, offset + 16);
        }

        public override string ToString()
        {
            return "UserID=0x" + ServerTestFramework.Utilities.Hexer.tohex(UserID) + " UserFlags=0x" + ServerTestFramework.Utilities.Hexer.tohex(UserFlags);
        }
    }

    /// <summary>
    /// Base authdata clrass for all Xbox authdata structures
    /// </summary>
    public abstract class XboxAuthDataBase : Kerberos.CommonTypeDataSequence
    {
        /// <summary>
        /// All authdata structs coming back from the XKDC have the signature prepended
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] ServerSignature; // 16 bytes

        private ushort authDataVersion;
        private ushort authDataSize;
        private ushort clientMajorVersion;
        private ushort clientMinorVersion;
        private ushort clientBuildNumber;
        private ushort clientQFENumber;

        public virtual ushort AuthDataVersion { get { return authDataVersion; } set { authDataVersion = value; }}
        public virtual ushort AuthDataSize { get { return authDataSize; } set { authDataSize = value; } }
        public virtual ushort ClientMajorVersion { get { return clientMajorVersion; } set { clientMajorVersion = value; } }
        public virtual ushort ClientMinorVersion { get { return clientMinorVersion; } set { clientMinorVersion = value; } }
        public virtual ushort ClientBuildNumber { get { return clientBuildNumber; } set { clientBuildNumber = value; } }
        public virtual ushort ClientQFENumber { get { return clientQFENumber; } set { clientQFENumber = value; } }

        // The following members are available in all versions of authdata
        public abstract ulong XboxID { get; set; }
        public abstract uint TitleID { get; set; }
        public abstract uint TitleVersion { get; set; }
        public abstract uint TitleRegion { get; set; }
        public abstract byte[] Key { get; set; }

        /// <summary>
        /// Get information about a specific user
        /// </summary>
        /// <param name="userIndex">The index of the user to lookup</param>
        /// <returns>The Xuid (user id and flags) of the specified user</returns>
        public abstract Xuid GetUser(uint userIndex);
        /// <summary>
        /// Get the trust factor of a specific user
        /// </summary>
        /// <param name="userIndex">The index of the user to lookup</param>
        /// <returns>A value between 0.0 and 1.0 representing the trust factor of the specified user</returns>
        public abstract float GetUserTrustFactor(uint userIndex);

        /// <summary>
        /// Indicates the number of services of a specific type contained in the authdata
        /// </summary>
        public abstract uint ServiceCount { get; }
        /// <summary>
        /// Determines if the authdata grants a specific service
        /// </summary>
        /// <param name="serviceId">The id of the service to check for</param>
        /// <returns>True if the authdata grants the given service, false otherwise.</returns>
        public abstract bool HasService(uint serviceId);
        /// <summary>
        /// Add a grant for the given service to the authdata
        /// </summary>
        /// <param name="serviceId">The id of the service to grant</param>
        public abstract void AddService(uint serviceId);
        /// <summary>
        /// Removes a grant for a given service from the authdata
        /// </summary>
        /// <param name="serviceId">The id of the service to revoke</param>
        public abstract void RemoveService(uint serviceId);
        /// <summary>
        /// Allows removal of a service at a specific position in the authdata.
        /// Depending on the authdata type this will have a different effect
        /// </summary>
        /// <param name="index">The index of the service to revoke</param>
        public abstract void RemoveServiceAt(uint index);

        /// <summary> Retrieves a list of byte services that are present. </summary>
        public abstract uint[] GetByteServices();

        /// <summary> Retrieves a list of dword services that are present. </summary>
        public abstract uint[] GetDwordServices();

        /// <summary>
        /// Get an alternate title id from the authdata
        /// </summary>
        /// <param name="index">The index to check</param>
        /// <returns>The alternate title id at the given index</returns>
        public abstract uint GetAltTitleId(uint index);

        /// <summary>
        /// Create an empty XboxAuthDataBase structure
        /// </summary>
        public XboxAuthDataBase() { }

        /// <summary>
        /// Create an XboxAuthDataBase structure and populate it from 
        /// the provided ASN data
        /// </summary>
        /// <param name="cdts">The ASN data to create the structure from</param>
        public XboxAuthDataBase(Kerberos.CommonTypeDataSequence ctds)
        {
            //copy to base first
            SetFromAsn(ctds);

            System.IO.BinaryReader reader=new System.IO.BinaryReader(new System.IO.MemoryStream(ctds.Data.Bytes));
            ReadFrom(reader);
        }

        /// <summary>
        /// Override in inheriting classes to read raw data from the encoded 
        /// structure into the version specific authdata fields
        /// </summary>
        /// <param name="reader">The reader which contains the raw authdata</param>
        public virtual void ReadFrom(BinaryReader reader)
        {
            this.ServerSignature = reader.ReadBytes(16);
            this.AuthDataVersion = reader.ReadUInt16();
            this.AuthDataSize = reader.ReadUInt16();

            // Lets do a quick check to ensure that we have enough bytes remaining
            long remainingBytes = reader.BaseStream.Length - reader.BaseStream.Position;
            // If there are fewer bytes remaining than the expected size make a note
            if (remainingBytes < (this.AuthDataSize - (sizeof(UInt16) * 2)))
            {
                Global.RO.Warn("Not enough stream data for authdata structure.");
            }

            this.ClientMajorVersion = reader.ReadUInt16();
            this.ClientMinorVersion = reader.ReadUInt16();
            this.ClientBuildNumber = reader.ReadUInt16();
            this.ClientQFENumber = reader.ReadUInt16();
        }

        // A bunch of delegate helper methods for printing stuff out
        // These should be in STF Utilities.
        public delegate String ConvertToStringDelegate<T>(T t);
        public static String ObjToString<T>(T t)
        {
            return t.ToString();
        }

        public static String ValuesToList<T>(T[] values)
        {
            return ValuesToList(values, "", ObjToString);
        }

        public static String ValuesToList<T>(T[] values, String prefix, ConvertToStringDelegate<T> converter)
        {
            if (values.Length == 0)
            {
                return String.Empty;
            }

            StringBuilder sb = new StringBuilder();

            foreach (T t in values)
            {
                sb.AppendFormat("{0}{1}, ", prefix, converter(t));
            }

            sb.Remove(sb.Length - 2, 2);
            return sb.ToString();
        }
    }

    /// <summary>
    /// Xbox2Authdata from inside an xkdc ticket.
    /// </summary>
    public class Xbox2XkdcAuthData : XboxAuthDataBase
    {
        private uint    titleId;
        private uint    titleVersion;
        private uint    titleRegion;
        private ulong   xboxID;
        private Xuid[]  users; //array of 4
        private uint    numServices;
        private uint[]  services; //array of 12
        private float[] userTrustFactor; //array of 4
        private uint[]  altTitleID; //array of 4
        private byte[]  key; //16 bytes

        public override uint TitleID { get { return titleId; } set { titleId = value; } }
        public override uint TitleVersion { get { return titleVersion; } set { titleVersion = value; } }
        public override uint TitleRegion { get { return titleRegion; } set { titleRegion = value; } }
        public override ulong XboxID { get { return xboxID; } set { xboxID = value; } }
        public override byte[] Key { get { return key; } set { key = value; } }

        public override Xuid GetUser(uint userIndex)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex");
            }

            return users[userIndex];
        }

        public override float GetUserTrustFactor(uint userIndex)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex");
            }

            return userTrustFactor[userIndex];
        }

        public override uint GetAltTitleId(uint index)
        {
            if (index > 3)
            {
                throw new ArgumentOutOfRangeException("index");
            }

            return altTitleID[index];
        }

        /// <summary>
        /// Indicates the total number of services in this authdata
        /// </summary>
        public override uint ServiceCount { get { return numServices; } }

        public override bool HasService(uint serviceId)
        {
            for (int i = 0; i < numServices; i++)
            {
                if (services[i] == serviceId)
                {
                    return true;
                }
            }

            return false;
        }

        public override void AddService(uint serviceId)
        {
            if (numServices < 12)
            {
                services[numServices++] = serviceId;
            }
        }

        public override void RemoveService(uint serviceId)
        {
            bool found = false;
            for (int i = 0; i < numServices; i++)
            {
                if (found)
                {
                    // Shift the service down and clear the current one
                    services[i - 1] = services[i];
                    services[i] = 0;
                }
                else if (services[i] == serviceId)
                {
                    found = true;
                    // We need to clear this in case it's the last service
                    services[i] = 0;
                }
            }

            if (found)
            {
                numServices--;
            }
        }

        public override void RemoveServiceAt(uint index)
        {
            if (index >= numServices)
            {
                throw new IndexOutOfRangeException("index");
            }

            RemoveService(services[index]);
        }

        public override uint[] GetByteServices()
        {
            System.Collections.Generic.List<uint> bs = new System.Collections.Generic.List<uint>();

            foreach (uint s in services)
            {
                if (s>0 && s<=127)
                {
                    bs.Add(s);
                }
            }

            return bs.ToArray();
        }

        public override uint[] GetDwordServices()
        {
            System.Collections.Generic.List<uint> dws = new System.Collections.Generic.List<uint>();

            foreach (uint s in services)
            {
                if (s>=256)
                {
                    dws.Add(s);
                }
            }

            return dws.ToArray();
        }

        /// <summary>
        /// Create an empty Xbox2XkdcAuthData structure
        /// </summary>
        public Xbox2XkdcAuthData() { }

        /// <summary>
        /// Create an Xbox2XkdcAuthData structure and populate it from 
        /// the provided ASN data
        /// </summary>
        /// <param name="cdts">The ASN data to create the structure from</param>
        public Xbox2XkdcAuthData(Kerberos.CommonTypeDataSequence cdts) : base(cdts) { }

        public override void ReadFrom(BinaryReader reader)
        {
            base.ReadFrom(reader);

            // Let's check a few things.
            if (AuthDataVersion != 0x02)
            {
                Global.RO.Warn("Attempting to read Xbox2AuthData from authdata version 0x{0:X}", AuthDataVersion);
            }

            if (AuthDataSize != 180)
            {
                Global.RO.Warn("Xbox2AuthData structure not expected size.  Expected: {0}, Got: {1}", 180, AuthDataSize);
            }

            this.TitleID = reader.ReadUInt32();
            this.TitleVersion = reader.ReadUInt32();
            this.TitleRegion = reader.ReadUInt32();
            this.XboxID = reader.ReadUInt64();
            this.users = new Xuid[4];
            for (int i = 0; i < 4; i++)
            {
                this.users[i] = new Xuid(reader.ReadUInt64(), reader.ReadUInt32());
            }

            this.numServices = reader.ReadUInt32();
            this.services = new uint[12];
            for (int i = 0; i < 12; i++)
            {
                this.services[i] = reader.ReadUInt32();
            }

            this.userTrustFactor = new float[4];
            for (int i = 0; i < 4; i++)
            {
                this.userTrustFactor[i] = reader.ReadSingle();
            }

            this.altTitleID = new uint[4];
            for (int i = 0; i < 4; i++)
            {
                this.altTitleID[i] = reader.ReadUInt32();
            }

            this.Key = reader.ReadBytes(16);
        }

        /// <summary> Loads all fields from auth data bytes. </summary>
        public static Xbox2XkdcAuthData Create(Kerberos.CommonTypeDataSequence genericAD)
        {
            return new Xbox2XkdcAuthData(genericAD);
        }

        public override string ToString()
        {
            string s="Xbox2AuthData - ASN Type "+Type+":";
            s+="\nXkdcAD ServerSignature: 0x"+ServerTestFramework.Utilities.Hexer.tohex(ServerSignature);
            s+="\nXkdcAD AuthDataVersion: "+AuthDataVersion;
            s+="\nXkdcAD AuthDataSize: "+AuthDataSize;
            s+="\nXkdcAD ClientVersion: "+ClientMajorVersion+"."+ClientMinorVersion+"."+ClientBuildNumber+"."+ClientQFENumber;
            s+="\nXkdcAD TitleID: 0x"+ServerTestFramework.Utilities.Hexer.tohex(TitleID);
            s+="\nXkdcAD TitleVersion: "+TitleVersion;
            s+="\nXkdcAD TitleRegion: "+TitleRegion;
            s+="\nXkdcAD XboxID: 0x" + ServerTestFramework.Utilities.Hexer.tohex(XboxID);
            s+="\nXkdcAD Users: " + ValuesToList(users);
            s+="\nXkdcAD NumServices: " + numServices;
            s+="\nXkdcAD ServiceID: " + ValuesToList(services);
            s+="\nXkdcAD UserTrustFactor: " + ValuesToList(userTrustFactor);
            s+="\nXkdcAD AltTitleID: " + ValuesToList(altTitleID, "0x", ServerTestFramework.Utilities.Hexer.tohex);
            s+="\nXkdcAD Key: 0x"+ServerTestFramework.Utilities.Hexer.tohex(Key);
            return s;
        }
    }

    /// <summary>
    /// Base Authdata class for all Xenon authdata structures
    /// </summary>
    public abstract class XenonAuthDataBase : XboxAuthDataBase
    {
        // Members new to AuthData3+
        public abstract uint AuthDataFlags { get; set; }
        public abstract uint ConsoleRegion { get; set; }
        public abstract uint MediaId { get; set; }
        public abstract ushort LanguageId { get; set; }

        public abstract bool HasPrivilege(uint privilegeId);
        public abstract bool HasPrivilege(uint privilegeId, uint userIndex);
        public abstract void SetPrivilege(uint privilegeId);
        public abstract void SetPrivilege(uint privilegeId, uint userIndex);
        public abstract void ClearPrivilege(uint privilegeId);
        public abstract void ClearPrivilege(uint privilegeId, uint userIndex);
        public abstract byte[] GetPrivileges();
        public abstract byte[] GetPrivileges(uint userIndex);
        public abstract uint[] GetDwordServicesArray();

        public override uint[] GetByteServices()
        {
            System.Collections.Generic.List<uint> bs = new System.Collections.Generic.List<uint>();

            for (uint s=0; s<128; ++s)
            {
                if (HasService(s))
                {
                    bs.Add(s);
                }
            }

            return bs.ToArray();
        }

        public override uint[] GetDwordServices()
        {
            System.Collections.Generic.List<uint> dws = new System.Collections.Generic.List<uint>();

            foreach (uint s in GetDwordServicesArray())
            {
                if (s!=0)
                {
                    dws.Add(s);
                }
            }

            return dws.ToArray();
        }

        public XenonAuthDataBase() { }

        public XenonAuthDataBase(Kerberos.CommonTypeDataSequence genericAd) : base(genericAd) { }
    }

    /// <summary> 
    /// XenonAuthdata from inside an xkdc ticket.
    /// </summary>
    public class XenonXkdcAuthData: XenonAuthDataBase
    {
        private uint    titleId;
        private uint    titleVersion;
        private uint    titleRegion;
        private uint    consoleRegion;
        private uint    mediaId;
        private ushort  languageId;
        private uint    authDataFlags;
        private ushort  numPrivileges;
        private byte[]  privileges; //256 bits, 32 bytes, or 8 dwords
        private ulong   xboxID;
        private Xuid[]  users; //array of 4
        private float[] userTrustFactor; //array of 4
        private ushort  numDwordServices;
        private uint[]  services; //array of 4
        private uint[]  altTitleID; //array of 4
        private byte[]  key; //16 bytes

        public override uint AuthDataFlags { get { return authDataFlags; } set { authDataFlags = value; } }
        public override uint TitleID { get { return titleId; } set { titleId = value; } }
        public override uint TitleVersion { get { return titleVersion; } set { titleVersion = value; } }
        public override uint TitleRegion { get { return titleRegion; } set { titleRegion = value; } }
        public override ulong XboxID { get { return xboxID; } set { xboxID = value; } }

        public override uint ConsoleRegion { get { return consoleRegion; } set { consoleRegion = value; } }
        public override uint MediaId { get { return mediaId; } set { mediaId = value; } }
        public override ushort LanguageId { get { return languageId; } set { languageId = value; } }

        public override byte[] Key { get { return key; } set { key = value; } }

        public override Xuid GetUser(uint userIndex)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex");
            }

            return users[userIndex];
        }

        public override float GetUserTrustFactor(uint userIndex)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex");
            }

            return userTrustFactor[userIndex];
        }

        public override uint GetAltTitleId(uint index)
        {
            if (index > 3)
            {
                throw new ArgumentOutOfRangeException("index");
            }

            return altTitleID[index];
        }

        public override bool HasPrivilege(uint privilegeId, uint userIndex)
        {
            return HasPrivilege(privilegeId);
        }

        public override bool HasPrivilege(uint privilegeId)
        {
            if (privilegeId > 255)
            {
                return false;
            }

            // Figure out which byte it's in
            uint privilegeByte = privilegeId / 8;
            // And create the privilege mask
            byte privilegeMask = (byte)(1 << ((int)privilegeId % 8));

            return (privileges[privilegeByte] & privilegeMask) == privilegeMask;
        }

        public override void SetPrivilege(uint privilegeId, uint userIndex)
        {
            // AuthData3 does not have user specific privileges
            // so we just ignore the user index
            SetPrivilege(privilegeId);
        }

        public override void SetPrivilege(uint privilegeId)
        {
            if (privilegeId > 255)
            {
                throw new ArgumentOutOfRangeException("privilegeId");
            }

            // Figure out which byte it's in
            uint privilegeByte = privilegeId / 8;
            // And create the privilege mask
            byte privilegeMask = (byte)(1 << ((int)privilegeId % 8));

            privileges[privilegeByte] |= privilegeMask;
        }

        public override void ClearPrivilege(uint privilegeId, uint userIndex)
        {
            // AuthData3 does not have user specific privileges
            // so we just ignore the user index
            ClearPrivilege(privilegeId);
        }

        public override void ClearPrivilege(uint privilegeId)
        {
            if (privilegeId > 255)
            {
                throw new ArgumentOutOfRangeException("privilegeId");
            }

            // Figure out which byte it's in
            uint privilegeByte = privilegeId / 8;
            // And create the privilege mask
            byte privilegeMask = (byte)(1 << ((int)privilegeId % 8));

            privileges[privilegeByte] &= (byte)~privilegeMask;
        }

        public override byte[] GetPrivileges(uint userIndex)
        {
            return GetPrivileges();
        }

        public override byte[] GetPrivileges()
        {
            byte[] privs = new byte[32];
            Array.Copy(this.privileges, privs, 32);

            return privs;
        }

        public override uint[] GetDwordServicesArray()
        {
            return services;
        }

        /// <summary>
        /// Indicates the number of DWORD services in this authdata
        /// </summary>
        public override uint ServiceCount { get { return numDwordServices; } }

        public override bool HasService(uint serviceId)
        {
            // Check in base services
            if (serviceId < 128)
            {
                return HasPrivilege(serviceId);
            }
            // Check in extended services
            {
                for (int i = 0; i < numDwordServices; i++)
                {
                    if (services[i] == serviceId)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public override void AddService(uint serviceId)
        {
            if (serviceId < 128)
            {
                // Check is privileges
                SetPrivilege(serviceId);
            }
            else
            {
                // Check in DWORD services
                if (numDwordServices < 4)
                {
                    services[numDwordServices++] = serviceId;
                }
            }
        }

        public override void RemoveService(uint serviceId)
        {
            if (serviceId < 128)
            {
                ClearPrivilege(serviceId);
            }
            else
            {
                bool found = false;
                for (int i = 0; i < numDwordServices; i++)
                {
                    if (found)
                    {
                        // Shift the service down and clear the current one
                        services[i - 1] = services[i];
                        services[i] = 0;
                    }
                    else if (services[i] == serviceId)
                    {
                        found = true;
                        // We need to clear it here in case it's the last service
                        services[i] = 0;
                    }
                }

                if (found)
                {
                    numDwordServices--;
                }
            }
        }

        public override void RemoveServiceAt(uint index)
        {
            if (index > 3)
            {
                throw new IndexOutOfRangeException("index");
            }

            RemoveService(services[index]);
        }

        /// <summary>
        /// Create an empty XenonXkdcAuthData structure
        /// </summary>
        public XenonXkdcAuthData() { }

        /// <summary>
        /// Create an XenonXkdcAuthData structure and populate it from 
        /// the provided ASN data
        /// </summary>
        /// <param name="cdts">The ASN data to create the structure from</param>
        public XenonXkdcAuthData(Kerberos.CommonTypeDataSequence cdts) : base(cdts) { }

        public override void ReadFrom(BinaryReader reader)
        {
            base.ReadFrom(reader);

            // Let's check a few things.
            if (AuthDataVersion != 0x03)
            {
                Global.RO.Warn("Attempting to read XenonAuthData from authdata version 0x{0:X}", AuthDataVersion);
            }

            if (AuthDataSize != 194)
            {
                Global.RO.Warn("XenonAuthData structure not expected size.  Expected: {0}, Got: {1}", 194, AuthDataSize);
            }

            this.TitleID = reader.ReadUInt32();
            this.TitleVersion = reader.ReadUInt32();
            this.TitleRegion = reader.ReadUInt32();
            this.ConsoleRegion = reader.ReadUInt32();
            this.MediaId = reader.ReadUInt32();
            this.LanguageId = reader.ReadUInt16();
            this.AuthDataFlags = reader.ReadUInt32();
            this.numPrivileges = reader.ReadUInt16();
            this.privileges = reader.ReadBytes(32);
            this.XboxID = reader.ReadUInt64();

            this.users = new Xuid[4];
            for (int i = 0; i < 4; i++)
            {
                this.users[i] = new Xuid(reader.ReadUInt64(), reader.ReadUInt32());
            }

            this.userTrustFactor = new float[4];
            for (int i = 0; i < 4; i++)
            {
                this.userTrustFactor[i] = reader.ReadSingle();
            }

            this.numDwordServices = reader.ReadUInt16();
            this.services = new uint[4];
            for (int i = 0; i < 4; i++)
            {
                this.services[i] = reader.ReadUInt32();
            }

            this.altTitleID = new uint[4];
            for (int i = 0; i < 4; i++)
            {
                this.altTitleID[i] = reader.ReadUInt32();
            }

            this.Key = reader.ReadBytes(16);
        }

        /// <summary> Loads all fields from auth data bytes. </summary>
        public static XenonXkdcAuthData Create(Kerberos.CommonTypeDataSequence genericAD)
        {
            return new XenonXkdcAuthData(genericAD);
        }

        public override string ToString()
        {
            string s = "XenonAuthData - ASN Type " + Type + ":";
            s += "\nXkdcAD ServerSignature: 0x" + ServerTestFramework.Utilities.Hexer.tohex(ServerSignature);
            s += "\nXkdcAD AuthDataVersion: " + AuthDataVersion;
            s += "\nXkdcAD AuthDataSize: " + AuthDataSize;
            s += "\nXkdcAD ClientVersion: " + ClientMajorVersion + "." + ClientMinorVersion + "." + ClientBuildNumber + "." + ClientQFENumber;
            s += "\nXkdcAD TitleID: 0x" + ServerTestFramework.Utilities.Hexer.tohex(TitleID);
            s += "\nXkdcAD TitleVersion: " + TitleVersion;
            s += "\nXkdcAD TitleRegion: " + TitleRegion;
            s += "\nXkdcAD ConsoleRegion: " + ConsoleRegion;
            s += "\nXkdcAD MediaID: " + mediaId;
            s += "\nXkdcAD LanguageID: " + languageId;
            s += "\nXkdcAD AuthDataFlags: 0x" + ServerTestFramework.Utilities.Hexer.tohex(AuthDataFlags);
            s += "\nXkdcAD NumPrivileges: " + numPrivileges;
            s += "\nXkdcAD Privileges: 0x" + ServerTestFramework.Utilities.Hexer.tohex(privileges);
            s += "\nXkdcAD XboxID: 0x" + ServerTestFramework.Utilities.Hexer.tohex(XboxID);
            s += "\nXkdcAD Users: " + ValuesToList(users);
            s += "\nXkdcAD UserTrustFactor: " + ValuesToList(userTrustFactor);
            s += "\nXkdcAD NumDwordServices: " + numDwordServices;
            s += "\nXkdcAD ServiceID: " + ValuesToList(services);
            s += "\nXkdcAD AltTitleID: " + ValuesToList(altTitleID, "0x", ServerTestFramework.Utilities.Hexer.tohex);
            s += "\nXkdcAD Key: 0x" + ServerTestFramework.Utilities.Hexer.tohex(Key);
            return s;
        }
    }

    /// <summary>
    /// Xenon2Authdata from inside an xkdc ticket.
    /// </summary>
    public class Xenon2XkdcAuthData : XenonAuthDataBase
    {
        private uint authDataFlags;
        private ulong xboxId;
        private float consoleTrustFactor;
        private uint titleId;
        private uint titleVersion;
        private uint titleRegion;
        private uint consoleRegion;
        private uint mediaId;
        private ushort languageId;
        private ushort numExtendedServices;
        private uint[] extendedServices; // Array of 4, This is *not* a bitmask of services
        private Xuid[] users; //array of 4
        private float[] userTrustFactor; //array of 4

        private uint[] baseServices; // Array of 4, This is a bitmask of services
        private uint[] machinePrivileges; // Array of 1, This is a bitmask of privileges
        private uint[][] userPrivileges; // Array of 4x3, This is a bitmask of privileges

        private uint[] altTitleID; //array of 4
        private ulong flowToken;
        private byte[] reserved; //array of 24
        private byte[] key; //16 bytes

        public override uint AuthDataFlags { get { return authDataFlags; } set { authDataFlags = value; } }
        public override ulong XboxID { get { return xboxId; } set { xboxId = value; } }
        public virtual float ConsoleTrustFactor { get { return consoleTrustFactor; } set { consoleTrustFactor = value; } }
        public override uint TitleID { get { return titleId; } set { titleId = value; } }
        public override uint TitleVersion { get { return titleVersion; } set { titleVersion = value; } }
        public override uint TitleRegion { get { return titleRegion; } set { titleRegion = value; } }
        public override uint ConsoleRegion { get { return consoleRegion; } set { consoleRegion = value; } }
        public override uint MediaId { get { return mediaId; } set { mediaId = value; } }
        public override ushort LanguageId { get { return languageId; } set { languageId = value; } }
        public ulong FlowToken { get { return flowToken; } set { flowToken = value; } }
        public override byte[] Key { get { return key; } set { key = value; } }

        public override Xuid GetUser(uint userIndex)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex");
            }

            return users[userIndex];
        }

        public override float GetUserTrustFactor(uint userIndex)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex");
            }

            return userTrustFactor[userIndex];
        }

        public override uint GetAltTitleId(uint index)
        {
            if (index > 3)
            {
                throw new ArgumentOutOfRangeException("index");
            }

            return altTitleID[index];
        }

        public override bool HasPrivilege(uint privilegeId)
        {
            return HasPrivilege(privilegeId, 0);
        }

        public override bool HasPrivilege(uint privilegeId, uint userIndex)
        {
            if (privilegeId < 128)
            {
                // Check in base services

                // Figure out which DWORD it's in
                uint privilegeDword = privilegeId / 32;
                // And create the privilege mask
                uint privilegeMask = (uint)1 << ((int)privilegeId % 32);

                return (baseServices[privilegeDword] & privilegeMask) == privilegeMask;
            }
            else if (privilegeId < 160)
            {
                // Check in machine privileges
                privilegeId -= 128;

                // Figure out which DWORD it's in
                uint privilegeDword = privilegeId / 32;
                // And create the privilege mask
                uint privilegeMask = (uint)1 << ((int)privilegeId % 32);

                return (machinePrivileges[privilegeDword] & privilegeMask) == privilegeMask;
            }
            else if(privilegeId < 256)
            {
                // Check in user privileges
                privilegeId -= 160;

                // Figure out which byte it's in
                uint privilegeDword = privilegeId / 32;
                // And create the privilege mask
                uint privilegeMask = (uint)1 << ((int)privilegeId % 32);

                return (userPrivileges[userIndex][privilegeDword] & privilegeMask) == privilegeMask;
            }

            return false;
        }

        public override void SetPrivilege(uint privilegeId)
        {
            SetPrivilege(privilegeId, 0);
        }

        public override void SetPrivilege(uint privilegeId, uint userIndex)
        {
            if (privilegeId < 128)
            {
                // Check in base services

                // Figure out which DWORD it's in
                uint privilegeDword = privilegeId / 32;
                // And create the privilege mask
                uint privilegeMask = (uint)1 << ((int)privilegeId % 32);

                baseServices[privilegeDword] |= privilegeMask;
            }
            else if (privilegeId < 160)
            {
                // Check in machine privileges
                privilegeId -= 128;

                // Figure out which DWORD it's in
                uint privilegeDword = privilegeId / 32;
                // And create the privilege mask
                uint privilegeMask = (uint)1 << ((int)privilegeId % 32);

                machinePrivileges[privilegeDword] |= privilegeMask;
            }
            else if (privilegeId < 256)
            {
                // Check in user privileges
                privilegeId -= 160;

                // Figure out which byte it's in
                uint privilegeDword = privilegeId / 32;
                // And create the privilege mask
                uint privilegeMask = (uint)1 << ((int)privilegeId % 32);

                userPrivileges[userIndex][privilegeDword] |= privilegeMask;
            }
        }

        public override void ClearPrivilege(uint privilegeId)
        {
            ClearPrivilege(privilegeId, 0);
        }

        public override void ClearPrivilege(uint privilegeId, uint userIndex)
        {
            if (privilegeId < 128)
            {
                // Check in base services

                // Figure out which DWORD it's in
                uint privilegeDword = privilegeId / 32;
                // And create the privilege mask
                uint privilegeMask = (uint)1 << ((int)privilegeId % 32);

                baseServices[privilegeDword] &= ~privilegeMask;
            }
            else if (privilegeId < 160)
            {
                // Check in machine privileges
                privilegeId -= 128;

                // Figure out which DWORD it's in
                uint privilegeDword = privilegeId / 32;
                // And create the privilege mask
                uint privilegeMask = (uint)1 << ((int)privilegeId % 32);

                machinePrivileges[privilegeDword] &= ~privilegeMask;
            }
            else if (privilegeId < 256)
            {
                // Check in user privileges
                privilegeId -= 160;

                // Figure out which byte it's in
                uint privilegeDword = privilegeId / 32;
                // And create the privilege mask
                uint privilegeMask = (uint)1 << ((int)privilegeId % 32);

                userPrivileges[userIndex][privilegeDword] &= ~privilegeMask;
            }
        }

        public override byte[] GetPrivileges()
        {
            return GetPrivileges(0);
        }

        public override byte[] GetPrivileges(uint userIndex)
        {
            byte[] privs = new byte[32];

            // Copy all the base services
            AddBytes(baseServices, ref privs, 0);
            // Copy all machine privs
            AddBytes(machinePrivileges, ref privs, 4);
            // Copy all privileges for the given user (must do each uint)
            AddBytes(userPrivileges[userIndex], ref privs, 5);

            return privs;
        }

        public override uint[] GetDwordServicesArray()
        {
            return extendedServices;
        }

        private void AddBytes(uint[] src, ref byte[] dest, int destIndex)
        {
            byte[] srcBytes = null;
            int index = destIndex;
            for (int i = 0; i < src.Length; i++)
            {
                srcBytes = BitConverter.GetBytes(src[i]);
                for (int j = 0; j < srcBytes.Length; j++)
                {
                    dest[index++] = srcBytes[j];
                }
            }
        }

        /// <summary>
        /// Indicates the number of extended services in this authdata
        /// </summary>
        public override uint ServiceCount { get { return numExtendedServices; } }

        public override bool HasService(uint serviceId)
        {
            // Check in base services
            if (serviceId < 128)
            {
                return HasPrivilege(serviceId);
            }
            // Check in extended services
            {
                for (int i = 0; i < numExtendedServices; i++)
                {
                    if (extendedServices[i] == serviceId)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public override void AddService(uint serviceId)
        {
            if (serviceId < 128)
            {
                // Add to base services
                SetPrivilege(serviceId);
            }
            else
            {
                // Add to extended services
                if (numExtendedServices < 4)
                {
                    extendedServices[numExtendedServices++] = serviceId;
                }
            }
        }

        public override void RemoveService(uint serviceId)
        {
            // Remove from base services
            if (serviceId < 128)
            {
                ClearPrivilege(serviceId);
            }
            // Remove from extended services
            {
                bool found = false;
                for (int i = 0; i < numExtendedServices; i++)
                {
                    if (found)
                    {
                        // Shift the service down and clear the current one
                        extendedServices[i - 1] = extendedServices[i];
                        extendedServices[i] = 0;
                    }
                    else if (extendedServices[i] == serviceId)
                    {
                        found = true;
                        // We need to clear it here in case it's the last service
                        extendedServices[i] = 0;
                    }
                }

                if (found)
                {
                    numExtendedServices--;
                }
            }
        }

        public override void RemoveServiceAt(uint index)
        {
            RemoveService(extendedServices[index]);
        }

        /// <summary>
        /// Create an empty Xenon2XkdcAuthData structure
        /// </summary>
        public Xenon2XkdcAuthData() { }

        /// <summary>
        /// Create an Xenon2XkdcAuthData structure and populate it from 
        /// the provided ASN data
        /// </summary>
        /// <param name="cdts">The ASN data to create the structure from</param>
        public Xenon2XkdcAuthData(Kerberos.CommonTypeDataSequence ctds) : base(ctds) { }

        public override void ReadFrom(BinaryReader reader)
        {
            base.ReadFrom(reader);

            // Let's check a few things.
            if (AuthDataVersion != 0x04)
            {
                Global.RO.Warn("Attempting to read Xenon2AuthData from authdata version 0x{0:X}", AuthDataVersion);
            }

            if (AuthDataSize != 256)
            {
                Global.RO.Warn("Xenon2AuthData structure not expected size.  Expected: {0}, Got: {1}", 256, AuthDataSize);
            }

            this.AuthDataFlags = reader.ReadUInt32();
            this.XboxID = reader.ReadUInt64();
            this.ConsoleTrustFactor = reader.ReadSingle();
            this.TitleID = reader.ReadUInt32();
            this.TitleVersion = reader.ReadUInt32();
            this.TitleRegion = reader.ReadUInt32();
            this.ConsoleRegion = reader.ReadUInt32();
            this.MediaId = reader.ReadUInt32();
            this.LanguageId = reader.ReadUInt16();

            this.numExtendedServices = reader.ReadUInt16();
            this.extendedServices = new uint[4];
            for (int i = 0; i < 4; i++)
            {
                this.extendedServices[i] = reader.ReadUInt32();
            }

            this.users = new Xuid[4];
            for (int i = 0; i < 4; i++)
            {
                this.users[i] = new Xuid(reader.ReadUInt64(), reader.ReadUInt32());
            }

            this.userTrustFactor = new float[4];
            for (int i = 0; i < 4; i++)
            {
                this.userTrustFactor[i] = reader.ReadSingle();
            }

            this.baseServices = new uint[4];
            for (int i = 0; i < 4; i++)
            {
                this.baseServices[i] = reader.ReadUInt32();
            }

            this.machinePrivileges = new uint[1];
            for (int i = 0; i < 1; i++)
            {
                this.machinePrivileges[i] = reader.ReadUInt32();
            }

            this.userPrivileges = new uint[4][]; // 3 uints for each user
            for (int i = 0; i < 4; i++)
            {
                this.userPrivileges[i] = new uint[3];
                for (int j = 0; j < 3; j++)
                {
                    this.userPrivileges[i][j] = reader.ReadUInt32();
                }
            }

            this.altTitleID = new uint[4];
            for (int i = 0; i < 4; i++)
            {
                this.altTitleID[i] = reader.ReadUInt32();
            }

            this.flowToken = reader.ReadUInt64();
            this.reserved = reader.ReadBytes(16);
            this.Key = reader.ReadBytes(16);
        }

        /// <summary> Loads all fields from auth data bytes. </summary>
        public static Xenon2XkdcAuthData Create(Kerberos.CommonTypeDataSequence genericAD)
        {
            return new Xenon2XkdcAuthData(genericAD);
        }

        public override string ToString()
        {
            StringBuilder s = new StringBuilder();
            s.AppendFormat("Xenon2AuthData - ASN Type {0}:\n", Type);
            s.AppendFormat("XkdcAD ServerSignature: 0x{0}\n", ServerTestFramework.Utilities.Hexer.tohex(ServerSignature));
            s.AppendFormat("XkdcAD AuthDataVersion: {0}\n", AuthDataVersion);
            s.AppendFormat("XkdcAD AuthDataSize: {0}\n", AuthDataSize);
            s.AppendFormat("XkdcAD ClientVersion: {0}.{1}.{2}.{3}\n", ClientMajorVersion, ClientMinorVersion, ClientBuildNumber, ClientQFENumber);
            s.AppendFormat("XkdcAD AuthDataFlags: 0x{0}\n", ServerTestFramework.Utilities.Hexer.tohex(AuthDataFlags));
            s.AppendFormat("XkdcAD XboxID: 0x{0}\n", ServerTestFramework.Utilities.Hexer.tohex(XboxID));
            s.AppendFormat("XkdcAD ConsoleTrustFactor: {0}\n", ConsoleTrustFactor);
            s.AppendFormat("XkdcAD TitleID: 0x{0}\n", ServerTestFramework.Utilities.Hexer.tohex(TitleID));
            s.AppendFormat("XkdcAD TitleVersion: {0}\n", TitleVersion);
            s.AppendFormat("XkdcAD TitleRegion: {0}\n", TitleRegion);
            s.AppendFormat("XkdcAD ConsoleRegion: {0}\n", ConsoleRegion);
            s.AppendFormat("XkdcAD MediaID: {0}\n", MediaId);
            s.AppendFormat("XkdcAD LanguageID: {0}\n", LanguageId);

            s.AppendFormat("XkdcAD NumExtendedServices: {0}\n", numExtendedServices);
            s.AppendFormat("XkdcAD ExtendedServices: {0}\n", ValuesToList(extendedServices, "0x", ServerTestFramework.Utilities.Hexer.tohex));
            s.AppendFormat("XkdcAD Users: {0}\n", ValuesToList(users));
            s.AppendFormat("XkdcAD UserTrustFactor: {0}\n", ValuesToList(userTrustFactor));

            s.AppendFormat("XkdcAD BaseServices: {0}\n", ValuesToList(baseServices, "0x", ServerTestFramework.Utilities.Hexer.tohex));
            s.AppendFormat("XkdcAD MachinePrivileges: {0}\n", ValuesToList(machinePrivileges, "0x", ServerTestFramework.Utilities.Hexer.tohex));
            uint[] userpriv = new uint[3];
            for (int i = 0; i < users.Length; i++)
            {
                if (users[i].UserID != 0)
                {
                    userpriv = new uint[] { userPrivileges[i][0], userPrivileges[i][1], userPrivileges[i][2] };
                    s.AppendFormat("XkdcAD UserPrivileges[{0}]: {1}\n", i, ValuesToList(userpriv, "0x", ServerTestFramework.Utilities.Hexer.tohex));
                }
            }

            s.AppendFormat("XkdcAD AltTitleID: {0}\n", ValuesToList(altTitleID, "0x", ServerTestFramework.Utilities.Hexer.tohex));
            s.AppendFormat("XkdcAD FlowToken: 0x{0}\n", ServerTestFramework.Utilities.Hexer.tohex(FlowToken));
            s.AppendFormat("XkdcAD Key: 0x{0}\n", ServerTestFramework.Utilities.Hexer.tohex(Key));

            return s.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\Fuzzing.cs ===
using System.Collections.Generic;

using ServerTestFramework;

namespace ServerTestFramework.LiveService.Auth.Asn
{
    /// <summary> Manages fuzzing ASN trees. </summary>
    public static class AsnFuzzing
    {
        /// <summary> Globally enables or disables fuzzing of ASN trees. </summary>
        public static bool Enabled=true;

        /// <summary> Enables verbose output of what structures are being fuzzed. </summary>
        public static bool Verbose=false;

        /// <summary> Used to debug re-encryption bugs. </summary>
        public static bool DebugReEncryption=false;
        public static bool DebugReencryption_AssumeAlreadyDecrypted=false;

        /// <summary> Delegate to call to fuzz an object. </summary>
        public delegate void FuzzAsnValueDelegate(AsnValueBase value, string verboseOrigin);

        /// <summary> List of handlers for fuzzing different types, and their propability of use weights. </summary>
        public static Dictionary<System.Type, List<KeyValuePair<FuzzAsnValueDelegate, int>>> FuzzMethods=new Dictionary<System.Type, List<KeyValuePair<FuzzAsnValueDelegate, int>>>();

        private static Report ro=new Report("AsnFuzzer");

        /// <summary> Registers a new fuzzing method for an ASN type. </summary>
        public static void AddFuzzMethod(System.Type type, FuzzAsnValueDelegate method, int weight)
        {
            if (!FuzzMethods.ContainsKey(type))
            {
                FuzzMethods.Add(type, new List<KeyValuePair<FuzzAsnValueDelegate, int>>());
            }

            FuzzMethods[type].Add(new KeyValuePair<FuzzAsnValueDelegate, int>(method, weight));
        }

        /// <summary> Fuzzes an ASN value tree. </summary>
        public static void Fuzz(AsnValueBase value)
        {
            Fuzz(value, "");
        }

        private static void Fuzz(AsnValueBase value, string verboseOrigin)
        {
            if (!Enabled || value==null)
            {
                return;
            }

            if (Verbose)
            {
                if (verboseOrigin.Length!=0)
                {
                    verboseOrigin=" from "+verboseOrigin;
                }

                string otherInfo=""; //add tag numbers to help with identification
                if (value is Raw.Tag)
                {
                    otherInfo="("+((Raw.Tag)value).Number+")";
                }
                else if (value is Compound.TagLengthValue)
                {
                    if (((Compound.TagLengthValue)value).Tag!=null)
                    {
                        otherInfo="("+((Compound.TagLengthValue)value).Tag.Number+")";
                    }
                }
                else if (value is Compound.ExplicitTagLengthValue)
                {
                    otherInfo="(";
                    if (((Compound.ExplicitTagLengthValue)value).ExplicitTag!=null)
                    {
                        otherInfo+=((Compound.ExplicitTagLengthValue)value).ExplicitTag.Number.ToString();
                    }
                    otherInfo+=",";
                    if (((Compound.ExplicitTagLengthValue)value).ValueTag!=null)
                    {
                        otherInfo+=((Compound.ExplicitTagLengthValue)value).ValueTag.Number.ToString();
                    }
                    otherInfo+=")";
                }

                verboseOrigin=value.GetType().Name.ToString()+otherInfo+verboseOrigin;
            }

            //see if we have a specific type
            List<KeyValuePair<FuzzAsnValueDelegate, int>> potentialMethods;
            if (!FuzzMethods.TryGetValue(value.GetType(), out potentialMethods) || potentialMethods.Count==0)
            {
                //see if we can fall back to a common type
                if (value is Kerberos.Preauth)
                {
                    FuzzMethods.TryGetValue(typeof(Kerberos.Preauth), out potentialMethods);
                }
                else if (value is Kerberos.EncryptedData)
                {
                    FuzzMethods.TryGetValue(typeof(Kerberos.EncryptedData), out potentialMethods);
                }
                else if (value is Kerberos.IEncryptable)
                {
                    FuzzMethods.TryGetValue(typeof(Kerberos.IEncryptable), out potentialMethods);
                }
                else if (value is Compound.TagLengthValue)
                {
                    FuzzMethods.TryGetValue(typeof(Compound.TagLengthValue), out potentialMethods);
                }
                else if (value is Compound.ExplicitTagLengthValue)
                {
                    FuzzMethods.TryGetValue(typeof(Compound.ExplicitTagLengthValue), out potentialMethods);
                }
                else if (value is Compound.Sequence)
                {
                    FuzzMethods.TryGetValue(typeof(Compound.Sequence), out potentialMethods);
                }
                else if (value is AsnBytes)
                {
                    FuzzMethods.TryGetValue(typeof(AsnBytes), out potentialMethods);
                }
            }

            //handle the found methods
            if (potentialMethods!=null && potentialMethods.Count>0)
            {
                //sum the weights
                int totalWeight=0;
                foreach (KeyValuePair<FuzzAsnValueDelegate, int> kvp in potentialMethods)
                {
                    totalWeight+=kvp.Value;
                }

                //pick one randomly and call it
                if (totalWeight>0)
                {
                    int pick=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%totalWeight;
                    int cur=0;
                    foreach (KeyValuePair<FuzzAsnValueDelegate, int> kvp in potentialMethods)
                    {
                        cur+=kvp.Value;
                        if (pick<cur)
                        {
                            if (Verbose)
                            {
                                ro.Debug("Calling "+kvp.Key.Method.Name+" on "+verboseOrigin);
                            }

                            kvp.Key(value, verboseOrigin);

                            break;
                        }
                    }
                }
            }
            else
            {
                ro.Warn("Unable to fuzz value of type "+value.GetType());
            }
        }

        // -- fuzzing methods

        //Any
        public static void FuzzNothing(AsnValueBase baseValue, string verboseOrigin)
        {
        }

        //AsnBytes
        public static void FuzzSingleByte(AsnValueBase baseValue, string verboseOrigin)
        {
            AsnBytes value=(AsnBytes)baseValue;
            if (value.Bytes.Length==0)
            {
                return;
            }

            int which=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%value.Bytes.Length;
            byte b=(byte)(ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%255);
            value.Bytes[which]=b;
        }

        //AsnBytes
        public static void FuzzSingleBit(AsnValueBase baseValue, string verboseOrigin)
        {
            AsnBytes value=(AsnBytes)baseValue;
            if (value.Bytes.Length==0)
            {
                return;
            }

            int which=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%value.Bytes.Length;
            int b=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%8;
            value.Bytes[which]^=(byte)(1<<b);
        }

        //AsnBytes
        public static void FuzzAllBytes(AsnValueBase baseValue, string verboseOrigin)
        {
            AsnBytes value=(AsnBytes)baseValue;
            for (int i=0; i<value.Bytes.Length; ++i)
            {
                byte b=(byte)(ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%255);
                value.Bytes[i]=b;
            }
        }

        //Sequence
        public static void FuzzSequenceForward(AsnValueBase baseValue, string verboseOrigin)
        {
            Compound.Sequence seq=(Compound.Sequence)baseValue;
            foreach (AsnValueBase value in seq.Values)
            {
                Fuzz(value, verboseOrigin);
            }
        }

        //Sequence
        public static void FuzzSequenceDropOne(AsnValueBase baseValue, string verboseOrigin)
        {
            Compound.Sequence seq=(Compound.Sequence)baseValue;
            int indexToDrop=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next()%seq.Values.Length;
            for (int i=0; i<seq.Values.Length; ++i)
            {
                if (i==indexToDrop)
                {
                    seq.Values[i]=null;
                }
                else
                {
                    Fuzz(seq.Values[i], verboseOrigin);
                }
            }
        }

        //TagLengthValue
        public static void FuzzTagLengthValueForward(AsnValueBase baseValue, string verboseOrigin)
        {
            Compound.TagLengthValue tlv=(Compound.TagLengthValue)baseValue;
            Fuzz(tlv.Tag, verboseOrigin);
            Fuzz(tlv.Length, verboseOrigin);
            Fuzz(tlv.Value, verboseOrigin);
        }

        //ExplicitTagLengthValue
        public static void FuzzExplicitTagLengthValueForward(AsnValueBase baseValue, string verboseOrigin)
        {
            Compound.ExplicitTagLengthValue tlv=(Compound.ExplicitTagLengthValue)baseValue;
            Fuzz(tlv.GetExplicitTagLengthValue(), verboseOrigin); //pass it on to the outter one, which will pass it on to the inner one
        }

        //Compound OctetString
        public static void FuzzCompoundOctetStringForward(AsnValueBase baseValue, string verboseOrigin)
        {
            Compound.OctetString os=(Compound.OctetString)baseValue;
            Fuzz(os.Value, verboseOrigin);
        }

        //Preauth
        public static void FuzzPreauthForward(AsnValueBase baseValue, string verboseOrigin)
        {
            Kerberos.Preauth pa=(Kerberos.Preauth)baseValue;
            Fuzz(pa.Type, verboseOrigin);
            Fuzz(pa.Data, verboseOrigin);
        }

        //EncryptedData
        public static void FuzzEncryptedData(AsnValueBase baseValue, string verboseOrigin)
        {
            Kerberos.EncryptedData ed=(Kerberos.EncryptedData)baseValue;

            //handle the tag and length parts
            Fuzz(ed.Tag, verboseOrigin);
            Fuzz(ed.Length, verboseOrigin);

            //we want to fuzz the part of the data inside the encrypted blob
            if (ed is Kerberos.IEncryptable)
            {
                FuzzIEncryptable(ed, verboseOrigin);
            }
            else
            {
                ro.Warn("Unable to fuzz the data inside of an EncryptedData("+ed.GetType()+") because it does not implement IEncryptable.");
            }
        }

        public static void FuzzIEncryptable(AsnValueBase baseValue, string verboseOrigin)
        {
            Kerberos.IEncryptable ie=(Kerberos.IEncryptable)baseValue;

            byte []origBytes=null;
            byte []origDecInnerBytes=null;
            if (DebugReEncryption) //save the original state
            {
                origBytes=baseValue.GetBytes();

                if (DebugReencryption_AssumeAlreadyDecrypted)
                {
                    if (ie is Kerberos.IContainsEncryptedAsn)
                    {
                        origDecInnerBytes=((Kerberos.IContainsEncryptedAsn)ie).GetInnerAsn().GetBytes();
                    }
                    else if (ie is Kerberos.IContainsEncryptedBytes)
                    {
                        origDecInnerBytes=((Kerberos.IContainsEncryptedBytes)ie).GetInnerBytes();
                    }
                }
            }

            ie.Decrypt();

            if (DebugReEncryption)
            {
                //store decrypted bytes for later comparison
                byte []beforeReDecInnerBytes=null;
                if (ie is Kerberos.IContainsEncryptedAsn)
                {
                    beforeReDecInnerBytes=((Kerberos.IContainsEncryptedAsn)ie).GetInnerAsn().GetBytes();
                }
                else if (ie is Kerberos.IContainsEncryptedBytes)
                {
                    beforeReDecInnerBytes=((Kerberos.IContainsEncryptedBytes)ie).GetInnerBytes();
                }

                if (origDecInnerBytes!=null) //compare against the original if we have it
                {
                    string origString=ServerTestFramework.Utilities.Hexer.tohex(origDecInnerBytes);
                    string newString=ServerTestFramework.Utilities.Hexer.tohex(beforeReDecInnerBytes);
                    if (origString!=newString)
                    {
                        Global.RO.Fatal("Re-decryption bug before re-encryption, bytes changed on "+baseValue.GetType()+":\norig bytes: "+origString+"\nnew bytes:  "+newString);
                    }
                }

                //encrypt it back... length of the encrypted blob should stay the same
                ie.Encrypt();
                byte []newBytes=baseValue.GetBytes();
                if (origBytes.Length!=newBytes.Length)
                {
                    string origString=ServerTestFramework.Utilities.Hexer.tohex(origBytes);
                    string newString=ServerTestFramework.Utilities.Hexer.tohex(newBytes);
                    Global.RO.Fatal("Re-encryption bug, length changed after re-encrypting on "+baseValue.GetType()+":\norig bytes: "+origString+"\nnew bytes:  "+newString);
                }

                //decrypt it again, the inner bytes should not have changed
                ie.Decrypt();

                byte []newDecInnerBytes=null;
                if (ie is Kerberos.IContainsEncryptedAsn)
                {
                    newDecInnerBytes=((Kerberos.IContainsEncryptedAsn)ie).GetInnerAsn().GetBytes();
                }
                else if (ie is Kerberos.IContainsEncryptedBytes)
                {
                    newDecInnerBytes=((Kerberos.IContainsEncryptedBytes)ie).GetInnerBytes();
                }

                if (beforeReDecInnerBytes!=null)
                {
                    string origString=ServerTestFramework.Utilities.Hexer.tohex(beforeReDecInnerBytes);
                    string newString=ServerTestFramework.Utilities.Hexer.tohex(newDecInnerBytes);
                    if (origString!=newString)
                    {
                        Global.RO.Fatal("Re-decryption bug after encryption, bytes changed on "+baseValue.GetType()+":\norig bytes: "+origString+"\nnew bytes:  "+newString);
                    }
                }
            }

            if (ie is Kerberos.IContainsEncryptedAsn)
            {
                Fuzz(((Kerberos.IContainsEncryptedAsn)ie).GetInnerAsn(), verboseOrigin);
            }
            else if (ie is Kerberos.IContainsEncryptedBytes)
            {
                byte []innerBytes=((Kerberos.IContainsEncryptedBytes)ie).GetInnerBytes();

                EncryptedBytes tempFuzzContainer=new EncryptedBytes();
                tempFuzzContainer.Bytes=innerBytes;
                Fuzz(tempFuzzContainer, verboseOrigin);

                ((Kerberos.IContainsEncryptedBytes)ie).SetInnerBytes(tempFuzzContainer.Bytes);
            }
            else
            {
                ro.Warn("Unable to fuzz the data inside of an IEncryptable("+ie.GetType()+") because it does not implement either IContainsEncryptedAsn or IContainsEncryptedBytes.");
            }

            ie.Encrypt();
        }

        //TODO: complex types
        // Doing EncryptedData might automatically get us a bunch of the preauths too, if it can re-encrypt with the key that was used after fuzzing the unencrypted portion.

        //PreauthTgsRequest
        //TODO

        //PreauthXenonMacRequest
        //TODO

        //PreauthPacRequestEx
        //TODO

        //PreauthEncryptedTimestamp
        //TODO

        //PreauthXboxClientVersion
        //TODO

        //PreauthXboxPPA
        //TODO

        //PreauthPCAccountCreationRequest
        //TODO

        //PreauthPCAccountCreationRequest_EncPart - maybe, if not part of PreauthPCAccountCreationRequest
        //TODO

        //PreauthPassportAuthenticationRequest
        //TODO

        //PreauthXboxEcho - reminder: it's encrypted with a secret service key, so fuzzing inner part is less interesting
        //TODO

        //PreauthXboxServiceRequest1
        //TODO

        //PreauthXboxServiceRequest2
        //TODO

        //PreauthXenonServiceRequest2
        //TODO

        //PreauthXenonServiceRequest3
        //TODO

        //PreauthCompoundIdentity
        //TODO

        //TODO: these are reply types that we might want to implement in the future if we ever use this for fuzzing the client's kerberos code:
        // PreauthXboxAccountCreation, PreauthPCAccountCreationReply, PreauthXboxServiceAddress, PreauthXboxServiceAddress1, PreauthXboxServiceAddress2, PreauthXenonServiceAddress2, PreauthPassportAuthenticationReply

        // -- populate the existing methods

        static AsnFuzzing()
        {
            //basic types
            AddFuzzMethod(typeof(AsnBytes), FuzzNothing, 1024);
            AddFuzzMethod(typeof(AsnBytes), FuzzSingleByte, 16);
            AddFuzzMethod(typeof(AsnBytes), FuzzSingleBit, 32);
            AddFuzzMethod(typeof(AsnBytes), FuzzAllBytes, 8);

            AddFuzzMethod(typeof(EncryptedBytes), FuzzNothing, 1024);
            AddFuzzMethod(typeof(EncryptedBytes), FuzzSingleByte, 48);
            AddFuzzMethod(typeof(EncryptedBytes), FuzzSingleBit, 64);
            AddFuzzMethod(typeof(EncryptedBytes), FuzzAllBytes, 8);

            AddFuzzMethod(typeof(Raw.Tag), FuzzNothing, 1024);
            AddFuzzMethod(typeof(Raw.Tag), FuzzSingleByte, 2);
            AddFuzzMethod(typeof(Raw.Tag), FuzzSingleBit, 4);
            AddFuzzMethod(typeof(Raw.Tag), FuzzAllBytes, 1);

            AddFuzzMethod(typeof(Raw.Length), FuzzNothing, 1024);
            AddFuzzMethod(typeof(Raw.Length), FuzzSingleByte, 2);
            AddFuzzMethod(typeof(Raw.Length), FuzzSingleBit, 4);
            AddFuzzMethod(typeof(Raw.Length), FuzzAllBytes, 1);

            //complex types
            AddFuzzMethod(typeof(Compound.Sequence), FuzzSequenceForward, 1024);
            AddFuzzMethod(typeof(Compound.Sequence), FuzzSequenceDropOne, 8);

            AddFuzzMethod(typeof(Compound.TagLengthValue), FuzzTagLengthValueForward, 1024);

            AddFuzzMethod(typeof(Compound.OctetString), FuzzCompoundOctetStringForward, 1024);

            AddFuzzMethod(typeof(Compound.ExplicitTagLengthValue), FuzzExplicitTagLengthValueForward, 1024);

            //kerberos types
            AddFuzzMethod(typeof(Kerberos.Preauth), FuzzPreauthForward, 1024);

            AddFuzzMethod(typeof(Kerberos.EncryptedData), FuzzEncryptedData, 1024);
            AddFuzzMethod(typeof(Kerberos.EncryptedData), FuzzTagLengthValueForward, 64);

            AddFuzzMethod(typeof(Kerberos.IEncryptable), FuzzIEncryptable, 1024);

            AddFuzzMethod(typeof(Kerberos.EncryptedTicketBody), FuzzNothing, 1024);
            AddFuzzMethod(typeof(Kerberos.EncryptedTicketBody), FuzzEncryptedData, 0); //this is sort of cheating, since clients can never do this

            //preauths
            //TODO
        }

        //allows us to control fuzzing on encrypted bytes separately from normal bytes
        public class EncryptedBytes: AsnBytes
        {
        };
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\sgPackets.cs ===
using System;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.common.service;

namespace ServerTestFramework.LiveService.Auth
{

    /// <summary>
    /// Kerb Constants
    /// </summary>
    public class KC
    {
        //public const uint   TEST_SPI_INIT       = 0x8D111100;
        public const int    k_MaxUDPPayload     = 1472;
        public const int    k_MaxXSPPayload     = 1472 - (4 + 12);  // spihdr + tail (+ padding room?)
        public const int    k_dwDHKeySize       = 96;
        public const int    k_APRequestSize     = 735;      // was 732; was 718;   // no bigger than 1300
        public const int    k_APResponseSize    = 115;      // was 800;   // no bigger than 800
        public const int    k_QuickTimeout      = 2000;     // in milliseconds
        public const int    k_LongTimeout       = 5000;     // in milliseconds
    }

    /// <summary>
    /// SG Constants
    /// </summary>
    public class SGC
    {
        public const uint sg_MinXbToSGInitPacketSize   = 1332; //the initial keyex packet size to the sg has to be at least this length
    }

#if false
    public abstract class SgPacket 
    {
        public SgPacket()
        {
        }

        public abstract void WriteStream(BinaryWriter);
        public abstract void ReadStream(BinaryReader);

        public void GetBytes(byte[] buffer, int index, int count)
        {
            MemoryStream ms = new MemoryStream(buffer, index, count);
            BinaryWriter bw = new BinaryWriter(ms);
            WriteStream(bw);
        }

        public void SetBytes(byte[] buffer, int index, int count)
        {
            MemoryStream ms = new MemoryStream(buffer, index, count);
            BinaryReader br = new BinaryReader(ms);
            ReadStream(br);
        }
    }
#endif



    #region SendablePacket and SGPacket





    /// <summary>
    /// Extend this class if your packet can be sent and received via a UDP socket.
    /// </summary>
    public class SendablePacket : WireDataIncludeBase
    {
        [WireInfo(Serialize=false)]
        protected int       recvSize        = 0;
        
        [WireInfo(Serialize=false)]
        protected byte[]    recvBuf         = null;
        
        [WireInfo(Serialize=false)]
        public SimpleUdpSG  simpleUdp       = null;

        /// <summary>
        /// Called just after receiving the bytes but before sending them to Wiredata. Override
        /// this as necessary to verify the received bytes are the expected ones. Generally, this
        /// can be done by looking at the first few bytes of the stream, if the packet specifies its
        /// type, or by looking at the stream length.
        /// </summary>
        /// <returns>true is this is the correct packet, false if we should try the Recv() again.</returns>
        public virtual bool Check()
        {
            return true;
        }

        /// <summary>
        /// Send this packet on its way.
        /// </summary>
        /// <param name="remoteHost"></param>
        public virtual void Send(IPEndPoint remoteHost, SimpleUdpSG udp)
        {
            simpleUdp = udp;
            if (remoteHost == null)
            {
                throw new Exception("remoteHost is null, unable to send packet");
            }
            byte[] packet = (byte[])this;
            simpleUdp.Send(packet, remoteHost);
        }

        public virtual void Send(IPEndPoint remoteHost)
        {
            if (simpleUdp == null)
                throw new Exception("Unable to use shortcut Send() since the UDP socket is null");
            Send(remoteHost, simpleUdp);
        }

        /// <summary>
        /// Used internally for recursive receives, in order to throw away unexpected packets and 
        /// try again.
        /// </summary>
        /// <param name="timeoutInMs"></param>
        /// <param name="recvAttempts"></param>
        /// <returns></returns>
        protected virtual byte[] RecvHelp(int timeoutInMs, SimpleUdpSG udp, int recvAttempts)
        {
            if (recvAttempts <= 0)
            {
                return null;
            }
            recvBuf = udp.RecvFast(timeoutInMs, out recvSize);
            if (recvBuf != null && recvSize > 0)
            {
                // Make sure this is the type of reply we're expecting before we go blindly filling
                // the WireData structure
                if (!Check())
                {
                    return RecvHelp(timeoutInMs, udp, recvAttempts-1);
                }
                ReadBytes(recvBuf, recvSize);
            }
            return recvBuf;
        }

        /// <summary>
        /// Wait for data to come in on this socket, then serialize the received bytes to this Wiredata
        /// object. It is assumed we are expecting exactly 1 type of packet to come back, so we'll retry
        /// up to a finite number of times if we get an unexpected packet type, as verified by Check().
        /// </summary>
        /// <param name="timeoutInMs"></param>
        /// <returns></returns>
        public virtual byte[] Recv(int timeoutInMs, SimpleUdpSG udp)
        {
            return RecvHelp(timeoutInMs, udp, 8);
        }

        public virtual byte[] Recv(int timeoutInMs)
        {
            if (simpleUdp == null)
                throw new Exception("Unable to use shortcut Recv() since the UDP socket is null");
            return RecvHelp(timeoutInMs, simpleUdp, 8);
        }

        /// <summary>
        /// Converts a SendablePacket to an XspBuffer.  Uses the buffer array to write to, saving an
        /// alloc/copy over using operator byte[].
        /// </summary>
        public static explicit operator XspBuffer (SendablePacket packet)
        {
            XspBuffer ans = null;

            try
            {
                ans = XspBufferManager.Allocate();

                MemoryStream ms = new MemoryStream(ans.RawBuffer);
                packet.WriteStream(new BinaryWriter(ms));

                ans.RawBufferLength = (uint)ms.Position;
            }
            catch
            {
                if (ans != null) { XspBufferManager.Free(ans); }
                throw;
            }

            return ans;
        }
    }

    /// <summary>
    /// All SG based packets will likely extend this, such as SECMSG*, SGMSG*, and KEYEX* messages.
    /// Of course, any packet that has Type and cbEnt fields at the beginning may extend it. Be sure
    /// to set these two fields before serializing into this class, since Check() will use these
    /// fields to verify the incoming byte stream.
    /// </summary>
    public class SGPacket : SendablePacket
    {
        public short                    Type            = 0;                //    See    KEYEX_TYPE_* and SECMSG_TYPE_*
        public short                    cbEnt           = 0;                //    Size of    this entry (including header)

        public const int SIZE = 4;

        public SGPacket()
        {
            cbEnt = SIZE;
        }

        public SGPacket(short type, short cbent)
        {
            Type = type;
            cbEnt = cbent;
        }

        public SGPacket(int type, int cbent)
        {
            Type = (short)type;
            cbEnt = (short)cbent;
        }

        public override bool Check()
        {
            if (this.recvSize < 4)
                return false;

            short type = (short)(recvBuf[0] + (recvBuf[1] << 8));
            short size = (short)(recvBuf[2] + (recvBuf[3] << 8));
            
            if (type != this.Type || size != this.cbEnt)
                return false;

            return true;
        }
      
    }

    #endregion

    #region XspPacket and header

    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class XspHeader : WireData
    {
        public  const uint XSP_TYPE_SEC        = 0; // Packet is in SecMsg format
        public  const uint XSP_TYPE_TCP_0      = 1; // packet is in TCP format (0 byte ports)
        public  const uint XSP_TYPE_TCP_1      = 2; // Packet is in TCP format (1 byte ports)
        public  const uint XSP_TYPE_TCP_2      = 3; // Packet is in TCP format (2 byte ports)
        public  const uint XSP_TYPE_UDP_0      = 4; // packet is in UDP format (0 byte ports)
        public  const uint XSP_TYPE_UDP_1      = 5; // Packet is in UDP format (1 byte ports)
        public  const uint XSP_TYPE_UDP_2      = 6; // Packet is in UDP format (2 byte ports)
        public  const uint XSP_TYPE_VDP_0      = 7; // Packet is in VDP format (0 byte ports)
        public  const uint XSP_TYPE_VDP_1      = 8; // Packet is in VDP format (1 byte ports)
        public  const uint XSP_TYPE_VDP_2      = 9; // Packet is in VDP format (2 byte ports)
        public  const uint XSP_TYPE_VDP_VO_0   = 10; // Packet is in VDP voice-only format (0 byte ports)
        public  const uint XSP_TYPE_VDP_VO_1   = 11; // Packet is in VDP voice-only format (1 byte ports)
        public  const uint XSP_TYPE_VDP_VO_2   = 12; // Packet is in VDP voice-only format (2 byte ports)
        public  const uint XSP_TYPE_VDP_DO_0   = 13; // Packet is in VDP data-only format (0 byte ports)
        public  const uint XSP_TYPE_VDP_DO_1   = 14; // Packet is in VDP data-only format (1 byte ports)
        public  const uint XSP_TYPE_VDP_DO_2   = 15; // Packet is in VDP data-only format (2 byte ports)
        public  const uint XSP_TYPE_MAX        = 15; // Highest packet type defined
        public  const uint XSP_TYPE_MASK       = 0x0F; // Packet type mask
        public  const uint XSP_DATPAD_MASK     = 0xE0; // Payload padding in bytes
        public  const byte XSP_DATPAD_SHIFT    = 5;    // How far left to shift payload padding
        public  const uint XSP_DATPADEX_MASK   = 0x10; // Payload padding (high bit of 16 byte blocks)
        public  const byte XSP_DATPADEX_SHIFT  = 1;    // How far left to shift payload padding

        public  const uint XSP_SPI_MASK        = 0xFFFFFF00; // SPI occupies the top 24 bits
        public  const uint XSP_FLAGS_MASK      = 0x000000FF; // Flags occupies the low 8 bits

        [FuzzData(Probability=1.0, RandomBytes=true)]
        public uint        SpiAndFlags         = 0;

        public XspHeader(int spi)
        {
            SpiAndFlags = (uint)spi;
        }

        public XspHeader(uint spi)
        {
            SpiAndFlags = (uint)spi;
        }

        public XspHeader(byte[] data)
        {
            // data.Length should be >= 4
            SpiAndFlags = (uint)(data[0] + (data[1] << 8) + (data[2] << 16) + (data[3] << 24));
        }

        public uint GetSpi()
        {
            return (SpiAndFlags & XSP_SPI_MASK);
        }

        public uint GetFlags()
        {
            return (SpiAndFlags & XSP_FLAGS_MASK);
        }

        public uint GetPadding()
        {
            return 
                ((SpiAndFlags & XSP_DATPAD_MASK) >> XSP_DATPAD_SHIFT) |
                ((SpiAndFlags & XSP_DATPADEX_MASK) >> XSP_DATPADEX_SHIFT);
        }

        public uint GetXspType()
        {
            return (SpiAndFlags & XSP_TYPE_MASK);
        }

        public void SetPadding(uint bytesOfPadding)
        {
            // Clear out existing pad
            SpiAndFlags &= ~(XSP_DATPAD_MASK | XSP_DATPADEX_MASK);

            // Set padding
            SpiAndFlags |= 
                (bytesOfPadding << XSP_DATPAD_SHIFT) & XSP_DATPAD_MASK |
                (bytesOfPadding << XSP_DATPADEX_SHIFT) & XSP_DATPADEX_MASK;

        }

        public void SetType(uint type)
        {
            // Clear out existing type
            SpiAndFlags &= ~XSP_TYPE_MASK;

            // Set it
            SpiAndFlags |= (type & XSP_TYPE_MASK);
        }
    }

    public class XspPacket : SendablePacket
    {
        // Packet layout:
        //   -- nethdrs, skip for simple packet (this one) --
        //   EnetHdr            (14 bytes)
        //   IpHdr              (20 bytes)
        //   UdpHdr             (8 bytes)
        //   -- begin data --
        //   SpiRecv            (4 bytes)
        //   -- encrypted message --
        //   message            (<= 1464 bytes)
        //   -- tail, encrypted and hashed --
        //   loword(SeqXmit)    (2 bytes)
        //   hiword(SeqXmit)    (2 bytes)
        //   SpiRecv            (4 bytes)
        //   dwZero             (4 bytes, set to 0)

        protected XspHeader     SpiRecv = new XspHeader(0);

        // Either this is set...
        protected SecMsgHeader  secmsg = null;

        // Or this is set (for other, non-SecMsg, XSP packets)
        protected byte[]        datamessage = null;
        protected int           datamessageLength = 0;

        // This is optionally set for non-SecMsg messages.  It will be a UDP or TCP header.
        [WireInfo(ForceSerialize=true)]
        [FuzzArray(Fuzz=true, Probability=0.25, RandomBytes=true, ElementProbability=0.2, LengthProbability=0.1)]
        protected byte[]        extraBytes = null;
        protected ushort        sourcePort = 0;
        protected ushort        destPort = 0;

        // Holds either the encrypted or decrypted XSP packet payload
        [WireInfo(ForceSerialize=true)]
        [FuzzArray(Fuzz=true, Probability=0.25, RandomBytes=true, ElementProbability=0.2, LengthProbability=0.1)]
        protected byte[]        payload;
        protected bool          bIsEncrypted = false;
        
        protected uint          Sequence;
        [WireInfo(ForceSerialize=true)]
        [FuzzData(Fuzz=true, Probability=0.25, RandomBytes=true)]
        protected ushort        SeqLo;
        protected ushort        SeqHi;
        protected BinaryWriter  preTail = null;
        [WireInfo(ForceSerialize=true)]
        [FuzzArray(Fuzz=true, Probability=0.25, RandomBytes=true, ElementProbability=0.2, LengthProbability=0.1)]
        protected byte[]        hashedTail = null;

        protected SecReg        keys;

        public XspHeader SpiHeader
        {
            get { return SpiRecv; }
        }

        public SecMsgHeader SecMsg
        {
            get { return secmsg; }
            set { secmsg = value; }
        }

        public byte[] Message
        {
            get { return datamessage; }
        }

        public int MessageLength 
        {
            get { return datamessageLength; }
        }

        public uint XspType
        {
            get { return SpiRecv.GetXspType(); }
        }

        public uint Padding
        {
            get { return SpiRecv.GetPadding(); }
        }

        public uint SequenceNumber
        {
            get { return Sequence; }
            set 
            { 
                Sequence = value; 
                this.SeqLo = (ushort)(Sequence & 0x0000FFFF);
                this.SeqHi = (ushort)((Sequence >> 16) & 0x0000FFFF);
            }
        }

        public ushort SourcePort
        {
            get { return sourcePort; }
        }

        public ushort DestPort
        {
            get { return destPort; }
        }

        public byte[] Payload
        {
            get { return payload; }
        }

        public byte[] HashedTail
        {
            get { return hashedTail; }
        }

        public void SetSecKeys(SecReg keys)
        {
            this.keys = keys;
            this.SpiHeader.SpiAndFlags = (keys.SpiRecv & XspHeader.XSP_SPI_MASK) | this.XspType;
        }

        /// <summary>
        /// Use this constructor for receiving Xsp packets
        /// </summary>
        /// <param name="keys"></param>
        public XspPacket(SecReg keys)
        {
            this.keys = keys;
        }

        /// <summary>
        /// Use this constructor for any SecMsg type message
        /// </summary>
        /// <param name="msg"></param>
        /// <param name="keys"></param>
        /// <param name="SeqXmit"></param>
        public XspPacket(SecMsgHeader msg, SecReg keys, uint SeqXmit) 
        {
            this.SpiRecv.SpiAndFlags = keys.SpiRecv;
            this.SpiRecv.SetType(XspHeader.XSP_TYPE_SEC);
            this.SequenceNumber = SeqXmit;
            this.keys = keys;

            this.secmsg = msg;
            this.extraBytes = null;
            byte[] msgbytes = (byte[])msg;
            //this.dataPayloadSize = msgbytes.Length;
            Encrypt(msgbytes);
        }

        /// <summary>
        /// Use this constructor for any SecMsg type message. Use for funky messages.
        /// </summary>
        /// <param name="msg"></param>
        /// <param name="keys"></param>
        /// <param name="SeqXmit"></param>
        public XspPacket(byte[] msgBytes, SecReg keys, uint SeqXmit) 
        {
            this.SpiRecv.SpiAndFlags = keys.SpiRecv;
            this.SpiRecv.SetType(XspHeader.XSP_TYPE_SEC);
            this.SequenceNumber = SeqXmit;
            this.keys = keys;

            this.secmsg = null;
            this.extraBytes = null;
            //this.dataPayloadSize = msgBytes == null ? 0 : msgBytes.Length;
            Encrypt((byte[])msgBytes);
        }


        /// <summary>
        /// Use this constructor for sending any non-SecMsg type message. This will automatically build
        /// the extra bytes needed for the UDP_1, UDP_2, etc, header.
        /// </summary>
        /// <param name="msgBytes"></param>
        /// <param name="xspType"></param>
        /// <param name="keys"></param>
        /// <param name="SeqXmit"></param>
        public XspPacket(byte[] msgBytes, uint xspType, int srcPort, int dstPort, SecReg keys, uint SeqXmit)
        {
            this.SpiRecv.SpiAndFlags = keys.SpiRecv;
            this.SpiRecv.SetType(xspType);
            this.SequenceNumber = SeqXmit;
            this.keys = keys;

            this.secmsg = null;
            //this.dataPayloadSize = msgBytes == null ? 0 : msgBytes.Length;
            BuildInsideHeaderBytes((ushort)srcPort, (ushort)dstPort);
            Encrypt(msgBytes);
        }

        public void Clear()
        {
            secmsg = null;
            datamessage = null;
            datamessageLength = 0;
            extraBytes = null;
            sourcePort = 0;
            destPort = 0;
        }

        /// <summary>
        /// Set payload and hashedTail members
        /// </summary>
        /// <param name="message"></param>
        public void Encrypt(byte[] message)
        {
            // Optimistic no-padding situation
            payload = message;

            // Pad up to blocksize byte boundary, required for encryption
            int  pad                = 0;
            int  totalMessageLength = message.Length;
            uint blockSize          = keys.BlockSize;
            if (blockSize > 0)
            {
                pad = (int)(blockSize - (totalMessageLength % blockSize));
                if (pad == blockSize)
                    pad = 0;

                if (pad > 0)
                {
                    // @@@ omg, we should really make this more efficient
                    totalMessageLength += pad;
                    payload = new byte[totalMessageLength];
                    message.CopyTo(payload, 0);
                }

                // If we have extra bytes to add to this message, and there's padding room available,
                // we need to copy the bytes over.
                if (pad > 0 && extraBytes != null && extraBytes.Length > 0)
                {
                    int bytesToCopy = (extraBytes.Length > pad) ? pad : extraBytes.Length;
                    Array.Copy(extraBytes, 0, payload, payload.Length - bytesToCopy, bytesToCopy);
                }
            
                // Calculate the IV
                byte[] abIv = keys.CalcIvAtSeq(keys.IvXmit, Sequence);

                // Encrypt payload
                keys.Crypt(true, abIv, payload, payload.Length);
                bIsEncrypted = true;
            }

            // Set padding in SPI header even if 0
            SpiRecv.SetPadding((uint)pad);

            // Encrypt and hash the tail
            //
            // First build the weird half-tail array
            if (hashedTail == null || preTail == null)
            {
                hashedTail = new byte[10];  // hiword(SeqXmit) [2 bytes] + SPI [4 bytes] + zero [4 bytes]
                preTail = new BinaryWriter(new MemoryStream(8));
            }
            else
            {
                preTail.Seek(0, SeekOrigin.Begin);
            }

            // preTail always includes the SeqLo, SeqHi, and Spi fields
            // It optionally includes the "extra" bytes (tcp, udp headers that don't fit 
            // in the padding)
            // Additionally, we need it to be a multiple of 4 bytes in length
            // or the hash will not match the SG.
            int extraHashZeros = 0;

            if (extraBytes != null && extraBytes.Length > 0)
            {
                int bytesToHash = extraBytes.Length - pad;
                if (bytesToHash > 0)
                {
                    // Only hash the stuff that didn't fit into the padding
                    preTail.Write(extraBytes, pad, bytesToHash);

                    // the number of bytes required to round up to a multiple of 4
                    extraHashZeros = (4 - (bytesToHash & 0x3)) & 0x3;
                }
            }
            preTail.Write(SeqLo);
            preTail.Write(SeqHi);
            preTail.Write(SpiRecv.SpiAndFlags);
            if (extraHashZeros > 0)
            {
                preTail.Write(new byte[4], 0, extraHashZeros);
            }
            byte[] pb1 = (preTail.BaseStream as MemoryStream).ToArray();
            AuthClientBase.XcHmac4(
                keys.KeyShaXmit,
                keys.KeyShaXmit.Length,
                pb1,
                pb1.Length,
                payload,
                payload.Length,
                null, 
                0,
                null,
                0,
                hashedTail,
                hashedTail.Length);
            
        }


        /// <summary>
        /// Sets secmsg and Sequence members
        /// </summary>
        public void Decrypt()
        {
            // Verify SPI is what we expect
            if (SpiRecv.GetSpi() != (this.keys.SpiXmit & XspHeader.XSP_SPI_MASK))
            {
                throw new SGException("Got SECMSG with wrong SPI, expected 0x{0:X}, got 0x{1:X}", keys.SpiXmit, SpiRecv.SpiAndFlags);
            }

            if (keys.Cipher != SecReg.CipherType.NULL)
            {
                // Calculate IV
                byte[] abIv = keys.CalcIvAtSeq(keys.IvRecv, SequenceNumber);

                // Decrypt the data goodness
                this.keys.Crypt(false, abIv, this.payload, this.payload.Length);
            }

            // payload now holds the decrypted message
            bIsEncrypted = false;

            // Trim off padding
//            if (SpiRecv.GetPadding() > 0)
//            {
//                decryptedMessage = new byte[payload.Length - SpiRecv.GetPadding()];
//                Array.Copy(payload, 0, decryptedMessage, 0, decryptedMessage.Length);
//            }

            // Is this a SECMSG*?
            if ((SpiRecv.GetFlags() & XspHeader.XSP_TYPE_MASK) == XspHeader.XSP_TYPE_SEC)
            {
                secmsg = SecMsgHeader.CreatePacket(payload);
            }
                // If not, then it's a UDP*, TCP*, VDP* message
            else
            {   
                this.datamessageLength = (int)(payload.Length - SpiRecv.GetPadding());
                this.datamessage = payload;
            }

            // I don't really care about the tail 
        }

        public static int GetInsideHeaderLength(uint xsptype)
        {
            switch (xsptype)
            {
                case XspHeader.XSP_TYPE_SEC:
                    return 0;
                case XspHeader.XSP_TYPE_UDP_0:
                    return 0;
                case XspHeader.XSP_TYPE_UDP_1: 
                    return 2;
                case XspHeader.XSP_TYPE_UDP_2: 
                    return 4;
                case XspHeader.XSP_TYPE_TCP_0:
                case XspHeader.XSP_TYPE_TCP_1:
                case XspHeader.XSP_TYPE_TCP_2:
                case XspHeader.XSP_TYPE_VDP_0:
                case XspHeader.XSP_TYPE_VDP_1:
                case XspHeader.XSP_TYPE_VDP_2:
                case XspHeader.XSP_TYPE_VDP_DO_0:
                case XspHeader.XSP_TYPE_VDP_DO_1:
                case XspHeader.XSP_TYPE_VDP_DO_2:
                case XspHeader.XSP_TYPE_VDP_VO_0:
                case XspHeader.XSP_TYPE_VDP_VO_1:
                case XspHeader.XSP_TYPE_VDP_VO_2:
                default:
                    throw new SGException("XspType {0} not yet implemented in BuildInsideHeader", xsptype);
            }
        }


        public void BuildInsideHeaderBytes(ushort srcPort, ushort dstPort)
        {
            this.extraBytes = BuildInsideHeader(srcPort, dstPort);
        }

        public byte[] BuildInsideHeader(ushort srcPort, ushort dstPort)
        {
            BinaryWriter bwExtra;
            
            // Save ports
            this.sourcePort = srcPort;
            this.destPort = dstPort;

            int insideHeaderLength = GetInsideHeaderLength(this.XspType);
            switch (this.XspType)
            {
                case XspHeader.XSP_TYPE_SEC:
                    return null;
                case XspHeader.XSP_TYPE_UDP_0:
                    return null;
                case XspHeader.XSP_TYPE_UDP_1: 
                    bwExtra = new BinaryWriter(new MemoryStream(insideHeaderLength));
                    bwExtra.Write((byte)sourcePort);
                    bwExtra.Write((byte)destPort);
                    break;
                case XspHeader.XSP_TYPE_UDP_2: 
                    bwExtra = new BinaryWriter(new MemoryStream(insideHeaderLength));
                    bwExtra.Write((ushort)NetConstants.HTONS((ushort)sourcePort));  // src
                    bwExtra.Write((ushort)NetConstants.HTONS((ushort)destPort));  // dst
                    break;
                case XspHeader.XSP_TYPE_TCP_0:
                case XspHeader.XSP_TYPE_TCP_1:
                case XspHeader.XSP_TYPE_TCP_2:
                case XspHeader.XSP_TYPE_VDP_0:
                case XspHeader.XSP_TYPE_VDP_1:
                case XspHeader.XSP_TYPE_VDP_2:
                case XspHeader.XSP_TYPE_VDP_DO_0:
                case XspHeader.XSP_TYPE_VDP_DO_1:
                case XspHeader.XSP_TYPE_VDP_DO_2:
                case XspHeader.XSP_TYPE_VDP_VO_0:
                case XspHeader.XSP_TYPE_VDP_VO_1:
                case XspHeader.XSP_TYPE_VDP_VO_2:
                default:
                    throw new SGException("XspType {0} not yet implemented in BuildInsideHeader", this.XspType);
            }

            return ((MemoryStream)bwExtra.BaseStream).ToArray();
        }

        public void DeconstructInsideHeader(byte[] header)
        {
            int insideHeaderLength = GetInsideHeaderLength(this.XspType);
            System.Diagnostics.Debug.Assert(header.Length >= insideHeaderLength, "Header length");

            BinaryReader br = new BinaryReader(new MemoryStream(header));
            switch (this.XspType)
            {
                case XspHeader.XSP_TYPE_SEC:
                    break;
                case XspHeader.XSP_TYPE_UDP_0:
                    sourcePort = 1000;
                    destPort = 1000;
                    break;
                case XspHeader.XSP_TYPE_UDP_1:
                    sourcePort = (ushort)(1000 + br.ReadByte());
                    destPort = (ushort)(1000 + br.ReadByte());
                    break;
                case XspHeader.XSP_TYPE_UDP_2: 
                    sourcePort = (ushort)br.ReadInt16();
                    destPort = (ushort)br.ReadInt16();
                    break;
                case XspHeader.XSP_TYPE_TCP_0:
                case XspHeader.XSP_TYPE_TCP_1:
                case XspHeader.XSP_TYPE_TCP_2:
                case XspHeader.XSP_TYPE_VDP_0:
                case XspHeader.XSP_TYPE_VDP_1:
                case XspHeader.XSP_TYPE_VDP_2:
                case XspHeader.XSP_TYPE_VDP_DO_0:
                case XspHeader.XSP_TYPE_VDP_DO_1:
                case XspHeader.XSP_TYPE_VDP_DO_2:
                case XspHeader.XSP_TYPE_VDP_VO_0:
                case XspHeader.XSP_TYPE_VDP_VO_1:
                case XspHeader.XSP_TYPE_VDP_VO_2:
                default:
                    throw new SGException("XspType {0} not yet implemented in DeconstructInsideHeader", this.XspType);
            }

            sourcePort = NetConstants.HTONS(sourcePort);
            destPort = NetConstants.HTONS(destPort);

        }

        public override void WriteStream(BinaryWriter bw)
        {
            WireDataFuzzHelper xspp = new WireDataFuzzHelper(typeof(XspPacket));
            WireDataFuzzHelper xsph = new WireDataFuzzHelper(typeof(XspHeader));

            if (xspp.Fuzz)
            {
                if (!(xsph.Fuzz && xsph.CheckWrite("SpiAndFlags", bw, SpiRecv.SpiAndFlags)))
                {
                    bw.Write(SpiRecv.SpiAndFlags); 
                }

                if (!xspp.CheckWrite("payload", bw, payload))
                {
                    bw.Write(payload);
                }

                // Have extra byte to include between encrypted message and tail?
                if (extraBytes != null)
                {
                    // It's possible the extra bytes fit into the padding.  If not, write it out here.
                    // If so, it's already included in the encrypted message portion.
                    if (Padding < extraBytes.Length)
                    {
                        byte[] temp = new byte[extraBytes.Length - Padding];
                        Buffer.BlockCopy(extraBytes, (int) Padding, temp, 0, temp.Length);

                        if (!xspp.CheckWrite("extraBytes", bw, temp))
                        {
                            bw.Write(temp);
                        }
                    }
                }

                if (!xspp.CheckWrite("SeqLo", bw, SeqLo))
                {
                    bw.Write(SeqLo);
                }

                if (!xspp.CheckWrite("hashedTail", bw, hashedTail))
                {
                    bw.Write(hashedTail);
                }
            }
            else
            {
                bw.Write(this.SpiRecv.SpiAndFlags);
                bw.Write(this.payload);
                // Have extra byte to include between encrypted message and tail?
                if (extraBytes != null)
                {
                    // It's possible the extra bytes fit into the padding.  If not, write it out here.
                    // If so, it's already included in the encrypted message portion.
                    if (Padding < extraBytes.Length)
                    {
                        bw.Write(this.extraBytes, (int) Padding, (int) (extraBytes.Length - Padding));
                    }
                }
                bw.Write(this.SeqLo);
                bw.Write(this.hashedTail);
            }
        }


        public override WireData ReadStream(BinaryReader br)
        {
            uint seq;
            int totalLength = 0;
            int encryptedMessageLength = 0;
            int insideHeaderLength = 0;
            int unencryptedLength = 0;
            byte[] unencryptedBytes = null;
            
            // Read spi so we can determine padding, type, etc
            this.SpiRecv.SpiAndFlags = (uint)br.ReadInt32();

            // Determine lengths
            totalLength = (int)br.BaseStream.Length;
            insideHeaderLength = GetInsideHeaderLength(XspType);
            encryptedMessageLength = totalLength - 4 /* SPI */ - 12 /* tail */;
            if (insideHeaderLength > Padding)
            {
                unencryptedLength = (int)(insideHeaderLength - Padding);
                encryptedMessageLength -= unencryptedLength;
            }
            System.Diagnostics.Debug.Assert((encryptedMessageLength % 8) == 0, "Encrypted message must be a multiple of 8");

            // Read encrypted part            
            this.payload = br.ReadBytes(encryptedMessageLength);

            // Read extra bytes, if present
            if (unencryptedLength > 0)
            {
                unencryptedBytes = br.ReadBytes(unencryptedLength);
            }
            
            // Read tail
            seq = (ushort)br.ReadUInt16();  // loword(SequenceRecv)
            this.hashedTail = br.ReadBytes(10 /* tail */);

            // Build Sequence number and check for wrappage
            // We very likely may reqeive things out of sequence, so be careful
            // when detecting wrappage.
            // Within 0x100 of the border
            if (seq < this.SeqLo && seq < 0x0100 && this.SeqLo > 0xFF00)
            {
                // We've wrapped
                seq += 0x10000;
            }
            // Curse the compiler! It uses ushort by default when adding 2 ushorts,
            // thus we were losing our hi word. And we have to shift. Curses!
            SequenceNumber = (uint)(((uint)this.SeqHi << 16) + (uint)seq);

            Decrypt();

            // Set the inside header, if necessary
            if (insideHeaderLength > 0)
            {
                if (unencryptedLength == 0)
                {
                    // Everything was inside the encrypted packet
                    this.extraBytes = new byte[insideHeaderLength];
                    Array.Copy(
                        this.payload, this.payload.Length - insideHeaderLength, 
                        extraBytes, 0,
                        insideHeaderLength);
                }
                else if (unencryptedLength == insideHeaderLength)
                {
                    // Everything was outside the encrypted packet
                    this.extraBytes = unencryptedBytes;
                }
                else
                {
                    // There's a mix :(
                    int cb1 = insideHeaderLength - unencryptedLength;
                    this.extraBytes = new byte[insideHeaderLength];
                    Array.Copy(
                        this.payload, this.payload.Length - cb1,
                        extraBytes, 0,
                        cb1);
                    Array.Copy(
                        unencryptedBytes, 0,
                        extraBytes, cb1,
                        unencryptedLength);
                }

                // Extract useful information from the inside header / extra bytes
                DeconstructInsideHeader(extraBytes);
            }
            
            return this;
        }


    }

    #endregion

    #region AuthData packets
    [StructLayout(LayoutKind.Sequential, Pack=1)]
    public class XUserID : WireData     // aka XUID
    {
        public ulong                    qwUserID;
        public uint                     dwUserFlags;

        public XUserID () { }

        public XUserID (XUserID toCopy)
        {
            qwUserID = toCopy.qwUserID;
            dwUserFlags = toCopy.dwUserFlags;
        }

        public bool Exists
        {
            get { return (qwUserID != 0); }
        }

        public bool IsGuest
        {
            get { return (UserFlagsUtil.UserGuestNumber(dwUserFlags) != 0); }
            set { dwUserFlags = UserFlagsUtil.SetUserGuestNumber(dwUserFlags, (uint)(value ? 1 : 0)); }
        }

        public uint CountryId
        {
            get { return UserFlagsUtil.UserCountryId(dwUserFlags); }
            set { dwUserFlags = UserFlagsUtil.SetUserCountryId(dwUserFlags, value); }
        }

        public void SetDefaults ()
        {
            qwUserID = NextUserID;
            dwUserFlags = 0x0260676c;
        }

        public static ulong NextUserID
        {
            get
            {
                return SgClient.NextSgPuid | SgClient.k_UserPuidMask;
            }
        }
    }

    public abstract class Authdata_Base : WireDataIncludeBase
    {
        public ushort                   wAuthDataVersion;
        public ushort                   wAuthDataSize;

        public const ushort XONLINE_XBOX2_AUTHDATA_VERSION = 2;
        public const ushort XONLINE_XENON_AUTHDATA_VERSION = 3;
        public const ushort XONLINE_XENON2_AUTHDATA_VERSION = 4;

        public bool IsXbox2 { get { return (this is Authdata_Xbox2); } }
        public bool IsXenon { get { return (this is Authdata_Xenon); } }
        public bool IsXenon2 { get { return (this is Authdata_Xenon2); } }

        public static Authdata_Base NewDefaultOfSameType (Authdata_Base authdata)
        {
            if (authdata.IsXbox2) return new Authdata_Xbox2();
            if (authdata.IsXenon) return new Authdata_Xenon();
            if (authdata.IsXenon2) return new Authdata_Xenon2();

            throw new ArgumentOutOfRangeException("authdata", authdata, "Unknown Authdata version.");
        }

        public static Authdata_Base NewDefaultFromSite (SiteInfo site)
        {
            switch (site.authdataVersion)
            {
                case XONLINE_XBOX2_AUTHDATA_VERSION: return new Authdata_Xbox2();
                case XONLINE_XENON_AUTHDATA_VERSION: return new Authdata_Xenon();
                case XONLINE_XENON2_AUTHDATA_VERSION: return new Authdata_Xenon2();
            }

            throw new ArgumentOutOfRangeException("site", site, "Unknown Authdata version.");
        }

        public abstract ushort MajorVersion { get; set; }
        public abstract ushort MinorVersion { get; set; }
        public abstract ushort BuildNumber { get; set; }
        public abstract ushort QFENumber { get; set; }

        public abstract ulong XboxID { get; set; }
        public abstract uint TitleId { get; set; }
        public abstract uint TitleVersion { get; set; }
        public abstract uint TitleRegion { get; set; }

        public abstract uint AuthDataFlags { get; set; }
        public abstract uint ConsoleRegion { get; set; }
        public abstract uint MediaID { get; set; }
        public abstract ushort LanguageID { get; set; }
        public abstract float[] TrustFactor { get; set; }

        public abstract byte[] Key { get; set; }

        public abstract XUserID GetUser (uint userIndex);
        public abstract void SetUser (uint userIndex, XUserID user);

        public abstract uint[] AltTitleIDs { get; set; }
        public abstract ulong Flowtoken { get; set; }

        public abstract uint[] GetCombinedPrivileges ();
        public abstract void SetCombinedPrivileges (uint[] privileges);

        public abstract void EnableAllBaseServices ();
        public abstract void RemoveAllServices ();
        public virtual ushort AddExtendedService(uint extendedServiceId) { return 0; }
        public virtual ushort RemoveExtendedService(uint extendedServiceId) { return 0; }
        public virtual ushort RemoveExtendedServiceAt(uint index) { return 0; }
    }

    public class UnsupportedAuthdataOperationException : Exception
    {
    }

    public class Authdata_Xbox2 : Authdata_Base
    {
        // XBOX_LIBRARY_VERSION         clientVersion;
        public ushort                   wMajorVersion;
        public ushort                   wMinorVersion;
        public ushort                   wBuildNumber;
        public ushort                   wQFENumber;
        public uint                     dwTitleID;
        public uint                     dwTitleVersion;
        public uint                     dwTitleRegion;

        public ulong                    qwXboxID;
        [WireInfo(ArraySize=4)]
        public XUserID[]                users;// = new XUserID[4];
        public uint                     dwNumServices;
        [WireInfo(ArraySize=12)]
        public uint[]                   dwServiceID = new uint[12];
        [WireInfo(ArraySize=4)]
        public float[]                  afltTrustFactor = new float[4];
        [WireInfo(ArraySize=4)]
        public uint[]                   dwAltTitleID = new uint[4];
        [WireInfo(ArraySize=16)]
        public byte[]                   abKey = new byte[16];

        public const int SIZE = 180;

        public override ushort MajorVersion { get { return wMajorVersion; } set { wMajorVersion = value; } }
        public override ushort MinorVersion { get { return wMinorVersion; } set { wMinorVersion = value; } }
        public override ushort BuildNumber { get { return wBuildNumber; } set { wBuildNumber = value; } }
        public override ushort QFENumber { get { return wQFENumber; } set { wQFENumber = value; } }

        public override ulong XboxID { get { return qwXboxID; } set { qwXboxID = value; } }
        public override uint TitleId { get { return dwTitleID; } set { dwTitleID = value; } }
        public override uint TitleVersion { get { return dwTitleVersion; } set { dwTitleVersion = value; } }
        public override uint TitleRegion { get { return dwTitleRegion; } set { dwTitleRegion = value; } }

        public override uint AuthDataFlags { get { throw new UnsupportedAuthdataOperationException(); } set { throw new UnsupportedAuthdataOperationException(); } } //doesn't exist here
        public override uint ConsoleRegion { get { throw new UnsupportedAuthdataOperationException(); } set { throw new UnsupportedAuthdataOperationException(); } } //doesn't exist here
        public override uint MediaID { get { throw new UnsupportedAuthdataOperationException(); } set { throw new UnsupportedAuthdataOperationException(); } } //doesn't exist here
        public override ushort LanguageID { get { throw new UnsupportedAuthdataOperationException(); } set { throw new UnsupportedAuthdataOperationException(); } } //doesn't exist here
        public override float[] TrustFactor { get { return afltTrustFactor; } set { afltTrustFactor = value; } }

        public override byte[] Key { get { return abKey; } set { abKey = value; } }

        public override XUserID GetUser(uint userIndex)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex", userIndex, "userIndex must be between 0 and 3");
            }

            return users[userIndex];
        }

        public override void SetUser (uint userIndex, XUserID user)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex", userIndex, "userIndex must be between 0 and 3");
            }

            users[userIndex] = new XUserID(user);
        }

        public override uint[] AltTitleIDs
        {
            get { return dwAltTitleID; }
            set { dwAltTitleID = value; }
        }

        public override ulong Flowtoken
        {
            get { return 0; }
            set { throw new UnsupportedAuthdataOperationException(); }
        }

        public override uint[] GetCombinedPrivileges()
        {
            throw new UnsupportedAuthdataOperationException(); //ad2 doesn't contain privileges
        }

        public override void SetCombinedPrivileges (uint[] privileges)
        {
            throw new UnsupportedAuthdataOperationException(); //ad2 doesn't contain privileges
        }

        public override void EnableAllBaseServices ()
        {
            throw new UnsupportedAuthdataOperationException(); //not sure what the list of all base services is for ad2
        }

        public override void RemoveAllServices ()
        {
            dwNumServices = 0;
            for (int i = 0; i < dwServiceID.Length; ++i)
            {
                dwServiceID[i] = 0;
            }
        }

        public override string ToString ()
        {
            int i;
            System.Text.StringBuilder sb = new StringBuilder(500);
            sb.Append("Authdata_Xbox2:\n");
            sb.Append("       Version: " + base.wAuthDataVersion + ", " + base.wAuthDataSize + " bytes\n");
            sb.Append("     ClientVer: " + wMajorVersion + "." + wMinorVersion + "." + wBuildNumber + "." + wQFENumber + "\n");
            sb.Append("         Title: id 0x" + dwTitleID.ToString("X8") + ", ver 0x" + dwTitleVersion.ToString("X8") + ", region " + dwTitleRegion + "\n");
            sb.Append("  Machine PUID: 0x" + qwXboxID.ToString("X16") + "\n");
            for (i = 0; i < 4; i++)
            {
                sb.Append("       User[" + i + "]: 0x" + users[i].qwUserID.ToString("X16") + ", flags 0x" + users[i].dwUserFlags.ToString("X8") + "\n");
            }
            sb.Append("      Services: [" + dwNumServices + "]");
            for (i = 0; i < dwNumServices; i++)
            {
                sb.Append(" " + dwServiceID[i]);
            }
            sb.Append("\n");
            sb.Append("         Trust: 0:" + afltTrustFactor[0] + " 1:" + afltTrustFactor[1] + " 2:" + afltTrustFactor[2] + " 3:" + afltTrustFactor[3] + "\n");
            sb.Append("    AltTitleId: 0:0x" + dwAltTitleID[0].ToString("X8") + " 1:0x" + dwAltTitleID[1].ToString("X8") + " 2:0x" + dwAltTitleID[2].ToString("X8") + " 3:0x" + dwAltTitleID[3].ToString("X8") + "\n");
            sb.Append("           Key: " + ServerTestFramework.Utilities.Hexer.tohex(abKey) + "\n");
            return sb.ToString();
        }

    }

    public class Authdata_Xenon : Authdata_Base
    {
        public const uint FLAGS_ISXENON             = 0x01;
        public const uint FLAGS_ISXENONBACKCOMPAT   = 0x02;
        public const uint FLAGS_ISDEVKIT            = 0x04;
        public const uint FLAGS_ISTESTKIT           = 0x08;
        public const uint FLAGS_ISBETAMACHINE       = 0x10;
        public const uint FLAGS_ISLIMITEDMACHINE    = 0x20;


        // XBOX_LIBRARY_VERSION         clientVersion;
        public ushort                   wMajorVersion;
        public ushort                   wMinorVersion;
        public ushort                   wBuildNumber;
        public ushort                   wQFENumber;
        public uint                     dwTitleID;
        public uint                     dwTitleVersion;
        public uint                     dwTitleRegion;

        public uint                     dwConsoleRegion;
        public uint                     dwMediaID;
        public ushort                   wLanguageID;
        public uint                     dwAuthDataFlags;
        public ushort                   wNumPrivileges;
        [WireInfo(ArraySize=8)]
        public uint[]                   dwPrivileges = new uint[8];
        public ulong                    qwXboxID;
        [WireInfo(ArraySize=4)]
        public XUserID[]                users;// = new XUserID[4];
        [WireInfo(ArraySize=4)]
        public float[]                  afltTrustFactor = new float[4];
        public ushort                   wNumDwordServices;
        [WireInfo(ArraySize=4)]
        public uint[]                   dwServiceID = new uint[4];
        [WireInfo(ArraySize=4)]
        public uint[]                   dwAltTitleID = new uint[4];
        [WireInfo(ArraySize=16)]
        public byte[]                   abKey = new byte[16];

        public const int SIZE = 194;

        public override ushort MajorVersion { get { return wMajorVersion; } set { wMajorVersion = value; } }
        public override ushort MinorVersion { get { return wMinorVersion; } set { wMinorVersion = value; } }
        public override ushort BuildNumber { get { return wBuildNumber; } set { wBuildNumber = value; } }
        public override ushort QFENumber { get { return wQFENumber; } set { wQFENumber = value; } }

        public override ulong XboxID { get { return qwXboxID; } set { qwXboxID = value; } }
        public override uint TitleId { get { return dwTitleID; } set { dwTitleID = value; } }
        public override uint TitleVersion { get { return dwTitleVersion; } set { dwTitleVersion = value; } }
        public override uint TitleRegion { get { return dwTitleRegion; } set { dwTitleRegion = value; } }

        public override uint AuthDataFlags { get { return dwAuthDataFlags; } set { dwAuthDataFlags = value; } }
        public override uint ConsoleRegion { get { return dwConsoleRegion; } set { dwConsoleRegion = value; } }
        public override uint MediaID { get { return dwMediaID; } set { dwMediaID = value; } }
        public override ushort LanguageID { get { return wLanguageID; } set { wLanguageID = value; } }
        public override float[] TrustFactor { get { return afltTrustFactor; } set { afltTrustFactor = value; } }

        public override byte[] Key { get { return abKey; } set { abKey = value; } }

        public override XUserID GetUser(uint userIndex)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex", userIndex, "userIndex must be between 0 and 3");
            }

            return users[userIndex];
        }

        public override void SetUser (uint userIndex, XUserID user)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex", userIndex, "userIndex must be between 0 and 3");
            }

            users[userIndex] = new XUserID(user);
        }

        public override uint[] AltTitleIDs
        {
            get { return dwAltTitleID; }
            set { dwAltTitleID = value; }
        }

        public override ulong Flowtoken
        {
            get { return 0; }
            set { throw new UnsupportedAuthdataOperationException(); }
        }

        public override uint[] GetCombinedPrivileges()
        {
            return dwPrivileges;
        }

        public override void SetCombinedPrivileges (uint[] privileges)
        {
            Array.Copy(privileges, dwPrivileges, dwPrivileges.Length);
            SetPrivilegeCount();
        }

        public override void EnableAllBaseServices ()
        {
            // at the time AD3 was used, this was the complete list of base services
            // we may decide to enable more here as appropriate
            dwPrivileges[0] = 0x7ffffffe;
            // HEY, WHEN YOU ARE INTEGRATING THIS WITH MAIN, UNCOMMENT!
            //SetPrivilegeCount();
        }

        public override void RemoveAllServices ()
        {
            // privilege services (base)
            for (int i = 0; i < 4; ++i)
            {
                dwPrivileges[i] = 0;
            }
            SetPrivilegeCount();

            // extended services
            wNumDwordServices = 0;
            for (int i = 0; i < dwServiceID.Length; ++i)
            {
                dwServiceID[i] = 0;
            }
        }

        private void SetPrivilegeCount ()
        {
            wNumPrivileges = 0;
            for (int i = 0; i < dwPrivileges.Length; ++i)
            {
                uint privs = dwPrivileges[i];

                while (privs != 0)
                {
                    privs &= privs - 1;
                    ++wNumPrivileges;
                }
            }
        }

        public override string ToString ()
        {
            int i;
            System.Text.StringBuilder sb = new StringBuilder(500);
            sb.Append("Authdata_Xenon:\n");
            sb.Append("       Version: " + base.wAuthDataVersion + ", " + base.wAuthDataSize + " bytes\n");
            sb.Append("     ClientVer: " + wMajorVersion + "." + wMinorVersion + "." + wBuildNumber + "." + wQFENumber + "\n");
            sb.Append("         Title: id 0x" + dwTitleID.ToString("X8") + ", ver 0x" + dwTitleVersion.ToString("X8") + ", region " + dwTitleRegion + "\n");
            sb.Append("       Console: ConsoleRegion " + dwConsoleRegion + ", MediaID " + dwMediaID + ", LanguageID " + wLanguageID + "\n");
            sb.Append(" AuthDataFlags: " + dwAuthDataFlags + "\n");
            sb.Append(" NumPrivileges: " + wNumPrivileges + "\n");
            for (i = 0; i < dwPrivileges.Length; i++)
            {
                sb.Append(" Privileges[" + i + "]: 0x" + dwPrivileges[i].ToString("X8") + "\n");
            }
            sb.Append("  Machine PUID: 0x" + qwXboxID.ToString("X16") + "\n");
            for (i = 0; i < 4; i++)
            {
                sb.Append("       User[" + i + "]: 0x" + users[i].qwUserID.ToString("X16") + ", flags 0x" + users[i].dwUserFlags.ToString("X8") + "\n");
            }
            sb.Append("         Trust: 0:" + afltTrustFactor[0] + " 1:" + afltTrustFactor[1] + " 2:" + afltTrustFactor[2] + " 3:" + afltTrustFactor[3] + "\n");
            sb.Append(" DwordServices: [" + wNumDwordServices + "] 0x" + dwServiceID[0].ToString("X8") + ", 0x" + dwServiceID[1].ToString("X8") + ", 0x" + dwServiceID[2].ToString("X8") + ", 0x" + dwServiceID[3].ToString("X8") + "\n");
            sb.Append("    AltTitleId: 0:0x" + dwAltTitleID[0].ToString("X8") + " 1:0x" + dwAltTitleID[1].ToString("X8") + " 2:0x" + dwAltTitleID[2].ToString("X8") + " 3:0x" + dwAltTitleID[3].ToString("X8") + "\n");
            sb.Append("           Key: " + ServerTestFramework.Utilities.Hexer.tohex(abKey) + "\n");
            return sb.ToString();
        }
    }

    public class Authdata_Xenon2 : Authdata_Base
    {
        public const uint FLAGS_ISXENON = 0x01;
        public const uint FLAGS_ISXENONBACKCOMPAT = 0x02;
        public const uint FLAGS_ISDEVKIT = 0x04;
        public const uint FLAGS_ISTESTKIT = 0x08;
        public const uint FLAGS_ISBETAMACHINE = 0x10;
        public const uint FLAGS_ISLIMITEDMACHINE = 0x20;


        // XBOX_LIBRARY_VERSION         clientVersion;
        public ushort wMajorVersion;
        public ushort wMinorVersion;
        public ushort wBuildNumber;
        public ushort wQFENumber;

        public uint dwAuthDataFlags;
        public ulong qwXboxID;
        public float fltConsoleTrustFactor;

        public uint dwTitleID;
        public uint dwTitleVersion;
        public uint dwTitleRegion;
        public uint dwConsoleRegion;
        public uint dwMediaID;
        public ushort wLanguageID;

        public ushort wNumExtendedServices;
        [WireInfo(ArraySize = 4)]
        public uint[] dwExtendedServices = new uint[4];

        [WireInfo(ArraySize = 4)]
        public XUserID[] users;// = new XUserID[4];
        [WireInfo(ArraySize = 4)]
        public float[] afltTrustFactor = new float[4];

        [WireInfo(ArraySize = 4)]
        public uint[] dwBaseServices = new uint[4];
        [WireInfo(ArraySize = 1)]
        public uint[] dwMachinePrivileges = new uint[1];
        [WireInfo(ArraySize = 12)] // 3 uints for each of 4 users
        public uint[] dwUserPrivileges = new uint[12];

        [WireInfo(ArraySize = 4)]
        public uint[] dwAltTitleID = new uint[4];
        public ulong flowToken;
        [WireInfo(ArraySize = 16)]
        public byte[] abReserved = new byte[16];
        [WireInfo(ArraySize = 16)]
        public byte[] abKey = new byte[16];

        public const int SIZE = 256;

        public override ushort MajorVersion { get { return wMajorVersion; } set { wMajorVersion = value; } }
        public override ushort MinorVersion { get { return wMinorVersion; } set { wMinorVersion = value; } }
        public override ushort BuildNumber { get { return wBuildNumber; } set { wBuildNumber = value; } }
        public override ushort QFENumber { get { return wQFENumber; } set { wQFENumber = value; } }

        public override ulong XboxID { get { return qwXboxID; } set { qwXboxID = value; } }
        public override uint TitleId { get { return dwTitleID; } set { dwTitleID = value; } }
        public override uint TitleVersion { get { return dwTitleVersion; } set { dwTitleVersion = value; } }
        public override uint TitleRegion { get { return dwTitleRegion; } set { dwTitleRegion = value; } }

        public override uint AuthDataFlags { get { return dwAuthDataFlags; } set { dwAuthDataFlags = value; } }
        public override uint ConsoleRegion { get { return dwConsoleRegion; } set { dwConsoleRegion = value; } }
        public override uint MediaID { get { return dwMediaID; } set { dwMediaID = value; } }
        public override ushort LanguageID { get { return wLanguageID; } set { wLanguageID = value; } }
        public override float[] TrustFactor { get { return afltTrustFactor; } set { afltTrustFactor = value; } }

        public override byte[] Key { get { return abKey; } set { abKey = value; } }

        public override XUserID GetUser(uint userIndex)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex", userIndex, "userIndex must be between 0 and 3");
            }

            return users[userIndex];
        }

        public override void SetUser (uint userIndex, XUserID user)
        {
            if (userIndex > 3)
            {
                throw new ArgumentOutOfRangeException("userIndex", userIndex, "userIndex must be between 0 and 3");
            }

            users[userIndex] = new XUserID(user);
        }

        public override uint[] AltTitleIDs
        {
            get { return dwAltTitleID; }
            set { dwAltTitleID = value; }
        }

        public override ulong Flowtoken
        {
            get { return flowToken; }
            set { flowToken = value; }
        }

        public override void EnableAllBaseServices ()
        {
            // Still don't use 0, but otherwise turn them all on
            dwBaseServices[0] = 0xFFFFFFFE;
            dwBaseServices[1] = dwBaseServices[2] = dwBaseServices[3] = 0xFFFFFFFF;
        }

        public override void RemoveAllServices ()
        {
            // extended services
            wNumExtendedServices = 0;
            for (int i = 0; i < dwExtendedServices.Length; ++i)
            {
                dwExtendedServices[i] = 0;
            }

            // base services
            for (int i = 0; i < dwBaseServices.Length; ++i)
            {
                dwBaseServices[i] = 0;
            }
        }

        public override ushort AddExtendedService (uint extendedServiceId)
        {
            if (wNumExtendedServices >= dwExtendedServices.Length)
            {
                throw new InvalidOperationException("Extended services list is already full.  Unable to add server 0x" + extendedServiceId.ToString("X8"));
            }

            dwExtendedServices[wNumExtendedServices] = extendedServiceId;
            return wNumExtendedServices++;
        }

        public override ushort RemoveExtendedService(uint extendedServiceId)
        {
            bool found = false;
            for (int i = 0; i < wNumExtendedServices; i++)
            {
                if(found)
                {
                    dwExtendedServices[i - 1] = dwExtendedServices[i];
                }
                else if (dwExtendedServices[i] == extendedServiceId)
                {
                    found = true;
                    dwExtendedServices[i] = 0;
                }
            }

            return wNumExtendedServices--;
        }

        public override ushort RemoveExtendedServiceAt(uint index)
        {
            return RemoveExtendedService(dwExtendedServices[index]);
        }

        public uint[] GetPrivileges(uint userIndex)
        {
            // This is the combined privilege set for a given user
            uint[] privileges = new uint[8];
            Array.Copy(dwBaseServices, privileges, 4); // Bytes 0,1,2,3
            Array.Copy(dwMachinePrivileges, 0, privileges, 4, 1); // Byte 4
            Array.Copy(dwUserPrivileges, userIndex * 3, privileges, 5, 3); // Bytes 5,6,7

            return privileges;
        }

        public override void SetCombinedPrivileges (uint[] privileges)
        {
            Array.Copy(privileges, dwBaseServices, dwBaseServices.Length);
            Array.Copy(privileges, dwBaseServices.Length, dwMachinePrivileges, 0, dwMachinePrivileges.Length);
            for (int i = 0; i < 4; ++i)
            {
                Array.Copy(privileges, dwBaseServices.Length + dwMachinePrivileges.Length, dwUserPrivileges, 3 * i, 3);
            }
        }

        public void SetPrivileges(uint userIndex, uint[] privileges)
        {
            Array.Copy(privileges, 0, dwBaseServices, 0, 4);
            Array.Copy(privileges, 4, dwMachinePrivileges, 0, 1);
            Array.Copy(privileges, 5, dwUserPrivileges, userIndex * 3, 3);
        }

        public void SetPrivileges(uint[] privileges)
        {
            for (uint i = 0; i < 4; i++)
            {
                if (users[i].qwUserID != 0)
                {
                    SetPrivileges(i, privileges);
                }
            }
        }

        public void SetPrivileges(uint userIndex, uint privilegeDword, uint privilegeIndex)
        {
            if (privilegeIndex <= 3)
            {
                dwBaseServices[privilegeIndex] = privilegeDword;
            }
            else if (privilegeIndex <= 4)
            {
                dwMachinePrivileges[privilegeIndex - 4] = privilegeDword;
            }
            else if (privilegeIndex <= 5)
            {
                dwUserPrivileges[userIndex * 3 + (privilegeIndex - 5)] = privilegeDword;
            }
        }

        public void SetPrivileges(uint privilegeDword, uint priviledgeIndex)
        {
            for (uint i = 0; i < 4; i++)
            {
                if (users[i].qwUserID != 0)
                {
                    SetPrivileges(i, privilegeDword, priviledgeIndex);
                }
            }
        }

        public uint[] GetMachinePrivileges()
        {
            uint[] privileges = new uint[8];
            Array.Copy(dwMachinePrivileges, 0, privileges, 4, 1); // Byte 4
            return privileges;
        }

        public uint[] GetServices()
        {
            uint[] privileges = new uint[8];
            Array.Copy(dwBaseServices, privileges, 4); // Bytes 0,1,2,3
            return privileges;
        }

        public override uint[] GetCombinedPrivileges()
        {
            //simulate ad3 combined privileges
            uint[] privileges = new uint[8];
            Array.Copy(dwBaseServices, privileges, 4); // Bytes 0,1,2,3
            Array.Copy(dwMachinePrivileges, 0, privileges, 4, 1); // Byte 4

            bool haveBaseUserPrivsSet=false;
            for (int user=0; user<4; ++user)
            {
                if (users[user].qwUserID!=0)
                {
                    if (!haveBaseUserPrivsSet)
                    {
                        haveBaseUserPrivsSet=true;
                        Array.Copy(dwUserPrivileges, user*3, privileges, 5, 3); // Bytes 5,6,7
                    }
                    else
                    {
                        for (int byteNumber=5; byteNumber<8; ++byteNumber)
                        {
                            privileges[byteNumber]&=dwUserPrivileges[user*3+byteNumber];
                        }
                    }
                }
            }

            return privileges;
        }

        public override string ToString()
        {
            int i;
            System.Text.StringBuilder sb = new StringBuilder(500);
            sb.Append("Authdata_Xenon2:\n");
            sb.Append("       Version: " + base.wAuthDataVersion + ", " + base.wAuthDataSize + " bytes\n");
            sb.Append("     ClientVer: " + wMajorVersion + "." + wMinorVersion + "." + wBuildNumber + "." + wQFENumber + "\n");
            sb.Append(" AuthDataFlags: " + dwAuthDataFlags + "\n");
            sb.Append("  Machine PUID: 0x" + qwXboxID.ToString("X16") + "\n");
            sb.Append(" Console Trust: " + fltConsoleTrustFactor + "\n");
            sb.Append("         Title: id 0x" + dwTitleID.ToString("X8") + ", ver 0x" + dwTitleVersion.ToString("X8") + ", region " + dwTitleRegion + "\n");
            sb.Append("       Console: ConsoleRegion " + dwConsoleRegion + ", MediaID " + dwMediaID + ", LanguageID " + wLanguageID + "\n");
            sb.Append("        Floken: " + new Floken(flowToken).ToString() + "\n");

            sb.Append("   ExtServices: [" + wNumExtendedServices + "] 0x" + dwExtendedServices[0].ToString("X8") + ", 0x" + dwExtendedServices[1].ToString("X8") + ", 0x" + dwExtendedServices[2].ToString("X8") + ", 0x" + dwExtendedServices[3].ToString("X8") + "\n");
            for (i = 0; i < 4; i++)
            {
                sb.Append("       User[" + i + "]: 0x" + users[i].qwUserID.ToString("X16") + ", flags 0x" + users[i].dwUserFlags.ToString("X8") + "\n");
            }
            sb.Append("         Trust: 0:" + afltTrustFactor[0] + " 1:" + afltTrustFactor[1] + " 2:" + afltTrustFactor[2] + " 3:" + afltTrustFactor[3] + "\n");

            sb.AppendFormat(" BaseServices:  [4] 0x{0:X8}, 0x{1:X8}, 0x{2:X8}, 0x{3:X8}\n", dwBaseServices[0], dwBaseServices[1], dwBaseServices[2], dwBaseServices[3]);
            sb.AppendFormat("  MachinePriv:  [1] 0x{0:X8}\n", dwMachinePrivileges[0]);
            for (i = 0; i < 4; i++)
            {
                sb.AppendFormat("  UserPriv[{0}]: 0x{1:X8}, 0x{2:X8}, 0x{3:X8}\n", i, dwUserPrivileges[i * 3], dwUserPrivileges[i * 3 + 1], dwUserPrivileges[i * 3 + 2]);
            }

            sb.Append("    AltTitleId: 0:0x" + dwAltTitleID[0].ToString("X8") + " 1:0x" + dwAltTitleID[1].ToString("X8") + " 2:0x" + dwAltTitleID[2].ToString("X8") + " 3:0x" + dwAltTitleID[3].ToString("X8") + "\n");
            sb.Append("           Key: " + ServerTestFramework.Utilities.Hexer.tohex(abKey) + "\n");
            return sb.ToString();
        }
    }

    #endregion

    #region KeyExchange packets

    public class SGAddress : WireData
    {
        public const int XPLT_XBOX1     = 0;
        public const int XPLT_XBOX360   = 1;
        public const int XPLT_PC        = 2;

        public IpAddr                   SgIP            = new IpAddr();         // IP address of the SG for the client
        public int                      SpiSg           = 0;                    // Pseudo-random identifier assigned by the SG
        public ulong                    XboxID          = 0;                    // Unique identifier of client machine account
        public byte                     Platform        = 0;                    // See XPLT_* above
        [WireInfo(ArraySize=3)]
        public byte[]                   Reserved        = new byte[3];          // Reserved (must be zero)

        public const int SIZE = 20;

        public override string ToString()
        {
            return String.Format("IP:{0}, SPI:0x{1:X}, XboxID:0x{2:X}, Platform:0x{3:X}", SgIP.ToString(), SpiSg, XboxID, Platform);
        }

        public static bool operator ==(SGAddress a, SGAddress b)
        {
            if (System.Object.ReferenceEquals(a, b))
                return true;
            if ((Object)a == null || (Object)b == null)
                return false;
            return 
                (a.SgIP.S_addr == b.SgIP.S_addr) &&
                (a.SpiSg == b.SpiSg) &&
                (a.XboxID == b.XboxID) &&
                (a.Platform == b.Platform);
        }

        public static bool operator !=(SGAddress a, SGAddress b)
        {
            return !(a == b);
        }
    }

    public class KeyExchangeHeader : SGPacket
    {
        // Definitions (0x58 is    'X') ---------------------------------------------------------
        public const int    KEYEX_VERSION               = 0x0000;   //  Current KeyExchange version
        public const int    KEYEX_TYPE_XBTOXB_INIT      = 0x5800;   //  CKeyExchangeXbToXb | DH_GX | HMAC_SHA
        public const int    KEYEX_TYPE_XBTOXB_RESP      = 0x5801;   //  CKeyExchangeXbToXb | DH_GX | HMAC_SHA
        public const int    KEYEX_TYPE_XBTOSG_INIT      = 0x5802;   //  CKeyExchangeXbToSgInit | DH_GX | APREQ
        public const int    KEYEX_TYPE_SGTOXB_RESP      = 0x5803;   //  CKeyExchangeSgToXbResp | DH_GX | APREP
        public const int    KEYEX_TYPE_NATOPEN_INIT     = 0x5804;   //  CKeyExchangeNatOpen
        public const int    KEYEX_TYPE_NATOPEN_RESP     = 0x5805;   //  CKeyExchangeNatOpen
        public const int    KEYEX_TYPE_QOS_INIT         = 0x5806;   //  CKeyExchangeQosInit
        public const int    KEYEX_TYPE_QOS_RESP         = 0x5807;   //  CKeyExchangeQosResp
        public const int    KEYEX_TYPE_XBTOTS_INIT      = 0x5808;   //  CKeyExchangeXbToTs | APREQ
        public const int    KEYEX_TYPE_TSTOXB_RESP      = 0x5809;   //  CKeyExchangeTsToXb | APREP
        public const int    KEYEX_TYPE_DH_GX            = 0x5880;   //  diffie-hellman g^X (or g^Y)
        public const int    KEYEX_TYPE_HMAC_SHA         = 0x5881;   //  HMAC-SHA-1 digest (XbToXb)
        public const int    KEYEX_TYPE_KERB_APREQ       = 0x5882;   //  CKeyExchangeKerbApReq (XbToSg)
        public const int    KEYEX_TYPE_KERB_APREP       = 0x5883;   //  CKeyExchangeKerbApRep (SgToXb)
        public const int    KEYEX_TYPE_NULL_APREP       = 0x5885;   //  CKeyExchangeNullApRep (SgToXb; insecure; test only)
        public const int    KEYEX_TYPE_PADDING          = 0x5886;   //  random padding to make packet larger
        public const int    KEYEX_TYPE_SGTOXB_CHAL      = 0x5887;   //  CKeyExchangeSgToXbChal
        public const int    KEYEX_TYPE_NULL_APREQ2      = 0x5888;   //  CKeyExchangeNullApReq2 (XbToSg; insecure; test only)

        public KeyExchangeHeader(int type, int cbent) : base(type, cbent)
        {
        }
        
        public static KeyExchangeHeader CreatePacket(byte[] data)
        {
            int type = 0;
            KeyExchangeHeader packet = null;

            if (data == null || data.Length < 4)
            {
                throw new SGException("CreatePacket failed, data is too short or null");
            }
            type = (int)(data[0] + (data[1] << 8));

            switch (type)
            {
                case KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP:
                    packet = new KeyExchangeInitResponse();
                    break;
                case KeyExchangeHeader.KEYEX_TYPE_SGTOXB_CHAL:
                    packet = new KeyExchangeSgToXbChallenge();
                    break;
                default:
                    throw new SGException("Don't know how to create packet of type 0x{0:X}, data.Length={1}", type, data.Length);
            }

            packet.ReadBytes(data);
            return packet;
        }

    }

    public class KeyExchangeSgToXbChallenge : KeyExchangeHeader
    {
        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_SGTOXB_CHAL;
        //public short                    cbEnt           = (short)SIZE;
        public uint                     DvdBlock        = 0;        // DVD block to read
        public short                    DvdHashOffset   = 0;        // Offset in block to start hashing
        public short                    DvdCopyOffset   = 0;        // Offset in block to start copying
        [WireInfo(ArraySize=16)]
        public byte[]                    Params          = new byte[16];     // Challenge parameters
        [WireInfo(ArraySize=PkSigSize)]
        public byte[]                    PkSig           = new byte[PkSigSize];    // Digest of the rest of this entry
        
        // The rest of this entry is filled with challenge code that needs to be run
        // on the challenged xbox.  The result of running the code will be to modify
        // the 256 bytes immediately preceeding it (where the _abPkSig is above).
        // The size of the entry must be a multiple of 8 bytes because it is encrypted
        // during transport.

        [WireInfo(ArraySize=0)]
        public byte[]                   ChalCode        = null;

        public const int PkSigSize = 256;
        public const int SIZE_WITHOUT_PKSIG = KeyExchangeHeader.SIZE + 24;
        public new const int SIZE = SIZE_WITHOUT_PKSIG + PkSigSize;

        public KeyExchangeSgToXbChallenge() : base(KeyExchangeHeader.KEYEX_TYPE_SGTOXB_CHAL, SIZE)
        {
        }

        public override WireData ReadStream(BinaryReader br)
        {
            // we get to assume these
            this.Type           = (short)br.ReadInt16();
            this.cbEnt          = (short)br.ReadInt16();
            this.DvdBlock       = (uint)br.ReadInt32();
            this.DvdHashOffset  = (short)br.ReadInt16();
            this.DvdCopyOffset  = (short)br.ReadInt16();
            this.Params         = (byte[])br.ReadBytes(16);

            int remaining = cbEnt - SIZE_WITHOUT_PKSIG;
            this.PkSig          = (byte[])br.ReadBytes(Math.Min(remaining, PkSigSize));

            if (remaining > PkSigSize)
            {
                this.ChalCode   = (byte[])br.ReadBytes(remaining - PkSigSize);
            }

            return this;
        }

        public void Decrypt(SecReg keys)
        {
            // Everything but the Type and cbEnt fields are encrypted
            int blobsize = cbEnt - 4;
            byte[] blob = new byte[blobsize];
            BinaryWriter bw = new BinaryWriter(new MemoryStream(blob));
            bw.Write(DvdBlock);
            bw.Write(DvdHashOffset);
            bw.Write(DvdCopyOffset);
            bw.Write(Params);
            bw.Write(PkSig);
            if (ChalCode != null)
                bw.Write(ChalCode);

            // Decrypt the data goodness
            // If connection is using DES or DES3, this will be encrypted with DES3.  
            // Otherwise, it will be AES.
            if (keys.Cipher == SecReg.CipherType.DES ||
                keys.Cipher == SecReg.CipherType.DES3)
            {
                keys.CryptWithCipher(false, SecReg.CipherType.DES3, keys.NonceResp, blob, (uint)blobsize, null, 0);
            }
            else
            {
                // IV is NonceInit + NonceResp (16 bytes)
                byte[] iv = new byte[16];
                Array.Copy(keys.NonceInit, 0, iv, 0, 8);
                Array.Copy(keys.NonceResp, 0, iv, 8, 8);
                keys.CryptWithCipher(false, SecReg.CipherType.AES, iv, blob, (uint)blobsize, null, 0);
            }

            // blob is now unencrypted, put decrypted data back in place
            BinaryReader br = new BinaryReader(new MemoryStream(blob));
            this.DvdBlock       = (uint)br.ReadInt32();
            this.DvdHashOffset  = (short)br.ReadInt16();
            this.DvdCopyOffset  = (short)br.ReadInt16();
            this.Params         = (byte[])br.ReadBytes(16);

            int remaining = cbEnt - SIZE_WITHOUT_PKSIG;
            this.PkSig          = (byte[])br.ReadBytes(Math.Min(remaining, PkSigSize));

            if (this.ChalCode != null)
                this.ChalCode   = (byte[])br.ReadBytes(ChalCode.Length);
        }

        public override string ToString()
        {
            return String.Format("Type=0x{0:X4}, Size={1}, Params={2}, PkSig={3}, ChalCode={4}",
                                 Type,
                                 cbEnt,
                                 Hexer.tohex(Params),
                                 Hexer.tohex(PkSig),
                                 Hexer.tohex(ChalCode));
        }


    }

    public class KeyExchangeInit : KeyExchangeHeader
    {
        // Definitions -----------------------------------------------------------------------
        public const int                XSIF_CONNECTION_SERVICE            = 0x0001;   // Initiator requests    connection service
        public const int                KEYEX_USER_GUEST_MASK           = 0x1F; 
        public const int                KEYEX_USER_PERMUTE_MASK            = 0x20;    
        public const int                KEYEX_USER_PERMUTATION_SHIFT    = 6;

        /// <summary>
        /// The default user permutation does not change the order of the users nor set any flags.
        /// It causes SgKeyExPermute() in sgrecv.cpp to essentially be a no-op.
        /// </summary>
        public const uint DefaultUserPermutation = 0xe0a06020;

        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT;
        //public short                    cbEnt           = (short)SIZE;
        public short                    Version         = KeyExchangeHeader.KEYEX_VERSION;                     //    KEYEX_VERSION
        public short                    wFlags          = 0;                            // See XSIF_* above
        public uint                     SpiInit         = 0;                            // SPI of the initiator
        [WireInfo(ArraySize=8)]
        public byte[]                   NonceInit       = null;                         // Nonce of the initiator (8 bytes)
        public uint                      UserPerm        = 0;                            // Permutation and guest bits    for    all    4 users
        
        public new const int SIZE = KeyExchangeHeader.SIZE + 20;
        public KeyExchangeInit() : base(KeyExchangeHeader.KEYEX_TYPE_XBTOSG_INIT, SIZE)
        {
            Reset();

            // If we don't set the UserPerm bits, the SG will always zero out our users (as specified
            // in the ticket).  See SgKeyExPermute() in sgrecv.cpp for all the details.  We'll set
            // the default value here so that our users never get permuted (i.e., 1:1, 2:2, 3:3, and 4:4)
            // The dword is 4 bytes, 1 per user; see KEYEX_USER_PERMUTE_MASK and KEYEX_USER_PERMUTATION_SHIFT
            // above for how to set each byte.
            // Actually - bits 6 and 7 (2 highest) specify the user, bit 5 must be 1.
            //UserPerm = 0;
            //for (int user = 0; user < 4; user++)
            //{
            //    // U1       U2       U3       U4
            //    // uup00000 uup00000 uup00000 uup00000
            //    int destUser = user;
            //    UserPerm |= ((user << KEYEX_USER_PERMUTATION_SHIFT) + KEYEX_USER_PERMUTE_MASK) << (destUser * 8);
            //}
            UserPerm = DefaultUserPermutation;
        }

        public void Reset()
        {
            wFlags = 0;
            SpiInit = AuthUtils.GetNewSpi();
            NonceInit = AuthUtils.GetNewNonce();
        }

    }

    public class KeyExchangeInitResponse : KeyExchangeHeader
    {
        // Definitions -----------------------------------------------------------------------
        public const int                SXRF_ENCRYPT_DES    = 0x00000001;     // SG wants DES encryption
        public const int                SXRF_ENCRYPT_3DES   = 0x00000002;     // SG wants 3DES encryption
        public const int                SXRF_ENCRYPT_AES    = 0x00000004;     // SG wants AES encryption
        public const int                SXRF_ENCRYPT_NULL   = 0x00000008;     // SG wants NULL encryption

        // This is a response, let's not initialize the fields to correct values. Instead, let's 
        // see what gets returned and verify that it is correct.
        // Data ------------------------------------------------------------------------------
        //public short                    Type            = 0;  //KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP;
        //public short                    cbEnt           = 0;  //(short)SIZE;
        public short                    Version         = 0;  //KeyExchangeHeader.KEYEX_VERSION;  // KEYEX_VERSION
        public short                    Flags           = 0;  // See SXRF_* above
        public uint                     SpiInit         = 0;  //KC.TEST_SPI_INIT;        // SPI of the initiator
        public uint                     SpiResp         = 0;  // SPI of the responder
        [WireInfo(ArraySize=8)]
        public byte[]                   NonceInit       = new byte[8];   // Nonce of the initiator (8 bytes)
        [WireInfo(ArraySize=8)]
        public byte[]                   NonceResp       = new byte[8];   // Nonce of the responder (8 bytes)

        // Note that everything from here down must be a multiple of 8 bytes and is encrypted
        // using the negotiated 3DES key and NonceResp as the IV.

        public SGAddress                SGAddressInit               = new SGAddress();      // SGADDR assigned to the initiator
        public IpAddr                   IPInit                      = new IpAddr();         // IP address of initiator (as seen by SG)
        public short                    PortInit                    = 0;                    // IP port of initiator (as seen by SG)
        public short                    XbToSgTimeoutInSecs         = 0;                    // Secs of no inbound data/pulse before disconnecting
        public short                    XbToSgPulseTimeoutInSecs    = 0;                    // Secs of no outbound data/pulse before sending SECMSG_TYPE_XBTOSG_PULSE
        public short                    PadZero                     = 0;                    // To make the encrypted area a multiple of 8 bytes

        public new const int SIZE = KeyExchangeHeader.SIZE + 60;
        public KeyExchangeInitResponse() : base(KeyExchangeHeader.KEYEX_TYPE_SGTOXB_RESP, SIZE)
        {
        }

        public void Decrypt(SecReg keys)
        {
            // Sigh.. we're doing this in place, since WireData is fussy. Marshall encrypted
            // blob into an array.... thanks C#!
            int blobsize = SGAddress.SIZE + 4 + 2 + 2 + 2 + 2;  // 32 bytes
            byte[] blob = new byte[blobsize];
            BinaryWriter bw = new BinaryWriter(new MemoryStream(blob));
            bw.Write((byte[])SGAddressInit);
            bw.Write((byte[])IPInit);
            bw.Write(PortInit);
            bw.Write(XbToSgTimeoutInSecs);
            bw.Write(XbToSgPulseTimeoutInSecs);
            bw.Write(PadZero);

            // Decrypt the data goodness
            // If connection is using DES or DES3, this will be encrypted with DES3.  
            // Otherwise, it will be AES.
            if (keys.Cipher == SecReg.CipherType.DES ||
                keys.Cipher == SecReg.CipherType.DES3)
            {
                keys.CryptWithCipher(false, SecReg.CipherType.DES3, NonceResp, blob, (uint)blobsize, null, 0);
            }
            else
            {
                // IV is NonceInit + NonceResp (16 bytes)
                byte[] iv = new byte[16];
                Array.Copy(NonceInit, 0, iv, 0, 8);
                Array.Copy(NonceResp, 0, iv, 8, 8);
                keys.CryptWithCipher(false, SecReg.CipherType.AES, iv, blob, (uint)blobsize, null, 0);
            }

            // blob is now unencrypted
            BinaryReader br = new BinaryReader(new MemoryStream(blob));
            SGAddressInit.ReadStream(br);
            IPInit.ReadStream(br);
            PortInit = br.ReadInt16();
            XbToSgTimeoutInSecs = br.ReadInt16();
            XbToSgPulseTimeoutInSecs = br.ReadInt16();
            PadZero = br.ReadInt16();
        }

    }


    public class KeyExchangeTsInit : KeyExchangeHeader
    {
        // Definitions -----------------------------------------------------------------------
        public const int                KEYEX_USER_GUEST_MASK           = 0x1F; 
        public const int                KEYEX_USER_PERMUTE_MASK            = 0x20;    
        public const int                KEYEX_USER_PERMUTATION_SHIFT    = 6; 

        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_XBTOTS_INIT;
        //public short                    cbEnt           = (short)SIZE;
        public short                    Version         = KeyExchangeHeader.KEYEX_VERSION;                     //    KEYEX_VERSION
        public short                    wFlags          = 0;                            // See XSIF_* above
        [WireInfo(ArraySize=8)]
        public byte[]                   Xnkid           = null;
        public uint                     SpiInit         = 0;                            // SPI of the initiator
        [WireInfo(ArraySize=8)]
        public byte[]                   NonceInit       = null;                         // Nonce of the initiator (8 bytes)
        public int                      UserPerm        = 0;                            // Permutation and guest bits    for    all    4 users
        
        public new const int SIZE = KeyExchangeHeader.SIZE + 28;
        public KeyExchangeTsInit() : base(KeyExchangeHeader.KEYEX_TYPE_XBTOTS_INIT, SIZE)
        {
            Reset();
        }

        public void Reset()
        {
            wFlags = 0;
            SpiInit = AuthUtils.GetNewSpi();
            NonceInit = AuthUtils.GetNewNonce();

            // If we don't set the UserPerm bits, the SG will always zero out our users (as specified
            // in the ticket).  See SgKeyExPermute() in sgrecv.cpp for all the details.  We'll set
            // the default value here so that our users never get permuted (i.e., 1:1, 2:2, 3:3, and 4:4)
            // The dword is 4 bytes, 1 per user; see KEYEX_USER_PERMUTE_MASK and KEYEX_USER_PERMUTATION_SHIFT
            // above for how to set each byte.
            // Actually - bits 6 and 7 (2 highest) specify the user, bit 5 must be 1.
            for (int user = 0; user < 4; user++)
            {
                // U1       U2       U3       U4
                // uup00000 uup00000 uup00000 uup00000
                UserPerm |= ((user << KEYEX_USER_PERMUTATION_SHIFT) + KEYEX_USER_PERMUTE_MASK) << (user * 8);
            }
        }

    }

    public class KeyExchangeTsInitResponse : KeyExchangeHeader
    {
        // This is a response, let's not initialize the fields to correct values. Instead, 
        // let's see what gets returned and verify that it is correct.
        // Data ------------------------------------------------------------------------------
        //public short                    Type            = 0;  //KeyExchangeHeader.KEYEX_TYPE_TSTOXB_RESP;
        //public short                    cbEnt           = 0;  //(short)SIZE;
        public short                    Version         = 0;  //KeyExchangeHeader.KEYEX_VERSION;  // KEYEX_VERSION
        public short                    Flags           = 0;  // See SXRF_* above
        public uint                     SpiInit         = 0;  // SPI of the initiator
        public uint                     SpiResp         = 0;  // SPI of the responder
        [WireInfo(ArraySize=8)]
        public byte[]                    NonceInit       = new byte[8];   // Nonce of the initiator (8 bytes)
        [WireInfo(ArraySize=8)]
        public byte[]                    NonceResp       = new byte[8];   // Nonce of the responder (8 bytes)
        public short                    XbToSgTimeoutInSecs         = 0;                    // Secs of no inbound data/pulse before disconnecting
        public short                    XbToSgPulseTimeoutInSecs    = 0;                    // Secs of no outbound data/pulse before sending SECMSG_TYPE_XBTOSG_PULSE

        // No encrypted section in the TS key exchange response

        public new const int SIZE = KeyExchangeHeader.SIZE + 32;
        public KeyExchangeTsInitResponse() : base(KeyExchangeHeader.KEYEX_TYPE_TSTOXB_RESP, SIZE)
        {
        }
    }

    public class KeyExchangeDHGx : KeyExchangeHeader
    {
        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_DH_GX;
        //public short                    cbEnt           = (short)SIZE; 
        [WireInfo(ArraySize=(int)KC.k_dwDHKeySize)]
        public byte[]                   DHGx            = new byte[KC.k_dwDHKeySize];
    
        public new const int SIZE = KeyExchangeHeader.SIZE + KC.k_dwDHKeySize;

        // Constructor -----------------------------------------------------------------------
        public KeyExchangeDHGx() : base(KeyExchangeHeader.KEYEX_TYPE_DH_GX, SIZE)
        {
            //our X would be 0x01010101....
            byte[] DHx = new byte[KC.k_dwDHKeySize];
            for (int i = 0; i < DHx.Length; i++)
            {
                DHx[i] = 1;
            }
            AuthClientBase.ComputeDHGX(DHGx, DHx);
        }
    }

    public class KeyExchangeDHGy : KeyExchangeHeader
    {
        // Data    ------------------------------------------------------------------------------
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_DH_GX;  // multi-tasking
        //public short                    cbEnt           = (short)SIZE; 
        [WireInfo(ArraySize=(int)KC.k_dwDHKeySize)]
        public byte[]                   DHGy            = new byte[KC.k_dwDHKeySize];

        public new const int SIZE = KeyExchangeHeader.SIZE + KC.k_dwDHKeySize;
        public KeyExchangeDHGy() : base(KeyExchangeHeader.KEYEX_TYPE_DH_GX, SIZE)
        {
        }
    }

    public class KeyExchangeAPReq : KeyExchangeHeader
    {
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(WriteOnlyVarLenString=true)]
        public byte[]                    Data            = new byte[0];    // Kerberos    AP request

        public int CURRENT_SIZE
        {
            get
            {
                return KeyExchangeHeader.SIZE + Data.Length;
            }
        }

        public KeyExchangeAPReq() : base(KeyExchangeHeader.KEYEX_TYPE_KERB_APREQ, KeyExchangeHeader.SIZE)
        {
        }

        //we override these so we can fix the packet length to the correct field just before it gets serialized
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            cbEnt = (short)(CURRENT_SIZE);
            base.WriteStream(binaryWriter);
        }
    }

    public class KeyExchangeAPRep : KeyExchangeHeader
    {
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_KERB_APREP;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(ArraySize=(int)KC.k_APResponseSize)]   
        public byte[]                    Data            = null;  //new byte[KC.k_APResponseSize];    // Kerberos    AP response

        public new const int SIZE = KeyExchangeHeader.SIZE + KC.k_APResponseSize;
        public KeyExchangeAPRep() : base(KeyExchangeHeader.KEYEX_TYPE_KERB_APREP, SIZE)
        {
        }

        public override WireData ReadStream(BinaryReader br)
        {
            base.Type = br.ReadInt16();
            base.cbEnt = br.ReadInt16();

            int bytesRemaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
            Data = br.ReadBytes(bytesRemaining);
            return this;
        }   

    }

    public class KeyExchangePadding : KeyExchangeHeader
    {
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_PADDING;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(WriteOnlyVarLenString=true)]
        public byte[]                   Padding         = new byte[0];

        public KeyExchangePadding(int paddingBytes) : base(KeyExchangeHeader.KEYEX_TYPE_PADDING, paddingBytes+SGPacket.SIZE)
        {
            Padding=new byte[paddingBytes];
        }
    }

    public class KeyExchangeTsPadding : KeyExchangeHeader
    {
        //public short                    Type            = KeyExchangeHeader.KEYEX_TYPE_PADDING;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(WriteOnlyVarLenString=true)]
        public byte[]                   Padding         = new byte[0];

        public KeyExchangeTsPadding(int paddingBytes) : base(KeyExchangeHeader.KEYEX_TYPE_PADDING, paddingBytes+SGPacket.SIZE)
        {
            Padding=new byte[paddingBytes];
        }
    }

    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // sent to the SG.
    public class KeyExchangeRequestPacket : SendablePacket
    {
        // Data    ------------------------------------------------------------------------------
        public uint                     SPI             = 0;                                // Should be 0, otherwise SG won't recognize it
        public KeyExchangeInit          keyexInit       = new KeyExchangeInit();
        public KeyExchangeDHGx          keyexDhgx       = new KeyExchangeDHGx();
        public KeyExchangeAPReq         keyexAPReq      = new KeyExchangeAPReq();
        public KeyExchangePadding       keyexPadding    = new KeyExchangePadding(0);

        public void Reset()
        {
            keyexInit.Reset();
        }

        //we need to pad up to at least sg_MinXbToSGInitPacketSize size total
        //we override these so we can fix the packet length field to the correct size just before it gets serialized
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            FixPadding();
            base.WriteStream(binaryWriter);
        }
        private void FixPadding()
        {
            int padAmount = (int)(SGC.sg_MinXbToSGInitPacketSize - (KeyExchangeInit.SIZE + KeyExchangeDHGx.SIZE + keyexAPReq.CURRENT_SIZE));
            if (padAmount<0) padAmount=0;

            keyexPadding = new KeyExchangePadding(padAmount);
        }

        /// <summary>
        /// Build the Kerberos AP portion of the key exchange request packet.
        /// </summary>
        /// <param name="context">The context to use when building the AP.</param>
        /// <returns>A byte array containing the Kerberos AP portion of the key exchange request packet.</returns>
        public byte[] BuildAP (AuthContext context)
        {
            long APTime;
            byte[] pb = new byte[1500];
            int cb = (int) pb.Length;

            // Build byte array of pre-AP data
            // Consists of:
            //     KeyexInit
            //     KeyexDhgx
            BinaryWriter bw = new BinaryWriter(new MemoryStream(pb));
            keyexInit.WriteStream(bw);
            keyexDhgx.WriteStream(bw);

            byte[] sha = new byte[AuthClientBase.k_Sha_Digest_Len];
            byte[] key;
            byte[] bytesServiceCtx;

            if (context.IsXenonTitle || context.IsPanorama)
            {
                key = context.ServiceCtxXe.SessionKey;
                bytesServiceCtx = (byte[]) context.ServiceCtxXe;
            }
            else
            {
                key = context.ServiceCtxXbox.SessionKey;
                bytesServiceCtx = (byte[]) context.ServiceCtxXbox;
            }

            // Compute SHA of pre-AP data
            AuthClientBase.XcHmac4(
                key,
                key.Length,
                pb,
                (int)bw.BaseStream.Position,
                null, 0,
                null, 0,
                null, 0,
                sha,
                sha.Length);

            try
            {
                AuthClientBase.DLL_BuildAp(
                    bytesServiceCtx,
                    out APTime,
                    sha,
                    AuthClientBase.k_Sha_Digest_Len,
                    pb,
                    out cb);
            }
            finally
            {
                AuthClientBase.SpewKerbclientDebug();
            }

            byte[] returnPacket = new byte[cb];
            Buffer.BlockCopy(pb, 0, returnPacket, 0, cb);

            return returnPacket;
        }
    }

    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // received from the SG.
    public class KeyExchangeResponsePacket : SendablePacket
    {
        // Data    ------------------------------------------------------------------------------
        public uint                     SPI             = 0;                                // 4 bytes
        public KeyExchangeInitResponse  keyexResp       = new KeyExchangeInitResponse();    // 64 bytes
        public KeyExchangeDHGy          keyexDhgy       = new KeyExchangeDHGy();            // 100 bytes
        public KeyExchangeSgToXbChallenge keyexChal     = null;                             // 284+codesize bytes (optional)
        public KeyExchangeAPRep         keyexAPRep      = new KeyExchangeAPRep();           // 119-ish bytes

        public const int SIZE = (4 + KeyExchangeInitResponse.SIZE + KeyExchangeDHGy.SIZE + KeyExchangeAPRep.SIZE);

        protected uint ExpectedSPI = 0;
        public int totalLength = 0;

        public KeyExchangeResponsePacket(uint expectedSPI)
        {
            this.ExpectedSPI = expectedSPI;
        }

        public override bool Check()
        {
            // Sometimes this returns a packet 1 byte short.  I don't know why but it doesn't seem
            // to hurt anything.
            if (recvSize < SIZE-1)
                return false;

            uint spi = (uint)(recvBuf[0] + (recvBuf[1] << 8) + (recvBuf[2] << 16) + (recvBuf[3] << 24));
            if (spi != ExpectedSPI)
                return false;

            return base.Check();
        }


        public override WireData ReadStream(BinaryReader br)
        {
            totalLength = (int)br.BaseStream.Length;
            int bytesRemaining;

            this.SPI = (uint)br.ReadInt32();
            this.keyexResp.ReadStream(br);
            this.keyexDhgy.ReadStream(br);

            // Peek at type and size
            // Read Challenge if it is available. It may not be.
            short type = br.ReadInt16();
            short size = br.ReadInt16();
            br.BaseStream.Seek(-4, SeekOrigin.Current);
            if (type == KeyExchangeHeader.KEYEX_TYPE_SGTOXB_CHAL)
            {
                if (size < KeyExchangeSgToXbChallenge.SIZE_WITHOUT_PKSIG)
                {
                    throw new SGException("SgToXbChal.cbEnt cannot be less than {0}, it was {1}",
                        KeyExchangeSgToXbChallenge.SIZE_WITHOUT_PKSIG, size);
                }

                bytesRemaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
                if (bytesRemaining < size)
                {
                    // Since we read them, may as well set them, handy for debugging
                    //this.keyexChal.Type = type;
                    //this.keyexChal.cbEnt = size;
                    throw new SGException("{0} bytes available in stream, need at least {1} for SgToXb Challenge (plus APRep) (keyexresp size={2}, chal.cbEnt={3})",
                        bytesRemaining, size, totalLength, size);
                }
                this.keyexChal = new KeyExchangeSgToXbChallenge();
                this.keyexChal.ReadStream(br);
            }

            // Read APReply
//            bytesRemaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
//            // sometimes it is 1 byte short
//            if (bytesRemaining < KeyExchangeAPRep.SIZE-1)
//            {
//                throw new SGException("{0} bytes available in stream, need at least {1} for APReply structure", bytesRemaining, KeyExchangeAPRep.SIZE);
//            }
            this.keyexAPRep.ReadStream(br);
            return this;
        }

    }

    
    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // sent to the LSP (TS) server.
    public class KeyExchangeTsRequestPacket : SendablePacket
    {
        // Data    ------------------------------------------------------------------------------
        public uint                     SPI             = 0;                                // Should be 0, otherwise SG won't recognize it
        public KeyExchangeTsInit        keyexInit       = new KeyExchangeTsInit();
        public KeyExchangeAPReq         keyexAPReq      = new KeyExchangeAPReq();
        public KeyExchangeTsPadding     keyexPadding    = new KeyExchangeTsPadding(0);

        public void Reset()
        {
            keyexInit.Reset();
        }

        //we need to pad up to at least sg_MinXbToSGInitPacketSize size total
        //we override these so we can fix the packet length field to the correct size just before it gets serialized
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            FixPadding();
            base.WriteStream(binaryWriter);
        }
        private void FixPadding()
        {
            int padAmount = (int)(SGC.sg_MinXbToSGInitPacketSize - (KeyExchangeInit.SIZE + keyexAPReq.CURRENT_SIZE));
            if (padAmount<0) padAmount=0;

            keyexPadding = new KeyExchangeTsPadding(padAmount);
        }
    }

    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // received from the LSP (TS) server.
    public class KeyExchangeTsResponsePacket : SendablePacket
    {
        // Data    ------------------------------------------------------------------------------
        public uint                     SPI             = 0;                                // 4 bytes
        public KeyExchangeTsInitResponse  keyexResp     = new KeyExchangeTsInitResponse();  // 36 bytes
        public KeyExchangeAPRep         keyexAPRep      = new KeyExchangeAPRep();           // 119-ish bytes

        public const int SIZE = (4 + KeyExchangeTsInitResponse.SIZE + KeyExchangeAPRep.SIZE);

        [WireInfo(Serialize=false)]
        protected uint ExpectedSPI = 0;
        
        [WireInfo(Serialize=false)]
        public int totalLength = 0;

        public KeyExchangeTsResponsePacket(uint expectedSPI)
        {
            this.ExpectedSPI = expectedSPI;
        }

        public override bool Check()
        {
            // Sometimes this returns a packet 1 byte short.  I don't know why but it doesn't seem
            // to hurt anything.
            if (recvSize < SIZE-1)
                return false;

            uint spi = (uint)(recvBuf[0] + (recvBuf[1] << 8) + (recvBuf[2] << 16) + (recvBuf[3] << 24));
            if (spi != ExpectedSPI)
                return false;

            return base.Check();
        }
    }

    #endregion

    #region SGMSG packets (SGInfo / SPIDATA)

    public class SgMsgHeader : SGPacket
    {
        public const int    SGMSG_TYPE_KICK_REQ             = 0x4705;  // CSgMsgKickReq
        public const int    SGMSG_TYPE_KICK_REP             = 0x4706;  // CSgMsgKickRep
        public const int    SGMSG_TYPE_SPIDATA_REQ          = 0x4710;  // CSgMsgSpiReq
        public const int    SGMSG_TYPE_SPIDATA_REP          = 0x4711;  // CSgMsgSpiRep
        public const int    SGMSG_TYPE_NOTIFY_CLI_DEL       = 0x4712;  // CSgMsgNotifyCliDelete
        public const int    SGMSG_TYPE_NOTIFY_CLI_UPD       = 0x4713;  // CSgMsgNotifyCliUpdate
        public const int    SGMSG_TYPE_NOTIFY_CLI_TCHG      = 0x4714;  // CSgMsgNotifyCliTitleChange
        public const int    SGMSG_TYPE_SPIDATA_REQ2         = 0x4716;  // CSgMsgSpiReq2
        public const int    SGMSG_TYPE_NOTIFY_CLI_UCHG      = 0x4717;  // CSgMsgNotifyCliUserChange
        public const int    SGMSG_TYPE_NOTIFY_SPI_UPD       = 0x4718;  // CSgMsgNotifySpiUpdate
        public const int    SGMSG_TYPE_SPIDATA              = 0x4782;  // CSgMsgSpiData in the payload
        public const int    SGMSG_TYPE_AUTHDATA             = 0x4783;  // CAuthData3 in the payload
        
        public SgMsgHeader(int type, int cbent) : base(type, cbent)
        {
        }
    }

    public class SgMsgKickReq : SgMsgHeader
    {
        public SGAddress SgAddr;

        public new const int SIZE = SgMsgHeader.SIZE + SGAddress.SIZE;

        public SgMsgKickReq () : base(SgMsgHeader.SGMSG_TYPE_KICK_REQ, SIZE) { }

        public override string ToString ()
        {
            return "SgMsgKickReq: " + SgAddr.ToString();
        }
    }

    public class SgMsgKickRep : SgMsgHeader
    {
        public SGAddress SgAddr;
        public byte NotFound;

        public new const int SIZE = SgMsgHeader.SIZE + SGAddress.SIZE + 1;

        public SgMsgKickRep () : base(SgMsgHeader.SGMSG_TYPE_KICK_REP, SIZE) { }

        public override string ToString ()
        {
            return "SgMsgKickRep: [" + (NotFound != 0 ? "NOT " : "") + "FOUND] " + SgAddr.ToString();
        }
    }

    public class SgMsgSpiData : SgMsgHeader
    {
        public ushort                   ClientPort      = 0;                // IP port of the client on the Internet
        public IpAddr                   ClientAddr      = new IpAddr();     // IP address of the client on the Internet
        public SGAddress                ClientSGAddr    = new SGAddress();  // SGADDR of the client
        public ushort                   VersionKeyEx    = 0;                // KeyEx version of the client
        public ushort                   FlagsKeyEx      = 0;                // Flags sent in KeyEx initiator
        [WireInfo(ArraySize=8)]
        public byte[]                    Nonce           = new byte[8]; 
        public long                     TimeInit        = 0;                // FILETIME marking session initiation
        public int                      fCs             = 0;                // TRUE if SG is providing connection services

        public new const int SIZE = SgMsgHeader.SIZE + 50;
        public SgMsgSpiData() : base(SgMsgHeader.SGMSG_TYPE_SPIDATA, SIZE)
        {
        }

        public override string ToString()
        {
            return String.Format("SpiData: Ip={0}, Port=0x{1:X4}, KeyexVersion={2}, KeyexFlags={3}, Nonce={4}, TimeInit=0x{5:X16}, fCs={6}",
                ClientAddr.ToString(),
                ClientPort,
                VersionKeyEx,
                FlagsKeyEx,
                ServerTestFramework.Utilities.Hexer.tohex(Nonce),
                TimeInit,
                fCs);
        }

    }

    public class SgMsgSpiReq : SgMsgHeader
    {
        public uint                     ReqNum          = 0;                // Request number from requester
        public IpAddr                   ClientAddr      = new IpAddr();     // IP address of the client on the DMZ
        public ushort                   ClientPort      = 0;                // IP port of the client on the DMZ

        public new const int SIZE = SgMsgHeader.SIZE + 10;
        public SgMsgSpiReq() : base(SgMsgHeader.SGMSG_TYPE_SPIDATA_REQ, SIZE)
        {
        }
    }

    public class SgMsgSpiReq2 : SgMsgHeader
    {
        public uint                     ReqNum          = 0;                // Request number from requester
        public IpAddr                   ClientAddr      = new IpAddr();     // IP address of the client on the DMZ
        public ushort                   ClientPort      = 0;                // IP port of the client on the DMZ
        public ushort                   AuthdataVersion = 0;                // Max supported authdata version

        public new const int SIZE = SgMsgHeader.SIZE + 12;
        public SgMsgSpiReq2() : base(SgMsgHeader.SGMSG_TYPE_SPIDATA_REQ2, SIZE)
        {
        }
    }

    public class SgMsgSpiRep : SgMsgHeader
    {
        //#define CBSGSPIREPMSG  (sizeof(CSgMsgSpiRep)+sizeof(CSgMsgSpiData)+sizeof(CSgMsgHdr)+sizeof(CAuthData3))

        public uint                     ReqNum          = 0;                // Copy of _dwReqNum from request
        public IpAddr                   ClientAddr      = new IpAddr();     // IP address of the client on the DMZ
        public ushort                   ClientPort      = 0;                // IP port of the client on the DMZ
        public byte                     fNotFound       = 0;                // TRUE if client not found (no auth-data enclosed)

        public new const int SIZE = SgMsgHeader.SIZE + 11;
        public SgMsgSpiRep() : base(SgMsgHeader.SGMSG_TYPE_SPIDATA_REP, SIZE)
        {
        }

        public override string ToString()
        {
            string s = String.Format("SpiRep: ReqNum=0x{0:X8}, fNotFound={1}, Ip={2}, Port=0x{3:X4}",
                ReqNum,
                fNotFound,
                ClientAddr.ToString(),
                ClientPort);
            return s;
        }

    }

    public class SgMsgAuthData : SgMsgHeader
    {
        public Authdata_Base AuthData = null;

#if false
        public override bool Check()
        {
            if (recvSize < 8)
                return false;

            short type = (short)(recvBuf[0] + (recvBuf[1] << 8));
            short cbent = (short)(recvBuf[2] + (recvBuf[3] << 8));
            short version = (short)(recvBuf[4] + (recvBuf[5] << 8));
            short size = (short)(recvBuf[6] + (recvBuf[7] << 8));
            
            if (type != SgMsgHeader.SGMSG_TYPE_AUTHDATA || cbEnt < 8)
                return false;

            authdataVersion = (int)version;

            return true;
        }
#endif

        public override WireData ReadStream(BinaryReader br)
        {
            // Check the size
            if (br.BaseStream.Length < 8)
            {
                throw new SGException("Stream length is less than 4, the minimum required for an Authdata packet");
            }
            
            // Read base header info
            this.Type = br.ReadInt16();
            this.cbEnt = br.ReadInt16();

            // Now peek at authdata fields
            short authdataVersion = br.ReadInt16();
            short size = br.ReadInt16();

            // Rewind to beginning of authdata section
            br.BaseStream.Seek(-4, SeekOrigin.Current);

            switch(authdataVersion)
            {
                case 2:
                    AuthData = new Authdata_Xbox2();
                    break;
                case 3:
                    AuthData = new Authdata_Xenon();
                    break;
                case 4:
                    AuthData = new Authdata_Xenon2();
                    break;
                default:
                    throw new SGException("Unknown authdata version {0}", authdataVersion);
            }

            AuthData.ReadStream(br);
            
            return this;
        }

        public SgMsgAuthData() : base(SgMsgHeader.SGMSG_TYPE_AUTHDATA, 4)
        {
        }
    }

    // This is not defined in xonline.x.  It's a glob of other types and represents the actual packet
    // received from the SG.
    //
    // The reply is actually of the form:
    // {
    //   CSgMsgSpiRep
    //   CSgMsgSpiData2
    //   CSgMsgHdr+CAuthData[2,3]
    // }
    //
    // where the last 2 structures are optional, depending on whether the user was found.
    //
    public class SgMsgSpiDataRepPacket : SendablePacket
    {
        public SgMsgSpiRep          SpiRep      = new SgMsgSpiRep();
        public SgMsgSpiData         SpiData     = null;  
        public SgMsgAuthData        SpiAuth     = null;

        public override bool Check()
        {
            if (recvSize < SgMsgSpiRep.SIZE)
                return false;

            short type = (short)(recvBuf[0] + (recvBuf[1] << 8));
            short cbent = (short)(recvBuf[2] + (recvBuf[3] << 8));

            if (type != SgMsgHeader.SGMSG_TYPE_SPIDATA_REP || cbent != SgMsgSpiRep.SIZE)
                return false;

            return true;
        }

        public override WireData ReadStream(BinaryReader br)
        {
            // Read #1
            SpiRep.ReadStream(br);

            // If user wasn't found, there will be no more data in the stream, otherwise we
            /// should read it.
            if (SpiRep.fNotFound == 0)
            {
                // Read the rest
                SpiData = new SgMsgSpiData();
                SpiData.ReadStream(br);

                SpiAuth = new SgMsgAuthData();
                SpiAuth.ReadStream(br);
            }
          
            return this;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            SpiRep.WriteStream(bw);
            if (SpiData != null)
                SpiData.WriteStream(bw);
            if (SpiAuth != null)
                SpiAuth.WriteStream(bw);
        }

#if false
            // Check the size
            if (br.BaseStream.Length < SgMsgSpiRep.SIZE)
            {
                throw new SGException("Stream length is less than {0}, the minimum required for an SgMsgSpiRep packet", SgMsgSpiRep.SIZE);
            }

            int length = (int)br.BaseStream.Length;

            // Read #1
            SpiRep.ReadStream(br);
            length -= SpiRep.cbEnt;

            // If user wasn't found, there will be no more data in the stream
            if (SpiRep.fNotFound != 0)
            {
                throw new SGException("User (ip=0x{0:X}, port=0x{1:X}) not found in SpiData request",
                    SpiRep.ClientAddr.S_addr, SpiRep.ClientPort);
            }

            if (length <= SgMsgSpiData.SIZE + SGPacket.SIZE)
            {
                throw new SGException("Returned stream is too short, only have {0} bytes", br.BaseStream.Length);
            }

            // Read #2
            SpiData.ReadStream(br);
            length -= SpiData.cbEnt;

            // Read #3
            SpiAuth.ReadStream(br);
            
            return this;
        }
#endif

        public override string ToString()
        {
            string s = SpiRep.ToString();
            if (SpiData != null)
                s += "\n" + SpiData.ToString();
            if (SpiAuth != null)
                s += "\n" + SpiAuth.AuthData.ToString();
            return s;
        }
    }

    public class SgMsgNotifyHeader : SgMsgHeader
    {
        public SGAddress SgAddr;

        public new const int SIZE = SgMsgHeader.SIZE + SGAddress.SIZE;
        
        public SgMsgNotifyHeader (int type, int cbent) : base(type, cbent)
        {
        }
    }

    public class SgMsgNotifyCliDelete : SgMsgNotifyHeader
    {
        public UInt32 TitleId;

        public new const int SIZE = SgMsgNotifyHeader.SIZE + 4;

        public override int Size ()
        {
            return SIZE;
        }

        public SgMsgNotifyCliDelete () : base(SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_DEL, SIZE) { }
    }

    public class SgMsgNotifyCliUpdate : SgMsgNotifyHeader
    {
        public UInt64 UserId;
        public UInt64 Xnkid;
        public UInt32 AuthFlags;
        public UInt32 State;
        public UInt32 TitleId;
        public UInt16 TitleDataSize;
        [WireInfo(ArraySize = 256)]
        public byte[] TitleData;

        public new const int SIZE = SgMsgNotifyHeader.SIZE + 286;

        public override int Size ()
        {
            return SIZE;
        }

        public SgMsgNotifyCliUpdate () : base(SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_UPD, SIZE) { }
    }

    public class SgMsgNotifyCliTitleChange : SgMsgNotifyHeader
    {
        public UInt32 OldTitleId;
        public UInt32 NewTitleId;

        public new const int SIZE = SgMsgNotifyHeader.SIZE + 8;

        public override int Size ()
        {
            return SIZE;
        }

        public SgMsgNotifyCliTitleChange () : base(SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_TCHG, SIZE) { }
    }

    public class SgMsgNotifyCliUserChange : SgMsgNotifyHeader
    {
        public const UInt32 SECMSG_CLIUSERCHANGE_TYPE_ADD = 0x000000000; // Bit 0
        public const UInt32 SECMSG_CLIUSERCHANGE_TYPE_DEL = 0x000000001; // Bit 0

        [WireInfo(ArraySize = 4)]
        public ulong[] Users;
        public IpAddr InternetIp;
        public UInt32 Flags;

        public new const int SIZE = SgMsgNotifyHeader.SIZE + 40;

        public override int Size ()
        {
            return SIZE;
        }

        public SgMsgNotifyCliUserChange () : base(SgMsgHeader.SGMSG_TYPE_NOTIFY_CLI_UCHG, SIZE) { }
    }

    public class SgMsgNotifySpiUpdate : SgMsgNotifyHeader
    {
        public UInt32 OldSpi;

        public new const int SIZE = SgMsgNotifyHeader.SIZE + 4;

        public override int Size ()
        {
            return SIZE;
        }

        public SgMsgNotifySpiUpdate() : base(SgMsgHeader.SGMSG_TYPE_NOTIFY_SPI_UPD, SIZE) { }
    }
    #endregion

    #region SECMSG packets

    //[StructLayout(LayoutKind.Sequential, Pack=1)]
    public class SecMsgHeader : SGPacket
    {
        // Definitions (0x53 is 'S') ---------------------------------------------------------
        public const int    SECMSG_TYPE_DELETE              = 0x5300;  // CSecMsgDelete
        public const int    SECMSG_TYPE_PULSE               = 0x5301;  // CSecMsgPulse
        public const int    SECMSG_TYPE_XBTOSG_PULSE        = 0x5302;  // CSecMsgXbToSgPulse
        public const int    SECMSG_TYPE_SGTOXB_PULSE        = 0x5303;  // CSecMsgSgToXbPulse (Obsolete)
        public const int    SECMSG_TYPE_XBTOXB_FORWARD      = 0x5304;  // CSecMsgXbToXbForward
        public const int    SECMSG_TYPE_CHANGE_USERS_REQ    = 0x5305;  // CSecMsgChangeUsersReq
        public const int    SECMSG_TYPE_CHANGE_USERS_REP    = 0x5306;  // CSecMsgChangeUsersRep
        public const int    SECMSG_TYPE_XBTOSG_QOS_INIT     = 0x5307;  // CSecMsgXbToSgQosInit
        public const int    SECMSG_TYPE_SGTOXB_QOS_RESP     = 0x5308;  // CSecMsgSgToXbQosResp
        public const int    SECMSG_TYPE_SGTOXB_PULSE_2      = 0x5309;  // CSecMsgSgToXbPulse
        public const int    SECMSG_TYPE_XBTOSG_CHALRESP     = 0x530A;  // CSecMsgXbToSgChalResp
        public const int    SECMSG_TYPE_XBTOSG_NATDET_REQ   = 0x530B;  // No payload
        public const int    SECMSG_TYPE_SGTOXB_NATDET_REP   = 0x530C;  // No payload
        public const int    SECMSG_TYPE_CHANGE_USERS_NULL   = 0x530D;  // CSecMsgChangeUsersReq; insecure; test only
        public const int    SECMSG_TYPE_SGTOXB_CHAL         = 0x530E;  // New async challenge
        public const int    SECMSG_TYPE_XBTOSG_CHALRESP_2   = 0x530F;  // New async challenge response
        public const int    SECMSG_TYPE_XBTOSG_CHAL_ACK     = 0x5310;  // Ack sent by client to confirm SGTOXB_CHAL
        public const int    SECMSG_TYPE_SGTOXB_CHALRESP_ACK = 0x5311;  // Ack sent by SG to confirm XBTOSG_CHALRESP_2
        public const int    SECMSG_TYPE_XBTOXB_FORWARD2     = 0x5312;  // CSecMsgXbToXbForward2
        public const int    SECMSG_TYPE_XBTOSG_CHALRESP_3   = 0x5313;  // CSecMsgXbToSgChalResp3, New sync challenge response

        // These used to be defined separately
        public const int    QPF_EMPTY_FLAGS                 = 0x00;    // Empty flags set
        public const int    QPF_PAIR_TWO                    = 0x01;    // This is the second packet of the pair
        public const int    QPF_DATA_REQ                    = 0x02;    // This is a Qos data request only
        public const int    QPF_DATA_REP                    = 0x04;    // This ia a Qos data reply only
        public const int    QPF_DATA_NONE                   = 0x08;    // The host has no Qos data (sent in probe response)
        public const int    QPF_DISABLED                    = 0x10;    // This host has disabled its Qos listener

        public SecMsgHeader(int type, int cbent) : base(type, cbent)
        {
        }
        
        public static SecMsgHeader CreatePacket(byte[] data)
        {
            int type = 0;
            int size = 0;

            if (data == null || data.Length < 4)
            {
                throw new SGException("CreatePacket failed, data is too short or null");
            }
            type = (int)(data[0] + (data[1] << 8));
            size = (int)(data[2] + (data[3] << 8));

            return CreatePacket(data, 0, data.Length, type);
        }

        public static SecMsgHeader CreatePacket (byte[] data, int offset, int length, int type)
        {
            SecMsgHeader packet = null;

            if (data == null || data.Length < (offset + length))
            {
                throw new SGException("CreatePacket failed, data is too short or null");
            }

            switch (type)
            {
                case SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REP:
                    packet = new SecMsgChangeUsersRep();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP:
                    packet = new SecMsgQosResp();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2:
                    packet = new SecMsgDataPulseResp();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_NATDET_REP:
                    packet = new SecMsgNatDetRep();
                    break;
                case SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD:
                    packet = new SecMsgXbToXbForward();
                    break;
                case SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD2:
                    packet = new SecMsgXbToXbForward2();
                    break;
                case SecMsgHeader.SECMSG_TYPE_DELETE:
                    packet = new SecMsgDelete();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL:
                    packet = new SecMsgSgToXbChal();
                    break;
                case SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK:
                    packet = new SecMsgSgToXbChalRespAck();
                    break;
                default:
                    throw new SGException("Don't know how to create packet of type 0x{0:X}, data.Length={1}", type, data.Length);
            }

            packet.ReadStream(new MemoryStream(data, offset, length));
            return packet;
        }
    }

    public class SecMsgSgToXbChal : SecMsgHeader, IEquatable<SecMsgSgToXbChal>
    {
        public const int ChallengeFlagBitType           = 0x00000001;   // 0=>HV, 1=>SV
        public const int ChallengeFlagBitSize           = 0x00000002;   // 0=>Small, 1=>Large

        /// <summary>
        /// Returns whether or not the flags indicate that the challenge can be used
        /// for the key exchange challenge or not
        /// </summary>
        public static bool ChallengeFlagKeyexSafe(uint ChallengeFlags)
        {
            return (ChallengeFlags & 0x3) == 0 ? true : false;
        }

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL;
        //public short                    cbEnt           = (short)SIZE;
        public uint                     ChallengeNonce  = 0;
        public uint                     ChallengeFlags  = 0;
        [WireInfo(ArraySize=16)]
        public byte[]                    Params          = new byte[16];     // Challenge parameters
        [WireInfo(ArraySize=256)]
        public byte[]                    PkSig           = new byte[256];    // Digest of the rest of this entry
        
        // The rest of this entry is filled with challenge code that needs to be run
        // on the challenged xbox.  The challenge consists of the PkSig field above plus 
        // whatever spills into this section.  It may be 0.
        // Thus PkSig + ChalCode will either be a SupervisorChallenge or a HypervisorChallenge.

        [WireInfo(ArraySize=0)]
        public byte[]                   ChalCode        = null;

        public new const int SIZE = SecMsgHeader.SIZE + 280;
        public SecMsgSgToXbChal() : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_CHAL, SIZE)
        {
        }

        public override string ToString()
        {
            return String.Format("[SgToXbChal] Nonce=0x{0:X8}, Flags=0x{1:X}, Params=0x{2}, ChalSize={3} ({4} extra)",
                ChallengeNonce,
                ChallengeFlags,
                Utilities.Hexer.tohex(Params),
                cbEnt - 28,
                cbEnt - SIZE);
        }

        public bool IsLargeSupervisorChallenge()
        {
            return (ChallengeFlags & 0x3) == 0x3;
        }

        public LargeSupervisorChallenge GetLargeSupervisorChallenge()
        {
            if (!IsLargeSupervisorChallenge())
                return null;
            return new LargeSupervisorChallenge(PkSig, ChalCode);
        }

        public override WireData ReadStream(BinaryReader br)
        {
            this.Type           = (short)br.ReadInt16();
            this.cbEnt          = (short)br.ReadInt16();
            this.ChallengeNonce = (uint)br.ReadInt32();
            this.ChallengeFlags = (uint)br.ReadInt32();
            this.Params         = (byte[])br.ReadBytes(16);
            this.PkSig          = (byte[])br.ReadBytes(256);

            int remaining       = this.cbEnt - SIZE;
            if (remaining > 0)
            {
                this.ChalCode       = (byte[])br.ReadBytes(remaining);
            }

            return this;
        }

        #region IEquatable<SecMsgSgToXbChal> Members

        public bool Equals (SecMsgSgToXbChal other)
        {
            return (
                ChallengeNonce == other.ChallengeNonce &&
                ChallengeFlags == other.ChallengeFlags &&
                ArrayEx.Equals<byte>(Params, other.Params) &&
                ArrayEx.Equals<byte>(PkSig, other.PkSig) &&
                ArrayEx.Equals<byte>(ChalCode, other.ChalCode)
                );
        }

        #endregion
    }

    public class LargeSupervisorChallenge
    {
        public byte[]       PkSig;              // 256 bytes
        public short        Version;
        public short        Size;
        public short        ChalId;
        public short        ChalVer;
        public int          ChalSize;
        public int          Context;

        public const int SIZE = 272;

        /// <summary>
        /// Allows for easy conversion from the way the challenge is stored in the input
        /// packet to a handy SupervisorChallenge structure.
        /// </summary>
        public LargeSupervisorChallenge(byte[] PkSig, byte[] ChalCode)
        {
            //System.Diagnostics.Debug.Assert(PkSig.Length == 256, "PkSig should be 256 bytes long");
            System.Diagnostics.Debug.Assert(ChalCode.Length >= 16, "ChalCode should be >= 16 bytes long");

            this.PkSig = PkSig;
            
            BinaryReader br = new BinaryReader(new MemoryStream(ChalCode));
            this.Version = br.ReadInt16();
            this.Size = br.ReadInt16();
            this.ChalId = br.ReadInt16();
            this.ChalVer = br.ReadInt16();
            this.ChalSize = br.ReadInt32();
            this.Context = br.ReadInt32();
        }

        public override string ToString()
        {
            return String.Format("[LargeSupervisorChal] Version={0}, Size={1}, ChalId=0x{2:X8}, ChalVer=0x{3:X}, ChalSize={4}, Context={5}",
                Version,
                Size,
                ChalId,
                ChalVer,
                ChalSize,
                Context);
        }
    }

    public class SecMsgXbToSgChalResp2 : SecMsgHeader
    {
        // The number of valid bytes in the packet can be determined by looking for the 
        // first non-zero byte from the end of the array.

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP_2 ;
        //public short                    cbEnt           = (short)SIZE;
        public uint                     ChallengeNonce  = 0;
        [WireInfo(ArraySize=1024)]
        public byte[]                   Execute         = null;    // 1024 byte answer from the client
        
        public new const int SIZE = SecMsgHeader.SIZE + 1028;
        public SecMsgXbToSgChalResp2() : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP_2 , SIZE)
        {
            ManualArraySize = true;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            if (Execute == null)
                Execute = new byte[1024];
            base.WriteStream(bw);
        }
    }

    public class SecMsgXbToSgChalAck : SecMsgHeader
    {
        // This packet is sent from the client to the server in order to acknowledge that a 
        // challenge with _dwSeqAck sequence number has been received. If the server does not 
        // receive this message in a timely fashion, it will resend the challenge.

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_CHAL_ACK ;
        //public short                    cbEnt           = (short)SIZE;
        public uint                     ChallengeNonce  = 0;
        
        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgXbToSgChalAck() : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_CHAL_ACK , SIZE)
        {
        }
    }

    public class SecMsgSgToXbChalRespAck : SecMsgHeader
    {
        // This packet is sent from the server to the client in oder to acknowledge that a 
        // challenge response with _dwSeqAck sequence number has been received. If the client 
        // does not receive this message in a timely fashion, it will resend the challenge response.

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK;
        //public short                    cbEnt           = (short)SIZE;
        public uint                     ChallengeNonce  = 0;
        
        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgSgToXbChalRespAck() : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_CHALRESP_ACK, SIZE)
        {
        }
    }

    //[StructLayout(LayoutKind.Sequential, Pack=1)]
    public class SecMsgQosInit : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_QOS_INIT;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(ArraySize=8)]
        public byte[]                    Nonce           = new byte[8]; //AuthUtils.GetNewNonce(); // Nonce assigned by the initiator (8 bytes)
        public ushort                   QosIdx          = 0;            // Index assigned by the initiator
        public byte                     PktIdx          = 0;            // Packet sequence number
        public byte                     Flags           = 0;            // See QPF_* above

        public new const int SIZE = SecMsgHeader.SIZE + 12;
        public SecMsgQosInit() : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_QOS_INIT, SIZE)
        {
        }

        public override void WriteStream(BinaryWriter bw)
        {
            bw.Write(base.Type);
            bw.Write(base.cbEnt);
            bw.Write(Nonce);
            bw.Write(QosIdx);
            bw.Write(PktIdx);
            bw.Write(Flags);

            byte[] arr = new byte[16] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            for (int i = SIZE, j = (int) cbEnt; i < j; i += 16)
            {
                bw.Write(arr, 0, (j > i + 16 ? 16 : j - i));
            }
        }
    }

    public class SecMsgQosResp : SecMsgHeader
    {
        // This is a response packet, let's not assign the correct values; instead, verify what gets returned.
        //public short                    Type            = 0;            // SecMsgHeader.SECMSG_TYPE_XBTOSG_QOS_INIT;
        //public short                    cbEnt           = 0;            // (short)SIZE;
        [WireInfo(ArraySize=8)]
        public byte[]                    Nonce           = new byte[8];  // Nonce assigned by the initiator (8 bytes)
        public ushort                   QosIdx          = 0;            // Index assigned by the initiator
        public byte                     PktIdx          = 0;            // Packet sequence number
        public byte                     Flags           = 0;            // See QPF_* above
        public uint                     Rtt             = 0;            // Time between recv of xmit of corresponding pkt in pair
        public uint                     Gap             = 0;            // Time between recv of pkt1 and pkt2 (less traffic)

        public new const int SIZE = SecMsgHeader.SIZE + 20;
        public SecMsgQosResp() : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_QOS_RESP, SIZE)
        {
        }

        // The rest of this entry contains the Qos data (if QPF_DATA_REP)
        
        public override string ToString()
        {
            return String.Format("QosResponse: nonce={0:X}, qosidx={1}, pktidx={2}, rtt={3}, gap={4}, flags={5:X}",
                                 Hexer.tohex(Nonce),
                                 QosIdx,
                                 PktIdx,
                                 Rtt,
                                 Gap,
                                 Flags);
        }
    }

    public class SecMsgPulse : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_PULSE;
        //public short                    cbEnt           = (short)SIZE;

        public new const int SIZE = SecMsgHeader.SIZE;
        public SecMsgPulse() : base(SecMsgHeader.SECMSG_TYPE_PULSE, SIZE)
        {
        }    
    }

    public class SecMsgDataPulse : SecMsgHeader
    {
        // Definitions -----------------------------------------------------------------------

        public const int XBPULSE_STATE_CHANGE           = 0x01;         // dwUserState changed
        public const int XBPULSE_XNKID_CHANGE           = 0x02;         // xnkidSession changed
        public const int XBPULSE_TDATA_CHANGE           = 0x04;         // abTitleData changed
        public const int XBPULSE_TITLE_CHANGE           = 0x08;         // dwTitleId changed

        // Data ------------------------------------------------------------------------------
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_PULSE;
        //public short                    cbEnt           = (short)SIZE;
        public uint                     SeqAck          = 0;            // Acknowledgement sequence number

        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgDataPulse() : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_PULSE, SIZE)
        {
        }

        // The rest of this entry is filled with a padded series of changes.
        //
        // Byte 0    - change type
        // Byte 1-8  - user PUID
        //
        // Type XBPULSE_STATE_CHANGE:
        // Byte 9-12 - new state
        //
        // Type XBPULSE_XNKID_CHANGE:
        // Byte 9-16 - new XNKID
        //
        // Type XBPULSE_TDATA_CHANGE:
        // Byte 9    - size in bytes of title data
        // Byte 10-x - new title data
        //
        // Type XBPULSE_TITLE_CHANGE:
        // Byte 9-12 - new title ID
    }

    public class SecMsgDataPulse_TitleChange : SecMsgDataPulse
    {
        public byte                     ChangeType      = SecMsgDataPulse.XBPULSE_TITLE_CHANGE;
        public ulong                    UserPuid        = 0;
        public uint                     TitleId         = 0;

        public new const int SIZE = SecMsgDataPulse.SIZE + 9 + 4;
        public SecMsgDataPulse_TitleChange()
        {
            this.cbEnt = SIZE;
        }
    }

    public class SecMsgDataPulse_StateChange : SecMsgDataPulse
    {
        public byte                     ChangeType      = SecMsgDataPulse.XBPULSE_STATE_CHANGE;
        public ulong                    UserPuid        = 0;
        public uint                     State           = 0;

        public new const int SIZE = SecMsgDataPulse.SIZE + 9 + 4;
        public SecMsgDataPulse_StateChange()
        {
            this.cbEnt = SIZE;
        }
    }

    public class SecMsgDataPulseResp : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2;
        //public short                    cbEnt           = (short)SIZE;
        public uint                     SeqAck          = 0;            // Acknowledgement sequence number

        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgDataPulseResp() : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_PULSE_2, SIZE)
        {
        }

        // The rest of this entry contains a series of _qwUserId / CQVal-list pairs.
        // The end of the CQVal list specified by a zero DWORD or the end of this
        // entry, whichever comes first.
    }

    public class SecMsgDelete : SecMsgHeader
    {
        // Reasons for Delete
        public const int    SHUTDOWN        = 0x0000;   // Client is shutting down or logging off 
        public const int    UNREGISTER      = 0x0001;   // Client unregistered key
        public const int    KICK            = 0x0002;   // Client has been kicked for duplicate logon
        public const int    QOS             = 0x0003;   // Client finished Qos lookup
        public const int    KILL            = 0x0004;   // Server is terminating the session

        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_DELETE;
        //public short                    cbEnt           = (short)SIZE;
        public uint                     Reason          = 0;

        public new const int SIZE = SecMsgHeader.SIZE + 4;
        public SecMsgDelete() : base(SecMsgHeader.SECMSG_TYPE_DELETE, SIZE)
        {
        }
    }

    public class SecMsgChangeUsersReq : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REQ;
        //public short                    cbEnt           = (short)SIZE;
        public uint                     UserPerm        = 0;            // Permutation and guest bits for all 4 users
        public long                     Time            = 0;            // Kerberos time of AP request

        // The rest of this entry contains the Kerberos AP request.

        [WireInfo(WriteOnlyVarLenString=true)]
        public byte[]                   APReqData       = new byte[0];  // Kerberos AP request

        public int CURRENT_SIZE
        {
            get
            {
                return SecMsgHeader.SIZE + 12 + APReqData.Length;
            }
        }

        public SecMsgChangeUsersReq() : base(SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REQ, SIZE)
        {
        }

        //we override these so we can fix the packet length to the correct field just before it gets serialized
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            cbEnt = (short)(CURRENT_SIZE);
            base.WriteStream(binaryWriter);
        }
    }

    public class SecMsgChangeUsersRep : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REP;
        //public short                    cbEnt           = (short)SIZE;
        public long                     Time            = 0;            // Kerberos time of AP request

        public new const int SIZE = SecMsgHeader.SIZE + 8;
        public SecMsgChangeUsersRep() : base(SecMsgHeader.SECMSG_TYPE_CHANGE_USERS_REP, SIZE)
        {
        }
    }

    public class SecMsgXbToSgChalResp : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(ArraySize=20)]
        public byte[]                   DvdHash         = new byte[20];     // Hash of part of DVD block
        [WireInfo(ArraySize=20)]
        public byte[]                   DvdCopy         = new byte[20];     // Copy of part of DVD block
        [WireInfo(ArraySize=256)]
        public byte[]                   Execute         = new byte[256];     // Result of executing the challenge code

        public new const int SIZE = SecMsgHeader.SIZE + 296;
        public SecMsgXbToSgChalResp() : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP, SIZE)
        {
            ManualArraySize = true;
        }
    }

    public class SecMsgXbToSgChalResp3 : SecMsgHeader
    {
        //public short                    Type            = SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP;
        //public short                    cbEnt           = (short)SIZE;
        [WireInfo(ArraySize=1024)]
        public byte[]                   Execute         = new byte[1024];     // Result of executing the challenge code

        public new const int SIZE = SecMsgHeader.SIZE + 1024;
        public SecMsgXbToSgChalResp3 () : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_CHALRESP_3, SIZE)
        {
            ManualArraySize = true;
        }
    }

    public class SecMsgNatDetReq : SecMsgHeader
    {
        // no payload
        public new const int SIZE = SecMsgHeader.SIZE;
        public SecMsgNatDetReq() : base(SecMsgHeader.SECMSG_TYPE_XBTOSG_NATDET_REQ, SIZE)
        {
        }
    }

    public class SecMsgNatDetRep : SecMsgHeader
    {
        // no payload
        public new const int SIZE = SecMsgHeader.SIZE;
        public SecMsgNatDetRep() : base(SecMsgHeader.SECMSG_TYPE_SGTOXB_NATDET_REP, SIZE)
        {
        }
    }

    public class SecMsgXbToXbForward : SecMsgHeader
    {
        public SGAddress                sgaddr          = new SGAddress();

        // The rest of this entry contains the actual message being forwarded
        [WireInfo(ArraySize=0)]
        public byte[]                   message         = null;

        public new const int SIZE = SecMsgHeader.SIZE + SGAddress.SIZE;
        public SecMsgXbToXbForward() : base(SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD, SIZE)
        {
        }

        public override WireData ReadStream(BinaryReader br)
        {
            this.Type = (short)br.ReadInt16();
            this.cbEnt = (short)br.ReadInt16();
            sgaddr.ReadStream(br);

            int remaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
            int messageLength = cbEnt - 4 - 20;  // the header + the SGADDR
            System.Diagnostics.Debug.Assert(messageLength <= remaining);
            message = br.ReadBytes(messageLength);

            return this;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            base.cbEnt = (short)(SIZE + (message != null ? message.Length : 0));
            bw.Write(base.Type);
            bw.Write(base.cbEnt);
            sgaddr.WriteStream(bw);

            if (message != null && message.Length > 0)
            {
                bw.Write(message);
            }

        }
    }
    
    public class SecMsgXbToXbForward2 : SecMsgHeader
    {
        public SGAddress                sgaSender        = new SGAddress();
        public SGAddress                sgaTarget        = new SGAddress();

        // The rest of this entry contains the actual message being forwarded
        [WireInfo(ArraySize=0)]
        public byte[]                   message         = null;

        public new const int SIZE = SecMsgHeader.SIZE + (SGAddress.SIZE * 2);
        public SecMsgXbToXbForward2() : base(SecMsgHeader.SECMSG_TYPE_XBTOXB_FORWARD2, SIZE)
        {
        }

        public void SetMessage(byte[] payload)
        {
            message = payload;
            if (message != null)
            {
                this.cbEnt = (short)(SIZE + message.Length);
            }
        }

        public override WireData ReadStream(BinaryReader br)
        {
            this.Type = (short)br.ReadInt16();
            this.cbEnt = (short)br.ReadInt16();
            sgaSender.ReadStream(br);
            sgaTarget.ReadStream(br);

            int remaining = (int)(br.BaseStream.Length - br.BaseStream.Position);
            int messageLength = cbEnt - 4 - 40;  // the header + the 2*SGADDR
            System.Diagnostics.Debug.Assert(messageLength <= remaining);
            message = br.ReadBytes(messageLength);

            return this;
        }

        public override void WriteStream(BinaryWriter bw)
        {
            //base.cbEnt = (short)(SIZE + (message != null ? message.Length : 0));
            bw.Write(base.Type);
            bw.Write(base.cbEnt);
            sgaSender.WriteStream(bw);
            sgaTarget.WriteStream(bw);

            if (message != null && message.Length > 0)
            {
                bw.Write(message);
            }
        }
    }






    #endregion


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\KerberosError.cs ===
using System.Collections.Generic;
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> An exception containing a kerberos error. </summary>
    public class KerberosErrorException: KerberosAsnException
    {
        public KerberosError Error;

        public KerberosErrorException(KerberosError ke) { Error=ke; }
        public KerberosErrorException(KerberosError ke, string msg): base(msg) { Error=ke; }
        public KerberosErrorException(KerberosError ke, string msg, System.Exception e): base(msg, e) { Error=ke; }

        public override string ToString()
        {
            string s=base.ToString();
            s+="\nKerberos Error:\n"+Error;
            return s;
        }
    };

    /// <summary> Represents a kerberos error (rfc 4120). </summary>
    public class KerberosError
    {
        public Raw.Integer            Version;                //tag 0             //normally always 5
        public Raw.Integer            MessageType;            //tag 1             //should be 30
        public Kerberos.Time          ClientTime;             //tag 2  (optional)
        public Raw.Integer            ClientTimeMicroseconds; //tag 3  (optional)
        public Kerberos.Time          ServerTime;             //tag 4
        public Raw.Integer            ServerTimeMicroseconds; //tag 5
        public Raw.Integer            ErrorCode;              //tag 6
        public Raw.GeneralString      ClientRealm;            //tag 7
        public Kerberos.PrincipalName ClientName;             //tag 8  (optional)
        public Raw.GeneralString      ServerRealm;            //tag 9
        public Kerberos.PrincipalName ServerName;             //tag 10
        public Raw.GeneralString      ErrorText;              //tag 11 (optional)
        public Raw.OctetString        ErrorData;              //tag 12 (optional)

        /// <summary> Walks through an asn tree containing a kerberos error and creates a KerberosError using the data from the tree.  If the message is not a kerberos error, this throws. </summary>
        public static KerberosError CreateFromAsn(AsnValueBase asnTree)
        {
            KerberosError err=CreateFromAsnIfError(asnTree);
            if (err==null)
            {
                throw new KerberosAsnException("The asn tree is not a kerberos error.");
            }

            return err;
        }

        /// <summary> Walks through an asn tree containing a kerberos error and creates a KerberosError using the data from the tree.  If the message is not tagged as a kerberos error, this returns null. </summary>
        public static KerberosError CreateFromAsnIfError(AsnValueBase asnTree)
        {
            //Extract the overall application tag for a reply and its sequence
            Compound.ExplicitTagLengthValue mainAppTag=asnTree as Compound.ExplicitTagLengthValue;
            Compound.Sequence mainAppSequence;
            if (mainAppTag==null)
            {
                return null;
            }

            //verify error tag
            ulong mainAppTagNumber=mainAppTag.ExplicitTag.Number;
            if (mainAppTagNumber!=30 || mainAppTag.ExplicitTag.Class!=TagClasses.Application || !mainAppTag.ExplicitTag.Constructed)
            {
                return null;
            }

            if (mainAppTag.ValueTag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
            {
                throw new KerberosAsnException("Overall kdc error has the wrong value tag: "+mainAppTag.ValueTag.ToString());
            }

            mainAppSequence=(Compound.Sequence)mainAppTag.Value;

            //step through the main sequence
            KerberosError err=new KerberosError();
            long lastTagNumber=-1;
            foreach (AsnValueBase seqEntry in mainAppSequence.Values)
            {
                Compound.ExplicitTagLengthValue tag=seqEntry as Compound.ExplicitTagLengthValue;
                if (tag==null)
                {
                    throw new KerberosAsnException("The main sequence in the overall kdc error has an entry that is not explicitely tagged.");
                }

                ulong tagNumber=tag.ExplicitTag.Number;
                if ((long)tagNumber<=lastTagNumber)
                {
                    throw new KerberosAsnException("Tag numbers are out of order in kdc error's main sequence.");
                }

                //match the tag number and process it
                if (tagNumber==0) //version
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.Integer()).GetDefaultTag(), tag.ValueTag);
                    err.Version=(Raw.Integer)tag.Value;
                }
                else if (tagNumber==1) //message type
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.Integer()).GetDefaultTag(), tag.ValueTag);
                    err.MessageType=(Raw.Integer)tag.Value;
                }
                else if (tagNumber==2) //client time
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralizedTime()).GetDefaultTag(), tag.ValueTag);
                    err.ClientTime=new Kerberos.Time((Raw.GeneralizedTime)tag.Value);
                }
                else if (tagNumber==3) //client time microseconds
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.Integer()).GetDefaultTag(), tag.ValueTag);
                    err.ClientTimeMicroseconds=(Raw.Integer)tag.Value;
                }
                else if (tagNumber==4) //server time
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralizedTime()).GetDefaultTag(), tag.ValueTag);
                    err.ServerTime=new Kerberos.Time((Raw.GeneralizedTime)tag.Value);
                }
                else if (tagNumber==5) //server time microseconds
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.Integer()).GetDefaultTag(), tag.ValueTag);
                    err.ServerTimeMicroseconds=(Raw.Integer)tag.Value;
                }
                else if (tagNumber==6) //error code
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.Integer()).GetDefaultTag(), tag.ValueTag);
                    err.ErrorCode=(Raw.Integer)tag.Value;
                }
                else if (tagNumber==7) //client realm
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralString()).GetDefaultTag(), tag.ValueTag);
                    err.ClientRealm=(Raw.GeneralString)tag.Value;
                }
                else if (tagNumber==8) //client name
                {
                    err.ClientName=Kerberos.PrincipalName.CreateFromAsn(tag.GetValueTagLengthValue());
                }
                else if (tagNumber==9) //server realm
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralString()).GetDefaultTag(), tag.ValueTag);
                    err.ServerRealm=(Raw.GeneralString)tag.Value;
                }
                else if (tagNumber==10) //server name
                {
                    err.ServerName=Kerberos.PrincipalName.CreateFromAsn(tag.GetValueTagLengthValue());
                }
                else if (tagNumber==11) //error text
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralString()).GetDefaultTag(), tag.ValueTag);
                    err.ErrorText=(Raw.GeneralString)tag.Value;
                }
                else if (tagNumber==12) //error data
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.OctetString()).GetDefaultTag(), tag.ValueTag);
                    err.ErrorData=(Raw.OctetString)tag.Value;
                }
                else
                {
                    Global.RO.Warn("Unhandled tag number in KerberosReply: "+tagNumber);
                }
            }

            return err;
        }

        //
        public override string ToString()
        {
            string s="";

            s+="Version: "+Version;
            s+="\nMessageType: "+MessageType;
            s+="\nClientTime: "+ClientTime;
            s+="\nClientTimeMicroseconds: "+ClientTimeMicroseconds;
            s+="\nServerTime: "+ServerTime;
            s+="\nServerTimeMicroseconds: "+ServerTimeMicroseconds;
            s+="\nErrorCode: "+(ErrorCode==null?"":ErrorCode+"("+(KerbErrCode)ErrorCode.Int64+")");
            s+="\nClientRealm: "+ClientRealm;
            s+="\nClientName: "+ClientName;
            s+="\nServerRealm: "+ServerRealm;
            s+="\nServerName: "+ServerName;
            s+="\nErrorText: "+ErrorText;
            s+="\nErrorData: "+ErrorData;

            return s;
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\KdcClient.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> Thrown for KdcClient errors. </summary>
    public class KdcClientException: System.Exception
    {
        public KdcClientException() {}
        public KdcClientException(string msg): base(msg) {}
        public KdcClientException(string msg, System.Exception e): base(msg, e) {}
    };

    /// <summary> Wrapper for making requests to and retrieving responses from Xmacs, Askdc, and Xkdc. </summary>
    public class KdcClient
    {
        //Current client type.  Requests and replies will be created and parsed based on the current value of this.
        public AuthContext.ClientTypes CurrentClientType;

        public bool RetryLostPackets=true;  //retry requests that don't get a response
        public bool DecryptReplies=true; //attempt to decrypt reply bodies
        public bool DecryptTickets=true; //attempt to decrypt tickets in replies
        public bool VerifyReplyBasics=true; //verify the bacic fields common to all replies

        public static bool VerboseOutput=false; //writes out details of every request and reply and error

        // -- xmacs stuff

        //most recent xmacs request and reply, and final output to be carried over to the askdc
        public XmacsGenericRequest XmacsRequest;
        public XmacsGenericReply XmacsReply;
        public XmacsGenericReplyOutput XmacsOutput;
        public KerberosError XmacsError;

        //nonces used for the xmacs requests
        public uint []XmacsNOnces=new uint[6];
        public uint XmacsNOncesUsed;

        //xmacs timeout setting
        public static int DefaultXmacsTimeoutTimeInMs=4000;
        public int XmacsTimeoutTimeInMs=DefaultXmacsTimeoutTimeInMs;

        //whether to throw an exception if an xmacs reply is a kerberos error
        public bool XmacsThrowOnKerberosError=true;

        // -- askdc stuff

        //most recent askdc request and reply, and output to be carried over for re-use by askdc or for use by xkdc
        public AskdcGenericRequest AskdcRequest;
        public AskdcGenericReply AskdcReply;
        public AskdcGenericReplyOutput AskdcOutput;
        public KerberosError AskdcError;

        //askdc timeout setting
        public static int DefaultAskdcTimeoutTimeInMs=2000;
        public int AskdcTimeoutTimeInMs=DefaultAskdcTimeoutTimeInMs;

        //delegate for handling preauth required error, for echo (set to null to disable handling and treat as a normal error)
        public delegate void AskdcPreauthRequiredErrorDelegate(ref AskdcGenericRequest askdcRequestToChange, KerberosError askdcReplyError);
        public AskdcPreauthRequiredErrorDelegate AskdcPreauthRequiredErrorHandler=DefaultAskdcPreauthRequiredErrorHandler;

        public KerberosError AskdcEchoError=null; //most recent echo error response
        public static bool DecryptEchoPreauth=true; //decrypt echo preauths

        //whether to throw an exception if an askdc reply is a kerberos error (other than echo unless echo handling is disabled)
        public bool AskdcThrowOnKerberosError=true;

        // -- xkdc stuff

        //most recent xkdc request and reply, and output from the reply
        public XkdcGenericRequest XkdcRequest;
        public XkdcGenericReply XkdcReply;
        public XkdcGenericReplyOutput XkdcOutput;
        public KerberosError XkdcError;

        //nonces used for the xkdc requests
        public uint []XkdcNOnces=new uint[6];
        public uint XkdcNOncesUsed;

        //xkdc timeout setting
        public static int DefaultXkdcTimeoutTimeInMs=2000;
        public int XkdcTimeoutTimeInMs=DefaultXkdcTimeoutTimeInMs;

        //whether to throw an exception if an xkdc reply is not a kerberos error, but the overall hr result from the xbox preauth indicates failure
        public bool XkdcThrowOnOverallHRFailure=true;

        //whether to throw an exception if an xkdc reply is a kerberos error
        public bool XkdcThrowOnKerberosError=true;

        //null means "default expectations", else this overrides expectations.
        public bool? ExpectXkdcServiceAddressFailed=null; //only relevent to request versions 6+.  
        public bool? ExpectXkdcValidTicket=null;

        // -- internals

        protected System.Net.Sockets.Socket socket=new System.Net.Sockets.Socket(System.Net.Sockets.AddressFamily.InterNetwork, System.Net.Sockets.SocketType.Dgram, System.Net.Sockets.ProtocolType.Udp);

        private static int lastBoundPort=1025;
        public static int []BlacklistedPorts=new int[]{88, 464, 1900, 22528, 53249}; //windows has problems with kerberos stuff happening on these

        private bool isEchoRetry=false;

        protected static ServerTestFramework.Report ro=new ServerTestFramework.Report("KDC");

        // --
        public static KdcClient CreateForClientType(AuthContext.ClientTypes clientType)
        {
            if (clientType == AuthContext.ClientTypes.Xenon) //xbox360
            {
                return new KdcClientXbox360();
            }
            else if (clientType == AuthContext.ClientTypes.Panorama) //PC
            {
                return new KdcClientPC();
            }
            else if (clientType == AuthContext.ClientTypes.Xbox || clientType == AuthContext.ClientTypes.XenonBackCompat) //xbox1
            {
                return new KdcClientXbox1();
            }
            else
            {
                throw new System.Exception("Unknown client type: " + clientType);
            }
        }

        public KdcClient(AuthContext.ClientTypes initialClientType)
        {
            CurrentClientType=initialClientType;
        }

        // -- Xmacs

        /// <summary>Indicates if this client has completed an Xmacs request</summary>
        public bool SignedInXmacs
        {
            get { return XmacsOutput != null; }
        }

        /// <summary> Clears out any stored xmacs data. </summary>
        public void ClearXmacs()
        {
            XmacsRequest=null;
            XmacsReply=null;
            XmacsOutput=null;
            XmacsError=null;
            XmacsNOncesUsed=0;
        }

        /// <summary> This creates a new XmacsRequest and sets SetDefaults for it.  If an xmacs request had already been done and not cleared, the previously created machine will be reset instead. </summary>
        public void CreateXmacsRequest()
        {
            //save previous request input (if any) for reset and clear
            XmacsGenericRequestInput prevMachineInput=null;
            if (XmacsRequest!=null)
            {
                prevMachineInput=XmacsRequest.Input;
            }
            ClearXmacs();

            //setup new request
            XmacsRequest=XmacsGenericRequest.CreateForClientType(CurrentClientType);
            if (prevMachineInput==null)
            {
                XmacsRequest.Input.SetDefaults();
            }
            else
            {
                XmacsRequest.Input.SetResetDefaults(prevMachineInput);
            }
        }

        /// <summary> Parses an xmacs reply from ASN. </summary>
        public void SetXmacsReply(AsnValueBase asn)
        {
            XmacsReply=null;
            XmacsOutput=null;

            //check for error
            XmacsError=KerberosError.CreateFromAsnIfError(asn);
            if (XmacsError!=null)
            {
                if (VerboseOutput)
                {
                    ro.Debug("Xmacs Error Reply:\n"+XmacsError);
                }

                if (XmacsThrowOnKerberosError)
                {
                    throw new KerberosErrorException(XmacsError, "Xmacs reply was an error."+(XmacsError.ErrorCode!=null?" ("+((KerbErrCode)XmacsError.ErrorCode.Int64).ToString()+")":""));
                }
                else
                {
                    return;
                }
            }

            //set
            XmacsReply=XmacsGenericReply.CreateFromAsnForClientType(asn, CurrentClientType);

            //now decrypt the reply
            if (DecryptReplies || DecryptTickets)
            {
                byte []ticketKey=null;
                if (DecryptTickets)
                {
                    ticketKey=ServiceKeys.Key_XmacsTicket;
                }

                byte []sessionKey=null;
                if (DecryptReplies)
                {
                    sessionKey=XmacsRequest.Input.Key;
                }

                //try all nonces
                bool decryptSuccess=false;
                for (int i=0; i<XmacsNOncesUsed; ++i)
                {
                    decryptSuccess=XmacsReply.Decrypt(sessionKey, ticketKey, XmacsNOnces[i]);
                    if (decryptSuccess)
                    {
                        break;
                    }
                }

                if (!decryptSuccess)
                {
                    ro.Warn("Failed to completely decrypt xmacs reply, after trying all "+XmacsNOncesUsed+" nonce(s).");
                }
            }

            XmacsOutput=XmacsReply.Output;

            if (VerboseOutput)
            {
                ro.Debug("Xmacs Reply:\n"+XmacsReply);
            }

            if (VerifyReplyBasics)
            {
                XmacsReply.VerifyBasics();
            }

            if (XmacsOutput==null)
            {
                throw new KdcClientException("XmacsOutput could not be set from the reply (decrypt failed?).");
            }
        }

        /// <summary> Synchronously sends and receieves the xmacs request and stores the reply. </summary>
        public void ExecuteXmacs(bool prepareRequest)
        {
            //fix up the request if needed
            if (XmacsRequest==null)
            {
                CreateXmacsRequest();
                prepareRequest=true;
            }


            //send and receieve the request, retrying as needed
            AsnValueBase asn=SendAndReceiveWithRetries("Xmacs("+XmacsRequest.Input.ConsoleId+")", XmacsRequest, XmacsNOnces, ref XmacsNOncesUsed, prepareRequest, XmacsTimeoutTimeInMs);

            SetXmacsReply(asn);
        }

        // -- Askdc

        /// <summary>Indicates if this client has completed an Askdc request</summary>
        public bool SignedInAskdc
        {
            get { return AskdcOutput != null; }
        }

        /// <summary> Clears out any stored askdc data. </summary>
        public void ClearAskdc()
        {
            AskdcRequest=null;
            AskdcReply=null;
            AskdcOutput=null;
            AskdcError=null;
            AskdcEchoError=null;
        }

        /// <summary> This creates a new AskdcRequest and sets defaults for it.  If there is a previous askdc ticket it will be carried over into this request.  If no xmacs output exists an xmacs request will be executed. </summary>
        public void CreateAskdcMachineRequest()
        {
            //do xmacs if needed
            if (XmacsOutput==null)
            {
                ExecuteXmacs(true);
            }

            //store information from the previous response (if any)
            Kerberos.Ticket prevTicket=null;
            byte []sessionKey=null;
            if (AskdcOutput!=null)
            {
                prevTicket=AskdcOutput.Ticket;
                sessionKey=AskdcOutput.SessionKey;
            }

            KerberosError previousEchoError=AskdcEchoError; //keep echo error to re-use for the request chain

            //
            ClearAskdc();
            AskdcEchoError=previousEchoError;

            AskdcRequest=AskdcGenericRequest.CreateForClientType(CurrentClientType);
            AskdcRequest.Input.SetMachineDefaults(XmacsOutput, sessionKey, prevTicket);
            if (AskdcEchoError!=null)
            {
                AskdcRequest.Input.SetEchoPreauth(AskdcEchoError, false); //this will just result in storing the bytes, the process right now won't have the decrypted structure as part of the request
            }

            //for xbox360, take the cert from the xmacs request and add that to the input if we have it, so that duplicate console IDs will be distinguishable.
            if (CurrentClientType==AuthContext.ClientTypes.Xenon)
            {
                if (XmacsRequest!=null && XmacsRequest.Input!=null && XmacsRequest.Input is XmacsXbox360RequestInput)
                {
                    AskdcRequest.Input.ConsoleCert=((XmacsXbox360RequestInput)XmacsRequest.Input).FindConsoleCertificateInPreauths();
                }
            }
        }

        /// <summary> This creates a new AskdcRequest and sets defaults for it.  If there is a previous askdc ticket it will be carried over into this request. </summary>
        public void CreateAskdcUserRequest(KdcUser user)
        {
            //create user if it is empty
            if (user==null)
            {
                user=new KdcUser();
            }

            if (user.UserID==0)
            {
                user.CreateUser();
            }

            //store information from the previous response (if any)
            Kerberos.Ticket prevTicket=null;
            byte []sessionKey=null;
            if (AskdcOutput!=null)
            {
                prevTicket=AskdcOutput.Ticket;
                sessionKey=AskdcOutput.SessionKey;
            }

            KerberosError previousEchoError=AskdcEchoError; //keep echo error to re-use for the request chain

            //
            ClearAskdc();

            if (CurrentClientType!=AuthContext.ClientTypes.Panorama) //our KDC doesn't handle echos with pc users correctly yet.  Remove this once it does.
            {
                AskdcEchoError=previousEchoError;
            }

            AskdcRequest=AskdcGenericRequest.CreateForClientType(CurrentClientType);
            AskdcRequest.Input.SetUserDefaults(user, sessionKey, prevTicket);
            if (AskdcEchoError!=null)
            {
                AskdcRequest.Input.SetEchoPreauth(AskdcEchoError, false); //this will just result in storing the bytes, the process right now won't have the decrypted structure as part of the request
            }
        }

        /// <summary> Parses an askdc reply from ASN. </summary>
        public void SetAskdcReply(AsnValueBase asn)
        {
            AskdcReply=null;
            AskdcOutput=null;
            AskdcError=null;

            //check for error.  we expect preauth required and handle that specially
            KerberosError err=KerberosError.CreateFromAsnIfError(asn);
            if (err!=null)
            {
                if (VerboseOutput)
                {
                    ro.Debug("Askdc Error Reply:\n"+err);
                }

                if (AskdcPreauthRequiredErrorHandler!=null && err.ErrorCode.Int64==(long)KerbErrCode.KDC_ERR_PREAUTH_REQUIRED && !isEchoRetry)
                {
                    //update request for echo preauth
                    AskdcEchoError=err;
                    AskdcPreauthRequiredErrorHandler(ref AskdcRequest, err);

                    //try it again now that echo has been set
                    try
                    {
                        isEchoRetry=true;
                        ExecuteAskdc(false);
                    }
                    finally
                    {
                        isEchoRetry=false;
                    }
                    return;
                }

                //it's actually an error (or an echo error and handling was disabled)
                AskdcError=err;
                if (AskdcThrowOnKerberosError)
                {
                    throw new KerberosErrorException(err, "Askdc reply was an error."+(err.ErrorCode!=null?" ("+((KerbErrCode)err.ErrorCode.Int64).ToString()+")":""));
                }
                else
                {
                    return;
                }
            }

            //set and decrypt
            AskdcReply=AskdcGenericReply.CreateFromAsnForClientType(asn, CurrentClientType);

            //now decrypt the reply
            if (DecryptReplies || DecryptTickets)
            {
                byte []ticketKey=null;
                if (DecryptTickets)
                {
                    ticketKey=ServiceKeys.GetServiceKey(ServiceKeys.Key_KdcXboxCom);
                }

                byte []sessionKey=null;
                if (DecryptReplies)
                {
                    sessionKey=AskdcRequest.Input.CompoundKey??AskdcRequest.Input.IndividualKey;
                }

                //try all nonces
                bool decryptSuccess=AskdcReply.Decrypt(sessionKey, ticketKey);
                if (!decryptSuccess)
                {
                    ro.Warn("Failed to completely decrypt askdc reply, after trying all "+XmacsNOncesUsed+" nonce(s).");
                }
            }

            AskdcOutput=AskdcReply.Output;

            if (VerboseOutput)
            {
                ro.Debug("Askdc Reply:\n"+AskdcReply);
            }

            if (VerifyReplyBasics)
            {
                AskdcReply.VerifyBasics();
            }

            if (AskdcOutput==null || AskdcOutput.SessionKey==null)
            {
                throw new KdcClientException("AskdcOutput could not be fully set from the reply (decrypt failed?).");
            }
        }

        /// <summary> Synchronously sends and receieves the askdc request and stores the reply. </summary>
        public void ExecuteAskdc(bool prepareRequest)
        {
            //fix up the request if needed
            if (AskdcRequest==null)
            {
                CreateAskdcMachineRequest();
                prepareRequest=true;
            }

            //send and receieve the request, retrying as needed
            uint []nonces=new uint[6];
            uint nonceCount=0;
            AsnValueBase asn=SendAndReceiveWithRetries("Askdc("+AskdcRequest.Input.ConsoleOrUserName+")", AskdcRequest, nonces, ref nonceCount, prepareRequest, AskdcTimeoutTimeInMs);

            SetAskdcReply(asn);
        }

        //The default way to handle preauth-required (echo) errors from the askdc
        public static void DefaultAskdcPreauthRequiredErrorHandler(ref AskdcGenericRequest askdcRequestToChange, KerberosError askdcReplyError)
        {
            askdcRequestToChange.Input.SetEchoPreauth(askdcReplyError, DecryptEchoPreauth);
            askdcRequestToChange.SetRequest();
            askdcRequestToChange.ConstructRequest();
        }

        // -- Xkdc

        /// <summary>Indicates if this client has completed an Xkdc request</summary>
        public bool SignedInXkdc
        {
            get { return XkdcOutput != null; }
        }

        /// <summary> Clears out any stored xkdc data. </summary>
        public void ClearXkdc()
        {
            XkdcRequest=null;
            XkdcReply=null;
            XkdcOutput=null;
            XkdcError=null;
            XkdcNOncesUsed=0;
        }

        /// <summary> This creates a new XkdcRequest and sets SetDefaults for it. </summary>
        public void CreateXkdcRequest()
        {
            if (AskdcOutput==null)
            {
                ExecuteAskdc(true);
            }

            ClearXkdc();
            XkdcRequest=XkdcGenericRequest.CreateForClientType(CurrentClientType);
            XkdcRequest.Input.SetDefaults(AskdcOutput);
        }

        /// <summary> Parses an xkdc reply from ASN. </summary>
        public void SetXkdcReply(AsnValueBase asn)
        {
            XkdcReply=null;
            XkdcOutput=null;

            //check for error
            XkdcError=KerberosError.CreateFromAsnIfError(asn);
            if (XkdcError!=null)
            {
                if (VerboseOutput)
                {
                    ro.Debug("Xkdc Error Reply:\n"+XkdcError);
                }

                if (XkdcThrowOnKerberosError)
                {
                    throw new KerberosErrorException(XkdcError, "Xkdc reply was an error."+(XkdcError.ErrorCode!=null?" ("+((KerbErrCode)XkdcError.ErrorCode.Int64).ToString()+")":""));
                }
                else
                {
                    return;
                }
            }

            //set
            XkdcReply=XkdcGenericReply.CreateFromAsnForClientType(asn, CurrentClientType);

            //now decrypt the reply
            if (DecryptReplies || DecryptTickets)
            {
                byte []ticketKey=null;
                if (DecryptTickets)
                {
                    ticketKey=ServiceKeys.GetServiceKey(ServiceKeys.Key_SG, "sg", "site1");
                }

                byte []sessionKey=null;
                if (DecryptReplies)
                {
                    sessionKey=XkdcRequest.Input.Key;
                }

                //try all nonces
                bool decryptSuccess=false;
                for (int i=0; i<XkdcNOncesUsed; ++i)
                {
                    decryptSuccess=XkdcReply.Decrypt(sessionKey, ticketKey, XkdcNOnces[i]);
                    if (decryptSuccess)
                    {
                        break;
                    }
                }

                if (!decryptSuccess)
                {
                    ro.Warn("Failed to completely decrypt xkdc reply, after trying all "+XkdcNOncesUsed+" nonce(s).");
                }
            }

            XkdcOutput=XkdcReply.Output;

            if (VerboseOutput)
            {
                ro.Debug("Xkdc Reply:\n"+XkdcReply);
            }

            if (VerifyReplyBasics)
            {
                XkdcReply.VerifyBasics();

                if (XkdcRequest!=null && XkdcRequest.Input!=null && XkdcOutput!=null && XkdcReply!=null)
                {
                    bool gotTicket=(XkdcOutput.ServiceName[1].ToLower()!="site0");
                    bool isAutoDiscover=(XkdcRequest.Input.AutoDiscoverServices!=0);
                    AuthClientBase.VerifyXkdcResponseCommon(XkdcRequest.Input.GetServiceRequestVersion(), XkdcReply.ReplyWasServiceAddressFailure, gotTicket, ExpectXkdcServiceAddressFailed, XkdcOutput.Hr, XkdcOutput.HrUser, isAutoDiscover, ExpectXkdcValidTicket);
                }
            }

            //throw on service result error
            if (XkdcThrowOnOverallHRFailure && XkdcOutput!=null && XkdcOutput.Hr!=0)
            {
                throw new KdcClientException("Overall HR in the Xkdc reply is an error: 0x"+XkdcOutput.Hr.ToString("X"));
            }

            if (XkdcOutput==null || XkdcOutput.SessionKey==null)
            {
                throw new KdcClientException("XkdcOutput could not be fully set from the reply (decrypt failed?).");
            }
        }

        /// <summary> Synchronously sends and receieves the xkdc request and stores the reply. </summary>
        public void ExecuteXkdc(bool prepareRequest)
        {
            //fix up the request if needed
            if (XkdcRequest==null)
            {
                CreateXkdcRequest();
                prepareRequest=true;
            }

            //send and receieve the request, retrying as needed
            AsnValueBase asn=SendAndReceiveWithRetries("Xkdc("+XkdcRequest.Input.ConsoleId+")", XkdcRequest, XkdcNOnces, ref XkdcNOncesUsed, prepareRequest, XkdcTimeoutTimeInMs);

            SetXkdcReply(asn);
        }

        /// <summary> Returns whether the last xkdc reply had services on other sites, or true if we haven't done anything yet. </summary>
        public bool XkdcResultHasMoreSites()
        {
            if (XkdcOutput==null) //no response yet, so return that there are more to do
            {
                return true;
            }

            if (XkdcOutput.Hr!=0 || XkdcOutput.ServiceResults==null) //if the response was bad, do no more
            {
                return false;
            }

            //search services
            foreach (XkdcGenericReplyOutput.ServiceResult service in XkdcOutput.ServiceResults)
            {
                if (service.Hr==1) //1 means the service is on another site
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary> Updates the current xkdc request to only request services that previously returned as being on a different site.  If no request is set, sets a new default one. </summaryP
        public void SetXkdcRequestForNextSite()
        {
            if (XkdcRequest==null)
            {
                CreateXkdcRequest();
            }

            if (XkdcOutput==null || XkdcOutput.ServiceResults==null)
            {
                return;
            }

            //find all services that return as being on a different site
            System.Collections.Generic.List<uint> servicesWithHR1=new System.Collections.Generic.List<uint>();
            foreach (XkdcGenericReplyOutput.ServiceResult service in XkdcOutput.ServiceResults)
            {
                if (service.Hr==1)
                {
                    servicesWithHR1.Add(service.Service);
                }
            }

            //now update the request for the new set of services
            XkdcRequest.Input.SetServices(servicesWithHR1.ToArray());
            XkdcRequest.Input.PrepareForResend();
            XkdcNOncesUsed=0;
        }

        // -- common

        //Synchronously sends and receieves a request and returns the reply
        public AsnValueBase SendAndReceiveWithRetries(string description, KerberosRequestWithInput req, uint []nonceList, ref uint nonceCount, bool rebuildRequest, int timeoutInMs)
        {
            //send and receieve the request, retrying as needed
            int maxTries=1;
            if (RetryLostPackets)
            {
                maxTries=6;
            }

            nonceCount=0;
            byte []replyBytes=null;
            for (int tryNum=0; tryNum<maxTries; ++tryNum)
            {
                //update nonce if needed and store off that we tried that nonce, and rebuild the request
                if (tryNum>0 && rebuildRequest)
                {
                    req.Input.PrepareForResend();
                }

                if (rebuildRequest)
                {
                    req.Input.GeneratePreauths();
                    req.SetRequest();
                    req.ConstructRequest();
                }

                nonceList[nonceCount]=req.Input.GetNOnce();
                ++nonceCount;

                //send the packet
                if (VerboseOutput)
                {
                    long requestLength=req.GetLength();
                    ro.Debug(description+" Request("+requestLength+" bytes):\n"+req);
                }

                byte []sendBytes=req.GetBytes();
                SendPacket(sendBytes);

                //get the reply
                replyBytes=ReceivePacket(timeoutInMs);
                if (replyBytes!=null)
                {
                    break;
                }

                ro.Warn(description+" request timed out after "+timeoutInMs+"ms (try "+(tryNum+1)+" of "+maxTries+", local port="+((System.Net.IPEndPoint)(socket.LocalEndPoint)).Port+")");
            }

            if (replyBytes==null) //all timed out
            {
                throw new ServerTestFramework.Utilities.TimeoutException("All "+maxTries+" "+description+" requests timed out.");
            }

            //parse it to ASN and set the reply
            long replyBytesUsed;
            AsnValueBase asn=Compound.AsnValueParser.Parse(replyBytes, 0, replyBytes.Length, out replyBytesUsed);
            if (replyBytes.Length!=(int)replyBytesUsed)
            {
                //TEMPORARILY added to track down a rare bug: Dump out the bytes if we ever hit this
                Global.RO.Warn("TEMPORARY DEBUG: Reply Bytes: 0x"+ServerTestFramework.Utilities.Hexer.tohex(replyBytes));

                throw new AsnException("Parsing "+description+" reply as ASN: "+replyBytes.Length+" bytes were received but only "+replyBytesUsed+" were used.");
            }

            return asn;
        }

        //bind to a non-recently used port
        private static void BindSocketToNewPort(System.Net.Sockets.Socket socket)
        {
            const int seqMaxTries=10; //try up to 10 ports sequentually, then just ask the system to pick one for us

            for (int tryCount=0; tryCount<seqMaxTries+1; ++tryCount)
            {
                int bindPort=0;

                if (tryCount<seqMaxTries)
                {
                    int origBindChoice=System.Threading.Interlocked.Increment(ref lastBoundPort);
                    bindPort=origBindChoice;
                    if (bindPort>65534)
                    {
                        bindPort-=(65534-1024);
                        System.Threading.Interlocked.CompareExchange(ref lastBoundPort, bindPort+1, origBindChoice);
                    }
                }

                bool skipPort=false;
                foreach (int blackPort in BlacklistedPorts)
                {
                    if (bindPort==blackPort)
                    {
                        skipPort=true;
                    }
                }

                if (skipPort)
                {
                    --tryCount;
                    continue;
                }

                try
                {
                    socket.Bind(new System.Net.IPEndPoint(System.Net.IPAddress.Any, bindPort));
                    return;
                }
                catch (System.Net.Sockets.SocketException e)
                {
                    if (bindPort==0)
                    {
                        throw new System.Exception("Failed to bind socket ", e);
                    }
                }
            }
        }

        //sends a packet to the kdc
        public void SendPacket(byte []data)
        {
            if (!socket.IsBound) //we want to specifically bind to a random port that hasn't been recently bound to, to avoid accidentally receiving previously time out'd responses from unrelated requests
            {
                BindSocketToNewPort(socket);
            }

            System.Net.IPEndPoint ep=Global.XEnv.GetVirtualInterface("kdcsvc");
            socket.SendTo(data, ep);
        }

        //receives a packet from the kdc
        public byte[] ReceivePacket(int timeoutInMs)
        {
            System.Collections.ArrayList readList=new System.Collections.ArrayList();
            readList.Add(socket);
            System.Collections.ArrayList errorList=new System.Collections.ArrayList();
            errorList.Add(socket);

            System.Net.Sockets.Socket.Select(readList, null, errorList, timeoutInMs*1000);

            if (errorList.Count>0) //something went wrong, reset it
            {
                ResetSocket();
            }
            else if (readList.Count>0)
            {
                byte []temp=new byte[socket.Available];
                int used=socket.Receive(temp);
                if (used!=temp.Length)
                {
                    System.Array.Resize(ref temp, used);
                }
                return temp;
            }

            return null;
        }

        //resets the socket so it will re-bind on next use
        public void ResetSocket()
        {
            socket.Close();
            socket=new System.Net.Sockets.Socket(System.Net.Sockets.AddressFamily.InterNetwork, System.Net.Sockets.SocketType.Dgram, System.Net.Sockets.ProtocolType.Udp);
        }
    };

    // -- KdcClients with types casted as their platform-specific types

    public class KdcClientPlatformSpecific<XmacsRequestType, XmacsReplyType, AskdcRequestType, AskdcReplyType, XkdcRequestType, XkdcReplyType>: KdcClient
        where XmacsRequestType:XmacsGenericRequest where XmacsReplyType:XmacsGenericReply
        where AskdcRequestType:AskdcGenericRequest where AskdcReplyType:AskdcGenericReply
        where XkdcRequestType:XkdcGenericRequest   where XkdcReplyType: XkdcGenericReply
    {
        public new XmacsRequestType XmacsRequest
        {
            get { return (XmacsRequestType)base.XmacsRequest; }
            set { base.XmacsRequest=value; }
        }

        public new XmacsReplyType XmacsReply
        {
            get { return (XmacsReplyType)base.XmacsReply; }
            set { base.XmacsReply=value; }
        }

        public new AskdcRequestType AskdcRequest
        {
            get { return (AskdcRequestType)base.AskdcRequest; }
            set { base.AskdcRequest=value; }
        }

        public new AskdcReplyType AskdcReply
        {
            get { return (AskdcReplyType)base.AskdcReply; }
            set { base.AskdcReply=value; }
        }

        public new XkdcRequestType XkdcRequest
        {
            get { return (XkdcRequestType)base.XkdcRequest; }
            set { base.XkdcRequest=value; }
        }

        public new XkdcReplyType XkdcReply
        {
            get { return (XkdcReplyType)base.XkdcReply; }
            set { base.XkdcReply=value; }
        }

        public KdcClientPlatformSpecific(AuthContext.ClientTypes initialClientType): base(initialClientType) {}
    };

    /// <summary> Identical to KdcClient except member types are xbox360-specific. </summary>
    public class KdcClientXbox360: KdcClientPlatformSpecific<XmacsXbox360Request, XmacsXbox360Reply, AskdcXbox360Request, AskdcXbox360Reply, XkdcXbox360Request, XkdcXbox360Reply>
    {
        public KdcClientXbox360(): base(AuthContext.ClientTypes.Xenon) {}
    }

    /// <summary> Identical to KdcClient except member types are pc-specific. </summary>
    public class KdcClientPC: KdcClientPlatformSpecific<XmacsPCRequest, XmacsPCReply, AskdcPCRequest, AskdcPCReply, XkdcPCRequest, XkdcPCReply>
    {
        public KdcClientPC(): base(AuthContext.ClientTypes.Panorama) {}
    }

    /// <summary> Identical to KdcClient except member types are xbox1-specific. </summary>
    public class KdcClientXbox1: KdcClientPlatformSpecific<XmacsXbox1Request, XmacsXbox1Reply, AskdcXbox1Request, AskdcXbox1Reply, XkdcXbox1Request, XkdcXbox1Reply>
    {
        public KdcClientXbox1(): base(AuthContext.ClientTypes.Xbox) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\KerberosPreauths.cs ===
using ServerTestFramework.LiveService.Auth;

namespace ServerTestFramework.LiveService.Auth.Asn
{
    public partial class Kerberos
    {
        /// <summary> Returns the type number for a preauth. </summary>
        public interface IGetPreauthNumber
        {
            int GetPreauthNumber();
        }

        /// <summary> A Kerberos Preauth.  This is intended to be held directly within the sequence of preauths. </summary>
        public class Preauth: AsnValueBase
        {
            //Values used for the preauth
            public Raw.Integer Type      //tag 1
            {
                get { return type; }
                set
                {
                    type=value;
                    TypeTag.Value=value;
                }
            }
            private Raw.Integer type=new Raw.Integer();

            public AsnValueBase Data     //tag 2
            {
                get { return data; }
                set
                {
                    data=value;
                    DataContainer.Value=value;
                }
            }
            private AsnValueBase data=null;

            //Glue used to hold the values
            public Compound.TagLengthValue SequenceTag=new Compound.TagLengthValue();
            public Compound.Sequence Sequence=new Compound.Sequence();
            public Compound.ExplicitTagLengthValue TypeTag=new Compound.ExplicitTagLengthValue(); //tag 1
            public Compound.ExplicitTagLengthValue DataTag=new Compound.ExplicitTagLengthValue(); //tag 2
            public Compound.OctetString DataContainer=new Compound.OctetString();

            //
            public Preauth()
            {
                //link everything together
                SequenceTag.Tag=Sequence.GetDefaultTag();
                SequenceTag.Value=Sequence;

                Sequence.Values=new AsnValueBase[2];
                Sequence.Values[0]=TypeTag;
                Sequence.Values[1]=DataTag;

                TypeTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                TypeTag.ValueTag=Type.GetDefaultTag();
                TypeTag.Value=Type;

                DataTag.ExplicitTag=new Raw.Tag(2, TagClasses.Context, true);
                DataTag.ValueTag=DataContainer.GetDefaultTag();
                DataTag.ValueTag.Constructed=false; //even though in some cases our preauth itself is actually asn encoded... we still always say that it's not for some reason.
                DataTag.Value=DataContainer;

                DataContainer.Value=Data;
            }

            public override void AppendBytesTo(System.IO.MemoryStream byteList)
            {
                SequenceTag.AppendBytesTo(byteList);
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                return SequenceTag.ProcessLengths(updateLengthFields, updateNestedStructures);
            }

            //loads from an asn tag containing the sequence containing everything
            public static Preauth CreateFromAsn(Compound.TagLengthValue tag)
            {
                if (tag.Tag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
                {
                    throw new KerberosAsnException("Preauth tag does not contain a sequence.");
                }

                Compound.Sequence seq=(Compound.Sequence)tag.Value;

                //copy parts out of sequence
                Preauth pa=new Preauth();
                pa.Type=null;
                pa.Data=null;
                foreach (AsnValueBase val in seq.Values)
                {
                    Compound.ExplicitTagLengthValue expTag=(Compound.ExplicitTagLengthValue)val;
                    ulong expTagNumber=expTag.ExplicitTag.Number;
                    if (expTagNumber==1) //Type
                    {
                        pa.Type=(Raw.Integer)expTag.Value;
                    }
                    else if (expTagNumber==2) //Data
                    {
                        pa.Data=expTag.Value;
                    }
                    else
                    {
                        Global.RO.Warn("Unknown explicit tag found while parsing preauth: "+expTag);
                    }
                }

                return pa;
            }

            public override string ToString()
            {
                return "PA-"+Type.ToString()+": "+Data.ToString();
            }
        };

        /// <summary> A typed version of Preauth, where Data points to an instance of a specific type and Type is initialized to the preauth's value. </summary>
        public class Preauth<PreauthType>: Preauth where PreauthType: AsnValueBase, IGetPreauthNumber, new()
        {
            public new PreauthType Data
            {
                get { return (PreauthType)base.Data; }
                set
                {
                    base.Data=value;
                    DataContainer.Value=value;
                }
            }

            public Preauth()
            {
                Data=new PreauthType();
                Type.Int64=Data.GetPreauthNumber();
            }
        };

        /// <summary> PADATA_TGS_REQ(1) - Used to get a ticket from our Xkdc.  It is an encoding of an AP-REQ, which contains a ticket from our Askdc and an authenticator. </summary>
        public class PreauthTgsRequest: Compound.ExplicitTagLengthValue, IGetPreauthNumber
        {
            //Values used in the structure
            public Raw.Integer   Version       //tag 0   //normally 5
            {
                get { return version; }
                set
                {
                    version=value;
                    VersionTag.Value=value;
                }
            }
            private Raw.Integer version=new Raw.Integer();

            public Raw.Integer   MessageType   //tag 1   //normally 14
            {
                get { return messageType; }
                set
                {
                    messageType=value;
                    MessageTypeTag.Value=value;
                }
            }
            private Raw.Integer messageType=new Raw.Integer();

            public APOptions     APOptions     //tag 2   //we normally set nothing here
            {
                get { return apOptions; }
                set
                {
                    apOptions=value;
                    APOptionsTag.Value=value;
                }
            }
            private APOptions apOptions=new APOptions();

            public Ticket        Ticket        //tag 3   //this will be the ticket from our Askdc
            {
                get { return ticket; }
                set
                {
                    ticket=value;
                    TicketTag.SetValueTagLengthValue(value);
                }
            }
            private Ticket ticket;

            public EncryptedAuthenticator EncryptedAuthenticator //tag 4  //encrypted version of Authenticator
            {
                get { return encAuthenticator; }
                set
                {
                    encAuthenticator=value;
                    AuthenticatorTag.SetValueTagLengthValue(encAuthenticator);
                }
            }
            private EncryptedAuthenticator encAuthenticator=new EncryptedAuthenticator();

            //glue
            public Compound.Sequence MainSequence=new Compound.Sequence();
            public Compound.ExplicitTagLengthValue VersionTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue MessageTypeTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue APOptionsTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue TicketTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue AuthenticatorTag=new Compound.ExplicitTagLengthValue();

            //
            public PreauthTgsRequest()
            {
                //values
                Version.Int64=5;
                MessageType.Int64=14;

                //glue
                ExplicitTag=new Raw.Tag(14, TagClasses.Application, true);
                ValueTag=MainSequence.GetDefaultTag();
                Value=MainSequence;

                MainSequence.Values=new AsnValueBase[5];
                MainSequence.Values[0]=VersionTag;
                MainSequence.Values[1]=MessageTypeTag;
                MainSequence.Values[2]=APOptionsTag;
                MainSequence.Values[3]=TicketTag;
                MainSequence.Values[4]=AuthenticatorTag;

                VersionTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
                VersionTag.ValueTag=Version.GetDefaultTag();
                VersionTag.Value=Version;

                MessageTypeTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                MessageTypeTag.ValueTag=MessageType.GetDefaultTag();
                MessageTypeTag.Value=MessageType;

                APOptionsTag.ExplicitTag=new Raw.Tag(2, TagClasses.Context, true);
                APOptionsTag.ValueTag=APOptions.GetDefaultTag();
                APOptionsTag.Value=APOptions;

                TicketTag.ExplicitTag=new Raw.Tag(3, TagClasses.Context, true);
                //TicketTag.SetValueTagLengthValue(Ticket);

                AuthenticatorTag.ExplicitTag=new Raw.Tag(4, TagClasses.Context, true);
                AuthenticatorTag.SetValueTagLengthValue(encAuthenticator);
            }

            //
            public override string ToString()
            {
                string s="TgsRequest: Version="+Version+" MessageType="+MessageType+" APOptions="+APOptions;
                s+="\nTgsRequest Ticket:\n"+Ticket;
                s+="\nTgsRequest Authenticator:\n"+EncryptedAuthenticator;
                return s;
            }

            public int GetPreauthNumber()
            {
                return 1;
            }
        };

        /// <summary> PADATA_XENON_MAC_REQUEST(209) - Machine Account Creation Request for Xbox 360. </summary>
        public class PreauthXenonMacRequest: AsnValueBase, IGetPreauthNumber
        {
            //Actual data fields for the request
            public byte []EncryptedSessionKey;      //should always be 256 bytes.  the session key is encrypted with the xmacs public key
            public ulong  AuthTime;                 //the current time, as a windows 64 bit time value
            public byte []Signature;                //should always be 128 bytes.  the auth time and a sha1 hash of the session key, sha1 hashed then signed with the console key
            public ConsoleCertificate Certificate;  //the console's certificate

            //Additional data needed to correctly set the above fields (not part of the request itself)
            public byte[] RawSessionKey
            {
                get { return rawSessionKey; }
            }
            private byte []rawSessionKey;

            //sets all fields to new valid defaults for a specific console ID (which must start with XE.).  If session key is not specified, one is calculated from the console ID.  Defaults to a retail console type.
            public void SetDefaults(string consoleID, byte []sessionKey, bool useTestKey)
            {
                SetDefaults(consoleID, sessionKey, ConsoleCertificate.CONSOLE_TYPE_RETAIL, useTestKey);
            }

            //sets all fields to new valid defaults for a specific console ID (which must start with XE.).  If session key is not specified, one is calculated from the console ID.
            public void SetDefaults(string consoleID, byte []sessionKey, uint consoleType, bool useTestKey)
            {
                if (sessionKey==null)
                {
                    if (RawSessionKey==null)
                    {
                        sessionKey=AuthContext.CalculateKeyFromGamertag(consoleID, true);
                    }
                    else
                    {
                        sessionKey=RawSessionKey;
                    }
                }
                SetAndEncryptSessionKey(sessionKey, useTestKey);

                AuthTime=(ulong)System.DateTime.UtcNow.ToFileTimeUtc();

                Certificate=new ConsoleCertificate();
                Certificate.SetConsoleIdFromGamertag(consoleID);
                Certificate.SetConsoleType(consoleType);
                Certificate.Sign();

                Sign();
            }

            //sets the the encrypted session key, from a raw session key
            public void SetAndEncryptSessionKey(byte []sessionKey, bool useTestKey)
            {
                rawSessionKey=sessionKey;

                if (useTestKey)
                {
                    EncryptedSessionKey=XmacsKeys.EncryptWithTestKey(sessionKey);
                }
                else
                {
                    EncryptedSessionKey=XmacsKeys.EncryptWithRealKey(sessionKey);
                }
            }

            //This calculates a signature from EncryptedSessionKey and AuthTime and sets it into Signature.
            public void Sign()
            {
                //do the sha1 stuff
                System.Security.Cryptography.SHA1 sha1=new System.Security.Cryptography.SHA1Managed();

                byte []hashOfSessionKey=sha1.ComputeHash(RawSessionKey);

                byte []combinedBytes=new byte[hashOfSessionKey.Length+8];
                System.Array.Copy(System.BitConverter.GetBytes(AuthTime), 0, combinedBytes, 0, 8);
                System.Array.Copy(hashOfSessionKey, 0, combinedBytes, 8, hashOfSessionKey.Length);

                byte []finalHash=sha1.ComputeHash(combinedBytes);

                //sign that hash now
                if (Certificate.ConsolePublicKey.CspBlob==null) //use default test console key
                {
                    Signature=ConsoleKeys.SignHashWithConsoleKey(finalHash);
                }
                else //use the console private key that matches the public key in the certificate
                {
                    Signature=ConsoleKeys.SignHashWithConsoleCspBlob(finalHash, Certificate.ConsolePublicKey.CspBlob);
                }
            }

            //
            public override void AppendBytesTo(System.IO.MemoryStream byteList)
            {
                byteList.Write(EncryptedSessionKey, 0, EncryptedSessionKey.Length);
                byteList.Write(System.BitConverter.GetBytes(AuthTime), 0, 8);
                byteList.Write(Signature, 0, Signature.Length);
                Certificate.WriteStream(byteList);
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                long len=EncryptedSessionKey.Length;
                len+=8;
                len+=Signature.Length;
                len+=Certificate.Size();
                return len;
            }

            public int GetPreauthNumber()
            {
                return 209;
            }

            public override string ToString()
            {
                if (Signature==null) //not set yet?
                {
                    return "XenonMacRequest";
                }

                string s="XenonMacRequest:";
                s+="\nPAXenonMac SessionKey=0x"+ServerTestFramework.Utilities.Hexer.tohex(RawSessionKey);
                s+="\nPAXenonMac AuthTime="+AuthTime+" ("+System.DateTime.FromFileTimeUtc((long)AuthTime)+")";
                s+="\nPAXenonMac Signature=0x"+ServerTestFramework.Utilities.Hexer.tohex(Signature);
                s+="\nPAXenonMac ConsoleCertificate:\n";
                s+=Certificate;
                return s;
            }
        };

        /// <summary> PADATA_XENON_MAC_REQUEST2(219) - Machine Account Creation Request (v2) for Xbox 360. </summary>
        public class PreauthXenonMacRequest2: AsnValueBase, IGetPreauthNumber
        {
            //Actual data fields for the request
            public byte []EncryptedSessionKey;      //should always be 256 bytes.  the session key is encrypted with the xmacs public key
            public ulong  AuthTime;                 //the current time, as a windows 64 bit time value
            public byte []SerialNumber;             //12 byte console serial number, encoded as ascii with leading 0s (no null termination or anything)
            public byte []Signature;                //should always be 128 bytes.  the auth time and a sha1 hash of the session key, sha1 hashed then signed with the console key
            public ConsoleCertificate Certificate;  //the console's certificate

            //Helper for getting/setting serial number as a string
            public string SerialNumberAsString
            {
                get
                {
                    return ServerTestFramework.Utilities.ByteEncoding.Instance.GetString(SerialNumber);
                }

                set
                {
                    SerialNumber=ServerTestFramework.Utilities.ByteEncoding.Instance.GetBytes(value);
                }
            }

            //Additional data needed to correctly set the above fields (not part of the request itself)
            public byte[] RawSessionKey
            {
                get { return rawSessionKey; }
            }
            private byte []rawSessionKey;

            //sets all fields to new valid defaults for a specific console ID (which must start with XE.).  If session key is not specified, one is calculated from the console ID.  Defaults to a retail console type.
            public void SetDefaults(string consoleID, byte []sessionKey, bool useTestKey)
            {
                SetDefaults(consoleID, sessionKey, ConsoleCertificate.CONSOLE_TYPE_RETAIL, useTestKey, null);
            }

            //sets all fields to new valid defaults for a specific console ID (which must start with XE.).  If session key is not specified, one is calculated from the console ID.
            public void SetDefaults(string consoleID, byte []sessionKey, uint consoleType, bool useTestKey, string serialNum)
            {
                if (sessionKey==null)
                {
                    if (RawSessionKey==null)
                    {
                        sessionKey=AuthContext.CalculateKeyFromGamertag(consoleID, true);
                    }
                    else
                    {
                        sessionKey=RawSessionKey;
                    }
                }
                SetAndEncryptSessionKey(sessionKey, useTestKey);

                AuthTime=(ulong)System.DateTime.UtcNow.ToFileTimeUtc();

                if (serialNum==null)
                {
                    serialNum=GenerateRandomConsoleSerialNumber();
                }
                SerialNumberAsString=serialNum;

                Certificate=new ConsoleCertificate();
                Certificate.SetConsoleIdFromGamertag(consoleID);
                Certificate.SetConsoleType(consoleType);
                Certificate.Sign();

                Sign();
            }

            //sets the the encrypted session key, from a raw session key
            public void SetAndEncryptSessionKey(byte []sessionKey, bool useTestKey)
            {
                rawSessionKey=sessionKey;

                if (useTestKey)
                {
                    EncryptedSessionKey=XmacsKeys.EncryptWithTestKey(sessionKey);
                }
                else
                {
                    EncryptedSessionKey=XmacsKeys.EncryptWithRealKey(sessionKey);
                }
            }

            //This calculates a signature from EncryptedSessionKey and AuthTime and sets it into Signature.
            public void Sign()
            {
                //do the sha1 stuff
                System.Security.Cryptography.SHA1 sha1=new System.Security.Cryptography.SHA1Managed();

                byte []hashOfSessionKey=sha1.ComputeHash(RawSessionKey);

                byte []combinedBytes=new byte[hashOfSessionKey.Length+20]; // SerialNum = 12 bytes, AuthTime = 8 bytes

                // Bytes 0-7 : AuthTime
                System.Array.Copy(System.BitConverter.GetBytes(AuthTime), 0, combinedBytes, 0, 8);

                // Bytes 8-19 : Serial Number
                System.Array.Copy(SerialNumber, 0, combinedBytes, 8, 12);

                // Bytes 20+ : Session Key Hash
                System.Array.Copy(hashOfSessionKey, 0, combinedBytes, 20, hashOfSessionKey.Length);

                byte []finalHash=sha1.ComputeHash(combinedBytes);

                //sign that hash now
                if (Certificate.ConsolePublicKey.CspBlob==null) //use default test console key
                {
                    Signature=ConsoleKeys.SignHashWithConsoleKey(finalHash);
                }
                else //use the console private key that matches the public key in the certificate
                {
                    Signature=ConsoleKeys.SignHashWithConsoleCspBlob(finalHash, Certificate.ConsolePublicKey.CspBlob);
                }
            }

            //
            public override void AppendBytesTo(System.IO.MemoryStream byteList)
            {
                byteList.Write(EncryptedSessionKey, 0, EncryptedSessionKey.Length);
                byteList.Write(System.BitConverter.GetBytes(AuthTime), 0, 8);

                byteList.Write(SerialNumber, 0, 12);

                byteList.Write(Signature, 0, Signature.Length);
                Certificate.WriteStream(byteList);
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                long len=EncryptedSessionKey.Length;
                len+=20;
                len+=Signature.Length;
                len+=Certificate.Size();
                return len;
            }

            //Generates a valid random console serial number.
            public static string GenerateRandomConsoleSerialNumber()
            {
                uint rand0=(uint)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(1000000);
                uint rand1=(uint)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(1000000);
                return rand0.ToString("D6")+rand1.ToString("D6");
            }

            public int GetPreauthNumber()
            {
                return 219;
            }

            public override string ToString()
            {
                if (Signature==null) //not set yet?
                {
                    return "XenonMacRequest2";
                }

                string s="XenonMacRequest2:";
                s+="\nPAXenonMac SessionKey=0x"+ServerTestFramework.Utilities.Hexer.tohex(RawSessionKey);
                s+="\nPAXenonMac AuthTime="+AuthTime+" ("+System.DateTime.FromFileTimeUtc((long)AuthTime)+")";
                s+="\nPAXenonMac SerialNum="+SerialNumber;
                s+="\nPAXenonMac Signature=0x"+ServerTestFramework.Utilities.Hexer.tohex(Signature);
                s+="\nPAXenonMac ConsoleCertificate:\n";
                s+=Certificate;
                return s;
            }
        };

        /// <summary> PADATA_PAC_REQUEST_EX (131) - Privilege Access Certificate Request with... extra!.  This is some variation of a windows PAC request.  It is ASN encoded. </summary>
        public class PreauthPacRequestEx: Compound.TagLengthValue, IGetPreauthNumber
        {
            //Values to be stored
            public Raw.Boolean IncludePac                          //tag 0
            {
                get { return includePac; }
                set
                {
                    includePac=value;
                    IncludePacTag.Value=value;
                }
            }
            private Raw.Boolean includePac=new Raw.Boolean();

            public Compound.TagLengthValue<Raw.Integer> []Sections   //tag 1
            {
                get { return sections; }
                set
                {
                    sections=value;
                    SectionSequence.Values=value;
                }
            }
            private Compound.TagLengthValue<Raw.Integer> []sections=new Compound.TagLengthValue<Raw.Integer>[0];

            //Glue used to hold the values
            public Compound.Sequence OverallSequence=new Compound.Sequence();
            public Compound.ExplicitTagLengthValue IncludePacTag=new Compound.ExplicitTagLengthValue();       //tag 0
            public Compound.ExplicitTagLengthValue SectionSequenceTag=new Compound.ExplicitTagLengthValue();  //tag 1
            public Compound.Sequence SectionSequence=new Compound.Sequence();

            //
            public PreauthPacRequestEx()
            {
                Tag=OverallSequence.GetDefaultTag();
                Value=OverallSequence;

                OverallSequence.Values=new AsnValueBase[2];
                OverallSequence.Values[0]=IncludePacTag;
                OverallSequence.Values[1]=SectionSequenceTag;

                IncludePacTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
                IncludePacTag.ValueTag=IncludePac.GetDefaultTag();
                IncludePacTag.Value=IncludePac;

                SectionSequenceTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                SectionSequenceTag.ValueTag=SectionSequence.GetDefaultTag();
                SectionSequenceTag.Value=SectionSequence;

                SectionSequence.Values=sections;
            }

            public int GetPreauthNumber()
            {
                return 131;
            }

            public override string ToString()
            {
                string s="PacRequestEx: ";
                s+="IncludePac="+IncludePac;
                foreach (Compound.TagLengthValue<Raw.Integer> sec in Sections)
                {
                    s+=", Value="+sec.Value;
                }
                return s;
            }
        };

        /// <summary> PADATA_ENC_TIMESTAMP(2) - An encrypted timestamp.  it is ASN encoded. </summary>
        public class PreauthEncryptedTimestamp: EncryptedData, IGetPreauthNumber, IContainsEncryptedAsn
        {
            //this is what gets encrypted
            public class TimestampBody: AsnValueBase
            {
                //the timestamp of the request (without milliseconds)
                public Time Timestamp
                {
                    get {return timestamp;}
                    set
                    {
                        timestamp=value;
                        TimestampTag.Value=value;
                        Sequence.Values[0]=(value==null?null:TimestampTag);
                    }
                }
                private Time timestamp=new Time();

                //milliseconds field of the timestamp (optional)
                public Raw.Integer Milliseconds
                {
                    get {return milliseconds;}
                    set
                    {
                        milliseconds=value;
                        MillisecondsTag.Value=value;
                        Sequence.Values[1]=(value==null?null:MillisecondsTag);
                    }
                }
                private Raw.Integer milliseconds=new Raw.Integer();

                //glue
                public Compound.TagLengthValue SequenceTag=new Compound.TagLengthValue();
                public Compound.Sequence Sequence=new Compound.Sequence();
                public Compound.ExplicitTagLengthValue TimestampTag=new Compound.ExplicitTagLengthValue();
                public Compound.ExplicitTagLengthValue MillisecondsTag=new Compound.ExplicitTagLengthValue();

                //
                public TimestampBody()
                {
                    SequenceTag.Tag=Sequence.GetDefaultTag();
                    SequenceTag.Value=Sequence;

                    Sequence.Values=new AsnValueBase[2];
                    Sequence.Values[0]=TimestampTag;
                    Sequence.Values[1]=MillisecondsTag;

                    TimestampTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
                    TimestampTag.ValueTag=Timestamp.GetDefaultTag();
                    TimestampTag.Value=Timestamp;

                    MillisecondsTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                    MillisecondsTag.ValueTag=Milliseconds.GetDefaultTag();
                    MillisecondsTag.Value=Milliseconds;
                }

                public override void AppendBytesTo(System.IO.MemoryStream byteList)
                {
                    SequenceTag.AppendBytesTo(byteList);
                }

                public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
                {
                    return SequenceTag.ProcessLengths(updateLengthFields, updateNestedStructures);
                }
            };

            //The actual timestamp.  This is used when Encrypt is called, and set when Decrypt is called.
            public TimestampBody Timestamp;

            //key used for encryption and decryption.
            public byte []EncryptionKey;

            //Encrypts Timestamp and sets it to the EncryptedBytes member of the base EncryptedData.
            public void Encrypt()
            {
                byte []bytes=Timestamp.GetBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncrypt(bytes, EncryptionKey, KdcCrypto.TIMESTAMP_SALT);
            }

            //Decrypts the Data member of the base EncryptedData and stores it in Timestamp.
            public void Decrypt()
            {
                byte []bytes=KdcCrypto.RC4HMACDecrypt(EncryptedBytes.Bytes, EncryptionKey, KdcCrypto.TIMESTAMP_SALT);

                long bytesUsed;
                AsnValueBase asnValues=Compound.AsnValueParser.Parse(bytes, 0, bytes.Length, out bytesUsed);

                Compound.TagLengthValue tlv=(Compound.TagLengthValue)asnValues;
                SetInnerAsn(tlv);
            }

            public AsnValueBase GetInnerAsn()
            {
                return Timestamp;
            }

            public void SetInnerAsn(Compound.TagLengthValue tlv)
            {
                Compound.Sequence seq=(Compound.Sequence)tlv.Value;

                Timestamp.SequenceTag=tlv;
                Timestamp.Sequence=new Compound.Sequence();
                Timestamp.Sequence.Values=new AsnValueBase[2];
                Timestamp.SequenceTag.Value=Timestamp.Sequence;

                Timestamp.Timestamp=null;
                Timestamp.Milliseconds=null;

                foreach (AsnValueBase val in seq.Values)
                {
                    Compound.ExplicitTagLengthValue expTag=(Compound.ExplicitTagLengthValue)val;
                    ulong expTagNumber=expTag.ExplicitTag.Number;
                    if (expTagNumber==0) //Timestamp
                    {
                        Timestamp.TimestampTag=expTag;
                        Timestamp.Timestamp=new Kerberos.Time((Raw.GeneralizedTime)expTag.Value);
                    }
                    else if (expTagNumber==1) //Milliseconds
                    {
                        Timestamp.MillisecondsTag=expTag;
                        Timestamp.Milliseconds=(Raw.Integer)expTag.Value;
                    }
                    else
                    {
                        Global.RO.Warn("Unknown explicit tag found while parsing inner EncryptedTimestamp: "+expTag);
                    }
                }
            }

            public void SetTimestamp(System.DateTime time)
            {
                Timestamp=new Kerberos.PreauthEncryptedTimestamp.TimestampBody();
                Timestamp.Timestamp.DateTime=time;
                Timestamp.Milliseconds.Int64=time.Millisecond;
                Timestamp.ProcessLengths(true, true);
            }

            //
            public PreauthEncryptedTimestamp()
            {
                Type.Int64=0x17; //rc4 hmac
                Version=null; //we don't normally include this field
            }

            public int GetPreauthNumber()
            {
                return 2;
            }

            public override string ToString()
            {
                return "EncryptedTimestamp: Timestamp="+Timestamp.Timestamp+" Milliseconds="+Timestamp.Milliseconds;
            }
        };

        /// <summary> PADATA_XBOX_CLIENT_VERSION(206) - Xbox client and title version preauth. </summary>
        public class PreauthXboxClientVersion: AsnValueBase, IGetPreauthNumber, IContainsEncryptedBytes
        {
            //Fields stored in this preauth
            public byte []Signature; //a 20 byte hmac4 signature of the version string (using session key and nonce)
            public Raw.GeneralString VersionString=new Raw.GeneralString(); //null-terminated version string of the form: Xbox Version=%s Title=0x%08X TitleVersion=%d

            //Encryption key used to sign the request
            public byte []EncryptionKey;
            public uint EncryptionNOnce;

            //Calculates and sets the Signature from the VersionString
            public void Sign()
            {
                Signature=KdcCrypto.GenerateHMAC4SignatureUsingNonceAndKey(VersionString.GetBytes(), EncryptionKey, EncryptionNOnce);
            }

            //to satisfy IEncryptable, instead we'll sign instead here
            public void Encrypt()
            {
                Sign();
            }

            //to satisfy IEncryptable, does nothing
            public void Decrypt()
            {
            }

            public byte[] GetInnerBytes()
            {
                return VersionString.GetBytes();
            }

            public void SetInnerBytes(byte []data)
            {
                VersionString.SetBytes(data);
            }

            //Helper to more easily set the version string
            public void SetVersion(string clientVersion, uint titleId, uint titleVersion)
            {
                VersionString.String=string.Format("Xbox Version={0} Title=0x{1:X8} TitleVersion={2}\0", clientVersion, titleId, titleVersion);
            }

            public void SetVersion(uint clientVersion, uint titleId, uint titleVersion)
            {
                string versionString=((clientVersion&0xf0000000)>>28)+"."+((clientVersion&0x0f000000)>>24)+"."+((clientVersion&0x00ffff00)>>8)+"."+(clientVersion&0x000000ff);
                VersionString.String=string.Format("Xbox Version={0} Title=0x{1:X8} TitleVersion={2}\0", versionString, titleId, titleVersion);
            }

            //
            public override void AppendBytesTo(System.IO.MemoryStream byteList)
            {
                byteList.Write(Signature, 0, Signature.Length);
                VersionString.AppendBytesTo(byteList);
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                long len=Signature.Length;
                len+=VersionString.ProcessLengths(updateLengthFields, updateNestedStructures);
                return len;
            }

            public int GetPreauthNumber()
            {
                return 206;
            }

            public override string ToString()
            {
                return "XboxClientVersion: "+VersionString;
            }
        };

        /// <summary> PADATA_XBOX_ACCOUNT_CREATION(203) - Information about a created machine account.  This is returned by xmacs. </summary>
        public class PreauthXboxAccountCreation: AsnBytes, IGetPreauthNumber
        {
            //Unencrypted data below.  The encrypted version of the data is stored in Bytes.
            public ulong  MachineId;
            public string ConsoleId; //up to 16 chars
            public string Domain;    //up to 20 chars
            public string Realm;     //up to 24 chars
            public byte []Key;       //session key used to talk to askdc - 16 bytes

            //The data above is held inside of an EncryptedData structure
            Kerberos.EncryptedData DataContainer;

            //Decrypts Bytes using a key and a specific nonce as part of the salt, and stores it in the above fields.
            public void Decrypt(byte []key, uint nonce)
            {
                //the first part is not encrypted, it is an ASN EncryptedData.  Pull that out.
                long bytesUsed;
                AsnValueBase asnValues=Compound.AsnValueParser.Parse(Bytes, 0, Bytes.Length, out bytesUsed);
                DataContainer=Kerberos.EncryptedData.CreateFromAsn((Compound.TagLengthValue)asnValues);

                if (DataContainer.EncryptedBytes.Bytes.Length!=84+KdcCrypto.HmacCryptoOverhead)
                {
                    throw new KerberosAsnException("Unable to decrypt PreauthXboxAccountCreation: Expected "+(84+KdcCrypto.HmacCryptoOverhead)+" bytes of encrypted data but there are "+DataContainer.EncryptedBytes.Bytes.Length);
                }

                //decrypt the encrypted bytes inside that container
                byte []decryptedBytes=KdcCrypto.RC4HMACDecryptUsingNonce(DataContainer.EncryptedBytes.Bytes, key, nonce, KdcCrypto.PA_XBOX_ACCOUNT_CREATION_SALT);

                //store fields
                MachineId=System.BitConverter.ToUInt64(decryptedBytes, 0);
                ConsoleId=ServerTestFramework.Utilities.ByteEncoding.Instance.GetNullTerminatedString(decryptedBytes, 8, 16);
                Domain=ServerTestFramework.Utilities.ByteEncoding.Instance.GetNullTerminatedString(decryptedBytes, 24, 20);
                Realm=ServerTestFramework.Utilities.ByteEncoding.Instance.GetNullTerminatedString(decryptedBytes, 44, 24);
                Key=new byte[16];
                System.Array.Copy(decryptedBytes, 68, Key, 0, 16);
            }

            //
            public int GetPreauthNumber()
            {
                return 203;
            }

            public override string ToString()
            {
                if (Key==null) //prolly not decrypted yet
                    return base.ToString();
                else
                    return "XboxAccountCreation: Id=0x"+ServerTestFramework.Utilities.Hexer.tohex(MachineId)+" ConsoleId="+ConsoleId+" Domain="+Domain+" Realm="+Realm+" Key=0x"+ServerTestFramework.Utilities.Hexer.tohex(Key);
            }
        };

        /// <summary> PADATA_XBOX_PPA(204) - Pre-Pre-Auth data for the askdc and xbox1 xmacs. </summary>
        public class PreauthXboxPPA: AsnValueBase, IGetPreauthNumber
        {
            public ulong  CurrentTime; //64 bit windows time value
            public byte []PPA1;        //20 bytes
            public byte []SPPA2;       //20 bytes

            //calculates and sets the PPA1 and SPPA2 fields.
            public void CalculatePPA(string consoleId, byte []key, ulong timestamp)
            {
                PPA1=GenPpa1(consoleId, key);
                SPPA2=GenSppa2(GenPpa2(consoleId, key), timestamp);
            }

            //calculates the ppa1 from a consoleID and key
            public static byte[] GenPpa1(string name, byte[] key)
            {
                byte []hashablename = new byte[16];
                System.Array.Copy((new System.Text.ASCIIEncoding().GetBytes(name.ToUpper())), 0, hashablename, 0, (name.Length<16?name.Length:16));

                System.Security.Cryptography.HMACSHA1 hmac=new System.Security.Cryptography.HMACSHA1(key);
                System.Security.Cryptography.CryptoStream cs=new System.Security.Cryptography.CryptoStream(System.IO.Stream.Null, hmac, System.Security.Cryptography.CryptoStreamMode.Write);
                cs.Write(hashablename, 0, hashablename.Length);
                cs.Close();

                //hmac.Clear(); //is this needed?
                return hmac.Hash;
            }

            //calculates the ppa2 from a console ID, key
            public static byte[] GenPpa2(string name, byte [] key)
            {
                byte []hashablename = new byte[16];
                System.Array.Copy((new System.Text.ASCIIEncoding().GetBytes(name.ToUpper())), 0, hashablename, 0, (name.Length<16?name.Length:16));

                byte[] doublename = new byte[32];
                hashablename.CopyTo(doublename, 0);
                hashablename.CopyTo(doublename, 16);

                System.Security.Cryptography.HMACSHA1 hmac=new System.Security.Cryptography.HMACSHA1(key);
                byte[] basePpa2=hmac.ComputeHash(doublename);
                hmac.Clear();

                return basePpa2;
            }

            //calculates the sppa2 from a ppa2 blob and timestamp
            public static byte[] GenSppa2(byte []ppa2, ulong timestamp)
            {
                //sha1 hash of first 8 bytes of basePpa2 and timestamp
                byte []sha1Ppa2Time=new byte[16];
                System.Array.Copy(ppa2, 0, sha1Ppa2Time, 0, 8);
                System.Array.Copy(System.BitConverter.GetBytes(timestamp), 0, sha1Ppa2Time, 8, 8);

                System.Security.Cryptography.SHA1 sha=new System.Security.Cryptography.SHA1Managed();
                byte []sppa2=sha.ComputeHash(sha1Ppa2Time);
                sha.Clear();

                return sppa2;
            }

            //
            public override void AppendBytesTo(System.IO.MemoryStream byteList)
            {
                byteList.Write(System.BitConverter.GetBytes(CurrentTime), 0, 8);
                byteList.Write(PPA1, 0, PPA1.Length);
                byteList.Write(SPPA2, 0, SPPA2.Length);
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                long len=8;
                len+=PPA1.Length;
                len+=SPPA2.Length;
                return len;
            }

            public override string ToString()
            {
                return "PreauthXboxPPA: CurrentTime="+CurrentTime+"("+System.DateTime.FromFileTimeUtc((long)CurrentTime)+") PPA1=0x"+ServerTestFramework.Utilities.Hexer.tohex(PPA1)+" SPPA2=0x"+ServerTestFramework.Utilities.Hexer.tohex(SPPA2);
            }

            public int GetPreauthNumber()
            {
                return 204;
            }
        };

        /// <summary> PADATA_XENON_PPA(216) - Pre-Pre-Auth data for the askdc for xbox360 machines. </summary>
        public class PreauthXenonPPA: AsnValueBase, IGetPreauthNumber
        {
            public byte []CertificateHash; //20 byte SHA1 hash of the console certificate

            //calculates certificate hash from the certificate
            public void CalculateHash(ConsoleCertificate cert)
            {
               CertificateHash=cert.ComputeHash();
            }

            //
            public override void AppendBytesTo(System.IO.MemoryStream byteList)
            {
                byteList.Write(CertificateHash, 0, CertificateHash.Length);
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                return CertificateHash.Length;
            }

            public override string ToString()
            {
                return "PreauthXenonPPA: CertificateHash=0x"+ServerTestFramework.Utilities.Hexer.tohex(CertificateHash);
            }

            public int GetPreauthNumber()
            {
                return 216;
            }
        };

        /// <summary> PADATA_PC_ACCOUNT_CREATION(212) Request.  Request to create a PC machine account.  Note that the preauth number is the same number as the Response. </summary>
        public class PreauthPCAccountCreationRequest: AsnBytes, IGetPreauthNumber
        {
            public ulong    PCNOnce;            //NOnce for the PC preauth (unrelated to the NOnce in the kerberos request)
            public ushort   PassportTicketLen;  //Length of the passport ticket bytes
            public byte   []PassportTicket;     //Bytes of the passport ticket
            public ushort   EncDataLen;         //Length of the encrypted data portion
            public byte   []EncData;            //Bytes of the encrypted data

            public PreauthPCAccountCreationRequest_EncPart EncryptedPart=new PreauthPCAccountCreationRequest_EncPart(); //representation of EncData

            //Decrypts the encrypted part
            public void Decrypt(byte []key)
            {
                throw new System.Exception("TODO: implement this.");
            }

            //Encrypts the encrypted part and stores everything in Bytes
            public void Encrypt(byte []key)
            {
                //encrypt the encrypted part and store it
                EncryptedPart.EncryptionKey=key;
                EncryptedPart.Encrypt();
                EncryptedPart.RecalculateLengths(true);

                EncData=EncryptedPart.GetBytes();
                EncDataLen=(EncData.Length>65535?(ushort)65535:(ushort)EncData.Length);

                //now pack this struct into the bytes to store in Bytes
                byte []rawBytes=new byte[12+PassportTicket.Length+EncData.Length];
                System.Array.Copy(System.BitConverter.GetBytes(PCNOnce), 0, rawBytes, 0, 8);
                System.Array.Copy(System.BitConverter.GetBytes(PassportTicketLen), 0, rawBytes, 8, 2);
                System.Array.Copy(PassportTicket, 0, rawBytes, 10, PassportTicket.Length);
                System.Array.Copy(System.BitConverter.GetBytes(EncDataLen), 0, rawBytes, 10+PassportTicket.Length+0, 2);
                System.Array.Copy(EncData, 0, rawBytes, 10+PassportTicket.Length+2, EncData.Length);

                Bytes=rawBytes;
            }

            //
            public override long SetBytes(byte []data, long dataStart, long dataLength)
            {
                //set into base
                long ret=base.SetBytes(data, dataStart, dataLength);

                //also copy the unencrypted portion out
                PCNOnce=System.BitConverter.ToUInt64(data, (int)dataStart+0);
                PassportTicketLen=System.BitConverter.ToUInt16(data, (int)dataStart+8);
                PassportTicket=new byte[PassportTicketLen];
                System.Array.Copy(data, dataStart+10, PassportTicket, 0, PassportTicketLen);
                EncDataLen=System.BitConverter.ToUInt16(data, (int)dataStart+10+PassportTicketLen+0);
                EncData=new byte[EncDataLen];
                System.Array.Copy(data, dataStart+10+PassportTicketLen+2, EncData, 0, EncDataLen);

                return ret;
            }

            public override string ToString()
            {
                if (PassportTicket==null) //prolly not set yet
                    return base.ToString();

                string s="PreauthPCAccountCreationRequest:";
                s+="\nPAPCMacReq PCNOnce: "+PCNOnce;
                s+="\nPAPCMacReq PassportTicketLen: "+PassportTicketLen;
                s+="\nPAPCMacReq PassportTicket: "+PassportTicket.Length+" bytes of data";
                if (EncryptedPart!=null) //print out encrypted part
                {
                    s+="\nPAPCMacReqEnc PcId: "+EncryptedPart.PcId;
                    s+="\nPAPCMacReqEnc SponsorTokenLen: "+EncryptedPart.SponsorTokenLen;
                    s+="\nPAPCMacReqEnc SponsorToken: 0x"+ServerTestFramework.Utilities.Hexer.tohex(EncryptedPart.SponsorToken)+" ("+ServerTestFramework.Utilities.ByteEncoding.Instance.GetString(EncryptedPart.SponsorToken)+")";
                }
                else //not decrypted, so just print out the EncData
                {
                    s+="\nPAPCMacReq EncDataLen: "+EncDataLen;
                    s+="\nPAPCMacReq EncData: "+EncData.Length+" bytes of data";
                }

                return s;
            }

            public int GetPreauthNumber()
            {
                return 212;
            }
        }

        /// <summary> Encrypted portion of the PreauthPCAccountCreationRequest preauth. </summary>
        public class PreauthPCAccountCreationRequest_EncPart: EncryptedData, IContainsEncryptedBytes
        {
            public ulong  PcId;            //Random value generated by the PC for this specific machine account
            public ushort SponsorTokenLen; //length of SponsorToken
            public byte []SponsorToken;    //5x5.  up to 41 bytes.  or exactly 41 bytes?

            //key used to encrypted the data
            public byte []EncryptionKey;

            //
            public PreauthPCAccountCreationRequest_EncPart()
            {
                //set key type and version for encrypted data structure
                Type.Int64=0x17;
                Version=null;
            }

            //Decrypts EncryptedData's Data.Bytes and stores the result in the above fields
            public void Decrypt()
            {
                throw new System.Exception("TODO: implement this.");
            }

            //Encrypts the above fields and stores the result in EncryptedData's Data.Bytes
            public void Encrypt()
            {
                byte []encPartBytes=GetInnerBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncrypt(encPartBytes, EncryptionKey, KdcCrypto.PA_PC_ACCOUNT_CREATION_SALT);
            }

            public byte[] GetInnerBytes()
            {
                byte []encPartBytes=new byte[10+SponsorToken.Length];
                System.Array.Copy(System.BitConverter.GetBytes(PcId), 0, encPartBytes, 0, 8);
                System.Array.Copy(System.BitConverter.GetBytes(SponsorTokenLen), 0, encPartBytes, 8, 2);
                System.Array.Copy(SponsorToken, 0, encPartBytes, 10, SponsorToken.Length);
                return encPartBytes;
            }

            public void SetInnerBytes(byte []data)
            {
                throw new System.Exception("TODO: implement this.");
            }
        }

        /// <summary> PADATA_PC_ACCOUNT_CREATION2(220) Request.  Request to create a PC machine account.  In this version the passport ticket is in the encrypted part, and the request encrypted with a random key. </su