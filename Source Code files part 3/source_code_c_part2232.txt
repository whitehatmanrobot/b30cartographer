t IVBSAXErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXErrorHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXErrorHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXErrorHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXErrorHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXErrorHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXErrorHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXErrorHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *error )( 
            IVBSAXErrorHandler * This,
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *fatalError )( 
            IVBSAXErrorHandler * This,
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ignorableWarning )( 
            IVBSAXErrorHandler * This,
            /* [in] */ IVBSAXLocator *oLocator,
            /* [out][in] */ BSTR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        END_INTERFACE
    } IVBSAXErrorHandlerVtbl;

    interface IVBSAXErrorHandler
    {
        CONST_VTBL struct IVBSAXErrorHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXErrorHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVBSAXErrorHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVBSAXErrorHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVBSAXErrorHandler_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVBSAXErrorHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVBSAXErrorHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVBSAXErrorHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVBSAXErrorHandler_error(This,oLocator,strErrorMessage,nErrorCode)	\
    ( (This)->lpVtbl -> error(This,oLocator,strErrorMessage,nErrorCode) ) 

#define IVBSAXErrorHandler_fatalError(This,oLocator,strErrorMessage,nErrorCode)	\
    ( (This)->lpVtbl -> fatalError(This,oLocator,strErrorMessage,nErrorCode) ) 

#define IVBSAXErrorHandler_ignorableWarning(This,oLocator,strErrorMessage,nErrorCode)	\
    ( (This)->lpVtbl -> ignorableWarning(This,oLocator,strErrorMessage,nErrorCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVBSAXErrorHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXLexicalHandler_INTERFACE_DEFINED__
#define __IVBSAXLexicalHandler_INTERFACE_DEFINED__

/* interface IVBSAXLexicalHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXLexicalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("032aac35-8c0e-4d9d-979f-e3b702935576")
    IVBSAXLexicalHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startDTD( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endDTD( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startEntity( 
            /* [out][in] */ BSTR *strName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endEntity( 
            /* [out][in] */ BSTR *strName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startCDATA( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE endCDATA( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE comment( 
            /* [out][in] */ BSTR *strChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXLexicalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXLexicalHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXLexicalHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXLexicalHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXLexicalHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startDTD )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endDTD )( 
            IVBSAXLexicalHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startEntity )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endEntity )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startCDATA )( 
            IVBSAXLexicalHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *endCDATA )( 
            IVBSAXLexicalHandler * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *comment )( 
            IVBSAXLexicalHandler * This,
            /* [out][in] */ BSTR *strChars);
        
        END_INTERFACE
    } IVBSAXLexicalHandlerVtbl;

    interface IVBSAXLexicalHandler
    {
        CONST_VTBL struct IVBSAXLexicalHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXLexicalHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVBSAXLexicalHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVBSAXLexicalHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVBSAXLexicalHandler_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVBSAXLexicalHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVBSAXLexicalHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVBSAXLexicalHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVBSAXLexicalHandler_startDTD(This,strName,strPublicId,strSystemId)	\
    ( (This)->lpVtbl -> startDTD(This,strName,strPublicId,strSystemId) ) 

#define IVBSAXLexicalHandler_endDTD(This)	\
    ( (This)->lpVtbl -> endDTD(This) ) 

#define IVBSAXLexicalHandler_startEntity(This,strName)	\
    ( (This)->lpVtbl -> startEntity(This,strName) ) 

#define IVBSAXLexicalHandler_endEntity(This,strName)	\
    ( (This)->lpVtbl -> endEntity(This,strName) ) 

#define IVBSAXLexicalHandler_startCDATA(This)	\
    ( (This)->lpVtbl -> startCDATA(This) ) 

#define IVBSAXLexicalHandler_endCDATA(This)	\
    ( (This)->lpVtbl -> endCDATA(This) ) 

#define IVBSAXLexicalHandler_comment(This,strChars)	\
    ( (This)->lpVtbl -> comment(This,strChars) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVBSAXLexicalHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXDeclHandler_INTERFACE_DEFINED__
#define __IVBSAXDeclHandler_INTERFACE_DEFINED__

/* interface IVBSAXDeclHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXDeclHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e8917260-7579-4be1-b5dd-7afbfa6f077b")
    IVBSAXDeclHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE elementDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strModel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE attributeDecl( 
            /* [out][in] */ BSTR *strElementName,
            /* [out][in] */ BSTR *strAttributeName,
            /* [out][in] */ BSTR *strType,
            /* [out][in] */ BSTR *strValueDefault,
            /* [out][in] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE internalEntityDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE externalEntityDecl( 
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXDeclHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXDeclHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXDeclHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXDeclHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXDeclHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXDeclHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *elementDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strModel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *attributeDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strElementName,
            /* [out][in] */ BSTR *strAttributeName,
            /* [out][in] */ BSTR *strType,
            /* [out][in] */ BSTR *strValueDefault,
            /* [out][in] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *internalEntityDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *externalEntityDecl )( 
            IVBSAXDeclHandler * This,
            /* [out][in] */ BSTR *strName,
            /* [out][in] */ BSTR *strPublicId,
            /* [out][in] */ BSTR *strSystemId);
        
        END_INTERFACE
    } IVBSAXDeclHandlerVtbl;

    interface IVBSAXDeclHandler
    {
        CONST_VTBL struct IVBSAXDeclHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXDeclHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVBSAXDeclHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVBSAXDeclHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVBSAXDeclHandler_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVBSAXDeclHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVBSAXDeclHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVBSAXDeclHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVBSAXDeclHandler_elementDecl(This,strName,strModel)	\
    ( (This)->lpVtbl -> elementDecl(This,strName,strModel) ) 

#define IVBSAXDeclHandler_attributeDecl(This,strElementName,strAttributeName,strType,strValueDefault,strValue)	\
    ( (This)->lpVtbl -> attributeDecl(This,strElementName,strAttributeName,strType,strValueDefault,strValue) ) 

#define IVBSAXDeclHandler_internalEntityDecl(This,strName,strValue)	\
    ( (This)->lpVtbl -> internalEntityDecl(This,strName,strValue) ) 

#define IVBSAXDeclHandler_externalEntityDecl(This,strName,strPublicId,strSystemId)	\
    ( (This)->lpVtbl -> externalEntityDecl(This,strName,strPublicId,strSystemId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVBSAXDeclHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXAttributes_INTERFACE_DEFINED__
#define __IVBSAXAttributes_INTERFACE_DEFINED__

/* interface IVBSAXAttributes */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10dc0586-132b-4cac-8bb3-db00ac8b7ee0")
    IVBSAXAttributes : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ int *nLength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getURI( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strURI) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getLocalName( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strLocalName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getQName( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strQName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getIndexFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ int *nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getIndexFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ int *nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getTypeFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getTypeFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getValue( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getValueFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getValueFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBSAXAttributes * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBSAXAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBSAXAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBSAXAttributes * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBSAXAttributes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBSAXAttributes * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBSAXAttributes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IVBSAXAttributes * This,
            /* [retval][out] */ int *nLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getURI )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getLocalName )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strLocalName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getQName )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strQName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getIndexFromName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ int *nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getIndexFromQName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ int *nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getType )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getTypeFromName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getTypeFromQName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getValue )( 
            IVBSAXAttributes * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getValueFromName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR *strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getValueFromQName )( 
            IVBSAXAttributes * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR *strValue);
        
        END_INTERFACE
    } IVBSAXAttributesVtbl;

    interface IVBSAXAttributes
    {
        CONST_VTBL struct IVBSAXAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXAttributes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVBSAXAttributes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVBSAXAttributes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVBSAXAttributes_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVBSAXAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVBSAXAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVBSAXAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVBSAXAttributes_get_length(This,nLength)	\
    ( (This)->lpVtbl -> get_length(This,nLength) ) 

#define IVBSAXAttributes_getURI(This,nIndex,strURI)	\
    ( (This)->lpVtbl -> getURI(This,nIndex,strURI) ) 

#define IVBSAXAttributes_getLocalName(This,nIndex,strLocalName)	\
    ( (This)->lpVtbl -> getLocalName(This,nIndex,strLocalName) ) 

#define IVBSAXAttributes_getQName(This,nIndex,strQName)	\
    ( (This)->lpVtbl -> getQName(This,nIndex,strQName) ) 

#define IVBSAXAttributes_getIndexFromName(This,strURI,strLocalName,nIndex)	\
    ( (This)->lpVtbl -> getIndexFromName(This,strURI,strLocalName,nIndex) ) 

#define IVBSAXAttributes_getIndexFromQName(This,strQName,nIndex)	\
    ( (This)->lpVtbl -> getIndexFromQName(This,strQName,nIndex) ) 

#define IVBSAXAttributes_getType(This,nIndex,strType)	\
    ( (This)->lpVtbl -> getType(This,nIndex,strType) ) 

#define IVBSAXAttributes_getTypeFromName(This,strURI,strLocalName,strType)	\
    ( (This)->lpVtbl -> getTypeFromName(This,strURI,strLocalName,strType) ) 

#define IVBSAXAttributes_getTypeFromQName(This,strQName,strType)	\
    ( (This)->lpVtbl -> getTypeFromQName(This,strQName,strType) ) 

#define IVBSAXAttributes_getValue(This,nIndex,strValue)	\
    ( (This)->lpVtbl -> getValue(This,nIndex,strValue) ) 

#define IVBSAXAttributes_getValueFromName(This,strURI,strLocalName,strValue)	\
    ( (This)->lpVtbl -> getValueFromName(This,strURI,strLocalName,strValue) ) 

#define IVBSAXAttributes_getValueFromQName(This,strQName,strValue)	\
    ( (This)->lpVtbl -> getValueFromQName(This,strQName,strValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVBSAXAttributes_INTERFACE_DEFINED__ */


#ifndef __IMXWriter_INTERFACE_DEFINED__
#define __IMXWriter_INTERFACE_DEFINED__

/* interface IMXWriter */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4d7ff4ba-1565-4ea8-94e1-6e724a46f98d")
    IMXWriter : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_output( 
            /* [in] */ VARIANT varDestination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_output( 
            /* [retval][out] */ VARIANT *varDestination) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_encoding( 
            /* [in] */ BSTR strEncoding) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_encoding( 
            /* [retval][out] */ BSTR *strEncoding) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_byteOrderMark( 
            /* [in] */ VARIANT_BOOL fWriteByteOrderMark) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_byteOrderMark( 
            /* [retval][out] */ VARIANT_BOOL *fWriteByteOrderMark) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_indent( 
            /* [in] */ VARIANT_BOOL fIndentMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_indent( 
            /* [retval][out] */ VARIANT_BOOL *fIndentMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_standalone( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_standalone( 
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_omitXMLDeclaration( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_omitXMLDeclaration( 
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_version( 
            /* [in] */ BSTR strVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [retval][out] */ BSTR *strVersion) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_disableOutputEscaping( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_disableOutputEscaping( 
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXWriter * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXWriter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXWriter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXWriter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXWriter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_output )( 
            IMXWriter * This,
            /* [in] */ VARIANT varDestination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_output )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT *varDestination);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_encoding )( 
            IMXWriter * This,
            /* [in] */ BSTR strEncoding);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_encoding )( 
            IMXWriter * This,
            /* [retval][out] */ BSTR *strEncoding);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_byteOrderMark )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fWriteByteOrderMark);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_byteOrderMark )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fWriteByteOrderMark);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_indent )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fIndentMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_indent )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fIndentMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_standalone )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_standalone )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_omitXMLDeclaration )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_omitXMLDeclaration )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_version )( 
            IMXWriter * This,
            /* [in] */ BSTR strVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_version )( 
            IMXWriter * This,
            /* [retval][out] */ BSTR *strVersion);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_disableOutputEscaping )( 
            IMXWriter * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_disableOutputEscaping )( 
            IMXWriter * This,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *flush )( 
            IMXWriter * This);
        
        END_INTERFACE
    } IMXWriterVtbl;

    interface IMXWriter
    {
        CONST_VTBL struct IMXWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMXWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMXWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMXWriter_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMXWriter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMXWriter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMXWriter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMXWriter_put_output(This,varDestination)	\
    ( (This)->lpVtbl -> put_output(This,varDestination) ) 

#define IMXWriter_get_output(This,varDestination)	\
    ( (This)->lpVtbl -> get_output(This,varDestination) ) 

#define IMXWriter_put_encoding(This,strEncoding)	\
    ( (This)->lpVtbl -> put_encoding(This,strEncoding) ) 

#define IMXWriter_get_encoding(This,strEncoding)	\
    ( (This)->lpVtbl -> get_encoding(This,strEncoding) ) 

#define IMXWriter_put_byteOrderMark(This,fWriteByteOrderMark)	\
    ( (This)->lpVtbl -> put_byteOrderMark(This,fWriteByteOrderMark) ) 

#define IMXWriter_get_byteOrderMark(This,fWriteByteOrderMark)	\
    ( (This)->lpVtbl -> get_byteOrderMark(This,fWriteByteOrderMark) ) 

#define IMXWriter_put_indent(This,fIndentMode)	\
    ( (This)->lpVtbl -> put_indent(This,fIndentMode) ) 

#define IMXWriter_get_indent(This,fIndentMode)	\
    ( (This)->lpVtbl -> get_indent(This,fIndentMode) ) 

#define IMXWriter_put_standalone(This,fValue)	\
    ( (This)->lpVtbl -> put_standalone(This,fValue) ) 

#define IMXWriter_get_standalone(This,fValue)	\
    ( (This)->lpVtbl -> get_standalone(This,fValue) ) 

#define IMXWriter_put_omitXMLDeclaration(This,fValue)	\
    ( (This)->lpVtbl -> put_omitXMLDeclaration(This,fValue) ) 

#define IMXWriter_get_omitXMLDeclaration(This,fValue)	\
    ( (This)->lpVtbl -> get_omitXMLDeclaration(This,fValue) ) 

#define IMXWriter_put_version(This,strVersion)	\
    ( (This)->lpVtbl -> put_version(This,strVersion) ) 

#define IMXWriter_get_version(This,strVersion)	\
    ( (This)->lpVtbl -> get_version(This,strVersion) ) 

#define IMXWriter_put_disableOutputEscaping(This,fValue)	\
    ( (This)->lpVtbl -> put_disableOutputEscaping(This,fValue) ) 

#define IMXWriter_get_disableOutputEscaping(This,fValue)	\
    ( (This)->lpVtbl -> get_disableOutputEscaping(This,fValue) ) 

#define IMXWriter_flush(This)	\
    ( (This)->lpVtbl -> flush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMXWriter_INTERFACE_DEFINED__ */


#ifndef __IMXAttributes_INTERFACE_DEFINED__
#define __IMXAttributes_INTERFACE_DEFINED__

/* interface IMXAttributes */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f10d27cc-3ec0-415c-8ed8-77ab1c5e7262")
    IMXAttributes : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addAttribute( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addAttributeFromIndex( 
            /* [in] */ VARIANT varAtts,
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE clear( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setAttributes( 
            /* [in] */ VARIANT varAtts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setLocalName( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strLocalName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setQName( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strQName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setType( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setURI( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setValue( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXAttributes * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXAttributes * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXAttributes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXAttributes * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXAttributes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addAttribute )( 
            IMXAttributes * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addAttributeFromIndex )( 
            IMXAttributes * This,
            /* [in] */ VARIANT varAtts,
            /* [in] */ int nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *clear )( 
            IMXAttributes * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAttribute )( 
            IMXAttributes * This,
            /* [in] */ int nIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttribute )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setAttributes )( 
            IMXAttributes * This,
            /* [in] */ VARIANT varAtts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setLocalName )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strLocalName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setQName )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strQName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setType )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setURI )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setValue )( 
            IMXAttributes * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strValue);
        
        END_INTERFACE
    } IMXAttributesVtbl;

    interface IMXAttributes
    {
        CONST_VTBL struct IMXAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXAttributes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMXAttributes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMXAttributes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMXAttributes_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMXAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMXAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMXAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMXAttributes_addAttribute(This,strURI,strLocalName,strQName,strType,strValue)	\
    ( (This)->lpVtbl -> addAttribute(This,strURI,strLocalName,strQName,strType,strValue) ) 

#define IMXAttributes_addAttributeFromIndex(This,varAtts,nIndex)	\
    ( (This)->lpVtbl -> addAttributeFromIndex(This,varAtts,nIndex) ) 

#define IMXAttributes_clear(This)	\
    ( (This)->lpVtbl -> clear(This) ) 

#define IMXAttributes_removeAttribute(This,nIndex)	\
    ( (This)->lpVtbl -> removeAttribute(This,nIndex) ) 

#define IMXAttributes_setAttribute(This,nIndex,strURI,strLocalName,strQName,strType,strValue)	\
    ( (This)->lpVtbl -> setAttribute(This,nIndex,strURI,strLocalName,strQName,strType,strValue) ) 

#define IMXAttributes_setAttributes(This,varAtts)	\
    ( (This)->lpVtbl -> setAttributes(This,varAtts) ) 

#define IMXAttributes_setLocalName(This,nIndex,strLocalName)	\
    ( (This)->lpVtbl -> setLocalName(This,nIndex,strLocalName) ) 

#define IMXAttributes_setQName(This,nIndex,strQName)	\
    ( (This)->lpVtbl -> setQName(This,nIndex,strQName) ) 

#define IMXAttributes_setType(This,nIndex,strType)	\
    ( (This)->lpVtbl -> setType(This,nIndex,strType) ) 

#define IMXAttributes_setURI(This,nIndex,strURI)	\
    ( (This)->lpVtbl -> setURI(This,nIndex,strURI) ) 

#define IMXAttributes_setValue(This,nIndex,strValue)	\
    ( (This)->lpVtbl -> setValue(This,nIndex,strValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMXAttributes_INTERFACE_DEFINED__ */


#ifndef __IMXReaderControl_INTERFACE_DEFINED__
#define __IMXReaderControl_INTERFACE_DEFINED__

/* interface IMXReaderControl */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXReaderControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("808f4e35-8d5a-4fbe-8466-33a41279ed30")
    IMXReaderControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE resume( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE suspend( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXReaderControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXReaderControl * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXReaderControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXReaderControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXReaderControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXReaderControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXReaderControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXReaderControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            IMXReaderControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *resume )( 
            IMXReaderControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *suspend )( 
            IMXReaderControl * This);
        
        END_INTERFACE
    } IMXReaderControlVtbl;

    interface IMXReaderControl
    {
        CONST_VTBL struct IMXReaderControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXReaderControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMXReaderControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMXReaderControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMXReaderControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMXReaderControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMXReaderControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMXReaderControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMXReaderControl_abort(This)	\
    ( (This)->lpVtbl -> abort(This) ) 

#define IMXReaderControl_resume(This)	\
    ( (This)->lpVtbl -> resume(This) ) 

#define IMXReaderControl_suspend(This)	\
    ( (This)->lpVtbl -> suspend(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMXReaderControl_INTERFACE_DEFINED__ */


#ifndef __IMXSchemaDeclHandler_INTERFACE_DEFINED__
#define __IMXSchemaDeclHandler_INTERFACE_DEFINED__

/* interface IMXSchemaDeclHandler */
/* [unique][helpstring][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXSchemaDeclHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fa4bb38c-faf9-4cca-9302-d1dd0fe520db")
    IMXSchemaDeclHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE schemaElementDecl( 
            /* [in] */ ISchemaElement *oSchemaElement) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXSchemaDeclHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXSchemaDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXSchemaDeclHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXSchemaDeclHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXSchemaDeclHandler * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXSchemaDeclHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXSchemaDeclHandler * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXSchemaDeclHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *schemaElementDecl )( 
            IMXSchemaDeclHandler * This,
            /* [in] */ ISchemaElement *oSchemaElement);
        
        END_INTERFACE
    } IMXSchemaDeclHandlerVtbl;

    interface IMXSchemaDeclHandler
    {
        CONST_VTBL struct IMXSchemaDeclHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXSchemaDeclHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMXSchemaDeclHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMXSchemaDeclHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMXSchemaDeclHandler_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMXSchemaDeclHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMXSchemaDeclHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMXSchemaDeclHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMXSchemaDeclHandler_schemaElementDecl(This,oSchemaElement)	\
    ( (This)->lpVtbl -> schemaElementDecl(This,oSchemaElement) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMXSchemaDeclHandler_INTERFACE_DEFINED__ */


#ifndef __IMXXMLFilter_INTERFACE_DEFINED__
#define __IMXXMLFilter_INTERFACE_DEFINED__

/* interface IMXXMLFilter */
/* [unique][nonextensible][oleautomation][dual][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IMXXMLFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c90352f7-643c-4fbc-bb23-e996eb2d51fd")
    IMXXMLFilter : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getFeature( 
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT_BOOL *fValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE putFeature( 
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT *varValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE putProperty( 
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT varValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_entityResolver( 
            /* [retval][out] */ IUnknown **oResolver) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_entityResolver( 
            /* [in] */ IUnknown *oResolver) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_contentHandler( 
            /* [retval][out] */ IUnknown **oHandler) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_contentHandler( 
            /* [in] */ IUnknown *oHandler) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_dtdHandler( 
            /* [retval][out] */ IUnknown **oHandler) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_dtdHandler( 
            /* [in] */ IUnknown *oHandler) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_errorHandler( 
            /* [retval][out] */ IUnknown **oHandler) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_errorHandler( 
            /* [in] */ IUnknown *oHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXXMLFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXXMLFilter * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXXMLFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXXMLFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXXMLFilter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXXMLFilter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXXMLFilter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXXMLFilter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getFeature )( 
            IMXXMLFilter * This,
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT_BOOL *fValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *putFeature )( 
            IMXXMLFilter * This,
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            IMXXMLFilter * This,
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT *varValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *putProperty )( 
            IMXXMLFilter * This,
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT varValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_entityResolver )( 
            IMXXMLFilter * This,
            /* [retval][out] */ IUnknown **oResolver);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_entityResolver )( 
            IMXXMLFilter * This,
            /* [in] */ IUnknown *oResolver);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_contentHandler )( 
            IMXXMLFilter * This,
            /* [retval][out] */ IUnknown **oHandler);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_contentHandler )( 
            IMXXMLFilter * This,
            /* [in] */ IUnknown *oHandler);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_dtdHandler )( 
            IMXXMLFilter * This,
            /* [retval][out] */ IUnknown **oHandler);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_dtdHandler )( 
            IMXXMLFilter * This,
            /* [in] */ IUnknown *oHandler);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_errorHandler )( 
            IMXXMLFilter * This,
            /* [retval][out] */ IUnknown **oHandler);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_errorHandler )( 
            IMXXMLFilter * This,
            /* [in] */ IUnknown *oHandler);
        
        END_INTERFACE
    } IMXXMLFilterVtbl;

    interface IMXXMLFilter
    {
        CONST_VTBL struct IMXXMLFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXXMLFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMXXMLFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMXXMLFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMXXMLFilter_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMXXMLFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMXXMLFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMXXMLFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMXXMLFilter_getFeature(This,strName,fValue)	\
    ( (This)->lpVtbl -> getFeature(This,strName,fValue) ) 

#define IMXXMLFilter_putFeature(This,strName,fValue)	\
    ( (This)->lpVtbl -> putFeature(This,strName,fValue) ) 

#define IMXXMLFilter_getProperty(This,strName,varValue)	\
    ( (This)->lpVtbl -> getProperty(This,strName,varValue) ) 

#define IMXXMLFilter_putProperty(This,strName,varValue)	\
    ( (This)->lpVtbl -> putProperty(This,strName,varValue) ) 

#define IMXXMLFilter_get_entityResolver(This,oResolver)	\
    ( (This)->lpVtbl -> get_entityResolver(This,oResolver) ) 

#define IMXXMLFilter_putref_entityResolver(This,oResolver)	\
    ( (This)->lpVtbl -> putref_entityResolver(This,oResolver) ) 

#define IMXXMLFilter_get_contentHandler(This,oHandler)	\
    ( (This)->lpVtbl -> get_contentHandler(This,oHandler) ) 

#define IMXXMLFilter_putref_contentHandler(This,oHandler)	\
    ( (This)->lpVtbl -> putref_contentHandler(This,oHandler) ) 

#define IMXXMLFilter_get_dtdHandler(This,oHandler)	\
    ( (This)->lpVtbl -> get_dtdHandler(This,oHandler) ) 

#define IMXXMLFilter_putref_dtdHandler(This,oHandler)	\
    ( (This)->lpVtbl -> putref_dtdHandler(This,oHandler) ) 

#define IMXXMLFilter_get_errorHandler(This,oHandler)	\
    ( (This)->lpVtbl -> get_errorHandler(This,oHandler) ) 

#define IMXXMLFilter_putref_errorHandler(This,oHandler)	\
    ( (This)->lpVtbl -> putref_errorHandler(This,oHandler) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMXXMLFilter_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMSchemaCollection2_INTERFACE_DEFINED__
#define __IXMLDOMSchemaCollection2_INTERFACE_DEFINED__

/* interface IXMLDOMSchemaCollection2 */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMSchemaCollection2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b0-dd1b-4664-9a50-c2f40f4bd79a")
    IXMLDOMSchemaCollection2 : public IXMLDOMSchemaCollection
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE validate( void) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_validateOnLoad( 
            /* [in] */ VARIANT_BOOL validateOnLoad) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_validateOnLoad( 
            /* [retval][out] */ VARIANT_BOOL *validateOnLoad) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getSchema( 
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ ISchema **schema) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getDeclaration( 
            /* [in] */ IXMLDOMNode *node,
            /* [retval][out] */ ISchemaItem **item) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMSchemaCollection2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMSchemaCollection2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMSchemaCollection2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMSchemaCollection2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *add )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ BSTR namespaceURI,
            /* [in] */ VARIANT var);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *get )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IXMLDOMNode **schemaNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *remove )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ BSTR namespaceURI);
        
        /* [propget][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMSchemaCollection2 * This,
            /* [retval][out] */ long *length);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ long index,
            /* [retval][out] */ BSTR *length);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addCollection )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ IXMLDOMSchemaCollection *otherCollection);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMSchemaCollection2 * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *validate )( 
            IXMLDOMSchemaCollection2 * This);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_validateOnLoad )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ VARIANT_BOOL validateOnLoad);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_validateOnLoad )( 
            IXMLDOMSchemaCollection2 * This,
            /* [retval][out] */ VARIANT_BOOL *validateOnLoad);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getSchema )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ ISchema **schema);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getDeclaration )( 
            IXMLDOMSchemaCollection2 * This,
            /* [in] */ IXMLDOMNode *node,
            /* [retval][out] */ ISchemaItem **item);
        
        END_INTERFACE
    } IXMLDOMSchemaCollection2Vtbl;

    interface IXMLDOMSchemaCollection2
    {
        CONST_VTBL struct IXMLDOMSchemaCollection2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMSchemaCollection2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXMLDOMSchemaCollection2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXMLDOMSchemaCollection2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXMLDOMSchemaCollection2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXMLDOMSchemaCollection2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXMLDOMSchemaCollection2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXMLDOMSchemaCollection2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IXMLDOMSchemaCollection2_add(This,namespaceURI,var)	\
    ( (This)->lpVtbl -> add(This,namespaceURI,var) ) 

#define IXMLDOMSchemaCollection2_get(This,namespaceURI,schemaNode)	\
    ( (This)->lpVtbl -> get(This,namespaceURI,schemaNode) ) 

#define IXMLDOMSchemaCollection2_remove(This,namespaceURI)	\
    ( (This)->lpVtbl -> remove(This,namespaceURI) ) 

#define IXMLDOMSchemaCollection2_get_length(This,length)	\
    ( (This)->lpVtbl -> get_length(This,length) ) 

#define IXMLDOMSchemaCollection2_get_namespaceURI(This,index,length)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,index,length) ) 

#define IXMLDOMSchemaCollection2_addCollection(This,otherCollection)	\
    ( (This)->lpVtbl -> addCollection(This,otherCollection) ) 

#define IXMLDOMSchemaCollection2_get__newEnum(This,ppUnk)	\
    ( (This)->lpVtbl -> get__newEnum(This,ppUnk) ) 


#define IXMLDOMSchemaCollection2_validate(This)	\
    ( (This)->lpVtbl -> validate(This) ) 

#define IXMLDOMSchemaCollection2_put_validateOnLoad(This,validateOnLoad)	\
    ( (This)->lpVtbl -> put_validateOnLoad(This,validateOnLoad) ) 

#define IXMLDOMSchemaCollection2_get_validateOnLoad(This,validateOnLoad)	\
    ( (This)->lpVtbl -> get_validateOnLoad(This,validateOnLoad) ) 

#define IXMLDOMSchemaCollection2_getSchema(This,namespaceURI,schema)	\
    ( (This)->lpVtbl -> getSchema(This,namespaceURI,schema) ) 

#define IXMLDOMSchemaCollection2_getDeclaration(This,node,item)	\
    ( (This)->lpVtbl -> getDeclaration(This,node,item) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMSchemaCollection2_INTERFACE_DEFINED__ */


#ifndef __ISchemaStringCollection_INTERFACE_DEFINED__
#define __ISchemaStringCollection_INTERFACE_DEFINED__

/* interface ISchemaStringCollection */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaStringCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b1-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaStringCollection : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR *bstr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *length) = 0;
        
        virtual /* [propget][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [retval][out] */ IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaStringCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaStringCollection * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaStringCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaStringCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaStringCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaStringCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaStringCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaStringCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            ISchemaStringCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ BSTR *bstr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            ISchemaStringCollection * This,
            /* [retval][out] */ long *length);
        
        /* [propget][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            ISchemaStringCollection * This,
            /* [retval][out] */ IUnknown **ppunk);
        
        END_INTERFACE
    } ISchemaStringCollectionVtbl;

    interface ISchemaStringCollection
    {
        CONST_VTBL struct ISchemaStringCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaStringCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaStringCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaStringCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaStringCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaStringCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaStringCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaStringCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaStringCollection_get_item(This,index,bstr)	\
    ( (This)->lpVtbl -> get_item(This,index,bstr) ) 

#define ISchemaStringCollection_get_length(This,length)	\
    ( (This)->lpVtbl -> get_length(This,length) ) 

#define ISchemaStringCollection_get__newEnum(This,ppunk)	\
    ( (This)->lpVtbl -> get__newEnum(This,ppunk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaStringCollection_INTERFACE_DEFINED__ */


#ifndef __ISchemaItemCollection_INTERFACE_DEFINED__
#define __ISchemaItemCollection_INTERFACE_DEFINED__

/* interface ISchemaItemCollection */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaItemCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b2-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaItemCollection : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long index,
            /* [retval][out] */ ISchemaItem **item) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE itemByName( 
            /* [in] */ BSTR name,
            /* [retval][out] */ ISchemaItem **item) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE itemByQName( 
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ ISchemaItem **item) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *length) = 0;
        
        virtual /* [propget][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [retval][out] */ IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaItemCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaItemCollection * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaItemCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaItemCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaItemCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaItemCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaItemCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaItemCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            ISchemaItemCollection * This,
            /* [in] */ long index,
            /* [retval][out] */ ISchemaItem **item);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *itemByName )( 
            ISchemaItemCollection * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ ISchemaItem **item);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *itemByQName )( 
            ISchemaItemCollection * This,
            /* [in] */ BSTR name,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ ISchemaItem **item);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            ISchemaItemCollection * This,
            /* [retval][out] */ long *length);
        
        /* [propget][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            ISchemaItemCollection * This,
            /* [retval][out] */ IUnknown **ppunk);
        
        END_INTERFACE
    } ISchemaItemCollectionVtbl;

    interface ISchemaItemCollection
    {
        CONST_VTBL struct ISchemaItemCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaItemCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaItemCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaItemCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaItemCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaItemCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaItemCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaItemCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaItemCollection_get_item(This,index,item)	\
    ( (This)->lpVtbl -> get_item(This,index,item) ) 

#define ISchemaItemCollection_itemByName(This,name,item)	\
    ( (This)->lpVtbl -> itemByName(This,name,item) ) 

#define ISchemaItemCollection_itemByQName(This,name,namespaceURI,item)	\
    ( (This)->lpVtbl -> itemByQName(This,name,namespaceURI,item) ) 

#define ISchemaItemCollection_get_length(This,length)	\
    ( (This)->lpVtbl -> get_length(This,length) ) 

#define ISchemaItemCollection_get__newEnum(This,ppunk)	\
    ( (This)->lpVtbl -> get__newEnum(This,ppunk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaItemCollection_INTERFACE_DEFINED__ */


#ifndef __ISchemaItem_INTERFACE_DEFINED__
#define __ISchemaItem_INTERFACE_DEFINED__

/* interface ISchemaItem */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b3-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaItem : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_namespaceURI( 
            /* [retval][out] */ BSTR *namespaceURI) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_schema( 
            /* [retval][out] */ ISchema **schema) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_id( 
            /* [retval][out] */ BSTR *id) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_itemType( 
            /* [retval][out] */ SOMITEMTYPE *itemType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_unhandledAttributes( 
            /* [retval][out] */ IVBSAXAttributes **attributes) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE writeAnnotation( 
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaItem * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaItem * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaItem * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaItem * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaItem * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaItem * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaItem * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaItem * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaItem * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaItem * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        END_INTERFACE
    } ISchemaItemVtbl;

    interface ISchemaItem
    {
        CONST_VTBL struct ISchemaItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaItem_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaItem_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaItem_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaItem_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaItem_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaItem_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaItem_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaItem_INTERFACE_DEFINED__ */


#ifndef __ISchema_INTERFACE_DEFINED__
#define __ISchema_INTERFACE_DEFINED__

/* interface ISchema */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchema;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b4-dd1b-4664-9a50-c2f40f4bd79a")
    ISchema : public ISchemaItem
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_targetNamespace( 
            /* [retval][out] */ BSTR *targetNamespace) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [retval][out] */ BSTR *version) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_types( 
            /* [retval][out] */ ISchemaItemCollection **types) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_elements( 
            /* [retval][out] */ ISchemaItemCollection **elements) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [retval][out] */ ISchemaItemCollection **attributes) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_attributeGroups( 
            /* [retval][out] */ ISchemaItemCollection **attributeGroups) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_modelGroups( 
            /* [retval][out] */ ISchemaItemCollection **modelGroups) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_notations( 
            /* [retval][out] */ ISchemaItemCollection **notations) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_schemaLocations( 
            /* [retval][out] */ ISchemaStringCollection **schemaLocations) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchema * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchema * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchema * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchema * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchema * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchema * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchema * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchema * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchema * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchema * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchema * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchema * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchema * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchema * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_targetNamespace )( 
            ISchema * This,
            /* [retval][out] */ BSTR *targetNamespace);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_version )( 
            ISchema * This,
            /* [retval][out] */ BSTR *version);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_types )( 
            ISchema * This,
            /* [retval][out] */ ISchemaItemCollection **types);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_elements )( 
            ISchema * This,
            /* [retval][out] */ ISchemaItemCollection **elements);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            ISchema * This,
            /* [retval][out] */ ISchemaItemCollection **attributes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_attributeGroups )( 
            ISchema * This,
            /* [retval][out] */ ISchemaItemCollection **attributeGroups);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_modelGroups )( 
            ISchema * This,
            /* [retval][out] */ ISchemaItemCollection **modelGroups);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_notations )( 
            ISchema * This,
            /* [retval][out] */ ISchemaItemCollection **notations);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schemaLocations )( 
            ISchema * This,
            /* [retval][out] */ ISchemaStringCollection **schemaLocations);
        
        END_INTERFACE
    } ISchemaVtbl;

    interface ISchema
    {
        CONST_VTBL struct ISchemaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchema_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchema_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchema_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchema_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchema_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchema_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchema_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchema_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchema_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchema_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchema_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchema_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchema_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchema_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchema_get_targetNamespace(This,targetNamespace)	\
    ( (This)->lpVtbl -> get_targetNamespace(This,targetNamespace) ) 

#define ISchema_get_version(This,version)	\
    ( (This)->lpVtbl -> get_version(This,version) ) 

#define ISchema_get_types(This,types)	\
    ( (This)->lpVtbl -> get_types(This,types) ) 

#define ISchema_get_elements(This,elements)	\
    ( (This)->lpVtbl -> get_elements(This,elements) ) 

#define ISchema_get_attributes(This,attributes)	\
    ( (This)->lpVtbl -> get_attributes(This,attributes) ) 

#define ISchema_get_attributeGroups(This,attributeGroups)	\
    ( (This)->lpVtbl -> get_attributeGroups(This,attributeGroups) ) 

#define ISchema_get_modelGroups(This,modelGroups)	\
    ( (This)->lpVtbl -> get_modelGroups(This,modelGroups) ) 

#define ISchema_get_notations(This,notations)	\
    ( (This)->lpVtbl -> get_notations(This,notations) ) 

#define ISchema_get_schemaLocations(This,schemaLocations)	\
    ( (This)->lpVtbl -> get_schemaLocations(This,schemaLocations) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchema_INTERFACE_DEFINED__ */


#ifndef __ISchemaParticle_INTERFACE_DEFINED__
#define __ISchemaParticle_INTERFACE_DEFINED__

/* interface ISchemaParticle */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaParticle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b5-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaParticle : public ISchemaItem
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_minOccurs( 
            /* [retval][out] */ VARIANT *minOccurs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_maxOccurs( 
            /* [retval][out] */ VARIANT *maxOccurs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaParticleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaParticle * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaParticle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaParticle * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaParticle * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaParticle * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaParticle * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaParticle * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaParticle * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaParticle * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaParticle * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaParticle * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaParticle * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaParticle * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaParticle * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minOccurs )( 
            ISchemaParticle * This,
            /* [retval][out] */ VARIANT *minOccurs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxOccurs )( 
            ISchemaParticle * This,
            /* [retval][out] */ VARIANT *maxOccurs);
        
        END_INTERFACE
    } ISchemaParticleVtbl;

    interface ISchemaParticle
    {
        CONST_VTBL struct ISchemaParticleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaParticle_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaParticle_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaParticle_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaParticle_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaParticle_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaParticle_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaParticle_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaParticle_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaParticle_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaParticle_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaParticle_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaParticle_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaParticle_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaParticle_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaParticle_get_minOccurs(This,minOccurs)	\
    ( (This)->lpVtbl -> get_minOccurs(This,minOccurs) ) 

#define ISchemaParticle_get_maxOccurs(This,maxOccurs)	\
    ( (This)->lpVtbl -> get_maxOccurs(This,maxOccurs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaParticle_INTERFACE_DEFINED__ */


#ifndef __ISchemaAttribute_INTERFACE_DEFINED__
#define __ISchemaAttribute_INTERFACE_DEFINED__

/* interface ISchemaAttribute */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b6-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaAttribute : public ISchemaItem
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ ISchemaType **type) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_scope( 
            /* [retval][out] */ ISchemaComplexType **scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_defaultValue( 
            /* [retval][out] */ BSTR *defaultValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_fixedValue( 
            /* [retval][out] */ BSTR *fixedValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_use( 
            /* [retval][out] */ SCHEMAUSE *use) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isReference( 
            /* [retval][out] */ VARIANT_BOOL *reference) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaAttribute * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaAttribute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaAttribute * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaAttribute * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaAttribute * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaAttribute * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaAttribute * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaAttribute * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaAttribute * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaAttribute * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaAttribute * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaAttribute * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaAttribute * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaAttribute * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            ISchemaAttribute * This,
            /* [retval][out] */ ISchemaType **type);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_scope )( 
            ISchemaAttribute * This,
            /* [retval][out] */ ISchemaComplexType **scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_defaultValue )( 
            ISchemaAttribute * This,
            /* [retval][out] */ BSTR *defaultValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_fixedValue )( 
            ISchemaAttribute * This,
            /* [retval][out] */ BSTR *fixedValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_use )( 
            ISchemaAttribute * This,
            /* [retval][out] */ SCHEMAUSE *use);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isReference )( 
            ISchemaAttribute * This,
            /* [retval][out] */ VARIANT_BOOL *reference);
        
        END_INTERFACE
    } ISchemaAttributeVtbl;

    interface ISchemaAttribute
    {
        CONST_VTBL struct ISchemaAttributeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaAttribute_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaAttribute_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaAttribute_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaAttribute_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaAttribute_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaAttribute_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaAttribute_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaAttribute_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaAttribute_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaAttribute_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaAttribute_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaAttribute_get_type(This,type)	\
    ( (This)->lpVtbl -> get_type(This,type) ) 

#define ISchemaAttribute_get_scope(This,scope)	\
    ( (This)->lpVtbl -> get_scope(This,scope) ) 

#define ISchemaAttribute_get_defaultValue(This,defaultValue)	\
    ( (This)->lpVtbl -> get_defaultValue(This,defaultValue) ) 

#define ISchemaAttribute_get_fixedValue(This,fixedValue)	\
    ( (This)->lpVtbl -> get_fixedValue(This,fixedValue) ) 

#define ISchemaAttribute_get_use(This,use)	\
    ( (This)->lpVtbl -> get_use(This,use) ) 

#define ISchemaAttribute_get_isReference(This,reference)	\
    ( (This)->lpVtbl -> get_isReference(This,reference) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaAttribute_INTERFACE_DEFINED__ */


#ifndef __ISchemaElement_INTERFACE_DEFINED__
#define __ISchemaElement_INTERFACE_DEFINED__

/* interface ISchemaElement */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b7-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaElement : public ISchemaParticle
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ ISchemaType **type) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_scope( 
            /* [retval][out] */ ISchemaComplexType **scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_defaultValue( 
            /* [retval][out] */ BSTR *defaultValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_fixedValue( 
            /* [retval][out] */ BSTR *fixedValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isNillable( 
            /* [retval][out] */ VARIANT_BOOL *nillable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_identityConstraints( 
            /* [retval][out] */ ISchemaItemCollection **constraints) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_substitutionGroup( 
            /* [retval][out] */ ISchemaElement **element) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_substitutionGroupExclusions( 
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *exclusions) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_disallowedSubstitutions( 
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *disallowed) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isAbstract( 
            /* [retval][out] */ VARIANT_BOOL *abstract) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isReference( 
            /* [retval][out] */ VARIANT_BOOL *reference) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaElement * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaElement * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaElement * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaElement * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaElement * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaElement * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaElement * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaElement * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaElement * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaElement * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaElement * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaElement * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minOccurs )( 
            ISchemaElement * This,
            /* [retval][out] */ VARIANT *minOccurs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxOccurs )( 
            ISchemaElement * This,
            /* [retval][out] */ VARIANT *maxOccurs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            ISchemaElement * This,
            /* [retval][out] */ ISchemaType **type);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_scope )( 
            ISchemaElement * This,
            /* [retval][out] */ ISchemaComplexType **scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_defaultValue )( 
            ISchemaElement * This,
            /* [retval][out] */ BSTR *defaultValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_fixedValue )( 
            ISchemaElement * This,
            /* [retval][out] */ BSTR *fixedValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isNillable )( 
            ISchemaElement * This,
            /* [retval][out] */ VARIANT_BOOL *nillable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_identityConstraints )( 
            ISchemaElement * This,
            /* [retval][out] */ ISchemaItemCollection **constraints);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_substitutionGroup )( 
            ISchemaElement * This,
            /* [retval][out] */ ISchemaElement **element);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_substitutionGroupExclusions )( 
            ISchemaElement * This,
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *exclusions);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_disallowedSubstitutions )( 
            ISchemaElement * This,
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *disallowed);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isAbstract )( 
            ISchemaElement * This,
            /* [retval][out] */ VARIANT_BOOL *abstract);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isReference )( 
            ISchemaElement * This,
            /* [retval][out] */ VARIANT_BOOL *reference);
        
        END_INTERFACE
    } ISchemaElementVtbl;

    interface ISchemaElement
    {
        CONST_VTBL struct ISchemaElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaElement_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaElement_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaElement_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaElement_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaElement_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaElement_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaElement_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaElement_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaElement_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaElement_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaElement_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaElement_get_minOccurs(This,minOccurs)	\
    ( (This)->lpVtbl -> get_minOccurs(This,minOccurs) ) 

#define ISchemaElement_get_maxOccurs(This,maxOccurs)	\
    ( (This)->lpVtbl -> get_maxOccurs(This,maxOccurs) ) 


#define ISchemaElement_get_type(This,type)	\
    ( (This)->lpVtbl -> get_type(This,type) ) 

#define ISchemaElement_get_scope(This,scope)	\
    ( (This)->lpVtbl -> get_scope(This,scope) ) 

#define ISchemaElement_get_defaultValue(This,defaultValue)	\
    ( (This)->lpVtbl -> get_defaultValue(This,defaultValue) ) 

#define ISchemaElement_get_fixedValue(This,fixedValue)	\
    ( (This)->lpVtbl -> get_fixedValue(This,fixedValue) ) 

#define ISchemaElement_get_isNillable(This,nillable)	\
    ( (This)->lpVtbl -> get_isNillable(This,nillable) ) 

#define ISchemaElement_get_identityConstraints(This,constraints)	\
    ( (This)->lpVtbl -> get_identityConstraints(This,constraints) ) 

#define ISchemaElement_get_substitutionGroup(This,element)	\
    ( (This)->lpVtbl -> get_substitutionGroup(This,element) ) 

#define ISchemaElement_get_substitutionGroupExclusions(This,exclusions)	\
    ( (This)->lpVtbl -> get_substitutionGroupExclusions(This,exclusions) ) 

#define ISchemaElement_get_disallowedSubstitutions(This,disallowed)	\
    ( (This)->lpVtbl -> get_disallowedSubstitutions(This,disallowed) ) 

#define ISchemaElement_get_isAbstract(This,abstract)	\
    ( (This)->lpVtbl -> get_isAbstract(This,abstract) ) 

#define ISchemaElement_get_isReference(This,reference)	\
    ( (This)->lpVtbl -> get_isReference(This,reference) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaElement_INTERFACE_DEFINED__ */


#ifndef __ISchemaType_INTERFACE_DEFINED__
#define __ISchemaType_INTERFACE_DEFINED__

/* interface ISchemaType */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b8-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaType : public ISchemaItem
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_baseTypes( 
            /* [retval][out] */ ISchemaItemCollection **baseTypes) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_final( 
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *final) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_variety( 
            /* [retval][out] */ SCHEMATYPEVARIETY *variety) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_derivedBy( 
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *derivedBy) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE isValid( 
            /* [in] */ BSTR data,
            /* [retval][out] */ VARIANT_BOOL *valid) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_minExclusive( 
            /* [retval][out] */ BSTR *minExclusive) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_minInclusive( 
            /* [retval][out] */ BSTR *minInclusive) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_maxExclusive( 
            /* [retval][out] */ BSTR *maxExclusive) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_maxInclusive( 
            /* [retval][out] */ BSTR *maxInclusive) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_totalDigits( 
            /* [retval][out] */ VARIANT *totalDigits) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_fractionDigits( 
            /* [retval][out] */ VARIANT *fractionDigits) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ VARIANT *length) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_minLength( 
            /* [retval][out] */ VARIANT *minLength) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_maxLength( 
            /* [retval][out] */ VARIANT *maxLength) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enumeration( 
            /* [retval][out] */ ISchemaStringCollection **enumeration) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_whitespace( 
            /* [retval][out] */ SCHEMAWHITESPACE *whitespace) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_patterns( 
            /* [retval][out] */ ISchemaStringCollection **patterns) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaType * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaType * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaType * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaType * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaType * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaType * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaType * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaType * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaType * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaType * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaType * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaType * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_baseTypes )( 
            ISchemaType * This,
            /* [retval][out] */ ISchemaItemCollection **baseTypes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_final )( 
            ISchemaType * This,
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *final);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_variety )( 
            ISchemaType * This,
            /* [retval][out] */ SCHEMATYPEVARIETY *variety);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_derivedBy )( 
            ISchemaType * This,
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *derivedBy);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *isValid )( 
            ISchemaType * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ VARIANT_BOOL *valid);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minExclusive )( 
            ISchemaType * This,
            /* [retval][out] */ BSTR *minExclusive);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minInclusive )( 
            ISchemaType * This,
            /* [retval][out] */ BSTR *minInclusive);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxExclusive )( 
            ISchemaType * This,
            /* [retval][out] */ BSTR *maxExclusive);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxInclusive )( 
            ISchemaType * This,
            /* [retval][out] */ BSTR *maxInclusive);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_totalDigits )( 
            ISchemaType * This,
            /* [retval][out] */ VARIANT *totalDigits);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_fractionDigits )( 
            ISchemaType * This,
            /* [retval][out] */ VARIANT *fractionDigits);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            ISchemaType * This,
            /* [retval][out] */ VARIANT *length);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minLength )( 
            ISchemaType * This,
            /* [retval][out] */ VARIANT *minLength);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxLength )( 
            ISchemaType * This,
            /* [retval][out] */ VARIANT *maxLength);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enumeration )( 
            ISchemaType * This,
            /* [retval][out] */ ISchemaStringCollection **enumeration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_whitespace )( 
            ISchemaType * This,
            /* [retval][out] */ SCHEMAWHITESPACE *whitespace);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_patterns )( 
            ISchemaType * This,
            /* [retval][out] */ ISchemaStringCollection **patterns);
        
        END_INTERFACE
    } ISchemaTypeVtbl;

    interface ISchemaType
    {
        CONST_VTBL struct ISchemaTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaType_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaType_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaType_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaType_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaType_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaType_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaType_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaType_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaType_get_baseTypes(This,baseTypes)	\
    ( (This)->lpVtbl -> get_baseTypes(This,baseTypes) ) 

#define ISchemaType_get_final(This,final)	\
    ( (This)->lpVtbl -> get_final(This,final) ) 

#define ISchemaType_get_variety(This,variety)	\
    ( (This)->lpVtbl -> get_variety(This,variety) ) 

#define ISchemaType_get_derivedBy(This,derivedBy)	\
    ( (This)->lpVtbl -> get_derivedBy(This,derivedBy) ) 

#define ISchemaType_isValid(This,data,valid)	\
    ( (This)->lpVtbl -> isValid(This,data,valid) ) 

#define ISchemaType_get_minExclusive(This,minExclusive)	\
    ( (This)->lpVtbl -> get_minExclusive(This,minExclusive) ) 

#define ISchemaType_get_minInclusive(This,minInclusive)	\
    ( (This)->lpVtbl -> get_minInclusive(This,minInclusive) ) 

#define ISchemaType_get_maxExclusive(This,maxExclusive)	\
    ( (This)->lpVtbl -> get_maxExclusive(This,maxExclusive) ) 

#define ISchemaType_get_maxInclusive(This,maxInclusive)	\
    ( (This)->lpVtbl -> get_maxInclusive(This,maxInclusive) ) 

#define ISchemaType_get_totalDigits(This,totalDigits)	\
    ( (This)->lpVtbl -> get_totalDigits(This,totalDigits) ) 

#define ISchemaType_get_fractionDigits(This,fractionDigits)	\
    ( (This)->lpVtbl -> get_fractionDigits(This,fractionDigits) ) 

#define ISchemaType_get_length(This,length)	\
    ( (This)->lpVtbl -> get_length(This,length) ) 

#define ISchemaType_get_minLength(This,minLength)	\
    ( (This)->lpVtbl -> get_minLength(This,minLength) ) 

#define ISchemaType_get_maxLength(This,maxLength)	\
    ( (This)->lpVtbl -> get_maxLength(This,maxLength) ) 

#define ISchemaType_get_enumeration(This,enumeration)	\
    ( (This)->lpVtbl -> get_enumeration(This,enumeration) ) 

#define ISchemaType_get_whitespace(This,whitespace)	\
    ( (This)->lpVtbl -> get_whitespace(This,whitespace) ) 

#define ISchemaType_get_patterns(This,patterns)	\
    ( (This)->lpVtbl -> get_patterns(This,patterns) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaType_INTERFACE_DEFINED__ */


#ifndef __ISchemaComplexType_INTERFACE_DEFINED__
#define __ISchemaComplexType_INTERFACE_DEFINED__

/* interface ISchemaComplexType */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaComplexType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08b9-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaComplexType : public ISchemaType
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isAbstract( 
            /* [retval][out] */ VARIANT_BOOL *abstract) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_anyAttribute( 
            /* [retval][out] */ ISchemaAny **anyAttribute) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [retval][out] */ ISchemaItemCollection **attributes) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_contentType( 
            /* [retval][out] */ SCHEMACONTENTTYPE *contentType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_contentModel( 
            /* [retval][out] */ ISchemaModelGroup **contentModel) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_prohibitedSubstitutions( 
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *prohibited) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaComplexTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaComplexType * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaComplexType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaComplexType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaComplexType * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaComplexType * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaComplexType * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaComplexType * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaComplexType * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaComplexType * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaComplexType * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaComplexType * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaComplexType * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaComplexType * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaComplexType * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_baseTypes )( 
            ISchemaComplexType * This,
            /* [retval][out] */ ISchemaItemCollection **baseTypes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_final )( 
            ISchemaComplexType * This,
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *final);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_variety )( 
            ISchemaComplexType * This,
            /* [retval][out] */ SCHEMATYPEVARIETY *variety);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_derivedBy )( 
            ISchemaComplexType * This,
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *derivedBy);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *isValid )( 
            ISchemaComplexType * This,
            /* [in] */ BSTR data,
            /* [retval][out] */ VARIANT_BOOL *valid);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minExclusive )( 
            ISchemaComplexType * This,
            /* [retval][out] */ BSTR *minExclusive);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minInclusive )( 
            ISchemaComplexType * This,
            /* [retval][out] */ BSTR *minInclusive);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxExclusive )( 
            ISchemaComplexType * This,
            /* [retval][out] */ BSTR *maxExclusive);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxInclusive )( 
            ISchemaComplexType * This,
            /* [retval][out] */ BSTR *maxInclusive);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_totalDigits )( 
            ISchemaComplexType * This,
            /* [retval][out] */ VARIANT *totalDigits);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_fractionDigits )( 
            ISchemaComplexType * This,
            /* [retval][out] */ VARIANT *fractionDigits);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            ISchemaComplexType * This,
            /* [retval][out] */ VARIANT *length);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minLength )( 
            ISchemaComplexType * This,
            /* [retval][out] */ VARIANT *minLength);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxLength )( 
            ISchemaComplexType * This,
            /* [retval][out] */ VARIANT *maxLength);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enumeration )( 
            ISchemaComplexType * This,
            /* [retval][out] */ ISchemaStringCollection **enumeration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_whitespace )( 
            ISchemaComplexType * This,
            /* [retval][out] */ SCHEMAWHITESPACE *whitespace);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_patterns )( 
            ISchemaComplexType * This,
            /* [retval][out] */ ISchemaStringCollection **patterns);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isAbstract )( 
            ISchemaComplexType * This,
            /* [retval][out] */ VARIANT_BOOL *abstract);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_anyAttribute )( 
            ISchemaComplexType * This,
            /* [retval][out] */ ISchemaAny **anyAttribute);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            ISchemaComplexType * This,
            /* [retval][out] */ ISchemaItemCollection **attributes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_contentType )( 
            ISchemaComplexType * This,
            /* [retval][out] */ SCHEMACONTENTTYPE *contentType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_contentModel )( 
            ISchemaComplexType * This,
            /* [retval][out] */ ISchemaModelGroup **contentModel);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_prohibitedSubstitutions )( 
            ISchemaComplexType * This,
            /* [retval][out] */ SCHEMADERIVATIONMETHOD *prohibited);
        
        END_INTERFACE
    } ISchemaComplexTypeVtbl;

    interface ISchemaComplexType
    {
        CONST_VTBL struct ISchemaComplexTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaComplexType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaComplexType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaComplexType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaComplexType_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaComplexType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaComplexType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaComplexType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaComplexType_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaComplexType_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaComplexType_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaComplexType_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaComplexType_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaComplexType_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaComplexType_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaComplexType_get_baseTypes(This,baseTypes)	\
    ( (This)->lpVtbl -> get_baseTypes(This,baseTypes) ) 

#define ISchemaComplexType_get_final(This,final)	\
    ( (This)->lpVtbl -> get_final(This,final) ) 

#define ISchemaComplexType_get_variety(This,variety)	\
    ( (This)->lpVtbl -> get_variety(This,variety) ) 

#define ISchemaComplexType_get_derivedBy(This,derivedBy)	\
    ( (This)->lpVtbl -> get_derivedBy(This,derivedBy) ) 

#define ISchemaComplexType_isValid(This,data,valid)	\
    ( (This)->lpVtbl -> isValid(This,data,valid) ) 

#define ISchemaComplexType_get_minExclusive(This,minExclusive)	\
    ( (This)->lpVtbl -> get_minExclusive(This,minExclusive) ) 

#define ISchemaComplexType_get_minInclusive(This,minInclusive)	\
    ( (This)->lpVtbl -> get_minInclusive(This,minInclusive) ) 

#define ISchemaComplexType_get_maxExclusive(This,maxExclusive)	\
    ( (This)->lpVtbl -> get_maxExclusive(This,maxExclusive) ) 

#define ISchemaComplexType_get_maxInclusive(This,maxInclusive)	\
    ( (This)->lpVtbl -> get_maxInclusive(This,maxInclusive) ) 

#define ISchemaComplexType_get_totalDigits(This,totalDigits)	\
    ( (This)->lpVtbl -> get_totalDigits(This,totalDigits) ) 

#define ISchemaComplexType_get_fractionDigits(This,fractionDigits)	\
    ( (This)->lpVtbl -> get_fractionDigits(This,fractionDigits) ) 

#define ISchemaComplexType_get_length(This,length)	\
    ( (This)->lpVtbl -> get_length(This,length) ) 

#define ISchemaComplexType_get_minLength(This,minLength)	\
    ( (This)->lpVtbl -> get_minLength(This,minLength) ) 

#define ISchemaComplexType_get_maxLength(This,maxLength)	\
    ( (This)->lpVtbl -> get_maxLength(This,maxLength) ) 

#define ISchemaComplexType_get_enumeration(This,enumeration)	\
    ( (This)->lpVtbl -> get_enumeration(This,enumeration) ) 

#define ISchemaComplexType_get_whitespace(This,whitespace)	\
    ( (This)->lpVtbl -> get_whitespace(This,whitespace) ) 

#define ISchemaComplexType_get_patterns(This,patterns)	\
    ( (This)->lpVtbl -> get_patterns(This,patterns) ) 


#define ISchemaComplexType_get_isAbstract(This,abstract)	\
    ( (This)->lpVtbl -> get_isAbstract(This,abstract) ) 

#define ISchemaComplexType_get_anyAttribute(This,anyAttribute)	\
    ( (This)->lpVtbl -> get_anyAttribute(This,anyAttribute) ) 

#define ISchemaComplexType_get_attributes(This,attributes)	\
    ( (This)->lpVtbl -> get_attributes(This,attributes) ) 

#define ISchemaComplexType_get_contentType(This,contentType)	\
    ( (This)->lpVtbl -> get_contentType(This,contentType) ) 

#define ISchemaComplexType_get_contentModel(This,contentModel)	\
    ( (This)->lpVtbl -> get_contentModel(This,contentModel) ) 

#define ISchemaComplexType_get_prohibitedSubstitutions(This,prohibited)	\
    ( (This)->lpVtbl -> get_prohibitedSubstitutions(This,prohibited) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaComplexType_INTERFACE_DEFINED__ */


#ifndef __ISchemaAttributeGroup_INTERFACE_DEFINED__
#define __ISchemaAttributeGroup_INTERFACE_DEFINED__

/* interface ISchemaAttributeGroup */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaAttributeGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08ba-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaAttributeGroup : public ISchemaItem
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_anyAttribute( 
            /* [retval][out] */ ISchemaAny **anyAttribute) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [retval][out] */ ISchemaItemCollection **attributes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaAttributeGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaAttributeGroup * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaAttributeGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaAttributeGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaAttributeGroup * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaAttributeGroup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaAttributeGroup * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaAttributeGroup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaAttributeGroup * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaAttributeGroup * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaAttributeGroup * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaAttributeGroup * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaAttributeGroup * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaAttributeGroup * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaAttributeGroup * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_anyAttribute )( 
            ISchemaAttributeGroup * This,
            /* [retval][out] */ ISchemaAny **anyAttribute);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_attributes )( 
            ISchemaAttributeGroup * This,
            /* [retval][out] */ ISchemaItemCollection **attributes);
        
        END_INTERFACE
    } ISchemaAttributeGroupVtbl;

    interface ISchemaAttributeGroup
    {
        CONST_VTBL struct ISchemaAttributeGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaAttributeGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaAttributeGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaAttributeGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaAttributeGroup_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaAttributeGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaAttributeGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaAttributeGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaAttributeGroup_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaAttributeGroup_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaAttributeGroup_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaAttributeGroup_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaAttributeGroup_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaAttributeGroup_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaAttributeGroup_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaAttributeGroup_get_anyAttribute(This,anyAttribute)	\
    ( (This)->lpVtbl -> get_anyAttribute(This,anyAttribute) ) 

#define ISchemaAttributeGroup_get_attributes(This,attributes)	\
    ( (This)->lpVtbl -> get_attributes(This,attributes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaAttributeGroup_INTERFACE_DEFINED__ */


#ifndef __ISchemaModelGroup_INTERFACE_DEFINED__
#define __ISchemaModelGroup_INTERFACE_DEFINED__

/* interface ISchemaModelGroup */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaModelGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08bb-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaModelGroup : public ISchemaParticle
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_particles( 
            /* [retval][out] */ ISchemaItemCollection **particles) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaModelGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaModelGroup * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaModelGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaModelGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaModelGroup * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaModelGroup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaModelGroup * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaModelGroup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaModelGroup * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaModelGroup * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaModelGroup * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaModelGroup * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaModelGroup * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaModelGroup * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaModelGroup * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minOccurs )( 
            ISchemaModelGroup * This,
            /* [retval][out] */ VARIANT *minOccurs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxOccurs )( 
            ISchemaModelGroup * This,
            /* [retval][out] */ VARIANT *maxOccurs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_particles )( 
            ISchemaModelGroup * This,
            /* [retval][out] */ ISchemaItemCollection **particles);
        
        END_INTERFACE
    } ISchemaModelGroupVtbl;

    interface ISchemaModelGroup
    {
        CONST_VTBL struct ISchemaModelGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaModelGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaModelGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaModelGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaModelGroup_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaModelGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaModelGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaModelGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaModelGroup_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaModelGroup_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaModelGroup_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaModelGroup_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaModelGroup_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaModelGroup_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaModelGroup_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaModelGroup_get_minOccurs(This,minOccurs)	\
    ( (This)->lpVtbl -> get_minOccurs(This,minOccurs) ) 

#define ISchemaModelGroup_get_maxOccurs(This,maxOccurs)	\
    ( (This)->lpVtbl -> get_maxOccurs(This,maxOccurs) ) 


#define ISchemaModelGroup_get_particles(This,particles)	\
    ( (This)->lpVtbl -> get_particles(This,particles) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaModelGroup_INTERFACE_DEFINED__ */


#ifndef __ISchemaAny_INTERFACE_DEFINED__
#define __ISchemaAny_INTERFACE_DEFINED__

/* interface ISchemaAny */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaAny;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08bc-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaAny : public ISchemaParticle
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_namespaces( 
            /* [retval][out] */ ISchemaStringCollection **namespaces) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_processContents( 
            /* [retval][out] */ SCHEMAPROCESSCONTENTS *processContents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaAnyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaAny * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaAny * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaAny * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaAny * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaAny * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaAny * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaAny * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaAny * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaAny * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaAny * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaAny * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaAny * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaAny * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaAny * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_minOccurs )( 
            ISchemaAny * This,
            /* [retval][out] */ VARIANT *minOccurs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxOccurs )( 
            ISchemaAny * This,
            /* [retval][out] */ VARIANT *maxOccurs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaces )( 
            ISchemaAny * This,
            /* [retval][out] */ ISchemaStringCollection **namespaces);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_processContents )( 
            ISchemaAny * This,
            /* [retval][out] */ SCHEMAPROCESSCONTENTS *processContents);
        
        END_INTERFACE
    } ISchemaAnyVtbl;

    interface ISchemaAny
    {
        CONST_VTBL struct ISchemaAnyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaAny_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaAny_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaAny_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaAny_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaAny_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaAny_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaAny_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaAny_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaAny_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaAny_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaAny_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaAny_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaAny_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaAny_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaAny_get_minOccurs(This,minOccurs)	\
    ( (This)->lpVtbl -> get_minOccurs(This,minOccurs) ) 

#define ISchemaAny_get_maxOccurs(This,maxOccurs)	\
    ( (This)->lpVtbl -> get_maxOccurs(This,maxOccurs) ) 


#define ISchemaAny_get_namespaces(This,namespaces)	\
    ( (This)->lpVtbl -> get_namespaces(This,namespaces) ) 

#define ISchemaAny_get_processContents(This,processContents)	\
    ( (This)->lpVtbl -> get_processContents(This,processContents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaAny_INTERFACE_DEFINED__ */


#ifndef __ISchemaIdentityConstraint_INTERFACE_DEFINED__
#define __ISchemaIdentityConstraint_INTERFACE_DEFINED__

/* interface ISchemaIdentityConstraint */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaIdentityConstraint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08bd-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaIdentityConstraint : public ISchemaItem
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_selector( 
            /* [retval][out] */ BSTR *selector) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_fields( 
            /* [retval][out] */ ISchemaStringCollection **fields) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_referencedKey( 
            /* [retval][out] */ ISchemaIdentityConstraint **key) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaIdentityConstraintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaIdentityConstraint * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaIdentityConstraint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaIdentityConstraint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaIdentityConstraint * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaIdentityConstraint * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaIdentityConstraint * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaIdentityConstraint * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaIdentityConstraint * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaIdentityConstraint * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaIdentityConstraint * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaIdentityConstraint * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaIdentityConstraint * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaIdentityConstraint * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaIdentityConstraint * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_selector )( 
            ISchemaIdentityConstraint * This,
            /* [retval][out] */ BSTR *selector);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_fields )( 
            ISchemaIdentityConstraint * This,
            /* [retval][out] */ ISchemaStringCollection **fields);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_referencedKey )( 
            ISchemaIdentityConstraint * This,
            /* [retval][out] */ ISchemaIdentityConstraint **key);
        
        END_INTERFACE
    } ISchemaIdentityConstraintVtbl;

    interface ISchemaIdentityConstraint
    {
        CONST_VTBL struct ISchemaIdentityConstraintVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaIdentityConstraint_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaIdentityConstraint_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaIdentityConstraint_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaIdentityConstraint_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaIdentityConstraint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaIdentityConstraint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaIdentityConstraint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaIdentityConstraint_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaIdentityConstraint_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaIdentityConstraint_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaIdentityConstraint_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaIdentityConstraint_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaIdentityConstraint_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaIdentityConstraint_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaIdentityConstraint_get_selector(This,selector)	\
    ( (This)->lpVtbl -> get_selector(This,selector) ) 

#define ISchemaIdentityConstraint_get_fields(This,fields)	\
    ( (This)->lpVtbl -> get_fields(This,fields) ) 

#define ISchemaIdentityConstraint_get_referencedKey(This,key)	\
    ( (This)->lpVtbl -> get_referencedKey(This,key) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaIdentityConstraint_INTERFACE_DEFINED__ */


#ifndef __ISchemaNotation_INTERFACE_DEFINED__
#define __ISchemaNotation_INTERFACE_DEFINED__

/* interface ISchemaNotation */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaNotation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50ea08be-dd1b-4664-9a50-c2f40f4bd79a")
    ISchemaNotation : public ISchemaItem
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_systemIdentifier( 
            /* [retval][out] */ BSTR *uri) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_publicIdentifier( 
            /* [retval][out] */ BSTR *uri) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaNotationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaNotation * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaNotation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaNotation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISchemaNotation * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISchemaNotation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISchemaNotation * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISchemaNotation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            ISchemaNotation * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_namespaceURI )( 
            ISchemaNotation * This,
            /* [retval][out] */ BSTR *namespaceURI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_schema )( 
            ISchemaNotation * This,
            /* [retval][out] */ ISchema **schema);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            ISchemaNotation * This,
            /* [retval][out] */ BSTR *id);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_itemType )( 
            ISchemaNotation * This,
            /* [retval][out] */ SOMITEMTYPE *itemType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_unhandledAttributes )( 
            ISchemaNotation * This,
            /* [retval][out] */ IVBSAXAttributes **attributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *writeAnnotation )( 
            ISchemaNotation * This,
            /* [in] */ IUnknown *annotationSink,
            /* [retval][out] */ VARIANT_BOOL *isWritten);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_systemIdentifier )( 
            ISchemaNotation * This,
            /* [retval][out] */ BSTR *uri);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_publicIdentifier )( 
            ISchemaNotation * This,
            /* [retval][out] */ BSTR *uri);
        
        END_INTERFACE
    } ISchemaNotationVtbl;

    interface ISchemaNotation
    {
        CONST_VTBL struct ISchemaNotationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaNotation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaNotation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaNotation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaNotation_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISchemaNotation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISchemaNotation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISchemaNotation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISchemaNotation_get_name(This,name)	\
    ( (This)->lpVtbl -> get_name(This,name) ) 

#define ISchemaNotation_get_namespaceURI(This,namespaceURI)	\
    ( (This)->lpVtbl -> get_namespaceURI(This,namespaceURI) ) 

#define ISchemaNotation_get_schema(This,schema)	\
    ( (This)->lpVtbl -> get_schema(This,schema) ) 

#define ISchemaNotation_get_id(This,id)	\
    ( (This)->lpVtbl -> get_id(This,id) ) 

#define ISchemaNotation_get_itemType(This,itemType)	\
    ( (This)->lpVtbl -> get_itemType(This,itemType) ) 

#define ISchemaNotation_get_unhandledAttributes(This,attributes)	\
    ( (This)->lpVtbl -> get_unhandledAttributes(This,attributes) ) 

#define ISchemaNotation_writeAnnotation(This,annotationSink,isWritten)	\
    ( (This)->lpVtbl -> writeAnnotation(This,annotationSink,isWritten) ) 


#define ISchemaNotation_get_systemIdentifier(This,uri)	\
    ( (This)->lpVtbl -> get_systemIdentifier(This,uri) ) 

#define ISchemaNotation_get_publicIdentifier(This,uri)	\
    ( (This)->lpVtbl -> get_publicIdentifier(This,uri) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaNotation_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMSelection_INTERFACE_DEFINED__
#define __IXMLDOMSelection_INTERFACE_DEFINED__

/* interface IXMLDOMSelection */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA634FC7-5888-44a7-A257-3A47150D3A0E")
    IXMLDOMSelection : public IXMLDOMNodeList
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_expr( 
            /* [retval][out] */ BSTR *expression) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_expr( 
            /* [in] */ BSTR expression) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_context( 
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id][propputref] */ HRESULT STDMETHODCALLTYPE putref_context( 
            /* [in] */ IXMLDOMNode *pNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE peekNode( 
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE matches( 
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeNext( 
            /* [retval][out] */ IXMLDOMNode **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeAll( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IXMLDOMSelection **ppNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLDOMSelection * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLDOMSelection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLDOMSelection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXMLDOMSelection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXMLDOMSelection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXMLDOMSelection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLDOMSelection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IXMLDOMSelection * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode **listItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ long *listLength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *nextNode )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **nextItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IXMLDOMSelection * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IXMLDOMSelection * This,
            /* [out][retval] */ IUnknown **ppUnk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_expr )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ BSTR *expression);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_expr )( 
            IXMLDOMSelection * This,
            /* [in] */ BSTR expression);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_context )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id][propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_context )( 
            IXMLDOMSelection * This,
            /* [in] */ IXMLDOMNode *pNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *peekNode )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *matches )( 
            IXMLDOMSelection * This,
            /* [in] */ IXMLDOMNode *pNode,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeNext )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMNode **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeAll )( 
            IXMLDOMSelection * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *clone )( 
            IXMLDOMSelection * This,
            /* [retval][out] */ IXMLDOMSelection **ppNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getProperty )( 
            IXMLDOMSelection * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setProperty )( 
            IXMLDOMSelection * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        END_INTERFACE
    } IXMLDOMSelectionVtbl;

    interface IXMLDOMSelection
    {
        CONST_VTBL struct IXMLDOMSelectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMSelection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXMLDOMSelection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXMLDOMSelection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXMLDOMSelection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXMLDOMSelection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXMLDOMSelection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXMLDOMSelection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IXMLDOMSelection_get_item(This,index,listItem)	\
    ( (This)->lpVtbl -> get_item(This,index,listItem) ) 

#define IXMLDOMSelection_get_length(This,listLength)	\
    ( (This)->lpVtbl -> get_length(This,listLength) ) 

#define IXMLDOMSelection_nextNode(This,nextItem)	\
    ( (This)->lpVtbl -> nextNode(This,nextItem) ) 

#define IXMLDOMSelection_reset(This)	\
    ( (This)->lpVtbl -> reset(This) ) 

#define IXMLDOMSelection_get__newEnum(This,ppUnk)	\
    ( (This)->lpVtbl -> get__newEnum(This,ppUnk) ) 


#define IXMLDOMSelection_get_expr(This,expression)	\
    ( (This)->lpVtbl -> get_expr(This,expression) ) 

#define IXMLDOMSelection_put_expr(This,expression)	\
    ( (This)->lpVtbl -> put_expr(This,expression) ) 

#define IXMLDOMSelection_get_context(This,ppNode)	\
    ( (This)->lpVtbl -> get_context(This,ppNode) ) 

#define IXMLDOMSelection_putref_context(This,pNode)	\
    ( (This)->lpVtbl -> putref_context(This,pNode) ) 

#define IXMLDOMSelection_peekNode(This,ppNode)	\
    ( (This)->lpVtbl -> peekNode(This,ppNode) ) 

#define IXMLDOMSelection_matches(This,pNode,ppNode)	\
    ( (This)->lpVtbl -> matches(This,pNode,ppNode) ) 

#define IXMLDOMSelection_removeNext(This,ppNode)	\
    ( (This)->lpVtbl -> removeNext(This,ppNode) ) 

#define IXMLDOMSelection_removeAll(This)	\
    ( (This)->lpVtbl -> removeAll(This) ) 

#define IXMLDOMSelection_clone(This,ppNode)	\
    ( (This)->lpVtbl -> clone(This,ppNode) ) 

#define IXMLDOMSelection_getProperty(This,name,value)	\
    ( (This)->lpVtbl -> getProperty(This,name,value) ) 

#define IXMLDOMSelection_setProperty(This,name,value)	\
    ( (This)->lpVtbl -> setProperty(This,name,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMSelection_INTERFACE_DEFINED__ */


#ifndef __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__
#define __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__

/* dispinterface XMLDOMDocumentEvents */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_XMLDOMDocumentEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3efaa427-272f-11d2-836f-0000f87a7782")
    XMLDOMDocumentEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct XMLDOMDocumentEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in XMLDOMDocumentEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in XMLDOMDocumentEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in XMLDOMDocumentEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in XMLDOMDocumentEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in XMLDOMDocumentEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in XMLDOMDocumentEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            XMLDOMDocumentEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } XMLDOMDocumentEventsVtbl;

    interface XMLDOMDocumentEvents
    {
        CONST_VTBL struct XMLDOMDocumentEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define XMLDOMDocumentEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define XMLDOMDocumentEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define XMLDOMDocumentEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define XMLDOMDocumentEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define XMLDOMDocumentEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define XMLDOMDocumentEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define XMLDOMDocumentEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IDSOControl_INTERFACE_DEFINED__
#define __IDSOControl_INTERFACE_DEFINED__

/* interface IDSOControl */
/* [unique][helpstring][hidden][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IDSOControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("310afa62-0575-11d2-9ca9-0060b0ec3d39")
    IDSOControl : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLDocument( 
            /* [retval][out] */ IXMLDOMDocument **ppDoc) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMLDocument( 
            /* [in] */ IXMLDOMDocument *ppDoc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_JavaDSOCompatible( 
            /* [retval][out] */ BOOL *fJavaDSOCompatible) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_JavaDSOCompatible( 
            /* [in] */ BOOL fJavaDSOCompatible) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long *state) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSOControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSOControl * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSOControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSOControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDSOControl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDSOControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDSOControl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDSOControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XMLDocument )( 
            IDSOControl * This,
            /* [retval][out] */ IXMLDOMDocument **ppDoc);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_XMLDocument )( 
            IDSOControl * This,
            /* [in] */ IXMLDOMDocument *ppDoc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JavaDSOCompatible )( 
            IDSOControl * This,
            /* [retval][out] */ BOOL *fJavaDSOCompatible);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_JavaDSOCompatible )( 
            IDSOControl * This,
            /* [in] */ BOOL fJavaDSOCompatible);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            IDSOControl * This,
            /* [retval][out] */ long *state);
        
        END_INTERFACE
    } IDSOControlVtbl;

    interface IDSOControl
    {
        CONST_VTBL struct IDSOControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSOControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSOControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSOControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSOControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDSOControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDSOControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDSOControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDSOControl_get_XMLDocument(This,ppDoc)	\
    ( (This)->lpVtbl -> get_XMLDocument(This,ppDoc) ) 

#define IDSOControl_put_XMLDocument(This,ppDoc)	\
    ( (This)->lpVtbl -> put_XMLDocument(This,ppDoc) ) 

#define IDSOControl_get_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    ( (This)->lpVtbl -> get_JavaDSOCompatible(This,fJavaDSOCompatible) ) 

#define IDSOControl_put_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    ( (This)->lpVtbl -> put_JavaDSOCompatible(This,fJavaDSOCompatible) ) 

#define IDSOControl_get_readyState(This,state)	\
    ( (This)->lpVtbl -> get_readyState(This,state) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSOControl_INTERFACE_DEFINED__ */


#ifndef __IXMLHTTPRequest_INTERFACE_DEFINED__
#define __IXMLHTTPRequest_INTERFACE_DEFINED__

/* interface IXMLHTTPRequest */
/* [unique][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IXMLHTTPRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED8C108D-4349-11D2-91A4-00C04F7969E8")
    IXMLHTTPRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE open( 
            /* [in] */ __RPC__in BSTR bstrMethod,
            /* [in] */ __RPC__in BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setRequestHeader( 
            /* [in] */ __RPC__in BSTR bstrHeader,
            /* [in] */ __RPC__in BSTR bstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getResponseHeader( 
            /* [in] */ __RPC__in BSTR bstrHeader,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getAllResponseHeaders( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrHeaders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE send( 
            /* [optional][in] */ VARIANT varBody) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_status( 
            /* [retval][out] */ __RPC__out long *plStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_statusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseXML( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseBody( 
            /* [retval][out] */ __RPC__out VARIANT *pvarBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_responseStream( 
            /* [retval][out] */ __RPC__out VARIANT *pvarBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ __RPC__out long *plState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_onreadystatechange( 
            /* [in] */ __RPC__in_opt IDispatch *pReadyStateSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLHTTPRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IXMLHTTPRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IXMLHTTPRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXMLHTTPRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *open )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [in] */ __RPC__in BSTR bstrMethod,
            /* [in] */ __RPC__in BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setRequestHeader )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [in] */ __RPC__in BSTR bstrHeader,
            /* [in] */ __RPC__in BSTR bstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getResponseHeader )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [in] */ __RPC__in BSTR bstrHeader,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAllResponseHeaders )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *send )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            __RPC__in IXMLHTTPRequest * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__out long *plStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statusText )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseXML )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseText )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseBody )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseStream )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__out long *plState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            __RPC__in IXMLHTTPRequest * This,
            /* [in] */ __RPC__in_opt IDispatch *pReadyStateSink);
        
        END_INTERFACE
    } IXMLHTTPRequestVtbl;

    interface IXMLHTTPRequest
    {
        CONST_VTBL struct IXMLHTTPRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLHTTPRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXMLHTTPRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXMLHTTPRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXMLHTTPRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXMLHTTPRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXMLHTTPRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXMLHTTPRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IXMLHTTPRequest_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    ( (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword) ) 

#define IXMLHTTPRequest_setRequestHeader(This,bstrHeader,bstrValue)	\
    ( (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue) ) 

#define IXMLHTTPRequest_getResponseHeader(This,bstrHeader,pbstrValue)	\
    ( (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue) ) 

#define IXMLHTTPRequest_getAllResponseHeaders(This,pbstrHeaders)	\
    ( (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders) ) 

#define IXMLHTTPRequest_send(This,varBody)	\
    ( (This)->lpVtbl -> send(This,varBody) ) 

#define IXMLHTTPRequest_abort(This)	\
    ( (This)->lpVtbl -> abort(This) ) 

#define IXMLHTTPRequest_get_status(This,plStatus)	\
    ( (This)->lpVtbl -> get_status(This,plStatus) ) 

#define IXMLHTTPRequest_get_statusText(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_statusText(This,pbstrStatus) ) 

#define IXMLHTTPRequest_get_responseXML(This,ppBody)	\
    ( (This)->lpVtbl -> get_responseXML(This,ppBody) ) 

#define IXMLHTTPRequest_get_responseText(This,pbstrBody)	\
    ( (This)->lpVtbl -> get_responseText(This,pbstrBody) ) 

#define IXMLHTTPRequest_get_responseBody(This,pvarBody)	\
    ( (This)->lpVtbl -> get_responseBody(This,pvarBody) ) 

#define IXMLHTTPRequest_get_responseStream(This,pvarBody)	\
    ( (This)->lpVtbl -> get_responseStream(This,pvarBody) ) 

#define IXMLHTTPRequest_get_readyState(This,plState)	\
    ( (This)->lpVtbl -> get_readyState(This,plState) ) 

#define IXMLHTTPRequest_put_onreadystatechange(This,pReadyStateSink)	\
    ( (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLHTTPRequest_INTERFACE_DEFINED__ */


#ifndef __IServerXMLHTTPRequest_INTERFACE_DEFINED__
#define __IServerXMLHTTPRequest_INTERFACE_DEFINED__

/* interface IServerXMLHTTPRequest */
/* [unique][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IServerXMLHTTPRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e9196bf-13ba-4dd4-91ca-6c571f281495")
    IServerXMLHTTPRequest : public IXMLHTTPRequest
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setTimeouts( 
            /* [in] */ long resolveTimeout,
            /* [in] */ long connectTimeout,
            /* [in] */ long sendTimeout,
            /* [in] */ long receiveTimeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE waitForResponse( 
            /* [optional][in] */ VARIANT timeoutInSeconds,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isSuccessful) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getOption( 
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [retval][out] */ __RPC__out VARIANT *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setOption( 
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [in] */ VARIANT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerXMLHTTPRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IServerXMLHTTPRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IServerXMLHTTPRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IServerXMLHTTPRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *open )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ __RPC__in BSTR bstrMethod,
            /* [in] */ __RPC__in BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setRequestHeader )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ __RPC__in BSTR bstrHeader,
            /* [in] */ __RPC__in BSTR bstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getResponseHeader )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ __RPC__in BSTR bstrHeader,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAllResponseHeaders )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *send )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            __RPC__in IServerXMLHTTPRequest * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__out long *plStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statusText )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseXML )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseText )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseBody )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseStream )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [retval][out] */ __RPC__out long *plState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ __RPC__in_opt IDispatch *pReadyStateSink);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setTimeouts )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ long resolveTimeout,
            /* [in] */ long connectTimeout,
            /* [in] */ long sendTimeout,
            /* [in] */ long receiveTimeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *waitForResponse )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [optional][in] */ VARIANT timeoutInSeconds,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getOption )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [retval][out] */ __RPC__out VARIANT *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setOption )( 
            __RPC__in IServerXMLHTTPRequest * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [in] */ VARIANT value);
        
        END_INTERFACE
    } IServerXMLHTTPRequestVtbl;

    interface IServerXMLHTTPRequest
    {
        CONST_VTBL struct IServerXMLHTTPRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerXMLHTTPRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServerXMLHTTPRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServerXMLHTTPRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServerXMLHTTPRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IServerXMLHTTPRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IServerXMLHTTPRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IServerXMLHTTPRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IServerXMLHTTPRequest_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    ( (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword) ) 

#define IServerXMLHTTPRequest_setRequestHeader(This,bstrHeader,bstrValue)	\
    ( (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue) ) 

#define IServerXMLHTTPRequest_getResponseHeader(This,bstrHeader,pbstrValue)	\
    ( (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue) ) 

#define IServerXMLHTTPRequest_getAllResponseHeaders(This,pbstrHeaders)	\
    ( (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders) ) 

#define IServerXMLHTTPRequest_send(This,varBody)	\
    ( (This)->lpVtbl -> send(This,varBody) ) 

#define IServerXMLHTTPRequest_abort(This)	\
    ( (This)->lpVtbl -> abort(This) ) 

#define IServerXMLHTTPRequest_get_status(This,plStatus)	\
    ( (This)->lpVtbl -> get_status(This,plStatus) ) 

#define IServerXMLHTTPRequest_get_statusText(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_statusText(This,pbstrStatus) ) 

#define IServerXMLHTTPRequest_get_responseXML(This,ppBody)	\
    ( (This)->lpVtbl -> get_responseXML(This,ppBody) ) 

#define IServerXMLHTTPRequest_get_responseText(This,pbstrBody)	\
    ( (This)->lpVtbl -> get_responseText(This,pbstrBody) ) 

#define IServerXMLHTTPRequest_get_responseBody(This,pvarBody)	\
    ( (This)->lpVtbl -> get_responseBody(This,pvarBody) ) 

#define IServerXMLHTTPRequest_get_responseStream(This,pvarBody)	\
    ( (This)->lpVtbl -> get_responseStream(This,pvarBody) ) 

#define IServerXMLHTTPRequest_get_readyState(This,plState)	\
    ( (This)->lpVtbl -> get_readyState(This,plState) ) 

#define IServerXMLHTTPRequest_put_onreadystatechange(This,pReadyStateSink)	\
    ( (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink) ) 


#define IServerXMLHTTPRequest_setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout)	\
    ( (This)->lpVtbl -> setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout) ) 

#define IServerXMLHTTPRequest_waitForResponse(This,timeoutInSeconds,isSuccessful)	\
    ( (This)->lpVtbl -> waitForResponse(This,timeoutInSeconds,isSuccessful) ) 

#define IServerXMLHTTPRequest_getOption(This,option,value)	\
    ( (This)->lpVtbl -> getOption(This,option,value) ) 

#define IServerXMLHTTPRequest_setOption(This,option,value)	\
    ( (This)->lpVtbl -> setOption(This,option,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServerXMLHTTPRequest_INTERFACE_DEFINED__ */


#ifndef __IServerXMLHTTPRequest2_INTERFACE_DEFINED__
#define __IServerXMLHTTPRequest2_INTERFACE_DEFINED__

/* interface IServerXMLHTTPRequest2 */
/* [unique][helpstring][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IServerXMLHTTPRequest2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e01311b-c322-4b0a-bd77-b90cfdc8dce7")
    IServerXMLHTTPRequest2 : public IServerXMLHTTPRequest
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProxy( 
            /* [in] */ SXH_PROXY_SETTING proxySetting,
            /* [optional][in] */ VARIANT varProxyServer,
            /* [optional][in] */ VARIANT varBypassList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setProxyCredentials( 
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerXMLHTTPRequest2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IServerXMLHTTPRequest2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IServerXMLHTTPRequest2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IServerXMLHTTPRequest2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *open )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ __RPC__in BSTR bstrMethod,
            /* [in] */ __RPC__in BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setRequestHeader )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ __RPC__in BSTR bstrHeader,
            /* [in] */ __RPC__in BSTR bstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getResponseHeader )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ __RPC__in BSTR bstrHeader,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getAllResponseHeaders )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *send )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *abort )( 
            __RPC__in IServerXMLHTTPRequest2 * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [retval][out] */ __RPC__out long *plStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_statusText )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseXML )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseText )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseBody )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_responseStream )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_readyState )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [retval][out] */ __RPC__out long *plState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_onreadystatechange )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ __RPC__in_opt IDispatch *pReadyStateSink);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setTimeouts )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ long resolveTimeout,
            /* [in] */ long connectTimeout,
            /* [in] */ long sendTimeout,
            /* [in] */ long receiveTimeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *waitForResponse )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [optional][in] */ VARIANT timeoutInSeconds,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *isSuccessful);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getOption )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [retval][out] */ __RPC__out VARIANT *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setOption )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [in] */ VARIANT value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setProxy )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ SXH_PROXY_SETTING proxySetting,
            /* [optional][in] */ VARIANT varProxyServer,
            /* [optional][in] */ VARIANT varBypassList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setProxyCredentials )( 
            __RPC__in IServerXMLHTTPRequest2 * This,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrPassword);
        
        END_INTERFACE
    } IServerXMLHTTPRequest2Vtbl;

    interface IServerXMLHTTPRequest2
    {
        CONST_VTBL struct IServerXMLHTTPRequest2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerXMLHTTPRequest2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IServerXMLHTTPRequest2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IServerXMLHTTPRequest2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IServerXMLHTTPRequest2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IServerXMLHTTPRequest2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IServerXMLHTTPRequest2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IServerXMLHTTPRequest2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IServerXMLHTTPRequest2_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    ( (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword) ) 

#define IServerXMLHTTPRequest2_setRequestHeader(This,bstrHeader,bstrValue)	\
    ( (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue) ) 

#define IServerXMLHTTPRequest2_getResponseHeader(This,bstrHeader,pbstrValue)	\
    ( (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue) ) 

#define IServerXMLHTTPRequest2_getAllResponseHeaders(This,pbstrHeaders)	\
    ( (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders) ) 

#define IServerXMLHTTPRequest2_send(This,varBody)	\
    ( (This)->lpVtbl -> send(This,varBody) ) 

#define IServerXMLHTTPRequest2_abort(This)	\
    ( (This)->lpVtbl -> abort(This) ) 

#define IServerXMLHTTPRequest2_get_status(This,plStatus)	\
    ( (This)->lpVtbl -> get_status(This,plStatus) ) 

#define IServerXMLHTTPRequest2_get_statusText(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_statusText(This,pbstrStatus) ) 

#define IServerXMLHTTPRequest2_get_responseXML(This,ppBody)	\
    ( (This)->lpVtbl -> get_responseXML(This,ppBody) ) 

#define IServerXMLHTTPRequest2_get_responseText(This,pbstrBody)	\
    ( (This)->lpVtbl -> get_responseText(This,pbstrBody) ) 

#define IServerXMLHTTPRequest2_get_responseBody(This,pvarBody)	\
    ( (This)->lpVtbl -> get_responseBody(This,pvarBody) ) 

#define IServerXMLHTTPRequest2_get_responseStream(This,pvarBody)	\
    ( (This)->lpVtbl -> get_responseStream(This,pvarBody) ) 

#define IServerXMLHTTPRequest2_get_readyState(This,plState)	\
    ( (This)->lpVtbl -> get_readyState(This,plState) ) 

#define IServerXMLHTTPRequest2_put_onreadystatechange(This,pReadyStateSink)	\
    ( (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink) ) 


#define IServerXMLHTTPRequest2_setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout)	\
    ( (This)->lpVtbl -> setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout) ) 

#define IServerXMLHTTPRequest2_waitForResponse(This,timeoutInSeconds,isSuccessful)	\
    ( (This)->lpVtbl -> waitForResponse(This,timeoutInSeconds,isSuccessful) ) 

#define IServerXMLHTTPRequest2_getOption(This,option,value)	\
    ( (This)->lpVtbl -> getOption(This,option,value) ) 

#define IServerXMLHTTPRequest2_setOption(This,option,value)	\
    ( (This)->lpVtbl -> setOption(This,option,value) ) 


#define IServerXMLHTTPRequest2_setProxy(This,proxySetting,varProxyServer,varBypassList)	\
    ( (This)->lpVtbl -> setProxy(This,proxySetting,varProxyServer,varBypassList) ) 

#define IServerXMLHTTPRequest2_setProxyCredentials(This,bstrUserName,bstrPassword)	\
    ( (This)->lpVtbl -> setProxyCredentials(This,bstrUserName,bstrPassword) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IServerXMLHTTPRequest2_INTERFACE_DEFINED__ */


#ifndef __IMXNamespacePrefixes_INTERFACE_DEFINED__
#define __IMXNamespacePrefixes_INTERFACE_DEFINED__

/* interface IMXNamespacePrefixes */
/* [unique][nonextensible][oleautomation][dual][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IMXNamespacePrefixes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c90352f4-643c-4fbc-bb23-e996eb2d51fd")
    IMXNamespacePrefixes : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR *prefix) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *length) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXNamespacePrefixesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXNamespacePrefixes * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXNamespacePrefixes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXNamespacePrefixes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMXNamespacePrefixes * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMXNamespacePrefixes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMXNamespacePrefixes * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMXNamespacePrefixes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IMXNamespacePrefixes * This,
            /* [in] */ long index,
            /* [retval][out] */ BSTR *prefix);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            IMXNamespacePrefixes * This,
            /* [retval][out] */ long *length);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__newEnum )( 
            IMXNamespacePrefixes * This,
            /* [retval][out] */ IUnknown **ppUnk);
        
        END_INTERFACE
    } IMXNamespacePrefixesVtbl;

    interface IMXNamespacePrefixes
    {
        CONST_VTBL struct IMXNamespacePrefixesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXNamespacePrefixes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMXNamespacePrefixes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMXNamespacePrefixes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMXNamespacePrefixes_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMXNamespacePrefixes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMXNamespacePrefixes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMXNamespacePrefixes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMXNamespacePrefixes_get_item(This,index,prefix)	\
    ( (This)->lpVtbl -> get_item(This,index,prefix) ) 

#define IMXNamespacePrefixes_get_length(This,length)	\
    ( (This)->lpVtbl -> get_length(This,length) ) 

#define IMXNamespacePrefixes_get__newEnum(This,ppUnk)	\
    ( (This)->lpVtbl -> get__newEnum(This,ppUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMXNamespacePrefixes_INTERFACE_DEFINED__ */


#ifndef __IVBMXNamespaceManager_INTERFACE_DEFINED__
#define __IVBMXNamespaceManager_INTERFACE_DEFINED__

/* interface IVBMXNamespaceManager */
/* [unique][nonextensible][oleautomation][dual][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IVBMXNamespaceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c90352f5-643c-4fbc-bb23-e996eb2d51fd")
    IVBMXNamespaceManager : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_allowOverride( 
            /* [in] */ VARIANT_BOOL fOverride) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_allowOverride( 
            /* [retval][out] */ VARIANT_BOOL *fOverride) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE pushContext( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE pushNodeContext( 
            /* [in] */ IXMLDOMNode *contextNode,
            /* [defaultvalue][in] */ VARIANT_BOOL fDeep = -1) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE popContext( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE declarePrefix( 
            /* [in] */ BSTR prefix,
            /* [in] */ BSTR namespaceURI) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getDeclaredPrefixes( 
            /* [retval][out] */ IMXNamespacePrefixes **prefixes) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getPrefixes( 
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IMXNamespacePrefixes **prefixes) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getURI( 
            /* [in] */ BSTR prefix,
            /* [retval][out] */ VARIANT *uri) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getURIFromNode( 
            /* [in] */ BSTR strPrefix,
            /* [in] */ IXMLDOMNode *contextNode,
            /* [retval][out] */ VARIANT *uri) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBMXNamespaceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVBMXNamespaceManager * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVBMXNamespaceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVBMXNamespaceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVBMXNamespaceManager * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVBMXNamespaceManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVBMXNamespaceManager * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVBMXNamespaceManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_allowOverride )( 
            IVBMXNamespaceManager * This,
            /* [in] */ VARIANT_BOOL fOverride);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_allowOverride )( 
            IVBMXNamespaceManager * This,
            /* [retval][out] */ VARIANT_BOOL *fOverride);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *reset )( 
            IVBMXNamespaceManager * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *pushContext )( 
            IVBMXNamespaceManager * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *pushNodeContext )( 
            IVBMXNamespaceManager * This,
            /* [in] */ IXMLDOMNode *contextNode,
            /* [defaultvalue][in] */ VARIANT_BOOL fDeep);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *popContext )( 
            IVBMXNamespaceManager * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *declarePrefix )( 
            IVBMXNamespaceManager * This,
            /* [in] */ BSTR prefix,
            /* [in] */ BSTR namespaceURI);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getDeclaredPrefixes )( 
            IVBMXNamespaceManager * This,
            /* [retval][out] */ IMXNamespacePrefixes **prefixes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getPrefixes )( 
            IVBMXNamespaceManager * This,
            /* [in] */ BSTR namespaceURI,
            /* [retval][out] */ IMXNamespacePrefixes **prefixes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getURI )( 
            IVBMXNamespaceManager * This,
            /* [in] */ BSTR prefix,
            /* [retval][out] */ VARIANT *uri);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getURIFromNode )( 
            IVBMXNamespaceManager * This,
            /* [in] */ BSTR strPrefix,
            /* [in] */ IXMLDOMNode *contextNode,
            /* [retval][out] */ VARIANT *uri);
        
        END_INTERFACE
    } IVBMXNamespaceManagerVtbl;

    interface IVBMXNamespaceManager
    {
        CONST_VTBL struct IVBMXNamespaceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBMXNamespaceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVBMXNamespaceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVBMXNamespaceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVBMXNamespaceManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IVBMXNamespaceManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IVBMXNamespaceManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IVBMXNamespaceManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IVBMXNamespaceManager_put_allowOverride(This,fOverride)	\
    ( (This)->lpVtbl -> put_allowOverride(This,fOverride) ) 

#define IVBMXNamespaceManager_get_allowOverride(This,fOverride)	\
    ( (This)->lpVtbl -> get_allowOverride(This,fOverride) ) 

#define IVBMXNamespaceManager_reset(This)	\
    ( (This)->lpVtbl -> reset(This) ) 

#define IVBMXNamespaceManager_pushContext(This)	\
    ( (This)->lpVtbl -> pushContext(This) ) 

#define IVBMXNamespaceManager_pushNodeContext(This,contextNode,fDeep)	\
    ( (This)->lpVtbl -> pushNodeContext(This,contextNode,fDeep) ) 

#define IVBMXNamespaceManager_popContext(This)	\
    ( (This)->lpVtbl -> popContext(This) ) 

#define IVBMXNamespaceManager_declarePrefix(This,prefix,namespaceURI)	\
    ( (This)->lpVtbl -> declarePrefix(This,prefix,namespaceURI) ) 

#define IVBMXNamespaceManager_getDeclaredPrefixes(This,prefixes)	\
    ( (This)->lpVtbl -> getDeclaredPrefixes(This,prefixes) ) 

#define IVBMXNamespaceManager_getPrefixes(This,namespaceURI,prefixes)	\
    ( (This)->lpVtbl -> getPrefixes(This,namespaceURI,prefixes) ) 

#define IVBMXNamespaceManager_getURI(This,prefix,uri)	\
    ( (This)->lpVtbl -> getURI(This,prefix,uri) ) 

#define IVBMXNamespaceManager_getURIFromNode(This,strPrefix,contextNode,uri)	\
    ( (This)->lpVtbl -> getURIFromNode(This,strPrefix,contextNode,uri) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVBMXNamespaceManager_INTERFACE_DEFINED__ */


#ifndef __IMXNamespaceManager_INTERFACE_DEFINED__
#define __IMXNamespaceManager_INTERFACE_DEFINED__

/* interface IMXNamespaceManager */
/* [unique][helpstring][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_IMXNamespaceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c90352f6-643c-4fbc-bb23-e996eb2d51fd")
    IMXNamespaceManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE putAllowOverride( 
            /* [in] */ VARIANT_BOOL fOverride) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getAllowOverride( 
            /* [retval][out] */ VARIANT_BOOL *fOverride) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE pushContext( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE pushNodeContext( 
            /* [in] */ IXMLDOMNode *contextNode,
            /* [in] */ VARIANT_BOOL fDeep) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE popContext( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE declarePrefix( 
            /* [in] */ const wchar_t *prefix,
            /* [in] */ const wchar_t *namespaceURI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getDeclaredPrefix( 
            /* [in] */ long nIndex,
            /* [out][in] */ wchar_t *pwchPrefix,
            /* [out][in] */ int *pcchPrefix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getPrefix( 
            /* [in] */ const wchar_t *pwszNamespaceURI,
            /* [in] */ long nIndex,
            /* [out][in] */ wchar_t *pwchPrefix,
            /* [out][in] */ int *pcchPrefix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getURI( 
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ IXMLDOMNode *pContextNode,
            /* [out][in] */ wchar_t *pwchUri,
            /* [out][in] */ int *pcchUri) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXNamespaceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMXNamespaceManager * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMXNamespaceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMXNamespaceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *putAllowOverride )( 
            IMXNamespaceManager * This,
            /* [in] */ VARIANT_BOOL fOverride);
        
        HRESULT ( STDMETHODCALLTYPE *getAllowOverride )( 
            IMXNamespaceManager * This,
            /* [retval][out] */ VARIANT_BOOL *fOverride);
        
        HRESULT ( STDMETHODCALLTYPE *reset )( 
            IMXNamespaceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *pushContext )( 
            IMXNamespaceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *pushNodeContext )( 
            IMXNamespaceManager * This,
            /* [in] */ IXMLDOMNode *contextNode,
            /* [in] */ VARIANT_BOOL fDeep);
        
        HRESULT ( STDMETHODCALLTYPE *popContext )( 
            IMXNamespaceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *declarePrefix )( 
            IMXNamespaceManager * This,
            /* [in] */ const wchar_t *prefix,
            /* [in] */ const wchar_t *namespaceURI);
        
        HRESULT ( STDMETHODCALLTYPE *getDeclaredPrefix )( 
            IMXNamespaceManager * This,
            /* [in] */ long nIndex,
            /* [out][in] */ wchar_t *pwchPrefix,
            /* [out][in] */ int *pcchPrefix);
        
        HRESULT ( STDMETHODCALLTYPE *getPrefix )( 
            IMXNamespaceManager * This,
            /* [in] */ const wchar_t *pwszNamespaceURI,
            /* [in] */ long nIndex,
            /* [out][in] */ wchar_t *pwchPrefix,
            /* [out][in] */ int *pcchPrefix);
        
        HRESULT ( STDMETHODCALLTYPE *getURI )( 
            IMXNamespaceManager * This,
            /* [in] */ const wchar_t *pwchPrefix,
            /* [in] */ IXMLDOMNode *pContextNode,
            /* [out][in] */ wchar_t *pwchUri,
            /* [out][in] */ int *pcchUri);
        
        END_INTERFACE
    } IMXNamespaceManagerVtbl;

    interface IMXNamespaceManager
    {
        CONST_VTBL struct IMXNamespaceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXNamespaceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMXNamespaceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMXNamespaceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMXNamespaceManager_putAllowOverride(This,fOverride)	\
    ( (This)->lpVtbl -> putAllowOverride(This,fOverride) ) 

#define IMXNamespaceManager_getAllowOverride(This,fOverride)	\
    ( (This)->lpVtbl -> getAllowOverride(This,fOverride) ) 

#define IMXNamespaceManager_reset(This)	\
    ( (This)->lpVtbl -> reset(This) ) 

#define IMXNamespaceManager_pushContext(This)	\
    ( (This)->lpVtbl -> pushContext(This) ) 

#define IMXNamespaceManager_pushNodeContext(This,contextNode,fDeep)	\
    ( (This)->lpVtbl -> pushNodeContext(This,contextNode,fDeep) ) 

#define IMXNamespaceManager_popContext(This)	\
    ( (This)->lpVtbl -> popContext(This) ) 

#define IMXNamespaceManager_declarePrefix(This,prefix,namespaceURI)	\
    ( (This)->lpVtbl -> declarePrefix(This,prefix,namespaceURI) ) 

#define IMXNamespaceManager_getDeclaredPrefix(This,nIndex,pwchPrefix,pcchPrefix)	\
    ( (This)->lpVtbl -> getDeclaredPrefix(This,nIndex,pwchPrefix,pcchPrefix) ) 

#define IMXNamespaceManager_getPrefix(This,pwszNamespaceURI,nIndex,pwchPrefix,pcchPrefix)	\
    ( (This)->lpVtbl -> getPrefix(This,pwszNamespaceURI,nIndex,pwchPrefix,pcchPrefix) ) 

#define IMXNamespaceManager_getURI(This,pwchPrefix,pContextNode,pwchUri,pcchUri)	\
    ( (This)->lpVtbl -> getURI(This,pwchPrefix,pContextNode,pwchUri,pcchUri) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMXNamespaceManager_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DOMDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F11-9C73-11D3-B32E-00C04F990BB4")
DOMDocument;
#endif

EXTERN_C const CLSID CLSID_DOMDocument26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1b-c551-11d3-89b9-0000f81fe221")
DOMDocument26;
#endif

EXTERN_C const CLSID CLSID_DOMDocument30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f32-c551-11d3-89b9-0000f81fe221")
DOMDocument30;
#endif

EXTERN_C const CLSID CLSID_DOMDocument40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969c0-f192-11d4-a65f-0040963251e5")
DOMDocument40;
#endif

EXTERN_C const CLSID CLSID_DOMDocument60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a05-f192-11d4-a65f-0040963251e5")
DOMDocument60;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F12-9C73-11D3-B32E-00C04F990BB4")
FreeThreadedDOMDocument;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1c-c551-11d3-89b9-0000f81fe221")
FreeThreadedDOMDocument26;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f33-c551-11d3-89b9-0000f81fe221")
FreeThreadedDOMDocument30;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969c1-f192-11d4-a65f-0040963251e5")
FreeThreadedDOMDocument40;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a06-f192-11d4-a65f-0040963251e5")
FreeThreadedDOMDocument60;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache;

#ifdef __cplusplus

class DECLSPEC_UUID("373984c9-b845-449b-91e7-45ac83036ade")
XMLSchemaCache;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1d-c551-11d3-89b9-0000f81fe221")
XMLSchemaCache26;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f34-c551-11d3-89b9-0000f81fe221")
XMLSchemaCache30;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969c2-f192-11d4-a65f-0040963251e5")
XMLSchemaCache40;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a07-f192-11d4-a65f-0040963251e5")
XMLSchemaCache60;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate;

#ifdef __cplusplus

class DECLSPEC_UUID("2933BF94-7B36-11d2-B20E-00C04F983E60")
XSLTemplate;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f21-c551-11d3-89b9-0000f81fe221")
XSLTemplate26;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f36-c551-11d3-89b9-0000f81fe221")
XSLTemplate30;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969c3-f192-11d4-a65f-0040963251e5")
XSLTemplate40;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a08-f192-11d4-a65f-0040963251e5")
XSLTemplate60;
#endif

EXTERN_C const CLSID CLSID_DSOControl;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F14-9C73-11D3-B32E-00C04F990BB4")
DSOControl;
#endif

EXTERN_C const CLSID CLSID_DSOControl26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1f-c551-11d3-89b9-0000f81fe221")
DSOControl26;
#endif

EXTERN_C const CLSID CLSID_DSOControl30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f39-c551-11d3-89b9-0000f81fe221")
DSOControl30;
#endif

EXTERN_C const CLSID CLSID_DSOControl40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969c4-f192-11d4-a65f-0040963251e5")
DSOControl40;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F16-9C73-11D3-B32E-00C04F990BB4")
XMLHTTP;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1e-c551-11d3-89b9-0000f81fe221")
XMLHTTP26;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f35-c551-11d3-89b9-0000f81fe221")
XMLHTTP30;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969c5-f192-11d4-a65f-0040963251e5")
XMLHTTP40;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a0a-f192-11d4-a65f-0040963251e5")
XMLHTTP60;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP;

#ifdef __cplusplus

class DECLSPEC_UUID("afba6b42-5692-48ea-8141-dc517dcf0ef1")
ServerXMLHTTP;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP30;

#ifdef __cplusplus

class DECLSPEC_UUID("afb40ffd-b609-40a3-9828-f88bbe11e4e3")
ServerXMLHTTP30;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969c6-f192-11d4-a65f-0040963251e5")
ServerXMLHTTP40;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a0b-f192-11d4-a65f-0040963251e5")
ServerXMLHTTP60;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader;

#ifdef __cplusplus

class DECLSPEC_UUID("079aa557-4a18-424a-8eee-e39f0a8d41b9")
SAXXMLReader;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader30;

#ifdef __cplusplus

class DECLSPEC_UUID("3124c396-fb13-4836-a6ad-1317f1713688")
SAXXMLReader30;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader40;

#ifdef __cplusplus

class DECLSPEC_UUID("7c6e29bc-8b8b-4c3d-859e-af6cd158be0f")
SAXXMLReader40;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a0c-f192-11d4-a65f-0040963251e5")
SAXXMLReader60;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter;

#ifdef __cplusplus

class DECLSPEC_UUID("fc220ad8-a72a-4ee8-926e-0b7ad152a020")
MXXMLWriter;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter30;

#ifdef __cplusplus

class DECLSPEC_UUID("3d813dfe-6c91-4a4e-8f41-04346a841d9c")
MXXMLWriter30;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969c8-f192-11d4-a65f-0040963251e5")
MXXMLWriter40;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a0f-f192-11d4-a65f-0040963251e5")
MXXMLWriter60;
#endif

EXTERN_C const CLSID CLSID_MXHTMLWriter;

#ifdef __cplusplus

class DECLSPEC_UUID("a4c23ec3-6b70-4466-9127-550077239978")
MXHTMLWriter;
#endif

EXTERN_C const CLSID CLSID_MXHTMLWriter30;

#ifdef __cplusplus

class DECLSPEC_UUID("853d1540-c1a7-4aa9-a226-4d3bd301146d")
MXHTMLWriter30;
#endif

EXTERN_C const CLSID CLSID_MXHTMLWriter40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969c9-f192-11d4-a65f-0040963251e5")
MXHTMLWriter40;
#endif

EXTERN_C const CLSID CLSID_MXHTMLWriter60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a10-f192-11d4-a65f-0040963251e5")
MXHTMLWriter60;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes;

#ifdef __cplusplus

class DECLSPEC_UUID("4dd441ad-526d-4a77-9f1b-9841ed802fb0")
SAXAttributes;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes30;

#ifdef __cplusplus

class DECLSPEC_UUID("3e784a01-f3ae-4dc0-9354-9526b9370eba")
SAXAttributes30;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969ca-f192-11d4-a65f-0040963251e5")
SAXAttributes40;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a0e-f192-11d4-a65f-0040963251e5")
SAXAttributes60;
#endif

EXTERN_C const CLSID CLSID_MXNamespaceManager;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969d5-f192-11d4-a65f-0040963251e5")
MXNamespaceManager;
#endif

EXTERN_C const CLSID CLSID_MXNamespaceManager40;

#ifdef __cplusplus

class DECLSPEC_UUID("88d969d6-f192-11d4-a65f-0040963251e5")
MXNamespaceManager40;
#endif

EXTERN_C const CLSID CLSID_MXNamespaceManager60;

#ifdef __cplusplus

class DECLSPEC_UUID("88d96a11-f192-11d4-a65f-0040963251e5")
MXNamespaceManager60;
#endif
#endif /* __MSXML2_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_msxml6_0001_0185 */
/* [local] */ 

//----------------------------
// MSXML SPECIFIC ERROR CODES 
//----------------------------
#define E_XML_NOTWF                0xC00CE223L  // Validate failed because the document is not well formed.
#define E_XML_NODTD                0xC00CE224L  // The node is neither Valid nor Invalid because no DTD/Schema declaration was found.
#define E_XML_INVALID              0xC00CE225L  // Validate failed because of a DTD/Schema violation.
#define E_XML_BUFFERTOOSMALL       0xC00CE226L  // Buffer passed in is too small to receive the data.
#ifdef __USE_MSXML6_NAMESPACE__
}
#endif


extern RPC_IF_HANDLE __MIDL_itf_msxml6_0001_0185_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml6_0001_0185_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MtxAdmin_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Nov 14 05:07:21 1997
 */
/* Compiler settings for mtxadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICatalog = {0x6eb22870,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};

// These IID's are included by linking to uuid.lib
//const IID IID_ICatalogObject = {0x6eb22871,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};

// These IID's are included by linking to uuid.lib
//const IID IID_ICatalogCollection = {0x6eb22872,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};

const IID IID_IComponentUtil = {0x6eb22873,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IPackageUtil = {0x6eb22874,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRemoteComponentUtil = {0x6eb22875,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_IRoleAssociationUtil = {0x6eb22876,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID LIBID_MTSAdmin = {0x6eb22880,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_Catalog = {0x6eb22881,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogObject = {0x6eb22882,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_CatalogCollection = {0x6eb22883,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_ComponentUtil = {0x6eb22884,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_PackageUtil = {0x6eb22885,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RemoteComponentUtil = {0x6eb22886,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const CLSID CLSID_RoleAssociationUtil = {0x6eb22887,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MtxAdmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Fri Nov 14 05:07:21 1997
 */
/* Compiler settings for mtxadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtxadmin_h__
#define __mtxadmin_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICatalog_FWD_DEFINED__
#define __ICatalog_FWD_DEFINED__
typedef interface ICatalog ICatalog;
#endif 	/* __ICatalog_FWD_DEFINED__ */


#ifndef __ICatalogObject_FWD_DEFINED__
#define __ICatalogObject_FWD_DEFINED__
typedef interface ICatalogObject ICatalogObject;
#endif 	/* __ICatalogObject_FWD_DEFINED__ */


#ifndef __ICatalogCollection_FWD_DEFINED__
#define __ICatalogCollection_FWD_DEFINED__
typedef interface ICatalogCollection ICatalogCollection;
#endif 	/* __ICatalogCollection_FWD_DEFINED__ */


#ifndef __IComponentUtil_FWD_DEFINED__
#define __IComponentUtil_FWD_DEFINED__
typedef interface IComponentUtil IComponentUtil;
#endif 	/* __IComponentUtil_FWD_DEFINED__ */


#ifndef __IPackageUtil_FWD_DEFINED__
#define __IPackageUtil_FWD_DEFINED__
typedef interface IPackageUtil IPackageUtil;
#endif 	/* __IPackageUtil_FWD_DEFINED__ */


#ifndef __IRemoteComponentUtil_FWD_DEFINED__
#define __IRemoteComponentUtil_FWD_DEFINED__
typedef interface IRemoteComponentUtil IRemoteComponentUtil;
#endif 	/* __IRemoteComponentUtil_FWD_DEFINED__ */


#ifndef __IRoleAssociationUtil_FWD_DEFINED__
#define __IRoleAssociationUtil_FWD_DEFINED__
typedef interface IRoleAssociationUtil IRoleAssociationUtil;
#endif 	/* __IRoleAssociationUtil_FWD_DEFINED__ */


#ifndef __Catalog_FWD_DEFINED__
#define __Catalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class Catalog Catalog;
#else
typedef struct Catalog Catalog;
#endif /* __cplusplus */

#endif 	/* __Catalog_FWD_DEFINED__ */


#ifndef __CatalogObject_FWD_DEFINED__
#define __CatalogObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogObject CatalogObject;
#else
typedef struct CatalogObject CatalogObject;
#endif /* __cplusplus */

#endif 	/* __CatalogObject_FWD_DEFINED__ */


#ifndef __CatalogCollection_FWD_DEFINED__
#define __CatalogCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogCollection CatalogCollection;
#else
typedef struct CatalogCollection CatalogCollection;
#endif /* __cplusplus */

#endif 	/* __CatalogCollection_FWD_DEFINED__ */


#ifndef __ComponentUtil_FWD_DEFINED__
#define __ComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComponentUtil ComponentUtil;
#else
typedef struct ComponentUtil ComponentUtil;
#endif /* __cplusplus */

#endif 	/* __ComponentUtil_FWD_DEFINED__ */


#ifndef __PackageUtil_FWD_DEFINED__
#define __PackageUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class PackageUtil PackageUtil;
#else
typedef struct PackageUtil PackageUtil;
#endif /* __cplusplus */

#endif 	/* __PackageUtil_FWD_DEFINED__ */


#ifndef __RemoteComponentUtil_FWD_DEFINED__
#define __RemoteComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteComponentUtil RemoteComponentUtil;
#else
typedef struct RemoteComponentUtil RemoteComponentUtil;
#endif /* __cplusplus */

#endif 	/* __RemoteComponentUtil_FWD_DEFINED__ */


#ifndef __RoleAssociationUtil_FWD_DEFINED__
#define __RoleAssociationUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RoleAssociationUtil RoleAssociationUtil;
#else
typedef struct RoleAssociationUtil RoleAssociationUtil;
#endif /* __cplusplus */

#endif 	/* __RoleAssociationUtil_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

/****************************************
 * Generated header for interface: __MIDL_itf_mtxadmin_0000
 * at Fri Nov 14 05:07:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


// -----------------------------------------------------------------------	
// mtxadmin.h  -- Microsoft Transaction Server Programming Interfaces				
//																			
// This file provides the prototypes for the APIs and COM interfaces			
// used by Microsoft Transaction Server applications.													
//																			
// Microsoft Transaction Server SDK												
// Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.		
// -----------------------------------------------------------------------	
#include <objbase.h>
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_mtxadmin_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtxadmin_0000_v0_0_s_ifspec;

#ifndef __ICatalog_INTERFACE_DEFINED__
#define __ICatalog_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalog
 * at Fri Nov 14 05:07:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22870-8a19-11d0-81b6-00a0c9231c29")
    ICatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCollection )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MajorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        END_INTERFACE
    } ICatalogVtbl;

    interface ICatalog
    {
        CONST_VTBL struct ICatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalog_GetCollection(This,bstrCollName,ppCatalogCollection)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollName,ppCatalogCollection)

#define ICatalog_Connect(This,bstrConnectString,ppCatalogCollection)	\
    (This)->lpVtbl -> Connect(This,bstrConnectString,ppCatalogCollection)

#define ICatalog_get_MajorVersion(This,retval)	\
    (This)->lpVtbl -> get_MajorVersion(This,retval)

#define ICatalog_get_MinorVersion(This,retval)	\
    (This)->lpVtbl -> get_MinorVersion(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_GetCollection_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrCollName,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_Connect_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrConnectString,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MajorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MinorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalog_INTERFACE_DEFINED__ */


#ifndef __ICatalogObject_INTERFACE_DEFINED__
#define __ICatalogObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalogObject
 * at Fri Nov 14 05:07:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalogObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22871-8a19-11d0-81b6-00a0c9231c29")
    ICatalogObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrPropName,
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyReadOnly( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Valid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsPropertyWriteOnly( 
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalogObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalogObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalogObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [in] */ VARIANT val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPropertyReadOnly )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Valid )( 
            ICatalogObject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPropertyWriteOnly )( 
            ICatalogObject __RPC_FAR * This,
            /* [in] */ BSTR bstrPropName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        END_INTERFACE
    } ICatalogObjectVtbl;

    interface ICatalogObject
    {
        CONST_VTBL struct ICatalogObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalogObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalogObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalogObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalogObject_get_Value(This,bstrPropName,retval)	\
    (This)->lpVtbl -> get_Value(This,bstrPropName,retval)

#define ICatalogObject_put_Value(This,bstrPropName,val)	\
    (This)->lpVtbl -> put_Value(This,bstrPropName,val)

#define ICatalogObject_get_Key(This,retval)	\
    (This)->lpVtbl -> get_Key(This,retval)

#define ICatalogObject_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define ICatalogObject_IsPropertyReadOnly(This,bstrPropName,retval)	\
    (This)->lpVtbl -> IsPropertyReadOnly(This,bstrPropName,retval)

#define ICatalogObject_get_Valid(This,retval)	\
    (This)->lpVtbl -> get_Valid(This,retval)

#define ICatalogObject_IsPropertyWriteOnly(This,bstrPropName,retval)	\
    (This)->lpVtbl -> IsPropertyWriteOnly(This,bstrPropName,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Value_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ICatalogObject_put_Value_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [in] */ VARIANT val);


void __RPC_STUB ICatalogObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Key_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Name_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogObject_IsPropertyReadOnly_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_IsPropertyReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogObject_get_Valid_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_get_Valid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogObject_IsPropertyWriteOnly_Proxy( 
    ICatalogObject __RPC_FAR * This,
    /* [in] */ BSTR bstrPropName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogObject_IsPropertyWriteOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogObject_INTERFACE_DEFINED__ */


#ifndef __ICatalogCollection_INTERFACE_DEFINED__
#define __ICatalogCollection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatalogCollection
 * at Fri Nov 14 05:07:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICatalogCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22872-8a19-11d0-81b6-00a0c9231c29")
    ICatalogCollection : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Populate( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveChanges( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ VARIANT __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoveEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUtilInterface( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMajorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataStoreMinorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByKey( 
            /* [in] */ SAFEARRAY __RPC_FAR * aKeys) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PopulateByQuery( 
            /* [in] */ BSTR bstrQueryString,
            /* [in] */ long lQueryType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalogCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalogCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalogCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ long lIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Populate )( 
            ICatalogCollection __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCollection )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrCollName,
            /* [in] */ VARIANT varObjectKey,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AddEnabled )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RemoveEnabled )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUtilInterface )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataStoreMajorVersion )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataStoreMinorVersion )( 
            ICatalogCollection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopulateByKey )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * aKeys);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PopulateByQuery )( 
            ICatalogCollection __RPC_FAR * This,
            /* [in] */ BSTR bstrQueryString,
            /* [in] */ long lQueryType);
        
        END_INTERFACE
    } ICatalogCollectionVtbl;

    interface ICatalogCollection
    {
        CONST_VTBL struct ICatalogCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalogCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalogCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalogCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalogCollection_get__NewEnum(This,ppEnumVariant)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumVariant)

#define ICatalogCollection_get_Item(This,lIndex,ppCatalogObject)	\
    (This)->lpVtbl -> get_Item(This,lIndex,ppCatalogObject)

#define ICatalogCollection_get_Count(This,retval)	\
    (This)->lpVtbl -> get_Count(This,retval)

#define ICatalogCollection_Remove(This,lIndex)	\
    (This)->lpVtbl -> Remove(This,lIndex)

#define ICatalogCollection_Add(This,ppCatalogObject)	\
    (This)->lpVtbl -> Add(This,ppCatalogObject)

#define ICatalogCollection_Populate(This)	\
    (This)->lpVtbl -> Populate(This)

#define ICatalogCollection_SaveChanges(This,retval)	\
    (This)->lpVtbl -> SaveChanges(This,retval)

#define ICatalogCollection_GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollName,varObjectKey,ppCatalogCollection)

#define ICatalogCollection_get_Name(This,retval)	\
    (This)->lpVtbl -> get_Name(This,retval)

#define ICatalogCollection_get_AddEnabled(This,retval)	\
    (This)->lpVtbl -> get_AddEnabled(This,retval)

#define ICatalogCollection_get_RemoveEnabled(This,retval)	\
    (This)->lpVtbl -> get_RemoveEnabled(This,retval)

#define ICatalogCollection_GetUtilInterface(This,ppUtil)	\
    (This)->lpVtbl -> GetUtilInterface(This,ppUtil)

#define ICatalogCollection_get_DataStoreMajorVersion(This,retval)	\
    (This)->lpVtbl -> get_DataStoreMajorVersion(This,retval)

#define ICatalogCollection_get_DataStoreMinorVersion(This,retval)	\
    (This)->lpVtbl -> get_DataStoreMinorVersion(This,retval)

#define ICatalogCollection_PopulateByKey(This,aKeys)	\
    (This)->lpVtbl -> PopulateByKey(This,aKeys)

#define ICatalogCollection_PopulateByQuery(This,bstrQueryString,lQueryType)	\
    (This)->lpVtbl -> PopulateByQuery(This,bstrQueryString,lQueryType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get__NewEnum_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumVariant);


void __RPC_STUB ICatalogCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Item_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);


void __RPC_STUB ICatalogCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Count_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Remove_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ long lIndex);


void __RPC_STUB ICatalogCollection_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Add_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogObject);


void __RPC_STUB ICatalogCollection_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_Populate_Proxy( 
    ICatalogCollection __RPC_FAR * This);


void __RPC_STUB ICatalogCollection_Populate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_SaveChanges_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_GetCollection_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrCollName,
    /* [in] */ VARIANT varObjectKey,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalogCollection_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_Name_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_AddEnabled_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_AddEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_RemoveEnabled_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_RemoveEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_GetUtilInterface_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppUtil);


void __RPC_STUB ICatalogCollection_GetUtilInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_DataStoreMajorVersion_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_DataStoreMajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_get_DataStoreMinorVersion_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalogCollection_get_DataStoreMinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_PopulateByKey_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * aKeys);


void __RPC_STUB ICatalogCollection_PopulateByKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalogCollection_PopulateByQuery_Proxy( 
    ICatalogCollection __RPC_FAR * This,
    /* [in] */ BSTR bstrQueryString,
    /* [in] */ long lQueryType);


void __RPC_STUB ICatalogCollection_PopulateByQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogCollection_INTERFACE_DEFINED__ */


#ifndef __IComponentUtil_INTERFACE_DEFINED__
#define __IComponentUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IComponentUtil
 * at Fri Nov 14 05:07:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22873-8a19-11d0-81b6-00a0c9231c29")
    IComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallComponent( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponent( 
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponentByName( 
            /* [in] */ BSTR bstrProgID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCLSIDs( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponentByName )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDs )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);
        
        END_INTERFACE
    } IComponentUtilVtbl;

    interface IComponentUtil
    {
        CONST_VTBL struct IComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IComponentUtil_InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)	\
    (This)->lpVtbl -> InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)

#define IComponentUtil_ImportComponent(This,bstrCLSID)	\
    (This)->lpVtbl -> ImportComponent(This,bstrCLSID)

#define IComponentUtil_ImportComponentByName(This,bstrProgID)	\
    (This)->lpVtbl -> ImportComponentByName(This,bstrProgID)

#define IComponentUtil_GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)	\
    (This)->lpVtbl -> GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_InstallComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [in] */ BSTR bstrProxyStubDLLFile);


void __RPC_STUB IComponentUtil_InstallComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IComponentUtil_ImportComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponentByName_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IComponentUtil_ImportComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_GetCLSIDs_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);


void __RPC_STUB IComponentUtil_GetCLSIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IPackageUtil_INTERFACE_DEFINED__
#define __IPackageUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPackageUtil
 * at Fri Nov 14 05:07:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IPackageUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22874-8a19-11d0-81b6-00a0c9231c29")
    IPackageUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallPackage( 
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportPackage( 
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShutdownPackage( 
            /* [in] */ BSTR bstrPackageID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPackageUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPackageUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPackageUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPackageUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID);
        
        END_INTERFACE
    } IPackageUtilVtbl;

    interface IPackageUtil
    {
        CONST_VTBL struct IPackageUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPackageUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPackageUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPackageUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPackageUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPackageUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPackageUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPackageUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPackageUtil_InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)	\
    (This)->lpVtbl -> InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)

#define IPackageUtil_ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)	\
    (This)->lpVtbl -> ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)

#define IPackageUtil_ShutdownPackage(This,bstrPackageID)	\
    (This)->lpVtbl -> ShutdownPackage(This,bstrPackageID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_InstallPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ BSTR bstrInstallPath,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_InstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ExportPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_ExportPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ShutdownPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID);


void __RPC_STUB IPackageUtil_ShutdownPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPackageUtil_INTERFACE_DEFINED__ */


#ifndef __IRemoteComponentUtil_INTERFACE_DEFINED__
#define __IRemoteComponentUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRemoteComponentUtil
 * at Fri Nov 14 05:07:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IRemoteComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22875-8a19-11d0-81b6-00a0c9231c29")
    IRemoteComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponent( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponentByName( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponent )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponentByName )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID);
        
        END_INTERFACE
    } IRemoteComponentUtilVtbl;

    interface IRemoteComponentUtil
    {
        CONST_VTBL struct IRemoteComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteComponentUtil_InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)	\
    (This)->lpVtbl -> InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)

#define IRemoteComponentUtil_InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)	\
    (This)->lpVtbl -> InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponent_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponentByName_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageName,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IRoleAssociationUtil_INTERFACE_DEFINED__
#define __IRoleAssociationUtil_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRoleAssociationUtil
 * at Fri Nov 14 05:07:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_IRoleAssociationUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6eb22876-8a19-11d0-81b6-00a0c9231c29")
    IRoleAssociationUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRole( 
            /* [in] */ BSTR bstrRoleID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRoleByName( 
            /* [in] */ BSTR bstrRoleName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRoleAssociationUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRole )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRoleByName )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleName);
        
        END_INTERFACE
    } IRoleAssociationUtilVtbl;

    interface IRoleAssociationUtil
    {
        CONST_VTBL struct IRoleAssociationUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRoleAssociationUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRoleAssociationUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRoleAssociationUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRoleAssociationUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRoleAssociationUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRoleAssociationUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRoleAssociationUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRoleAssociationUtil_AssociateRole(This,bstrRoleID)	\
    (This)->lpVtbl -> AssociateRole(This,bstrRoleID)

#define IRoleAssociationUtil_AssociateRoleByName(This,bstrRoleName)	\
    (This)->lpVtbl -> AssociateRoleByName(This,bstrRoleName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRole_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleID);


void __RPC_STUB IRoleAssociationUtil_AssociateRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRoleByName_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleName);


void __RPC_STUB IRoleAssociationUtil_AssociateRoleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRoleAssociationUtil_INTERFACE_DEFINED__ */



#ifndef __MTSAdmin_LIBRARY_DEFINED__
#define __MTSAdmin_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MTSAdmin
 * at Fri Nov 14 05:07:21 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 


typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0001
    {	mtsInstallUsers	= 1
    }	MTSPackageInstallOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0002
    {	mtsExportUsers	= 1
    }	MTSPackageExportOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtxadmin_0107_0003
    {	mtsErrObjectErrors	= 0x80110401,
	mtsErrObjectInvalid	= 0x80110402,
	mtsErrKeyMissing	= 0x80110403,
	mtsErrAlreadyInstalled	= 0x80110404,
	mtsErrDownloadFailed	= 0x80110405,
	mtsErrPDFWriteFail	= 0x80110407,
	mtsErrPDFReadFail	= 0x80110408,
	mtsErrPDFVersion	= 0x80110409,
	mtsErrCoReqCompInstalled	= 0x80110410,
	mtsErrBadPath	= 0x8011040a,
	mtsErrPackageExists	= 0x8011040b,
	mtsErrRoleExists	= 0x8011040c,
	mtsErrCantCopyFile	= 0x8011040d,
	mtsErrNoTypeLib	= 0x8011040e,
	mtsErrNoUser	= 0x8011040f,
	mtsErrInvalidUserids	= 0x80110410,
	mtsErrNoRegistryCLSID	= 0x80110411,
	mtsErrBadRegistryProgID	= 0x80110412,
	mtsErrAuthenticationLevel	= 0x80110413,
	mtsErrUserPasswdNotValid	= 0x80110414,
	mtsErrNoRegistryRead	= 0x80110415,
	mtsErrNoRegistryWrite	= 0x80110416,
	mtsErrNoRegistryRepair	= 0x80110417,
	mtsErrCLSIDOrIIDMismatch	= 0x80110418,
	mtsErrRemoteInterface	= 0x80110419,
	mtsErrDllRegisterServer	= 0x8011041a,
	mtsErrNoServerShare	= 0x8011041b,
	mtsErrNoAccessToUNC	= 0x8011041c,
	mtsErrDllLoadFailed	= 0x8011041d,
	mtsErrBadRegistryLibID	= 0x8011041e,
	mtsErrPackDirNotFound	= 0x8011041f,
	mtsErrTreatAs	= 0x80110420,
	mtsErrBadForward	= 0x80110421,
	mtsErrBadIID	= 0x80110422,
	mtsErrRegistrarFailed	= 0x80110423,
	mtsErrCompFileDoesNotExist	= 0x80110424,
	mtsErrCompFileLoadDLLFail	= 0x80110425,
	mtsErrCompFileGetClassObj	= 0x80110426,
	mtsErrCompFileClassNotAvail	= 0x80110427,
	mtsErrCompFileBadTLB	= 0x80110428,
	mtsErrCompFileNotInstallable	= 0x80110429,
	mtsErrNotChangeable	= 0x8011042a,
	mtsErrNotDeletable	= 0x8011042b,
	mtsErrSession	= 0x8011042c,
	mtsErrCompFileNoRegistrar	= 0x80110434
    }	MTSAdminErrorCodes;

#define E_MTS_OBJECTERRORS			 	mtsErrObjectErrors				
#define E_MTS_OBJECTINVALID				mtsErrObjectInvalid				
#define E_MTS_KEYMISSING				mtsErrKeyMissing				
#define E_MTS_ALREADYINSTALLED			mtsErrAlreadyInstalled			
#define E_MTS_DOWNLOADFAILED			mtsErrDownloadFailed			
#define E_MTS_PDFWRITEFAIL				mtsErrPDFWriteFail				
#define E_MTS_PDFREADFAIL				mtsErrPDFReadFail				
#define E_MTS_PDFVERSION				mtsErrPDFVersion				
#define E_MTS_COREQCOMPINSTALLED		mtsErrCoReqCompInstalled		
#define E_MTS_BADPATH					mtsErrBadPath					
#define E_MTS_PACKAGEEXISTS				mtsErrPackageExists				
#define E_MTS_ROLEEXISTS				mtsErrRoleExists				
#define E_MTS_CANTCOPYFILE				mtsErrCantCopyFile				
#define E_MTS_NOTYPELIB					mtsErrNoTypeLib					
#define E_MTS_NOUSER					mtsErrNoUser					
#define E_MTS_INVALIDUSERIDS			mtsErrInvalidUserids			
#define E_MTS_NOREGISTRYCLSID			mtsErrNoRegistryCLSID			
#define E_MTS_BADREGISTRYPROGID			mtsErrBadRegistryProgID			
#define E_MTS_AUTHENTICATIONLEVEL		mtsErrAuthenticationLevel		
#define E_MTS_USERPASSWDNOTVALID		mtsErrUserPasswdNotValid		
#define E_MTS_NOREGISTRYREAD			mtsErrNoRegistryRead			
#define E_MTS_NOREGISTRYWRITE			mtsErrNoRegistryWrite			
#define E_MTS_NOREGISTRYREPAIR			mtsErrNoRegistryRepair			
#define E_MTS_CLSIDORIIDMISMATCH		mtsErrCLSIDOrIIDMismatch		
#define E_MTS_REMOTEINTERFACE			mtsErrRemoteInterface			
#define E_MTS_DLLREGISTERSERVER			mtsErrDllRegisterServer			
#define E_MTS_NOSERVERSHARE				mtsErrNoServerShare				
#define E_MTS_NOACCESSTOUNC				mtsErrNoAccessToUNC				
#define E_MTS_DLLLOADFAILED				mtsErrDllLoadFailed				
#define E_MTS_BADREGISTRYLIBID			mtsErrBadRegistryLibID			
#define E_MTS_PACKDIRNOTFOUND			mtsErrPackDirNotFound			
#define E_MTS_TREATAS					mtsErrTreatAs					
#define E_MTS_BADFORWARD				mtsErrBadForward				
#define E_MTS_BADIID					mtsErrBadIID					
#define E_MTS_REGISTRARFAILED			mtsErrRegistrarFailed			
#define E_MTS_COMPFILE_DOESNOTEXIST		mtsErrCompFileDoesNotExist		
#define E_MTS_COMPFILE_LOADDLLFAIL		mtsErrCompFileLoadDLLFail		
#define E_MTS_COMPFILE_GETCLASSOBJ		mtsErrCompFileGetClassObj		
#define E_MTS_COMPFILE_CLASSNOTAVAIL	mtsErrCompFileClassNotAvail		
#define E_MTS_COMPFILE_BADTLB			mtsErrCompFileBadTLB			
#define E_MTS_COMPFILE_NOTINSTALLABLE	mtsErrCompFileNotInstallable	
#define E_MTS_NOTCHANGEABLE				mtsErrNotChangeable				
#define E_MTS_NOTDELETEABLE				mtsErrNotDeleteable				
#define E_MTS_SESSION					mtsErrSession					
#define E_MTS_COMPFILE_NOREGISTRAR		mtsErrCompFileNoRegistrar		

EXTERN_C const IID LIBID_MTSAdmin;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Catalog;

class DECLSPEC_UUID("6eb22881-8a19-11d0-81b6-00a0c9231c29")
Catalog;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CatalogObject;

class DECLSPEC_UUID("6eb22882-8a19-11d0-81b6-00a0c9231c29")
CatalogObject;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CatalogCollection;

class DECLSPEC_UUID("6eb22883-8a19-11d0-81b6-00a0c9231c29")
CatalogCollection;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_ComponentUtil;

class DECLSPEC_UUID("6eb22884-8a19-11d0-81b6-00a0c9231c29")
ComponentUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_PackageUtil;

class DECLSPEC_UUID("6eb22885-8a19-11d0-81b6-00a0c9231c29")
PackageUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RemoteComponentUtil;

class DECLSPEC_UUID("6eb22886-8a19-11d0-81b6-00a0c9231c29")
RemoteComponentUtil;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_RoleAssociationUtil;

class DECLSPEC_UUID("6eb22887-8a19-11d0-81b6-00a0c9231c29")
RoleAssociationUtil;
#endif
#endif /* __MTSAdmin_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Mtxdm.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.

#ifndef __MTXDM_H__
#define __MTXDM_H__

// mtxdm.h
// Defines legacy mtxdm startup interface, remove asap, when all dispensers stop doing this.
// New stuff is in ccpublic.idl and dispman.idl

#include "comsvcs.h"

#ifdef __cplusplus
extern "C"{
#endif 

//
// GetDispenserManager
// A Dispenser calls this API to get a reference to DispenserManager.
//
__declspec(dllimport) HRESULT __cdecl GetDispenserManager(IDispenserManager**);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MtxAttr.h ===
#ifndef _MTXATTR_H_
#define _MTXATTR_H_

// -----------------------------------------------------------------------
// mtxattr.h  -- Microsoft Transaction Server Custom Properties                 
//                                                                                                                                              
// This file is the IDL include for Microsoft Transaction Server                
// custom typelib properties.                                                                                   
//                                                                                                                                              
// COM+ 1.0                                                                             
// Copyright (c) 1996-1998 Microsoft Corporation.  All Rights Reserved. 
// -----------------------------------------------------------------------  

//======================================================================================
// Component attributes
//======================================================================================

#define         TLBATTR_TRANS_REQUIRED  17093CC5-9BD2-11cf-AA4F-304BF89C0001
#define         TLBATTR_TRANS_NOTSUPP   17093CC6-9BD2-11cf-AA4F-304BF89C0001
#define         TLBATTR_TRANS_REQNEW    17093CC7-9BD2-11cf-AA4F-304BF89C0001
#define         TLBATTR_TRANS_SUPPORTED 17093CC8-9BD2-11cf-AA4F-304BF89C0001
#define         TLBATTR_QUEUEABLE       E5FC3761-0BBA-11d2-B8FE-00C04FC340EE
#define         TLBATTR_COMTI_INTRINSICS 47065EDC-D7FE-4B03-919C-C4A50B749605

//======================================================================================
// Component attribute MACROS
//======================================================================================

#define TRANSACTION_REQUIRED            custom(TLBATTR_TRANS_REQUIRED,0)
#define TRANSACTION_SUPPORTED           custom(TLBATTR_TRANS_SUPPORTED,0)
#define TRANSACTION_NOT_SUPPORTED       custom(TLBATTR_TRANS_NOTSUPP,0)
#define TRANSACTION_REQUIRES_NEW        custom(TLBATTR_TRANS_REQNEW,0)
#define QUEUEABLE                       custom(TLBATTR_QUEUEABLE, 0)
#define COMTI_INTRINSICS_ENABLED        custom(TLBATTR_COMTI_INTRINSICS, 0)

#endif _MTXATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MtsAdmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0158 */
/* at Thu Mar 11 18:35:18 1999
 */
/* Compiler settings for mtsadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mtsadmin_h__
#define __mtsadmin_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICatalog_FWD_DEFINED__
#define __ICatalog_FWD_DEFINED__
typedef interface ICatalog ICatalog;
#endif 	/* __ICatalog_FWD_DEFINED__ */


#ifndef __IComponentUtil_FWD_DEFINED__
#define __IComponentUtil_FWD_DEFINED__
typedef interface IComponentUtil IComponentUtil;
#endif 	/* __IComponentUtil_FWD_DEFINED__ */


#ifndef __IPackageUtil_FWD_DEFINED__
#define __IPackageUtil_FWD_DEFINED__
typedef interface IPackageUtil IPackageUtil;
#endif 	/* __IPackageUtil_FWD_DEFINED__ */


#ifndef __IRemoteComponentUtil_FWD_DEFINED__
#define __IRemoteComponentUtil_FWD_DEFINED__
typedef interface IRemoteComponentUtil IRemoteComponentUtil;
#endif 	/* __IRemoteComponentUtil_FWD_DEFINED__ */


#ifndef __IRoleAssociationUtil_FWD_DEFINED__
#define __IRoleAssociationUtil_FWD_DEFINED__
typedef interface IRoleAssociationUtil IRoleAssociationUtil;
#endif 	/* __IRoleAssociationUtil_FWD_DEFINED__ */


#ifndef __Catalog_FWD_DEFINED__
#define __Catalog_FWD_DEFINED__

#ifdef __cplusplus
typedef class Catalog Catalog;
#else
typedef struct Catalog Catalog;
#endif /* __cplusplus */

#endif 	/* __Catalog_FWD_DEFINED__ */


#ifndef __CatalogObject_FWD_DEFINED__
#define __CatalogObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogObject CatalogObject;
#else
typedef struct CatalogObject CatalogObject;
#endif /* __cplusplus */

#endif 	/* __CatalogObject_FWD_DEFINED__ */


#ifndef __CatalogCollection_FWD_DEFINED__
#define __CatalogCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class CatalogCollection CatalogCollection;
#else
typedef struct CatalogCollection CatalogCollection;
#endif /* __cplusplus */

#endif 	/* __CatalogCollection_FWD_DEFINED__ */


#ifndef __ComponentUtil_FWD_DEFINED__
#define __ComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComponentUtil ComponentUtil;
#else
typedef struct ComponentUtil ComponentUtil;
#endif /* __cplusplus */

#endif 	/* __ComponentUtil_FWD_DEFINED__ */


#ifndef __PackageUtil_FWD_DEFINED__
#define __PackageUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class PackageUtil PackageUtil;
#else
typedef struct PackageUtil PackageUtil;
#endif /* __cplusplus */

#endif 	/* __PackageUtil_FWD_DEFINED__ */


#ifndef __RemoteComponentUtil_FWD_DEFINED__
#define __RemoteComponentUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteComponentUtil RemoteComponentUtil;
#else
typedef struct RemoteComponentUtil RemoteComponentUtil;
#endif /* __cplusplus */

#endif 	/* __RemoteComponentUtil_FWD_DEFINED__ */


#ifndef __RoleAssociationUtil_FWD_DEFINED__
#define __RoleAssociationUtil_FWD_DEFINED__

#ifdef __cplusplus
typedef class RoleAssociationUtil RoleAssociationUtil;
#else
typedef struct RoleAssociationUtil RoleAssociationUtil;
#endif /* __cplusplus */

#endif 	/* __RoleAssociationUtil_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "comadmin.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_mtsadmin_0000 */
/* [local] */ 

// -----------------------------------------------------------------------	
// mtsadmin.h  -- COM (MTS Compatible) Administration Programming Interfaces 
//																			
// This file provides the prototypes for the APIs and COM interfaces			
// used by Microsoft Transaction Server applications.						
//																			
// Copyright (c) Microsoft Corporation. All rights reserved.
// -----------------------------------------------------------------------	
#include <objbase.h>
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_mtsadmin_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mtsadmin_0000_v0_0_s_ifspec;

#ifndef __ICatalog_INTERFACE_DEFINED__
#define __ICatalog_INTERFACE_DEFINED__

/* interface ICatalog */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICatalog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22870-8a19-11d0-81b6-00a0c9231c29")
    ICatalog : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion( 
            /* [retval][out] */ long __RPC_FAR *retval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatalog __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatalog __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICatalog __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCollection )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrCollName,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            ICatalog __RPC_FAR * This,
            /* [in] */ BSTR bstrConnectString,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MajorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinorVersion )( 
            ICatalog __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *retval);
        
        END_INTERFACE
    } ICatalogVtbl;

    interface ICatalog
    {
        CONST_VTBL struct ICatalogVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICatalog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICatalog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICatalog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICatalog_GetCollection(This,bstrCollName,ppCatalogCollection)	\
    (This)->lpVtbl -> GetCollection(This,bstrCollName,ppCatalogCollection)

#define ICatalog_Connect(This,bstrConnectString,ppCatalogCollection)	\
    (This)->lpVtbl -> Connect(This,bstrConnectString,ppCatalogCollection)

#define ICatalog_get_MajorVersion(This,retval)	\
    (This)->lpVtbl -> get_MajorVersion(This,retval)

#define ICatalog_get_MinorVersion(This,retval)	\
    (This)->lpVtbl -> get_MinorVersion(This,retval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_GetCollection_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrCollName,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICatalog_Connect_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [in] */ BSTR bstrConnectString,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppCatalogCollection);


void __RPC_STUB ICatalog_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MajorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICatalog_get_MinorVersion_Proxy( 
    ICatalog __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *retval);


void __RPC_STUB ICatalog_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalog_INTERFACE_DEFINED__ */


#ifndef __IComponentUtil_INTERFACE_DEFINED__
#define __IComponentUtil_INTERFACE_DEFINED__

/* interface IComponentUtil */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22873-8a19-11d0-81b6-00a0c9231c29")
    IComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallComponent( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponent( 
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportComponentByName( 
            /* [in] */ BSTR bstrProgID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCLSIDs( 
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [in] */ BSTR bstrProxyStubDLLFile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponent )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImportComponentByName )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDs )( 
            IComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrDLLFile,
            /* [in] */ BSTR bstrTypelibFile,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);
        
        END_INTERFACE
    } IComponentUtilVtbl;

    interface IComponentUtil
    {
        CONST_VTBL struct IComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IComponentUtil_InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)	\
    (This)->lpVtbl -> InstallComponent(This,bstrDLLFile,bstrTypelibFile,bstrProxyStubDLLFile)

#define IComponentUtil_ImportComponent(This,bstrCLSID)	\
    (This)->lpVtbl -> ImportComponent(This,bstrCLSID)

#define IComponentUtil_ImportComponentByName(This,bstrProgID)	\
    (This)->lpVtbl -> ImportComponentByName(This,bstrProgID)

#define IComponentUtil_GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)	\
    (This)->lpVtbl -> GetCLSIDs(This,bstrDLLFile,bstrTypelibFile,aCLSIDs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_InstallComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [in] */ BSTR bstrProxyStubDLLFile);


void __RPC_STUB IComponentUtil_InstallComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponent_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IComponentUtil_ImportComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_ImportComponentByName_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IComponentUtil_ImportComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IComponentUtil_GetCLSIDs_Proxy( 
    IComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrDLLFile,
    /* [in] */ BSTR bstrTypelibFile,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *aCLSIDs);


void __RPC_STUB IComponentUtil_GetCLSIDs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IPackageUtil_INTERFACE_DEFINED__
#define __IPackageUtil_INTERFACE_DEFINED__

/* interface IPackageUtil */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPackageUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22874-8a19-11d0-81b6-00a0c9231c29")
    IPackageUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallPackage( 
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExportPackage( 
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShutdownPackage( 
            /* [in] */ BSTR bstrPackageID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPackageUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPackageUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPackageUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IPackageUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ BSTR bstrInstallPath,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExportPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrPackageFile,
            /* [in] */ long lOptions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownPackage )( 
            IPackageUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrPackageID);
        
        END_INTERFACE
    } IPackageUtilVtbl;

    interface IPackageUtil
    {
        CONST_VTBL struct IPackageUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPackageUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPackageUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPackageUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPackageUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPackageUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPackageUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPackageUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPackageUtil_InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)	\
    (This)->lpVtbl -> InstallPackage(This,bstrPackageFile,bstrInstallPath,lOptions)

#define IPackageUtil_ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)	\
    (This)->lpVtbl -> ExportPackage(This,bstrPackageID,bstrPackageFile,lOptions)

#define IPackageUtil_ShutdownPackage(This,bstrPackageID)	\
    (This)->lpVtbl -> ShutdownPackage(This,bstrPackageID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_InstallPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ BSTR bstrInstallPath,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_InstallPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ExportPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrPackageFile,
    /* [in] */ long lOptions);


void __RPC_STUB IPackageUtil_ExportPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPackageUtil_ShutdownPackage_Proxy( 
    IPackageUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrPackageID);


void __RPC_STUB IPackageUtil_ShutdownPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPackageUtil_INTERFACE_DEFINED__ */


#ifndef __IRemoteComponentUtil_INTERFACE_DEFINED__
#define __IRemoteComponentUtil_INTERFACE_DEFINED__

/* interface IRemoteComponentUtil */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRemoteComponentUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22875-8a19-11d0-81b6-00a0c9231c29")
    IRemoteComponentUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponent( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InstallRemoteComponentByName( 
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteComponentUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteComponentUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponent )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageID,
            /* [in] */ BSTR bstrCLSID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallRemoteComponentByName )( 
            IRemoteComponentUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrServer,
            /* [in] */ BSTR bstrPackageName,
            /* [in] */ BSTR bstrProgID);
        
        END_INTERFACE
    } IRemoteComponentUtilVtbl;

    interface IRemoteComponentUtil
    {
        CONST_VTBL struct IRemoteComponentUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteComponentUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteComponentUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteComponentUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteComponentUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteComponentUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteComponentUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteComponentUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteComponentUtil_InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)	\
    (This)->lpVtbl -> InstallRemoteComponent(This,bstrServer,bstrPackageID,bstrCLSID)

#define IRemoteComponentUtil_InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)	\
    (This)->lpVtbl -> InstallRemoteComponentByName(This,bstrServer,bstrPackageName,bstrProgID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponent_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageID,
    /* [in] */ BSTR bstrCLSID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteComponentUtil_InstallRemoteComponentByName_Proxy( 
    IRemoteComponentUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrServer,
    /* [in] */ BSTR bstrPackageName,
    /* [in] */ BSTR bstrProgID);


void __RPC_STUB IRemoteComponentUtil_InstallRemoteComponentByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteComponentUtil_INTERFACE_DEFINED__ */


#ifndef __IRoleAssociationUtil_INTERFACE_DEFINED__
#define __IRoleAssociationUtil_INTERFACE_DEFINED__

/* interface IRoleAssociationUtil */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRoleAssociationUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eb22876-8a19-11d0-81b6-00a0c9231c29")
    IRoleAssociationUtil : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRole( 
            /* [in] */ BSTR bstrRoleID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssociateRoleByName( 
            /* [in] */ BSTR bstrRoleName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRoleAssociationUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRoleAssociationUtil __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRole )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateRoleByName )( 
            IRoleAssociationUtil __RPC_FAR * This,
            /* [in] */ BSTR bstrRoleName);
        
        END_INTERFACE
    } IRoleAssociationUtilVtbl;

    interface IRoleAssociationUtil
    {
        CONST_VTBL struct IRoleAssociationUtilVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRoleAssociationUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRoleAssociationUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRoleAssociationUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRoleAssociationUtil_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRoleAssociationUtil_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRoleAssociationUtil_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRoleAssociationUtil_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRoleAssociationUtil_AssociateRole(This,bstrRoleID)	\
    (This)->lpVtbl -> AssociateRole(This,bstrRoleID)

#define IRoleAssociationUtil_AssociateRoleByName(This,bstrRoleName)	\
    (This)->lpVtbl -> AssociateRoleByName(This,bstrRoleName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRole_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleID);


void __RPC_STUB IRoleAssociationUtil_AssociateRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRoleAssociationUtil_AssociateRoleByName_Proxy( 
    IRoleAssociationUtil __RPC_FAR * This,
    /* [in] */ BSTR bstrRoleName);


void __RPC_STUB IRoleAssociationUtil_AssociateRoleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRoleAssociationUtil_INTERFACE_DEFINED__ */



#ifndef __MTSAdmin_LIBRARY_DEFINED__
#define __MTSAdmin_LIBRARY_DEFINED__

/* library MTSAdmin */
/* [helpstring][version][uuid] */ 

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtsadmin_0123_0001
    {	mtsInstallUsers	= 1
    }	MTSPackageInstallOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtsadmin_0123_0002
    {	mtsExportUsers	= 1
    }	MTSPackageExportOptions;

typedef /* [public][helpstring] */ 
enum __MIDL___MIDL_itf_mtsadmin_0123_0003
    {	mtsErrObjectErrors	= ( HRESULT  )0x80110401L,
	mtsErrObjectInvalid	= ( HRESULT  )0x80110402L,
	mtsErrKeyMissing	= ( HRESULT  )0x80110403L,
	mtsErrAlreadyInstalled	= ( HRESULT  )0x80110404L,
	mtsErrDownloadFailed	= 0x80110405,
	mtsErrPDFWriteFail	= ( HRESULT  )0x80110407L,
	mtsErrPDFReadFail	= ( HRESULT  )0x80110408L,
	mtsErrPDFVersion	= ( HRESULT  )0x80110409L,
	mtsErrBadPath	= ( HRESULT  )0x8011040aL,
	mtsErrPackageExists	= ( HRESULT  )0x8011040bL,
	mtsErrRoleExists	= ( HRESULT  )0x8011040cL,
	mtsErrCantCopyFile	= ( HRESULT  )0x8011040dL,
	mtsErrNoTypeLib	= 0x8011040e,
	mtsErrNoUser	= ( HRESULT  )0x8011040fL,
	mtsErrInvalidUserids	= ( HRESULT  )0x80110410L,
	mtsErrNoRegistryCLSID	= ( HRESULT  )0x80110411L,
	mtsErrBadRegistryProgID	= ( HRESULT  )0x80110412L,
	mtsErrAuthenticationLevel	= ( HRESULT  )0x80110413L,
	mtsErrUserPasswdNotValid	= ( HRESULT  )0x80110414L,
	mtsErrNoRegistryRead	= 0x80110415,
	mtsErrNoRegistryWrite	= 0x80110416,
	mtsErrNoRegistryRepair	= 0x80110417,
	mtsErrCLSIDOrIIDMismatch	= ( HRESULT  )0x80110418L,
	mtsErrRemoteInterface	= ( HRESULT  )0x80110419L,
	mtsErrDllRegisterServer	= ( HRESULT  )0x8011041aL,
	mtsErrNoServerShare	= ( HRESULT  )0x8011041bL,
	mtsErrNoAccessToUNC	= 0x8011041c,
	mtsErrDllLoadFailed	= ( HRESULT  )0x8011041dL,
	mtsErrBadRegistryLibID	= ( HRESULT  )0x8011041eL,
	mtsErrPackDirNotFound	= ( HRESULT  )0x8011041fL,
	mtsErrTreatAs	= 0x80110420,
	mtsErrBadForward	= 0x80110421,
	mtsErrBadIID	= 0x80110422,
	mtsErrRegistrarFailed	= ( HRESULT  )0x80110423L,
	mtsErrCompFileDoesNotExist	= ( HRESULT  )0x80110424L,
	mtsErrCompFileLoadDLLFail	= ( HRESULT  )0x80110425L,
	mtsErrCompFileGetClassObj	= ( HRESULT  )0x80110426L,
	mtsErrCompFileClassNotAvail	= ( HRESULT  )0x80110427L,
	mtsErrCompFileBadTLB	= ( HRESULT  )0x80110428L,
	mtsErrCompFileNotInstallable	= ( HRESULT  )0x80110429L,
	mtsErrNotChangeable	= ( HRESULT  )0x8011042aL,
	mtsErrNotDeletable	= ( HRESULT  )0x8011042bL,
	mtsErrSession	= ( HRESULT  )0x8011042cL,
	mtsErrCompMoveLocked	= ( HRESULT  )0x8011042dL,
	mtsErrCompMoveBadDest	= ( HRESULT  )0x8011042eL,
	mtsErrRegisterTLB	= ( HRESULT  )0x80110430L,
	mtsErrSystemPack	= ( HRESULT  )0x80110433L,
	mtsErrCompFileNoRegistrar	= ( HRESULT  )0x80110434L,
	mtsErrCoReqCompInstalled	= ( HRESULT  )0x80110435L,
	mtsErrPropSaveFailed	= ( HRESULT  )0x80110437L,
	mtsErrObjectExists	= ( HRESULT  )0x80110438L,
	mtsErrRegFileCorrupt	= ( HRESULT  )0x8011043bL,
	mtsErrPropertyOverflow	= ( HRESULT  )0x8011043cL,
	mtsErrNotInRegistry	= ( HRESULT  )0x8011043eL,
	mtsErrApplidMatchesClsid	= ( HRESULT  )0x80110446L,
	mtsErrRoleDoesNotExist	= ( HRESULT  )0x80110447L,
	mtsErrObjectParentMissing	= ( HRESULT  )0x80110808L,
	mtsErrObjectDoesNotExist	= ( HRESULT  )0x80110809L,
	mtsErrCanNotExportAppProxy	= 0x8011044a,
	mtsErrCanNotExportSystemPack	= 0x8011044c
    }	;

#define E_MTS_OBJECTERRORS		 mtsErrObjectErrors 
#define E_MTS_OBJECTINVALID		 mtsErrObjectInvalid 
#define E_MTS_KEYMISSING		 mtsErrKeyMissing 
#define E_MTS_ALREADYINSTALLED		 mtsErrAlreadyInstalled 
#define E_MTS_DOWNLOADFAILED		 mtsErrDownloadFailed 
#define E_MTS_PDFWRITEFAIL		 mtsErrPDFWriteFail 
#define E_MTS_PDFREADFAIL		 mtsErrPDFReadFail 
#define E_MTS_PDFVERSION		 mtsErrPDFVersion 
#define E_MTS_BADPATH		 mtsErrBadPath 
#define E_MTS_PACKAGEEXISTS		 mtsErrPackageExists 
#define E_MTS_ROLEEXISTS		 mtsErrRoleExists 
#define E_MTS_CANTCOPYFILE		 mtsErrCantCopyFile 
#define E_MTS_NOTYPELIB		 mtsErrNoTypeLib 
#define E_MTS_NOUSER		 mtsErrNoUser 
#define E_MTS_INVALIDUSERIDS		 mtsErrInvalidUserids 
#define E_MTS_NOREGISTRYCLSID		 mtsErrNoRegistryCLSID 
#define E_MTS_BADREGISTRYPROGID		 mtsErrBadRegistryProgID 
#define E_MTS_AUTHENTICATIONLEVEL		 mtsErrAuthenticationLevel 
#define E_MTS_USERPASSWDNOTVALID		 mtsErrUserPasswdNotValid 
#define E_MTS_NOREGISTRYREAD		 mtsErrNoRegistryRead 
#define E_MTS_NOREGISTRYWRITE		 mtsErrNoRegistryWrite 
#define E_MTS_NOREGISTRYREPAIR		 mtsErrNoRegistryRepair 
#define E_MTS_CLSIDORIIDMISMATCH		 mtsErrCLSIDOrIIDMismatch 
#define E_MTS_REMOTEINTERFACE		 mtsErrRemoteInterface 
#define E_MTS_DLLREGISTERSERVER		 mtsErrDllRegisterServer 
#define E_MTS_NOSERVERSHARE		 mtsErrNoServerShare 
#define E_MTS_NOACCESSTOUNC		 mtsErrNoAccessToUNC 
#define E_MTS_DLLLOADFAILED		 mtsErrDllLoadFailed 
#define E_MTS_BADREGISTRYLIBID		 mtsErrBadRegistryLibID 
#define E_MTS_PACKDIRNOTFOUND		 mtsErrPackDirNotFound 
#define E_MTS_TREATAS		 mtsErrTreatAs 
#define E_MTS_BADFORWARD		 mtsErrBadForward 
#define E_MTS_BADIID		 mtsErrBadIID 
#define E_MTS_REGISTRARFAILED		 mtsErrRegistrarFailed 
#define E_MTS_COMPFILE_DOESNOTEXIST		 mtsErrCompFileDoesNotExist 
#define E_MTS_COMPFILE_LOADDLLFAIL		 mtsErrCompFileLoadDLLFail 
#define E_MTS_COMPFILE_GETCLASSOBJ		 mtsErrCompFileGetClassObj 
#define E_MTS_COMPFILE_CLASSNOTAVAIL		 mtsErrCompFileClassNotAvail 
#define E_MTS_COMPFILE_BADTLB		 mtsErrCompFileBadTLB 
#define E_MTS_COMPFILE_NOTINSTALLABLE		 mtsErrCompFileNotInstallable 
#define E_MTS_NOTCHANGEABLE		 mtsErrNotChangeable 
#define E_MTS_NOTDELETEABLE		 mtsErrNotDeletable 
#define E_MTS_SESSION		 mtsErrSession 
#define E_MTS_COMP_MOVE_LOCKED		 mtsErrCompMoveLocked 
#define E_MTS_COMP_MOVE_BAD_DEST		 mtsErrCompMoveBadDest 
#define E_MTS_REGISTERTLB		 mtsErrRegisterTLB 
#define E_MTS_SYSTEMPACK		 mtsErrSystemPack 
#define E_MTS_COMPFILE_NOREGISTRAR		 mtsErrCompFileNoRegistrar 
#define E_MTS_COREQCOMPINSTALLED		 mtsErrCoReqCompInstalled 
#define E_MTS_PROPERTYSAVEFAILED		 mtsErrPropSaveFailed 
#define E_MTS_OBJECTEXISTS		 mtsErrObjectExists 
#define E_MTS_REGFILE_CORRUPT		 mtsErrRegFileCorrupt 
#define E_MTS_PROPERTY_OVERFLOW		 mtsErrPropertyOverflow 
#define E_MTS_NOTINREGISTRY		 mtsErrNotInRegistry 
#define E_MTS_APPLID_MATCHES_CLSID		 mtsErrApplidMatchesClsid 
#define E_MTS_ROLE_DOES_NOT_EXIST		 mtsErrRoleDoesNotExist 
#define E_MTS_OBJECT_PARENT_MISSING		 mtsErrObjectParentMissing 
#define E_MTS_OBJECT_DOES_NOT_EXIST		 mtsErrObjectDoesNotExist 
#define E_MTS_CAN_NOT_EXPORT_APP_PROXY   mtsErrCanNotExportAppProxy	
#define E_MTS_CAN_NOT_EXPORT_SYSTEM_PACK   mtsErrCanNotExportSystemPack

EXTERN_C const IID LIBID_MTSAdmin;

EXTERN_C const CLSID CLSID_Catalog;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22881-8a19-11d0-81b6-00a0c9231c29")
Catalog;
#endif

EXTERN_C const CLSID CLSID_CatalogObject;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22882-8a19-11d0-81b6-00a0c9231c29")
CatalogObject;
#endif

EXTERN_C const CLSID CLSID_CatalogCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22883-8a19-11d0-81b6-00a0c9231c29")
CatalogCollection;
#endif

EXTERN_C const CLSID CLSID_ComponentUtil;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22884-8a19-11d0-81b6-00a0c9231c29")
ComponentUtil;
#endif

EXTERN_C const CLSID CLSID_PackageUtil;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22885-8a19-11d0-81b6-00a0c9231c29")
PackageUtil;
#endif

EXTERN_C const CLSID CLSID_RemoteComponentUtil;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22886-8a19-11d0-81b6-00a0c9231c29")
RemoteComponentUtil;
#endif

EXTERN_C const CLSID CLSID_RoleAssociationUtil;

#ifdef __cplusplus

class DECLSPEC_UUID("6eb22887-8a19-11d0-81b6-00a0c9231c29")
RoleAssociationUtil;
#endif
#endif /* __MTSAdmin_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MultInfo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Mar 29 16:59:57 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __multinfo_h__
#define __multinfo_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideClassInfo_FWD_DEFINED__
#define __IProvideClassInfo_FWD_DEFINED__
typedef interface IProvideClassInfo IProvideClassInfo;
#endif 	/* __IProvideClassInfo_FWD_DEFINED__ */


#ifndef __IProvideClassInfo2_FWD_DEFINED__
#define __IProvideClassInfo2_FWD_DEFINED__
typedef interface IProvideClassInfo2 IProvideClassInfo2;
#endif 	/* __IProvideClassInfo2_FWD_DEFINED__ */


#ifndef __IProvideMultipleClassInfo_FWD_DEFINED__
#define __IProvideMultipleClassInfo_FWD_DEFINED__
typedef interface IProvideMultipleClassInfo IProvideMultipleClassInfo;
#endif 	/* __IProvideMultipleClassInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#ifndef _OLECTL_H_
#include <olectl.h>
#endif

// {A7ABA9C1-8983-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IProvideMultipleClassInfo,
0xa7aba9c1, 0x8983, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);


extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_s_ifspec;

#ifndef __IProvideMultipleClassInfo_INTERFACE_DEFINED__
#define __IProvideMultipleClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideMultipleClassInfo
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


#define MULTICLASSINFO_GETTYPEINFO           0x00000001
#define MULTICLASSINFO_GETNUMRESERVEDDISPIDS 0x00000002
#define MULTICLASSINFO_GETIIDPRIMARY         0x00000004
#define MULTICLASSINFO_GETIIDSOURCE          0x00000008
#define TIFLAGS_EXTENDDISPATCHONLY           0x00000001

EXTERN_C const IID IID_IProvideMultipleClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideMultipleClassInfo : public IProvideClassInfo2
    {
    public:
        virtual HRESULT __stdcall GetMultiTypeInfoCount( 
            /* [out] */ ULONG __RPC_FAR *pcti) = 0;
        
        virtual HRESULT __stdcall GetInfoOfIndex( 
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideMultipleClassInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfo )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUID )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( __stdcall __RPC_FAR *GetMultiTypeInfoCount )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcti);
        
        HRESULT ( __stdcall __RPC_FAR *GetInfoOfIndex )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource);
        
    } IProvideMultipleClassInfoVtbl;

    interface IProvideMultipleClassInfo
    {
        CONST_VTBL struct IProvideMultipleClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideMultipleClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideMultipleClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideMultipleClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideMultipleClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideMultipleClassInfo_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)


#define IProvideMultipleClassInfo_GetMultiTypeInfoCount(This,pcti)	\
    (This)->lpVtbl -> GetMultiTypeInfoCount(This,pcti)

#define IProvideMultipleClassInfo_GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)	\
    (This)->lpVtbl -> GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideMultipleClassInfo_GetMultiTypeInfoCount_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcti);


void __RPC_STUB IProvideMultipleClassInfo_GetMultiTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IProvideMultipleClassInfo_GetInfoOfIndex_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [in] */ ULONG iti,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
    /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
    /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
    /* [out] */ IID __RPC_FAR *piidPrimary,
    /* [out] */ IID __RPC_FAR *piidSource);


void __RPC_STUB IProvideMultipleClassInfo_GetInfoOfIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideMultipleClassInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\naperror.h ===
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the NAP-specific HRESULTs.
//
////////////////////////////////////////////////////////////

#ifndef NAPERROR_H
#define NAPERROR_H

#pragma once

#define FACILITY_NAP       0x27


//
// MessageId: NAP_E_INVALID_PACKET
//
// MessageText:
//
//  The NAP SoH packet is invalid.
//
#define NAP_E_INVALID_PACKET  _HRESULT_TYPEDEF_(0x80270001L)


//
// MessageId: NAP_E_MISSING_SOH
//
// MessageText:
//
// An SoH was missing from the NAP packet.
//
#define NAP_E_MISSING_SOH     _HRESULT_TYPEDEF_(0x80270002L)


//
// MessageId: NAP_E_CONFLICTING_ID
//
// MessageText:
//
//  The entity ID conflicts with an already registered id.
//
#define NAP_E_CONFLICTING_ID  _HRESULT_TYPEDEF_(0x80270003L)


//
// MessageId: NAP_E_NO_CACHED_SOH
//
// MessageText:
//
//  No cached SoH is present.
//
#define NAP_E_NO_CACHED_SOH    _HRESULT_TYPEDEF_(0x80270004L)


//
// MessageId: NAP_E_STILL_BOUND
//
// MessageText:
//
//  The entity is still bound to the NAP system.
//
#define NAP_E_STILL_BOUND      _HRESULT_TYPEDEF_(0x80270005L)


//
// MessageId: NAP_E_NOT_REGISTERED
//
// MessageText:
//
//  The entity is not registered with the NAP system.
//
#define NAP_E_NOT_REGISTERED   _HRESULT_TYPEDEF_(0x80270006L)


//
// MessageId: NAP_E_NOT_INITIALIZED
//
// MessageText:
//
//  The entity is not initialized with the NAP system.
//
#define NAP_E_NOT_INITIALIZED   _HRESULT_TYPEDEF_(0x80270007L)


//
// MessageId: NAP_E_MISMATCHED_ID
//
// MessageText:
//
//  The correlation id in the SoH-Request and SoH-Response do not match up.
//
#define NAP_E_MISMATCHED_ID   _HRESULT_TYPEDEF_(0x80270008L)


//
// MessageId: NAP_E_NOT_PENDING
//
// MessageText:
//
//  Completion was indicated on a request that is not currently pending.
//
#define NAP_E_NOT_PENDING    _HRESULT_TYPEDEF_(0x80270009L)


//
// MessageId: NAP_E_ID_NOT_FOUND
//
// MessageText:
//
//  The NAP component's id was not found.
//
#define NAP_E_ID_NOT_FOUND    _HRESULT_TYPEDEF_(0x8027000AL)


//
// MessageId: NAP_E_MAXSIZE_TOO_SMALL
//
// MessageText:
//
//  The maximum size of the connection is too small for an SoH packet.
//
#define NAP_E_MAXSIZE_TOO_SMALL    _HRESULT_TYPEDEF_(0x8027000BL)


//
// MessageId: NAP_E_SERVICE_NOT_RUNNING
//
// MessageText:
//
//  The NapAgent service is not running.
//
#define NAP_E_SERVICE_NOT_RUNNING    _HRESULT_TYPEDEF_(0x8027000CL)


//
// MessageId: NAP_S_CERT_ALREADY_PRESENT
//
// MessageText:
//
//  A certificate is already present in the cert store
//
#define NAP_S_CERT_ALREADY_PRESENT    _HRESULT_TYPEDEF_(0x0027000DL)

//
// MessageId: NAP_E_ENTITY_DISABLED
//
// MessageText:
//
//  The entity is disabled with the NapAgent service.
//
#define NAP_E_ENTITY_DISABLED    _HRESULT_TYPEDEF_(0x8027000EL)

//
// MessageId: NAP_E_NETSH_GROUPPOLICY_ERROR
//
// MessageText:
//
//  Group Policy is not configured
//
#define NAP_E_NETSH_GROUPPOLICY_ERROR    _HRESULT_TYPEDEF_(0x8027000FL)

//
// MessageId: NAP_E_TOO_MANY_CALLS
//
// MessageText:
//
//  Too many simultaneous calls
//
#define NAP_E_TOO_MANY_CALLS    _HRESULT_TYPEDEF_(0x80270010L)

//
// MessageId: NAP_E_SHV_CONFIG_EXISTED
//
// MessageText:
// 
// SHV configuration already existed
//
#define NAP_E_SHV_CONFIG_EXISTED _HRESULT_TYPEDEF_(0x80270011L)

//
// MessageId: NAP_E_SHV_CONFIG_NOT_FOUND
//
// MessageText:
// 
// SHV configuration is not found
//
#define NAP_E_SHV_CONFIG_NOT_FOUND _HRESULT_TYPEDEF_(0x80270012L)

//
// MessageId: NAP_E_SHV_TIMEOUT
//
// MessageText:
// 
// SHV timed out on the request
//
#define NAP_E_SHV_TIMEOUT _HRESULT_TYPEDEF_(0x80270013L)
#endif // NAPERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\napmicrosoftvendorids.h ===
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares the MS IDs for the NAP system.
//
////////////////////////////////////////////////////////////

#ifndef NAPMICROSOFTVENDORIDS_H
#define NAPMICROSOFTVENDORIDS_H

#pragma once

extern "C"
{
   static UINT32 MicrosoftVendorId = 0x137;

   // These are the IDs used to identify internal Microsoft
   // enforcers and system health components.
   // The 4-byte values are encoded as follows - 
   //    first 3 bytes are the IETF-supplied SMI ID.
   //    last byte is used to identify the product.
   // 

   // The NAP system use the following ID.
   static UINT32 NapSystemId = 0x00013700;


   // Microsoft Enforcers use the following IDs.

   static UINT32 NapDhcpEnforcementId           = 0x00013701;
   static UINT32 NapRasEnforcementId            = 0x00013702;
   static UINT32 NapIpsecEnforcementId          = 0x00013703;
   static UINT32 Nap8021xEnforcementId          = 0x00013704;
   static UINT32 NapAnywhereAccessEnforcementId = 0x00013705;
   static UINT32 NapIsaEnforcementId            = 0x00013706;
   static UINT32 NapEapEnforcementId            = 0x00013707;


   // Microsoft System Health Components use the following IDs.
   
   static UINT32 NapOutOfBoxSystemHealthId      = 0x00013780;
   static UINT32 NapSmsSystemHealthId           = 0x00013781;
   static UINT32 NapFCSv1SystemHealthId         = 0x00013782;
   static UINT32 NapFCSv2SystemHealthId         = 0x00013783;
   static UINT32 NapTpmSystemHealthId           = 0x00013784; 
}

#endif // NAPMICROSOFTVENDORIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\MultiMon.h ===
//=============================================================================
//
// multimon.h -- Stub module that fakes multiple monitor apis on Win32 OSes
//               without them.
//
// By using this header your code will get back default values from
// GetSystemMetrics() for new metrics, and the new multimonitor APIs
// will act like only one display is present on a Win32 OS without
// multimonitor APIs.
//
// Exactly one source must include this with COMPILE_MULTIMON_STUBS defined.
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
//=============================================================================

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus

//
// If we are building with Win95/NT4 headers, we need to declare
// the multimonitor-related metrics and APIs ourselves.
//
#ifndef SM_CMONITORS

#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81

// HMONITOR is already declared if WINVER >= 0x0500 in windef.h
// This is for components built with an older version number.
//
#if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
DECLARE_HANDLE(HMONITOR);
#define HMONITOR_DECLARED
#endif

#define MONITOR_DEFAULTTONULL       0x00000000
#define MONITOR_DEFAULTTOPRIMARY    0x00000001
#define MONITOR_DEFAULTTONEAREST    0x00000002

#define MONITORINFOF_PRIMARY        0x00000001

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

#ifndef CCHDEVICENAME
#define CCHDEVICENAME 32
#endif

#ifdef __cplusplus
typedef struct tagMONITORINFOEXA : public tagMONITORINFO
{
    CHAR        szDevice[CCHDEVICENAME];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO
{
    WCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEXW, *LPMONITORINFOEXW;
#ifdef UNICODE
typedef MONITORINFOEXW MONITORINFOEX;
typedef LPMONITORINFOEXW LPMONITORINFOEX;
#else
typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
#endif // UNICODE
#else // ndef __cplusplus
typedef struct tagMONITORINFOEXA
{
    MONITORINFO;
    CHAR        szDevice[CCHDEVICENAME];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW
{
    MONITORINFO;
    WCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEXW, *LPMONITORINFOEXW;
#ifdef UNICODE
typedef MONITORINFOEXW MONITORINFOEX;
typedef LPMONITORINFOEXW LPMONITORINFOEX;
#else
typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
#endif // UNICODE
#endif

typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

#ifndef DISPLAY_DEVICE_ATTACHED_TO_DESKTOP
typedef struct _DISPLAY_DEVICEA {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
    CHAR   DeviceID[128];
    CHAR   DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD  cb;
    WCHAR  DeviceName[32];
    WCHAR  DeviceString[128];
    DWORD  StateFlags;
    WCHAR  DeviceID[128];
    WCHAR  DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;
#ifdef UNICODE
typedef DISPLAY_DEVICEW DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEW PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEW LPDISPLAY_DEVICE;
#else
typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;
#endif // UNICODE

#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008
#define DISPLAY_DEVICE_VGA_COMPATIBLE      0x00000010
#endif

#endif  // SM_CMONITORS

#undef GetMonitorInfo
#undef GetSystemMetrics
#undef MonitorFromWindow
#undef MonitorFromRect
#undef MonitorFromPoint
#undef EnumDisplayMonitors
#undef EnumDisplayDevices

//
// Define COMPILE_MULTIMON_STUBS to compile the stubs;
// otherwise, you get the declarations.
//
#ifdef COMPILE_MULTIMON_STUBS

//-----------------------------------------------------------------------------
//
// Implement the API stubs.
//
//-----------------------------------------------------------------------------

#ifndef _MULTIMON_USE_SECURE_CRT
#if defined(__GOT_SECURE_LIB__) && __GOT_SECURE_LIB__ >= 200402L
#define _MULTIMON_USE_SECURE_CRT 1
#else
#define _MULTIMON_USE_SECURE_CRT 0
#endif
#endif

#ifndef MULTIMON_FNS_DEFINED

int      (WINAPI* g_pfnGetSystemMetrics)(int) = NULL;
HMONITOR (WINAPI* g_pfnMonitorFromWindow)(HWND, DWORD) = NULL;
HMONITOR (WINAPI* g_pfnMonitorFromRect)(LPCRECT, DWORD) = NULL;
HMONITOR (WINAPI* g_pfnMonitorFromPoint)(POINT, DWORD) = NULL;
BOOL     (WINAPI* g_pfnGetMonitorInfo)(HMONITOR, LPMONITORINFO) = NULL;
BOOL     (WINAPI* g_pfnEnumDisplayMonitors)(HDC, LPCRECT, MONITORENUMPROC, LPARAM) = NULL;
BOOL     (WINAPI* g_pfnEnumDisplayDevices)(PVOID, DWORD, PDISPLAY_DEVICE,DWORD) = NULL;
BOOL     g_fMultiMonInitDone = FALSE;
BOOL     g_fMultimonPlatformNT = FALSE;

#endif

BOOL IsPlatformNT()
{ 
    OSVERSIONINFOA osvi = {0};
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA((OSVERSIONINFOA*)&osvi);
    return (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);    
}

BOOL InitMultipleMonitorStubs(void)
{
    HMODULE hUser32;
    if (g_fMultiMonInitDone)
    {
        return g_pfnGetMonitorInfo != NULL;
    }

    g_fMultimonPlatformNT = IsPlatformNT();
    hUser32 = GetModuleHandle(TEXT("USER32"));
    if (hUser32 &&
        (*(FARPROC*)&g_pfnGetSystemMetrics    = GetProcAddress(hUser32,"GetSystemMetrics")) != NULL &&
        (*(FARPROC*)&g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) != NULL &&
        (*(FARPROC*)&g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) != NULL &&
        (*(FARPROC*)&g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) != NULL &&
        (*(FARPROC*)&g_pfnEnumDisplayMonitors = GetProcAddress(hUser32,"EnumDisplayMonitors")) != NULL &&
#ifdef UNICODE
        (*(FARPROC*)&g_pfnEnumDisplayDevices  = GetProcAddress(hUser32,"EnumDisplayDevicesW")) != NULL &&
        (*(FARPROC*)&g_pfnGetMonitorInfo      = g_fMultimonPlatformNT ? GetProcAddress(hUser32,"GetMonitorInfoW") : 
                                                GetProcAddress(hUser32,"GetMonitorInfoA")) != NULL
#else
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")) != NULL &&
        (*(FARPROC*)&g_pfnEnumDisplayDevices  = GetProcAddress(hUser32,"EnumDisplayDevicesA")) != NULL
#endif
    ) {
        g_fMultiMonInitDone = TRUE;
        return TRUE;
    }
    else
    {
        g_pfnGetSystemMetrics    = NULL;
        g_pfnMonitorFromWindow   = NULL;
        g_pfnMonitorFromRect     = NULL;
        g_pfnMonitorFromPoint    = NULL;
        g_pfnGetMonitorInfo      = NULL;
        g_pfnEnumDisplayMonitors = NULL;
        g_pfnEnumDisplayDevices  = NULL;

        g_fMultiMonInitDone = TRUE;
        return FALSE;
    }
}

//-----------------------------------------------------------------------------
//
// fake implementations of Monitor APIs that work with the primary display
// no special parameter validation is made since these run in client code
//
//-----------------------------------------------------------------------------

int WINAPI
xGetSystemMetrics(int nIndex)
{
    if (InitMultipleMonitorStubs())
        return g_pfnGetSystemMetrics(nIndex);

    switch (nIndex)
    {
    case SM_CMONITORS:
    case SM_SAMEDISPLAYFORMAT:
        return 1;

    case SM_XVIRTUALSCREEN:
    case SM_YVIRTUALSCREEN:
        return 0;

    case SM_CXVIRTUALSCREEN:
        nIndex = SM_CXSCREEN;
        break;

    case SM_CYVIRTUALSCREEN:
        nIndex = SM_CYSCREEN;
        break;
    }

    return GetSystemMetrics(nIndex);
}

#define xPRIMARY_MONITOR ((HMONITOR)0x12340042)

HMONITOR WINAPI
xMonitorFromPoint(POINT ptScreenCoords, DWORD dwFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromPoint(ptScreenCoords, dwFlags);

    if ((dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((ptScreenCoords.x >= 0) &&
        (ptScreenCoords.x < GetSystemMetrics(SM_CXSCREEN)) &&
        (ptScreenCoords.y >= 0) &&
        (ptScreenCoords.y < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

HMONITOR WINAPI
xMonitorFromRect(LPCRECT lprcScreenCoords, DWORD dwFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromRect(lprcScreenCoords, dwFlags);

    if ((dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((lprcScreenCoords->right > 0) &&
        (lprcScreenCoords->bottom > 0) &&
        (lprcScreenCoords->left < GetSystemMetrics(SM_CXSCREEN)) &&
        (lprcScreenCoords->top < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

HMONITOR WINAPI
xMonitorFromWindow(HWND hWnd, DWORD dwFlags)
{
    WINDOWPLACEMENT wp;

    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromWindow(hWnd, dwFlags);

    if (dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST))
        return xPRIMARY_MONITOR;

    if (IsIconic(hWnd) ?
            GetWindowPlacement(hWnd, &wp) :
            GetWindowRect(hWnd, &wp.rcNormalPosition)) {

        return xMonitorFromRect(&wp.rcNormalPosition, dwFlags);
    }

    return NULL;
}

BOOL WINAPI
xGetMonitorInfo(HMONITOR hMonitor, __inout LPMONITORINFO lpMonitorInfo)
{
    RECT rcWork;

    if (InitMultipleMonitorStubs())
    {
        BOOL f = g_pfnGetMonitorInfo(hMonitor, lpMonitorInfo);
#ifdef UNICODE
        if (f && !g_fMultimonPlatformNT && (lpMonitorInfo->cbSize >= sizeof(MONITORINFOEX)))
        { 
            MultiByteToWideChar(CP_ACP, 0,
                (LPSTR)((MONITORINFOEX*)lpMonitorInfo)->szDevice, -1,
                ((MONITORINFOEX*)lpMonitorInfo)->szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)->szDevice)/sizeof(TCHAR)));
        }
#endif
        return f;
    }

    if ((hMonitor == xPRIMARY_MONITOR) &&
        lpMonitorInfo &&
        (lpMonitorInfo->cbSize >= sizeof(MONITORINFO)) &&
        SystemParametersInfoA(SPI_GETWORKAREA, 0, &rcWork, 0))
    {
        lpMonitorInfo->rcMonitor.left = 0;
        lpMonitorInfo->rcMonitor.top  = 0;
        lpMonitorInfo->rcMonitor.right  = GetSystemMetrics(SM_CXSCREEN);
        lpMonitorInfo->rcMonitor.bottom = GetSystemMetrics(SM_CYSCREEN);
        lpMonitorInfo->rcWork = rcWork;
        lpMonitorInfo->dwFlags = MONITORINFOF_PRIMARY;

        if (lpMonitorInfo->cbSize >= sizeof(MONITORINFOEX))
        {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, ((MONITORINFOEX*)lpMonitorInfo)->szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)->szDevice)/sizeof(TCHAR)));
#else // UNICODE
#if _MULTIMON_USE_SECURE_CRT
            strncpy_s(((MONITORINFOEX*)lpMonitorInfo)->szDevice, (sizeof(((MONITORINFOEX*)lpMonitorInfo)->szDevice)/sizeof(TCHAR)), TEXT("DISPLAY"), (sizeof(((MONITORINFOEX*)lpMonitorInfo)->szDevice)/sizeof(TCHAR)) - 1);
#else
            lstrcpyn(((MONITORINFOEX*)lpMonitorInfo)->szDevice, TEXT("DISPLAY"), (sizeof(((MONITORINFOEX*)lpMonitorInfo)->szDevice)/sizeof(TCHAR)));
#endif // _MULTIMON_USE_SECURE_CRT
#endif // UNICODE
        }

        return TRUE;
    }

    return FALSE;
}

BOOL WINAPI
xEnumDisplayMonitors(
        HDC             hdcOptionalForPainting,
        LPCRECT         lprcEnumMonitorsThatIntersect,
        MONITORENUMPROC lpfnEnumProc,
        LPARAM          dwData)
{
    RECT rcLimit;

    if (InitMultipleMonitorStubs()) {
        return g_pfnEnumDisplayMonitors(
                hdcOptionalForPainting,
                lprcEnumMonitorsThatIntersect,
                lpfnEnumProc,
                dwData);
    }

    if (!lpfnEnumProc)
        return FALSE;

    rcLimit.left   = 0;
    rcLimit.top    = 0;
    rcLimit.right  = GetSystemMetrics(SM_CXSCREEN);
    rcLimit.bottom = GetSystemMetrics(SM_CYSCREEN);

    if (hdcOptionalForPainting)
    {
        RECT    rcClip;
        POINT   ptOrg;

        switch (GetClipBox(hdcOptionalForPainting, &rcClip))
        {
        default:
            if (!GetDCOrgEx(hdcOptionalForPainting, &ptOrg))
                return FALSE;

            OffsetRect(&rcLimit, -ptOrg.x, -ptOrg.y);
            if (IntersectRect(&rcLimit, &rcLimit, &rcClip) &&
                (!lprcEnumMonitorsThatIntersect ||
                     IntersectRect(&rcLimit, &rcLimit, lprcEnumMonitorsThatIntersect))) {

                break;
            }
            //fall thru
        case NULLREGION:
             return TRUE;
        case ERROR:
             return FALSE;
        }
    } else {
        if (    lprcEnumMonitorsThatIntersect &&
                !IntersectRect(&rcLimit, &rcLimit, lprcEnumMonitorsThatIntersect)) {

            return TRUE;
        }
    }

    return lpfnEnumProc(
            xPRIMARY_MONITOR,
            hdcOptionalForPainting,
            &rcLimit,
            dwData);
}

BOOL WINAPI
xEnumDisplayDevices(
    PVOID Unused,
    DWORD iDevNum,
    __inout PDISPLAY_DEVICE lpDisplayDevice,
    DWORD dwFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnEnumDisplayDevices(Unused, iDevNum, lpDisplayDevice, dwFlags);

    if (Unused != NULL)
        return FALSE;

    if (iDevNum != 0)
        return FALSE;

    if (lpDisplayDevice == NULL || lpDisplayDevice->cb < sizeof(DISPLAY_DEVICE))
        return FALSE;

#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, lpDisplayDevice->DeviceName, (sizeof(lpDisplayDevice->DeviceName)/sizeof(TCHAR)));
    MultiByteToWideChar(CP_ACP, 0, "DISPLAY", -1, lpDisplayDevice->DeviceString, (sizeof(lpDisplayDevice->DeviceString)/sizeof(TCHAR)));
#else // UNICODE
#if _MULTIMON_USE_SECURE_CRT
    strncpy_s((LPTSTR)lpDisplayDevice->DeviceName, (sizeof(lpDisplayDevice->DeviceName)/sizeof(TCHAR)), TEXT("DISPLAY"), (sizeof(lpDisplayDevice->DeviceName)/sizeof(TCHAR)) - 1);
    strncpy_s((LPTSTR)lpDisplayDevice->DeviceString, (sizeof(lpDisplayDevice->DeviceString)/sizeof(TCHAR)), TEXT("DISPLAY"), (sizeof(lpDisplayDevice->DeviceName)/sizeof(TCHAR)) - 1);
#else
    lstrcpyn((LPTSTR)lpDisplayDevice->DeviceName,   TEXT("DISPLAY"), (sizeof(lpDisplayDevice->DeviceName)/sizeof(TCHAR)));
    lstrcpyn((LPTSTR)lpDisplayDevice->DeviceString, TEXT("DISPLAY"), (sizeof(lpDisplayDevice->DeviceString)/sizeof(TCHAR)));
#endif // _MULTIMON_USE_SECURE_CRT
#endif // UNICODE

    lpDisplayDevice->StateFlags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP | DISPLAY_DEVICE_PRIMARY_DEVICE;

    return TRUE;
}

#undef xPRIMARY_MONITOR
#undef COMPILE_MULTIMON_STUBS

#else   // COMPILE_MULTIMON_STUBS

extern int  WINAPI xGetSystemMetrics(int);
extern HMONITOR WINAPI xMonitorFromWindow(HWND, DWORD);
extern HMONITOR WINAPI xMonitorFromRect(LPCRECT, DWORD);
extern HMONITOR WINAPI xMonitorFromPoint(POINT, DWORD);
extern BOOL WINAPI xGetMonitorInfo(HMONITOR, LPMONITORINFO);
extern BOOL WINAPI xEnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM);
extern BOOL WINAPI xEnumDisplayDevices(PVOID, DWORD, PDISPLAY_DEVICE, DWORD);

#endif  // COMPILE_MULTIMON_STUBS

//
// build defines that replace the regular APIs with our versions
//
#define GetSystemMetrics    xGetSystemMetrics
#define MonitorFromWindow   xMonitorFromWindow
#define MonitorFromRect     xMonitorFromRect
#define MonitorFromPoint    xMonitorFromPoint
#define GetMonitorInfo      xGetMonitorInfo
#define EnumDisplayMonitors xEnumDisplayMonitors
#define EnumDisplayDevices  xEnumDisplayDevices

#ifdef __cplusplus
}
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\mxdc.h ===
/*++

Copyright (c) 1998-2006  Microsoft Corporation

Module Name:

    mxdc.h

Abstract:

    Header file for the Microsoft XPS Document Converter (MXDC),
    which is the conversion component of the
    Microsoft XPS Digital Writer (MXDW).

Environment:

    Windows NT printer drivers

Revision History:


--*/


#ifndef _MXDC_H_
#define _MXDC_H_


#ifdef __cplusplus
extern "C" {
#endif

#if (NTDDI_VERSION >= NTDDI_VISTASP1)

#define MXDC_IMAGEABLE_AREA_PROP_NAME_WSTR          (L"MxdcImageableArea")
#define MXDC_IMAGE_COMPRESSION_TYPE_PROP_NAME_WSTR  (L"MxdcImageCompressionType")
#define MXDC_DOTS_PER_INCH_PROP_NAME_WSTR           (L"MxdcDotsPerInch")

#define MXDC_LANDSCAPE_ROTATION_PROP_NAME_WSTR      (L"MxdcLandscapeRotation")


typedef enum tagMxdcLandscapeRotationEnums 
{
    MXDC_LANDSCAPE_ROTATE_COUNTERCLOCKWISE_90_DEGREES   =   90,  // 90 Degrees rotation counter-clockwise
    MXDC_LANDSCAPE_ROTATE_NONE         =    0,  // No Rotation
    MXDC_LANDSCAPE_ROTATE_COUNTERCLOCKWISE_270_DEGREES  =  -90   // 270 Degrees rotation counter-clockwise
} MXDC_LANDSCAPE_ROTATION_ENUMS;

/*
 * Microsoft XPS Document Converter Image Types
 */
typedef enum tagMxdcImageTypeEnums
{
    MXDC_IMAGETYPE_JPEGHIGH_COMPRESSION     = 1,  // Lowest Quality, and smallest file size
    MXDC_IMAGETYPE_JPEGMEDIUM_COMPRESSION   = 2,  // Medium Quality, and medium file size
    MXDC_IMAGETYPE_JPEGLOW_COMPRESSION      = 3,  // High Quality, and large file size
    MXDC_IMAGETYPE_PNG                      = 4   // Highest Quality, and largest file size
} MXDC_IMAGE_TYPE_ENUMS;

//
// MxdcGetPDEVAdjustment is exported by XPSDrv configuration module and called by the
// Microsoft XPS Document Converter (MXDC) to supply printer configuration data in the form of a property bag.
//
HRESULT WINAPI
MxdcGetPDEVAdjustment(
    __in HANDLE                                                           hPrinter,
    ULONG                                                                 cbDevMode,
    __in_bcount(cbDevMode) const DEVMODE                                  *pDevMode,
    ULONG                                                                 cbIn,
    __in_bcount_opt(cbIn) const VOID                                      *pvIn,
    ULONG                                                                 cbPrintPropertiesCollection,
    __inout_bcount(cbPrintPropertiesCollection) PrintPropertiesCollection *pPrintPropertiesCollection
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTASP1)

#define MXDC_ESCAPE                        4122

/*
 * Operation Codes used with the MXDC Escape (MXDC_ESCAPE)
 */

 /* MXDC Destination File Name Query Escape */
#define MXDCOP_GET_FILENAME                   14


/* MXDC Document Sequence PrintTicket Escape */
#define MXDCOP_PRINTTICKET_FIXED_DOC_SEQ      22

/* MXDC Fixed Document PrintTicket Escape */
#define MXDCOP_PRINTTICKET_FIXED_DOC          24

/* MXDC Fixed Page PrintTicket Escape */
#define MXDCOP_PRINTTICKET_FIXED_PAGE         26

/* MXDC S0 Page Pass-through Escape */
#define MXDCOP_SET_S0PAGE                     28

/* MXDC S0 Page Resource Pass-through */
#define MXDCOP_SET_S0PAGE_RESOURCE            30

/* MXDC Full XPS Pass-through Mode */
#define MXDCOP_SET_XPSPASSTHRU_MODE           32



#pragma pack(1)

/*
 * All of the MXDC's Escapes must start with this structure.
 */
typedef struct tagMxdcEscapeHeader
{
    ULONG cbInput;
    ULONG cbOutput;
    ULONG opCode;
} MXDC_ESCAPE_HEADER_T, * P_MXDC_ESCAPE_HEADER_T;


typedef struct tagMxdcGetFileNameData
{
    ULONG   cbOutput;
    wchar_t wszData[1];
} MXDC_GET_FILENAME_DATA_T, * P_MXDC_GET_FILENAME_DATA_T;

/*
 * Passthrough and entire S0 Page
 */
typedef struct tagMxdcS0PageData
{
    DWORD  dwSize;
    BYTE   bData[1];
} MXDC_S0PAGE_DATA_T, * P_MXDC_S0PAGE_DATA_T;


/*
 * Microsoft XPS Document Writer Resource Enumerators
 */
typedef enum tagMxdcS0PageEnums
{
    MXDC_RESOURCE_TTF            = 0, /* TrueType (OpenType) font                */
    MXDC_RESOURCE_JPEG           = 1, /* JPEG Image                              */
    MXDC_RESOURCE_PNG            = 2, /* PNG Image                               */
    MXDC_RESOURCE_TIFF           = 3, /* TIFF Image                              */
    MXDC_RESOURCE_WDP            = 4, /* Windows Media Photo Image               */
    MXDC_RESOURCE_DICTIONARY     = 5, /* Remote Resource Dictionary Pass-through */
    MXDC_RESOURCE_ICC_PROFILE    = 6, /* ICC Profile Pass-through                */
    MXDC_RESOURCE_JPEG_THUMBNAIL = 7, /* JPEG Thumbnail Pass-through             */
    MXDC_RESOURCE_PNG_THUMBNAIL  = 8, /* PNG Thumbnail Pass-through              */
    MXDC_RESOURCE_MAX                 /* Maximum Resource Count for validation   */
} MXDC_S0_PAGE_ENUMS;


typedef struct tagMxdcXpsS0PageResource
{
    DWORD dwSize;                /* Size of the structue and data        */
    DWORD dwResourceType;        /* Resource Type, "MXDC_S0_PAGE_ENUMS"  */
    BYTE  szUri[MAX_PATH];       /* URI sting of the resource            */
    DWORD dwDataSize;            /* The resource's data byte size        */
    BYTE  bData[1];              /* The resource's data                  */
} MXDC_XPS_S0PAGE_RESOURCE_T, * P_MXDC_XPS_S0PAGE_RESOURCE_T;


typedef struct tagMxdcPrintTicketPassthrough
{
    DWORD dwDataSize;            /* The Print Ticket's data byte size  */
    BYTE  bData[1];              /* The Print Ticket's data            */
} MXDC_PRINTTICKET_DATA_T, * P_MXDC_PRINTTICKET_DATA_T;


/***********************************************************
 * MXDC Escape Data Structures
 *
 */

typedef struct tagMxdcPrintTicketEscape
{
    MXDC_ESCAPE_HEADER_T     mxdcEscape;
    MXDC_PRINTTICKET_DATA_T  printTicketData;
} MXDC_PRINTTICKET_ESCAPE_T, * P_MXDC_PRINTTICKET_ESCAPE_T;

/*
 * The application will use this to pass the entire
 * XPS Page through the MXDC.
 */
typedef struct tagMxdcS0PagePassthroughEscape
{
    MXDC_ESCAPE_HEADER_T  mxdcEscape;
    MXDC_S0PAGE_DATA_T    xpsS0PageData;
} MXDC_S0PAGE_PASSTHROUGH_ESCAPE_T, * P_MXDC_S0PAGE_PASSTHROUGH_ESCAPE_T;

/*
 * This works in concert with MXDC_S0PAGE_PASSTHROUGH_ESCAPE_T.
 * This structure allows the respective resource of the
 * passed through XPS page to be saved. Some of the resource types
 * are as follows: JPEGs, PNGs, TIFFs, WDPs, Thumbnails, TTFs, etc..
 * The full list of resource types are described in the enum,
 * MXDC_S0_PAGE_ENUMS.
 */
typedef struct tagMxdcS0PageResourceEscape
{
    MXDC_ESCAPE_HEADER_T        mxdcEscape;
    MXDC_XPS_S0PAGE_RESOURCE_T  xpsS0PageResourcePassthrough;
} MXDC_S0PAGE_RESOURCE_ESCAPE_T, * P_MXDC_S0PAGE_RESOURCE_ESCAPE_T;


#pragma pack()





#ifdef __cplusplus
}
#endif

#endif //_MXDC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\napmanagement.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for napmanagement.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __napmanagement_h__
#define __napmanagement_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INapClientManagement_FWD_DEFINED__
#define __INapClientManagement_FWD_DEFINED__
typedef interface INapClientManagement INapClientManagement;
#endif 	/* __INapClientManagement_FWD_DEFINED__ */


#ifndef __INapClientManagement2_FWD_DEFINED__
#define __INapClientManagement2_FWD_DEFINED__
typedef interface INapClientManagement2 INapClientManagement2;
#endif 	/* __INapClientManagement2_FWD_DEFINED__ */


/* header files for imported files */
#include "NapTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __INapClientManagement_INTERFACE_DEFINED__
#define __INapClientManagement_INTERFACE_DEFINED__

/* interface INapClientManagement */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapClientManagement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("432a1da5-3888-4b9a-a734-cff1e448c5b9")
    INapClientManagement : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNapClientInfo( 
            /* [out] */ __RPC__out BOOL *isNapEnabled,
            /* [out] */ __RPC__deref_out_opt CountedString **clientName,
            /* [out] */ __RPC__deref_out_opt CountedString **clientDescription,
            /* [out] */ __RPC__deref_out_opt CountedString **protocolVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemIsolationInfo( 
            /* [out] */ __RPC__deref_out_opt IsolationInfo **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterSystemHealthAgent( 
            /* [in] */ __RPC__in const NapComponentRegistrationInfo *agent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterSystemHealthAgent( 
            /* [in] */ SystemHealthEntityId id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterEnforcementClient( 
            /* [in] */ __RPC__in const NapComponentRegistrationInfo *enforcer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterEnforcementClient( 
            /* [in] */ EnforcementEntityId id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisteredSystemHealthAgents( 
            /* [out] */ __RPC__out SystemHealthEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) NapComponentRegistrationInfo **agents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisteredEnforcementClients( 
            /* [out] */ __RPC__out EnforcementEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) NapComponentRegistrationInfo **enforcers) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapClientManagementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapClientManagement * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapClientManagement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapClientManagement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNapClientInfo )( 
            __RPC__in INapClientManagement * This,
            /* [out] */ __RPC__out BOOL *isNapEnabled,
            /* [out] */ __RPC__deref_out_opt CountedString **clientName,
            /* [out] */ __RPC__deref_out_opt CountedString **clientDescription,
            /* [out] */ __RPC__deref_out_opt CountedString **protocolVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemIsolationInfo )( 
            __RPC__in INapClientManagement * This,
            /* [out] */ __RPC__deref_out_opt IsolationInfo **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterSystemHealthAgent )( 
            __RPC__in INapClientManagement * This,
            /* [in] */ __RPC__in const NapComponentRegistrationInfo *agent);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterSystemHealthAgent )( 
            __RPC__in INapClientManagement * This,
            /* [in] */ SystemHealthEntityId id);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterEnforcementClient )( 
            __RPC__in INapClientManagement * This,
            /* [in] */ __RPC__in const NapComponentRegistrationInfo *enforcer);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterEnforcementClient )( 
            __RPC__in INapClientManagement * This,
            /* [in] */ EnforcementEntityId id);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisteredSystemHealthAgents )( 
            __RPC__in INapClientManagement * This,
            /* [out] */ __RPC__out SystemHealthEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) NapComponentRegistrationInfo **agents);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisteredEnforcementClients )( 
            __RPC__in INapClientManagement * This,
            /* [out] */ __RPC__out EnforcementEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) NapComponentRegistrationInfo **enforcers);
        
        END_INTERFACE
    } INapClientManagementVtbl;

    interface INapClientManagement
    {
        CONST_VTBL struct INapClientManagementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapClientManagement_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapClientManagement_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapClientManagement_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapClientManagement_GetNapClientInfo(This,isNapEnabled,clientName,clientDescription,protocolVersion)	\
    ( (This)->lpVtbl -> GetNapClientInfo(This,isNapEnabled,clientName,clientDescription,protocolVersion) ) 

#define INapClientManagement_GetSystemIsolationInfo(This,isolationInfo,unknownConnections)	\
    ( (This)->lpVtbl -> GetSystemIsolationInfo(This,isolationInfo,unknownConnections) ) 

#define INapClientManagement_RegisterSystemHealthAgent(This,agent)	\
    ( (This)->lpVtbl -> RegisterSystemHealthAgent(This,agent) ) 

#define INapClientManagement_UnregisterSystemHealthAgent(This,id)	\
    ( (This)->lpVtbl -> UnregisterSystemHealthAgent(This,id) ) 

#define INapClientManagement_RegisterEnforcementClient(This,enforcer)	\
    ( (This)->lpVtbl -> RegisterEnforcementClient(This,enforcer) ) 

#define INapClientManagement_UnregisterEnforcementClient(This,id)	\
    ( (This)->lpVtbl -> UnregisterEnforcementClient(This,id) ) 

#define INapClientManagement_GetRegisteredSystemHealthAgents(This,count,agents)	\
    ( (This)->lpVtbl -> GetRegisteredSystemHealthAgents(This,count,agents) ) 

#define INapClientManagement_GetRegisteredEnforcementClients(This,count,enforcers)	\
    ( (This)->lpVtbl -> GetRegisteredEnforcementClients(This,count,enforcers) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapClientManagement_INTERFACE_DEFINED__ */


#ifndef __INapClientManagement2_INTERFACE_DEFINED__
#define __INapClientManagement2_INTERFACE_DEFINED__

/* interface INapClientManagement2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapClientManagement2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07a1127b-18cc-422a-b988-e892600fcc74")
    INapClientManagement2 : public INapClientManagement
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemIsolationInfoEx( 
            /* [out] */ __RPC__deref_out_opt IsolationInfoEx **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapClientManagement2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapClientManagement2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapClientManagement2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapClientManagement2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNapClientInfo )( 
            __RPC__in INapClientManagement2 * This,
            /* [out] */ __RPC__out BOOL *isNapEnabled,
            /* [out] */ __RPC__deref_out_opt CountedString **clientName,
            /* [out] */ __RPC__deref_out_opt CountedString **clientDescription,
            /* [out] */ __RPC__deref_out_opt CountedString **protocolVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemIsolationInfo )( 
            __RPC__in INapClientManagement2 * This,
            /* [out] */ __RPC__deref_out_opt IsolationInfo **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterSystemHealthAgent )( 
            __RPC__in INapClientManagement2 * This,
            /* [in] */ __RPC__in const NapComponentRegistrationInfo *agent);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterSystemHealthAgent )( 
            __RPC__in INapClientManagement2 * This,
            /* [in] */ SystemHealthEntityId id);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterEnforcementClient )( 
            __RPC__in INapClientManagement2 * This,
            /* [in] */ __RPC__in const NapComponentRegistrationInfo *enforcer);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterEnforcementClient )( 
            __RPC__in INapClientManagement2 * This,
            /* [in] */ EnforcementEntityId id);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisteredSystemHealthAgents )( 
            __RPC__in INapClientManagement2 * This,
            /* [out] */ __RPC__out SystemHealthEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) NapComponentRegistrationInfo **agents);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisteredEnforcementClients )( 
            __RPC__in INapClientManagement2 * This,
            /* [out] */ __RPC__out EnforcementEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) NapComponentRegistrationInfo **enforcers);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemIsolationInfoEx )( 
            __RPC__in INapClientManagement2 * This,
            /* [out] */ __RPC__deref_out_opt IsolationInfoEx **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections);
        
        END_INTERFACE
    } INapClientManagement2Vtbl;

    interface INapClientManagement2
    {
        CONST_VTBL struct INapClientManagement2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapClientManagement2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapClientManagement2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapClientManagement2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapClientManagement2_GetNapClientInfo(This,isNapEnabled,clientName,clientDescription,protocolVersion)	\
    ( (This)->lpVtbl -> GetNapClientInfo(This,isNapEnabled,clientName,clientDescription,protocolVersion) ) 

#define INapClientManagement2_GetSystemIsolationInfo(This,isolationInfo,unknownConnections)	\
    ( (This)->lpVtbl -> GetSystemIsolationInfo(This,isolationInfo,unknownConnections) ) 

#define INapClientManagement2_RegisterSystemHealthAgent(This,agent)	\
    ( (This)->lpVtbl -> RegisterSystemHealthAgent(This,agent) ) 

#define INapClientManagement2_UnregisterSystemHealthAgent(This,id)	\
    ( (This)->lpVtbl -> UnregisterSystemHealthAgent(This,id) ) 

#define INapClientManagement2_RegisterEnforcementClient(This,enforcer)	\
    ( (This)->lpVtbl -> RegisterEnforcementClient(This,enforcer) ) 

#define INapClientManagement2_UnregisterEnforcementClient(This,id)	\
    ( (This)->lpVtbl -> UnregisterEnforcementClient(This,id) ) 

#define INapClientManagement2_GetRegisteredSystemHealthAgents(This,count,agents)	\
    ( (This)->lpVtbl -> GetRegisteredSystemHealthAgents(This,count,agents) ) 

#define INapClientManagement2_GetRegisteredEnforcementClients(This,count,enforcers)	\
    ( (This)->lpVtbl -> GetRegisteredEnforcementClients(This,count,enforcers) ) 


#define INapClientManagement2_GetSystemIsolationInfoEx(This,isolationInfo,unknownConnections)	\
    ( (This)->lpVtbl -> GetSystemIsolationInfoEx(This,isolationInfo,unknownConnections) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapClientManagement2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_napmanagement_0000_0002 */
/* [local] */ 

// Declarations of CLSIDs of objects provided  
// by the system. Link to uuid.lib to get them 
// defined.                                    
EXTERN_C const CLSID 
   CLSID_NapClientManagement;


extern RPC_IF_HANDLE __MIDL_itf_napmanagement_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napmanagement_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\muiload.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    MUILoad.h

Abstract:

    Public include file containing API declarations with Language Neutral
    resource module loading capabilities and downlevel compatibility

--*/

#ifndef _MUILOAD_H_INCLUDED_
#define _MUILOAD_H_INCLUDED_

#pragma once


#include <windows.h>

// Language convention flags
#define MUI_LANGUAGE_ID          0x4      // Use traditional language ID convention
#define MUI_LANGUAGE_NAME        0x8      // Use ISO language (culture) name convention
#define MUI_LANGUAGE_EXACT      0x10      // Don't fall back if language module is not found

#ifdef  __cplusplus
extern "C" {
#endif

/*++
LoadMUILibrary

Routine Description:

    This function is meant as a replacement for existing calls to
    LoadLibrary/LoadLibraryEx for components that need to provide
    support for Language neutral scenarios on Vista, Windows Server 2008 as well
    as older versions of the OS.
    It adds a wrapper around the actual call to LoadLibraryEx
    to search for MUI versions of the module in different
    locations depending on the language and the OS.
    The semantics are the same as for a call to LoadLibraryEx,
    including the return value and the error codes.


Arguments:

    pszFullModuleName - file name of the module (with or without path)
        originally containing the resources, as called by LoadLibraryEx().
        This filename is used to build the appropriate Language Neutral
        filename depending on the OS version.

    dwLangConvention - used to let the API know which installation
    convention was used to setup the files.
        Possible values:
            MUI_LANGUAGE_NAME  - (default) use ISO language name convention
            MUI_LANGUAGE_ID    - use traditional LCID language name convention

        Options:
            MUI_LANGUAGE_EXACT - When wLangID is present and the associated library is not found,
                                 return NULL rather than falling back to the module at pwszModuleName

    LangID - if nonzero, the caller is looking for an arbitrary Lang ID path
               specified by this parameter

Return Value:

    Handle to the mapped resource module if found.
    Otherwise, returns NULL.

--*/

// ANSI version
HINSTANCE __stdcall LoadMUILibraryA(
    __in PCSTR pszFullModuleName,
    __in DWORD dwLangConvention,
    __in LANGID LangID
    );

// Wide char version
HINSTANCE __stdcall LoadMUILibraryW(
    __in PCWSTR pszFullModuleName,
    __in DWORD dwLangConvention,
    __in LANGID LangID
    );

#ifdef UNICODE
#define LoadMUILibrary LoadMUILibraryW
#else
#define LoadMUILibrary LoadMUILibraryA
#endif

/*++
FreeMUILibrary

Routine Description:

    This function should be used the same way as FreeLibrary() to
    free the handle returned by LoadMUILibrary().
    It is provided in order to reproduce the LoadLibrary/FreeLibrary
    mechanism; any call to LoadMUILibrary should be
    paired with a call to FreeMUILibrary.


Arguments:

    hResModule - handle to the module loaded with LoadMUILibrary.


Return Value:

    If the function succeeds, the return value is nonzero.
    If the function fails, the return value is zero. To get extended error
    information, call GetLastError.

--*/
BOOL __stdcall FreeMUILibrary(
    __in HMODULE hResModule
    );

/*++
GetUILanguageFallbackList

Routine Description:

    This function returns the UI language fallback list in the provided
    buffer 'pFallbackList'.

    To find the length of the buffer needed to contain the list, call with
    'pFallbackList' set to NULL and 'cchFallbackList' set to 0, and the
    required length will be supplied via 'pcchFallbackOut'.

Arguments:

    pFallbackList   - On successful return, contains a NULL-delimited list
                      of UI Language names e.g. 'tk-TM'.  This list is double-null
                      terminated.

    cchFallbackList - The size in characters of the provided buffer,
                      'pFallbackList'

    pcchFallbackOut - If 'pFallbackList' is large enough to hold the list,
                      this will be the number of characters copied into
                      the buffer.  Otherwise, this will return the number of
                      size in characters necessary to hold the list.

Return Value:

    TRUE on success
    FALSE on failure

    To get extended error information, call GetLastError.

--*/
BOOL __stdcall GetUILanguageFallbackList(
    __out_ecount_opt(cchFallbackList)   PWSTR       pFallbackList,
    __in                                ULONG       cchFallbackList,
    __out_opt                           PULONG      pcchFallbackOut
    );

#ifdef  __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\naptypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for naptypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __naptypes_h__
#define __naptypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_naptypes_0000_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_naptypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_naptypes_0000_0000_v0_0_s_ifspec;

#ifndef __INapTypes_INTERFACE_DEFINED__
#define __INapTypes_INTERFACE_DEFINED__

/* interface INapTypes */
/* [unique] */ 

#define	maxSoHAttributeCount	( 100 )

#define	maxSoHAttributeSize	( 4000 )

#define	minNetworkSoHSize	( 12 )

#define	maxNetworkSoHSize	( 4000 )

#define	maxDwordCountPerSoHAttribute	( ( maxSoHAttributeSize / sizeof( DWORD  ) )  )

#define	maxIpv4CountPerSoHAttribute	( ( maxSoHAttributeSize / 4 )  )

#define	maxIpv6CountPerSoHAttribute	( ( maxSoHAttributeSize / 16 )  )

#define	maxStringLength	( 1024 )

#define	maxStringLengthInBytes	( ( (( maxStringLength + 1 ) ) * sizeof( WCHAR  ) )  )

#define	maxSystemHealthEntityCount	( 20 )

#define	maxEnforcerCount	( 20 )

#define	maxPrivateDataSize	( 200 )

#define	maxConnectionCountPerEnforcer	( 20 )

#define	maxCachedSoHCount	( ( ( maxSystemHealthEntityCount * maxEnforcerCount )  * maxConnectionCountPerEnforcer )  )

#define	freshSoHRequest	( 0x1 )

#define	shaFixup	( 0x1 )

typedef 
enum tagIsolationState
    {	isolationStateNotRestricted	= 1,
	isolationStateInProbation	= 2,
	isolationStateRestrictedAccess	= 3
    } 	IsolationState;

typedef 
enum tagExtendedIsolationState
    {	extendedIsolationStateNoData	= 0,
	extendedIsolationStateTransition	= 0x1,
	extendedIsolationStateInfected	= 0x2,
	extendedIsolationStateUnknown	= 0x3
    } 	ExtendedIsolationState;

typedef 
enum tagNapTracingLevel
    {	tracingLevelUndefined	= 0,
	tracingLevelBasic	= 1,
	tracingLevelAdvanced	= 2,
	tracingLevelDebug	= 3
    } 	NapTracingLevel;

typedef FILETIME ProbationTime;

typedef struct tagCountedString
    {
    UINT16 length;
    WCHAR *string;
    } 	CountedString;

typedef struct tagIsolationInfo
    {
    IsolationState isolationState;
    ProbationTime probEndTime;
    CountedString failureUrl;
    } 	IsolationInfo;

typedef struct tagIsolationInfoEx
    {
    IsolationState isolationState;
    ExtendedIsolationState extendedIsolationState;
    ProbationTime probEndTime;
    CountedString failureUrl;
    } 	IsolationInfoEx;

#define	failureCategoryCount	( 5 )

typedef 
enum tagFailureCategory
    {	failureCategoryNone	= 0,
	failureCategoryOther	= 1,
	failureCategoryClientComponent	= 2,
	failureCategoryClientCommunication	= 3,
	failureCategoryServerComponent	= 4,
	failureCategoryServerCommunication	= 5
    } 	FailureCategory;

typedef struct tagFailureCategoryMapping
    {
    BOOL mappingCompliance[ 5 ];
    } 	FailureCategoryMapping;

typedef UINT32 NapComponentId;

typedef NapComponentId SystemHealthEntityId;

typedef NapComponentId EnforcementEntityId;

#define	ComponentTypeEnforcementClientSoH	( 0x1 )

#define	ComponentTypeEnforcementClientRp	( 0x2 )

typedef /* [range] */ __RPC__range(0,maxSystemHealthEntityCount) UINT16 SystemHealthEntityCount;

typedef /* [range] */ __RPC__range(0,maxEnforcerCount) UINT16 EnforcementEntityCount;

typedef struct tagCorrelationId
    {
    GUID connId;
    FILETIME timeStamp;
    } 	CorrelationId;

typedef CountedString StringCorrelationId;

typedef GUID ConnectionId;

#define	percentageNotSupported	( 101 )

typedef /* [range] */ __RPC__range(0,percentageNotSupported) UINT8 Percentage;

typedef UINT32 MessageId;

typedef struct tagResultCodes
    {
    UINT16 count;
    HRESULT *results;
    } 	ResultCodes;

typedef struct tagIpv4Address
    {
    BYTE addr[ 4 ];
    } 	Ipv4Address;

typedef struct tagIpv6Address
    {
    BYTE addr[ 16 ];
    } 	Ipv6Address;

typedef 
enum tagFixupState
    {	fixupStateSuccess	= 0,
	fixupStateInProgress	= 1,
	fixupStateCouldNotUpdate	= 2
    } 	FixupState;

typedef struct tagFixupInfo
    {
    FixupState state;
    Percentage percentage;
    ResultCodes resultCodes;
    MessageId fixupMsgId;
    } 	FixupInfo;

typedef 
enum tagNapNotifyType
    {	napNotifyTypeUnknown	= 0,
	napNotifyTypeServiceState	= 1,
	napNotifyTypeQuarState	= 2
    } 	NapNotifyType;

typedef struct tagSystemHealthAgentState
    {
    SystemHealthEntityId id;
    ResultCodes shaResultCodes;
    FailureCategory failureCategory;
    FixupInfo fixupInfo;
    } 	SystemHealthAgentState;

typedef struct tagSoHAttribute
    {
    UINT16 type;
    UINT16 size;
    BYTE *value;
    } 	SoHAttribute;

typedef struct tagSoH
    {
    UINT16 count;
    SoHAttribute *attributes;
    } 	SoH;

typedef struct tagSoH SoHRequest;

typedef struct tagSoH SoHResponse;

typedef struct tagNetworkSoH
    {
    UINT16 size;
    BYTE *data;
    } 	NetworkSoH;

typedef struct tagNetworkSoH NetworkSoHRequest;

typedef struct tagNetworkSoH NetworkSoHResponse;

typedef struct tagPrivateData
    {
    UINT16 size;
    BYTE *data;
    } 	PrivateData;

typedef struct tagNapComponentRegistrationInfo
    {
    NapComponentId id;
    CountedString friendlyName;
    CountedString description;
    CountedString version;
    CountedString vendorName;
    CLSID infoClsid;
    CLSID configClsid;
    FILETIME registrationDate;
    UINT32 componentType;
    } 	NapComponentRegistrationInfo;

typedef 
enum tagRemoteConfigurationType
    {	remoteConfigTypeMachine	= 1,
	remoteConfigTypeConfigBlob	= ( remoteConfigTypeMachine + 1 ) 
    } 	RemoteConfigurationType;



extern RPC_IF_HANDLE INapTypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE INapTypes_v0_0_s_ifspec;
#endif /* __INapTypes_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\napcertrelyingparty.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for napcertrelyingparty.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __napcertrelyingparty_h__
#define __napcertrelyingparty_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INapCertRelyingParty_FWD_DEFINED__
#define __INapCertRelyingParty_FWD_DEFINED__
typedef interface INapCertRelyingParty INapCertRelyingParty;
#endif 	/* __INapCertRelyingParty_FWD_DEFINED__ */


/* header files for imported files */
#include "NapTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_napcertrelyingparty_0000_0000 */
/* [local] */ 

#include <wincrypt.h>
static const UINT32 NapAfwZonePropId = CERT_FIRST_USER_PROP_ID;
static const UINT32 NapAfwProtectionLevelPropId = CERT_FIRST_USER_PROP_ID + 1;


extern RPC_IF_HANDLE __MIDL_itf_napcertrelyingparty_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napcertrelyingparty_0000_0000_v0_0_s_ifspec;

#ifndef __INapCertRelyingParty_INTERFACE_DEFINED__
#define __INapCertRelyingParty_INTERFACE_DEFINED__

/* interface INapCertRelyingParty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapCertRelyingParty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62c02ffc-4c77-4158-8754-782d5b4ee66e")
    INapCertRelyingParty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SubscribeCertByGroup( 
            /* [in] */ EnforcementEntityId id,
            /* [in] */ __RPC__in const BSTR subscriberName,
            /* [unique][in] */ __RPC__in_opt const VARIANT *reserved,
            /* [out] */ __RPC__out BOOL *certExists) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnSubscribeCertByGroup( 
            /* [in] */ EnforcementEntityId id,
            /* [unique][in] */ __RPC__in_opt const VARIANT *reserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubscribedRelyingParties( 
            /* [out] */ __RPC__out EnforcementEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) EnforcementEntityId **relyingParties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapCertRelyingPartyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapCertRelyingParty * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapCertRelyingParty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapCertRelyingParty * This);
        
        HRESULT ( STDMETHODCALLTYPE *SubscribeCertByGroup )( 
            __RPC__in INapCertRelyingParty * This,
            /* [in] */ EnforcementEntityId id,
            /* [in] */ __RPC__in const BSTR subscriberName,
            /* [unique][in] */ __RPC__in_opt const VARIANT *reserved,
            /* [out] */ __RPC__out BOOL *certExists);
        
        HRESULT ( STDMETHODCALLTYPE *UnSubscribeCertByGroup )( 
            __RPC__in INapCertRelyingParty * This,
            /* [in] */ EnforcementEntityId id,
            /* [unique][in] */ __RPC__in_opt const VARIANT *reserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubscribedRelyingParties )( 
            __RPC__in INapCertRelyingParty * This,
            /* [out] */ __RPC__out EnforcementEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) EnforcementEntityId **relyingParties);
        
        END_INTERFACE
    } INapCertRelyingPartyVtbl;

    interface INapCertRelyingParty
    {
        CONST_VTBL struct INapCertRelyingPartyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapCertRelyingParty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapCertRelyingParty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapCertRelyingParty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapCertRelyingParty_SubscribeCertByGroup(This,id,subscriberName,reserved,certExists)	\
    ( (This)->lpVtbl -> SubscribeCertByGroup(This,id,subscriberName,reserved,certExists) ) 

#define INapCertRelyingParty_UnSubscribeCertByGroup(This,id,reserved)	\
    ( (This)->lpVtbl -> UnSubscribeCertByGroup(This,id,reserved) ) 

#define INapCertRelyingParty_GetSubscribedRelyingParties(This,count,relyingParties)	\
    ( (This)->lpVtbl -> GetSubscribedRelyingParties(This,count,relyingParties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapCertRelyingParty_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_napcertrelyingparty_0000_0001 */
/* [local] */ 

// Declarations of CLSIDs of objects provided  
// by the system. Link to uuid.lib to get them 
// defined.                                    
EXTERN_C const CLSID 
   CLSID_NapCertRelyingParty;


extern RPC_IF_HANDLE __MIDL_itf_napcertrelyingparty_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napcertrelyingparty_0000_0001_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\napcommon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for napcommon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __napcommon_h__
#define __napcommon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INapComponentInfo_FWD_DEFINED__
#define __INapComponentInfo_FWD_DEFINED__
typedef interface INapComponentInfo INapComponentInfo;
#endif 	/* __INapComponentInfo_FWD_DEFINED__ */


#ifndef __INapComponentConfig_FWD_DEFINED__
#define __INapComponentConfig_FWD_DEFINED__
typedef interface INapComponentConfig INapComponentConfig;
#endif 	/* __INapComponentConfig_FWD_DEFINED__ */


#ifndef __INapComponentConfig2_FWD_DEFINED__
#define __INapComponentConfig2_FWD_DEFINED__
typedef interface INapComponentConfig2 INapComponentConfig2;
#endif 	/* __INapComponentConfig2_FWD_DEFINED__ */


#ifndef __INapComponentConfig3_FWD_DEFINED__
#define __INapComponentConfig3_FWD_DEFINED__
typedef interface INapComponentConfig3 INapComponentConfig3;
#endif 	/* __INapComponentConfig3_FWD_DEFINED__ */


/* header files for imported files */
#include "NapTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __INapComponentInfo_INTERFACE_DEFINED__
#define __INapComponentInfo_INTERFACE_DEFINED__

/* interface INapComponentInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapComponentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B475F925-E3F7-414c-8C72-1CEE64B9D8F6")
    INapComponentInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFriendlyName( 
            /* [out] */ __RPC__out MessageId *friendlyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ __RPC__out MessageId *description) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVendorName( 
            /* [out] */ __RPC__out MessageId *vendorName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ __RPC__out MessageId *version) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcon( 
            /* [out] */ __RPC__deref_out_opt CountedString **dllFilePath,
            /* [out] */ __RPC__out UINT32 *iconResourceId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertErrorCodeToMessageId( 
            /* [in] */ HRESULT errorCode,
            /* [out] */ __RPC__out MessageId *msgId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalizedString( 
            /* [in] */ MessageId msgId,
            /* [out] */ __RPC__deref_out_opt CountedString **string) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapComponentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapComponentInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapComponentInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapComponentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in INapComponentInfo * This,
            /* [out] */ __RPC__out MessageId *friendlyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            __RPC__in INapComponentInfo * This,
            /* [out] */ __RPC__out MessageId *description);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorName )( 
            __RPC__in INapComponentInfo * This,
            /* [out] */ __RPC__out MessageId *vendorName);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in INapComponentInfo * This,
            /* [out] */ __RPC__out MessageId *version);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            __RPC__in INapComponentInfo * This,
            /* [out] */ __RPC__deref_out_opt CountedString **dllFilePath,
            /* [out] */ __RPC__out UINT32 *iconResourceId);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertErrorCodeToMessageId )( 
            __RPC__in INapComponentInfo * This,
            /* [in] */ HRESULT errorCode,
            /* [out] */ __RPC__out MessageId *msgId);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalizedString )( 
            __RPC__in INapComponentInfo * This,
            /* [in] */ MessageId msgId,
            /* [out] */ __RPC__deref_out_opt CountedString **string);
        
        END_INTERFACE
    } INapComponentInfoVtbl;

    interface INapComponentInfo
    {
        CONST_VTBL struct INapComponentInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapComponentInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapComponentInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapComponentInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapComponentInfo_GetFriendlyName(This,friendlyName)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,friendlyName) ) 

#define INapComponentInfo_GetDescription(This,description)	\
    ( (This)->lpVtbl -> GetDescription(This,description) ) 

#define INapComponentInfo_GetVendorName(This,vendorName)	\
    ( (This)->lpVtbl -> GetVendorName(This,vendorName) ) 

#define INapComponentInfo_GetVersion(This,version)	\
    ( (This)->lpVtbl -> GetVersion(This,version) ) 

#define INapComponentInfo_GetIcon(This,dllFilePath,iconResourceId)	\
    ( (This)->lpVtbl -> GetIcon(This,dllFilePath,iconResourceId) ) 

#define INapComponentInfo_ConvertErrorCodeToMessageId(This,errorCode,msgId)	\
    ( (This)->lpVtbl -> ConvertErrorCodeToMessageId(This,errorCode,msgId) ) 

#define INapComponentInfo_GetLocalizedString(This,msgId,string)	\
    ( (This)->lpVtbl -> GetLocalizedString(This,msgId,string) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapComponentInfo_INTERFACE_DEFINED__ */


#ifndef __INapComponentConfig_INTERFACE_DEFINED__
#define __INapComponentConfig_INTERFACE_DEFINED__

/* interface INapComponentConfig */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapComponentConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a9e0af1a-3713-478e-ae03-8edd272d21fa")
    INapComponentConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsUISupported( 
            /* [out] */ __RPC__out BOOL *isSupported) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeUI( 
            /* [unique][in] */ __RPC__in_opt HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfig( 
            /* [out] */ __RPC__out UINT16 *bCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*bCount) BYTE **data) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConfig( 
            /* [in] */ UINT16 bCount,
            /* [size_is][in] */ __RPC__in_ecount_full(bCount) BYTE *data) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapComponentConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapComponentConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapComponentConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapComponentConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUISupported )( 
            __RPC__in INapComponentConfig * This,
            /* [out] */ __RPC__out BOOL *isSupported);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeUI )( 
            __RPC__in INapComponentConfig * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfig )( 
            __RPC__in INapComponentConfig * This,
            /* [out] */ __RPC__out UINT16 *bCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*bCount) BYTE **data);
        
        HRESULT ( STDMETHODCALLTYPE *SetConfig )( 
            __RPC__in INapComponentConfig * This,
            /* [in] */ UINT16 bCount,
            /* [size_is][in] */ __RPC__in_ecount_full(bCount) BYTE *data);
        
        END_INTERFACE
    } INapComponentConfigVtbl;

    interface INapComponentConfig
    {
        CONST_VTBL struct INapComponentConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapComponentConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapComponentConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapComponentConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapComponentConfig_IsUISupported(This,isSupported)	\
    ( (This)->lpVtbl -> IsUISupported(This,isSupported) ) 

#define INapComponentConfig_InvokeUI(This,hwndParent)	\
    ( (This)->lpVtbl -> InvokeUI(This,hwndParent) ) 

#define INapComponentConfig_GetConfig(This,bCount,data)	\
    ( (This)->lpVtbl -> GetConfig(This,bCount,data) ) 

#define INapComponentConfig_SetConfig(This,bCount,data)	\
    ( (This)->lpVtbl -> SetConfig(This,bCount,data) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapComponentConfig_INTERFACE_DEFINED__ */


#ifndef __INapComponentConfig2_INTERFACE_DEFINED__
#define __INapComponentConfig2_INTERFACE_DEFINED__

/* interface INapComponentConfig2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapComponentConfig2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47cbdb9e-1972-4f5e-bd3c-5eb6230614b5")
    INapComponentConfig2 : public INapComponentConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsRemoteConfigSupported( 
            /* [out] */ __RPC__out BOOL *isSupported,
            /* [out] */ __RPC__out UINT8 *remoteConfigType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeUIForMachine( 
            /* [unique][in] */ __RPC__in_opt HWND hwndParent,
            /* [unique][in] */ __RPC__in_opt CountedString *machineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeUIFromConfigBlob( 
            /* [unique][in] */ __RPC__in_opt HWND hwndParent,
            /* [in] */ UINT16 inbCount,
            /* [size_is][in] */ __RPC__in_ecount_full(inbCount) BYTE *inData,
            /* [out] */ __RPC__out UINT16 *outbCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*outbCount) BYTE **outdata,
            /* [out] */ __RPC__out BOOL *fConfigChanged) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapComponentConfig2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapComponentConfig2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapComponentConfig2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapComponentConfig2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUISupported )( 
            __RPC__in INapComponentConfig2 * This,
            /* [out] */ __RPC__out BOOL *isSupported);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeUI )( 
            __RPC__in INapComponentConfig2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfig )( 
            __RPC__in INapComponentConfig2 * This,
            /* [out] */ __RPC__out UINT16 *bCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*bCount) BYTE **data);
        
        HRESULT ( STDMETHODCALLTYPE *SetConfig )( 
            __RPC__in INapComponentConfig2 * This,
            /* [in] */ UINT16 bCount,
            /* [size_is][in] */ __RPC__in_ecount_full(bCount) BYTE *data);
        
        HRESULT ( STDMETHODCALLTYPE *IsRemoteConfigSupported )( 
            __RPC__in INapComponentConfig2 * This,
            /* [out] */ __RPC__out BOOL *isSupported,
            /* [out] */ __RPC__out UINT8 *remoteConfigType);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeUIForMachine )( 
            __RPC__in INapComponentConfig2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndParent,
            /* [unique][in] */ __RPC__in_opt CountedString *machineName);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeUIFromConfigBlob )( 
            __RPC__in INapComponentConfig2 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndParent,
            /* [in] */ UINT16 inbCount,
            /* [size_is][in] */ __RPC__in_ecount_full(inbCount) BYTE *inData,
            /* [out] */ __RPC__out UINT16 *outbCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*outbCount) BYTE **outdata,
            /* [out] */ __RPC__out BOOL *fConfigChanged);
        
        END_INTERFACE
    } INapComponentConfig2Vtbl;

    interface INapComponentConfig2
    {
        CONST_VTBL struct INapComponentConfig2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapComponentConfig2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapComponentConfig2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapComponentConfig2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapComponentConfig2_IsUISupported(This,isSupported)	\
    ( (This)->lpVtbl -> IsUISupported(This,isSupported) ) 

#define INapComponentConfig2_InvokeUI(This,hwndParent)	\
    ( (This)->lpVtbl -> InvokeUI(This,hwndParent) ) 

#define INapComponentConfig2_GetConfig(This,bCount,data)	\
    ( (This)->lpVtbl -> GetConfig(This,bCount,data) ) 

#define INapComponentConfig2_SetConfig(This,bCount,data)	\
    ( (This)->lpVtbl -> SetConfig(This,bCount,data) ) 


#define INapComponentConfig2_IsRemoteConfigSupported(This,isSupported,remoteConfigType)	\
    ( (This)->lpVtbl -> IsRemoteConfigSupported(This,isSupported,remoteConfigType) ) 

#define INapComponentConfig2_InvokeUIForMachine(This,hwndParent,machineName)	\
    ( (This)->lpVtbl -> InvokeUIForMachine(This,hwndParent,machineName) ) 

#define INapComponentConfig2_InvokeUIFromConfigBlob(This,hwndParent,inbCount,inData,outbCount,outdata,fConfigChanged)	\
    ( (This)->lpVtbl -> InvokeUIFromConfigBlob(This,hwndParent,inbCount,inData,outbCount,outdata,fConfigChanged) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapComponentConfig2_INTERFACE_DEFINED__ */


#ifndef __INapComponentConfig3_INTERFACE_DEFINED__
#define __INapComponentConfig3_INTERFACE_DEFINED__

/* interface INapComponentConfig3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapComponentConfig3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C4A8101-8CFE-4332-876E-C4A49D1D3F77")
    INapComponentConfig3 : public INapComponentConfig2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NewConfig( 
            UINT32 configID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteConfig( 
            UINT32 configID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAllConfig( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfigFromID( 
            /* [in] */ UINT32 configID,
            /* [out] */ __RPC__out UINT16 *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) BYTE **outdata) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConfigToID( 
            /* [in] */ UINT32 configID,
            /* [in] */ UINT16 count,
            /* [size_is][in] */ __RPC__in_ecount_full(count) BYTE *data) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapComponentConfig3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapComponentConfig3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapComponentConfig3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapComponentConfig3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsUISupported )( 
            __RPC__in INapComponentConfig3 * This,
            /* [out] */ __RPC__out BOOL *isSupported);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeUI )( 
            __RPC__in INapComponentConfig3 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfig )( 
            __RPC__in INapComponentConfig3 * This,
            /* [out] */ __RPC__out UINT16 *bCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*bCount) BYTE **data);
        
        HRESULT ( STDMETHODCALLTYPE *SetConfig )( 
            __RPC__in INapComponentConfig3 * This,
            /* [in] */ UINT16 bCount,
            /* [size_is][in] */ __RPC__in_ecount_full(bCount) BYTE *data);
        
        HRESULT ( STDMETHODCALLTYPE *IsRemoteConfigSupported )( 
            __RPC__in INapComponentConfig3 * This,
            /* [out] */ __RPC__out BOOL *isSupported,
            /* [out] */ __RPC__out UINT8 *remoteConfigType);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeUIForMachine )( 
            __RPC__in INapComponentConfig3 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndParent,
            /* [unique][in] */ __RPC__in_opt CountedString *machineName);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeUIFromConfigBlob )( 
            __RPC__in INapComponentConfig3 * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndParent,
            /* [in] */ UINT16 inbCount,
            /* [size_is][in] */ __RPC__in_ecount_full(inbCount) BYTE *inData,
            /* [out] */ __RPC__out UINT16 *outbCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*outbCount) BYTE **outdata,
            /* [out] */ __RPC__out BOOL *fConfigChanged);
        
        HRESULT ( STDMETHODCALLTYPE *NewConfig )( 
            __RPC__in INapComponentConfig3 * This,
            UINT32 configID);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteConfig )( 
            __RPC__in INapComponentConfig3 * This,
            UINT32 configID);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllConfig )( 
            __RPC__in INapComponentConfig3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfigFromID )( 
            __RPC__in INapComponentConfig3 * This,
            /* [in] */ UINT32 configID,
            /* [out] */ __RPC__out UINT16 *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) BYTE **outdata);
        
        HRESULT ( STDMETHODCALLTYPE *SetConfigToID )( 
            __RPC__in INapComponentConfig3 * This,
            /* [in] */ UINT32 configID,
            /* [in] */ UINT16 count,
            /* [size_is][in] */ __RPC__in_ecount_full(count) BYTE *data);
        
        END_INTERFACE
    } INapComponentConfig3Vtbl;

    interface INapComponentConfig3
    {
        CONST_VTBL struct INapComponentConfig3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapComponentConfig3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapComponentConfig3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapComponentConfig3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapComponentConfig3_IsUISupported(This,isSupported)	\
    ( (This)->lpVtbl -> IsUISupported(This,isSupported) ) 

#define INapComponentConfig3_InvokeUI(This,hwndParent)	\
    ( (This)->lpVtbl -> InvokeUI(This,hwndParent) ) 

#define INapComponentConfig3_GetConfig(This,bCount,data)	\
    ( (This)->lpVtbl -> GetConfig(This,bCount,data) ) 

#define INapComponentConfig3_SetConfig(This,bCount,data)	\
    ( (This)->lpVtbl -> SetConfig(This,bCount,data) ) 


#define INapComponentConfig3_IsRemoteConfigSupported(This,isSupported,remoteConfigType)	\
    ( (This)->lpVtbl -> IsRemoteConfigSupported(This,isSupported,remoteConfigType) ) 

#define INapComponentConfig3_InvokeUIForMachine(This,hwndParent,machineName)	\
    ( (This)->lpVtbl -> InvokeUIForMachine(This,hwndParent,machineName) ) 

#define INapComponentConfig3_InvokeUIFromConfigBlob(This,hwndParent,inbCount,inData,outbCount,outdata,fConfigChanged)	\
    ( (This)->lpVtbl -> InvokeUIFromConfigBlob(This,hwndParent,inbCount,inData,outbCount,outdata,fConfigChanged) ) 


#define INapComponentConfig3_NewConfig(This,configID)	\
    ( (This)->lpVtbl -> NewConfig(This,configID) ) 

#define INapComponentConfig3_DeleteConfig(This,configID)	\
    ( (This)->lpVtbl -> DeleteConfig(This,configID) ) 

#define INapComponentConfig3_DeleteAllConfig(This)	\
    ( (This)->lpVtbl -> DeleteAllConfig(This) ) 

#define INapComponentConfig3_GetConfigFromID(This,configID,count,outdata)	\
    ( (This)->lpVtbl -> GetConfigFromID(This,configID,count,outdata) ) 

#define INapComponentConfig3_SetConfigToID(This,configID,count,data)	\
    ( (This)->lpVtbl -> SetConfigToID(This,configID,count,data) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapComponentConfig3_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\napenforcementclient.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for napenforcementclient.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __napenforcementclient_h__
#define __napenforcementclient_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INapEnforcementClientBinding_FWD_DEFINED__
#define __INapEnforcementClientBinding_FWD_DEFINED__
typedef interface INapEnforcementClientBinding INapEnforcementClientBinding;
#endif 	/* __INapEnforcementClientBinding_FWD_DEFINED__ */


#ifndef __INapEnforcementClientCallback_FWD_DEFINED__
#define __INapEnforcementClientCallback_FWD_DEFINED__
typedef interface INapEnforcementClientCallback INapEnforcementClientCallback;
#endif 	/* __INapEnforcementClientCallback_FWD_DEFINED__ */


#ifndef __INapEnforcementClientConnection_FWD_DEFINED__
#define __INapEnforcementClientConnection_FWD_DEFINED__
typedef interface INapEnforcementClientConnection INapEnforcementClientConnection;
#endif 	/* __INapEnforcementClientConnection_FWD_DEFINED__ */


#ifndef __INapEnforcementClientConnection2_FWD_DEFINED__
#define __INapEnforcementClientConnection2_FWD_DEFINED__
typedef interface INapEnforcementClientConnection2 INapEnforcementClientConnection2;
#endif 	/* __INapEnforcementClientConnection2_FWD_DEFINED__ */


/* header files for imported files */
#include "NapTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_napenforcementclient_0000_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_napenforcementclient_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napenforcementclient_0000_0000_v0_0_s_ifspec;

#ifndef __INapEnforcementClientBinding_INTERFACE_DEFINED__
#define __INapEnforcementClientBinding_INTERFACE_DEFINED__

/* interface INapEnforcementClientBinding */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapEnforcementClientBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92B93223-7487-42d9-9A91-5B8507720384")
    INapEnforcementClientBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ EnforcementEntityId id,
            /* [in] */ __RPC__in_opt INapEnforcementClientCallback *callback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateConnection( 
            /* [out] */ __RPC__deref_out_opt INapEnforcementClientConnection **connection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoHRequest( 
            /* [in] */ __RPC__in_opt INapEnforcementClientConnection *connection,
            /* [out] */ __RPC__out BOOL *retriggerHint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessSoHResponse( 
            /* [in] */ __RPC__in_opt INapEnforcementClientConnection *connection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyConnectionStateDown( 
            /* [in] */ __RPC__in_opt INapEnforcementClientConnection *downCxn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifySoHChangeFailure( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapEnforcementClientBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapEnforcementClientBinding * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapEnforcementClientBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapEnforcementClientBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INapEnforcementClientBinding * This,
            /* [in] */ EnforcementEntityId id,
            /* [in] */ __RPC__in_opt INapEnforcementClientCallback *callback);
        
        HRESULT ( STDMETHODCALLTYPE *Uninitialize )( 
            __RPC__in INapEnforcementClientBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateConnection )( 
            __RPC__in INapEnforcementClientBinding * This,
            /* [out] */ __RPC__deref_out_opt INapEnforcementClientConnection **connection);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHRequest )( 
            __RPC__in INapEnforcementClientBinding * This,
            /* [in] */ __RPC__in_opt INapEnforcementClientConnection *connection,
            /* [out] */ __RPC__out BOOL *retriggerHint);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSoHResponse )( 
            __RPC__in INapEnforcementClientBinding * This,
            /* [in] */ __RPC__in_opt INapEnforcementClientConnection *connection);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyConnectionStateDown )( 
            __RPC__in INapEnforcementClientBinding * This,
            /* [in] */ __RPC__in_opt INapEnforcementClientConnection *downCxn);
        
        HRESULT ( STDMETHODCALLTYPE *NotifySoHChangeFailure )( 
            __RPC__in INapEnforcementClientBinding * This);
        
        END_INTERFACE
    } INapEnforcementClientBindingVtbl;

    interface INapEnforcementClientBinding
    {
        CONST_VTBL struct INapEnforcementClientBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapEnforcementClientBinding_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapEnforcementClientBinding_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapEnforcementClientBinding_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapEnforcementClientBinding_Initialize(This,id,callback)	\
    ( (This)->lpVtbl -> Initialize(This,id,callback) ) 

#define INapEnforcementClientBinding_Uninitialize(This)	\
    ( (This)->lpVtbl -> Uninitialize(This) ) 

#define INapEnforcementClientBinding_CreateConnection(This,connection)	\
    ( (This)->lpVtbl -> CreateConnection(This,connection) ) 

#define INapEnforcementClientBinding_GetSoHRequest(This,connection,retriggerHint)	\
    ( (This)->lpVtbl -> GetSoHRequest(This,connection,retriggerHint) ) 

#define INapEnforcementClientBinding_ProcessSoHResponse(This,connection)	\
    ( (This)->lpVtbl -> ProcessSoHResponse(This,connection) ) 

#define INapEnforcementClientBinding_NotifyConnectionStateDown(This,downCxn)	\
    ( (This)->lpVtbl -> NotifyConnectionStateDown(This,downCxn) ) 

#define INapEnforcementClientBinding_NotifySoHChangeFailure(This)	\
    ( (This)->lpVtbl -> NotifySoHChangeFailure(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapEnforcementClientBinding_INTERFACE_DEFINED__ */


#ifndef __INapEnforcementClientCallback_INTERFACE_DEFINED__
#define __INapEnforcementClientCallback_INTERFACE_DEFINED__

/* interface INapEnforcementClientCallback */
/* [unique][uuid][object] */ 

typedef struct tagConnections
    {
    UINT16 count;
    INapEnforcementClientConnection **connections;
    } 	Connections;


EXTERN_C const IID IID_INapEnforcementClientCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5A0B90A-83A1-4f76-BA3F-025418682814")
    INapEnforcementClientCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifySoHChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnections( 
            /* [out] */ __RPC__deref_out_opt Connections **connections) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapEnforcementClientCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapEnforcementClientCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapEnforcementClientCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapEnforcementClientCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifySoHChange )( 
            __RPC__in INapEnforcementClientCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnections )( 
            __RPC__in INapEnforcementClientCallback * This,
            /* [out] */ __RPC__deref_out_opt Connections **connections);
        
        END_INTERFACE
    } INapEnforcementClientCallbackVtbl;

    interface INapEnforcementClientCallback
    {
        CONST_VTBL struct INapEnforcementClientCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapEnforcementClientCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapEnforcementClientCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapEnforcementClientCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapEnforcementClientCallback_NotifySoHChange(This)	\
    ( (This)->lpVtbl -> NotifySoHChange(This) ) 

#define INapEnforcementClientCallback_GetConnections(This,connections)	\
    ( (This)->lpVtbl -> GetConnections(This,connections) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapEnforcementClientCallback_INTERFACE_DEFINED__ */


#ifndef __INapEnforcementClientConnection_INTERFACE_DEFINED__
#define __INapEnforcementClientConnection_INTERFACE_DEFINED__

/* interface INapEnforcementClientConnection */
/* [unique][uuid][object] */ 

#define	defaultProtocolMaxSize	( 4000 )

#define	minProtocolMaxSize	( 300 )

#define	maxProtocolMaxSize	( 0xffff )

typedef /* [range] */ __RPC__range(minProtocolMaxSize,maxProtocolMaxSize) UINT32 ProtocolMaxSize;


EXTERN_C const IID IID_INapEnforcementClientConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FB3A3505-DDB1-468a-B307-F328A57419D8")
    INapEnforcementClientConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ EnforcementEntityId id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxSize( 
            /* [in] */ ProtocolMaxSize maxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxSize( 
            /* [out] */ __RPC__out ProtocolMaxSize *maxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ UINT8 flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ __RPC__out UINT8 *flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionId( 
            /* [in] */ __RPC__in const ConnectionId *connectionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionId( 
            /* [out] */ __RPC__deref_out_opt ConnectionId **connectionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCorrelationId( 
            /* [out] */ __RPC__out CorrelationId *correlationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringCorrelationId( 
            /* [out] */ __RPC__deref_out_opt StringCorrelationId **correlationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCorrelationId( 
            /* [in] */ CorrelationId correlationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSoHRequest( 
            /* [unique][in] */ __RPC__in_opt const NetworkSoHRequest *sohRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoHRequest( 
            /* [out] */ __RPC__deref_out_opt NetworkSoHRequest **sohRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSoHResponse( 
            /* [in] */ __RPC__in const NetworkSoHResponse *sohResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoHResponse( 
            /* [out] */ __RPC__deref_out_opt NetworkSoHResponse **sohResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIsolationInfo( 
            /* [in] */ __RPC__in const IsolationInfo *isolationInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsolationInfo( 
            /* [out] */ __RPC__deref_out_opt IsolationInfo **isolationInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrivateData( 
            /* [in] */ __RPC__in const PrivateData *privateData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateData( 
            /* [out] */ __RPC__deref_out_opt PrivateData **privateData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnforcerPrivateData( 
            /* [in] */ __RPC__in const PrivateData *privateData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnforcerPrivateData( 
            /* [out] */ __RPC__deref_out_opt PrivateData **privateData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapEnforcementClientConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapEnforcementClientConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapEnforcementClientConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ EnforcementEntityId id);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxSize )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ ProtocolMaxSize maxSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxSize )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__out ProtocolMaxSize *maxSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ UINT8 flags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__out UINT8 *flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionId )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ __RPC__in const ConnectionId *connectionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionId )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__deref_out_opt ConnectionId **connectionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorrelationId )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__out CorrelationId *correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringCorrelationId )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__deref_out_opt StringCorrelationId **correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *SetCorrelationId )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ CorrelationId correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *SetSoHRequest )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [unique][in] */ __RPC__in_opt const NetworkSoHRequest *sohRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHRequest )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__deref_out_opt NetworkSoHRequest **sohRequest);
        
        HRESULT ( STDMETHODCALLTYPE *SetSoHResponse )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ __RPC__in const NetworkSoHResponse *sohResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHResponse )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__deref_out_opt NetworkSoHResponse **sohResponse);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsolationInfo )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ __RPC__in const IsolationInfo *isolationInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsolationInfo )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__deref_out_opt IsolationInfo **isolationInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ __RPC__in const PrivateData *privateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__deref_out_opt PrivateData **privateData);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnforcerPrivateData )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [in] */ __RPC__in const PrivateData *privateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnforcerPrivateData )( 
            __RPC__in INapEnforcementClientConnection * This,
            /* [out] */ __RPC__deref_out_opt PrivateData **privateData);
        
        END_INTERFACE
    } INapEnforcementClientConnectionVtbl;

    interface INapEnforcementClientConnection
    {
        CONST_VTBL struct INapEnforcementClientConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapEnforcementClientConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapEnforcementClientConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapEnforcementClientConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapEnforcementClientConnection_Initialize(This,id)	\
    ( (This)->lpVtbl -> Initialize(This,id) ) 

#define INapEnforcementClientConnection_SetMaxSize(This,maxSize)	\
    ( (This)->lpVtbl -> SetMaxSize(This,maxSize) ) 

#define INapEnforcementClientConnection_GetMaxSize(This,maxSize)	\
    ( (This)->lpVtbl -> GetMaxSize(This,maxSize) ) 

#define INapEnforcementClientConnection_SetFlags(This,flags)	\
    ( (This)->lpVtbl -> SetFlags(This,flags) ) 

#define INapEnforcementClientConnection_GetFlags(This,flags)	\
    ( (This)->lpVtbl -> GetFlags(This,flags) ) 

#define INapEnforcementClientConnection_SetConnectionId(This,connectionId)	\
    ( (This)->lpVtbl -> SetConnectionId(This,connectionId) ) 

#define INapEnforcementClientConnection_GetConnectionId(This,connectionId)	\
    ( (This)->lpVtbl -> GetConnectionId(This,connectionId) ) 

#define INapEnforcementClientConnection_GetCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetCorrelationId(This,correlationId) ) 

#define INapEnforcementClientConnection_GetStringCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetStringCorrelationId(This,correlationId) ) 

#define INapEnforcementClientConnection_SetCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> SetCorrelationId(This,correlationId) ) 

#define INapEnforcementClientConnection_SetSoHRequest(This,sohRequest)	\
    ( (This)->lpVtbl -> SetSoHRequest(This,sohRequest) ) 

#define INapEnforcementClientConnection_GetSoHRequest(This,sohRequest)	\
    ( (This)->lpVtbl -> GetSoHRequest(This,sohRequest) ) 

#define INapEnforcementClientConnection_SetSoHResponse(This,sohResponse)	\
    ( (This)->lpVtbl -> SetSoHResponse(This,sohResponse) ) 

#define INapEnforcementClientConnection_GetSoHResponse(This,sohResponse)	\
    ( (This)->lpVtbl -> GetSoHResponse(This,sohResponse) ) 

#define INapEnforcementClientConnection_SetIsolationInfo(This,isolationInfo)	\
    ( (This)->lpVtbl -> SetIsolationInfo(This,isolationInfo) ) 

#define INapEnforcementClientConnection_GetIsolationInfo(This,isolationInfo)	\
    ( (This)->lpVtbl -> GetIsolationInfo(This,isolationInfo) ) 

#define INapEnforcementClientConnection_SetPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,privateData) ) 

#define INapEnforcementClientConnection_GetPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,privateData) ) 

#define INapEnforcementClientConnection_SetEnforcerPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> SetEnforcerPrivateData(This,privateData) ) 

#define INapEnforcementClientConnection_GetEnforcerPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> GetEnforcerPrivateData(This,privateData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapEnforcementClientConnection_INTERFACE_DEFINED__ */


#ifndef __INapEnforcementClientConnection2_INTERFACE_DEFINED__
#define __INapEnforcementClientConnection2_INTERFACE_DEFINED__

/* interface INapEnforcementClientConnection2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapEnforcementClientConnection2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BD244906-70DD-4690-BEEA-648653393500")
    INapEnforcementClientConnection2 : public INapEnforcementClientConnection
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIsolationInfoEx( 
            /* [in] */ __RPC__in const IsolationInfoEx *isolationInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIsolationInfoEx( 
            /* [out] */ __RPC__deref_out_opt IsolationInfoEx **isolationInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInstalledShvs( 
            /* [out] */ __RPC__out SystemHealthEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) SystemHealthEntityId **ids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInstalledShvs( 
            /* [in] */ SystemHealthEntityCount count,
            /* [size_is][in] */ __RPC__in_ecount_full(count) SystemHealthEntityId *ids) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapEnforcementClientConnection2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapEnforcementClientConnection2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapEnforcementClientConnection2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ EnforcementEntityId id);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxSize )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ ProtocolMaxSize maxSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxSize )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__out ProtocolMaxSize *maxSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ UINT8 flags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__out UINT8 *flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionId )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ __RPC__in const ConnectionId *connectionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionId )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__deref_out_opt ConnectionId **connectionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorrelationId )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__out CorrelationId *correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringCorrelationId )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__deref_out_opt StringCorrelationId **correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *SetCorrelationId )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ CorrelationId correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *SetSoHRequest )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [unique][in] */ __RPC__in_opt const NetworkSoHRequest *sohRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHRequest )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__deref_out_opt NetworkSoHRequest **sohRequest);
        
        HRESULT ( STDMETHODCALLTYPE *SetSoHResponse )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ __RPC__in const NetworkSoHResponse *sohResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHResponse )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__deref_out_opt NetworkSoHResponse **sohResponse);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsolationInfo )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ __RPC__in const IsolationInfo *isolationInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsolationInfo )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__deref_out_opt IsolationInfo **isolationInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ __RPC__in const PrivateData *privateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__deref_out_opt PrivateData **privateData);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnforcerPrivateData )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ __RPC__in const PrivateData *privateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnforcerPrivateData )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__deref_out_opt PrivateData **privateData);
        
        HRESULT ( STDMETHODCALLTYPE *SetIsolationInfoEx )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ __RPC__in const IsolationInfoEx *isolationInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIsolationInfoEx )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__deref_out_opt IsolationInfoEx **isolationInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetInstalledShvs )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [out] */ __RPC__out SystemHealthEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) SystemHealthEntityId **ids);
        
        HRESULT ( STDMETHODCALLTYPE *SetInstalledShvs )( 
            __RPC__in INapEnforcementClientConnection2 * This,
            /* [in] */ SystemHealthEntityCount count,
            /* [size_is][in] */ __RPC__in_ecount_full(count) SystemHealthEntityId *ids);
        
        END_INTERFACE
    } INapEnforcementClientConnection2Vtbl;

    interface INapEnforcementClientConnection2
    {
        CONST_VTBL struct INapEnforcementClientConnection2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapEnforcementClientConnection2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapEnforcementClientConnection2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapEnforcementClientConnection2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapEnforcementClientConnection2_Initialize(This,id)	\
    ( (This)->lpVtbl -> Initialize(This,id) ) 

#define INapEnforcementClientConnection2_SetMaxSize(This,maxSize)	\
    ( (This)->lpVtbl -> SetMaxSize(This,maxSize) ) 

#define INapEnforcementClientConnection2_GetMaxSize(This,maxSize)	\
    ( (This)->lpVtbl -> GetMaxSize(This,maxSize) ) 

#define INapEnforcementClientConnection2_SetFlags(This,flags)	\
    ( (This)->lpVtbl -> SetFlags(This,flags) ) 

#define INapEnforcementClientConnection2_GetFlags(This,flags)	\
    ( (This)->lpVtbl -> GetFlags(This,flags) ) 

#define INapEnforcementClientConnection2_SetConnectionId(This,connectionId)	\
    ( (This)->lpVtbl -> SetConnectionId(This,connectionId) ) 

#define INapEnforcementClientConnection2_GetConnectionId(This,connectionId)	\
    ( (This)->lpVtbl -> GetConnectionId(This,connectionId) ) 

#define INapEnforcementClientConnection2_GetCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetCorrelationId(This,correlationId) ) 

#define INapEnforcementClientConnection2_GetStringCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetStringCorrelationId(This,correlationId) ) 

#define INapEnforcementClientConnection2_SetCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> SetCorrelationId(This,correlationId) ) 

#define INapEnforcementClientConnection2_SetSoHRequest(This,sohRequest)	\
    ( (This)->lpVtbl -> SetSoHRequest(This,sohRequest) ) 

#define INapEnforcementClientConnection2_GetSoHRequest(This,sohRequest)	\
    ( (This)->lpVtbl -> GetSoHRequest(This,sohRequest) ) 

#define INapEnforcementClientConnection2_SetSoHResponse(This,sohResponse)	\
    ( (This)->lpVtbl -> SetSoHResponse(This,sohResponse) ) 

#define INapEnforcementClientConnection2_GetSoHResponse(This,sohResponse)	\
    ( (This)->lpVtbl -> GetSoHResponse(This,sohResponse) ) 

#define INapEnforcementClientConnection2_SetIsolationInfo(This,isolationInfo)	\
    ( (This)->lpVtbl -> SetIsolationInfo(This,isolationInfo) ) 

#define INapEnforcementClientConnection2_GetIsolationInfo(This,isolationInfo)	\
    ( (This)->lpVtbl -> GetIsolationInfo(This,isolationInfo) ) 

#define INapEnforcementClientConnection2_SetPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,privateData) ) 

#define INapEnforcementClientConnection2_GetPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,privateData) ) 

#define INapEnforcementClientConnection2_SetEnforcerPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> SetEnforcerPrivateData(This,privateData) ) 

#define INapEnforcementClientConnection2_GetEnforcerPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> GetEnforcerPrivateData(This,privateData) ) 


#define INapEnforcementClientConnection2_SetIsolationInfoEx(This,isolationInfo)	\
    ( (This)->lpVtbl -> SetIsolationInfoEx(This,isolationInfo) ) 

#define INapEnforcementClientConnection2_GetIsolationInfoEx(This,isolationInfo)	\
    ( (This)->lpVtbl -> GetIsolationInfoEx(This,isolationInfo) ) 

#define INapEnforcementClientConnection2_GetInstalledShvs(This,count,ids)	\
    ( (This)->lpVtbl -> GetInstalledShvs(This,count,ids) ) 

#define INapEnforcementClientConnection2_SetInstalledShvs(This,count,ids)	\
    ( (This)->lpVtbl -> SetInstalledShvs(This,count,ids) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapEnforcementClientConnection2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_napenforcementclient_0000_0004 */
/* [local] */ 

// Declarations of CLSIDs of objects provided  
// by the system. Link to uuid.lib to get them 
// defined.                                    
EXTERN_C const CLSID 
   CLSID_NapEnforcementClientBinding;


extern RPC_IF_HANDLE __MIDL_itf_napenforcementclient_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napenforcementclient_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\napprotocol.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for napprotocol.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __napprotocol_h__
#define __napprotocol_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INapSoHConstructor_FWD_DEFINED__
#define __INapSoHConstructor_FWD_DEFINED__
typedef interface INapSoHConstructor INapSoHConstructor;
#endif 	/* __INapSoHConstructor_FWD_DEFINED__ */


#ifndef __INapSoHProcessor_FWD_DEFINED__
#define __INapSoHProcessor_FWD_DEFINED__
typedef interface INapSoHProcessor INapSoHProcessor;
#endif 	/* __INapSoHProcessor_FWD_DEFINED__ */


/* header files for imported files */
#include "NapTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __INapSoHTypes_INTERFACE_DEFINED__
#define __INapSoHTypes_INTERFACE_DEFINED__

/* interface INapSoHTypes */
/* [unique] */ 

typedef 
enum tagSoHAttributeType
    {	sohAttributeTypeSystemHealthId	= 2,
	sohAttributeTypeIpv4FixupServers	= 3,
	sohAttributeTypeComplianceResultCodes	= 4,
	sohAttributeTypeTimeOfLastUpdate	= 5,
	sohAttributeTypeClientId	= 6,
	sohAttributeTypeVendorSpecific	= 7,
	sohAttributeTypeHealthClass	= 8,
	sohAttributeTypeSoftwareVersion	= 9,
	sohAttributeTypeProductName	= 10,
	sohAttributeTypeHealthClassStatus	= 11,
	sohAttributeTypeSoHGenerationTime	= 12,
	sohAttributeTypeErrorCodes	= 13,
	sohAttributeTypeFailureCategory	= 14,
	sohAttributeTypeIpv6FixupServers	= 15,
	sohAttributeTypeExtendedIsolationState	= 16
    } 	SoHAttributeType;

typedef 
enum tagHealthClassValue
    {	healthClassFirewall	= 0,
	healthClassPatchLevel	= 1,
	healthClassAntiVirus	= 2,
	healthClassCriticalUpdate	= 3,
	healthClassReserved	= 128
    } 	HealthClassValue;

typedef /* [switch_type] */ union tagSoHAttributeValue
    {
    SystemHealthEntityId idVal;
    struct tagIpv4Addresses
        {
        UINT16 count;
        Ipv4Address *addresses;
        } 	v4AddressesVal;
    struct tagIpv6Addresses
        {
        UINT16 count;
        Ipv6Address *addresses;
        } 	v6AddressesVal;
    ResultCodes codesVal;
    FILETIME dateTimeVal;
    struct tagVendorSpecific
        {
        UINT32 vendorId;
        UINT16 size;
        BYTE *vendorSpecificData;
        } 	vendorSpecificVal;
    UINT8 uint8Val;
    struct tagOctetString
        {
        UINT16 size;
        BYTE *data;
        } 	octetStringVal;
    } 	SoHAttributeValue;



extern RPC_IF_HANDLE INapSoHTypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE INapSoHTypes_v0_0_s_ifspec;
#endif /* __INapSoHTypes_INTERFACE_DEFINED__ */

#ifndef __INapSoHConstructor_INTERFACE_DEFINED__
#define __INapSoHConstructor_INTERFACE_DEFINED__

/* interface INapSoHConstructor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapSoHConstructor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("35298344-96A6-45e7-9B6B-62ECC6E09920")
    INapSoHConstructor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ SystemHealthEntityId id,
            /* [in] */ BOOL isRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendAttribute( 
            /* [in] */ SoHAttributeType type,
            /* [switch_is][in] */ __RPC__in const SoHAttributeValue *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoH( 
            /* [out] */ __RPC__deref_out_opt SoH **soh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ __RPC__in const SoH *soh,
            /* [in] */ BOOL isRequest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapSoHConstructorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapSoHConstructor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapSoHConstructor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapSoHConstructor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INapSoHConstructor * This,
            /* [in] */ SystemHealthEntityId id,
            /* [in] */ BOOL isRequest);
        
        HRESULT ( STDMETHODCALLTYPE *AppendAttribute )( 
            __RPC__in INapSoHConstructor * This,
            /* [in] */ SoHAttributeType type,
            /* [switch_is][in] */ __RPC__in const SoHAttributeValue *value);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoH )( 
            __RPC__in INapSoHConstructor * This,
            /* [out] */ __RPC__deref_out_opt SoH **soh);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            __RPC__in INapSoHConstructor * This,
            /* [in] */ __RPC__in const SoH *soh,
            /* [in] */ BOOL isRequest);
        
        END_INTERFACE
    } INapSoHConstructorVtbl;

    interface INapSoHConstructor
    {
        CONST_VTBL struct INapSoHConstructorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapSoHConstructor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapSoHConstructor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapSoHConstructor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapSoHConstructor_Initialize(This,id,isRequest)	\
    ( (This)->lpVtbl -> Initialize(This,id,isRequest) ) 

#define INapSoHConstructor_AppendAttribute(This,type,value)	\
    ( (This)->lpVtbl -> AppendAttribute(This,type,value) ) 

#define INapSoHConstructor_GetSoH(This,soh)	\
    ( (This)->lpVtbl -> GetSoH(This,soh) ) 

#define INapSoHConstructor_Validate(This,soh,isRequest)	\
    ( (This)->lpVtbl -> Validate(This,soh,isRequest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapSoHConstructor_INTERFACE_DEFINED__ */


#ifndef __INapSoHProcessor_INTERFACE_DEFINED__
#define __INapSoHProcessor_INTERFACE_DEFINED__

/* interface INapSoHProcessor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapSoHProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FB2FA8B0-2CD5-457d-ABA8-4376F63EA1C0")
    INapSoHProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in const SoH *soh,
            /* [in] */ BOOL isRequest,
            /* [out] */ __RPC__out SystemHealthEntityId *id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextAttribute( 
            /* [in] */ UINT16 fromLocation,
            /* [in] */ SoHAttributeType type,
            /* [out] */ __RPC__out UINT16 *attributeLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [in] */ UINT16 attributeLocation,
            /* [out] */ __RPC__out SoHAttributeType *type,
            /* [switch_is][out] */ __RPC__deref_out_opt SoHAttributeValue **value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfAttributes( 
            /* [out] */ __RPC__out UINT16 *attributeCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapSoHProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapSoHProcessor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapSoHProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapSoHProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INapSoHProcessor * This,
            /* [in] */ __RPC__in const SoH *soh,
            /* [in] */ BOOL isRequest,
            /* [out] */ __RPC__out SystemHealthEntityId *id);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextAttribute )( 
            __RPC__in INapSoHProcessor * This,
            /* [in] */ UINT16 fromLocation,
            /* [in] */ SoHAttributeType type,
            /* [out] */ __RPC__out UINT16 *attributeLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            __RPC__in INapSoHProcessor * This,
            /* [in] */ UINT16 attributeLocation,
            /* [out] */ __RPC__out SoHAttributeType *type,
            /* [switch_is][out] */ __RPC__deref_out_opt SoHAttributeValue **value);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfAttributes )( 
            __RPC__in INapSoHProcessor * This,
            /* [out] */ __RPC__out UINT16 *attributeCount);
        
        END_INTERFACE
    } INapSoHProcessorVtbl;

    interface INapSoHProcessor
    {
        CONST_VTBL struct INapSoHProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapSoHProcessor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapSoHProcessor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapSoHProcessor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapSoHProcessor_Initialize(This,soh,isRequest,id)	\
    ( (This)->lpVtbl -> Initialize(This,soh,isRequest,id) ) 

#define INapSoHProcessor_FindNextAttribute(This,fromLocation,type,attributeLocation)	\
    ( (This)->lpVtbl -> FindNextAttribute(This,fromLocation,type,attributeLocation) ) 

#define INapSoHProcessor_GetAttribute(This,attributeLocation,type,value)	\
    ( (This)->lpVtbl -> GetAttribute(This,attributeLocation,type,value) ) 

#define INapSoHProcessor_GetNumberOfAttributes(This,attributeCount)	\
    ( (This)->lpVtbl -> GetNumberOfAttributes(This,attributeCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapSoHProcessor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_napprotocol_0000_0003 */
/* [local] */ 

// Declarations of CLSIDs of objects provided  
// by the system. Link to uuid.lib to get them 
// defined.                                    
EXTERN_C const CLSID CLSID_NapSoHConstructor;
EXTERN_C const CLSID CLSID_NapSoHProcessor;


extern RPC_IF_HANDLE __MIDL_itf_napprotocol_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napprotocol_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\naputil.h ===
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    NAP utilities.
//
////////////////////////////////////////////////////////////

#ifndef NAPUTIL_H
#define NAPUTIL_H

#if _MSC_VER > 1000
#pragma once
#endif

#include "naptypes.h"
#include "napmanagement.h"
#include "napservermanagement.h"
#include "napprotocol.h"
#include "napenforcementclient.h"


#ifdef __cplusplus
extern "C" {
#endif

// The following functions are exported in QUtil.dll.
// 
#ifndef NAPAPI
#define NAPAPI DECLSPEC_IMPORT
#endif

// All the COM interfaces supported by the NAP system
// use standard COM memory management rules and the COM
// memory allocator (CoTaskMemAlloc and CoTaskMemFree).
//    in parameters     -- allocated and freed by caller.
//    out parameters    -- allocated by callee, freed 
//                         by caller using CoTaskMem*()
//    in/out parameters -- allocated by caller, freed
//                         and reallocated by callee,
//                         ultimately freed by caller,
//                         using CoTaskMem*()
// 
// The following functions are helpers to aid with
// COM memory management of some complex structures.
// 
// In the Free() functions below, all embedded pointers
// will also be freed.
// 


// Return values of Alloc functions:
//    E_INVALIDARG
//    E_OUTOFMEMORY
//    S_OK

NAPAPI
HRESULT WINAPI
AllocFixupInfo(
   IN OUT FixupInfo** fixupInfo,
   IN UINT16 countResultCodes
   );


NAPAPI
HRESULT WINAPI
AllocConnections(
   IN OUT Connections** connections,
   IN UINT16 connectionsCount
   );


NAPAPI
HRESULT WINAPI
AllocCountedString(
   IN OUT CountedString** countedString,
   IN CONST WCHAR* string
   );
   

NAPAPI
VOID WINAPI
FreeFixupInfo(
   IN FixupInfo* fixupInfo
   );


NAPAPI
VOID WINAPI
FreeConnections(
   IN Connections* connections
   );


NAPAPI
VOID WINAPI
FreeIsolationInfo(
   IN IsolationInfo* isolationInfo
   );


NAPAPI
VOID WINAPI
FreeIsolationInfoEx(
   IN IsolationInfoEx* isolationInfo
   );


NAPAPI
VOID WINAPI
FreeCountedString(
   IN CountedString* countedString
   );
   

NAPAPI
VOID WINAPI
FreeSoH(
   IN SoH* soh
   );


NAPAPI
VOID WINAPI
FreeNetworkSoH(
   IN NetworkSoH* networkSoh
   );


NAPAPI
VOID WINAPI
FreePrivateData(
   IN PrivateData* privateData
   );


NAPAPI
VOID WINAPI
FreeSoHAttributeValue(
   IN SoHAttributeType type,
   IN SoHAttributeValue* value
   );


NAPAPI
VOID WINAPI
FreeNapComponentRegistrationInfoArray(
   IN UINT16 count,
   IN NapComponentRegistrationInfo** info
   );


NAPAPI
VOID WINAPI
FreeSystemHealthAgentState(
   IN SystemHealthAgentState* state
   );


// InitializeNapAgentNotifier and UninitializeNapAgentNotifier are used to
// subscribe to NapAgent service state change notifications and quarantine
// state change notifications.
// These functions are not thread safe and should be called once for each 
// process.

NAPAPI
HRESULT WINAPI 
InitializeNapAgentNotifier(
   IN NapNotifyType type, 
   IN HANDLE hNotifyEvent
   );

NAPAPI
VOID WINAPI 
UninitializeNapAgentNotifier(
   IN NapNotifyType type
   );

#ifdef __cplusplus
}
#endif

#endif // NAPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ndfapi.h ===
/*++

Copyright (c) 2005  Microsoft Corporation

Module Name  : NDF.h

Abstract:

This file contains declaration for Network Diagnostics Framework (NDF) client API

Author:

Tin Qian (tinqian) 07-08-2005

Revision history:

--*/
#pragma once

#include <specstrings.h>
#include <ndattrib.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#ifndef __CSADDR_DEFINED__
struct SOCKET_ADDRESS_LIST;
#endif // __CSADDR_DEFINED__


typedef PVOID NDFHANDLE; 

STDAPI
NdfCreateIncident(
    __in LPCWSTR helperClassName,
    ULONG celt,
    __in_ecount(celt) HELPER_ATTRIBUTE *attributes,
    __deref_out NDFHANDLE *handle);

STDAPI
NdfCreateWinSockIncident(  
    SOCKET sock,
    __in_opt LPCWSTR host,
    USHORT port,
    __in_opt LPCWSTR appId,
    __in_opt SID *userId,
    __deref_out NDFHANDLE *handle);
    
STDAPI
NdfCreateWebIncident(
    __in LPCWSTR url,
    __deref_out NDFHANDLE *handle);    
    
STDAPI
NdfCreateWebIncidentEx(
       __in LPCWSTR url,
       BOOL useWinHTTP,
       __in_opt LPWSTR moduleName, 
       __deref_out NDFHANDLE *handle);

STDAPI NdfCreateSharingIncident(  
    __in LPCWSTR UNCPath,
    __deref_out NDFHANDLE *handle);

STDAPI NdfCreateDNSIncident(  
    __in LPCWSTR hostname,
    WORD queryType,
    __deref_out NDFHANDLE *handle);

STDAPI NdfCreateConnectivityIncident(  
    __deref_out NDFHANDLE *handle);

STDAPI NdfCreatePnrpIncident(  
    __in LPCWSTR cloudname,
    __in_opt LPCWSTR peername,
    __in BOOL diagnosePublish,
    __in_opt    LPCWSTR appId,  
    __deref_out NDFHANDLE *handle);

#define NDF_INBOUND_FLAG_EDGETRAVERSAL      0x00001
#define NDF_INBOUND_FLAG_HEALTHCHECK         0x00002

#ifdef __CSADDR_DEFINED__
STDAPI NdfCreateInboundIncident(
    __in_opt LPCWSTR applicationID,
    __in_opt LPCWSTR serviceID,
    __in_opt SID * userID,
    __in_opt const SOCKADDR_STORAGE *localTarget,
    IPPROTO protocol,
    DWORD dwFlags,
    __deref_out NDFHANDLE *handle
    );
#endif


HRESULT WINAPI
NdfCreateGroupingIncident(
	__in_opt		LPCWSTR	CloudName,
	__in_opt		LPCWSTR	GroupName,
	__in_opt    	LPCWSTR	Identity,                	
	__in_opt		LPCWSTR	Invitation,
	__in_opt    	SOCKET_ADDRESS_LIST * Addresses,
	__in_opt    LPCWSTR appId,	
	__deref_out 	NDFHANDLE *handle);


STDAPI
NdfExecuteDiagnosis(       
    __in NDFHANDLE handle,
    __in_opt HWND hwnd
    );

STDAPI
NdfCloseIncident(
    NDFHANDLE handle);

// Available flags for NdfDiagnoseIncident
#define NDF_ADD_CAPTURE_TRACE   0x0001

//UI-less diagnosis API
STDAPI
#ifdef __cplusplus
NdfDiagnoseIncident(
    __in NDFHANDLE Handle,
    __out ULONG *RootCauseCount,
    __deref_out_ecount(*RootCauseCount) 
    RootCauseInfo **RootCauses,
    DWORD dwWait=INFINITE,
    DWORD dwFlags=0
);
#else
NdfDiagnoseIncident(
    __in NDFHANDLE Handle,
    __out ULONG *RootCauseCount,
    __deref_out_ecount(*RootCauseCount) 
    RootCauseInfo **RootCauses,
    DWORD dwWait,
    DWORD dwFlags
);
#endif

//UI-less repair API
STDAPI
#ifdef __cplusplus
NdfRepairIncident(
      __in NDFHANDLE Handle,
      __in RepairInfoEx *RepairEx,
      DWORD dwWait=INFINITE
      );
#else
NdfRepairIncident(
      __in NDFHANDLE Handle,
      __in RepairInfoEx *RepairEx,
      DWORD dwWait
      );
#endif

//UI-less cancel API
STDAPI
NdfCancelIncident(
      __in NDFHANDLE Handle
      );

STDAPI
NdfGetTraceFile(
      __in NDFHANDLE Handle,
      __deref_out LPCWSTR *TraceFileLocation
      );

#ifdef __cplusplus
}
#endif // defined(__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\napsystemhealthagent.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for napsystemhealthagent.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __napsystemhealthagent_h__
#define __napsystemhealthagent_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INapSystemHealthAgentBinding_FWD_DEFINED__
#define __INapSystemHealthAgentBinding_FWD_DEFINED__
typedef interface INapSystemHealthAgentBinding INapSystemHealthAgentBinding;
#endif 	/* __INapSystemHealthAgentBinding_FWD_DEFINED__ */


#ifndef __INapSystemHealthAgentBinding2_FWD_DEFINED__
#define __INapSystemHealthAgentBinding2_FWD_DEFINED__
typedef interface INapSystemHealthAgentBinding2 INapSystemHealthAgentBinding2;
#endif 	/* __INapSystemHealthAgentBinding2_FWD_DEFINED__ */


#ifndef __INapSystemHealthAgentCallback_FWD_DEFINED__
#define __INapSystemHealthAgentCallback_FWD_DEFINED__
typedef interface INapSystemHealthAgentCallback INapSystemHealthAgentCallback;
#endif 	/* __INapSystemHealthAgentCallback_FWD_DEFINED__ */


#ifndef __AsyncINapSystemHealthAgentCallback_FWD_DEFINED__
#define __AsyncINapSystemHealthAgentCallback_FWD_DEFINED__
typedef interface AsyncINapSystemHealthAgentCallback AsyncINapSystemHealthAgentCallback;
#endif 	/* __AsyncINapSystemHealthAgentCallback_FWD_DEFINED__ */


#ifndef __INapSystemHealthAgentRequest_FWD_DEFINED__
#define __INapSystemHealthAgentRequest_FWD_DEFINED__
typedef interface INapSystemHealthAgentRequest INapSystemHealthAgentRequest;
#endif 	/* __INapSystemHealthAgentRequest_FWD_DEFINED__ */


/* header files for imported files */
#include "NapTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_napsystemhealthagent_0000_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_napsystemhealthagent_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napsystemhealthagent_0000_0000_v0_0_s_ifspec;

#ifndef __INapSystemHealthAgentBinding_INTERFACE_DEFINED__
#define __INapSystemHealthAgentBinding_INTERFACE_DEFINED__

/* interface INapSystemHealthAgentBinding */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapSystemHealthAgentBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6894F43-9CC7-44c9-A23F-19DBF36BAD28")
    INapSystemHealthAgentBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ SystemHealthEntityId id,
            /* [in] */ __RPC__in_opt INapSystemHealthAgentCallback *callback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifySoHChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemIsolationInfo( 
            /* [out] */ __RPC__deref_out_opt IsolationInfo **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapSystemHealthAgentBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapSystemHealthAgentBinding * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapSystemHealthAgentBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapSystemHealthAgentBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INapSystemHealthAgentBinding * This,
            /* [in] */ SystemHealthEntityId id,
            /* [in] */ __RPC__in_opt INapSystemHealthAgentCallback *callback);
        
        HRESULT ( STDMETHODCALLTYPE *Uninitialize )( 
            __RPC__in INapSystemHealthAgentBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifySoHChange )( 
            __RPC__in INapSystemHealthAgentBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemIsolationInfo )( 
            __RPC__in INapSystemHealthAgentBinding * This,
            /* [out] */ __RPC__deref_out_opt IsolationInfo **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections);
        
        HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            __RPC__in INapSystemHealthAgentBinding * This);
        
        END_INTERFACE
    } INapSystemHealthAgentBindingVtbl;

    interface INapSystemHealthAgentBinding
    {
        CONST_VTBL struct INapSystemHealthAgentBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapSystemHealthAgentBinding_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapSystemHealthAgentBinding_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapSystemHealthAgentBinding_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapSystemHealthAgentBinding_Initialize(This,id,callback)	\
    ( (This)->lpVtbl -> Initialize(This,id,callback) ) 

#define INapSystemHealthAgentBinding_Uninitialize(This)	\
    ( (This)->lpVtbl -> Uninitialize(This) ) 

#define INapSystemHealthAgentBinding_NotifySoHChange(This)	\
    ( (This)->lpVtbl -> NotifySoHChange(This) ) 

#define INapSystemHealthAgentBinding_GetSystemIsolationInfo(This,isolationInfo,unknownConnections)	\
    ( (This)->lpVtbl -> GetSystemIsolationInfo(This,isolationInfo,unknownConnections) ) 

#define INapSystemHealthAgentBinding_FlushCache(This)	\
    ( (This)->lpVtbl -> FlushCache(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapSystemHealthAgentBinding_INTERFACE_DEFINED__ */


#ifndef __INapSystemHealthAgentBinding2_INTERFACE_DEFINED__
#define __INapSystemHealthAgentBinding2_INTERFACE_DEFINED__

/* interface INapSystemHealthAgentBinding2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapSystemHealthAgentBinding2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1140C38E-5100-4ea1-8D43-87D326724028")
    INapSystemHealthAgentBinding2 : public INapSystemHealthAgentBinding
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemIsolationInfoEx( 
            /* [out] */ __RPC__deref_out_opt IsolationInfoEx **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapSystemHealthAgentBinding2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapSystemHealthAgentBinding2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapSystemHealthAgentBinding2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapSystemHealthAgentBinding2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INapSystemHealthAgentBinding2 * This,
            /* [in] */ SystemHealthEntityId id,
            /* [in] */ __RPC__in_opt INapSystemHealthAgentCallback *callback);
        
        HRESULT ( STDMETHODCALLTYPE *Uninitialize )( 
            __RPC__in INapSystemHealthAgentBinding2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifySoHChange )( 
            __RPC__in INapSystemHealthAgentBinding2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemIsolationInfo )( 
            __RPC__in INapSystemHealthAgentBinding2 * This,
            /* [out] */ __RPC__deref_out_opt IsolationInfo **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections);
        
        HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            __RPC__in INapSystemHealthAgentBinding2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemIsolationInfoEx )( 
            __RPC__in INapSystemHealthAgentBinding2 * This,
            /* [out] */ __RPC__deref_out_opt IsolationInfoEx **isolationInfo,
            /* [out] */ __RPC__out BOOL *unknownConnections);
        
        END_INTERFACE
    } INapSystemHealthAgentBinding2Vtbl;

    interface INapSystemHealthAgentBinding2
    {
        CONST_VTBL struct INapSystemHealthAgentBinding2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapSystemHealthAgentBinding2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapSystemHealthAgentBinding2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapSystemHealthAgentBinding2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapSystemHealthAgentBinding2_Initialize(This,id,callback)	\
    ( (This)->lpVtbl -> Initialize(This,id,callback) ) 

#define INapSystemHealthAgentBinding2_Uninitialize(This)	\
    ( (This)->lpVtbl -> Uninitialize(This) ) 

#define INapSystemHealthAgentBinding2_NotifySoHChange(This)	\
    ( (This)->lpVtbl -> NotifySoHChange(This) ) 

#define INapSystemHealthAgentBinding2_GetSystemIsolationInfo(This,isolationInfo,unknownConnections)	\
    ( (This)->lpVtbl -> GetSystemIsolationInfo(This,isolationInfo,unknownConnections) ) 

#define INapSystemHealthAgentBinding2_FlushCache(This)	\
    ( (This)->lpVtbl -> FlushCache(This) ) 


#define INapSystemHealthAgentBinding2_GetSystemIsolationInfoEx(This,isolationInfo,unknownConnections)	\
    ( (This)->lpVtbl -> GetSystemIsolationInfoEx(This,isolationInfo,unknownConnections) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapSystemHealthAgentBinding2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_napsystemhealthagent_0000_0002 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_napsystemhealthagent_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napsystemhealthagent_0000_0002_v0_0_s_ifspec;

#ifndef __INapSystemHealthAgentCallback_INTERFACE_DEFINED__
#define __INapSystemHealthAgentCallback_INTERFACE_DEFINED__

/* interface INapSystemHealthAgentCallback */
/* [unique][async_uuid][uuid][object] */ 


EXTERN_C const IID IID_INapSystemHealthAgentCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1072A57-214F-4ee2-8377-14EF140CD9F3")
    INapSystemHealthAgentCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSoHRequest( 
            /* [in] */ __RPC__in_opt INapSystemHealthAgentRequest *request) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessSoHResponse( 
            /* [in] */ __RPC__in_opt INapSystemHealthAgentRequest *request) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifySystemIsolationStateChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFixupInfo( 
            /* [out] */ __RPC__deref_out_opt FixupInfo **info) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareSoHRequests( 
            /* [in] */ __RPC__in const SoHRequest *lhs,
            /* [in] */ __RPC__in const SoHRequest *rhs,
            /* [out] */ __RPC__out BOOL *isEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyOrphanedSoHRequest( 
            /* [in] */ __RPC__in const CorrelationId *correlationId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapSystemHealthAgentCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapSystemHealthAgentCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapSystemHealthAgentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHRequest )( 
            __RPC__in INapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in_opt INapSystemHealthAgentRequest *request);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSoHResponse )( 
            __RPC__in INapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in_opt INapSystemHealthAgentRequest *request);
        
        HRESULT ( STDMETHODCALLTYPE *NotifySystemIsolationStateChange )( 
            __RPC__in INapSystemHealthAgentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFixupInfo )( 
            __RPC__in INapSystemHealthAgentCallback * This,
            /* [out] */ __RPC__deref_out_opt FixupInfo **info);
        
        HRESULT ( STDMETHODCALLTYPE *CompareSoHRequests )( 
            __RPC__in INapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in const SoHRequest *lhs,
            /* [in] */ __RPC__in const SoHRequest *rhs,
            /* [out] */ __RPC__out BOOL *isEqual);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyOrphanedSoHRequest )( 
            __RPC__in INapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in const CorrelationId *correlationId);
        
        END_INTERFACE
    } INapSystemHealthAgentCallbackVtbl;

    interface INapSystemHealthAgentCallback
    {
        CONST_VTBL struct INapSystemHealthAgentCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapSystemHealthAgentCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapSystemHealthAgentCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapSystemHealthAgentCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapSystemHealthAgentCallback_GetSoHRequest(This,request)	\
    ( (This)->lpVtbl -> GetSoHRequest(This,request) ) 

#define INapSystemHealthAgentCallback_ProcessSoHResponse(This,request)	\
    ( (This)->lpVtbl -> ProcessSoHResponse(This,request) ) 

#define INapSystemHealthAgentCallback_NotifySystemIsolationStateChange(This)	\
    ( (This)->lpVtbl -> NotifySystemIsolationStateChange(This) ) 

#define INapSystemHealthAgentCallback_GetFixupInfo(This,info)	\
    ( (This)->lpVtbl -> GetFixupInfo(This,info) ) 

#define INapSystemHealthAgentCallback_CompareSoHRequests(This,lhs,rhs,isEqual)	\
    ( (This)->lpVtbl -> CompareSoHRequests(This,lhs,rhs,isEqual) ) 

#define INapSystemHealthAgentCallback_NotifyOrphanedSoHRequest(This,correlationId)	\
    ( (This)->lpVtbl -> NotifyOrphanedSoHRequest(This,correlationId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapSystemHealthAgentCallback_INTERFACE_DEFINED__ */


#ifndef __AsyncINapSystemHealthAgentCallback_INTERFACE_DEFINED__
#define __AsyncINapSystemHealthAgentCallback_INTERFACE_DEFINED__

/* interface AsyncINapSystemHealthAgentCallback */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_AsyncINapSystemHealthAgentCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("860D8FD9-0219-43ea-AE7F-59611F4CC16A")
    AsyncINapSystemHealthAgentCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin_GetSoHRequest( 
            /* [in] */ __RPC__in_opt INapSystemHealthAgentRequest *request) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_GetSoHRequest( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_ProcessSoHResponse( 
            /* [in] */ __RPC__in_opt INapSystemHealthAgentRequest *request) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_ProcessSoHResponse( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_NotifySystemIsolationStateChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_NotifySystemIsolationStateChange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_GetFixupInfo( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_GetFixupInfo( 
            /* [out] */ __RPC__deref_out_opt FixupInfo **info) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_CompareSoHRequests( 
            /* [in] */ __RPC__in const SoHRequest *lhs,
            /* [in] */ __RPC__in const SoHRequest *rhs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_CompareSoHRequests( 
            /* [out] */ __RPC__out BOOL *isEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_NotifyOrphanedSoHRequest( 
            /* [in] */ __RPC__in const CorrelationId *correlationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_NotifyOrphanedSoHRequest( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AsyncINapSystemHealthAgentCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_GetSoHRequest )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in_opt INapSystemHealthAgentRequest *request);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_GetSoHRequest )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_ProcessSoHResponse )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in_opt INapSystemHealthAgentRequest *request);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_ProcessSoHResponse )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_NotifySystemIsolationStateChange )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_NotifySystemIsolationStateChange )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_GetFixupInfo )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_GetFixupInfo )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This,
            /* [out] */ __RPC__deref_out_opt FixupInfo **info);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_CompareSoHRequests )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in const SoHRequest *lhs,
            /* [in] */ __RPC__in const SoHRequest *rhs);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_CompareSoHRequests )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This,
            /* [out] */ __RPC__out BOOL *isEqual);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_NotifyOrphanedSoHRequest )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This,
            /* [in] */ __RPC__in const CorrelationId *correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_NotifyOrphanedSoHRequest )( 
            __RPC__in AsyncINapSystemHealthAgentCallback * This);
        
        END_INTERFACE
    } AsyncINapSystemHealthAgentCallbackVtbl;

    interface AsyncINapSystemHealthAgentCallback
    {
        CONST_VTBL struct AsyncINapSystemHealthAgentCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AsyncINapSystemHealthAgentCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define AsyncINapSystemHealthAgentCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define AsyncINapSystemHealthAgentCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define AsyncINapSystemHealthAgentCallback_Begin_GetSoHRequest(This,request)	\
    ( (This)->lpVtbl -> Begin_GetSoHRequest(This,request) ) 

#define AsyncINapSystemHealthAgentCallback_Finish_GetSoHRequest(This)	\
    ( (This)->lpVtbl -> Finish_GetSoHRequest(This) ) 

#define AsyncINapSystemHealthAgentCallback_Begin_ProcessSoHResponse(This,request)	\
    ( (This)->lpVtbl -> Begin_ProcessSoHResponse(This,request) ) 

#define AsyncINapSystemHealthAgentCallback_Finish_ProcessSoHResponse(This)	\
    ( (This)->lpVtbl -> Finish_ProcessSoHResponse(This) ) 

#define AsyncINapSystemHealthAgentCallback_Begin_NotifySystemIsolationStateChange(This)	\
    ( (This)->lpVtbl -> Begin_NotifySystemIsolationStateChange(This) ) 

#define AsyncINapSystemHealthAgentCallback_Finish_NotifySystemIsolationStateChange(This)	\
    ( (This)->lpVtbl -> Finish_NotifySystemIsolationStateChange(This) ) 

#define AsyncINapSystemHealthAgentCallback_Begin_GetFixupInfo(This)	\
    ( (This)->lpVtbl -> Begin_GetFixupInfo(This) ) 

#define AsyncINapSystemHealthAgentCallback_Finish_GetFixupInfo(This,info)	\
    ( (This)->lpVtbl -> Finish_GetFixupInfo(This,info) ) 

#define AsyncINapSystemHealthAgentCallback_Begin_CompareSoHRequests(This,lhs,rhs)	\
    ( (This)->lpVtbl -> Begin_CompareSoHRequests(This,lhs,rhs) ) 

#define AsyncINapSystemHealthAgentCallback_Finish_CompareSoHRequests(This,isEqual)	\
    ( (This)->lpVtbl -> Finish_CompareSoHRequests(This,isEqual) ) 

#define AsyncINapSystemHealthAgentCallback_Begin_NotifyOrphanedSoHRequest(This,correlationId)	\
    ( (This)->lpVtbl -> Begin_NotifyOrphanedSoHRequest(This,correlationId) ) 

#define AsyncINapSystemHealthAgentCallback_Finish_NotifyOrphanedSoHRequest(This)	\
    ( (This)->lpVtbl -> Finish_NotifyOrphanedSoHRequest(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __AsyncINapSystemHealthAgentCallback_INTERFACE_DEFINED__ */


#ifndef __INapSystemHealthAgentRequest_INTERFACE_DEFINED__
#define __INapSystemHealthAgentRequest_INTERFACE_DEFINED__

/* interface INapSystemHealthAgentRequest */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapSystemHealthAgentRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5B360A69-212D-440d-B398-7EEFD497853A")
    INapSystemHealthAgentRequest : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCorrelationId( 
            /* [out] */ __RPC__out CorrelationId *correlationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringCorrelationId( 
            /* [out] */ __RPC__deref_out_opt StringCorrelationId **correlationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSoHRequest( 
            /* [in] */ __RPC__in const SoHRequest *sohRequest,
            /* [in] */ BOOL cacheSohForLaterUse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoHRequest( 
            /* [out] */ __RPC__deref_out_opt SoHRequest **sohRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoHResponse( 
            /* [out] */ __RPC__deref_out_opt SoHResponse **sohResponse,
            /* [out] */ __RPC__out UINT8 *flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCacheSoHFlag( 
            __RPC__in BOOL *cacheSohForLaterUse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapSystemHealthAgentRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapSystemHealthAgentRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapSystemHealthAgentRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapSystemHealthAgentRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorrelationId )( 
            __RPC__in INapSystemHealthAgentRequest * This,
            /* [out] */ __RPC__out CorrelationId *correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringCorrelationId )( 
            __RPC__in INapSystemHealthAgentRequest * This,
            /* [out] */ __RPC__deref_out_opt StringCorrelationId **correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *SetSoHRequest )( 
            __RPC__in INapSystemHealthAgentRequest * This,
            /* [in] */ __RPC__in const SoHRequest *sohRequest,
            /* [in] */ BOOL cacheSohForLaterUse);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHRequest )( 
            __RPC__in INapSystemHealthAgentRequest * This,
            /* [out] */ __RPC__deref_out_opt SoHRequest **sohRequest);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHResponse )( 
            __RPC__in INapSystemHealthAgentRequest * This,
            /* [out] */ __RPC__deref_out_opt SoHResponse **sohResponse,
            /* [out] */ __RPC__out UINT8 *flags);
        
        HRESULT ( STDMETHODCALLTYPE *GetCacheSoHFlag )( 
            __RPC__in INapSystemHealthAgentRequest * This,
            __RPC__in BOOL *cacheSohForLaterUse);
        
        END_INTERFACE
    } INapSystemHealthAgentRequestVtbl;

    interface INapSystemHealthAgentRequest
    {
        CONST_VTBL struct INapSystemHealthAgentRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapSystemHealthAgentRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapSystemHealthAgentRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapSystemHealthAgentRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapSystemHealthAgentRequest_GetCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetCorrelationId(This,correlationId) ) 

#define INapSystemHealthAgentRequest_GetStringCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetStringCorrelationId(This,correlationId) ) 

#define INapSystemHealthAgentRequest_SetSoHRequest(This,sohRequest,cacheSohForLaterUse)	\
    ( (This)->lpVtbl -> SetSoHRequest(This,sohRequest,cacheSohForLaterUse) ) 

#define INapSystemHealthAgentRequest_GetSoHRequest(This,sohRequest)	\
    ( (This)->lpVtbl -> GetSoHRequest(This,sohRequest) ) 

#define INapSystemHealthAgentRequest_GetSoHResponse(This,sohResponse,flags)	\
    ( (This)->lpVtbl -> GetSoHResponse(This,sohResponse,flags) ) 

#define INapSystemHealthAgentRequest_GetCacheSoHFlag(This,cacheSohForLaterUse)	\
    ( (This)->lpVtbl -> GetCacheSoHFlag(This,cacheSohForLaterUse) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapSystemHealthAgentRequest_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_napsystemhealthagent_0000_0004 */
/* [local] */ 

// Declarations of CLSIDs of objects provided  
// by the system. Link to uuid.lib to get them 
// defined.                                    
EXTERN_C const CLSID 
   CLSID_NapSystemHealthAgentBinding;


extern RPC_IF_HANDLE __MIDL_itf_napsystemhealthagent_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napsystemhealthagent_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\napservermanagement.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for napservermanagement.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __napservermanagement_h__
#define __napservermanagement_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INapServerInfo_FWD_DEFINED__
#define __INapServerInfo_FWD_DEFINED__
typedef interface INapServerInfo INapServerInfo;
#endif 	/* __INapServerInfo_FWD_DEFINED__ */


#ifndef __INapServerManagement_FWD_DEFINED__
#define __INapServerManagement_FWD_DEFINED__
typedef interface INapServerManagement INapServerManagement;
#endif 	/* __INapServerManagement_FWD_DEFINED__ */


/* header files for imported files */
#include "NapTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __INapServerInfo_INTERFACE_DEFINED__
#define __INapServerInfo_INTERFACE_DEFINED__

/* interface INapServerInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapServerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("599F9021-5643-4965-9949-E88975EFFF0E")
    INapServerInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNapServerInfo( 
            /* [out] */ __RPC__deref_out_opt CountedString **serverName,
            /* [out] */ __RPC__deref_out_opt CountedString **serverDescription,
            /* [out] */ __RPC__deref_out_opt CountedString **protocolVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisteredSystemHealthValidators( 
            /* [out] */ __RPC__out SystemHealthEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) NapComponentRegistrationInfo **validators,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) CLSID **validatorClsids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFailureCategoryMappings( 
            /* [in] */ SystemHealthEntityId id,
            /* [out] */ __RPC__out FailureCategoryMapping *mapping) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapServerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapServerInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapServerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapServerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNapServerInfo )( 
            __RPC__in INapServerInfo * This,
            /* [out] */ __RPC__deref_out_opt CountedString **serverName,
            /* [out] */ __RPC__deref_out_opt CountedString **serverDescription,
            /* [out] */ __RPC__deref_out_opt CountedString **protocolVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisteredSystemHealthValidators )( 
            __RPC__in INapServerInfo * This,
            /* [out] */ __RPC__out SystemHealthEntityCount *count,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) NapComponentRegistrationInfo **validators,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*count) CLSID **validatorClsids);
        
        HRESULT ( STDMETHODCALLTYPE *GetFailureCategoryMappings )( 
            __RPC__in INapServerInfo * This,
            /* [in] */ SystemHealthEntityId id,
            /* [out] */ __RPC__out FailureCategoryMapping *mapping);
        
        END_INTERFACE
    } INapServerInfoVtbl;

    interface INapServerInfo
    {
        CONST_VTBL struct INapServerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapServerInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapServerInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapServerInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapServerInfo_GetNapServerInfo(This,serverName,serverDescription,protocolVersion)	\
    ( (This)->lpVtbl -> GetNapServerInfo(This,serverName,serverDescription,protocolVersion) ) 

#define INapServerInfo_GetRegisteredSystemHealthValidators(This,count,validators,validatorClsids)	\
    ( (This)->lpVtbl -> GetRegisteredSystemHealthValidators(This,count,validators,validatorClsids) ) 

#define INapServerInfo_GetFailureCategoryMappings(This,id,mapping)	\
    ( (This)->lpVtbl -> GetFailureCategoryMappings(This,id,mapping) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapServerInfo_INTERFACE_DEFINED__ */


#ifndef __INapServerManagement_INTERFACE_DEFINED__
#define __INapServerManagement_INTERFACE_DEFINED__

/* interface INapServerManagement */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapServerManagement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9DE543E7-0F23-47e0-A8BC-971A894F86D4")
    INapServerManagement : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterSystemHealthValidator( 
            /* [in] */ __RPC__in const NapComponentRegistrationInfo *validator,
            /* [in] */ __RPC__in const CLSID *validatorClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterSystemHealthValidator( 
            /* [in] */ SystemHealthEntityId id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFailureCategoryMappings( 
            /* [in] */ SystemHealthEntityId id,
            /* [in] */ const FailureCategoryMapping mapping) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapServerManagementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapServerManagement * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapServerManagement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapServerManagement * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterSystemHealthValidator )( 
            __RPC__in INapServerManagement * This,
            /* [in] */ __RPC__in const NapComponentRegistrationInfo *validator,
            /* [in] */ __RPC__in const CLSID *validatorClsid);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterSystemHealthValidator )( 
            __RPC__in INapServerManagement * This,
            /* [in] */ SystemHealthEntityId id);
        
        HRESULT ( STDMETHODCALLTYPE *SetFailureCategoryMappings )( 
            __RPC__in INapServerManagement * This,
            /* [in] */ SystemHealthEntityId id,
            /* [in] */ const FailureCategoryMapping mapping);
        
        END_INTERFACE
    } INapServerManagementVtbl;

    interface INapServerManagement
    {
        CONST_VTBL struct INapServerManagementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapServerManagement_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapServerManagement_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapServerManagement_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapServerManagement_RegisterSystemHealthValidator(This,validator,validatorClsid)	\
    ( (This)->lpVtbl -> RegisterSystemHealthValidator(This,validator,validatorClsid) ) 

#define INapServerManagement_UnregisterSystemHealthValidator(This,id)	\
    ( (This)->lpVtbl -> UnregisterSystemHealthValidator(This,id) ) 

#define INapServerManagement_SetFailureCategoryMappings(This,id,mapping)	\
    ( (This)->lpVtbl -> SetFailureCategoryMappings(This,id,mapping) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapServerManagement_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_napservermanagement_0000_0002 */
/* [local] */ 

// Declarations of CLSIDs of objects provided  
// by the system. Link to uuid.lib to get them 
// defined.                                    
EXTERN_C const CLSID 
   CLSID_NapServerInfo;
EXTERN_C const CLSID 
   CLSID_NapServerManagement;


extern RPC_IF_HANDLE __MIDL_itf_napservermanagement_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napservermanagement_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\napsystemhealthvalidator.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for napsystemhealthvalidator.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __napsystemhealthvalidator_h__
#define __napsystemhealthvalidator_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INapSystemHealthValidator_FWD_DEFINED__
#define __INapSystemHealthValidator_FWD_DEFINED__
typedef interface INapSystemHealthValidator INapSystemHealthValidator;
#endif 	/* __INapSystemHealthValidator_FWD_DEFINED__ */


#ifndef __AsyncINapSystemHealthValidator_FWD_DEFINED__
#define __AsyncINapSystemHealthValidator_FWD_DEFINED__
typedef interface AsyncINapSystemHealthValidator AsyncINapSystemHealthValidator;
#endif 	/* __AsyncINapSystemHealthValidator_FWD_DEFINED__ */


#ifndef __INapServerCallback_FWD_DEFINED__
#define __INapServerCallback_FWD_DEFINED__
typedef interface INapServerCallback INapServerCallback;
#endif 	/* __INapServerCallback_FWD_DEFINED__ */


#ifndef __INapSystemHealthValidationRequest_FWD_DEFINED__
#define __INapSystemHealthValidationRequest_FWD_DEFINED__
typedef interface INapSystemHealthValidationRequest INapSystemHealthValidationRequest;
#endif 	/* __INapSystemHealthValidationRequest_FWD_DEFINED__ */


#ifndef __INapSystemHealthValidationRequest2_FWD_DEFINED__
#define __INapSystemHealthValidationRequest2_FWD_DEFINED__
typedef interface INapSystemHealthValidationRequest2 INapSystemHealthValidationRequest2;
#endif 	/* __INapSystemHealthValidationRequest2_FWD_DEFINED__ */


/* header files for imported files */
#include "NapTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_napsystemhealthvalidator_0000_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_napsystemhealthvalidator_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_napsystemhealthvalidator_0000_0000_v0_0_s_ifspec;

#ifndef __INapSystemHealthValidator_INTERFACE_DEFINED__
#define __INapSystemHealthValidator_INTERFACE_DEFINED__

/* interface INapSystemHealthValidator */
/* [unique][async_uuid][uuid][object] */ 


EXTERN_C const IID IID_INapSystemHealthValidator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF43D87C-5B6D-4820-8620-868907FE07D3")
    INapSystemHealthValidator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ __RPC__in_opt INapSystemHealthValidationRequest *request,
            /* [in] */ UINT32 hintTimeOutInMsec,
            /* [in] */ __RPC__in_opt INapServerCallback *callback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapSystemHealthValidatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapSystemHealthValidator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapSystemHealthValidator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapSystemHealthValidator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            __RPC__in INapSystemHealthValidator * This,
            /* [in] */ __RPC__in_opt INapSystemHealthValidationRequest *request,
            /* [in] */ UINT32 hintTimeOutInMsec,
            /* [in] */ __RPC__in_opt INapServerCallback *callback);
        
        END_INTERFACE
    } INapSystemHealthValidatorVtbl;

    interface INapSystemHealthValidator
    {
        CONST_VTBL struct INapSystemHealthValidatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapSystemHealthValidator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapSystemHealthValidator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapSystemHealthValidator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapSystemHealthValidator_Validate(This,request,hintTimeOutInMsec,callback)	\
    ( (This)->lpVtbl -> Validate(This,request,hintTimeOutInMsec,callback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapSystemHealthValidator_INTERFACE_DEFINED__ */


#ifndef __AsyncINapSystemHealthValidator_INTERFACE_DEFINED__
#define __AsyncINapSystemHealthValidator_INTERFACE_DEFINED__

/* interface AsyncINapSystemHealthValidator */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_AsyncINapSystemHealthValidator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2516031A-A391-454d-B53D-C5DC84C7F2DB")
    AsyncINapSystemHealthValidator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin_Validate( 
            /* [in] */ __RPC__in_opt INapSystemHealthValidationRequest *request,
            /* [in] */ UINT32 hintTimeOutInMsec,
            /* [in] */ __RPC__in_opt INapServerCallback *callback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_Validate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AsyncINapSystemHealthValidatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in AsyncINapSystemHealthValidator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in AsyncINapSystemHealthValidator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in AsyncINapSystemHealthValidator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_Validate )( 
            __RPC__in AsyncINapSystemHealthValidator * This,
            /* [in] */ __RPC__in_opt INapSystemHealthValidationRequest *request,
            /* [in] */ UINT32 hintTimeOutInMsec,
            /* [in] */ __RPC__in_opt INapServerCallback *callback);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_Validate )( 
            __RPC__in AsyncINapSystemHealthValidator * This);
        
        END_INTERFACE
    } AsyncINapSystemHealthValidatorVtbl;

    interface AsyncINapSystemHealthValidator
    {
        CONST_VTBL struct AsyncINapSystemHealthValidatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AsyncINapSystemHealthValidator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define AsyncINapSystemHealthValidator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define AsyncINapSystemHealthValidator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define AsyncINapSystemHealthValidator_Begin_Validate(This,request,hintTimeOutInMsec,callback)	\
    ( (This)->lpVtbl -> Begin_Validate(This,request,hintTimeOutInMsec,callback) ) 

#define AsyncINapSystemHealthValidator_Finish_Validate(This)	\
    ( (This)->lpVtbl -> Finish_Validate(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __AsyncINapSystemHealthValidator_INTERFACE_DEFINED__ */


#ifndef __INapServerCallback_INTERFACE_DEFINED__
#define __INapServerCallback_INTERFACE_DEFINED__

/* interface INapServerCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapServerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09C20568-F30C-489b-AE9C-4930AD7F165F")
    INapServerCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnComplete( 
            /* [in] */ __RPC__in_opt INapSystemHealthValidationRequest *request,
            /* [in] */ HRESULT errorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapServerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapServerCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapServerCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapServerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnComplete )( 
            __RPC__in INapServerCallback * This,
            /* [in] */ __RPC__in_opt INapSystemHealthValidationRequest *request,
            /* [in] */ HRESULT errorCode);
        
        END_INTERFACE
    } INapServerCallbackVtbl;

    interface INapServerCallback
    {
        CONST_VTBL struct INapServerCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapServerCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapServerCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapServerCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapServerCallback_OnComplete(This,request,errorCode)	\
    ( (This)->lpVtbl -> OnComplete(This,request,errorCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapServerCallback_INTERFACE_DEFINED__ */


#ifndef __INapSystemHealthValidationRequest_INTERFACE_DEFINED__
#define __INapSystemHealthValidationRequest_INTERFACE_DEFINED__

/* interface INapSystemHealthValidationRequest */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapSystemHealthValidationRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ADACB3A0-D4F4-4f17-8933-51D60FCCA606")
    INapSystemHealthValidationRequest : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCorrelationId( 
            /* [out] */ __RPC__out CorrelationId *correlationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringCorrelationId( 
            /* [out] */ __RPC__deref_out_opt StringCorrelationId **correlationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMachineName( 
            /* [out] */ __RPC__deref_out_opt CountedString **machineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoHRequest( 
            /* [out] */ __RPC__deref_out_opt SoHRequest **sohRequest,
            /* [out] */ __RPC__out BOOL *napSystemGenerated) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSoHResponse( 
            /* [in] */ __RPC__in const SoHResponse *sohResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSoHResponse( 
            /* [out] */ __RPC__deref_out_opt SoHResponse **sohResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrivateData( 
            /* [in] */ __RPC__in const PrivateData *privateData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateData( 
            /* [out] */ __RPC__deref_out_opt PrivateData **privateData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapSystemHealthValidationRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapSystemHealthValidationRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapSystemHealthValidationRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapSystemHealthValidationRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorrelationId )( 
            __RPC__in INapSystemHealthValidationRequest * This,
            /* [out] */ __RPC__out CorrelationId *correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringCorrelationId )( 
            __RPC__in INapSystemHealthValidationRequest * This,
            /* [out] */ __RPC__deref_out_opt StringCorrelationId **correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineName )( 
            __RPC__in INapSystemHealthValidationRequest * This,
            /* [out] */ __RPC__deref_out_opt CountedString **machineName);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHRequest )( 
            __RPC__in INapSystemHealthValidationRequest * This,
            /* [out] */ __RPC__deref_out_opt SoHRequest **sohRequest,
            /* [out] */ __RPC__out BOOL *napSystemGenerated);
        
        HRESULT ( STDMETHODCALLTYPE *SetSoHResponse )( 
            __RPC__in INapSystemHealthValidationRequest * This,
            /* [in] */ __RPC__in const SoHResponse *sohResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHResponse )( 
            __RPC__in INapSystemHealthValidationRequest * This,
            /* [out] */ __RPC__deref_out_opt SoHResponse **sohResponse);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            __RPC__in INapSystemHealthValidationRequest * This,
            /* [in] */ __RPC__in const PrivateData *privateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            __RPC__in INapSystemHealthValidationRequest * This,
            /* [out] */ __RPC__deref_out_opt PrivateData **privateData);
        
        END_INTERFACE
    } INapSystemHealthValidationRequestVtbl;

    interface INapSystemHealthValidationRequest
    {
        CONST_VTBL struct INapSystemHealthValidationRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapSystemHealthValidationRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapSystemHealthValidationRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapSystemHealthValidationRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapSystemHealthValidationRequest_GetCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetCorrelationId(This,correlationId) ) 

#define INapSystemHealthValidationRequest_GetStringCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetStringCorrelationId(This,correlationId) ) 

#define INapSystemHealthValidationRequest_GetMachineName(This,machineName)	\
    ( (This)->lpVtbl -> GetMachineName(This,machineName) ) 

#define INapSystemHealthValidationRequest_GetSoHRequest(This,sohRequest,napSystemGenerated)	\
    ( (This)->lpVtbl -> GetSoHRequest(This,sohRequest,napSystemGenerated) ) 

#define INapSystemHealthValidationRequest_SetSoHResponse(This,sohResponse)	\
    ( (This)->lpVtbl -> SetSoHResponse(This,sohResponse) ) 

#define INapSystemHealthValidationRequest_GetSoHResponse(This,sohResponse)	\
    ( (This)->lpVtbl -> GetSoHResponse(This,sohResponse) ) 

#define INapSystemHealthValidationRequest_SetPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,privateData) ) 

#define INapSystemHealthValidationRequest_GetPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,privateData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapSystemHealthValidationRequest_INTERFACE_DEFINED__ */


#ifndef __INapSystemHealthValidationRequest2_INTERFACE_DEFINED__
#define __INapSystemHealthValidationRequest2_INTERFACE_DEFINED__

/* interface INapSystemHealthValidationRequest2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INapSystemHealthValidationRequest2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("91A5D706-0CB4-4a84-8315-9380D453E385")
    INapSystemHealthValidationRequest2 : public INapSystemHealthValidationRequest
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConfigID( 
            /* [out] */ __RPC__out UINT32 *configID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INapSystemHealthValidationRequest2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INapSystemHealthValidationRequest2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INapSystemHealthValidationRequest2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorrelationId )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [out] */ __RPC__out CorrelationId *correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringCorrelationId )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [out] */ __RPC__deref_out_opt StringCorrelationId **correlationId);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineName )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [out] */ __RPC__deref_out_opt CountedString **machineName);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHRequest )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [out] */ __RPC__deref_out_opt SoHRequest **sohRequest,
            /* [out] */ __RPC__out BOOL *napSystemGenerated);
        
        HRESULT ( STDMETHODCALLTYPE *SetSoHResponse )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [in] */ __RPC__in const SoHResponse *sohResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetSoHResponse )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [out] */ __RPC__deref_out_opt SoHResponse **sohResponse);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [in] */ __RPC__in const PrivateData *privateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [out] */ __RPC__deref_out_opt PrivateData **privateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfigID )( 
            __RPC__in INapSystemHealthValidationRequest2 * This,
            /* [out] */ __RPC__out UINT32 *configID);
        
        END_INTERFACE
    } INapSystemHealthValidationRequest2Vtbl;

    interface INapSystemHealthValidationRequest2
    {
        CONST_VTBL struct INapSystemHealthValidationRequest2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INapSystemHealthValidationRequest2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INapSystemHealthValidationRequest2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INapSystemHealthValidationRequest2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INapSystemHealthValidationRequest2_GetCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetCorrelationId(This,correlationId) ) 

#define INapSystemHealthValidationRequest2_GetStringCorrelationId(This,correlationId)	\
    ( (This)->lpVtbl -> GetStringCorrelationId(This,correlationId) ) 

#define INapSystemHealthValidationRequest2_GetMachineName(This,machineName)	\
    ( (This)->lpVtbl -> GetMachineName(This,machineName) ) 

#define INapSystemHealthValidationRequest2_GetSoHRequest(This,sohRequest,napSystemGenerated)	\
    ( (This)->lpVtbl -> GetSoHRequest(This,sohRequest,napSystemGenerated) ) 

#define INapSystemHealthValidationRequest2_SetSoHResponse(This,sohResponse)	\
    ( (This)->lpVtbl -> SetSoHResponse(This,sohResponse) ) 

#define INapSystemHealthValidationRequest2_GetSoHResponse(This,sohResponse)	\
    ( (This)->lpVtbl -> GetSoHResponse(This,sohResponse) ) 

#define INapSystemHealthValidationRequest2_SetPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,privateData) ) 

#define INapSystemHealthValidationRequest2_GetPrivateData(This,privateData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,privateData) ) 


#define INapSystemHealthValidationRequest2_GetConfigID(This,configID)	\
    ( (This)->lpVtbl -> GetConfigID(This,configID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INapSystemHealthValidationRequest2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ndattrib.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for ndattrib.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __ndattrib_h__
#define __ndattrib_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_ndattrib_0000_0000 */
/* [local] */ 

//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2004.
//
//---------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif
#define NDF_ERROR_START (0xF900)
//error code deprecated
#define NDF_E_LENGTH_EXCEEDED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, NDF_ERROR_START)
//
// MessageId: NDF_E_NOHELPERCLASS
//
// MessageText:
//
// Helper Class parameter not specified to NdfCreateIncident API.
//
#define NDF_E_NOHELPERCLASS                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, NDF_ERROR_START + 1)
//error code deprecated
#define NDF_E_CANCELLED                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, NDF_ERROR_START + 2)
//error code deprecated
#define NDF_E_DISABLED                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, NDF_ERROR_START + 4)
//
// MessageId: NDF_E_BAD_PARAM
//
// MessageText:
//
// Inavlid parameter.
//
#define NDF_E_BAD_PARAM						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, NDF_ERROR_START + 5)
//
// MessageId: NDF_E_VALIDATION
//
// MessageText:
//
// Diagnosis failed to resolve the problems.
//
#define NDF_E_VALIDATION					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, NDF_ERROR_START + 6)
//
// MessageId: NDF_E_UNKNOWN
//
// MessageText:
//
// Diagnostics session result is unkown, the diagnostics phase did not complete.
//
#define NDF_E_UNKNOWN                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, NDF_ERROR_START + 7)
//
// MessageId: NDF_E_PROBLEM_PRESENT
//
// MessageText:
//
// Diagnostics session finished with problems still present.
//
#define NDF_E_PROBLEM_PRESENT                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, NDF_ERROR_START + 8)
typedef /* [v1_enum] */ 
enum tagATTRIBUTE_TYPE
    {	AT_INVALID	= 0,
	AT_BOOLEAN	= ( AT_INVALID + 1 ) ,
	AT_INT8	= ( AT_BOOLEAN + 1 ) ,
	AT_UINT8	= ( AT_INT8 + 1 ) ,
	AT_INT16	= ( AT_UINT8 + 1 ) ,
	AT_UINT16	= ( AT_INT16 + 1 ) ,
	AT_INT32	= ( AT_UINT16 + 1 ) ,
	AT_UINT32	= ( AT_INT32 + 1 ) ,
	AT_INT64	= ( AT_UINT32 + 1 ) ,
	AT_UINT64	= ( AT_INT64 + 1 ) ,
	AT_STRING	= ( AT_UINT64 + 1 ) ,
	AT_GUID	= ( AT_STRING + 1 ) ,
	AT_LIFE_TIME	= ( AT_GUID + 1 ) ,
	AT_SOCKADDR	= ( AT_LIFE_TIME + 1 ) ,
	AT_OCTET_STRING	= ( AT_SOCKADDR + 1 ) 
    } 	ATTRIBUTE_TYPE;

typedef struct tagOCTET_STRING
    {
    DWORD dwLength;
    BYTE *lpValue;
    } 	OCTET_STRING;

typedef struct tagOCTET_STRING *POCTET_STRING;

typedef struct tagLIFE_TIME
    {
    FILETIME startTime;
    FILETIME endTime;
    } 	LIFE_TIME;

typedef struct tagLIFE_TIME *PLIFE_TIME;

typedef struct tagSOCK_ADDR
    {
    USHORT family;
    CHAR data[ 126 ];
    } 	DIAG_SOCKADDR;

typedef struct tagSOCK_ADDR *PDIAG_SOCK_ADDR;

typedef struct tagHELPER_ATTRIBUTE
    {
    LPWSTR pwszName;
    ATTRIBUTE_TYPE type;
    union 
        {
        BOOL Boolean;
        char Char;
        byte Byte;
        short Short;
        WORD Word;
        int Int;
        DWORD DWord;
        LONGLONG Int64;
        ULONGLONG UInt64;
        LPWSTR PWStr;
        GUID Guid;
        LIFE_TIME LifeTime;
        DIAG_SOCKADDR Address;
        OCTET_STRING OctetString;
        } 	;
    } 	HELPER_ATTRIBUTE;

typedef struct tagHELPER_ATTRIBUTE *PHELPER_ATTRIBUTE;

typedef /* [v1_enum] */ 
enum tagREPAIR_SCOPE
    {	RS_SYSTEM	= 0,
	RS_USER	= ( RS_SYSTEM + 1 ) ,
	RS_APPLICATION	= ( RS_USER + 1 ) ,
	RS_PROCESS	= ( RS_APPLICATION + 1 ) 
    } 	REPAIR_SCOPE;

typedef /* [v1_enum] */ enum tagREPAIR_SCOPE *PREPAIR_SCOPE;

typedef /* [public][public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_ndattrib_0000_0000_0002
    {	RR_NOROLLBACK	= 0,
	RR_ROLLBACK	= ( RR_NOROLLBACK + 1 ) ,
	RR_NORISK	= ( RR_ROLLBACK + 1 ) 
    } 	REPAIR_RISK;

typedef /* [public][public][public][public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_ndattrib_0000_0000_0003
    {	UIT_INVALID	= 0,
	UIT_NONE	= 1,
	UIT_SHELL_COMMAND	= ( UIT_NONE + 1 ) ,
	UIT_HELP_PANE	= ( UIT_SHELL_COMMAND + 1 ) ,
	UIT_DUI	= ( UIT_HELP_PANE + 1 ) 
    } 	UI_INFO_TYPE;

typedef struct tagShellCommandInfo
    {
    LPWSTR pwszOperation;
    LPWSTR pwszFile;
    LPWSTR pwszParameters;
    LPWSTR pwszDirectory;
    ULONG nShowCmd;
    } 	ShellCommandInfo;

typedef struct tagShellCommandInfo *PShellCommandInfo;

typedef struct tagUiInfo
    {
    UI_INFO_TYPE type;
    union 
        {
        LPWSTR pwzNull;
        ShellCommandInfo ShellInfo;
        LPWSTR pwzHelpUrl;
        LPWSTR pwzDui;
        } 	;
    } 	UiInfo;

typedef struct tagUiInfo *PUiInfo;

#define RF_WORKAROUND          0x20000000
#define RF_USER_ACTION         0x10000000
#define RF_USER_CONFIRMATION   0x8000000
#define RF_INFORMATION_ONLY    0x2000000
//RF_UI_ONLY is deprecated
#define RF_UI_ONLY             0x1000000
#define RF_SHOW_EVENTS         0x800000
#define RF_VALIDATE_HELPTOPIC  0x400000
#define RF_REPRO               0x200000
#define RF_CONTACT_ADMIN    	  0x20000
#define RF_RESERVED            0x40000000
#define RF_RESERVED_CA         0x80000000
#define RF_RESERVED_LNI        0x10000
typedef struct tagRepairInfo
    {
    GUID guid;
    LPWSTR pwszClassName;
    LPWSTR pwszDescription;
    DWORD sidType;
    long cost;
    ULONG flags;
    REPAIR_SCOPE scope;
    REPAIR_RISK risk;
    UiInfo UiInfo;
    int rootCauseIndex;
    } 	RepairInfo;

typedef struct tagRepairInfo *PRepairInfo;

typedef struct tagRepairInfoEx
    {
    RepairInfo repair;
    USHORT repairRank;
    } 	RepairInfoEx;

typedef struct tagRepairInfoEx *PRepairInfoEx;

#define RCF_ISLEAF         0x1
#define RCF_ISCONFIRMED    0x2
#define RCF_ISTHIRDPARTY   0x4
typedef struct tagRootCauseInfo
    {
    LPWSTR pwszDescription;
    GUID rootCauseID;
    DWORD rootCauseFlags;
    GUID networkInterfaceID;
    RepairInfoEx *pRepairs;
    USHORT repairCount;
    } 	RootCauseInfo;

typedef struct tagRootCauseInfo *PRootCauseInfo;

EXTERN_C HRESULT EncodeHelperAttribute(HELPER_ATTRIBUTE *attribute, BYTE **buf, size_t *bufSize);
EXTERN_C HRESULT DecodeHelperAttribute(BYTE *buf, size_t bufSize, HELPER_ATTRIBUTE *attribute);
EXTERN_C HRESULT EncodeRepairInfo(RepairInfo *info, BYTE **buf, size_t *bufSize);
EXTERN_C HRESULT DecodeRepairInfo(BYTE *buf, size_t bufSize, RepairInfo *info);
EXTERN_C HRESULT EncodeRepairInfoEx(RepairInfoEx *info, BYTE **buf, size_t *bufSize);
EXTERN_C HRESULT DecodeRepairInfoEx(BYTE *buf, size_t bufSize, RepairInfoEx *info);
EXTERN_C HRESULT EncodeRootCauseInfo(RootCauseInfo *info, BYTE **buf, size_t *bufSize);
EXTERN_C HRESULT DecodeRootCauseInfo(BYTE *buf, size_t bufSize, RootCauseInfo *info);
EXTERN_C GUID NetDiagModuleId;
EXTERN_C GUID NetDiagScenarioId;


extern RPC_IF_HANDLE __MIDL_itf_ndattrib_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndattrib_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ndhelper.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for ndhelper.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ndhelper_h__
#define __ndhelper_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INetDiagHelper_FWD_DEFINED__
#define __INetDiagHelper_FWD_DEFINED__
typedef interface INetDiagHelper INetDiagHelper;
#endif 	/* __INetDiagHelper_FWD_DEFINED__ */


#ifndef __INetDiagHelperUtilFactory_FWD_DEFINED__
#define __INetDiagHelperUtilFactory_FWD_DEFINED__
typedef interface INetDiagHelperUtilFactory INetDiagHelperUtilFactory;
#endif 	/* __INetDiagHelperUtilFactory_FWD_DEFINED__ */


#ifndef __INetDiagHelperEx_FWD_DEFINED__
#define __INetDiagHelperEx_FWD_DEFINED__
typedef interface INetDiagHelperEx INetDiagHelperEx;
#endif 	/* __INetDiagHelperEx_FWD_DEFINED__ */


#ifndef __INetDiagHelperInfo_FWD_DEFINED__
#define __INetDiagHelperInfo_FWD_DEFINED__
typedef interface INetDiagHelperInfo INetDiagHelperInfo;
#endif 	/* __INetDiagHelperInfo_FWD_DEFINED__ */


#ifndef __INetDiagExtensibleHelper_FWD_DEFINED__
#define __INetDiagExtensibleHelper_FWD_DEFINED__
typedef interface INetDiagExtensibleHelper INetDiagExtensibleHelper;
#endif 	/* __INetDiagExtensibleHelper_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ndattrib.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_ndhelper_0000_0000 */
/* [local] */ 

//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2007.
//
//---------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif


typedef /* [v1_enum] */ 
enum tagDIAGNOSIS_STATUS
    {	DS_NOT_IMPLEMENTED	= 0,
	DS_CONFIRMED	= ( DS_NOT_IMPLEMENTED + 1 ) ,
	DS_REJECTED	= ( DS_CONFIRMED + 1 ) ,
	DS_INDETERMINATE	= ( DS_REJECTED + 1 ) ,
	DS_DEFERRED	= ( DS_INDETERMINATE + 1 ) ,
	DS_PASSTHROUGH	= ( DS_DEFERRED + 1 ) 
    } 	DIAGNOSIS_STATUS;

typedef /* [v1_enum] */ 
enum tagREPAIR_STATUS
    {	RS_NOT_IMPLEMENTED	= 0,
	RS_REPAIRED	= ( RS_NOT_IMPLEMENTED + 1 ) ,
	RS_UNREPAIRED	= ( RS_REPAIRED + 1 ) ,
	RS_DEFERRED	= ( RS_UNREPAIRED + 1 ) ,
	RS_USER_ACTION	= ( RS_DEFERRED + 1 ) 
    } 	REPAIR_STATUS;

typedef /* [v1_enum] */ 
enum tagPROBLEM_TYPE
    {	PT_INVALID	= 0,
	PT_LOW_HEALTH	= 1,
	PT_LOWER_HEALTH	= 2,
	PT_DOWN_STREAM_HEALTH	= 4,
	PT_HIGH_UTILIZATION	= 8,
	PT_HIGHER_UTILIZATION	= 16,
	PT_UP_STREAM_UTILIZATION	= 32
    } 	PROBLEM_TYPE;

typedef struct tagHYPOTHESIS
    {
    LPWSTR pwszClassName;
    LPWSTR pwszDescription;
    ULONG celt;
    PHELPER_ATTRIBUTE rgAttributes;
    } 	HYPOTHESIS;

typedef struct tagHYPOTHESIS *PHYPOTHESIS;

typedef struct tagHelperAttributeInfo
    {
    LPWSTR pwszName;
    ATTRIBUTE_TYPE type;
    } 	HelperAttributeInfo;

typedef struct tagHelperAttributeInfo *PHelperAttributeInfo;

#define DF_IMPERSONATION 0x80000000
#define DF_TRACELESS 0x40000000
typedef struct tagDiagnosticsInfo
    {
    long cost;
    ULONG flags;
    } 	DiagnosticsInfo;

typedef struct tagDiagnosticsInfo *PDiagnosticsInfo;



extern RPC_IF_HANDLE __MIDL_itf_ndhelper_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndhelper_0000_0000_v0_0_s_ifspec;

#ifndef __INetDiagHelper_INTERFACE_DEFINED__
#define __INetDiagHelper_INTERFACE_DEFINED__

/* interface INetDiagHelper */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INetDiagHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c0b35746-ebf5-11d8-bbe9-505054503030")
    INetDiagHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ULONG celt,
            /* [size_is][in] */ __RPC__in_ecount_full(celt) HELPER_ATTRIBUTE rgAttributes[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiagnosticsInfo( 
            /* [retval][out] */ __RPC__deref_out_opt DiagnosticsInfo **ppInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyAttributes( 
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HELPER_ATTRIBUTE **pprgAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LowHealth( 
            /* [unique][string][in] */ __RPC__in_opt_string LPCWSTR pwszInstanceDescription,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszDescription,
            /* [out] */ __RPC__out long *pDeferredTime,
            /* [out] */ __RPC__out DIAGNOSIS_STATUS *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HighUtilization( 
            /* [unique][string][in] */ __RPC__in_opt_string LPCWSTR pwszInstanceDescription,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszDescription,
            /* [out] */ __RPC__out long *pDeferredTime,
            /* [out] */ __RPC__out DIAGNOSIS_STATUS *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLowerHypotheses( 
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HYPOTHESIS **pprgHypotheses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownStreamHypotheses( 
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HYPOTHESIS **pprgHypotheses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHigherHypotheses( 
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HYPOTHESIS **pprgHypotheses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUpStreamHypotheses( 
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HYPOTHESIS **pprgHypotheses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Repair( 
            /* [in] */ __RPC__in RepairInfo *pInfo,
            /* [out] */ __RPC__out long *pDeferredTime,
            /* [out] */ __RPC__out REPAIR_STATUS *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ PROBLEM_TYPE problem,
            /* [out] */ __RPC__out long *pDeferredTime,
            /* [out] */ __RPC__out REPAIR_STATUS *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRepairInfo( 
            /* [in] */ PROBLEM_TYPE problem,
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) RepairInfo **ppInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLifeTime( 
            /* [out] */ __RPC__out LIFE_TIME *pLifeTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLifeTime( 
            /* [in] */ LIFE_TIME lifeTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCacheTime( 
            /* [out] */ __RPC__out FILETIME *pCacheTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HELPER_ATTRIBUTE **pprgAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cleanup( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetDiagHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetDiagHelper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetDiagHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetDiagHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in INetDiagHelper * This,
            /* [in] */ ULONG celt,
            /* [size_is][in] */ __RPC__in_ecount_full(celt) HELPER_ATTRIBUTE rgAttributes[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiagnosticsInfo )( 
            __RPC__in INetDiagHelper * This,
            /* [retval][out] */ __RPC__deref_out_opt DiagnosticsInfo **ppInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyAttributes )( 
            __RPC__in INetDiagHelper * This,
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HELPER_ATTRIBUTE **pprgAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *LowHealth )( 
            __RPC__in INetDiagHelper * This,
            /* [unique][string][in] */ __RPC__in_opt_string LPCWSTR pwszInstanceDescription,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszDescription,
            /* [out] */ __RPC__out long *pDeferredTime,
            /* [out] */ __RPC__out DIAGNOSIS_STATUS *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *HighUtilization )( 
            __RPC__in INetDiagHelper * This,
            /* [unique][string][in] */ __RPC__in_opt_string LPCWSTR pwszInstanceDescription,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszDescription,
            /* [out] */ __RPC__out long *pDeferredTime,
            /* [out] */ __RPC__out DIAGNOSIS_STATUS *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetLowerHypotheses )( 
            __RPC__in INetDiagHelper * This,
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HYPOTHESIS **pprgHypotheses);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownStreamHypotheses )( 
            __RPC__in INetDiagHelper * This,
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HYPOTHESIS **pprgHypotheses);
        
        HRESULT ( STDMETHODCALLTYPE *GetHigherHypotheses )( 
            __RPC__in INetDiagHelper * This,
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HYPOTHESIS **pprgHypotheses);
        
        HRESULT ( STDMETHODCALLTYPE *GetUpStreamHypotheses )( 
            __RPC__in INetDiagHelper * This,
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HYPOTHESIS **pprgHypotheses);
        
        HRESULT ( STDMETHODCALLTYPE *Repair )( 
            __RPC__in INetDiagHelper * This,
            /* [in] */ __RPC__in RepairInfo *pInfo,
            /* [out] */ __RPC__out long *pDeferredTime,
            /* [out] */ __RPC__out REPAIR_STATUS *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            __RPC__in INetDiagHelper * This,
            /* [in] */ PROBLEM_TYPE problem,
            /* [out] */ __RPC__out long *pDeferredTime,
            /* [out] */ __RPC__out REPAIR_STATUS *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetRepairInfo )( 
            __RPC__in INetDiagHelper * This,
            /* [in] */ PROBLEM_TYPE problem,
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) RepairInfo **ppInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetLifeTime )( 
            __RPC__in INetDiagHelper * This,
            /* [out] */ __RPC__out LIFE_TIME *pLifeTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetLifeTime )( 
            __RPC__in INetDiagHelper * This,
            /* [in] */ LIFE_TIME lifeTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetCacheTime )( 
            __RPC__in INetDiagHelper * This,
            /* [out] */ __RPC__out FILETIME *pCacheTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            __RPC__in INetDiagHelper * This,
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HELPER_ATTRIBUTE **pprgAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in INetDiagHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cleanup )( 
            __RPC__in INetDiagHelper * This);
        
        END_INTERFACE
    } INetDiagHelperVtbl;

    interface INetDiagHelper
    {
        CONST_VTBL struct INetDiagHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetDiagHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetDiagHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetDiagHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetDiagHelper_Initialize(This,celt,rgAttributes)	\
    ( (This)->lpVtbl -> Initialize(This,celt,rgAttributes) ) 

#define INetDiagHelper_GetDiagnosticsInfo(This,ppInfo)	\
    ( (This)->lpVtbl -> GetDiagnosticsInfo(This,ppInfo) ) 

#define INetDiagHelper_GetKeyAttributes(This,pcelt,pprgAttributes)	\
    ( (This)->lpVtbl -> GetKeyAttributes(This,pcelt,pprgAttributes) ) 

#define INetDiagHelper_LowHealth(This,pwszInstanceDescription,ppwszDescription,pDeferredTime,pStatus)	\
    ( (This)->lpVtbl -> LowHealth(This,pwszInstanceDescription,ppwszDescription,pDeferredTime,pStatus) ) 

#define INetDiagHelper_HighUtilization(This,pwszInstanceDescription,ppwszDescription,pDeferredTime,pStatus)	\
    ( (This)->lpVtbl -> HighUtilization(This,pwszInstanceDescription,ppwszDescription,pDeferredTime,pStatus) ) 

#define INetDiagHelper_GetLowerHypotheses(This,pcelt,pprgHypotheses)	\
    ( (This)->lpVtbl -> GetLowerHypotheses(This,pcelt,pprgHypotheses) ) 

#define INetDiagHelper_GetDownStreamHypotheses(This,pcelt,pprgHypotheses)	\
    ( (This)->lpVtbl -> GetDownStreamHypotheses(This,pcelt,pprgHypotheses) ) 

#define INetDiagHelper_GetHigherHypotheses(This,pcelt,pprgHypotheses)	\
    ( (This)->lpVtbl -> GetHigherHypotheses(This,pcelt,pprgHypotheses) ) 

#define INetDiagHelper_GetUpStreamHypotheses(This,pcelt,pprgHypotheses)	\
    ( (This)->lpVtbl -> GetUpStreamHypotheses(This,pcelt,pprgHypotheses) ) 

#define INetDiagHelper_Repair(This,pInfo,pDeferredTime,pStatus)	\
    ( (This)->lpVtbl -> Repair(This,pInfo,pDeferredTime,pStatus) ) 

#define INetDiagHelper_Validate(This,problem,pDeferredTime,pStatus)	\
    ( (This)->lpVtbl -> Validate(This,problem,pDeferredTime,pStatus) ) 

#define INetDiagHelper_GetRepairInfo(This,problem,pcelt,ppInfo)	\
    ( (This)->lpVtbl -> GetRepairInfo(This,problem,pcelt,ppInfo) ) 

#define INetDiagHelper_GetLifeTime(This,pLifeTime)	\
    ( (This)->lpVtbl -> GetLifeTime(This,pLifeTime) ) 

#define INetDiagHelper_SetLifeTime(This,lifeTime)	\
    ( (This)->lpVtbl -> SetLifeTime(This,lifeTime) ) 

#define INetDiagHelper_GetCacheTime(This,pCacheTime)	\
    ( (This)->lpVtbl -> GetCacheTime(This,pCacheTime) ) 

#define INetDiagHelper_GetAttributes(This,pcelt,pprgAttributes)	\
    ( (This)->lpVtbl -> GetAttributes(This,pcelt,pprgAttributes) ) 

#define INetDiagHelper_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define INetDiagHelper_Cleanup(This)	\
    ( (This)->lpVtbl -> Cleanup(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetDiagHelper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ndhelper_0000_0001 */
/* [local] */ 

typedef struct tagHypothesisResult
    {
    HYPOTHESIS hypothesis;
    DIAGNOSIS_STATUS pathStatus;
    } 	HypothesisResult;



extern RPC_IF_HANDLE __MIDL_itf_ndhelper_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndhelper_0000_0001_v0_0_s_ifspec;

#ifndef __INetDiagHelperUtilFactory_INTERFACE_DEFINED__
#define __INetDiagHelperUtilFactory_INTERFACE_DEFINED__

/* interface INetDiagHelperUtilFactory */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INetDiagHelperUtilFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("104613FB-BC57-4178-95BA-88809698354A")
    INetDiagHelperUtilFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateUtilityInstance( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetDiagHelperUtilFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetDiagHelperUtilFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetDiagHelperUtilFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetDiagHelperUtilFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateUtilityInstance )( 
            __RPC__in INetDiagHelperUtilFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        END_INTERFACE
    } INetDiagHelperUtilFactoryVtbl;

    interface INetDiagHelperUtilFactory
    {
        CONST_VTBL struct INetDiagHelperUtilFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetDiagHelperUtilFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetDiagHelperUtilFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetDiagHelperUtilFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetDiagHelperUtilFactory_CreateUtilityInstance(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> CreateUtilityInstance(This,riid,ppvObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetDiagHelperUtilFactory_INTERFACE_DEFINED__ */


#ifndef __INetDiagHelperEx_INTERFACE_DEFINED__
#define __INetDiagHelperEx_INTERFACE_DEFINED__

/* interface INetDiagHelperEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INetDiagHelperEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("972DAB4D-E4E3-4fc6-AE54-5F65CCDE4A15")
    INetDiagHelperEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReconfirmLowHealth( 
            /* [in] */ ULONG celt,
            /* [size_is][in] */ __RPC__in_ecount_full(celt) HypothesisResult *pResults,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszUpdatedDescription,
            /* [out] */ __RPC__out DIAGNOSIS_STATUS *pUpdatedStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUtilities( 
            /* [in] */ __RPC__in_opt INetDiagHelperUtilFactory *pUtilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReproduceFailure( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetDiagHelperExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetDiagHelperEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetDiagHelperEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetDiagHelperEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReconfirmLowHealth )( 
            __RPC__in INetDiagHelperEx * This,
            /* [in] */ ULONG celt,
            /* [size_is][in] */ __RPC__in_ecount_full(celt) HypothesisResult *pResults,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszUpdatedDescription,
            /* [out] */ __RPC__out DIAGNOSIS_STATUS *pUpdatedStatus);
        
        HRESULT ( STDMETHODCALLTYPE *SetUtilities )( 
            __RPC__in INetDiagHelperEx * This,
            /* [in] */ __RPC__in_opt INetDiagHelperUtilFactory *pUtilities);
        
        HRESULT ( STDMETHODCALLTYPE *ReproduceFailure )( 
            __RPC__in INetDiagHelperEx * This);
        
        END_INTERFACE
    } INetDiagHelperExVtbl;

    interface INetDiagHelperEx
    {
        CONST_VTBL struct INetDiagHelperExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetDiagHelperEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetDiagHelperEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetDiagHelperEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetDiagHelperEx_ReconfirmLowHealth(This,celt,pResults,ppwszUpdatedDescription,pUpdatedStatus)	\
    ( (This)->lpVtbl -> ReconfirmLowHealth(This,celt,pResults,ppwszUpdatedDescription,pUpdatedStatus) ) 

#define INetDiagHelperEx_SetUtilities(This,pUtilities)	\
    ( (This)->lpVtbl -> SetUtilities(This,pUtilities) ) 

#define INetDiagHelperEx_ReproduceFailure(This)	\
    ( (This)->lpVtbl -> ReproduceFailure(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetDiagHelperEx_INTERFACE_DEFINED__ */


#ifndef __INetDiagHelperInfo_INTERFACE_DEFINED__
#define __INetDiagHelperInfo_INTERFACE_DEFINED__

/* interface INetDiagHelperInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INetDiagHelperInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c0b35747-ebf5-11d8-bbe9-505054503030")
    INetDiagHelperInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributeInfo( 
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HelperAttributeInfo **pprgAttributeInfos) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetDiagHelperInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetDiagHelperInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetDiagHelperInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetDiagHelperInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeInfo )( 
            __RPC__in INetDiagHelperInfo * This,
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HelperAttributeInfo **pprgAttributeInfos);
        
        END_INTERFACE
    } INetDiagHelperInfoVtbl;

    interface INetDiagHelperInfo
    {
        CONST_VTBL struct INetDiagHelperInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetDiagHelperInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetDiagHelperInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetDiagHelperInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetDiagHelperInfo_GetAttributeInfo(This,pcelt,pprgAttributeInfos)	\
    ( (This)->lpVtbl -> GetAttributeInfo(This,pcelt,pprgAttributeInfos) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetDiagHelperInfo_INTERFACE_DEFINED__ */


#ifndef __INetDiagExtensibleHelper_INTERFACE_DEFINED__
#define __INetDiagExtensibleHelper_INTERFACE_DEFINED__

/* interface INetDiagExtensibleHelper */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INetDiagExtensibleHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c0b35748-ebf5-11d8-bbe9-505054503030")
    INetDiagExtensibleHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResolveAttributes( 
            /* [in] */ ULONG celt,
            /* [size_is][in] */ __RPC__in_ecount_full(celt) HELPER_ATTRIBUTE rgKeyAttributes[  ],
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HELPER_ATTRIBUTE **prgMatchValues) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetDiagExtensibleHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetDiagExtensibleHelper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetDiagExtensibleHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetDiagExtensibleHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveAttributes )( 
            __RPC__in INetDiagExtensibleHelper * This,
            /* [in] */ ULONG celt,
            /* [size_is][in] */ __RPC__in_ecount_full(celt) HELPER_ATTRIBUTE rgKeyAttributes[  ],
            /* [out] */ __RPC__out ULONG *pcelt,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcelt) HELPER_ATTRIBUTE **prgMatchValues);
        
        END_INTERFACE
    } INetDiagExtensibleHelperVtbl;

    interface INetDiagExtensibleHelper
    {
        CONST_VTBL struct INetDiagExtensibleHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetDiagExtensibleHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetDiagExtensibleHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetDiagExtensibleHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetDiagExtensibleHelper_ResolveAttributes(This,celt,rgKeyAttributes,pcelt,prgMatchValues)	\
    ( (This)->lpVtbl -> ResolveAttributes(This,celt,rgKeyAttributes,pcelt,prgMatchValues) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetDiagExtensibleHelper_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Nb30.h ===
//*++
//
// Copyright (c) 1991-1999  Microsoft Corporation
//
// Module Name:
//
//  nb30.h
//
// Abstract:
//
//  This module contains the definitions for portable NetBIOS 3.0
//  support.
//
//--*/

#ifndef NCB_INCLUDED
#define NCB_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************
 *                                                              *
 *              Data structure templates                        *
 *                                                              *
 ****************************************************************/

#define NCBNAMSZ        16    /* absolute length of a net name           */
#define MAX_LANA       254    /* lana's in range 0 to MAX_LANA inclusive */

/*
 * Network Control Block
 */

typedef struct _NCB {
    UCHAR   ncb_command;            /* command code                   */
    UCHAR   ncb_retcode;            /* return code                    */
    UCHAR   ncb_lsn;                /* local session number           */
    UCHAR   ncb_num;                /* number of our network name     */
    PUCHAR  ncb_buffer;             /* address of message buffer      */
    WORD    ncb_length;             /* size of message buffer         */
    UCHAR   ncb_callname[NCBNAMSZ]; /* blank-padded name of remote    */
    UCHAR   ncb_name[NCBNAMSZ];     /* our blank-padded netname       */
    UCHAR   ncb_rto;                /* rcv timeout/retry count        */
    UCHAR   ncb_sto;                /* send timeout/sys timeout       */
    void (CALLBACK *ncb_post)( struct _NCB * ); /* POST routine address        */
    UCHAR   ncb_lana_num;           /* lana (adapter) number          */
    UCHAR   ncb_cmd_cplt;           /* 0xff => commmand pending       */
#ifdef _WIN64
    UCHAR   ncb_reserve[18];        /* reserved, used by BIOS         */
#else
    UCHAR   ncb_reserve[10];        /* reserved, used by BIOS         */
#endif
    HANDLE  ncb_event;              /* HANDLE to Win32 event which    */
                                    /* will be set to the signalled   */
                                    /* state when an ASYNCH command   */
                                    /* completes                      */
} NCB, *PNCB;

/*
 *  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
 *  by an array of NAME_BUFFER structures.
 */

typedef struct _ADAPTER_STATUS {
    UCHAR   adapter_address[6];
    UCHAR   rev_major;
    UCHAR   reserved0;
    UCHAR   adapter_type;
    UCHAR   rev_minor;
    WORD    duration;
    WORD    frmr_recv;
    WORD    frmr_xmit;

    WORD    iframe_recv_err;

    WORD    xmit_aborts;
    DWORD   xmit_success;
    DWORD   recv_success;

    WORD    iframe_xmit_err;

    WORD    recv_buff_unavail;
    WORD    t1_timeouts;
    WORD    ti_timeouts;
    DWORD   reserved1;
    WORD    free_ncbs;
    WORD    max_cfg_ncbs;
    WORD    max_ncbs;
    WORD    xmit_buf_unavail;
    WORD    max_dgram_size;
    WORD    pending_sess;
    WORD    max_cfg_sess;
    WORD    max_sess;
    WORD    max_sess_pkt_size;
    WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;

typedef struct _NAME_BUFFER {
    UCHAR   name[NCBNAMSZ];
    UCHAR   name_num;
    UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

//  values for name_flags bits.

#define NAME_FLAGS_MASK 0x87

#define GROUP_NAME      0x80
#define UNIQUE_NAME     0x00

#define REGISTERING     0x00
#define REGISTERED      0x04
#define DEREGISTERED    0x05
#define DUPLICATE       0x06
#define DUPLICATE_DEREG 0x07

/*
 *  Structure returned to the NCB command NCBSSTAT is SESSION_HEADER followed
 *  by an array of SESSION_BUFFER structures. If the NCB_NAME starts with an
 *  asterisk then an array of these structures is returned containing the
 *  status for all names.
 */

typedef struct _SESSION_HEADER {
    UCHAR   sess_name;
    UCHAR   num_sess;
    UCHAR   rcv_dg_outstanding;
    UCHAR   rcv_any_outstanding;
} SESSION_HEADER, *PSESSION_HEADER;

typedef struct _SESSION_BUFFER {
    UCHAR   lsn;
    UCHAR   state;
    UCHAR   local_name[NCBNAMSZ];
    UCHAR   remote_name[NCBNAMSZ];
    UCHAR   rcvs_outstanding;
    UCHAR   sends_outstanding;
} SESSION_BUFFER, *PSESSION_BUFFER;

//  Values for state

#define LISTEN_OUTSTANDING      0x01
#define CALL_PENDING            0x02
#define SESSION_ESTABLISHED     0x03
#define HANGUP_PENDING          0x04
#define HANGUP_COMPLETE         0x05
#define SESSION_ABORTED         0x06

/*
 *  Structure returned to the NCB command NCBENUM.
 *
 *  On a system containing lana's 0, 2 and 3, a structure with
 *  length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
 */

typedef struct _LANA_ENUM {
    UCHAR   length;         //  Number of valid entries in lana[]
    UCHAR   lana[MAX_LANA+1];
} LANA_ENUM, *PLANA_ENUM;

/*
 *  Structure returned to the NCB command NCBFINDNAME is FIND_NAME_HEADER followed
 *  by an array of FIND_NAME_BUFFER structures.
 */

typedef struct _FIND_NAME_HEADER {
    WORD    node_count;
    UCHAR   reserved;
    UCHAR   unique_group;
} FIND_NAME_HEADER, *PFIND_NAME_HEADER;

typedef struct _FIND_NAME_BUFFER {
    UCHAR   length;
    UCHAR   access_control;
    UCHAR   frame_control;
    UCHAR   destination_addr[6];
    UCHAR   source_addr[6];
    UCHAR   routing_info[18];
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

/*
 *  Structure provided with NCBACTION. The purpose of NCBACTION is to provide
 *  transport specific extensions to netbios.
 */

typedef struct _ACTION_HEADER {
    ULONG   transport_id;
    USHORT  action_code;
    USHORT  reserved;
} ACTION_HEADER, *PACTION_HEADER;

//  Values for transport_id

#define ALL_TRANSPORTS  "M\0\0\0"
#define MS_NBF          "MNBF"


/****************************************************************
 *                                                              *
 *              Special values and constants                    *
 *                                                              *
 ****************************************************************/

/*
 *      NCB Command codes
 */

#define NCBCALL         0x10            /* NCB CALL                           */
#define NCBLISTEN       0x11            /* NCB LISTEN                         */
#define NCBHANGUP       0x12            /* NCB HANG UP                        */
#define NCBSEND         0x14            /* NCB SEND                           */
#define NCBRECV         0x15            /* NCB RECEIVE                        */
#define NCBRECVANY      0x16            /* NCB RECEIVE ANY                    */
#define NCBCHAINSEND    0x17            /* NCB CHAIN SEND                     */
#define NCBDGSEND       0x20            /* NCB SEND DATAGRAM                  */
#define NCBDGRECV       0x21            /* NCB RECEIVE DATAGRAM               */
#define NCBDGSENDBC     0x22            /* NCB SEND BROADCAST DATAGRAM        */
#define NCBDGRECVBC     0x23            /* NCB RECEIVE BROADCAST DATAGRAM     */
#define NCBADDNAME      0x30            /* NCB ADD NAME                       */
#define NCBDELNAME      0x31            /* NCB DELETE NAME                    */
#define NCBRESET        0x32            /* NCB RESET                          */
#define NCBASTAT        0x33            /* NCB ADAPTER STATUS                 */
#define NCBSSTAT        0x34            /* NCB SESSION STATUS                 */
#define NCBCANCEL       0x35            /* NCB CANCEL                         */
#define NCBADDGRNAME    0x36            /* NCB ADD GROUP NAME                 */
#define NCBENUM         0x37            /* NCB ENUMERATE LANA NUMBERS         */
#define NCBUNLINK       0x70            /* NCB UNLINK                         */
#define NCBSENDNA       0x71            /* NCB SEND NO ACK                    */
#define NCBCHAINSENDNA  0x72            /* NCB CHAIN SEND NO ACK              */
#define NCBLANSTALERT   0x73            /* NCB LAN STATUS ALERT               */
#define NCBACTION       0x77            /* NCB ACTION                         */
#define NCBFINDNAME     0x78            /* NCB FIND NAME                      */
#define NCBTRACE        0x79            /* NCB TRACE                          */


#define ASYNCH          0x80            /* high bit set == asynchronous       */

/*
 *      NCB Return codes
 */

#define NRC_GOODRET     0x00    /* good return                                */
                                /* also returned when ASYNCH request accepted */
#define NRC_BUFLEN      0x01    /* illegal buffer length                      */
#define NRC_ILLCMD      0x03    /* illegal command                            */
#define NRC_CMDTMO      0x05    /* command timed out                          */
#define NRC_INCOMP      0x06    /* message incomplete, issue another command  */
#define NRC_BADDR       0x07    /* illegal buffer address                     */
#define NRC_SNUMOUT     0x08    /* session number out of range                */
#define NRC_NORES       0x09    /* no resource available                      */
#define NRC_SCLOSED     0x0a    /* session closed                             */
#define NRC_CMDCAN      0x0b    /* command cancelled                          */
#define NRC_DUPNAME     0x0d    /* duplicate name                             */
#define NRC_NAMTFUL     0x0e    /* name table full                            */
#define NRC_ACTSES      0x0f    /* no deletions, name has active sessions     */
#define NRC_LOCTFUL     0x11    /* local session table full                   */
#define NRC_REMTFUL     0x12    /* remote session table full                  */
#define NRC_ILLNN       0x13    /* illegal name number                        */
#define NRC_NOCALL      0x14    /* no callname                                */
#define NRC_NOWILD      0x15    /* cannot put * in NCB_NAME                   */
#define NRC_INUSE       0x16    /* name in use on remote adapter              */
#define NRC_NAMERR      0x17    /* name deleted                               */
#define NRC_SABORT      0x18    /* session ended abnormally                   */
#define NRC_NAMCONF     0x19    /* name conflict detected                     */
#define NRC_IFBUSY      0x21    /* interface busy, IRET before retrying       */
#define NRC_TOOMANY     0x22    /* too many commands outstanding, retry later */
#define NRC_BRIDGE      0x23    /* ncb_lana_num field invalid                 */
#define NRC_CANOCCR     0x24    /* command completed while cancel occurring   */
#define NRC_CANCEL      0x26    /* command not valid to cancel                */
#define NRC_DUPENV      0x30    /* name defined by anther local process       */
#define NRC_ENVNOTDEF   0x34    /* environment undefined. RESET required      */
#define NRC_OSRESNOTAV  0x35    /* required OS resources exhausted            */
#define NRC_MAXAPPS     0x36    /* max number of applications exceeded        */
#define NRC_NOSAPS      0x37    /* no saps available for netbios              */
#define NRC_NORESOURCES 0x38    /* requested resources are not available      */
#define NRC_INVADDRESS  0x39    /* invalid ncb address or length > segment    */
#define NRC_INVDDID     0x3B    /* invalid NCB DDID                           */
#define NRC_LOCKFAIL    0x3C    /* lock of user area failed                   */
#define NRC_OPENERR     0x3f    /* NETBIOS not loaded                         */
#define NRC_SYSTEM      0x40    /* system error                               */

#define NRC_PENDING     0xff    /* asynchronous command is not yet finished   */

/****************************************************************
 *                                                              *
 *              main user entry point for NetBIOS 3.0           *
 *                                                              *
 * Usage: result = Netbios( pncb );                             *
 ****************************************************************/

UCHAR
APIENTRY
Netbios(
    PNCB pncb
    );

/****************************************************************
 *                                                              *
 *              Prefix for callback routines                    *
 *                                                              *
 * Usage in a declaration: NCB_POST MyPostRoutine( PNCB pncb ); *
 ****************************************************************/

#define NCB_POST void CALLBACK

#ifdef __cplusplus
}
#endif

#endif /* NCB_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\natupnp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for natupnp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __natupnp_h__
#define __natupnp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUPnPNAT_FWD_DEFINED__
#define __IUPnPNAT_FWD_DEFINED__
typedef interface IUPnPNAT IUPnPNAT;
#endif 	/* __IUPnPNAT_FWD_DEFINED__ */


#ifndef __INATEventManager_FWD_DEFINED__
#define __INATEventManager_FWD_DEFINED__
typedef interface INATEventManager INATEventManager;
#endif 	/* __INATEventManager_FWD_DEFINED__ */


#ifndef __INATExternalIPAddressCallback_FWD_DEFINED__
#define __INATExternalIPAddressCallback_FWD_DEFINED__
typedef interface INATExternalIPAddressCallback INATExternalIPAddressCallback;
#endif 	/* __INATExternalIPAddressCallback_FWD_DEFINED__ */


#ifndef __INATNumberOfEntriesCallback_FWD_DEFINED__
#define __INATNumberOfEntriesCallback_FWD_DEFINED__
typedef interface INATNumberOfEntriesCallback INATNumberOfEntriesCallback;
#endif 	/* __INATNumberOfEntriesCallback_FWD_DEFINED__ */


#ifndef __IDynamicPortMappingCollection_FWD_DEFINED__
#define __IDynamicPortMappingCollection_FWD_DEFINED__
typedef interface IDynamicPortMappingCollection IDynamicPortMappingCollection;
#endif 	/* __IDynamicPortMappingCollection_FWD_DEFINED__ */


#ifndef __IDynamicPortMapping_FWD_DEFINED__
#define __IDynamicPortMapping_FWD_DEFINED__
typedef interface IDynamicPortMapping IDynamicPortMapping;
#endif 	/* __IDynamicPortMapping_FWD_DEFINED__ */


#ifndef __IStaticPortMappingCollection_FWD_DEFINED__
#define __IStaticPortMappingCollection_FWD_DEFINED__
typedef interface IStaticPortMappingCollection IStaticPortMappingCollection;
#endif 	/* __IStaticPortMappingCollection_FWD_DEFINED__ */


#ifndef __IStaticPortMapping_FWD_DEFINED__
#define __IStaticPortMapping_FWD_DEFINED__
typedef interface IStaticPortMapping IStaticPortMapping;
#endif 	/* __IStaticPortMapping_FWD_DEFINED__ */


#ifndef __UPnPNAT_FWD_DEFINED__
#define __UPnPNAT_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPNAT UPnPNAT;
#else
typedef struct UPnPNAT UPnPNAT;
#endif /* __cplusplus */

#endif 	/* __UPnPNAT_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_natupnp_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2001.
//
//--------------------------------------------------------------------------
//  MODULE: natupnp.h
//








extern RPC_IF_HANDLE __MIDL_itf_natupnp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_natupnp_0000_0000_v0_0_s_ifspec;

#ifndef __IUPnPNAT_INTERFACE_DEFINED__
#define __IUPnPNAT_INTERFACE_DEFINED__

/* interface IUPnPNAT */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPNAT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B171C812-CC76-485A-94D8-B6B3A2794E99")
    IUPnPNAT : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StaticPortMappingCollection( 
            /* [retval][out] */ __RPC__deref_out_opt IStaticPortMappingCollection **ppSPMs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DynamicPortMappingCollection( 
            /* [retval][out] */ __RPC__deref_out_opt IDynamicPortMappingCollection **ppDPMs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NATEventManager( 
            /* [retval][out] */ __RPC__deref_out_opt INATEventManager **ppNEM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPNATVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPNAT * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPNAT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPNAT * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUPnPNAT * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUPnPNAT * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUPnPNAT * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPNAT * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StaticPortMappingCollection )( 
            __RPC__in IUPnPNAT * This,
            /* [retval][out] */ __RPC__deref_out_opt IStaticPortMappingCollection **ppSPMs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DynamicPortMappingCollection )( 
            __RPC__in IUPnPNAT * This,
            /* [retval][out] */ __RPC__deref_out_opt IDynamicPortMappingCollection **ppDPMs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NATEventManager )( 
            __RPC__in IUPnPNAT * This,
            /* [retval][out] */ __RPC__deref_out_opt INATEventManager **ppNEM);
        
        END_INTERFACE
    } IUPnPNATVtbl;

    interface IUPnPNAT
    {
        CONST_VTBL struct IUPnPNATVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPNAT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPNAT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPNAT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPNAT_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPNAT_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPNAT_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPNAT_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPNAT_get_StaticPortMappingCollection(This,ppSPMs)	\
    ( (This)->lpVtbl -> get_StaticPortMappingCollection(This,ppSPMs) ) 

#define IUPnPNAT_get_DynamicPortMappingCollection(This,ppDPMs)	\
    ( (This)->lpVtbl -> get_DynamicPortMappingCollection(This,ppDPMs) ) 

#define IUPnPNAT_get_NATEventManager(This,ppNEM)	\
    ( (This)->lpVtbl -> get_NATEventManager(This,ppNEM) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPNAT_INTERFACE_DEFINED__ */


#ifndef __INATEventManager_INTERFACE_DEFINED__
#define __INATEventManager_INTERFACE_DEFINED__

/* interface INATEventManager */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_INATEventManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("624BD588-9060-4109-B0B0-1ADBBCAC32DF")
    INATEventManager : public IDispatch
    {
    public:
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ExternalIPAddressCallback( 
            /* [in] */ __RPC__in_opt IUnknown *pUnk) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_NumberOfEntriesCallback( 
            /* [in] */ __RPC__in_opt IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INATEventManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INATEventManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INATEventManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INATEventManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INATEventManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INATEventManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INATEventManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INATEventManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ExternalIPAddressCallback )( 
            __RPC__in INATEventManager * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnk);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_NumberOfEntriesCallback )( 
            __RPC__in INATEventManager * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnk);
        
        END_INTERFACE
    } INATEventManagerVtbl;

    interface INATEventManager
    {
        CONST_VTBL struct INATEventManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INATEventManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INATEventManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INATEventManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INATEventManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INATEventManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INATEventManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INATEventManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INATEventManager_put_ExternalIPAddressCallback(This,pUnk)	\
    ( (This)->lpVtbl -> put_ExternalIPAddressCallback(This,pUnk) ) 

#define INATEventManager_put_NumberOfEntriesCallback(This,pUnk)	\
    ( (This)->lpVtbl -> put_NumberOfEntriesCallback(This,pUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INATEventManager_INTERFACE_DEFINED__ */


#ifndef __INATExternalIPAddressCallback_INTERFACE_DEFINED__
#define __INATExternalIPAddressCallback_INTERFACE_DEFINED__

/* interface INATExternalIPAddressCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INATExternalIPAddressCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C416740-A34E-446F-BA06-ABD04C3149AE")
    INATExternalIPAddressCallback : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NewExternalIPAddress( 
            /* [in] */ __RPC__in BSTR bstrNewExternalIPAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INATExternalIPAddressCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INATExternalIPAddressCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INATExternalIPAddressCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INATExternalIPAddressCallback * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NewExternalIPAddress )( 
            __RPC__in INATExternalIPAddressCallback * This,
            /* [in] */ __RPC__in BSTR bstrNewExternalIPAddress);
        
        END_INTERFACE
    } INATExternalIPAddressCallbackVtbl;

    interface INATExternalIPAddressCallback
    {
        CONST_VTBL struct INATExternalIPAddressCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INATExternalIPAddressCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INATExternalIPAddressCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INATExternalIPAddressCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INATExternalIPAddressCallback_NewExternalIPAddress(This,bstrNewExternalIPAddress)	\
    ( (This)->lpVtbl -> NewExternalIPAddress(This,bstrNewExternalIPAddress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INATExternalIPAddressCallback_INTERFACE_DEFINED__ */


#ifndef __INATNumberOfEntriesCallback_INTERFACE_DEFINED__
#define __INATNumberOfEntriesCallback_INTERFACE_DEFINED__

/* interface INATNumberOfEntriesCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INATNumberOfEntriesCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C83A0A74-91EE-41B6-B67A-67E0F00BBD78")
    INATNumberOfEntriesCallback : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NewNumberOfEntries( 
            /* [in] */ long lNewNumberOfEntries) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INATNumberOfEntriesCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INATNumberOfEntriesCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INATNumberOfEntriesCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INATNumberOfEntriesCallback * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NewNumberOfEntries )( 
            __RPC__in INATNumberOfEntriesCallback * This,
            /* [in] */ long lNewNumberOfEntries);
        
        END_INTERFACE
    } INATNumberOfEntriesCallbackVtbl;

    interface INATNumberOfEntriesCallback
    {
        CONST_VTBL struct INATNumberOfEntriesCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INATNumberOfEntriesCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INATNumberOfEntriesCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INATNumberOfEntriesCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INATNumberOfEntriesCallback_NewNumberOfEntries(This,lNewNumberOfEntries)	\
    ( (This)->lpVtbl -> NewNumberOfEntries(This,lNewNumberOfEntries) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INATNumberOfEntriesCallback_INTERFACE_DEFINED__ */


#ifndef __IDynamicPortMappingCollection_INTERFACE_DEFINED__
#define __IDynamicPortMappingCollection_INTERFACE_DEFINED__

/* interface IDynamicPortMappingCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDynamicPortMappingCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B60DE00F-156E-4E8D-9EC1-3A2342C10899")
    IDynamicPortMappingCollection : public IDispatch
    {
    public:
        virtual /* [restricted][hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ __RPC__in BSTR bstrRemoteHost,
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol,
            /* [retval][out] */ __RPC__deref_out_opt IDynamicPortMapping **ppDPM) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ __RPC__in BSTR bstrRemoteHost,
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in BSTR bstrRemoteHost,
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol,
            /* [in] */ long lInternalPort,
            /* [in] */ __RPC__in BSTR bstrInternalClient,
            /* [in] */ VARIANT_BOOL bEnabled,
            /* [in] */ __RPC__in BSTR bstrDescription,
            /* [in] */ long lLeaseDuration,
            /* [retval][out] */ __RPC__deref_out_opt IDynamicPortMapping **ppDPM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDynamicPortMappingCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDynamicPortMappingCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDynamicPortMappingCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDynamicPortMappingCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDynamicPortMappingCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDynamicPortMappingCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDynamicPortMappingCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDynamicPortMappingCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IDynamicPortMappingCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IDynamicPortMappingCollection * This,
            /* [in] */ __RPC__in BSTR bstrRemoteHost,
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol,
            /* [retval][out] */ __RPC__deref_out_opt IDynamicPortMapping **ppDPM);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IDynamicPortMappingCollection * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IDynamicPortMappingCollection * This,
            /* [in] */ __RPC__in BSTR bstrRemoteHost,
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IDynamicPortMappingCollection * This,
            /* [in] */ __RPC__in BSTR bstrRemoteHost,
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol,
            /* [in] */ long lInternalPort,
            /* [in] */ __RPC__in BSTR bstrInternalClient,
            /* [in] */ VARIANT_BOOL bEnabled,
            /* [in] */ __RPC__in BSTR bstrDescription,
            /* [in] */ long lLeaseDuration,
            /* [retval][out] */ __RPC__deref_out_opt IDynamicPortMapping **ppDPM);
        
        END_INTERFACE
    } IDynamicPortMappingCollectionVtbl;

    interface IDynamicPortMappingCollection
    {
        CONST_VTBL struct IDynamicPortMappingCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDynamicPortMappingCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDynamicPortMappingCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDynamicPortMappingCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDynamicPortMappingCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDynamicPortMappingCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDynamicPortMappingCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDynamicPortMappingCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDynamicPortMappingCollection_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define IDynamicPortMappingCollection_get_Item(This,bstrRemoteHost,lExternalPort,bstrProtocol,ppDPM)	\
    ( (This)->lpVtbl -> get_Item(This,bstrRemoteHost,lExternalPort,bstrProtocol,ppDPM) ) 

#define IDynamicPortMappingCollection_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define IDynamicPortMappingCollection_Remove(This,bstrRemoteHost,lExternalPort,bstrProtocol)	\
    ( (This)->lpVtbl -> Remove(This,bstrRemoteHost,lExternalPort,bstrProtocol) ) 

#define IDynamicPortMappingCollection_Add(This,bstrRemoteHost,lExternalPort,bstrProtocol,lInternalPort,bstrInternalClient,bEnabled,bstrDescription,lLeaseDuration,ppDPM)	\
    ( (This)->lpVtbl -> Add(This,bstrRemoteHost,lExternalPort,bstrProtocol,lInternalPort,bstrInternalClient,bEnabled,bstrDescription,lLeaseDuration,ppDPM) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDynamicPortMappingCollection_INTERFACE_DEFINED__ */


#ifndef __IDynamicPortMapping_INTERFACE_DEFINED__
#define __IDynamicPortMapping_INTERFACE_DEFINED__

/* interface IDynamicPortMapping */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDynamicPortMapping;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4FC80282-23B6-4378-9A27-CD8F17C9400C")
    IDynamicPortMapping : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExternalIPAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoteHost( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExternalPort( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InternalPort( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InternalClient( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LeaseDuration( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RenewLease( 
            /* [in] */ long lLeaseDurationDesired,
            /* [retval][out] */ __RPC__out long *pLeaseDurationReturned) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EditInternalClient( 
            /* [in] */ __RPC__in BSTR bstrInternalClient) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ VARIANT_BOOL vb) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EditDescription( 
            /* [in] */ __RPC__in BSTR bstrDescription) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EditInternalPort( 
            /* [in] */ long lInternalPort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDynamicPortMappingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDynamicPortMapping * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDynamicPortMapping * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDynamicPortMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDynamicPortMapping * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDynamicPortMapping * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDynamicPortMapping * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDynamicPortMapping * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExternalIPAddress )( 
            __RPC__in IDynamicPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteHost )( 
            __RPC__in IDynamicPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExternalPort )( 
            __RPC__in IDynamicPortMapping * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            __RPC__in IDynamicPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InternalPort )( 
            __RPC__in IDynamicPortMapping * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InternalClient )( 
            __RPC__in IDynamicPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IDynamicPortMapping * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IDynamicPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LeaseDuration )( 
            __RPC__in IDynamicPortMapping * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RenewLease )( 
            __RPC__in IDynamicPortMapping * This,
            /* [in] */ long lLeaseDurationDesired,
            /* [retval][out] */ __RPC__out long *pLeaseDurationReturned);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EditInternalClient )( 
            __RPC__in IDynamicPortMapping * This,
            /* [in] */ __RPC__in BSTR bstrInternalClient);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Enable )( 
            __RPC__in IDynamicPortMapping * This,
            /* [in] */ VARIANT_BOOL vb);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EditDescription )( 
            __RPC__in IDynamicPortMapping * This,
            /* [in] */ __RPC__in BSTR bstrDescription);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EditInternalPort )( 
            __RPC__in IDynamicPortMapping * This,
            /* [in] */ long lInternalPort);
        
        END_INTERFACE
    } IDynamicPortMappingVtbl;

    interface IDynamicPortMapping
    {
        CONST_VTBL struct IDynamicPortMappingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDynamicPortMapping_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDynamicPortMapping_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDynamicPortMapping_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDynamicPortMapping_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDynamicPortMapping_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDynamicPortMapping_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDynamicPortMapping_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDynamicPortMapping_get_ExternalIPAddress(This,pVal)	\
    ( (This)->lpVtbl -> get_ExternalIPAddress(This,pVal) ) 

#define IDynamicPortMapping_get_RemoteHost(This,pVal)	\
    ( (This)->lpVtbl -> get_RemoteHost(This,pVal) ) 

#define IDynamicPortMapping_get_ExternalPort(This,pVal)	\
    ( (This)->lpVtbl -> get_ExternalPort(This,pVal) ) 

#define IDynamicPortMapping_get_Protocol(This,pVal)	\
    ( (This)->lpVtbl -> get_Protocol(This,pVal) ) 

#define IDynamicPortMapping_get_InternalPort(This,pVal)	\
    ( (This)->lpVtbl -> get_InternalPort(This,pVal) ) 

#define IDynamicPortMapping_get_InternalClient(This,pVal)	\
    ( (This)->lpVtbl -> get_InternalClient(This,pVal) ) 

#define IDynamicPortMapping_get_Enabled(This,pVal)	\
    ( (This)->lpVtbl -> get_Enabled(This,pVal) ) 

#define IDynamicPortMapping_get_Description(This,pVal)	\
    ( (This)->lpVtbl -> get_Description(This,pVal) ) 

#define IDynamicPortMapping_get_LeaseDuration(This,pVal)	\
    ( (This)->lpVtbl -> get_LeaseDuration(This,pVal) ) 

#define IDynamicPortMapping_RenewLease(This,lLeaseDurationDesired,pLeaseDurationReturned)	\
    ( (This)->lpVtbl -> RenewLease(This,lLeaseDurationDesired,pLeaseDurationReturned) ) 

#define IDynamicPortMapping_EditInternalClient(This,bstrInternalClient)	\
    ( (This)->lpVtbl -> EditInternalClient(This,bstrInternalClient) ) 

#define IDynamicPortMapping_Enable(This,vb)	\
    ( (This)->lpVtbl -> Enable(This,vb) ) 

#define IDynamicPortMapping_EditDescription(This,bstrDescription)	\
    ( (This)->lpVtbl -> EditDescription(This,bstrDescription) ) 

#define IDynamicPortMapping_EditInternalPort(This,lInternalPort)	\
    ( (This)->lpVtbl -> EditInternalPort(This,lInternalPort) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDynamicPortMapping_INTERFACE_DEFINED__ */


#ifndef __IStaticPortMappingCollection_INTERFACE_DEFINED__
#define __IStaticPortMappingCollection_INTERFACE_DEFINED__

/* interface IStaticPortMappingCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IStaticPortMappingCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD1F3E77-66D6-4664-82C7-36DBB641D0F1")
    IStaticPortMappingCollection : public IDispatch
    {
    public:
        virtual /* [restricted][hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol,
            /* [retval][out] */ __RPC__deref_out_opt IStaticPortMapping **ppSPM) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol,
            /* [in] */ long lInternalPort,
            /* [in] */ __RPC__in BSTR bstrInternalClient,
            /* [in] */ VARIANT_BOOL bEnabled,
            /* [in] */ __RPC__in BSTR bstrDescription,
            /* [retval][out] */ __RPC__deref_out_opt IStaticPortMapping **ppSPM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStaticPortMappingCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStaticPortMappingCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStaticPortMappingCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStaticPortMappingCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IStaticPortMappingCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IStaticPortMappingCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IStaticPortMappingCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IStaticPortMappingCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [restricted][hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IStaticPortMappingCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IStaticPortMappingCollection * This,
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol,
            /* [retval][out] */ __RPC__deref_out_opt IStaticPortMapping **ppSPM);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IStaticPortMappingCollection * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IStaticPortMappingCollection * This,
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IStaticPortMappingCollection * This,
            /* [in] */ long lExternalPort,
            /* [in] */ __RPC__in BSTR bstrProtocol,
            /* [in] */ long lInternalPort,
            /* [in] */ __RPC__in BSTR bstrInternalClient,
            /* [in] */ VARIANT_BOOL bEnabled,
            /* [in] */ __RPC__in BSTR bstrDescription,
            /* [retval][out] */ __RPC__deref_out_opt IStaticPortMapping **ppSPM);
        
        END_INTERFACE
    } IStaticPortMappingCollectionVtbl;

    interface IStaticPortMappingCollection
    {
        CONST_VTBL struct IStaticPortMappingCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStaticPortMappingCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStaticPortMappingCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStaticPortMappingCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStaticPortMappingCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IStaticPortMappingCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IStaticPortMappingCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IStaticPortMappingCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IStaticPortMappingCollection_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define IStaticPortMappingCollection_get_Item(This,lExternalPort,bstrProtocol,ppSPM)	\
    ( (This)->lpVtbl -> get_Item(This,lExternalPort,bstrProtocol,ppSPM) ) 

#define IStaticPortMappingCollection_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#define IStaticPortMappingCollection_Remove(This,lExternalPort,bstrProtocol)	\
    ( (This)->lpVtbl -> Remove(This,lExternalPort,bstrProtocol) ) 

#define IStaticPortMappingCollection_Add(This,lExternalPort,bstrProtocol,lInternalPort,bstrInternalClient,bEnabled,bstrDescription,ppSPM)	\
    ( (This)->lpVtbl -> Add(This,lExternalPort,bstrProtocol,lInternalPort,bstrInternalClient,bEnabled,bstrDescription,ppSPM) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStaticPortMappingCollection_INTERFACE_DEFINED__ */


#ifndef __IStaticPortMapping_INTERFACE_DEFINED__
#define __IStaticPortMapping_INTERFACE_DEFINED__

/* interface IStaticPortMapping */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IStaticPortMapping;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6F10711F-729B-41E5-93B8-F21D0F818DF1")
    IStaticPortMapping : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExternalIPAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExternalPort( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InternalPort( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InternalClient( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EditInternalClient( 
            /* [in] */ __RPC__in BSTR bstrInternalClient) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ VARIANT_BOOL vb) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EditDescription( 
            /* [in] */ __RPC__in BSTR bstrDescription) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EditInternalPort( 
            /* [in] */ long lInternalPort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStaticPortMappingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStaticPortMapping * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStaticPortMapping * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStaticPortMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IStaticPortMapping * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IStaticPortMapping * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IStaticPortMapping * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IStaticPortMapping * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExternalIPAddress )( 
            __RPC__in IStaticPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExternalPort )( 
            __RPC__in IStaticPortMapping * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InternalPort )( 
            __RPC__in IStaticPortMapping * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            __RPC__in IStaticPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InternalClient )( 
            __RPC__in IStaticPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IStaticPortMapping * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IStaticPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EditInternalClient )( 
            __RPC__in IStaticPortMapping * This,
            /* [in] */ __RPC__in BSTR bstrInternalClient);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Enable )( 
            __RPC__in IStaticPortMapping * This,
            /* [in] */ VARIANT_BOOL vb);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EditDescription )( 
            __RPC__in IStaticPortMapping * This,
            /* [in] */ __RPC__in BSTR bstrDescription);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EditInternalPort )( 
            __RPC__in IStaticPortMapping * This,
            /* [in] */ long lInternalPort);
        
        END_INTERFACE
    } IStaticPortMappingVtbl;

    interface IStaticPortMapping
    {
        CONST_VTBL struct IStaticPortMappingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStaticPortMapping_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStaticPortMapping_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStaticPortMapping_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStaticPortMapping_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IStaticPortMapping_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IStaticPortMapping_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IStaticPortMapping_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IStaticPortMapping_get_ExternalIPAddress(This,pVal)	\
    ( (This)->lpVtbl -> get_ExternalIPAddress(This,pVal) ) 

#define IStaticPortMapping_get_ExternalPort(This,pVal)	\
    ( (This)->lpVtbl -> get_ExternalPort(This,pVal) ) 

#define IStaticPortMapping_get_InternalPort(This,pVal)	\
    ( (This)->lpVtbl -> get_InternalPort(This,pVal) ) 

#define IStaticPortMapping_get_Protocol(This,pVal)	\
    ( (This)->lpVtbl -> get_Protocol(This,pVal) ) 

#define IStaticPortMapping_get_InternalClient(This,pVal)	\
    ( (This)->lpVtbl -> get_InternalClient(This,pVal) ) 

#define IStaticPortMapping_get_Enabled(This,pVal)	\
    ( (This)->lpVtbl -> get_Enabled(This,pVal) ) 

#define IStaticPortMapping_get_Description(This,pVal)	\
    ( (This)->lpVtbl -> get_Description(This,pVal) ) 

#define IStaticPortMapping_EditInternalClient(This,bstrInternalClient)	\
    ( (This)->lpVtbl -> EditInternalClient(This,bstrInternalClient) ) 

#define IStaticPortMapping_Enable(This,vb)	\
    ( (This)->lpVtbl -> Enable(This,vb) ) 

#define IStaticPortMapping_EditDescription(This,bstrDescription)	\
    ( (This)->lpVtbl -> EditDescription(This,bstrDescription) ) 

#define IStaticPortMapping_EditInternalPort(This,lInternalPort)	\
    ( (This)->lpVtbl -> EditInternalPort(This,lInternalPort) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStaticPortMapping_INTERFACE_DEFINED__ */



#ifndef __NATUPNPLib_LIBRARY_DEFINED__
#define __NATUPNPLib_LIBRARY_DEFINED__

/* library NATUPNPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_NATUPNPLib;

EXTERN_C const CLSID CLSID_UPnPNAT;

#ifdef __cplusplus

class DECLSPEC_UUID("AE1E00AA-3FD5-403C-8A27-2BBDC30CD0E1")
UPnPNAT;
#endif
#endif /* __NATUPNPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ncrypt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2004.
//
//  File:       ncrypt.h
//
//  Contents:   Cryptographic API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __NCRYPT_H__
#define __NCRYPT_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WINAPI
#define WINAPI __stdcall
#endif

#ifndef __SECSTATUS_DEFINED__
typedef LONG SECURITY_STATUS;
#define __SECSTATUS_DEFINED__
#endif

#include <bcrypt.h>

//
// Microsoft built-in providers.
//

#define MS_KEY_STORAGE_PROVIDER         L"Microsoft Software Key Storage Provider"
#define MS_SMART_CARD_KEY_STORAGE_PROVIDER L"Microsoft Smart Card Key Storage Provider"

//
// Common algorithm identifiers.
//

#define NCRYPT_RSA_ALGORITHM            BCRYPT_RSA_ALGORITHM
#define NCRYPT_RSA_SIGN_ALGORITHM       BCRYPT_RSA_SIGN_ALGORITHM
#define NCRYPT_DH_ALGORITHM             BCRYPT_DH_ALGORITHM
#define NCRYPT_DSA_ALGORITHM            BCRYPT_DSA_ALGORITHM
#define NCRYPT_MD2_ALGORITHM            BCRYPT_MD2_ALGORITHM
#define NCRYPT_MD4_ALGORITHM            BCRYPT_MD4_ALGORITHM
#define NCRYPT_MD5_ALGORITHM            BCRYPT_MD5_ALGORITHM
#define NCRYPT_SHA1_ALGORITHM           BCRYPT_SHA1_ALGORITHM
#define NCRYPT_SHA256_ALGORITHM         BCRYPT_SHA256_ALGORITHM
#define NCRYPT_SHA384_ALGORITHM         BCRYPT_SHA384_ALGORITHM
#define NCRYPT_SHA512_ALGORITHM         BCRYPT_SHA512_ALGORITHM
#define NCRYPT_ECDSA_P256_ALGORITHM     BCRYPT_ECDSA_P256_ALGORITHM
#define NCRYPT_ECDSA_P384_ALGORITHM     BCRYPT_ECDSA_P384_ALGORITHM
#define NCRYPT_ECDSA_P521_ALGORITHM     BCRYPT_ECDSA_P521_ALGORITHM
#define NCRYPT_ECDH_P256_ALGORITHM      BCRYPT_ECDH_P256_ALGORITHM
#define NCRYPT_ECDH_P384_ALGORITHM      BCRYPT_ECDH_P384_ALGORITHM
#define NCRYPT_ECDH_P521_ALGORITHM      BCRYPT_ECDH_P521_ALGORITHM

#define NCRYPT_KEY_STORAGE_ALGORITHM            L"KEY_STORAGE"

//
// Interfaces
//

#define NCRYPT_HASH_INTERFACE                   BCRYPT_HASH_INTERFACE
#define NCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE  BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE

#define NCRYPT_SECRET_AGREEMENT_INTERFACE       BCRYPT_SECRET_AGREEMENT_INTERFACE

#define NCRYPT_SIGNATURE_INTERFACE              BCRYPT_SIGNATURE_INTERFACE

#define NCRYPT_KEY_STORAGE_INTERFACE            0x00010001
#define NCRYPT_SCHANNEL_INTERFACE               0x00010002
#define NCRYPT_SCHANNEL_SIGNATURE_INTERFACE     0x00010003

//
// algorithm groups.
//

#define NCRYPT_RSA_ALGORITHM_GROUP      NCRYPT_RSA_ALGORITHM
#define NCRYPT_DH_ALGORITHM_GROUP       NCRYPT_DH_ALGORITHM
#define NCRYPT_DSA_ALGORITHM_GROUP      NCRYPT_DSA_ALGORITHM
#define NCRYPT_ECDSA_ALGORITHM_GROUP    L"ECDSA"
#define NCRYPT_ECDH_ALGORITHM_GROUP     L"ECDH"

//
// NCrypt generic memory descriptors
//

#define NCRYPTBUFFER_VERSION                0

#define NCRYPTBUFFER_EMPTY                  0
#define NCRYPTBUFFER_DATA                   1
#define NCRYPTBUFFER_SSL_CLIENT_RANDOM      20
#define NCRYPTBUFFER_SSL_SERVER_RANDOM      21
#define NCRYPTBUFFER_SSL_HIGHEST_VERSION    22
#define NCRYPTBUFFER_SSL_CLEAR_KEY          23
#define NCRYPTBUFFER_SSL_KEY_ARG_DATA       24

#define NCRYPTBUFFER_PKCS_OID               40
#define NCRYPTBUFFER_PKCS_ALG_OID           41
#define NCRYPTBUFFER_PKCS_ALG_PARAM         42
#define NCRYPTBUFFER_PKCS_ALG_ID            43
#define NCRYPTBUFFER_PKCS_ATTRS             44
#define NCRYPTBUFFER_PKCS_KEY_NAME          45
#define NCRYPTBUFFER_PKCS_SECRET            46

#define NCRYPTBUFFER_CERT_BLOB              47

// NCRYPT shares the same BCRYPT definitions
typedef BCryptBuffer     NCryptBuffer;
typedef BCryptBuffer*    PNCryptBuffer;
typedef BCryptBufferDesc NCryptBufferDesc;
typedef BCryptBufferDesc* PNCryptBufferDesc;

//
// NCrypt handles
//

typedef ULONG_PTR NCRYPT_HANDLE;
typedef ULONG_PTR NCRYPT_PROV_HANDLE;
typedef ULONG_PTR NCRYPT_KEY_HANDLE;
typedef ULONG_PTR NCRYPT_HASH_HANDLE;
typedef ULONG_PTR NCRYPT_SECRET_HANDLE;


//
// NCrypt API Flags
//

#define NCRYPT_NO_PADDING_FLAG      BCRYPT_PAD_NONE
#define NCRYPT_PAD_PKCS1_FLAG       BCRYPT_PAD_PKCS1  // NCryptEncrypt/Decrypt NCryptSignHash/VerifySignature
#define NCRYPT_PAD_OAEP_FLAG        BCRYPT_PAD_OAEP   // BCryptEncrypt/Decrypt
#define NCRYPT_PAD_PSS_FLAG         BCRYPT_PAD_PSS    // BCryptSignHash/VerifySignature
#define NCRYPT_NO_KEY_VALIDATION    BCRYPT_NO_KEY_VALIDATION
#define NCRYPT_MACHINE_KEY_FLAG                 0x00000020  // same as CAPI CRYPT_MACHINE_KEYSET
#define NCRYPT_SILENT_FLAG                      0x00000040  // same as CAPI CRYPT_SILENT
#define NCRYPT_OVERWRITE_KEY_FLAG               0x00000080
#define NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG   0x00000200
#define NCRYPT_DO_NOT_FINALIZE_FLAG             0x00000400
#define NCRYPT_PERSIST_ONLY_FLAG                0x40000000
#define NCRYPT_PERSIST_FLAG                     0x80000000
#define NCRYPT_REGISTER_NOTIFY_FLAG             0x00000001
#define NCRYPT_UNREGISTER_NOTIFY_FLAG           0x00000002


//
// Functions used to manage persisted keys.
//
__checkReturn
SECURITY_STATUS
WINAPI
NCryptOpenStorageProvider(
    __out   NCRYPT_PROV_HANDLE *phProvider,
    __in_opt LPCWSTR pszProviderName,
    __in    DWORD   dwFlags);



// AlgOperations flags for use with NCryptEnumAlgorithms()
#define NCRYPT_CIPHER_OPERATION                 BCRYPT_CIPHER_OPERATION
#define NCRYPT_HASH_OPERATION                   BCRYPT_HASH_OPERATION
#define NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION  BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION
#define NCRYPT_SECRET_AGREEMENT_OPERATION       BCRYPT_SECRET_AGREEMENT_OPERATION
#define NCRYPT_SIGNATURE_OPERATION              BCRYPT_SIGNATURE_OPERATION
#define NCRYPT_RNG_OPERATION                    BCRYPT_RNG_OPERATION

// USE EXTREME CAUTION: editing comments that contain "certenrolls_*" tokens
// could break building CertEnroll idl files:
// certenrolls_begin -- NCryptAlgorithmName
typedef struct _NCryptAlgorithmName
{
    LPWSTR  pszName;
    DWORD   dwClass;            // the CNG interface that supports this algorithm
    DWORD   dwAlgOperations;    // the types of operations supported by this algorithm
    DWORD   dwFlags;
} NCryptAlgorithmName;
// certenrolls_end

__checkReturn
SECURITY_STATUS
WINAPI
NCryptEnumAlgorithms(
    __in    NCRYPT_PROV_HANDLE hProvider,
    __in    DWORD   dwAlgOperations,
    __out   DWORD * pdwAlgCount,
    __deref_out_ecount(*pdwAlgCount) NCryptAlgorithmName **ppAlgList,
    __in    DWORD   dwFlags);



__checkReturn
SECURITY_STATUS
WINAPI
NCryptIsAlgSupported(
    __in    NCRYPT_PROV_HANDLE hProvider,
    __in    LPCWSTR pszAlgId,
    __in    DWORD   dwFlags);



// NCryptEnumKeys flags
#define NCRYPT_MACHINE_KEY_FLAG         0x00000020

typedef struct NCryptKeyName
{
    LPWSTR  pszName;
    LPWSTR  pszAlgid;
    DWORD   dwLegacyKeySpec;
    DWORD   dwFlags;
} NCryptKeyName;

__checkReturn
SECURITY_STATUS
WINAPI
NCryptEnumKeys(
    __in    NCRYPT_PROV_HANDLE hProvider,
    __in_opt LPCWSTR pszScope,
    __deref_out NCryptKeyName **ppKeyName,
    __inout PVOID * ppEnumState,
    __in    DWORD   dwFlags);



typedef struct NCryptProviderName
{
    LPWSTR  pszName;
    LPWSTR  pszComment;
} NCryptProviderName;

__checkReturn
SECURITY_STATUS
WINAPI
NCryptEnumStorageProviders(
    __out   DWORD * pdwProviderCount,
    __deref_out_ecount(*pdwProviderCount) NCryptProviderName **ppProviderList,
    __in    DWORD   dwFlags);



SECURITY_STATUS
WINAPI
NCryptFreeBuffer(
    __deref PVOID   pvInput);



// NCryptOpenKey flags
#define NCRYPT_MACHINE_KEY_FLAG         0x00000020
#define NCRYPT_SILENT_FLAG              0x00000040

__checkReturn
SECURITY_STATUS
WINAPI
NCryptOpenKey(
    __inout NCRYPT_PROV_HANDLE hProvider,
    __out   NCRYPT_KEY_HANDLE *phKey,
    __in    LPCWSTR pszKeyName,
    __in_opt DWORD  dwLegacyKeySpec,
    __in    DWORD   dwFlags);



// NCryptCreatePersistedKey flags
#define NCRYPT_MACHINE_KEY_FLAG         0x00000020
#define NCRYPT_OVERWRITE_KEY_FLAG       0x00000080

__checkReturn
SECURITY_STATUS
WINAPI
NCryptCreatePersistedKey(
    __in    NCRYPT_PROV_HANDLE hProvider,
    __out   NCRYPT_KEY_HANDLE *phKey,
    __in    LPCWSTR pszAlgId,
    __in_opt LPCWSTR pszKeyName,
    __in    DWORD   dwLegacyKeySpec,
    __in    DWORD   dwFlags);



// Standard property names.
#define NCRYPT_NAME_PROPERTY                    L"Name"
#define NCRYPT_UNIQUE_NAME_PROPERTY             L"Unique Name"
#define NCRYPT_ALGORITHM_PROPERTY               L"Algorithm Name"
#define NCRYPT_LENGTH_PROPERTY                  L"Length"
#define NCRYPT_LENGTHS_PROPERTY                 L"Lengths"
#define NCRYPT_BLOCK_LENGTH_PROPERTY            L"Block Length"
#define NCRYPT_UI_POLICY_PROPERTY               L"UI Policy"
#define NCRYPT_EXPORT_POLICY_PROPERTY           L"Export Policy"
#define NCRYPT_WINDOW_HANDLE_PROPERTY           L"HWND Handle"
#define NCRYPT_USE_CONTEXT_PROPERTY             L"Use Context"
#define NCRYPT_IMPL_TYPE_PROPERTY               L"Impl Type"
#define NCRYPT_KEY_USAGE_PROPERTY               L"Key Usage"
#define NCRYPT_KEY_TYPE_PROPERTY                L"Key Type"
#define NCRYPT_VERSION_PROPERTY                 L"Version"
#define NCRYPT_SECURITY_DESCR_SUPPORT_PROPERTY  L"Security Descr Support"
#define NCRYPT_SECURITY_DESCR_PROPERTY          L"Security Descr"
#define NCRYPT_USE_COUNT_ENABLED_PROPERTY       L"Enabled Use Count"
#define NCRYPT_USE_COUNT_PROPERTY               L"Use Count"
#define NCRYPT_LAST_MODIFIED_PROPERTY           L"Modified"
#define NCRYPT_MAX_NAME_LENGTH_PROPERTY         L"Max Name Length"
#define NCRYPT_ALGORITHM_GROUP_PROPERTY         L"Algorithm Group"
#define NCRYPT_DH_PARAMETERS_PROPERTY           BCRYPT_DH_PARAMETERS
#define NCRYPT_PROVIDER_HANDLE_PROPERTY         L"Provider Handle"
#define NCRYPT_PIN_PROPERTY                     L"SmartCardPin"
#define NCRYPT_READER_PROPERTY                  L"SmartCardReader"
#define NCRYPT_SMARTCARD_GUID_PROPERTY          L"SmartCardGuid"
#define NCRYPT_CERTIFICATE_PROPERTY             L"SmartCardKeyCertificate"
#define NCRYPT_PIN_PROMPT_PROPERTY              L"SmartCardPinPrompt"
#define NCRYPT_USER_CERTSTORE_PROPERTY          L"SmartCardUserCertStore"
#define NCRYPT_ROOT_CERTSTORE_PROPERTY          L"SmartcardRootCertStore"
#define NCRYPT_SECURE_PIN_PROPERTY              L"SmartCardSecurePin"
#define NCRYPT_ASSOCIATED_ECDH_KEY              L"SmartCardAssociatedECDHKey"
#define NCRYPT_SCARD_PIN_ID                     L"SmartCardPinId"
#define NCRYPT_SCARD_PIN_INFO                   L"SmartCardPinInfo"

// Maximum length of property name (in characters)
#define NCRYPT_MAX_PROPERTY_NAME        64

// Maximum length of property data (in bytes)
#define NCRYPT_MAX_PROPERTY_DATA        0x100000

// NCRYPT_EXPORT_POLICY_PROPERTY property flags.
#define NCRYPT_ALLOW_EXPORT_FLAG                0x00000001
#define NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG      0x00000002
#define NCRYPT_ALLOW_ARCHIVING_FLAG             0x00000004
#define NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG   0x00000008

// NCRYPT_IMPL_TYPE_PROPERTY property flags.
#define NCRYPT_IMPL_HARDWARE_FLAG               0x00000001
#define NCRYPT_IMPL_SOFTWARE_FLAG               0x00000002
#define NCRYPT_IMPL_REMOVABLE_FLAG              0x00000008
#define NCRYPT_IMPL_HARDWARE_RNG_FLAG           0x00000010

// NCRYPT_KEY_USAGE_PROPERTY property flags.
#define NCRYPT_ALLOW_DECRYPT_FLAG               0x00000001
#define NCRYPT_ALLOW_SIGNING_FLAG               0x00000002
#define NCRYPT_ALLOW_KEY_AGREEMENT_FLAG         0x00000004
#define NCRYPT_ALLOW_ALL_USAGES                 0x00ffffff

// NCRYPT_UI_POLICY_PROPERTY property flags and structure
#define NCRYPT_UI_PROTECT_KEY_FLAG              0x00000001
#define NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG    0x00000002

typedef struct __NCRYPT_UI_POLICY_BLOB
{
    DWORD   dwVersion;
    DWORD   dwFlags;
    DWORD   cbCreationTitle;
    DWORD   cbFriendlyName;
    DWORD   cbDescription;
    // creation title string
    // friendly name string
    // description string
} NCRYPT_UI_POLICY_BLOB;

typedef struct __NCRYPT_UI_POLICY
{
    DWORD   dwVersion;
    DWORD   dwFlags;
    LPCWSTR pszCreationTitle;
    LPCWSTR pszFriendlyName;
    LPCWSTR pszDescription;
} NCRYPT_UI_POLICY;


// NCRYPT_LENGTHS_PROPERTY property structure.
typedef struct __NCRYPT_SUPPORTED_LENGTHS
{
    DWORD   dwMinLength;
    DWORD   dwMaxLength;
    DWORD   dwIncrement;
    DWORD   dwDefaultLength;
} NCRYPT_SUPPORTED_LENGTHS;

// NCryptGetProperty flags
#define NCRYPT_PERSIST_ONLY_FLAG        0x40000000

__checkReturn
SECURITY_STATUS
WINAPI
NCryptGetProperty(
    __in    NCRYPT_HANDLE hObject,
    __in    LPCWSTR pszProperty,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);



// NCryptSetProperty flags
#define NCRYPT_PERSIST_FLAG             0x80000000
#define NCRYPT_PERSIST_ONLY_FLAG        0x40000000

__checkReturn
SECURITY_STATUS
WINAPI
NCryptSetProperty(
    __in    NCRYPT_HANDLE hObject,
    __in    LPCWSTR pszProperty,
    __in_bcount(cbInput) PBYTE pbInput,
    __in    DWORD   cbInput,
    __in    DWORD   dwFlags);



#define     NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG   0x00000200

__checkReturn
SECURITY_STATUS
WINAPI
NCryptFinalizeKey(
    __in    NCRYPT_KEY_HANDLE hKey,
    __in    DWORD   dwFlags);



__checkReturn
SECURITY_STATUS
WINAPI
NCryptEncrypt(
    __in    NCRYPT_KEY_HANDLE hKey,
    __in_bcount_opt(cbInput) PBYTE pbInput,
    __in    DWORD   cbInput,
    __in_opt    VOID *pPaddingInfo,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);



__checkReturn
SECURITY_STATUS
WINAPI
NCryptDecrypt(
    __in    NCRYPT_KEY_HANDLE hKey,
    __in_bcount_opt(cbInput) PBYTE pbInput,
    __in    DWORD   cbInput,
    __in_opt    VOID *pPaddingInfo,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);



#define NCRYPT_PKCS7_ENVELOPE_BLOB      L"PKCS7_ENVELOPE"
#define NCRYPT_PKCS8_PRIVATE_KEY_BLOB   L"PKCS8_PRIVATEKEY"
#define NCRYPT_OPAQUETRANSPORT_BLOB     L"OpaqueTransport"

#define NCRYPT_MACHINE_KEY_FLAG         0x00000020
#define NCRYPT_DO_NOT_FINALIZE_FLAG     0x00000400
#define NCRYPT_EXPORT_LEGACY_FLAG       0x00000800

__checkReturn
SECURITY_STATUS
WINAPI
NCryptImportKey(
    __in    NCRYPT_PROV_HANDLE hProvider,
    __in_opt NCRYPT_KEY_HANDLE hImportKey,
    __in    LPCWSTR pszBlobType,
    __in_opt NCryptBufferDesc *pParameterList,
    __out   NCRYPT_KEY_HANDLE *phKey,
    __in_bcount(cbData) PBYTE pbData,
    __in    DWORD   cbData,
    __in    DWORD   dwFlags);



__checkReturn
SECURITY_STATUS
WINAPI
NCryptExportKey(
    __in    NCRYPT_KEY_HANDLE hKey,
    __in_opt NCRYPT_KEY_HANDLE hExportKey,
    __in    LPCWSTR pszBlobType,
    __in_opt NCryptBufferDesc *pParameterList,
    __out_bcount_part_opt(cbOutput, *pcbResult) PBYTE pbOutput,
    __in    DWORD   cbOutput,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);



__checkReturn
SECURITY_STATUS
WINAPI
NCryptSignHash(
    __in    NCRYPT_KEY_HANDLE hKey,
    __in_opt    VOID *pPaddingInfo,
    __in_bcount(cbHashValue) PBYTE pbHashValue,
    __in    DWORD   cbHashValue,
    __out_bcount_part_opt(cbSignature, *pcbResult) PBYTE pbSignature,
    __in    DWORD   cbSignature,
    __out   DWORD * pcbResult,
    __in    DWORD   dwFlags);



__checkReturn
SECURITY_STATUS
WINAPI
NCryptVerifySignature(
    __in    NCRYPT_KEY_HANDLE hKey,
    __in_opt    VOID *pPaddingInfo,
    __in_bcount(cbHashValue) PBYTE pbHashValue,
    __in    DWORD   cbHashValue,
    __in_bcount(cbSignature) PBYTE pbSignature,
    __in    DWORD   cbSignature,
    __in    DWORD   dwFlags);



SECURITY_STATUS
WINAPI
NCryptDeleteKey(
    __in    NCRYPT_KEY_HANDLE hKey,
    __in    DWORD   dwFlags);



SECURITY_STATUS
WINAPI
NCryptFreeObject(
    __in    NCRYPT_HANDLE hObject);



BOOL
WINAPI
NCryptIsKeyHandle(
    __in    NCRYPT_KEY_HANDLE hKey);

__checkReturn
SECURITY_STATUS
WINAPI
NCryptTranslateHandle(
    __out_opt NCRYPT_PROV_HANDLE *phProvider,
    __out   NCRYPT_KEY_HANDLE *phKey,
    __in    HCRYPTPROV hLegacyProv,
    __in_opt HCRYPTKEY hLegacyKey,
    __in_opt DWORD  dwLegacyKeySpec,
    __in    DWORD   dwFlags);



// NCryptNotifyChangeKey flags
#define NCRYPT_REGISTER_NOTIFY_FLAG     0x00000001
#define NCRYPT_UNREGISTER_NOTIFY_FLAG   0x00000002
#define NCRYPT_MACHINE_KEY_FLAG         0x00000020

__checkReturn
SECURITY_STATUS
WINAPI
NCryptNotifyChangeKey(
    __in    NCRYPT_PROV_HANDLE hProvider,
    __inout HANDLE *phEvent,
    __in    DWORD   dwFlags);



__checkReturn
SECURITY_STATUS
WINAPI
NCryptSecretAgreement(
    __in    NCRYPT_KEY_HANDLE hPrivKey,
    __in    NCRYPT_KEY_HANDLE hPubKey,
    __out   NCRYPT_SECRET_HANDLE *phAgreedSecret,
    __in    DWORD   dwFlags);



__checkReturn
SECURITY_STATUS
WINAPI
NCryptDeriveKey(
    __in        NCRYPT_SECRET_HANDLE hSharedSecret,
    __in        LPCWSTR              pwszKDF,
    __in_opt    NCryptBufferDesc     *pParameterList,
    __out_bcount_part_opt(cbDerivedKey, *pcbResult) PBYTE pbDerivedKey,
    __in        DWORD                cbDerivedKey,
    __out       DWORD                *pcbResult,
    __in        ULONG                dwFlags);



#define NCRYPT_KEY_STORAGE_INTERFACE_VERSION BCRYPT_MAKE_INTERFACE_VERSION(1,0)



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __NCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ndrtypes.h ===
/*++

Copyright (c) 1993-1999 Microsoft Corporation

Module Name:

    ndrtypes.h

Abstract:

    Definitions of new NDR format string types.

Revision History:

    DKays    Sep-1993     Created.

--*/

#ifndef __NDRTYPES_H__
#define __NDRTYPES_H__

#include <limits.h>
#ifdef __cplusplus
extern "C" {
#endif

//
// We use C compiler constants like _I16_MIN or _UI32_MAX from limits.h
// when we need to check for integral boundaries.

#define UNION_OFFSET16_MIN      -32512 /*0x8100*/

// These are pointer sizes used by the compiler.
// As they we do cross-compilation, they cannot be expressed as sizeof(void*).
// The native pointer sizes used by the NDR engine are defined in ndrp.h.

#define PTR_WIRE_SIZE       4

#define NT64_PTR_SIZE       8
#define NT32_PTR_SIZE       4
#define SIZEOF_PTR( f64 )   ((f64) ? NT64_PTR_SIZE : NT32_PTR_SIZE )
#define SIZEOF_MEM_PTR()    ((pCommand->Is64BitEnv()) ? NT64_PTR_SIZE : NT32_PTR_SIZE )

#define SIZEOF_INT3264()    ((pCommand->Is64BitEnv()) ? 8 : 4 )

//
// Ndr versions.  Versions history is as follows :
//
//      1.1 - Windows NT version 3.5
//      1.1 - Windows NT version 3.51
//      2.0 - Windows NT version 4.0
//               2.0 is switched on for Oi2, user_marshal, pipes.
//      5.0 - Windows NT version 5.0, beta1
//               [message], object pipes, async rpc
//      5.2 - Windows NT version 5.0, beta2
//               /robust, [notify] in -Oicf, [async_uuid()]
//               extensions to the format string descriptors.
//      5.3 - Windows 2000 (NT ver. 5.0), beta3 RC1
//               unlimited number of methods with stubless proxies
//      5.4 - Windows 2000 (NT ver. 5.0), beta3
//              pickling with -Oicf
//
// A stub can not be used with an rpcrt4.dll which has a version number
// less than the version number emitted in the stub.  A stub with a lower
// version number than the rpcrt4.dll must work.
//
// Note that the MIDL version is used to choose between -Oi and -Oi2
// interpreters when NDR version is 2.0 or later as now the compiler
// generates an explicit flag indicating the interpreter flavor.
// The compiler version needs to be 3.0.39 or later for that.
//
// Since MIDL 3.3.126, for object interfaces, we have proc header extensions,
// and async uuid supported. Also since the same version, for object interfaces
// the header has a fixed size as we always generate rpcflags into the header
// and always generate an "autohandle" handle. Hence, the oicf interpreter flags
// and also the extended header is always at the fixed position.
//
// The MIDL version history is as follows.
//
//     Windows NT ver. 3.1   - MIDL 1.0
//     Windows NT ver. 3.5   - MIDL 2.0.72              __midl macro
//     Windows NT ver. 3.51  - MIDL 2.0.102 (internally, .104)   vers. in StubDesc
//     Windows NT ver. 4.0   - MIDL 3.0.44              user_marshal, pipes
//     VC 5.0                - MIDL 3.1.75
//     Windows NT ver. 5.0   - MIDL 3.1.76  IDW
//                           - MIDL 3.2.88  IDW
//                           - MIDL 3.3.110 beta1       async rpc
//                           - MIDL 5.0.140             async_uuid, robust
//                           - MIDL 5.1.164 beta2       midl_pragma warning
//     VC 6.0                - MIDL 5.1.164
//     Windows NT 5.0 saga   - MIDL 5.2.204             64b support
//        now WIndows 2000   - MIDL 5.2.235 beta3       netmon 
//                           - MIDL 5.3.266             midl/midlc exe split
//
// The MIDL version is generated into the stub descriptor starting with
// MIDL ver.2.0.96 (pre NT 3.51 beta 2, Feb 95).
// See ndr20\ndrp.h for constants used for specific versions.
//


#define NDR_MAJOR_VERSION   5UL
#define NDR_MINOR_VERSION   4UL
#define NDR_VERSION         ((NDR_MAJOR_VERSION << 16) | NDR_MINOR_VERSION)

#define NDR_VERSION_1_1     ((1UL << 16) | 1UL)
#define NDR_VERSION_2_0     ((2UL << 16) | 0UL)
#define NDR_VERSION_5_0     ((5UL << 16) | 0UL)
#define NDR_VERSION_5_2     ((5UL << 16) | 2UL)
#define NDR_VERSION_5_3     ((5UL << 16) | 3UL)
#define NDR_VERSION_5_4     ((5UL << 16) | 4UL)

// !!! WARNING !!!
//
// These definitions should be removed in conjunction with Automation
// check-in for dual TLBs.
//

#define LOAD_TLB_AS_64BIT   0
#define LOAD_TLB_AS_32BIT   0

//
// !!! WARNING WARNING WARNING !!!
//
// All of the format character values up to FC_PAD can no longer be changed,
// in order to preserve NT 3.5 compatability (excluding those marked as
// FC_UNUSED*, these were unused format characters in NDR library version 1.1).
// Their ordinal number, as well as semantics, must remain.
//
// When additional format characters are added (at the end), changes must
// be made in ndr20 as well as midl20\codegen\frmtstr.cxx to handle the
// new type.
// In particular, there is a pFormatCharNames table and a pNdrRoutineNames table
// that should be kept in ssync.
//
// !!! WARNING WARNING WARNING !!!
//

typedef enum {

    //
    // This might catch some errors, probably can be removed after debugging.
    //
    FC_ZERO,

    //
    // Simple integer and floating point types.
    //

    FC_BYTE,                    // 0x01
    FC_CHAR,                    // 0x02
    FC_SMALL,                   // 0x03
    FC_USMALL,                  // 0x04

    FC_WCHAR,                   // 0x05
    FC_SHORT,                   // 0x06
    FC_USHORT,                  // 0x07

    FC_LONG,                    // 0x08
    FC_ULONG,                   // 0x09

    FC_FLOAT,                   // 0x0a

    FC_HYPER,                   // 0x0b

    FC_DOUBLE,                  // 0x0c

    //
    // Enums.
    //
    FC_ENUM16,                  // 0x0d
    FC_ENUM32,                  // 0x0e

    //
    // !!!IMPORTANT!!!
    // All format charaters which appear before this comment must have an
    // enum value which will fit in 4 bits.
    //

    //
    // Special.
    //
    FC_IGNORE,                  // 0x0f
    FC_ERROR_STATUS_T,          // 0x10

    //
    // Pointer types :
    //     RP - reference pointer
    //     UP - unique pointer
    //     OP - OLE unique pointer
    //     FP - full pointer
    //

    FC_RP,                      // 0x11
    FC_UP,                      // 0x12
    FC_OP,                      // 0x13
    FC_FP,                      // 0x14

    //
    // Structures
    //

    //
    // Structure containing only simple types and fixed arrays.
    //
    FC_STRUCT,                  // 0x15

    //
    // Structure containing only simple types, pointers and fixed arrays.
    //
    FC_PSTRUCT,                 // 0x16

    //
    // Structure containing a conformant array plus all those types
    // allowed by FC_STRUCT.
    //
    FC_CSTRUCT,                 // 0x17

    //
    // Struct containing a conformant array plus all those types allowed by
    // FC_PSTRUCT.
    //
    FC_CPSTRUCT,                // 0x18

    //
    // Struct containing either a conformant varying array or a conformant
    // string, plus all those types allowed by FC_PSTRUCT.
    //
    FC_CVSTRUCT,                // 0x19

    //
    // Complex struct - totally bogus!
    //
    FC_BOGUS_STRUCT,            // 0x1a

    //
    // Arrays.
    //

    //
    // Conformant arrray.
    //
    FC_CARRAY,                  // 0x1b

    //
    // Conformant varying array.
    //
    FC_CVARRAY,                 // 0x1c

    //
    // Fixed array, small and large.
    //
    FC_SMFARRAY,                // 0x1d
    FC_LGFARRAY,                // 0x1e

    //
    // Varying array, small and large.
    //
    FC_SMVARRAY,                // 0x1f
    FC_LGVARRAY,                // 0x20

    //
    // Complex arrays - totally bogus!
    //
    FC_BOGUS_ARRAY,             // 0x21

    //
    // Strings :
    //
    // The order of these should have been moved around, but it's too late
    // now.
    //
    //     CSTRING - character string
    //     BSTRING - byte string (Beta2 compatability only)
    //     SSTRING - structure string
    //     WSTRING - wide charater string
    //

    //
    // Conformant strings.
    //
    FC_C_CSTRING,               // 0x22
    FC_C_BSTRING,               // 0x23
    FC_C_SSTRING,               // 0x24
    FC_C_WSTRING,               // 0x25

    //
    // Non-conformant strings.
    //
    FC_CSTRING,                 // 0x26
    FC_BSTRING,                 // 0x27
    FC_SSTRING,                 // 0x28
    FC_WSTRING,                 // 0x29

    //
    // Unions
    //
    FC_ENCAPSULATED_UNION,      // 0x2a
    FC_NON_ENCAPSULATED_UNION,  // 0x2b

    //
    // Byte count pointer.
    //
    FC_BYTE_COUNT_POINTER,      // 0x2c

    //
    // transmit_as and represent_as
    //
    FC_TRANSMIT_AS,             // 0x2d
    FC_REPRESENT_AS,            // 0x2e

    //
    // Cairo Interface pointer.
    //
    FC_IP,                      // 0x2f

    //
    // Binding handle types
    //
    FC_BIND_CONTEXT,            // 0x30
    FC_BIND_GENERIC,            // 0x31
    FC_BIND_PRIMITIVE,          // 0x32
    FC_AUTO_HANDLE,             // 0x33
    FC_CALLBACK_HANDLE,         // 0x34
    FC_UNUSED1,                 // 0x35

    // Embedded pointer - used in complex structure layouts only.
    FC_POINTER,                 // 0x36

    //
    // Alignment directives, used in structure layouts.
    //
    FC_ALIGNM2,                 // 0x37
    FC_ALIGNM4,                 // 0x38
    FC_ALIGNM8,                 // 0x39

    FC_UNUSED2,                 // 0x3a
    FC_UNUSED3,                 // 0x3b
    FC_UNUSED4,                 // 0x3c

    //
    // Structure padding directives, used in structure layouts only.
    //
    FC_STRUCTPAD1,              // 0x3d
    FC_STRUCTPAD2,              // 0x3e
    FC_STRUCTPAD3,              // 0x3f
    FC_STRUCTPAD4,              // 0x40
    FC_STRUCTPAD5,              // 0x41
    FC_STRUCTPAD6,              // 0x42
    FC_STRUCTPAD7,              // 0x43

    //
    // Additional string attribute.
    //
    FC_STRING_SIZED,            // 0x44

    FC_UNUSED5,                 // 0x45

    //
    // Pointer layout attributes.
    //
    FC_NO_REPEAT,               // 0x46
    FC_FIXED_REPEAT,            // 0x47
    FC_VARIABLE_REPEAT,         // 0x48
    FC_FIXED_OFFSET,            // 0x49
    FC_VARIABLE_OFFSET,         // 0x4a

    // Pointer section delimiter.
    FC_PP,                      // 0x4b

    // Embedded complex type.
    FC_EMBEDDED_COMPLEX,        // 0x4c

    // Parameter attributes.
    FC_IN_PARAM,                // 0x4d
    FC_IN_PARAM_BASETYPE,       // 0x4e
    FC_IN_PARAM_NO_FREE_INST,   // 0x4d
    FC_IN_OUT_PARAM,            // 0x50
    FC_OUT_PARAM,               // 0x51
    FC_RETURN_PARAM,            // 0x52
    FC_RETURN_PARAM_BASETYPE,   // 0x53

    //
    // Conformance/variance attributes.
    //
    FC_DEREFERENCE,             // 0x54
    FC_DIV_2,                   // 0x55
    FC_MULT_2,                  // 0x56
    FC_ADD_1,                   // 0x57
    FC_SUB_1,                   // 0x58
    FC_CALLBACK,                // 0x59

    // Iid flag.
    FC_CONSTANT_IID,            // 0x5a

    FC_END,                     // 0x5b
    FC_PAD,                     // 0x5c

    //
    // split Conformance/variance attributes.
    //
    FC_SPLIT_DEREFERENCE = 0x74,      // 0x74
    FC_SPLIT_DIV_2,                   // 0x75
    FC_SPLIT_MULT_2,                  // 0x76
    FC_SPLIT_ADD_1,                   // 0x77
    FC_SPLIT_SUB_1,                   // 0x78
    FC_SPLIT_CALLBACK,                // 0x79

    //
    // **********************************
    // New Post NT 3.5 format characters.
    // **********************************
    //

    //
    // Attributes, directives, etc.
    //

    //
    // New types.
    //
    // These start at 0xb1 (0x31 + 0x80) so that their routines can simply be
    // placed sequentially in the various routine tables, while using
    // a new ROUTINE_INDEX() macro which strips off the most significant bit
    // of the format character.  The value 0x31 is the next value after
    // FC_BIND_CONTEXT, whose routines were previously the last to appear
    // in the routine tables.
    //
    FC_HARD_STRUCT = 0xb1,      // 0xb1

    FC_TRANSMIT_AS_PTR,         // 0xb2
    FC_REPRESENT_AS_PTR,        // 0xb3

    FC_USER_MARSHAL,            // 0xb4

    FC_PIPE,                    // 0xb5

    FC_BLKHOLE,                 // 0xb6

    FC_RANGE,                   // 0xb7     NT 5 beta2 MIDL 3.3.110

    FC_INT3264,                 // 0xb8     NT 5 beta2, MIDL64, 5.1.194+
    FC_UINT3264,                // 0xb9     NT 5 beta2, MIDL64, 5.1.194+

    FC_END_OF_UNIVERSE          // 0xba
} FORMAT_CHARACTER;


#if !defined(__RPC_MAC__)
//
// Interpreter bit flag structures.
//

// These are the old Oi interpreter proc flags.

typedef struct
    {
    unsigned char   FullPtrUsed             : 1;    // 0x01
    unsigned char   RpcSsAllocUsed          : 1;    // 0x02
    unsigned char   ObjectProc              : 1;    // 0x04
    unsigned char   HasRpcFlags             : 1;    // 0x08
    unsigned char   IgnoreObjectException   : 1;    // 0x10
    unsigned char   HasCommOrFault          : 1;    // 0x20
    unsigned char   UseNewInitRoutines      : 1;    // 0x40
    unsigned char   Unused                  : 1;
    } INTERPRETER_FLAGS, *PINTERPRETER_FLAGS;

// These are the Oi2 parameter flags.

typedef struct
    {
    unsigned short  MustSize            : 1;    // 0x0001
    unsigned short  MustFree            : 1;    // 0x0002
    unsigned short  IsPipe              : 1;    // 0x0004
    unsigned short  IsIn                : 1;    // 0x0008
    unsigned short  IsOut               : 1;    // 0x0010
    unsigned short  IsReturn            : 1;    // 0x0020
    unsigned short  IsBasetype          : 1;    // 0x0040
    unsigned short  IsByValue           : 1;    // 0x0080
    unsigned short  IsSimpleRef         : 1;    // 0x0100
    unsigned short  IsDontCallFreeInst  : 1;    // 0x0200
    unsigned short  SaveForAsyncFinish  : 1;    // 0x0400
    unsigned short  Unused              : 2;
    unsigned short  ServerAllocSize     : 3;    // 0xe000
    } PARAM_ATTRIBUTES, *PPARAM_ATTRIBUTES;

// These are the new Oi2 proc flags.

typedef struct
    {
    unsigned char   ServerMustSize      : 1;    // 0x01
    unsigned char   ClientMustSize      : 1;    // 0x02
    unsigned char   HasReturn           : 1;    // 0x04
    unsigned char   HasPipes            : 1;    // 0x08
    unsigned char   Unused              : 1;
    unsigned char   HasAsyncUuid        : 1;    // 0x20
    unsigned char   HasExtensions       : 1;    // 0x40
    unsigned char   HasAsyncHandle      : 1;    // 0x80
    } INTERPRETER_OPT_FLAGS, *PINTERPRETER_OPT_FLAGS;

// This is the proc header layout for object procs starting with MIDL 3.3.129,
// introduced for the async_uuid() support in dcom but generated for ony object
// interface, regardless of the compiler mode and interface being async.
// Handle is always autohandle and so there never is explicit handle descriptor.
// RpcFlags are always present to make the layout fixed.

typedef struct _NDR_DCOM_OI2_PROC_HEADER
    {
    unsigned char               HandleType;          // The old Oi header
    INTERPRETER_FLAGS           OldOiFlags;          //
    unsigned short              RpcFlagsLow;         //
    unsigned short              RpcFlagsHi;          //
    unsigned short              ProcNum;             //
    unsigned short              StackSize;           //
    // expl handle descr is never generated          //
    unsigned short              ClientBufferSize;    // The Oi2 header
    unsigned short              ServerBufferSize;    //
    INTERPRETER_OPT_FLAGS       Oi2Flags;            //
    unsigned char               NumberParams;        //
    } NDR_DCOM_OI2_PROC_HEADER, *PNDR_DCOM_OI2_PROC_HEADER;

// These are extended Oi2 interpreter proc flags.
// They have been introduced for NT5 beta2.

typedef struct
    {
    unsigned char   HasNewCorrDesc      : 1;    // 0x01
    unsigned char   ClientCorrCheck     : 1;    // 0x02
    unsigned char   ServerCorrCheck     : 1;    // 0x04
    unsigned char   HasNotify           : 1;    // 0x08
    unsigned char   HasNotify2          : 1;    // 0x10
    unsigned char   Unused              : 3;
    } INTERPRETER_OPT_FLAGS2, *PINTERPRETER_OPT_FLAGS2;

// This is the layout of the proc header extensions introduced for denial of
// attacks for NT5 beta2, MIDL version 3.3.129.
// The extensions would be announced by the HasExtensions Oi2 flag and would
// follow directly after the ParameterCount field of Oi2 header.

typedef struct
    {
    unsigned char               Size;   // size as the extension version
    INTERPRETER_OPT_FLAGS2      Flags2;
    unsigned short              ClientCorrHint;
    unsigned short              ServerCorrHint;
    unsigned short              NotifyIndex;
    } NDR_PROC_HEADER_EXTS, *PNDR_PROC_HEADER_EXTS;

typedef struct
    {
    unsigned char               Size;   // size as the extension version
    INTERPRETER_OPT_FLAGS2      Flags2;
    unsigned short              ClientCorrHint;
    unsigned short              ServerCorrHint;
    unsigned short              NotifyIndex;
    unsigned short              FloatArgMask;
    } NDR_PROC_HEADER_EXTS64, *PNDR_PROC_HEADER_EXTS64;


// Context handle flags

typedef struct
    {
    unsigned char   CannotBeNull        : 1;    // 0x01
    unsigned char   Serialize           : 1;    // 0x02
    unsigned char   NoSerialize         : 1;    // 0x04
    unsigned char   IsStrict            : 1;    // 0x08
    unsigned char   IsReturn            : 1;    // 0x10
    unsigned char   IsOut               : 1;    // 0x20
    unsigned char   IsIn                : 1;    // 0x40
    unsigned char   IsViaPtr            : 1;    // 0x80

    } NDR_CONTEXT_HANDLE_FLAGS, *PNDR_CONTEXT_HANDLE_FLAGS;

// Type pickling flags

typedef struct _MIDL_TYPE_PICKLING_FLAGS
    {
    unsigned long   Oicf                : 1;
    unsigned long   HasNewCorrDesc      : 1;
    unsigned long   Unused              : 30;
    } MIDL_TYPE_PICKLING_FLAGS, *PMIDL_TYPE_PICKLING_FLAGS;

#else
// now Mac defs: bits are flipped on Mac.

typedef struct
    {
    unsigned char   Unused              : 3;
    unsigned char   HasNotify2          : 1;    // 0x10
    unsigned char   HasNotify           : 1;    // 0x08
    unsigned char   ServerCorrCheck     : 1;    // 0x04
    unsigned char   ClientCorrCheck     : 1;    // 0x02
    unsigned char   HasNewCorrDec       : 1;    // 0x01
    } INTERPRETER_OPT_FLAGS2, *PINTERPRETER_OPT_FLAGS2;

typedef struct
    {
    unsigned char   Unused                  : 1;
    unsigned char   UseNewInitRoutines      : 1;    // 0x40
    unsigned char   HasCommOrFault          : 1;    // 0x20
    unsigned char   IgnoreObjectException   : 1;    // 0x10
    unsigned char   HasRpcFlags             : 1;    // 0x08
    unsigned char   ObjectProc              : 1;    // 0x04
    unsigned char   RpcSsAllocUsed          : 1;    // 0x02
    unsigned char   FullPtrUsed             : 1;    // 0x01
    } INTERPRETER_FLAGS, *PINTERPRETER_FLAGS;

typedef struct
    {
    unsigned char   HasAsyncHandle      : 1;    // 0x80
    unsigned char   HasExtensions       : 1;    // 0x40
    unsigned char   Unused              : 2;
    unsigned char   HasPipes            : 1;    // 0x08
    unsigned char   HasReturn           : 1;    // 0x04
    unsigned char   ClientMustSize      : 1;    // 0x02
    unsigned char   ServerMustSize      : 1;    // 0x01
    } INTERPRETER_OPT_FLAGS, *PINTERPRETER_OPT_FLAGS;

typedef struct
    {
    unsigned short  ServerAllocSize     : 3;    // 0xe000
    unsigned short  Unused              : 2;
    unsigned short  SaveForAsyncFinish  : 1;    // 0x0400
    unsigned short  IsDontCallFreeInst  : 1;    // 0x0200
    unsigned short  IsSimpleRef         : 1;    // 0x0100
//
    unsigned short  IsByValue           : 1;    // 0x0080
    unsigned short  IsBasetype          : 1;    // 0x0040
    unsigned short  IsReturn            : 1;    // 0x0020
    unsigned short  IsOut               : 1;    // 0x0010
    unsigned short  IsIn                : 1;    // 0x0008
    unsigned short  IsPipe              : 1;    // 0x0004
    unsigned short  MustFree            : 1;    // 0x0002
    unsigned short  MustSize            : 1;    // 0x0001
    } PARAM_ATTRIBUTES, *PPARAM_ATTRIBUTES;

#endif

#define MAX_INTERPRETER_OUT_SIZE        128
#define MAX_INTERPRETER_PARAM_OUT_SIZE  7 * 8

#define INTERPRETER_THUNK_PARAM_SIZE_THRESHOLD  (sizeof(long) * 32)

#define INTERPRETER_PROC_STACK_FRAME_SIZE_THRESHOLD  ( ( 64 * 1024 ) - 1 )

#define FC_NORMAL_CONFORMANCE           (unsigned char) 0x00
#define FC_POINTER_CONFORMANCE          (unsigned char) 0x10
#define FC_TOP_LEVEL_CONFORMANCE        (unsigned char) 0x20
#define FC_CONSTANT_CONFORMANCE         (unsigned char) 0x40
#define FC_TOP_LEVEL_MULTID_CONFORMANCE (unsigned char) 0x80

#define FC_NORMAL_VARIANCE              FC_NORMAL_CONFORMANCE
#define FC_POINTER_VARIANCE             FC_POINTER_CONFORMANCE
#define FC_TOP_LEVEL_VARIANCE           FC_TOP_LEVEL_CONFORMANCE
#define FC_CONSTANT_VARIANCE            FC_CONSTANT_CONFORMANCE
#define FC_TOP_LEVEL_MULTID_VARIANCE    FC_TOP_LEVEL_MULTID_CONFORMANCE

#define FC_NORMAL_SWITCH_IS             FC_NORMAL_CONFORMANCE
#define FC_POINTER_SWITCH_IS            FC_POINTER_CONFORMANCE
#define FC_TOP_LEVEL_SWITCH_IS          FC_TOP_LEVEL_CONFORMANCE
#define FC_CONSTANT_SWITCH_IS           FC_CONSTANT_CONFORMANCE

typedef  struct  _NDR_CORRELATION_FLAGS
    {
    unsigned char   Early    : 1;
    unsigned char   Split    : 1;
    unsigned char   IsIidIs  : 1;
    unsigned char   DontCheck: 1;
    unsigned char   Unused   : 4;
    } NDR_CORRELATION_FLAGS;

#define FC_EARLY_CORRELATION            (unsigned char) 0x01
#define FC_SPLIT_CORRELATION            (unsigned char) 0x02
#define FC_IID_CORRELATION              (unsigned char) 0x04
#define FC_NOCHECK_CORRELATION          (unsigned char) 0x08

//
// Pointer attributes.
//
#define FC_ALLOCATE_ALL_NODES       0x01
#define FC_DONT_FREE                0x02
#define FC_ALLOCED_ON_STACK         0x04
#define FC_SIMPLE_POINTER           0x08
#define FC_POINTER_DEREF            0x10

#define LOW_NIBBLE(Byte)            (((unsigned char)Byte) & 0x0f)
#define HIGH_NIBBLE(Byte)           (((unsigned char)Byte) >> 4)

#define INVALID_RUNDOWN_ROUTINE_INDEX   255

//
// internal bits to represent operation bits
//

#define OPERATION_MAYBE         0x0001
#define OPERATION_BROADCAST     0x0002
#define OPERATION_IDEMPOTENT    0x0004
#define OPERATION_INPUT_SYNC    0x0008
#define OPERATION_ASYNC         0x0010
#define OPERATION_MESSAGE       0x0020

//
//  Transmit as / Represent as flag field flags.
//
//     Lower nibble of this byte has an alignment of the transmitted type.
//     Upper nibble keeps flags.
//

#define PRESENTED_TYPE_NO_FLAG_SET  0x00
#define PRESENTED_TYPE_IS_ARRAY     0x10
#define PRESENTED_TYPE_ALIGN_4      0x20
#define PRESENTED_TYPE_ALIGN_8      0x40

//
//  User marshal flags

#define USER_MARSHAL_POINTER        0xc0  /* unique or ref */

#define USER_MARSHAL_UNIQUE         0x80
#define USER_MARSHAL_REF            0x40
#define USER_MARSHAL_IID            0x20  /* user marshal has optional info */


//
//  Handle flags.
//
//  Lower nibble of this byte may have a generic handle size.
//  Upper nibble keeps flags.  ALL FLAGS ARE NOW USED.
//

#define HANDLE_PARAM_IS_VIA_PTR     0x80
#define HANDLE_PARAM_IS_IN          0x40
#define HANDLE_PARAM_IS_OUT         0x20
#define HANDLE_PARAM_IS_RETURN      0x10

// Lower nibble of this byte may have a generic handle size.
// For context handles, it is used for the following flags.

#define NDR_STRICT_CONTEXT_HANDLE             0x08   /* NT5 */
#define NDR_CONTEXT_HANDLE_NOSERIALIZE        0x04   /* NT5 */
#define NDR_CONTEXT_HANDLE_SERIALIZE          0x02   /* NT5 */
#define NDR_CONTEXT_HANDLE_CANNOT_BE_NULL     0x01   /* NT5 */

//  These are old interpreter flags.
//  Oi and pickling per procedure flags.
//

#define Oi_FULL_PTR_USED                        0x01
#define Oi_RPCSS_ALLOC_USED                     0x02
#define Oi_OBJECT_PROC                          0x04
#define Oi_HAS_RPCFLAGS                         0x08

//
// Bits 5, 6 and 7 are overloaded for use by both pickling and
// non-pickling conditions.
//
// Bit 5 (0x20) is overloaded for object interfaces to distinguish
//       between invocations of V1 and V2 intepreters for proxies and stubs.
//       Note that for backward compatibility the bit is actually set
//       for V1 as it is checked only when NDR version is 2 or later.
//

#define Oi_IGNORE_OBJECT_EXCEPTION_HANDLING     0x10

#define ENCODE_IS_USED                          0x10
#define DECODE_IS_USED                          0x20
#define PICKLING_HAS_COMM_OR_FAULT              0x40    // In -Oicf mode only

#define Oi_HAS_COMM_OR_FAULT                    0x20
#define Oi_OBJ_USE_V2_INTERPRETER               0x20

#define Oi_USE_NEW_INIT_ROUTINES                0x40
#define Oi_UNUSED                               0x80

//  The new -Oicf interpreter flags

#define Oif_HAS_ASYNC_UUID                     0x20

//  Extended new interpreter flags


//
// Union arm description types.
//
#define UNION_CONSECUTIVE_ARMS      1
#define UNION_SMALL_ARMS            2
#define UNION_LARGE_ARMS            3

// Pipe flags
#define FC_BIG_PIPE                 0x80
#define FC_OBJECT_PIPE              0x40
#define FC_PIPE_HAS_RANGE           0x20

// Black Hole flags
#define BLKHOLE_BASETYPE            0x01
#define BLKHOLE_FUNCTION            0x02
#define BLKHOLE_XURTYPE             0x04 // Xmit Usermarshal or Represent-as TYPE
//
// Union ex. magic union byte, now short
//
#define MAGIC_UNION_SHORT           ((unsigned short) 0x8000)

#define NDR_DEFAULT_CORR_CACHE_SIZE 400

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ndr64types.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ndr64types.h

Abstract:

    Definitions for NDR64 format strings.

--*/



#ifndef _NDR64TYPES_H
#define _NDR64TYPES_H

#include <pshpack8.h>

#include <guiddef.h>    // REVIEW: or just redefine GUID here
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning (disable: 4201)     // nameless struct/union
#pragma warning (disable: 4214)     // bitfield


typedef const void * FormatInfoRef;
#define INVALID_FRAGMENT_ID 0

/*
*  Format string types
*/
typedef unsigned __int8     NDR64_UINT8;
typedef unsigned __int16    NDR64_UINT16;
typedef unsigned __int32    NDR64_UINT32;
typedef unsigned __int64    NDR64_UINT64;

typedef __int8              NDR64_INT8;
typedef __int16             NDR64_INT16;
typedef __int32             NDR64_INT32;
typedef __int64             NDR64_INT64;

typedef NDR64_UINT8         NDR64_FORMAT_CHAR;
typedef const void *        PNDR64_FORMAT;
typedef NDR64_UINT8         NDR64_ALIGNMENT;
typedef NDR64_UINT32        NDR64_FORMAT_UINT32;


#define NDR64_FC_EXPLICIT_HANDLE    0
#define NDR64_FC_BIND_GENERIC       1
#define NDR64_FC_BIND_PRIMITIVE     2
#define NDR64_FC_AUTO_HANDLE        3
#define NDR64_FC_CALLBACK_HANDLE    4
#define NDR64_FC_NO_HANDLE          5


#if defined(__RPC_WIN32__)
typedef NDR64_INT32 NDR64_PTR_WIRE_TYPE;
#else
typedef NDR64_INT64 NDR64_PTR_WIRE_TYPE;
#endif

#define NDR64_PTR_WIRE_ALIGN (sizeof(NDR64_PTR_WIRE_TYPE)-1)

typedef NDR64_UINT64 NDR64_WIRE_COUNT_TYPE;
#define NDR64_WIRE_COUNT_ALIGN (sizeof(NDR64_WIRE_COUNT_TYPE)-1)

//
// Procedures and parameters
//

typedef struct _NDR64_PROC_FLAGS
{
    NDR64_UINT32    HandleType              : 3;        // 0x00000000
    NDR64_UINT32    ProcType                : 3;        // 0x00000008
    NDR64_UINT32    IsInterpreted           : 2;        // 0x00000040
    NDR64_UINT32    IsObject                : 1;        // 0x00000100
    NDR64_UINT32    IsAsync                 : 1;        // 0x00000200
    NDR64_UINT32    IsEncode                : 1;        // 0x00000400
    NDR64_UINT32    IsDecode                : 1;        // 0x00000800
    NDR64_UINT32    UsesFullPtrPackage      : 1;        // 0x00001000
    NDR64_UINT32    UsesRpcSmPackage        : 1;        // 0x00002000
    NDR64_UINT32    UsesPipes               : 1;        // 0x00004000
    NDR64_UINT32    HandlesExceptions       : 2;        // 0x00008000
    NDR64_UINT32    ServerMustSize          : 1;        // 0x00020000
    NDR64_UINT32    ClientMustSize          : 1;        // 0x00040000
    NDR64_UINT32    HasReturn               : 1;        // 0x00080000
    NDR64_UINT32    HasComplexReturn        : 1;        // 0x00100000
    NDR64_UINT32    ServerHasCorrelation    : 1;        // 0x00200000
    NDR64_UINT32    ClientHasCorrelation    : 1;        // 0x00400000
    NDR64_UINT32    HasNotify               : 1;        // 0x00800000
    NDR64_UINT32    HasOtherExtensions      : 1;        // 0x01000000
    NDR64_UINT32    HasBigByValueParam      : 1;        // 0x02000000
    NDR64_UINT32    Reserved                : 6;        // 0x04000000
} NDR64_PROC_FLAGS;

typedef struct _NDR64_RPC_FLAGS
{
    NDR64_UINT16    Idempotent          : 1;
    NDR64_UINT16    Broadcast           : 1;
    NDR64_UINT16    Maybe               : 1;
    NDR64_UINT16    Reserved0           : 1;
    NDR64_UINT16    HasGuarantee        : 1;
    NDR64_UINT16    Reserved1           : 3;
    NDR64_UINT16    Message             : 1;
    NDR64_UINT16    Reserved2           : 4;
    NDR64_UINT16    InputSynchronous    : 1;
    NDR64_UINT16    Asynchronous        : 1;
    NDR64_UINT16    Reserved3           : 1;
} NDR64_RPC_FLAGS;


typedef struct _NDR64_PROC_FORMAT
{
    NDR64_UINT32        Flags;
    NDR64_UINT32        StackSize;
    NDR64_UINT32        ConstantClientBufferSize;
    NDR64_UINT32        ConstantServerBufferSize;
    NDR64_UINT16        RpcFlags;
    NDR64_UINT16        FloatDoubleMask;
    NDR64_UINT16        NumberOfParams;
    NDR64_UINT16        ExtensionSize;
} NDR64_PROC_FORMAT, *PNDR64_PROC_FORMAT;

typedef struct _NDR64_PARAM_FLAGS
{
    NDR64_UINT16    MustSize            : 1;
    NDR64_UINT16    MustFree            : 1;
    NDR64_UINT16    IsPipe              : 1;
    NDR64_UINT16    IsIn                : 1;
    NDR64_UINT16    IsOut               : 1;
    NDR64_UINT16    IsReturn            : 1;
    NDR64_UINT16    IsBasetype          : 1;
    NDR64_UINT16    IsByValue           : 1;
    NDR64_UINT16    IsSimpleRef         : 1;
    NDR64_UINT16    IsDontCallFreeInst  : 1;
    NDR64_UINT16    SaveForAsyncFinish  : 1;
    NDR64_UINT16    IsPartialIgnore     : 1;
    NDR64_UINT16    IsForceAllocate     : 1;
    NDR64_UINT16    Reserved            : 2;
    NDR64_UINT16    UseCache            : 1;
} NDR64_PARAM_FLAGS;


typedef struct _NDR64_PARAM_FORMAT
{
    PNDR64_FORMAT       Type;
    NDR64_PARAM_FLAGS   Attributes;
    NDR64_UINT16        Reserved;
    NDR64_UINT32        StackOffset;
} NDR64_PARAM_FORMAT, *PNDR64_PARAM_FORMAT;


//
// Base types
//

typedef struct _NDR64_RANGE_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_FORMAT_CHAR   RangeType;
    NDR64_UINT16        Reserved;
    NDR64_INT64         MinValue;
    NDR64_INT64         MaxValue;
} NDR64_RANGE_FORMAT;

//
// Handles & bindings
//

typedef struct _NDR64_CONTEXT_HANDLE_FLAGS
{
    NDR64_UINT8         CannotBeNull : 1;
    NDR64_UINT8         Serialize    : 1;
    NDR64_UINT8         NoSerialize  : 1;
    NDR64_UINT8         Strict       : 1;
    NDR64_UINT8         IsReturn     : 1;
    NDR64_UINT8         IsOut        : 1;
    NDR64_UINT8         IsIn         : 1;
    NDR64_UINT8         IsViaPointer : 1;
} NDR64_CONTEXT_HANDLE_FLAGS;

typedef struct _NDR64_CONTEXT_HANDLE_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         ContextFlags;
    NDR64_UINT8         RundownRoutineIndex;
    NDR64_UINT8         Ordinal;
} NDR64_CONTEXT_HANDLE_FORMAT;

typedef struct _NDR64_BIND_PRIMITIVE
{
    NDR64_FORMAT_CHAR   HandleType;
    NDR64_UINT8         Flags;
    NDR64_UINT16        StackOffset;
    NDR64_UINT16        Reserved;
} NDR64_BIND_PRIMITIVE;

typedef struct _NDR64_BIND_GENERIC
{
    NDR64_FORMAT_CHAR   HandleType;
    NDR64_UINT8         Flags;
    NDR64_UINT16        StackOffset;
    NDR64_UINT8         RoutineIndex;
    NDR64_UINT8         Size;
} NDR64_BIND_GENERIC;

typedef struct _NDR64_BIND_CONTEXT
{
    NDR64_FORMAT_CHAR   HandleType;
    NDR64_UINT8         Flags;
    NDR64_UINT16        StackOffset;
    NDR64_UINT8         RoutineIndex;
    NDR64_UINT8         Ordinal;
} NDR64_BIND_CONTEXT;

typedef union _NDR64_BINDINGS
{
    NDR64_BIND_PRIMITIVE    Primitive;
    NDR64_BIND_GENERIC      Generic;
    NDR64_BIND_CONTEXT      Context;
} NDR64_BINDINGS;

// NOTE: The type of the Binding member below is actually NDR64_BINDINGS.
//       We use NDR64_BIND_CONTEXT because it has essentially the same
//       signature as the others and it makes static initilization clearer.

typedef struct _NDR64_BIND_AND_NOTIFY_EXTENSION
{
    NDR64_BIND_CONTEXT  Binding;
    NDR64_UINT16        NotifyIndex;
} NDR64_BIND_AND_NOTIFY_EXTENSION;


//
// Pointers
//

typedef struct _NDR64_POINTER_FORMAT
{
    NDR64_FORMAT_CHAR  FormatCode;
    NDR64_UINT8        Flags;
    NDR64_UINT16       Reserved;
    PNDR64_FORMAT      Pointee;
} NDR64_POINTER_FORMAT;

typedef struct _NDR64_NO_REPEAT_FORMAT
{
   NDR64_FORMAT_CHAR    FormatCode;
   NDR64_UINT8          Flags;
   NDR64_UINT16         Reserved1;
   NDR64_UINT32         Reserved2;
} NDR64_NO_REPEAT_FORMAT;

typedef struct _NDR64_POINTER_INSTANCE_HEADER_FORMAT
{
    NDR64_UINT32         Offset;
    NDR64_UINT32         Reserved;
} NDR64_POINTER_INSTANCE_HEADER_FORMAT;

typedef struct _NDR64_POINTER_REPEAT_FLAGS
{
    NDR64_UINT8          SetCorrMark : 1;
    NDR64_UINT8          Reserved : 7;
} NDR64_POINTER_REPEAT_FLAGS, *PNDR64_POINTER_REPEAT_FLAGS;

typedef struct _NDR64_REPEAT_FORMAT
{
    NDR64_FORMAT_CHAR    FormatCode;
    NDR64_POINTER_REPEAT_FLAGS  Flags;
    NDR64_UINT16         Reserved;
    NDR64_UINT32         Increment;
    NDR64_UINT32         OffsetToArray;
    NDR64_UINT32         NumberOfPointers;
} NDR64_REPEAT_FORMAT, *PNDR64_REPEAT_FORMAT;

typedef struct _NDR64_FIXED_REPEAT_FORMAT
{
    NDR64_REPEAT_FORMAT  RepeatFormat;
    NDR64_UINT32         Iterations;
    NDR64_UINT32         Reserved;
} NDR64_FIXED_REPEAT_FORMAT, *PNDR64_FIXED_REPEAT_FORMAT;

typedef struct _NDR64_IID_FLAGS
{
    NDR64_UINT8         ConstantIID : 1;
    NDR64_UINT8         Reserved    : 7;
} NDR64_IID_FLAGS;

typedef struct _NDR64_CONSTANT_IID_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT16        Reserved;
    GUID                Guid;
} NDR64_CONSTANT_IID_FORMAT;

typedef struct _NDR64_IID_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT16        Reserved;
    PNDR64_FORMAT       IIDDescriptor;
} NDR64_IID_FORMAT;

//
// Structures
//

typedef struct _NDR64_STRUCTURE_FLAGS
{
    NDR64_UINT8         HasPointerInfo      : 1; /* 1 */
    NDR64_UINT8         HasMemberInfo       : 1; /* 2 */
    NDR64_UINT8         HasConfArray        : 1; /* 3 */
    NDR64_UINT8         HasOrigPointerInfo  : 1; /* 4 */
    NDR64_UINT8         HasOrigMemberInfo   : 1; /* 5 */
    NDR64_UINT8         Reserved1           : 1; /* 6 */
    NDR64_UINT8         Reserved2           : 1; /* 7 */
    NDR64_UINT8         Reserved3           : 1; /* 8 */
} NDR64_STRUCTURE_FLAGS;

typedef struct _NDR64_STRUCTURE_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR       FormatCode;
    NDR64_ALIGNMENT         Alignment;
    NDR64_STRUCTURE_FLAGS   Flags;
    NDR64_UINT8             Reserve;
    NDR64_UINT32            MemorySize;
} NDR64_STRUCTURE_HEADER_FORMAT;

typedef struct _NDR64_CONF_STRUCTURE_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR       FormatCode;
    NDR64_ALIGNMENT         Alignment;
    NDR64_STRUCTURE_FLAGS   Flags;
    NDR64_UINT8             Reserve;
    NDR64_UINT32            MemorySize;
    PNDR64_FORMAT           ArrayDescription;
} NDR64_CONF_STRUCTURE_HEADER_FORMAT;

typedef struct _NDR64_BOGUS_STRUCTURE_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR       FormatCode;
    NDR64_ALIGNMENT         Alignment;
    NDR64_STRUCTURE_FLAGS   Flags;
    NDR64_UINT8             Reserve;
    NDR64_UINT32            MemorySize;
    PNDR64_FORMAT           OriginalMemberLayout;
    PNDR64_FORMAT           OriginalPointerLayout;
    PNDR64_FORMAT           PointerLayout;
} NDR64_BOGUS_STRUCTURE_HEADER_FORMAT;

typedef struct _NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR       FormatCode;
    NDR64_ALIGNMENT         Alignment;
    NDR64_STRUCTURE_FLAGS   Flags;
    NDR64_UINT8             Dimensions;
    NDR64_UINT32            MemorySize;
    PNDR64_FORMAT           OriginalMemberLayout;
    PNDR64_FORMAT           OriginalPointerLayout;
    PNDR64_FORMAT           PointerLayout;
    PNDR64_FORMAT           ConfArrayDescription;
} NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT;

/*
*   Structure member layout components
*/

typedef struct _NDR64_SIMPLE_MEMBER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Reserved1;
    NDR64_UINT16        Reserved2;
    NDR64_UINT32        Reserved3;
} NDR64_SIMPLE_MEMBER_FORMAT;

typedef struct _NDR64_MEMPAD_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Reserve1;
    NDR64_UINT16        MemPad;
    NDR64_UINT32        Reserved2;
} NDR64_MEMPAD_FORMAT;

typedef struct _NDR64_EMBEDDED_COMPLEX_FORMAT
{
    NDR64_FORMAT_CHAR FormatCode;
    NDR64_UINT8       Reserve1;
    NDR64_UINT16      Reserve2;
    PNDR64_FORMAT     Type;
} NDR64_EMBEDDED_COMPLEX_FORMAT;

typedef struct _NDR64_BUFFER_ALIGN_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_UINT16        Reserved;
    NDR64_UINT32        Reserved2;
} NDR64_BUFFER_ALIGN_FORMAT;

typedef struct _NDR64_SIMPLE_REGION_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_UINT16        RegionSize;
    NDR64_UINT32        Reserved;
} NDR64_SIMPLE_REGION_FORMAT;

//
// Unions
//

typedef struct _NDR64_ENCAPSULATED_UNION
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Alignment;
    NDR64_UINT8         Flags;
    NDR64_FORMAT_CHAR   SwitchType;
    NDR64_UINT32        MemoryOffset;
    NDR64_UINT32        MemorySize;
    NDR64_UINT32        Reserved;
}
NDR64_ENCAPSULATED_UNION;

typedef struct _NDR64_NON_ENCAPSULATED_UNION
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Alignment;
    NDR64_UINT8         Flags;
    NDR64_FORMAT_CHAR   SwitchType;
    NDR64_UINT32        MemorySize;
    PNDR64_FORMAT       Switch;
    NDR64_UINT32        Reserved;
}
NDR64_NON_ENCAPSULATED_UNION;

typedef struct _NDR64_UNION_ARM_SELECTOR
{
    NDR64_UINT8         Reserved1;
    NDR64_UINT8         Alignment;
    NDR64_UINT16        Reserved2;
    NDR64_UINT32        Arms;
}
NDR64_UNION_ARM_SELECTOR;

typedef struct _NDR64_UNION_ARM
{
    NDR64_INT64         CaseValue;
    PNDR64_FORMAT       Type;
    NDR64_UINT32        Reserved;
}
NDR64_UNION_ARM;

/*
*    Array related data
*/

typedef struct _NDR64_ARRAY_FLAGS
{
    NDR64_UINT8         HasPointerInfo      :   1; /* 1 */
    NDR64_UINT8         HasElementInfo      :   1; /* 2 */
    NDR64_UINT8         IsMultiDimensional  :   1; /* 3 */
    NDR64_UINT8         IsArrayofStrings    :   1; /* 4 */
    NDR64_UINT8         Reserved1           :   1; /* 5 */
    NDR64_UINT8         Reserved2           :   1; /* 6 */
    NDR64_UINT8         Reserved3           :   1; /* 7 */
    NDR64_UINT8         Reserved4           :   1; /* 8 */
} NDR64_ARRAY_FLAGS;

typedef struct _NDR64_ARRAY_ELEMENT_INFO
{
    NDR64_UINT32        ElementMemSize;
    PNDR64_FORMAT       Element;
} NDR64_ARRAY_ELEMENT_INFO;

typedef struct _NDR64_FIX_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         Reserved;
    NDR64_UINT32        TotalSize;
} NDR64_FIX_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_CONF_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         Reserved;
    NDR64_UINT32        ElementSize;
    PNDR64_FORMAT       ConfDescriptor;
} NDR64_CONF_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_CONF_VAR_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         Reserved;
    NDR64_UINT32        ElementSize;
    PNDR64_FORMAT       ConfDescriptor;
    PNDR64_FORMAT       VarDescriptor;
} NDR64_CONF_VAR_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_VAR_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         Reserved;
    NDR64_UINT32        TotalSize;
    NDR64_UINT32        ElementSize;
    PNDR64_FORMAT       VarDescriptor;
} NDR64_VAR_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_BOGUS_ARRAY_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_ALIGNMENT     Alignment;
    NDR64_ARRAY_FLAGS   Flags;
    NDR64_UINT8         NumberDims;
    NDR64_UINT32        NumberElements;
    PNDR64_FORMAT       Element;
} NDR64_BOGUS_ARRAY_HEADER_FORMAT;

typedef struct _NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT
{
    NDR64_BOGUS_ARRAY_HEADER_FORMAT FixedArrayFormat;
    PNDR64_FORMAT                ConfDescription;
    PNDR64_FORMAT                VarDescription;
    PNDR64_FORMAT                OffsetDescription;
} NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT;

/*
*   String related data.
*/

typedef struct _NDR64_STRING_FLAGS
{
  NDR64_UINT8           IsSized     : 1;
  NDR64_UINT8           IsRanged    : 1;
  NDR64_UINT8           Reserved3   : 1;
  NDR64_UINT8           Reserved4   : 1;
  NDR64_UINT8           Reserved5   : 1;
  NDR64_UINT8           Reserved6   : 1;
  NDR64_UINT8           Reserved7   : 1;
  NDR64_UINT8           Reserved8   : 1;
} NDR64_STRING_FLAGS;

typedef struct NDR64_STRING_HEADER_FORMAT
{
    NDR64_FORMAT_CHAR    FormatCode;
    NDR64_STRING_FLAGS   Flags;
    NDR64_UINT16         ElementSize;
} NDR64_STRING_HEADER_FORMAT;

typedef struct _NDR64_NON_CONFORMANT_STRING_FORMAT
{
   NDR64_STRING_HEADER_FORMAT   Header;
   NDR64_UINT32                 TotalSize;
} NDR64_NON_CONFORMANT_STRING_FORMAT;

#if NTDDI_VERSION >= NTDDI_VISTA
typedef struct _NDR64_RANGED_STRING_FORMAT
{
    NDR64_STRING_HEADER_FORMAT Header;
    NDR64_UINT32 Reserved;
    NDR64_UINT64 Min;
    NDR64_UINT64 Max;
} NDR64_RANGED_STRING_FORMAT;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _NDR64_CONFORMANT_STRING_FORMAT
{
   NDR64_STRING_HEADER_FORMAT   Header;
} NDR64_CONFORMANT_STRING_FORMAT;

typedef struct NDR64_SIZED_CONFORMANT_STRING_FORMAT
{
   NDR64_STRING_HEADER_FORMAT   Header;
   PNDR64_FORMAT                SizeDescription;
} NDR64_SIZED_CONFORMANT_STRING_FORMAT;

//
// Correlation expressions
//

typedef enum _tagEXPR_TOKEN
{
    FC_EXPR_START = 0,
    FC_EXPR_ILLEGAL = FC_EXPR_START,
    FC_EXPR_CONST32,
    FC_EXPR_CONST64,
    FC_EXPR_VAR,
    FC_EXPR_OPER,
    FC_EXPR_NOOP,    // pad up the format string buffer.
    FC_EXPR_END

} EXPR_TOKEN;

typedef struct _NDR64_EXPR_OPERATOR
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_FORMAT_CHAR   Operator;
    NDR64_FORMAT_CHAR   CastType;
    NDR64_UINT8         Reserved;
} NDR64_EXPR_OPERATOR;

typedef struct _NDR64_EXPR_CONST32
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_FORMAT_CHAR   Reserved;
    NDR64_UINT16        Reserved1;
    NDR64_UINT32        ConstValue;
} NDR64_EXPR_CONST32;

typedef struct _NDR64_EXPR_CONST64
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_FORMAT_CHAR   Reserved;
    NDR64_UINT16        Reserved1;
    NDR64_INT64         ConstValue;
} NDR64_EXPR_CONST64;

typedef struct _NDR64_EXPR_VAR
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_FORMAT_CHAR   VarType;
    NDR64_UINT16        Reserved;
    NDR64_UINT32        Offset;
} NDR64_EXPR_VAR;

typedef struct _NDR64_EXPR_NOOP
{
    NDR64_FORMAT_CHAR   ExprType;
    NDR64_UINT8         Size;
    NDR64_UINT16        Reserved;
} NDR64_EXPR_NOOP;

//
// transmit_as, represent_as
//

typedef struct _NDR64_TRANSMIT_AS_FLAGS
{
    NDR64_UINT8         PresentedTypeIsArray : 1;
    NDR64_UINT8         PresentedTypeAlign4  : 1;
    NDR64_UINT8         PresentedTypeAlign8  : 1;
    NDR64_UINT8         Reserved             : 5;
} NDR64_TRANSMIT_AS_FLAGS;

typedef struct _NDR64_TRANSMIT_AS_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT16        RoutineIndex;
    NDR64_UINT16        TransmittedTypeWireAlignment;
    NDR64_UINT16        MemoryAlignment;
    NDR64_UINT32        PresentedTypeMemorySize;
    NDR64_UINT32        TransmittedTypeBufferSize;
    PNDR64_FORMAT       TransmittedType;
} NDR64_TRANSMIT_AS_FORMAT;

typedef NDR64_TRANSMIT_AS_FORMAT NDR64_REPRESENT_AS_FORMAT;

//
// user_marshal
//

typedef struct _NDR64_USER_MARSHAL_FLAGS
{
    NDR64_UINT8         Reserved        : 5;
    NDR64_UINT8         IID             : 1;
    NDR64_UINT8         RefPointer      : 1;
    NDR64_UINT8         UniquePointer   : 1;
} NDR64_USER_MARSHAL_FLAGS;

typedef struct _NDR64_USER_MARSHAL_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT16        RoutineIndex;
    NDR64_UINT16        TransmittedTypeWireAlignment;
    NDR64_UINT16        MemoryAlignment;
    NDR64_UINT32        UserTypeMemorySize;
    NDR64_UINT32        TransmittedTypeBufferSize;
    PNDR64_FORMAT       TransmittedType;
} NDR64_USER_MARSHAL_FORMAT;

//
// Pipes
//

typedef struct NDR64_PIPE_FLAGS
{
    NDR64_UINT8         Reserved1  : 5;
    NDR64_UINT8         HasRange   : 1;
    NDR64_UINT8         BlockCopy  : 1;
    NDR64_UINT8         Reserved2  : 1;
} NDR64_PIPE_FLAGS;

typedef struct _NDR64_PIPE_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT8         Alignment;
    NDR64_UINT8         Reserved;
    PNDR64_FORMAT       Type;
    NDR64_UINT32        MemorySize;
    NDR64_UINT32        BufferSize;
} NDR64_PIPE_FORMAT;


typedef struct _NDR64_RANGE_PIPE_FORMAT
{
    NDR64_FORMAT_CHAR   FormatCode;
    NDR64_UINT8         Flags;
    NDR64_UINT8         Alignment;
    NDR64_UINT8         Reserved;
    PNDR64_FORMAT       Type;
    NDR64_UINT32        MemorySize;
    NDR64_UINT32        BufferSize;
    NDR64_UINT32        MinValue;
    NDR64_UINT32        MaxValue;
} NDR64_RANGE_PIPE_FORMAT;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct _NDR64_TYPE_STRICT_CONTEXT_HANDLE
{
	NDR64_FORMAT_CHAR FormatCode;
	NDR64_FORMAT_CHAR RealFormatCode;
	NDR64_UINT16      Reserved;
	PNDR64_FORMAT     Type;
	NDR64_UINT32      CtxtFlags;
	NDR64_UINT32      CtxtID;
} NDR64_TYPE_STRICT_CONTEXT_HANDLE;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)


#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#include <poppack.h>

#endif //_NDR64TYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\NetCon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for netcon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netcon_h__
#define __netcon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumNetConnection_FWD_DEFINED__
#define __IEnumNetConnection_FWD_DEFINED__
typedef interface IEnumNetConnection IEnumNetConnection;
#endif 	/* __IEnumNetConnection_FWD_DEFINED__ */


#ifndef __INetConnection_FWD_DEFINED__
#define __INetConnection_FWD_DEFINED__
typedef interface INetConnection INetConnection;
#endif 	/* __INetConnection_FWD_DEFINED__ */


#ifndef __INetConnectionManager_FWD_DEFINED__
#define __INetConnectionManager_FWD_DEFINED__
typedef interface INetConnectionManager INetConnectionManager;
#endif 	/* __INetConnectionManager_FWD_DEFINED__ */


#ifndef __INetConnectionConnectUi_FWD_DEFINED__
#define __INetConnectionConnectUi_FWD_DEFINED__
typedef interface INetConnectionConnectUi INetConnectionConnectUi;
#endif 	/* __INetConnectionConnectUi_FWD_DEFINED__ */


#ifndef __IEnumNetSharingPortMapping_FWD_DEFINED__
#define __IEnumNetSharingPortMapping_FWD_DEFINED__
typedef interface IEnumNetSharingPortMapping IEnumNetSharingPortMapping;
#endif 	/* __IEnumNetSharingPortMapping_FWD_DEFINED__ */


#ifndef __INetSharingPortMappingProps_FWD_DEFINED__
#define __INetSharingPortMappingProps_FWD_DEFINED__
typedef interface INetSharingPortMappingProps INetSharingPortMappingProps;
#endif 	/* __INetSharingPortMappingProps_FWD_DEFINED__ */


#ifndef __INetSharingPortMapping_FWD_DEFINED__
#define __INetSharingPortMapping_FWD_DEFINED__
typedef interface INetSharingPortMapping INetSharingPortMapping;
#endif 	/* __INetSharingPortMapping_FWD_DEFINED__ */


#ifndef __IEnumNetSharingEveryConnection_FWD_DEFINED__
#define __IEnumNetSharingEveryConnection_FWD_DEFINED__
typedef interface IEnumNetSharingEveryConnection IEnumNetSharingEveryConnection;
#endif 	/* __IEnumNetSharingEveryConnection_FWD_DEFINED__ */


#ifndef __IEnumNetSharingPublicConnection_FWD_DEFINED__
#define __IEnumNetSharingPublicConnection_FWD_DEFINED__
typedef interface IEnumNetSharingPublicConnection IEnumNetSharingPublicConnection;
#endif 	/* __IEnumNetSharingPublicConnection_FWD_DEFINED__ */


#ifndef __IEnumNetSharingPrivateConnection_FWD_DEFINED__
#define __IEnumNetSharingPrivateConnection_FWD_DEFINED__
typedef interface IEnumNetSharingPrivateConnection IEnumNetSharingPrivateConnection;
#endif 	/* __IEnumNetSharingPrivateConnection_FWD_DEFINED__ */


#ifndef __INetSharingPortMappingCollection_FWD_DEFINED__
#define __INetSharingPortMappingCollection_FWD_DEFINED__
typedef interface INetSharingPortMappingCollection INetSharingPortMappingCollection;
#endif 	/* __INetSharingPortMappingCollection_FWD_DEFINED__ */


#ifndef __INetConnectionProps_FWD_DEFINED__
#define __INetConnectionProps_FWD_DEFINED__
typedef interface INetConnectionProps INetConnectionProps;
#endif 	/* __INetConnectionProps_FWD_DEFINED__ */


#ifndef __INetSharingConfiguration_FWD_DEFINED__
#define __INetSharingConfiguration_FWD_DEFINED__
typedef interface INetSharingConfiguration INetSharingConfiguration;
#endif 	/* __INetSharingConfiguration_FWD_DEFINED__ */


#ifndef __INetSharingEveryConnectionCollection_FWD_DEFINED__
#define __INetSharingEveryConnectionCollection_FWD_DEFINED__
typedef interface INetSharingEveryConnectionCollection INetSharingEveryConnectionCollection;
#endif 	/* __INetSharingEveryConnectionCollection_FWD_DEFINED__ */


#ifndef __INetSharingPublicConnectionCollection_FWD_DEFINED__
#define __INetSharingPublicConnectionCollection_FWD_DEFINED__
typedef interface INetSharingPublicConnectionCollection INetSharingPublicConnectionCollection;
#endif 	/* __INetSharingPublicConnectionCollection_FWD_DEFINED__ */


#ifndef __INetSharingPrivateConnectionCollection_FWD_DEFINED__
#define __INetSharingPrivateConnectionCollection_FWD_DEFINED__
typedef interface INetSharingPrivateConnectionCollection INetSharingPrivateConnectionCollection;
#endif 	/* __INetSharingPrivateConnectionCollection_FWD_DEFINED__ */


#ifndef __INetSharingManager_FWD_DEFINED__
#define __INetSharingManager_FWD_DEFINED__
typedef interface INetSharingManager INetSharingManager;
#endif 	/* __INetSharingManager_FWD_DEFINED__ */


#ifndef __NetSharingManager_FWD_DEFINED__
#define __NetSharingManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetSharingManager NetSharingManager;
#else
typedef struct NetSharingManager NetSharingManager;
#endif /* __cplusplus */

#endif 	/* __NetSharingManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "prsht.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_netcon_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif

EXTERN_C const CLSID CLSID_ConnectionManager;
EXTERN_C const CLSID CLSID_NetSharingManager;

#define NETCON_MAX_NAME_LEN 256















extern RPC_IF_HANDLE __MIDL_itf_netcon_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netcon_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumNetConnection_INTERFACE_DEFINED__
#define __IEnumNetConnection_INTERFACE_DEFINED__

/* interface IEnumNetConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNetConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956A0-1CD3-11D1-B1C5-00805FC1270E")
    IEnumNetConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) INetConnection **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumNetConnection **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumNetConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumNetConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumNetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumNetConnection * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) INetConnection **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumNetConnection * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumNetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumNetConnection * This,
            /* [out] */ __RPC__deref_out_opt IEnumNetConnection **ppenum);
        
        END_INTERFACE
    } IEnumNetConnectionVtbl;

    interface IEnumNetConnection
    {
        CONST_VTBL struct IEnumNetConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumNetConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumNetConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumNetConnection_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumNetConnection_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumNetConnection_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumNetConnection_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumNetConnection_INTERFACE_DEFINED__ */


#ifndef __INetConnection_INTERFACE_DEFINED__
#define __INetConnection_INTERFACE_DEFINED__

/* interface INetConnection */
/* [unique][uuid][object] */ 

typedef 
enum tagNETCON_CHARACTERISTIC_FLAGS
    {	NCCF_NONE	= 0,
	NCCF_ALL_USERS	= 0x1,
	NCCF_ALLOW_DUPLICATION	= 0x2,
	NCCF_ALLOW_REMOVAL	= 0x4,
	NCCF_ALLOW_RENAME	= 0x8,
	NCCF_INCOMING_ONLY	= 0x20,
	NCCF_OUTGOING_ONLY	= 0x40,
	NCCF_BRANDED	= 0x80,
	NCCF_SHARED	= 0x100,
	NCCF_BRIDGED	= 0x200,
	NCCF_FIREWALLED	= 0x400,
	NCCF_DEFAULT	= 0x800,
	NCCF_HOMENET_CAPABLE	= 0x1000,
	NCCF_SHARED_PRIVATE	= 0x2000,
	NCCF_QUARANTINED	= 0x4000,
	NCCF_RESERVED	= 0x8000,
	NCCF_HOSTED_NETWORK	= 0x10000,
	NCCF_VIRTUAL_STATION	= 0x20000,
	NCCF_BLUETOOTH_MASK	= 0xf0000,
	NCCF_LAN_MASK	= 0xf00000
    } 	NETCON_CHARACTERISTIC_FLAGS;

typedef 
enum tagNETCON_STATUS
    {	NCS_DISCONNECTED	= 0,
	NCS_CONNECTING	= ( NCS_DISCONNECTED + 1 ) ,
	NCS_CONNECTED	= ( NCS_CONNECTING + 1 ) ,
	NCS_DISCONNECTING	= ( NCS_CONNECTED + 1 ) ,
	NCS_HARDWARE_NOT_PRESENT	= ( NCS_DISCONNECTING + 1 ) ,
	NCS_HARDWARE_DISABLED	= ( NCS_HARDWARE_NOT_PRESENT + 1 ) ,
	NCS_HARDWARE_MALFUNCTION	= ( NCS_HARDWARE_DISABLED + 1 ) ,
	NCS_MEDIA_DISCONNECTED	= ( NCS_HARDWARE_MALFUNCTION + 1 ) ,
	NCS_AUTHENTICATING	= ( NCS_MEDIA_DISCONNECTED + 1 ) ,
	NCS_AUTHENTICATION_SUCCEEDED	= ( NCS_AUTHENTICATING + 1 ) ,
	NCS_AUTHENTICATION_FAILED	= ( NCS_AUTHENTICATION_SUCCEEDED + 1 ) ,
	NCS_INVALID_ADDRESS	= ( NCS_AUTHENTICATION_FAILED + 1 ) ,
	NCS_CREDENTIALS_REQUIRED	= ( NCS_INVALID_ADDRESS + 1 ) 
    } 	NETCON_STATUS;

typedef 
enum tagNETCON_TYPE
    {	NCT_DIRECT_CONNECT	= 0,
	NCT_INBOUND	= 1,
	NCT_INTERNET	= ( NCT_INBOUND + 1 ) ,
	NCT_LAN	= ( NCT_INTERNET + 1 ) ,
	NCT_PHONE	= ( NCT_LAN + 1 ) ,
	NCT_TUNNEL	= ( NCT_PHONE + 1 ) ,
	NCT_BRIDGE	= ( NCT_TUNNEL + 1 ) 
    } 	NETCON_TYPE;

typedef 
enum tagNETCON_MEDIATYPE
    {	NCM_NONE	= 0,
	NCM_DIRECT	= ( NCM_NONE + 1 ) ,
	NCM_ISDN	= 2,
	NCM_LAN	= ( NCM_ISDN + 1 ) ,
	NCM_PHONE	= ( NCM_LAN + 1 ) ,
	NCM_TUNNEL	= ( NCM_PHONE + 1 ) ,
	NCM_PPPOE	= ( NCM_TUNNEL + 1 ) ,
	NCM_BRIDGE	= ( NCM_PPPOE + 1 ) ,
	NCM_SHAREDACCESSHOST_LAN	= ( NCM_BRIDGE + 1 ) ,
	NCM_SHAREDACCESSHOST_RAS	= ( NCM_SHAREDACCESSHOST_LAN + 1 ) 
    } 	NETCON_MEDIATYPE;

typedef struct tagNETCON_PROPERTIES
    {
    GUID guidId;
    LPWSTR pszwName;
    LPWSTR pszwDeviceName;
    NETCON_STATUS Status;
    NETCON_MEDIATYPE MediaType;
    DWORD dwCharacter;
    CLSID clsidThisObject;
    CLSID clsidUiObject;
    } 	NETCON_PROPERTIES;

#define S_OBJECT_NO_LONGER_VALID ((HRESULT)0x00000002L)

EXTERN_C const IID IID_INetConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956A1-1CD3-11D1-B1C5-00805FC1270E")
    INetConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Duplicate( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszwDuplicateName,
            /* [out] */ __RPC__deref_out_opt INetConnection **ppCon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__deref_out_opt NETCON_PROPERTIES **ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUiObjectClassId( 
            /* [ref][out] */ __RPC__out CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rename( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszwNewName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            __RPC__in INetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            __RPC__in INetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in INetConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Duplicate )( 
            __RPC__in INetConnection * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszwDuplicateName,
            /* [out] */ __RPC__deref_out_opt INetConnection **ppCon);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in INetConnection * This,
            /* [out] */ __RPC__deref_out_opt NETCON_PROPERTIES **ppProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetUiObjectClassId )( 
            __RPC__in INetConnection * This,
            /* [ref][out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *Rename )( 
            __RPC__in INetConnection * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszwNewName);
        
        END_INTERFACE
    } INetConnectionVtbl;

    interface INetConnection
    {
        CONST_VTBL struct INetConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetConnection_Connect(This)	\
    ( (This)->lpVtbl -> Connect(This) ) 

#define INetConnection_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define INetConnection_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#define INetConnection_Duplicate(This,pszwDuplicateName,ppCon)	\
    ( (This)->lpVtbl -> Duplicate(This,pszwDuplicateName,ppCon) ) 

#define INetConnection_GetProperties(This,ppProps)	\
    ( (This)->lpVtbl -> GetProperties(This,ppProps) ) 

#define INetConnection_GetUiObjectClassId(This,pclsid)	\
    ( (This)->lpVtbl -> GetUiObjectClassId(This,pclsid) ) 

#define INetConnection_Rename(This,pszwNewName)	\
    ( (This)->lpVtbl -> Rename(This,pszwNewName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetConnection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netcon_0000_0002 */
/* [local] */ 


STDAPI_(VOID) NcFreeNetconProperties (NETCON_PROPERTIES* pProps);


STDAPI_(BOOL) NcIsValidConnectionName (PCWSTR pszwName);



extern RPC_IF_HANDLE __MIDL_itf_netcon_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netcon_0000_0002_v0_0_s_ifspec;

#ifndef __INetConnectionManager_INTERFACE_DEFINED__
#define __INetConnectionManager_INTERFACE_DEFINED__

/* interface INetConnectionManager */
/* [unique][uuid][object] */ 

typedef 
enum tagNETCONMGR_ENUM_FLAGS
    {	NCME_DEFAULT	= 0,
	NCME_HIDDEN	= 0x1
    } 	NETCONMGR_ENUM_FLAGS;


EXTERN_C const IID IID_INetConnectionManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956A2-1CD3-11D1-B1C5-00805FC1270E")
    INetConnectionManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumConnections( 
            /* [in] */ NETCONMGR_ENUM_FLAGS Flags,
            /* [out] */ __RPC__deref_out_opt IEnumNetConnection **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetConnectionManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetConnectionManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetConnectionManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumConnections )( 
            __RPC__in INetConnectionManager * This,
            /* [in] */ NETCONMGR_ENUM_FLAGS Flags,
            /* [out] */ __RPC__deref_out_opt IEnumNetConnection **ppEnum);
        
        END_INTERFACE
    } INetConnectionManagerVtbl;

    interface INetConnectionManager
    {
        CONST_VTBL struct INetConnectionManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetConnectionManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetConnectionManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetConnectionManager_EnumConnections(This,Flags,ppEnum)	\
    ( (This)->lpVtbl -> EnumConnections(This,Flags,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetConnectionManager_INTERFACE_DEFINED__ */


#ifndef __INetConnectionConnectUi_INTERFACE_DEFINED__
#define __INetConnectionConnectUi_INTERFACE_DEFINED__

/* interface INetConnectionConnectUi */
/* [unique][uuid][object] */ 

typedef 
enum tagNETCONUI_CONNECT_FLAGS
    {	NCUC_DEFAULT	= 0,
	NCUC_NO_UI	= 0x1,
	NCUC_ENABLE_DISABLE	= 0x2
    } 	NETCONUI_CONNECT_FLAGS;


EXTERN_C const IID IID_INetConnectionConnectUi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956A3-1CD3-11D1-B1C5-00805FC1270E")
    INetConnectionConnectUi : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetConnection( 
            /* [in] */ __RPC__in_opt INetConnection *pCon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionConnectUiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetConnectionConnectUi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetConnectionConnectUi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetConnectionConnectUi * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnection )( 
            __RPC__in INetConnectionConnectUi * This,
            /* [in] */ __RPC__in_opt INetConnection *pCon);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            __RPC__in INetConnectionConnectUi * This,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            __RPC__in INetConnectionConnectUi * This,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } INetConnectionConnectUiVtbl;

    interface INetConnectionConnectUi
    {
        CONST_VTBL struct INetConnectionConnectUiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionConnectUi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetConnectionConnectUi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetConnectionConnectUi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetConnectionConnectUi_SetConnection(This,pCon)	\
    ( (This)->lpVtbl -> SetConnection(This,pCon) ) 

#define INetConnectionConnectUi_Connect(This,hwndParent,dwFlags)	\
    ( (This)->lpVtbl -> Connect(This,hwndParent,dwFlags) ) 

#define INetConnectionConnectUi_Disconnect(This,hwndParent,dwFlags)	\
    ( (This)->lpVtbl -> Disconnect(This,hwndParent,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetConnectionConnectUi_INTERFACE_DEFINED__ */


#ifndef __IEnumNetSharingPortMapping_INTERFACE_DEFINED__
#define __IEnumNetSharingPortMapping_INTERFACE_DEFINED__

/* interface IEnumNetSharingPortMapping */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNetSharingPortMapping;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956B0-1CD3-11D1-B1C5-00805FC1270E")
    IEnumNetSharingPortMapping : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VARIANT *rgVar,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumNetSharingPortMapping **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetSharingPortMappingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumNetSharingPortMapping * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumNetSharingPortMapping * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumNetSharingPortMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumNetSharingPortMapping * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VARIANT *rgVar,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumNetSharingPortMapping * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumNetSharingPortMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumNetSharingPortMapping * This,
            /* [out] */ __RPC__deref_out_opt IEnumNetSharingPortMapping **ppenum);
        
        END_INTERFACE
    } IEnumNetSharingPortMappingVtbl;

    interface IEnumNetSharingPortMapping
    {
        CONST_VTBL struct IEnumNetSharingPortMappingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetSharingPortMapping_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumNetSharingPortMapping_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumNetSharingPortMapping_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumNetSharingPortMapping_Next(This,celt,rgVar,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgVar,pceltFetched) ) 

#define IEnumNetSharingPortMapping_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumNetSharingPortMapping_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumNetSharingPortMapping_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumNetSharingPortMapping_INTERFACE_DEFINED__ */


#ifndef __INetSharingPortMappingProps_INTERFACE_DEFINED__
#define __INetSharingPortMappingProps_INTERFACE_DEFINED__

/* interface INetSharingPortMappingProps */
/* [unique][dual][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_INetSharingPortMappingProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("24B7E9B5-E38F-4685-851B-00892CF5F940")
    INetSharingPortMappingProps : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IPProtocol( 
            /* [retval][out] */ __RPC__out UCHAR *pucIPProt) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExternalPort( 
            /* [retval][out] */ __RPC__out long *pusPort) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InternalPort( 
            /* [retval][out] */ __RPC__out long *pusPort) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Options( 
            /* [retval][out] */ __RPC__out long *pdwOptions) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TargetName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTargetName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TargetIPAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTargetIPAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbool) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharingPortMappingPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetSharingPortMappingProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetSharingPortMappingProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetSharingPortMappingProps * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IPProtocol )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [retval][out] */ __RPC__out UCHAR *pucIPProt);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExternalPort )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [retval][out] */ __RPC__out long *pusPort);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InternalPort )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [retval][out] */ __RPC__out long *pusPort);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Options )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [retval][out] */ __RPC__out long *pdwOptions);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetName )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTargetName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetIPAddress )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTargetIPAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in INetSharingPortMappingProps * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbool);
        
        END_INTERFACE
    } INetSharingPortMappingPropsVtbl;

    interface INetSharingPortMappingProps
    {
        CONST_VTBL struct INetSharingPortMappingPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharingPortMappingProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetSharingPortMappingProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetSharingPortMappingProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetSharingPortMappingProps_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetSharingPortMappingProps_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetSharingPortMappingProps_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetSharingPortMappingProps_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetSharingPortMappingProps_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define INetSharingPortMappingProps_get_IPProtocol(This,pucIPProt)	\
    ( (This)->lpVtbl -> get_IPProtocol(This,pucIPProt) ) 

#define INetSharingPortMappingProps_get_ExternalPort(This,pusPort)	\
    ( (This)->lpVtbl -> get_ExternalPort(This,pusPort) ) 

#define INetSharingPortMappingProps_get_InternalPort(This,pusPort)	\
    ( (This)->lpVtbl -> get_InternalPort(This,pusPort) ) 

#define INetSharingPortMappingProps_get_Options(This,pdwOptions)	\
    ( (This)->lpVtbl -> get_Options(This,pdwOptions) ) 

#define INetSharingPortMappingProps_get_TargetName(This,pbstrTargetName)	\
    ( (This)->lpVtbl -> get_TargetName(This,pbstrTargetName) ) 

#define INetSharingPortMappingProps_get_TargetIPAddress(This,pbstrTargetIPAddress)	\
    ( (This)->lpVtbl -> get_TargetIPAddress(This,pbstrTargetIPAddress) ) 

#define INetSharingPortMappingProps_get_Enabled(This,pbool)	\
    ( (This)->lpVtbl -> get_Enabled(This,pbool) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetSharingPortMappingProps_INTERFACE_DEFINED__ */


#ifndef __INetSharingPortMapping_INTERFACE_DEFINED__
#define __INetSharingPortMapping_INTERFACE_DEFINED__

/* interface INetSharingPortMapping */
/* [unique][dual][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_INetSharingPortMapping;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956B1-1CD3-11D1-B1C5-00805FC1270E")
    INetSharingPortMapping : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disable( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Enable( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPortMappingProps **ppNSPMP) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharingPortMappingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetSharingPortMapping * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetSharingPortMapping * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetSharingPortMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetSharingPortMapping * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetSharingPortMapping * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetSharingPortMapping * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetSharingPortMapping * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disable )( 
            __RPC__in INetSharingPortMapping * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Enable )( 
            __RPC__in INetSharingPortMapping * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            __RPC__in INetSharingPortMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPortMappingProps **ppNSPMP);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in INetSharingPortMapping * This);
        
        END_INTERFACE
    } INetSharingPortMappingVtbl;

    interface INetSharingPortMapping
    {
        CONST_VTBL struct INetSharingPortMappingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharingPortMapping_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetSharingPortMapping_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetSharingPortMapping_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetSharingPortMapping_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetSharingPortMapping_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetSharingPortMapping_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetSharingPortMapping_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetSharingPortMapping_Disable(This)	\
    ( (This)->lpVtbl -> Disable(This) ) 

#define INetSharingPortMapping_Enable(This)	\
    ( (This)->lpVtbl -> Enable(This) ) 

#define INetSharingPortMapping_get_Properties(This,ppNSPMP)	\
    ( (This)->lpVtbl -> get_Properties(This,ppNSPMP) ) 

#define INetSharingPortMapping_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetSharingPortMapping_INTERFACE_DEFINED__ */


#ifndef __IEnumNetSharingEveryConnection_INTERFACE_DEFINED__
#define __IEnumNetSharingEveryConnection_INTERFACE_DEFINED__

/* interface IEnumNetSharingEveryConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNetSharingEveryConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956B8-1CD3-11D1-B1C5-00805FC1270E")
    IEnumNetSharingEveryConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VARIANT *rgVar,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumNetSharingEveryConnection **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetSharingEveryConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumNetSharingEveryConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumNetSharingEveryConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumNetSharingEveryConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumNetSharingEveryConnection * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VARIANT *rgVar,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumNetSharingEveryConnection * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumNetSharingEveryConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumNetSharingEveryConnection * This,
            /* [out] */ __RPC__deref_out_opt IEnumNetSharingEveryConnection **ppenum);
        
        END_INTERFACE
    } IEnumNetSharingEveryConnectionVtbl;

    interface IEnumNetSharingEveryConnection
    {
        CONST_VTBL struct IEnumNetSharingEveryConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetSharingEveryConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumNetSharingEveryConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumNetSharingEveryConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumNetSharingEveryConnection_Next(This,celt,rgVar,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgVar,pceltFetched) ) 

#define IEnumNetSharingEveryConnection_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumNetSharingEveryConnection_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumNetSharingEveryConnection_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumNetSharingEveryConnection_INTERFACE_DEFINED__ */


#ifndef __IEnumNetSharingPublicConnection_INTERFACE_DEFINED__
#define __IEnumNetSharingPublicConnection_INTERFACE_DEFINED__

/* interface IEnumNetSharingPublicConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNetSharingPublicConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956B4-1CD3-11D1-B1C5-00805FC1270E")
    IEnumNetSharingPublicConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VARIANT *rgVar,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumNetSharingPublicConnection **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetSharingPublicConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumNetSharingPublicConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumNetSharingPublicConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumNetSharingPublicConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumNetSharingPublicConnection * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) VARIANT *rgVar,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumNetSharingPublicConnection * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumNetSharingPublicConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumNetSharingPublicConnection * This,
            /* [out] */ __RPC__deref_out_opt IEnumNetSharingPublicConnection **ppenum);
        
        END_INTERFACE
    } IEnumNetSharingPublicConnectionVtbl;

    interface IEnumNetSharingPublicConnection
    {
        CONST_VTBL struct IEnumNetSharingPublicConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetSharingPublicConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumNetSharingPublicConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumNetSharingPublicConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumNetSharingPublicConnection_Next(This,celt,rgVar,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgVar,pceltFetched) ) 

#define IEnumNetSharingPublicConnection_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumNetSharingPublicConnection_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumNetSharingPublicConnection_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumNetSharingPublicConnection_INTERFACE_DEFINED__ */


#ifndef __IEnumNetSharingPrivateConnection_INTERFACE_DEFINED__
#define __IEnumNetSharingPrivateConnection_INTERFACE_DEFINED__

/* interface IEnumNetSharingPrivateConnection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNetSharingPrivateConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956B5-1CD3-11D1-B1C5-00805FC1270E")
    IEnumNetSharingPrivateConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pCeltFetched) VARIANT *rgVar,
            /* [out] */ __RPC__out ULONG *pCeltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumNetSharingPrivateConnection **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetSharingPrivateConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumNetSharingPrivateConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumNetSharingPrivateConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumNetSharingPrivateConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumNetSharingPrivateConnection * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pCeltFetched) VARIANT *rgVar,
            /* [out] */ __RPC__out ULONG *pCeltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumNetSharingPrivateConnection * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumNetSharingPrivateConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumNetSharingPrivateConnection * This,
            /* [out] */ __RPC__deref_out_opt IEnumNetSharingPrivateConnection **ppenum);
        
        END_INTERFACE
    } IEnumNetSharingPrivateConnectionVtbl;

    interface IEnumNetSharingPrivateConnection
    {
        CONST_VTBL struct IEnumNetSharingPrivateConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetSharingPrivateConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumNetSharingPrivateConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumNetSharingPrivateConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumNetSharingPrivateConnection_Next(This,celt,rgVar,pCeltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgVar,pCeltFetched) ) 

#define IEnumNetSharingPrivateConnection_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumNetSharingPrivateConnection_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumNetSharingPrivateConnection_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumNetSharingPrivateConnection_INTERFACE_DEFINED__ */


#ifndef __INetSharingPortMappingCollection_INTERFACE_DEFINED__
#define __INetSharingPortMappingCollection_INTERFACE_DEFINED__

/* interface INetSharingPortMappingCollection */
/* [unique][helpstring][dual][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_INetSharingPortMappingCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02E4A2DE-DA20-4E34-89C8-AC22275A010B")
    INetSharingPortMappingCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharingPortMappingCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetSharingPortMappingCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetSharingPortMappingCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetSharingPortMappingCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetSharingPortMappingCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetSharingPortMappingCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetSharingPortMappingCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetSharingPortMappingCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in INetSharingPortMappingCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in INetSharingPortMappingCollection * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        END_INTERFACE
    } INetSharingPortMappingCollectionVtbl;

    interface INetSharingPortMappingCollection
    {
        CONST_VTBL struct INetSharingPortMappingCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharingPortMappingCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetSharingPortMappingCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetSharingPortMappingCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetSharingPortMappingCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetSharingPortMappingCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetSharingPortMappingCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetSharingPortMappingCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetSharingPortMappingCollection_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define INetSharingPortMappingCollection_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetSharingPortMappingCollection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netcon_0000_0011 */
/* [local] */ 

// properties for INetConnection (wraps NETCON_PROPERTIES)


extern RPC_IF_HANDLE __MIDL_itf_netcon_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netcon_0000_0011_v0_0_s_ifspec;

#ifndef __INetConnectionProps_INTERFACE_DEFINED__
#define __INetConnectionProps_INTERFACE_DEFINED__

/* interface INetConnectionProps */
/* [unique][helpstring][dual][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_INetConnectionProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4277C95-CE5B-463D-8167-5662D9BCAA72")
    INetConnectionProps : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Guid( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGuid) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__out NETCON_STATUS *pStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ __RPC__out NETCON_MEDIATYPE *pMediaType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Characteristics( 
            /* [retval][out] */ __RPC__out DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetConnectionPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetConnectionProps * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetConnectionProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetConnectionProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetConnectionProps * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetConnectionProps * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetConnectionProps * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetConnectionProps * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Guid )( 
            __RPC__in INetConnectionProps * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in INetConnectionProps * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceName )( 
            __RPC__in INetConnectionProps * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in INetConnectionProps * This,
            /* [retval][out] */ __RPC__out NETCON_STATUS *pStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            __RPC__in INetConnectionProps * This,
            /* [retval][out] */ __RPC__out NETCON_MEDIATYPE *pMediaType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Characteristics )( 
            __RPC__in INetConnectionProps * This,
            /* [retval][out] */ __RPC__out DWORD *pdwFlags);
        
        END_INTERFACE
    } INetConnectionPropsVtbl;

    interface INetConnectionProps
    {
        CONST_VTBL struct INetConnectionPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetConnectionProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetConnectionProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetConnectionProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetConnectionProps_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetConnectionProps_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetConnectionProps_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetConnectionProps_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetConnectionProps_get_Guid(This,pbstrGuid)	\
    ( (This)->lpVtbl -> get_Guid(This,pbstrGuid) ) 

#define INetConnectionProps_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define INetConnectionProps_get_DeviceName(This,pbstrDeviceName)	\
    ( (This)->lpVtbl -> get_DeviceName(This,pbstrDeviceName) ) 

#define INetConnectionProps_get_Status(This,pStatus)	\
    ( (This)->lpVtbl -> get_Status(This,pStatus) ) 

#define INetConnectionProps_get_MediaType(This,pMediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,pMediaType) ) 

#define INetConnectionProps_get_Characteristics(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_Characteristics(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetConnectionProps_INTERFACE_DEFINED__ */


#ifndef __INetSharingConfiguration_INTERFACE_DEFINED__
#define __INetSharingConfiguration_INTERFACE_DEFINED__

/* interface INetSharingConfiguration */
/* [unique][dual][oleautomation][uuid][object] */ 

typedef 
enum tagSHARINGCONNECTIONTYPE
    {	ICSSHARINGTYPE_PUBLIC	= 0,
	ICSSHARINGTYPE_PRIVATE	= ( ICSSHARINGTYPE_PUBLIC + 1 ) 
    } 	SHARINGCONNECTIONTYPE;

typedef enum tagSHARINGCONNECTIONTYPE *LPSHARINGCONNECTIONTYPE;

typedef 
enum tagSHARINGCONNECTION_ENUM_FLAGS
    {	ICSSC_DEFAULT	= 0,
	ICSSC_ENABLED	= ( ICSSC_DEFAULT + 1 ) 
    } 	SHARINGCONNECTION_ENUM_FLAGS;

typedef 
enum tagICS_TARGETTYPE
    {	ICSTT_NAME	= 0,
	ICSTT_IPADDRESS	= ( ICSTT_NAME + 1 ) 
    } 	ICS_TARGETTYPE;


EXTERN_C const IID IID_INetSharingConfiguration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956B6-1CD3-11D1-B1C5-00805FC1270E")
    INetSharingConfiguration : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SharingEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SharingConnectionType( 
            /* [retval][out] */ __RPC__out SHARINGCONNECTIONTYPE *pType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisableSharing( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableSharing( 
            /* [in] */ SHARINGCONNECTIONTYPE Type) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InternetFirewallEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisableInternetFirewall( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableInternetFirewall( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumPortMappings( 
            /* [in] */ SHARINGCONNECTION_ENUM_FLAGS Flags,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPortMappingCollection **ppColl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddPortMapping( 
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ UCHAR ucIPProtocol,
            /* [in] */ USHORT usExternalPort,
            /* [in] */ USHORT usInternalPort,
            /* [in] */ DWORD dwOptions,
            /* [in] */ __RPC__in BSTR bstrTargetNameOrIPAddress,
            /* [in] */ ICS_TARGETTYPE eTargetType,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPortMapping **ppMapping) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemovePortMapping( 
            /* [in] */ __RPC__in_opt INetSharingPortMapping *pMapping) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharingConfigurationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetSharingConfiguration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetSharingConfiguration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetSharingConfiguration * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetSharingConfiguration * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetSharingConfiguration * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetSharingConfiguration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetSharingConfiguration * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SharingEnabled )( 
            __RPC__in INetSharingConfiguration * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SharingConnectionType )( 
            __RPC__in INetSharingConfiguration * This,
            /* [retval][out] */ __RPC__out SHARINGCONNECTIONTYPE *pType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisableSharing )( 
            __RPC__in INetSharingConfiguration * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableSharing )( 
            __RPC__in INetSharingConfiguration * This,
            /* [in] */ SHARINGCONNECTIONTYPE Type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InternetFirewallEnabled )( 
            __RPC__in INetSharingConfiguration * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisableInternetFirewall )( 
            __RPC__in INetSharingConfiguration * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableInternetFirewall )( 
            __RPC__in INetSharingConfiguration * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumPortMappings )( 
            __RPC__in INetSharingConfiguration * This,
            /* [in] */ SHARINGCONNECTION_ENUM_FLAGS Flags,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPortMappingCollection **ppColl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddPortMapping )( 
            __RPC__in INetSharingConfiguration * This,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ UCHAR ucIPProtocol,
            /* [in] */ USHORT usExternalPort,
            /* [in] */ USHORT usInternalPort,
            /* [in] */ DWORD dwOptions,
            /* [in] */ __RPC__in BSTR bstrTargetNameOrIPAddress,
            /* [in] */ ICS_TARGETTYPE eTargetType,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPortMapping **ppMapping);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemovePortMapping )( 
            __RPC__in INetSharingConfiguration * This,
            /* [in] */ __RPC__in_opt INetSharingPortMapping *pMapping);
        
        END_INTERFACE
    } INetSharingConfigurationVtbl;

    interface INetSharingConfiguration
    {
        CONST_VTBL struct INetSharingConfigurationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharingConfiguration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetSharingConfiguration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetSharingConfiguration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetSharingConfiguration_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetSharingConfiguration_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetSharingConfiguration_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetSharingConfiguration_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetSharingConfiguration_get_SharingEnabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_SharingEnabled(This,pbEnabled) ) 

#define INetSharingConfiguration_get_SharingConnectionType(This,pType)	\
    ( (This)->lpVtbl -> get_SharingConnectionType(This,pType) ) 

#define INetSharingConfiguration_DisableSharing(This)	\
    ( (This)->lpVtbl -> DisableSharing(This) ) 

#define INetSharingConfiguration_EnableSharing(This,Type)	\
    ( (This)->lpVtbl -> EnableSharing(This,Type) ) 

#define INetSharingConfiguration_get_InternetFirewallEnabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_InternetFirewallEnabled(This,pbEnabled) ) 

#define INetSharingConfiguration_DisableInternetFirewall(This)	\
    ( (This)->lpVtbl -> DisableInternetFirewall(This) ) 

#define INetSharingConfiguration_EnableInternetFirewall(This)	\
    ( (This)->lpVtbl -> EnableInternetFirewall(This) ) 

#define INetSharingConfiguration_get_EnumPortMappings(This,Flags,ppColl)	\
    ( (This)->lpVtbl -> get_EnumPortMappings(This,Flags,ppColl) ) 

#define INetSharingConfiguration_AddPortMapping(This,bstrName,ucIPProtocol,usExternalPort,usInternalPort,dwOptions,bstrTargetNameOrIPAddress,eTargetType,ppMapping)	\
    ( (This)->lpVtbl -> AddPortMapping(This,bstrName,ucIPProtocol,usExternalPort,usInternalPort,dwOptions,bstrTargetNameOrIPAddress,eTargetType,ppMapping) ) 

#define INetSharingConfiguration_RemovePortMapping(This,pMapping)	\
    ( (This)->lpVtbl -> RemovePortMapping(This,pMapping) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetSharingConfiguration_INTERFACE_DEFINED__ */


#ifndef __INetSharingEveryConnectionCollection_INTERFACE_DEFINED__
#define __INetSharingEveryConnectionCollection_INTERFACE_DEFINED__

/* interface INetSharingEveryConnectionCollection */
/* [unique][helpstring][dual][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_INetSharingEveryConnectionCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33C4643C-7811-46FA-A89A-768597BD7223")
    INetSharingEveryConnectionCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharingEveryConnectionCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetSharingEveryConnectionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetSharingEveryConnectionCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetSharingEveryConnectionCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetSharingEveryConnectionCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetSharingEveryConnectionCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetSharingEveryConnectionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetSharingEveryConnectionCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in INetSharingEveryConnectionCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in INetSharingEveryConnectionCollection * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        END_INTERFACE
    } INetSharingEveryConnectionCollectionVtbl;

    interface INetSharingEveryConnectionCollection
    {
        CONST_VTBL struct INetSharingEveryConnectionCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharingEveryConnectionCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetSharingEveryConnectionCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetSharingEveryConnectionCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetSharingEveryConnectionCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetSharingEveryConnectionCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetSharingEveryConnectionCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetSharingEveryConnectionCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetSharingEveryConnectionCollection_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define INetSharingEveryConnectionCollection_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetSharingEveryConnectionCollection_INTERFACE_DEFINED__ */


#ifndef __INetSharingPublicConnectionCollection_INTERFACE_DEFINED__
#define __INetSharingPublicConnectionCollection_INTERFACE_DEFINED__

/* interface INetSharingPublicConnectionCollection */
/* [unique][helpstring][dual][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_INetSharingPublicConnectionCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7D7A6355-F372-4971-A149-BFC927BE762A")
    INetSharingPublicConnectionCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharingPublicConnectionCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetSharingPublicConnectionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetSharingPublicConnectionCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetSharingPublicConnectionCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetSharingPublicConnectionCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetSharingPublicConnectionCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetSharingPublicConnectionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetSharingPublicConnectionCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in INetSharingPublicConnectionCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in INetSharingPublicConnectionCollection * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        END_INTERFACE
    } INetSharingPublicConnectionCollectionVtbl;

    interface INetSharingPublicConnectionCollection
    {
        CONST_VTBL struct INetSharingPublicConnectionCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharingPublicConnectionCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetSharingPublicConnectionCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetSharingPublicConnectionCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetSharingPublicConnectionCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetSharingPublicConnectionCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetSharingPublicConnectionCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetSharingPublicConnectionCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetSharingPublicConnectionCollection_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define INetSharingPublicConnectionCollection_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetSharingPublicConnectionCollection_INTERFACE_DEFINED__ */


#ifndef __INetSharingPrivateConnectionCollection_INTERFACE_DEFINED__
#define __INetSharingPrivateConnectionCollection_INTERFACE_DEFINED__

/* interface INetSharingPrivateConnectionCollection */
/* [unique][helpstring][dual][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_INetSharingPrivateConnectionCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38AE69E0-4409-402A-A2CB-E965C727F840")
    INetSharingPrivateConnectionCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharingPrivateConnectionCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetSharingPrivateConnectionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetSharingPrivateConnectionCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetSharingPrivateConnectionCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetSharingPrivateConnectionCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetSharingPrivateConnectionCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetSharingPrivateConnectionCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetSharingPrivateConnectionCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in INetSharingPrivateConnectionCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in INetSharingPrivateConnectionCollection * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        END_INTERFACE
    } INetSharingPrivateConnectionCollectionVtbl;

    interface INetSharingPrivateConnectionCollection
    {
        CONST_VTBL struct INetSharingPrivateConnectionCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharingPrivateConnectionCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetSharingPrivateConnectionCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetSharingPrivateConnectionCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetSharingPrivateConnectionCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetSharingPrivateConnectionCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetSharingPrivateConnectionCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetSharingPrivateConnectionCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetSharingPrivateConnectionCollection_get__NewEnum(This,pVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,pVal) ) 

#define INetSharingPrivateConnectionCollection_get_Count(This,pVal)	\
    ( (This)->lpVtbl -> get_Count(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetSharingPrivateConnectionCollection_INTERFACE_DEFINED__ */


#ifndef __INetSharingManager_INTERFACE_DEFINED__
#define __INetSharingManager_INTERFACE_DEFINED__

/* interface INetSharingManager */
/* [unique][dual][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_INetSharingManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956B7-1CD3-11D1-B1C5-00805FC1270E")
    INetSharingManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SharingInstalled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbInstalled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumPublicConnections( 
            /* [in] */ SHARINGCONNECTION_ENUM_FLAGS Flags,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPublicConnectionCollection **ppColl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumPrivateConnections( 
            /* [in] */ SHARINGCONNECTION_ENUM_FLAGS Flags,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPrivateConnectionCollection **ppColl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_INetSharingConfigurationForINetConnection( 
            /* [in] */ __RPC__in_opt INetConnection *pNetConnection,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingConfiguration **ppNetSharingConfiguration) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumEveryConnection( 
            /* [retval][out] */ __RPC__deref_out_opt INetSharingEveryConnectionCollection **ppColl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetConnectionProps( 
            /* [in] */ __RPC__in_opt INetConnection *pNetConnection,
            /* [retval][out] */ __RPC__deref_out_opt INetConnectionProps **ppProps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetSharingManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetSharingManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetSharingManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetSharingManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetSharingManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetSharingManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetSharingManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetSharingManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SharingInstalled )( 
            __RPC__in INetSharingManager * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbInstalled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumPublicConnections )( 
            __RPC__in INetSharingManager * This,
            /* [in] */ SHARINGCONNECTION_ENUM_FLAGS Flags,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPublicConnectionCollection **ppColl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumPrivateConnections )( 
            __RPC__in INetSharingManager * This,
            /* [in] */ SHARINGCONNECTION_ENUM_FLAGS Flags,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingPrivateConnectionCollection **ppColl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_INetSharingConfigurationForINetConnection )( 
            __RPC__in INetSharingManager * This,
            /* [in] */ __RPC__in_opt INetConnection *pNetConnection,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingConfiguration **ppNetSharingConfiguration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumEveryConnection )( 
            __RPC__in INetSharingManager * This,
            /* [retval][out] */ __RPC__deref_out_opt INetSharingEveryConnectionCollection **ppColl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetConnectionProps )( 
            __RPC__in INetSharingManager * This,
            /* [in] */ __RPC__in_opt INetConnection *pNetConnection,
            /* [retval][out] */ __RPC__deref_out_opt INetConnectionProps **ppProps);
        
        END_INTERFACE
    } INetSharingManagerVtbl;

    interface INetSharingManager
    {
        CONST_VTBL struct INetSharingManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetSharingManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetSharingManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetSharingManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetSharingManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetSharingManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetSharingManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetSharingManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetSharingManager_get_SharingInstalled(This,pbInstalled)	\
    ( (This)->lpVtbl -> get_SharingInstalled(This,pbInstalled) ) 

#define INetSharingManager_get_EnumPublicConnections(This,Flags,ppColl)	\
    ( (This)->lpVtbl -> get_EnumPublicConnections(This,Flags,ppColl) ) 

#define INetSharingManager_get_EnumPrivateConnections(This,Flags,ppColl)	\
    ( (This)->lpVtbl -> get_EnumPrivateConnections(This,Flags,ppColl) ) 

#define INetSharingManager_get_INetSharingConfigurationForINetConnection(This,pNetConnection,ppNetSharingConfiguration)	\
    ( (This)->lpVtbl -> get_INetSharingConfigurationForINetConnection(This,pNetConnection,ppNetSharingConfiguration) ) 

#define INetSharingManager_get_EnumEveryConnection(This,ppColl)	\
    ( (This)->lpVtbl -> get_EnumEveryConnection(This,ppColl) ) 

#define INetSharingManager_get_NetConnectionProps(This,pNetConnection,ppProps)	\
    ( (This)->lpVtbl -> get_NetConnectionProps(This,pNetConnection,ppProps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetSharingManager_INTERFACE_DEFINED__ */



#ifndef __NETCONLib_LIBRARY_DEFINED__
#define __NETCONLib_LIBRARY_DEFINED__

/* library NETCONLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_NETCONLib;

EXTERN_C const CLSID CLSID_NetSharingManager;

#ifdef __cplusplus

class DECLSPEC_UUID("5C63C1AD-3956-4FF8-8486-40034758315B")
NetSharingManager;
#endif
#endif /* __NETCONLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\neterr.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1991-1999. All rights reserved.
//
//  MODULE: nmneterr.h
//
//  This is the top-level include file for all NETWORK topology error codes
//  Network Monitor driver network error codes -- DO NOT CHANGE!
//=============================================================================

#if !defined(_NMNETERR_)

#define _NMNETERR_

//=============================================================================
//  TOKENRING errors
//=============================================================================

#define NETERR_RING_STATUS_SIGNAL_LOST           0x00008000

#define NETERR_RING_STATUS_HARD_ERROR            0x00004000

#define NETERR_RING_STATUS_SOFT_ERROR            0x00002000

#define NETERR_RING_STATUS_TRANSMIT_BEACON       0x00001000

#define NETERR_RING_STATUS_LOBE_WIRE_FAULT       0x00000800

#define NETERR_RING_STATUS_AUTO_REMOVAL_ERROR    0x00000400

#define NETERR_RING_STATUS_REMOTE_RECEIVED       0x00000200

#define NETERR_RING_STATUS_COUNTER_OVERFLOW      0x00000100

#define NETERR_RING_STATUS_SIGNAL_STATION        0x00000080

#define NETERR_RING_STATUS_RECOVERY              0x00000040


//
// The following defines a bit mask to be compared with to see if
// the state of the ring should cause us to stop the current network
// capture.
//
// LobeWireFault, Signal Loss, Remove Received, and Auto Removal are
// currently the ones that fall into this category.
//
#define NETERR_RING_STOP_CAPTURE                 0x00008E00


//=============================================================================
//  ETHERNET errors
//=============================================================================

//=============================================================================
//  FDDI errors
//=============================================================================

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\nldef.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    nldef.h

Abstract:

    This module contains basic network layer definitions.
    Previously some of these were duplicated in both routprot.h and
    iprtrmib.h.

Author:
Environment:

    user mode or kernel mode

--*/

#ifndef _NLDEF_
#define _NLDEF_
#pragma once

#define NL_MAX_METRIC_COMPONENT ((((ULONG) 1) << 31) - 1)

typedef enum {
    //
    // These values are from iptypes.h.
    // They need to fit in a 4 bit field.
    //
    IpPrefixOriginOther = 0,
    IpPrefixOriginManual,
    IpPrefixOriginWellKnown,
    IpPrefixOriginDhcp,
    IpPrefixOriginRouterAdvertisement,
    IpPrefixOriginUnchanged = 1 << 4
} NL_PREFIX_ORIGIN;

//
// TODO: Remove these definitions.
//
#define NlpoOther               IpPrefixOriginOther
#define NlpoManual              IpPrefixOriginManual
#define NlpoWellKnown           IpPrefixOriginWellKnown
#define NlpoDhcp                IpPrefixOriginDhcp
#define NlpoRouterAdvertisement IpPrefixOriginRouterAdvertisement

typedef enum {
    //
    // TODO: Remove the Nlso* definitions.
    //
    NlsoOther = 0,
    NlsoManual,
    NlsoWellKnown,
    NlsoDhcp,
    NlsoLinkLayerAddress,
    NlsoRandom,

    //
    // These values are from in iptypes.h.
    // They need to fit in a 4 bit field.
    //
    IpSuffixOriginOther = 0,
    IpSuffixOriginManual,
    IpSuffixOriginWellKnown,
    IpSuffixOriginDhcp,
    IpSuffixOriginLinkLayerAddress,
    IpSuffixOriginRandom,
    IpSuffixOriginUnchanged = 1 << 4
} NL_SUFFIX_ORIGIN;

typedef enum {
    //
    // TODO: Remove the Nlds* definitions.
    //
    NldsInvalid,
    NldsTentative,
    NldsDuplicate,
    NldsDeprecated,
    NldsPreferred,

    //
    // These values are from in iptypes.h.
    //
    IpDadStateInvalid    = 0,
    IpDadStateTentative,
    IpDadStateDuplicate,
    IpDadStateDeprecated,
    IpDadStatePreferred,
} NL_DAD_STATE;

//
// MIB_IPPROTO_* values were previously in iprtrmib.h.
// PROTO_IP_* values were previously in routprot.h.
//
#define MAKE_ROUTE_PROTOCOL(suffix, value) \
    MIB_IPPROTO_ ## suffix = value, \
    PROTO_IP_ ## suffix    = value

//
// Routing protocol values from RFC.
//
typedef enum {
    //
    // TODO: Remove the RouteProtocol* definitions.
    //
    RouteProtocolOther   = 1,
    RouteProtocolLocal   = 2,
    RouteProtocolNetMgmt = 3,
    RouteProtocolIcmp    = 4,
    RouteProtocolEgp     = 5,
    RouteProtocolGgp     = 6,
    RouteProtocolHello   = 7,
    RouteProtocolRip     = 8,
    RouteProtocolIsIs    = 9,
    RouteProtocolEsIs    = 10,
    RouteProtocolCisco   = 11,
    RouteProtocolBbn     = 12,
    RouteProtocolOspf    = 13,
    RouteProtocolBgp     = 14,

    MAKE_ROUTE_PROTOCOL(OTHER,   1),
    MAKE_ROUTE_PROTOCOL(LOCAL,   2),
    MAKE_ROUTE_PROTOCOL(NETMGMT, 3),
    MAKE_ROUTE_PROTOCOL(ICMP,    4),
    MAKE_ROUTE_PROTOCOL(EGP,     5),
    MAKE_ROUTE_PROTOCOL(GGP,     6),
    MAKE_ROUTE_PROTOCOL(HELLO,   7),
    MAKE_ROUTE_PROTOCOL(RIP,     8),
    MAKE_ROUTE_PROTOCOL(IS_IS,   9),
    MAKE_ROUTE_PROTOCOL(ES_IS,  10),
    MAKE_ROUTE_PROTOCOL(CISCO,  11),
    MAKE_ROUTE_PROTOCOL(BBN,    12),
    MAKE_ROUTE_PROTOCOL(OSPF,   13),
    MAKE_ROUTE_PROTOCOL(BGP,    14),

    //
    // Windows-specific definitions.
    //
    MAKE_ROUTE_PROTOCOL(NT_AUTOSTATIC,     10002),
    MAKE_ROUTE_PROTOCOL(NT_STATIC,         10006),
    MAKE_ROUTE_PROTOCOL(NT_STATIC_NON_DOD, 10007),

} NL_ROUTE_PROTOCOL, *PNL_ROUTE_PROTOCOL;

typedef enum {
    NlatUnspecified,
    NlatUnicast,
    NlatAnycast,
    NlatMulticast,
    NlatBroadcast,
    NlatInvalid
} NL_ADDRESS_TYPE, *PNL_ADDRESS_TYPE;

//
// NL_ROUTE_ORIGIN
//
// Define route origin values.
//

typedef enum _NL_ROUTE_ORIGIN {
    NlroManual,
    NlroWellKnown,
    NlroDHCP,
    NlroRouterAdvertisement,
    Nlro6to4,
} NL_ROUTE_ORIGIN, *PNL_ROUTE_ORIGIN;

//
// NL_NEIGHBOR_STATE
//
// Define network layer neighbor state.  RFC 2461, section 7.3.2 has details.
// Note: Only state names are documented, we chose the values used here.
//

typedef enum _NL_NEIGHBOR_STATE {
    NlnsUnreachable,
    NlnsIncomplete,
    NlnsProbe,
    NlnsDelay,
    NlnsStale,
    NlnsReachable,
    NlnsPermanent,
    NlnsMaximum,
} NL_NEIGHBOR_STATE, *PNL_NEIGHBOR_STATE;

typedef enum _NL_LINK_LOCAL_ADDRESS_BEHAVIOR{
    LinkLocalAlwaysOff = 0,     // Never use link locals.
    LinkLocalDelayed,           // Use link locals only if no other addresses. 
                                // (default for IPv4).
                                // Legacy mapping: IPAutoconfigurationEnabled.
    LinkLocalAlwaysOn,          // Always use link locals (default for IPv6). 
    LinkLocalUnchanged = -1
} NL_LINK_LOCAL_ADDRESS_BEHAVIOR;

#pragma warning(push)
#pragma warning(disable:4214)

typedef struct _NL_INTERFACE_OFFLOAD_ROD {
    BOOLEAN NlChecksumSupported : 1;
    BOOLEAN NlOptionsSupported : 1;
    BOOLEAN TlDatagramChecksumSupported : 1;
    BOOLEAN TlStreamChecksumSupported : 1;
    BOOLEAN TlStreamOptionsSupported : 1;
    BOOLEAN FastPathCompatible : 1;
    BOOLEAN TlLargeSendOffloadSupported : 1;
    BOOLEAN TlGiantSendOffloadSupported : 1;
} NL_INTERFACE_OFFLOAD_ROD, *PNL_INTERFACE_OFFLOAD_ROD;

#pragma warning(pop)

typedef enum _NL_ROUTER_DISCOVERY_BEHAVIOR {
    RouterDiscoveryDisabled = 0, 
    RouterDiscoveryEnabled, 
    RouterDiscoveryDhcp, 
    RouterDiscoveryUnchanged = -1
} NL_ROUTER_DISCOVERY_BEHAVIOR;

typedef enum _NL_BANDWIDTH_FLAG {
    NlbwDisabled = 0,
    NlbwEnabled,
    NlbwUnchanged = -1
} NL_BANDWIDTH_FLAG, *PNL_BANDWIDTH_FLAG;

typedef struct _NL_PATH_BANDWIDTH_ROD {
    ULONG64 Bandwidth;
    ULONG64 Instability;
    BOOLEAN BandwidthPeaked;
} NL_PATH_BANDWIDTH_ROD, *PNL_PATH_BANDWIDTH_ROD;

typedef enum _NL_NETWORK_CATEGORY {
    NetworkCategoryPublic,
    NetworkCategoryPrivate,
    NetworkCategoryDomainAuthenticated,
    NetworkCategoryUnchanged = -1,          // used in a set operation
    NetworkCategoryUnknown = -1             // returned in a query operation
} NL_NETWORK_CATEGORY, *PNL_NETWORK_CATEGORY;

#define NET_IF_CURRENT_SESSION ((ULONG)-1)

#endif // _NLDEF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\nmsupp.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1991-1999. All rights reserved.
//
//  MODULE: bhsupp.h
//=============================================================================

#if !defined(_NMSUPP_H)

#define _NMSUPP_H

#pragma pack(1)

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __cplusplus
#ifndef try
#define try                         __try
#endif

#ifndef except
#define except                      __except
#endif
#endif

//=============================================================================
//  Windows version constants.
//=============================================================================

#define WINDOWS_VERSION_UNKNOWN     0
#define WINDOWS_VERSION_WIN32S      1
#define WINDOWS_VERSION_WIN32C      2
#define WINDOWS_VERSION_WIN32       3

//=============================================================================
//  Frame masks.
//=============================================================================

#define FRAME_MASK_ETHERNET         ((BYTE) ~0x01)
#define FRAME_MASK_TOKENRING        ((BYTE) ~0x80)
#define FRAME_MASK_FDDI             ((BYTE) ~0x01)

//=============================================================================
//  ACCESSRIGHTS
//=============================================================================

typedef enum _ACCESSRIGHTS
{
    AccessRightsNoAccess,               //... Access denied, invalid password.
    AccessRightsMonitoring,             //... Monitoring mode only.
    AccessRightsUserAccess,             //... User-level access rights.
    AccessRightsAllAccess               //... All access.
} ACCESSRIGHTS;

typedef ACCESSRIGHTS *PACCESSRIGHTS;

typedef LPVOID HPASSWORD;

#define HANDLE_TYPE_PASSWORD            MAKE_IDENTIFIER('P', 'W', 'D', '$')

//=============================================================================
//  Object heap type.
//=============================================================================

typedef LPVOID HOBJECTHEAP;                 //... Opaque.

//=============================================================================
//  Object cleanup procedure.
//=============================================================================

typedef VOID (WINAPI *OBJECTPROC)(HOBJECTHEAP, LPVOID);

#pragma pack()

//=============================================================================
//  Network Monitor timers.
//=============================================================================

typedef struct _TIMER *HTIMER;

typedef VOID (WINAPI *BHTIMERPROC)(LPVOID);

extern  HTIMER WINAPI BhSetTimer(BHTIMERPROC TimerProc, LPVOID InstData, DWORD TimeOut);

extern  VOID   WINAPI BhKillTimer(HTIMER hTimer);

//=============================================================================
//  Network Monitor driver support.
//=============================================================================

extern LPVOID WINAPI BhAllocSystemMemory(DWORD nBytes);

extern LPVOID WINAPI BhFreeSystemMemory(LPVOID ptr);

extern LPVOID WINAPI BhGetNetworkRequestAddress(DWORD NalRequestType);

//=============================================================================
//  Network Monitor global error API.
//=============================================================================

extern DWORD  WINAPI BhGetLastError(VOID);

extern DWORD  WINAPI BhSetLastError(DWORD Error);

//=============================================================================
//  Object manager function prototypes.
//=============================================================================

extern HOBJECTHEAP WINAPI CreateObjectHeap(DWORD ObjectSize, OBJECTPROC ObjectProc);

extern HOBJECTHEAP WINAPI DestroyObjectHeap(HOBJECTHEAP hObjectHeap);

extern LPVOID      WINAPI AllocObject(HOBJECTHEAP hObjectHeap);

extern LPVOID      WINAPI FreeObject(HOBJECTHEAP hObjectHeap, LPVOID ObjectMemory);

extern DWORD       WINAPI GrowObjectHeap(HOBJECTHEAP hObjectHeap, DWORD nObjects);

extern DWORD       WINAPI GetObjectHeapSize(HOBJECTHEAP hObjectHeap);

extern VOID        WINAPI PurgeObjectHeap(HOBJECTHEAP hObjectHeap);

//=============================================================================
//  Memory functions.
//=============================================================================

extern LPVOID     WINAPI AllocMemory(SIZE_T size);

extern LPVOID     WINAPI ReallocMemory(LPVOID ptr, SIZE_T NewSize);

extern VOID       WINAPI FreeMemory(LPVOID ptr);

extern VOID       WINAPI TestMemory(LPVOID ptr);

extern SIZE_T     WINAPI MemorySize(LPVOID ptr);

extern HANDLE     WINAPI MemoryHandle(LPBYTE ptr);

//=============================================================================
//  Password API's.
//=============================================================================

extern HPASSWORD    WINAPI CreatePassword(LPSTR password);

extern VOID         WINAPI DestroyPassword(HPASSWORD hPassword);

extern ACCESSRIGHTS WINAPI ValidatePassword(HPASSWORD hPassword);

//=============================================================================
//  EXPRESSION API's
//=============================================================================

extern LPEXPRESSION         WINAPI InitializeExpression(LPEXPRESSION Expression);

extern LPPATTERNMATCH       WINAPI InitializePattern(LPPATTERNMATCH Pattern, LPVOID ptr, DWORD offset, DWORD length);

extern LPEXPRESSION         WINAPI AndExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

extern LPEXPRESSION         WINAPI OrExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

extern LPPATTERNMATCH       WINAPI NegatePattern(LPPATTERNMATCH Pattern);

extern LPADDRESSTABLE       WINAPI AdjustOperatorPrecedence(LPADDRESSTABLE AddressTable);

extern LPADDRESS            WINAPI NormalizeAddress(LPADDRESS Address);

extern LPADDRESSTABLE       WINAPI NormalizeAddressTable(LPADDRESSTABLE AddressTable);

//=============================================================================
//  SERVICE API's
//=============================================================================

extern HANDLE               WINAPI BhOpenService(LPSTR ServiceName);

extern VOID                 WINAPI BhCloseService(HANDLE ServiceHandle);

extern DWORD                WINAPI BhStartService(HANDLE ServiceHandle);

extern DWORD                WINAPI BhStopService(HANDLE ServiceHandle);

//=============================================================================
//  MISC. API's
//=============================================================================

extern DWORD                WINAPI BhGetWindowsVersion(VOID);

extern BOOL                 WINAPI IsDaytona(VOID);

extern VOID                 _cdecl dprintf(LPSTR format, ...);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\netlistmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for netlistmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netlistmgr_h__
#define __netlistmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INetworkListManager_FWD_DEFINED__
#define __INetworkListManager_FWD_DEFINED__
typedef interface INetworkListManager INetworkListManager;
#endif 	/* __INetworkListManager_FWD_DEFINED__ */


#ifndef __INetworkListManagerEvents_FWD_DEFINED__
#define __INetworkListManagerEvents_FWD_DEFINED__
typedef interface INetworkListManagerEvents INetworkListManagerEvents;
#endif 	/* __INetworkListManagerEvents_FWD_DEFINED__ */


#ifndef __INetwork_FWD_DEFINED__
#define __INetwork_FWD_DEFINED__
typedef interface INetwork INetwork;
#endif 	/* __INetwork_FWD_DEFINED__ */


#ifndef __IEnumNetworks_FWD_DEFINED__
#define __IEnumNetworks_FWD_DEFINED__
typedef interface IEnumNetworks IEnumNetworks;
#endif 	/* __IEnumNetworks_FWD_DEFINED__ */


#ifndef __INetworkEvents_FWD_DEFINED__
#define __INetworkEvents_FWD_DEFINED__
typedef interface INetworkEvents INetworkEvents;
#endif 	/* __INetworkEvents_FWD_DEFINED__ */


#ifndef __INetworkConnection_FWD_DEFINED__
#define __INetworkConnection_FWD_DEFINED__
typedef interface INetworkConnection INetworkConnection;
#endif 	/* __INetworkConnection_FWD_DEFINED__ */


#ifndef __IEnumNetworkConnections_FWD_DEFINED__
#define __IEnumNetworkConnections_FWD_DEFINED__
typedef interface IEnumNetworkConnections IEnumNetworkConnections;
#endif 	/* __IEnumNetworkConnections_FWD_DEFINED__ */


#ifndef __INetworkConnectionEvents_FWD_DEFINED__
#define __INetworkConnectionEvents_FWD_DEFINED__
typedef interface INetworkConnectionEvents INetworkConnectionEvents;
#endif 	/* __INetworkConnectionEvents_FWD_DEFINED__ */


#ifndef __NetworkListManager_FWD_DEFINED__
#define __NetworkListManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetworkListManager NetworkListManager;
#else
typedef struct NetworkListManager NetworkListManager;
#endif /* __cplusplus */

#endif 	/* __NetworkListManager_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_netlistmgr_0000_0000 */
/* [local] */ 









#define NA_DomainAuthenticationFailed  L"NA_DomainAuthenticationFailed"
#define NA_NetworkClass  L"NA_NetworkClass"
#define NA_NameSetByPolicy  L"NA_NameSetByPolicy"
#define NA_IconSetByPolicy  L"NA_IconSetByPolicy"
#define NA_DescriptionSetByPolicy  L"NA_DescriptionSetByPolicy"
#define NA_CategorySetByPolicy  L"NA_CategorySetByPolicy"
#define NA_NameReadOnly  L"NA_NameReadOnly"
#define NA_IconReadOnly  L"NA_IconReadOnly"
#define NA_DescriptionReadOnly  L"NA_DescriptionReadOnly"
#define NA_CategoryReadOnly  L"NA_CategoryReadOnly"
#define NA_AllowMerge  L"NA_AllowMerge"
#define NA_InternetConnectivityV4 L"NA_InternetConnectivityV4"
#define NA_InternetConnectivityV6 L"NA_InternetConnectivityV6"
typedef /* [v1_enum] */ 
enum NLM_NETWORK_CLASS
    {	NLM_NETWORK_IDENTIFYING	= 0x1,
	NLM_NETWORK_IDENTIFIED	= 0x2,
	NLM_NETWORK_UNIDENTIFIED	= 0x3
    } 	NLM_NETWORK_CLASS;

typedef /* [v1_enum] */ 
enum NLM_INTERNET_CONNECTIVITY
    {	NLM_INTERNET_CONNECTIVITY_WEBHIJACK	= 0x1,
	NLM_INTERNET_CONNECTIVITY_PROXIED	= 0x2,
	NLM_INTERNET_CONNECTIVITY_CORPORATE	= 0x4
    } 	NLM_INTERNET_CONNECTIVITY;

typedef /* [v1_enum] */ 
enum NLM_CONNECTIVITY
    {	NLM_CONNECTIVITY_DISCONNECTED	= 0,
	NLM_CONNECTIVITY_IPV4_NOTRAFFIC	= 0x1,
	NLM_CONNECTIVITY_IPV6_NOTRAFFIC	= 0x2,
	NLM_CONNECTIVITY_IPV4_SUBNET	= 0x10,
	NLM_CONNECTIVITY_IPV4_LOCALNETWORK	= 0x20,
	NLM_CONNECTIVITY_IPV4_INTERNET	= 0x40,
	NLM_CONNECTIVITY_IPV6_SUBNET	= 0x100,
	NLM_CONNECTIVITY_IPV6_LOCALNETWORK	= 0x200,
	NLM_CONNECTIVITY_IPV6_INTERNET	= 0x400
    } 	NLM_CONNECTIVITY;

typedef 
enum NLM_DOMAIN_TYPE
    {	NLM_DOMAIN_TYPE_NON_DOMAIN_NETWORK	= 0,
	NLM_DOMAIN_TYPE_DOMAIN_NETWORK	= 0x1,
	NLM_DOMAIN_TYPE_DOMAIN_AUTHENTICATED	= 0x2
    } 	NLM_DOMAIN_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_netlistmgr_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netlistmgr_0000_0000_v0_0_s_ifspec;

#ifndef __INetworkListManager_INTERFACE_DEFINED__
#define __INetworkListManager_INTERFACE_DEFINED__

/* interface INetworkListManager */
/* [dual][unique][oleautomation][object][helpstring][uuid] */ 

typedef /* [v1_enum] */ 
enum NLM_ENUM_NETWORK
    {	NLM_ENUM_NETWORK_CONNECTED	= 0x1,
	NLM_ENUM_NETWORK_DISCONNECTED	= 0x2,
	NLM_ENUM_NETWORK_ALL	= 0x3
    } 	NLM_ENUM_NETWORK;


EXTERN_C const IID IID_INetworkListManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCB00000-570F-4A9B-8D69-199FDBA5723B")
    INetworkListManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNetworks( 
            /* [in] */ NLM_ENUM_NETWORK Flags,
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworks **ppEnumNetwork) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNetwork( 
            /* [in] */ GUID gdNetworkId,
            /* [retval][out] */ __RPC__deref_out_opt INetwork **ppNetwork) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNetworkConnections( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworkConnections **ppEnum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNetworkConnection( 
            /* [in] */ GUID gdNetworkConnectionId,
            /* [retval][out] */ __RPC__deref_out_opt INetworkConnection **ppNetworkConnection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsConnectedToInternet( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsConnected( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectivity( 
            /* [retval][out] */ __RPC__out NLM_CONNECTIVITY *pConnectivity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetworkListManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetworkListManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetworkListManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetworkListManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetworkListManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetworkListManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetworkListManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetworkListManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNetworks )( 
            __RPC__in INetworkListManager * This,
            /* [in] */ NLM_ENUM_NETWORK Flags,
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworks **ppEnumNetwork);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNetwork )( 
            __RPC__in INetworkListManager * This,
            /* [in] */ GUID gdNetworkId,
            /* [retval][out] */ __RPC__deref_out_opt INetwork **ppNetwork);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNetworkConnections )( 
            __RPC__in INetworkListManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworkConnections **ppEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNetworkConnection )( 
            __RPC__in INetworkListManager * This,
            /* [in] */ GUID gdNetworkConnectionId,
            /* [retval][out] */ __RPC__deref_out_opt INetworkConnection **ppNetworkConnection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsConnectedToInternet )( 
            __RPC__in INetworkListManager * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsConnected )( 
            __RPC__in INetworkListManager * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectivity )( 
            __RPC__in INetworkListManager * This,
            /* [retval][out] */ __RPC__out NLM_CONNECTIVITY *pConnectivity);
        
        END_INTERFACE
    } INetworkListManagerVtbl;

    interface INetworkListManager
    {
        CONST_VTBL struct INetworkListManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetworkListManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetworkListManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetworkListManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetworkListManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetworkListManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetworkListManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetworkListManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetworkListManager_GetNetworks(This,Flags,ppEnumNetwork)	\
    ( (This)->lpVtbl -> GetNetworks(This,Flags,ppEnumNetwork) ) 

#define INetworkListManager_GetNetwork(This,gdNetworkId,ppNetwork)	\
    ( (This)->lpVtbl -> GetNetwork(This,gdNetworkId,ppNetwork) ) 

#define INetworkListManager_GetNetworkConnections(This,ppEnum)	\
    ( (This)->lpVtbl -> GetNetworkConnections(This,ppEnum) ) 

#define INetworkListManager_GetNetworkConnection(This,gdNetworkConnectionId,ppNetworkConnection)	\
    ( (This)->lpVtbl -> GetNetworkConnection(This,gdNetworkConnectionId,ppNetworkConnection) ) 

#define INetworkListManager_get_IsConnectedToInternet(This,pbIsConnected)	\
    ( (This)->lpVtbl -> get_IsConnectedToInternet(This,pbIsConnected) ) 

#define INetworkListManager_get_IsConnected(This,pbIsConnected)	\
    ( (This)->lpVtbl -> get_IsConnected(This,pbIsConnected) ) 

#define INetworkListManager_GetConnectivity(This,pConnectivity)	\
    ( (This)->lpVtbl -> GetConnectivity(This,pConnectivity) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetworkListManager_INTERFACE_DEFINED__ */


#ifndef __INetworkListManagerEvents_INTERFACE_DEFINED__
#define __INetworkListManagerEvents_INTERFACE_DEFINED__

/* interface INetworkListManagerEvents */
/* [unique][oleautomation][object][helpstring][uuid] */ 


EXTERN_C const IID IID_INetworkListManagerEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCB00001-570F-4A9B-8D69-199FDBA5723B")
    INetworkListManagerEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectivityChanged( 
            /* [in] */ NLM_CONNECTIVITY newConnectivity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetworkListManagerEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetworkListManagerEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetworkListManagerEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetworkListManagerEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectivityChanged )( 
            __RPC__in INetworkListManagerEvents * This,
            /* [in] */ NLM_CONNECTIVITY newConnectivity);
        
        END_INTERFACE
    } INetworkListManagerEventsVtbl;

    interface INetworkListManagerEvents
    {
        CONST_VTBL struct INetworkListManagerEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetworkListManagerEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetworkListManagerEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetworkListManagerEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetworkListManagerEvents_ConnectivityChanged(This,newConnectivity)	\
    ( (This)->lpVtbl -> ConnectivityChanged(This,newConnectivity) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetworkListManagerEvents_INTERFACE_DEFINED__ */


#ifndef __INetwork_INTERFACE_DEFINED__
#define __INetwork_INTERFACE_DEFINED__

/* interface INetwork */
/* [dual][unique][oleautomation][object][helpstring][uuid] */ 

typedef 
enum NLM_NETWORK_CATEGORY
    {	NLM_NETWORK_CATEGORY_PUBLIC	= 0,
	NLM_NETWORK_CATEGORY_PRIVATE	= 0x1,
	NLM_NETWORK_CATEGORY_DOMAIN_AUTHENTICATED	= 0x2
    } 	NLM_NETWORK_CATEGORY;


EXTERN_C const IID IID_INetwork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCB00002-570F-4A9B-8D69-199FDBA5723B")
    INetwork : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetName( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string BSTR *pszNetworkName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetName( 
            /* [string][in] */ __RPC__in_string BSTR szNetworkNewName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [retval][string][out] */ __RPC__deref_out_opt_string BSTR *pszDescription) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [string][in] */ __RPC__in_string BSTR szDescription) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNetworkId( 
            /* [retval][out] */ __RPC__out GUID *pgdGuidNetworkId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDomainType( 
            /* [retval][out] */ __RPC__out NLM_DOMAIN_TYPE *pNetworkType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNetworkConnections( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworkConnections **ppEnumNetworkConnection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTimeCreatedAndConnected( 
            /* [out] */ __RPC__out DWORD *pdwLowDateTimeCreated,
            /* [out] */ __RPC__out DWORD *pdwHighDateTimeCreated,
            /* [out] */ __RPC__out DWORD *pdwLowDateTimeConnected,
            /* [out] */ __RPC__out DWORD *pdwHighDateTimeConnected) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsConnectedToInternet( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsConnected( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectivity( 
            /* [retval][out] */ __RPC__out NLM_CONNECTIVITY *pConnectivity) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [retval][out] */ __RPC__out NLM_NETWORK_CATEGORY *pCategory) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetCategory( 
            /* [in] */ NLM_NETWORK_CATEGORY NewCategory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetworkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetwork * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetwork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetwork * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetwork * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetwork * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetwork * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetwork * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetName )( 
            __RPC__in INetwork * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string BSTR *pszNetworkName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetName )( 
            __RPC__in INetwork * This,
            /* [string][in] */ __RPC__in_string BSTR szNetworkNewName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            __RPC__in INetwork * This,
            /* [retval][string][out] */ __RPC__deref_out_opt_string BSTR *pszDescription);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            __RPC__in INetwork * This,
            /* [string][in] */ __RPC__in_string BSTR szDescription);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNetworkId )( 
            __RPC__in INetwork * This,
            /* [retval][out] */ __RPC__out GUID *pgdGuidNetworkId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomainType )( 
            __RPC__in INetwork * This,
            /* [retval][out] */ __RPC__out NLM_DOMAIN_TYPE *pNetworkType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNetworkConnections )( 
            __RPC__in INetwork * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworkConnections **ppEnumNetworkConnection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTimeCreatedAndConnected )( 
            __RPC__in INetwork * This,
            /* [out] */ __RPC__out DWORD *pdwLowDateTimeCreated,
            /* [out] */ __RPC__out DWORD *pdwHighDateTimeCreated,
            /* [out] */ __RPC__out DWORD *pdwLowDateTimeConnected,
            /* [out] */ __RPC__out DWORD *pdwHighDateTimeConnected);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsConnectedToInternet )( 
            __RPC__in INetwork * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsConnected )( 
            __RPC__in INetwork * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectivity )( 
            __RPC__in INetwork * This,
            /* [retval][out] */ __RPC__out NLM_CONNECTIVITY *pConnectivity);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            __RPC__in INetwork * This,
            /* [retval][out] */ __RPC__out NLM_NETWORK_CATEGORY *pCategory);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetCategory )( 
            __RPC__in INetwork * This,
            /* [in] */ NLM_NETWORK_CATEGORY NewCategory);
        
        END_INTERFACE
    } INetworkVtbl;

    interface INetwork
    {
        CONST_VTBL struct INetworkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetwork_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetwork_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetwork_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetwork_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetwork_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetwork_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetwork_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetwork_GetName(This,pszNetworkName)	\
    ( (This)->lpVtbl -> GetName(This,pszNetworkName) ) 

#define INetwork_SetName(This,szNetworkNewName)	\
    ( (This)->lpVtbl -> SetName(This,szNetworkNewName) ) 

#define INetwork_GetDescription(This,pszDescription)	\
    ( (This)->lpVtbl -> GetDescription(This,pszDescription) ) 

#define INetwork_SetDescription(This,szDescription)	\
    ( (This)->lpVtbl -> SetDescription(This,szDescription) ) 

#define INetwork_GetNetworkId(This,pgdGuidNetworkId)	\
    ( (This)->lpVtbl -> GetNetworkId(This,pgdGuidNetworkId) ) 

#define INetwork_GetDomainType(This,pNetworkType)	\
    ( (This)->lpVtbl -> GetDomainType(This,pNetworkType) ) 

#define INetwork_GetNetworkConnections(This,ppEnumNetworkConnection)	\
    ( (This)->lpVtbl -> GetNetworkConnections(This,ppEnumNetworkConnection) ) 

#define INetwork_GetTimeCreatedAndConnected(This,pdwLowDateTimeCreated,pdwHighDateTimeCreated,pdwLowDateTimeConnected,pdwHighDateTimeConnected)	\
    ( (This)->lpVtbl -> GetTimeCreatedAndConnected(This,pdwLowDateTimeCreated,pdwHighDateTimeCreated,pdwLowDateTimeConnected,pdwHighDateTimeConnected) ) 

#define INetwork_get_IsConnectedToInternet(This,pbIsConnected)	\
    ( (This)->lpVtbl -> get_IsConnectedToInternet(This,pbIsConnected) ) 

#define INetwork_get_IsConnected(This,pbIsConnected)	\
    ( (This)->lpVtbl -> get_IsConnected(This,pbIsConnected) ) 

#define INetwork_GetConnectivity(This,pConnectivity)	\
    ( (This)->lpVtbl -> GetConnectivity(This,pConnectivity) ) 

#define INetwork_GetCategory(This,pCategory)	\
    ( (This)->lpVtbl -> GetCategory(This,pCategory) ) 

#define INetwork_SetCategory(This,NewCategory)	\
    ( (This)->lpVtbl -> SetCategory(This,NewCategory) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetwork_INTERFACE_DEFINED__ */


#ifndef __IEnumNetworks_INTERFACE_DEFINED__
#define __IEnumNetworks_INTERFACE_DEFINED__

/* interface IEnumNetworks */
/* [dual][unique][oleautomation][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumNetworks;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCB00003-570F-4A9B-8D69-199FDBA5723B")
    IEnumNetworks : public IDispatch
    {
    public:
        virtual /* [restricted][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppEnumVar) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) INetwork **rgelt,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworks **ppEnumNetwork) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetworksVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumNetworks * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumNetworks * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumNetworks * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IEnumNetworks * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IEnumNetworks * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IEnumNetworks * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEnumNetworks * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [restricted][hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IEnumNetworks * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppEnumVar);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumNetworks * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) INetwork **rgelt,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumNetworks * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumNetworks * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumNetworks * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworks **ppEnumNetwork);
        
        END_INTERFACE
    } IEnumNetworksVtbl;

    interface IEnumNetworks
    {
        CONST_VTBL struct IEnumNetworksVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetworks_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumNetworks_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumNetworks_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumNetworks_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IEnumNetworks_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IEnumNetworks_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IEnumNetworks_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IEnumNetworks_get__NewEnum(This,ppEnumVar)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppEnumVar) ) 

#define IEnumNetworks_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumNetworks_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumNetworks_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumNetworks_Clone(This,ppEnumNetwork)	\
    ( (This)->lpVtbl -> Clone(This,ppEnumNetwork) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumNetworks_INTERFACE_DEFINED__ */


#ifndef __INetworkEvents_INTERFACE_DEFINED__
#define __INetworkEvents_INTERFACE_DEFINED__

/* interface INetworkEvents */
/* [unique][oleautomation][object][helpstring][uuid] */ 

typedef 
enum NLM_NETWORK_PROPERTY_CHANGE
    {	NLM_NETWORK_PROPERTY_CHANGE_CONNECTION	= 0x1,
	NLM_NETWORK_PROPERTY_CHANGE_DESCRIPTION	= 0x2,
	NLM_NETWORK_PROPERTY_CHANGE_NAME	= 0x4,
	NLM_NETWORK_PROPERTY_CHANGE_ICON	= 0x8,
	NLM_NETWORK_PROPERTY_CHANGE_CATEGORY_VALUE	= 0x10
    } 	NLM_NETWORK_PROPERTY_CHANGE;


EXTERN_C const IID IID_INetworkEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCB00004-570F-4A9B-8D69-199FDBA5723B")
    INetworkEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NetworkAdded( 
            /* [in] */ GUID networkId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NetworkDeleted( 
            /* [in] */ GUID networkId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NetworkConnectivityChanged( 
            /* [in] */ GUID networkId,
            /* [in] */ NLM_CONNECTIVITY newConnectivity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NetworkPropertyChanged( 
            /* [in] */ GUID networkId,
            /* [in] */ NLM_NETWORK_PROPERTY_CHANGE flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetworkEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetworkEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetworkEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetworkEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *NetworkAdded )( 
            __RPC__in INetworkEvents * This,
            /* [in] */ GUID networkId);
        
        HRESULT ( STDMETHODCALLTYPE *NetworkDeleted )( 
            __RPC__in INetworkEvents * This,
            /* [in] */ GUID networkId);
        
        HRESULT ( STDMETHODCALLTYPE *NetworkConnectivityChanged )( 
            __RPC__in INetworkEvents * This,
            /* [in] */ GUID networkId,
            /* [in] */ NLM_CONNECTIVITY newConnectivity);
        
        HRESULT ( STDMETHODCALLTYPE *NetworkPropertyChanged )( 
            __RPC__in INetworkEvents * This,
            /* [in] */ GUID networkId,
            /* [in] */ NLM_NETWORK_PROPERTY_CHANGE flags);
        
        END_INTERFACE
    } INetworkEventsVtbl;

    interface INetworkEvents
    {
        CONST_VTBL struct INetworkEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetworkEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetworkEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetworkEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetworkEvents_NetworkAdded(This,networkId)	\
    ( (This)->lpVtbl -> NetworkAdded(This,networkId) ) 

#define INetworkEvents_NetworkDeleted(This,networkId)	\
    ( (This)->lpVtbl -> NetworkDeleted(This,networkId) ) 

#define INetworkEvents_NetworkConnectivityChanged(This,networkId,newConnectivity)	\
    ( (This)->lpVtbl -> NetworkConnectivityChanged(This,networkId,newConnectivity) ) 

#define INetworkEvents_NetworkPropertyChanged(This,networkId,flags)	\
    ( (This)->lpVtbl -> NetworkPropertyChanged(This,networkId,flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetworkEvents_INTERFACE_DEFINED__ */


#ifndef __INetworkConnection_INTERFACE_DEFINED__
#define __INetworkConnection_INTERFACE_DEFINED__

/* interface INetworkConnection */
/* [dual][unique][oleautomation][object][helpstring][uuid] */ 


EXTERN_C const IID IID_INetworkConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCB00005-570F-4A9B-8D69-199FDBA5723B")
    INetworkConnection : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNetwork( 
            /* [retval][out] */ __RPC__deref_out_opt INetwork **ppNetwork) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsConnectedToInternet( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsConnected( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectivity( 
            /* [retval][out] */ __RPC__out NLM_CONNECTIVITY *pConnectivity) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectionId( 
            /* [retval][out] */ __RPC__out GUID *pgdConnectionId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAdapterId( 
            /* [retval][out] */ __RPC__out GUID *pgdAdapterId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDomainType( 
            /* [retval][out] */ __RPC__out NLM_DOMAIN_TYPE *pDomainType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetworkConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetworkConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetworkConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetworkConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetworkConnection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetworkConnection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetworkConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetworkConnection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNetwork )( 
            __RPC__in INetworkConnection * This,
            /* [retval][out] */ __RPC__deref_out_opt INetwork **ppNetwork);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsConnectedToInternet )( 
            __RPC__in INetworkConnection * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsConnected )( 
            __RPC__in INetworkConnection * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbIsConnected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectivity )( 
            __RPC__in INetworkConnection * This,
            /* [retval][out] */ __RPC__out NLM_CONNECTIVITY *pConnectivity);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectionId )( 
            __RPC__in INetworkConnection * This,
            /* [retval][out] */ __RPC__out GUID *pgdConnectionId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAdapterId )( 
            __RPC__in INetworkConnection * This,
            /* [retval][out] */ __RPC__out GUID *pgdAdapterId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomainType )( 
            __RPC__in INetworkConnection * This,
            /* [retval][out] */ __RPC__out NLM_DOMAIN_TYPE *pDomainType);
        
        END_INTERFACE
    } INetworkConnectionVtbl;

    interface INetworkConnection
    {
        CONST_VTBL struct INetworkConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetworkConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetworkConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetworkConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetworkConnection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetworkConnection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetworkConnection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetworkConnection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetworkConnection_GetNetwork(This,ppNetwork)	\
    ( (This)->lpVtbl -> GetNetwork(This,ppNetwork) ) 

#define INetworkConnection_get_IsConnectedToInternet(This,pbIsConnected)	\
    ( (This)->lpVtbl -> get_IsConnectedToInternet(This,pbIsConnected) ) 

#define INetworkConnection_get_IsConnected(This,pbIsConnected)	\
    ( (This)->lpVtbl -> get_IsConnected(This,pbIsConnected) ) 

#define INetworkConnection_GetConnectivity(This,pConnectivity)	\
    ( (This)->lpVtbl -> GetConnectivity(This,pConnectivity) ) 

#define INetworkConnection_GetConnectionId(This,pgdConnectionId)	\
    ( (This)->lpVtbl -> GetConnectionId(This,pgdConnectionId) ) 

#define INetworkConnection_GetAdapterId(This,pgdAdapterId)	\
    ( (This)->lpVtbl -> GetAdapterId(This,pgdAdapterId) ) 

#define INetworkConnection_GetDomainType(This,pDomainType)	\
    ( (This)->lpVtbl -> GetDomainType(This,pDomainType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetworkConnection_INTERFACE_DEFINED__ */


#ifndef __IEnumNetworkConnections_INTERFACE_DEFINED__
#define __IEnumNetworkConnections_INTERFACE_DEFINED__

/* interface IEnumNetworkConnections */
/* [dual][unique][oleautomation][object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumNetworkConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCB00006-570F-4A9B-8D69-199FDBA5723B")
    IEnumNetworkConnections : public IDispatch
    {
    public:
        virtual /* [restricted][hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppEnumVar) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) INetworkConnection **rgelt,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworkConnections **ppEnumNetwork) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetworkConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumNetworkConnections * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumNetworkConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumNetworkConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IEnumNetworkConnections * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IEnumNetworkConnections * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IEnumNetworkConnections * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEnumNetworkConnections * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [restricted][hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IEnumNetworkConnections * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **ppEnumVar);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumNetworkConnections * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) INetworkConnection **rgelt,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumNetworkConnections * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumNetworkConnections * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumNetworkConnections * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumNetworkConnections **ppEnumNetwork);
        
        END_INTERFACE
    } IEnumNetworkConnectionsVtbl;

    interface IEnumNetworkConnections
    {
        CONST_VTBL struct IEnumNetworkConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetworkConnections_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumNetworkConnections_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumNetworkConnections_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumNetworkConnections_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IEnumNetworkConnections_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IEnumNetworkConnections_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IEnumNetworkConnections_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IEnumNetworkConnections_get__NewEnum(This,ppEnumVar)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppEnumVar) ) 

#define IEnumNetworkConnections_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumNetworkConnections_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumNetworkConnections_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumNetworkConnections_Clone(This,ppEnumNetwork)	\
    ( (This)->lpVtbl -> Clone(This,ppEnumNetwork) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumNetworkConnections_INTERFACE_DEFINED__ */


#ifndef __INetworkConnectionEvents_INTERFACE_DEFINED__
#define __INetworkConnectionEvents_INTERFACE_DEFINED__

/* interface INetworkConnectionEvents */
/* [unique][object][helpstring][uuid] */ 

typedef 
enum NLM_CONNECTION_PROPERTY_CHANGE
    {	NLM_CONNECTION_PROPERTY_CHANGE_AUTHENTICATION	= 0x1
    } 	NLM_CONNECTION_PROPERTY_CHANGE;


EXTERN_C const IID IID_INetworkConnectionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCB00007-570F-4A9B-8D69-199FDBA5723B")
    INetworkConnectionEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NetworkConnectionConnectivityChanged( 
            /* [in] */ GUID connectionId,
            /* [in] */ NLM_CONNECTIVITY newConnectivity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NetworkConnectionPropertyChanged( 
            /* [in] */ GUID connectionId,
            /* [in] */ NLM_CONNECTION_PROPERTY_CHANGE flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetworkConnectionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetworkConnectionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetworkConnectionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetworkConnectionEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *NetworkConnectionConnectivityChanged )( 
            __RPC__in INetworkConnectionEvents * This,
            /* [in] */ GUID connectionId,
            /* [in] */ NLM_CONNECTIVITY newConnectivity);
        
        HRESULT ( STDMETHODCALLTYPE *NetworkConnectionPropertyChanged )( 
            __RPC__in INetworkConnectionEvents * This,
            /* [in] */ GUID connectionId,
            /* [in] */ NLM_CONNECTION_PROPERTY_CHANGE flags);
        
        END_INTERFACE
    } INetworkConnectionEventsVtbl;

    interface INetworkConnectionEvents
    {
        CONST_VTBL struct INetworkConnectionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetworkConnectionEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetworkConnectionEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetworkConnectionEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetworkConnectionEvents_NetworkConnectionConnectivityChanged(This,connectionId,newConnectivity)	\
    ( (This)->lpVtbl -> NetworkConnectionConnectivityChanged(This,connectionId,newConnectivity) ) 

#define INetworkConnectionEvents_NetworkConnectionPropertyChanged(This,connectionId,flags)	\
    ( (This)->lpVtbl -> NetworkConnectionPropertyChanged(This,connectionId,flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetworkConnectionEvents_INTERFACE_DEFINED__ */



#ifndef __NETWORKLIST_LIBRARY_DEFINED__
#define __NETWORKLIST_LIBRARY_DEFINED__

/* library NETWORKLIST */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_NETWORKLIST;

EXTERN_C const CLSID CLSID_NetworkListManager;

#ifdef __cplusplus

class DECLSPEC_UUID("DCB00C01-570F-4A9B-8D69-199FDBA5723B")
NetworkListManager;
#endif
#endif /* __NETWORKLIST_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\netioapi.h ===
/*++

Module Name:

    netioapi.h

Abstract:

    This module contains definitions for version agnostic IP helper APIs.


Environment:

    User mode or kernel mode.

    In user mode this file should be included from iphlpapi.h,
    after including the following headers:

    #include <ws2def.h> 
    #include <ws2ipdef.h>

    In kernel mode the following files should be included.
    
    #include <ntddk.h>

    For all APIs, the caller IRQL should be less than DISPATCH_LEVEL.

Notes:

    Please follow these notes to maintain consistency within this API set,
    as well as across the legacy IP helper API:
    
    1. Express objects and functions in terms of MIB operations if possible.
       E.g. MIB_UNICASTIPADDRESS_ROW structure is associated with the 
       GetUnicastIpAddress() function.

    2. Use the NETIO/RTL coding convention for naming structures and functions.
       When modifying a structure with a legacy IP helper API counterpart,
       try to maintain the same name (without abbreviations).
       The hungarian convention must not be used and, for structure fields,
       the structure name need not prefix the field.

    3. For versioning a new structure or API,
       append a version number to the constructs.

    4. The functions in this file are grouped by the object they operate upon.
       Within the group, they are sorted alphabetically.

--*/

#ifndef _NETIOAPI_H_
#define _NETIOAPI_H_
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// General types.
//

//
// Nameless structure/union.
//
#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4214)

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

#ifdef __IPHLPAPI_H__

//
// User Mode.  This file should be included from iphlpapi.h
// User should include ws2ipdef.h to use these APIs.
//

#define NETIO_STATUS DWORD
#define NETIO_SUCCESS(x) ((x) == NO_ERROR)
#define NETIOAPI_API_ WINAPI

#else

//
// Kernel Mode.
//

#include <ws2def.h>
#include <ws2ipdef.h>
#include <ifdef.h>
#include <nldef.h>

#define NETIO_STATUS NTSTATUS
#define NETIO_SUCCESS(x) NT_SUCCESS(x)
#define NETIOAPI_API_ NTAPI

#endif

#define NETIOAPI_API NETIO_STATUS NETIOAPI_API_

typedef enum _MIB_NOTIFICATION_TYPE {
    //
    // ParameterChange.
    //
    MibParameterNotification,
    //
    // Addition.
    //
    MibAddInstance,
    //
    // Deletion.
    //
    MibDeleteInstance,
    //
    // Initial notification.
    // 
    MibInitialNotification,
} MIB_NOTIFICATION_TYPE, *PMIB_NOTIFICATION_TYPE;

//
// Interface management routines.
//

//
// The MIB structure for Interface management routines.
//

#ifdef _WS2IPDEF_ 
#include <ntddndis.h>

typedef struct _MIB_IF_ROW2 {
    //
    // Key structure.  Sorted by preference.
    //
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex; 

    //
    // Read-Only fields.
    //
    GUID InterfaceGuid;
    WCHAR Alias[IF_MAX_STRING_SIZE + 1]; 
    WCHAR Description[IF_MAX_STRING_SIZE + 1];
    ULONG PhysicalAddressLength;
    UCHAR PhysicalAddress[IF_MAX_PHYS_ADDRESS_LENGTH];
    UCHAR PermanentPhysicalAddress[IF_MAX_PHYS_ADDRESS_LENGTH];    

    ULONG Mtu;
    IFTYPE Type;                // Interface Type.
    TUNNEL_TYPE TunnelType;     // Tunnel Type, if Type = IF_TUNNEL.
    NDIS_MEDIUM MediaType; 
    NDIS_PHYSICAL_MEDIUM PhysicalMediumType; 
    NET_IF_ACCESS_TYPE AccessType;
    NET_IF_DIRECTION_TYPE DirectionType;
    struct {
        BOOLEAN HardwareInterface : 1;
        BOOLEAN FilterInterface : 1;
        BOOLEAN ConnectorPresent : 1;
        BOOLEAN NotAuthenticated : 1;
        BOOLEAN NotMediaConnected : 1;
        BOOLEAN Paused : 1;
        BOOLEAN LowPower : 1;
        BOOLEAN EndPointInterface : 1;
    } InterfaceAndOperStatusFlags;
    
    IF_OPER_STATUS OperStatus;  
    NET_IF_ADMIN_STATUS AdminStatus;
    NET_IF_MEDIA_CONNECT_STATE MediaConnectState;
    NET_IF_NETWORK_GUID NetworkGuid;
    NET_IF_CONNECTION_TYPE ConnectionType; 

    //
    // Statistics.
    //
    ULONG64 TransmitLinkSpeed;
    ULONG64 ReceiveLinkSpeed;

    ULONG64 InOctets;
    ULONG64 InUcastPkts;
    ULONG64 InNUcastPkts;
    ULONG64 InDiscards;
    ULONG64 InErrors;
    ULONG64 InUnknownProtos;
    ULONG64 InUcastOctets;      
    ULONG64 InMulticastOctets;  
    ULONG64 InBroadcastOctets; 
    ULONG64 OutOctets;
    ULONG64 OutUcastPkts;
    ULONG64 OutNUcastPkts;
    ULONG64 OutDiscards;
    ULONG64 OutErrors;
    ULONG64 OutUcastOctets;     
    ULONG64 OutMulticastOctets; 
    ULONG64 OutBroadcastOctets;   
    ULONG64 OutQLen; 
} MIB_IF_ROW2, *PMIB_IF_ROW2;

typedef struct _MIB_IF_TABLE2 {
    ULONG NumEntries;
    MIB_IF_ROW2 Table[ANY_SIZE];
} MIB_IF_TABLE2, *PMIB_IF_TABLE2;

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIfEntry2(
    __inout PMIB_IF_ROW2 Row
    );
/*++

Routine Description:

    Retrieves information for the specified interface on the local computer. 

Arguments:

    Row - Supplies a MIB_IF_ROW2 structure with either the Luid or Index
        initialized to that of the interface for which to retrieve 
        information.      
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1.  At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIfTable2(
    __deref_out PMIB_IF_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the MIB-II interface table. 

Arguments:

    Table - Returns the table of interfaces in a MIB_IFTABLE2 structure.
        Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/

typedef enum _MIB_IF_TABLE_LEVEL {
    MibIfTableNormal,
    MibIfTableRaw
} MIB_IF_TABLE_LEVEL, *PMIB_IF_TABLE_LEVEL;

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIfTable2Ex(
    __in MIB_IF_TABLE_LEVEL Level,
    __deref_out PMIB_IF_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the MIB-II interface table. 

Arguments:

    Table - Returns the table of interfaces in a MIB_IFTABLE2 structure.
        Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/

//
// IpInterface management routines.
//

//
// The MIB structure for Network layer Interface management routines.
//
typedef struct _MIB_IPINTERFACE_ROW {
    //
    // Key Structure;
    //
    ADDRESS_FAMILY Family;
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;

    //
    // Read-Write fields.
    //

    //
    // Fields currently not exposed.
    //
    ULONG MaxReassemblySize;
    ULONG64 InterfaceIdentifier;
    ULONG MinRouterAdvertisementInterval;
    ULONG MaxRouterAdvertisementInterval;

    //
    // Fileds currently exposed.
    //       
    BOOLEAN AdvertisingEnabled;
    BOOLEAN ForwardingEnabled;
    BOOLEAN WeakHostSend;
    BOOLEAN WeakHostReceive;
    BOOLEAN UseAutomaticMetric;
    BOOLEAN UseNeighborUnreachabilityDetection;   
    BOOLEAN ManagedAddressConfigurationSupported;
    BOOLEAN OtherStatefulConfigurationSupported;
    BOOLEAN AdvertiseDefaultRoute;
    
    NL_ROUTER_DISCOVERY_BEHAVIOR RouterDiscoveryBehavior;
    ULONG DadTransmits;         // DupAddrDetectTransmits in RFC 2462.    
    ULONG BaseReachableTime;
    ULONG RetransmitTime;
    ULONG PathMtuDiscoveryTimeout; // Path MTU discovery timeout (in ms).
    
    NL_LINK_LOCAL_ADDRESS_BEHAVIOR LinkLocalAddressBehavior;
    ULONG LinkLocalAddressTimeout; // In ms.
    ULONG ZoneIndices[ScopeLevelCount]; // Zone part of a SCOPE_ID.
    ULONG SitePrefixLength;
    ULONG Metric;
    ULONG NlMtu;    

    //
    // Read Only fields.
    //
    BOOLEAN Connected;
    BOOLEAN SupportsWakeUpPatterns;   
    BOOLEAN SupportsNeighborDiscovery;
    BOOLEAN SupportsRouterDiscovery;
    
    ULONG ReachableTime;

    NL_INTERFACE_OFFLOAD_ROD TransmitOffload;
    NL_INTERFACE_OFFLOAD_ROD ReceiveOffload; 

    //
    // Disables using default route on the interface. This flag
    // can be used by VPN clients to restrict Split tunnelling.
    //
    BOOLEAN DisableDefaultRoutes;
} MIB_IPINTERFACE_ROW, *PMIB_IPINTERFACE_ROW;

typedef struct _MIB_IPINTERFACE_TABLE {
    ULONG NumEntries;
    MIB_IPINTERFACE_ROW Table[ANY_SIZE];
} MIB_IPINTERFACE_TABLE, *PMIB_IPINTERFACE_TABLE;

typedef struct _MIB_IFSTACK_ROW {
    NET_IFINDEX HigherLayerInterfaceIndex;
    NET_IFINDEX LowerLayerInterfaceIndex;
} MIB_IFSTACK_ROW, *PMIB_IFSTACK_ROW;

typedef struct _MIB_INVERTEDIFSTACK_ROW {
    NET_IFINDEX LowerLayerInterfaceIndex;
    NET_IFINDEX HigherLayerInterfaceIndex;
} MIB_INVERTEDIFSTACK_ROW, *PMIB_INVERTEDIFSTACK_ROW;

typedef struct _MIB_IFSTACK_TABLE {
    ULONG NumEntries;
    MIB_IFSTACK_ROW Table[ANY_SIZE];
} MIB_IFSTACK_TABLE, *PMIB_IFSTACK_TABLE;

typedef struct _MIB_INVERTEDIFSTACK_TABLE {
    ULONG NumEntries;
    MIB_INVERTEDIFSTACK_ROW Table[ANY_SIZE];
} MIB_INVERTEDIFSTACK_TABLE, *PMIB_INVERTEDIFSTACK_TABLE;

typedef
VOID
(NETIOAPI_API_ *PIPINTERFACE_CHANGE_CALLBACK) (
    __in PVOID CallerContext,
    __in PMIB_IPINTERFACE_ROW Row OPTIONAL,
    __in MIB_NOTIFICATION_TYPE NotificationType
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIfStackTable(
    __deref_out PMIB_IFSTACK_TABLE *Table
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetInvertedIfStackTable(
    __deref_out PMIB_INVERTEDIFSTACK_TABLE *Table
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIpInterfaceEntry(
    __inout PMIB_IPINTERFACE_ROW Row
    );
/*++

Routine Description:

    Retrieves IP information for the specified interface on the local computer.
    
Arguments:

    Row - Supplies a MIB_IPINTERFACE_ROW structure with either the Luid or
        Index initialized to that of the interface for which to retrieve 
        information. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. Family: it must be either AF_INET or AF_INET6
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIpInterfaceTable(
    __in ADDRESS_FAMILY Family,
    __deref_out PMIB_IPINTERFACE_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the network-layer interface table. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 MIB entries.

        AF_INET6: Only returns IPv6 MIB entries.

        AF_UNSPEC: Returns both IPv4 and IPv6 MIB entries.

    Table - Returns the table of interfaces in a MIB_IPINTERFACE_TABLE
        structure.  Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.

--*/

VOID
__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API_
InitializeIpInterfaceEntry(
    __inout PMIB_IPINTERFACE_ROW Row
    );
/*++

Routine Description:

    Initialize the MIB_IPINTERFACE_ROW entry for use in SetIpInterfaceRow.

Arguments:

    Row - Returns an initialized MIB_IPINTERFACE_ROW structure. 

Return Value:

    None. 

Notes:

    InitializeIpInterfaceEntry must be used to initialize the fields of
    MIB_IPINTERFACE_ROW with default values.  The caller can then update the
    fields it wishes to modify and invoke SetIpInterfaceEntry.
        
--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
NotifyIpInterfaceChange(
    __in ADDRESS_FAMILY Family,
    __in PIPINTERFACE_CHANGE_CALLBACK Callback,
    __in PVOID CallerContext,    
    __in BOOLEAN InitialNotification,
    __inout OUT HANDLE *NotificationHandle
    );
/*++

Routine Description:

    Register for notification for IP interface changes.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only register for IPv4 change notifications.

        AF_INET6: Only register for IPv6 change notifications.

        AF_UNSPEC: Register for both IPv4 and IPv6 change notifications.

    Callback - Supplies a callback function.  This function will be invoked
        when an interface notification is received.

    CallerContext - Provides the user specific caller context.  This context 
        will be supplied to the callback function.

    InitialNotification - Supplies a boolean to indicate whether an 
        initialization notification should be provided. 

    NotificationHandle - Returns a handle to the notification registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    1. Invokation of the callback function is serialized.

    2. Use CancelMibChangeNotify2 to deregister for change notifications.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
SetIpInterfaceEntry(
    __inout PMIB_IPINTERFACE_ROW Row
    );
/*++

Routine Description:

    Set the properties of an IP interface. 

Arguments:

    Row - Supplies a MIB_IPINTERFACE_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeIpInterfaceEntry must be used to initialize the fields of
    MIB_IPINTERFACE_ROW with default values.  The caller can then update the
    fields it wishes to modify and invoke SetIpInterfaceEntry.

    On input, the following key fields of Row must be initialized after
    invoking InitializeIpInterfaceEntry:
    1. Family: To AF_INET or AF_INET6.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/


//
// Unicast address management routines.
//

//
// The structure for unicast IP Address management.
//
typedef struct _MIB_UNICASTIPADDRESS_ROW {
    //
    // Key Structure.
    //
    SOCKADDR_INET Address;
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;

    // 
    // Read-Write Fileds.
    //
    NL_PREFIX_ORIGIN PrefixOrigin;
    NL_SUFFIX_ORIGIN SuffixOrigin;    
    ULONG ValidLifetime;
    ULONG PreferredLifetime;
    UINT8 OnLinkPrefixLength;
    BOOLEAN SkipAsSource;

    //
    // Read-Only Fields.
    //
    NL_DAD_STATE DadState;
    SCOPE_ID ScopeId;
    LARGE_INTEGER CreationTimeStamp;    
} MIB_UNICASTIPADDRESS_ROW, *PMIB_UNICASTIPADDRESS_ROW;

typedef struct _MIB_UNICASTIPADDRESS_TABLE {
    ULONG NumEntries;
    MIB_UNICASTIPADDRESS_ROW Table[ANY_SIZE];
} MIB_UNICASTIPADDRESS_TABLE, *PMIB_UNICASTIPADDRESS_TABLE;

typedef
VOID
(NETIOAPI_API_ *PUNICAST_IPADDRESS_CHANGE_CALLBACK) (
    __in PVOID CallerContext,
    __in_opt PMIB_UNICASTIPADDRESS_ROW Row,
    __in MIB_NOTIFICATION_TYPE NotificationType
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)    
NETIOAPI_API
CreateUnicastIpAddressEntry(
    __in CONST MIB_UNICASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Create a unicast IP address entry on the local computer. 

Arguments:

    Row - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeUnicastIpAddressEntry must be used to initialize the fields of
    MIB_UNICASTIPADDRESS_ROW with default values.  The caller can then update
    the fields it wishes to modify and invoke CreateIpInterfaceEntry.

    On input, the following key fields of Row must be initialized after
    invoking InitializeUnicastIpAddressEntry:
    1. Address to a valid IPv4 or IPv6 unicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
DeleteUnicastIpAddressEntry(
    __in CONST MIB_UNICASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Delete a unicast IP address entry on the local computer. 

Arguments:

    Row - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:
    1. Address to a valid IPv4 or IPv6 unicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetUnicastIpAddressEntry(
    __inout PMIB_UNICASTIPADDRESS_ROW Row
    );
/*++

Routine Description:

    Retrieves information for the specified unicast IP address entry on the 
        local computer. 

Arguments:

    Address - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. Address to a valid IPv4 or IPv6 unicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetUnicastIpAddressTable(
    __in ADDRESS_FAMILY Family,
    __deref_out PMIB_UNICASTIPADDRESS_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the unicast IP address table on a local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 unicast addresses.

        AF_INET6: Only returns IPv6 unicast addresses.

        AF_UNSPEC: Returns both IPv4 and IPv6 unicast addresses.

    Table - Returns the table of unicast IP addresses in a
        MIB_UNICASTIPADDRESS_TABLE Structure.  Use FreeMibTable to free this
        buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.

--*/

VOID
__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API_
InitializeUnicastIpAddressEntry(
    __out PMIB_UNICASTIPADDRESS_ROW Row
    );
/*++

Routine Description:

    Initialize the MIB_UNICASTIPADDRESS_ROW entry for use in 
    CreateUnicastIpAddressEntry and SetUnicastIpAddressEntry.

Arguments:

    Address - Returns an initialized MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    None. 

Notes:

    InitializeUnicastIpAddressEntry must be used to initialize the fields of
    MIB_UNICASTIPADDRESS_ROW with default values.  The caller can then update
    the fields it wishes to modify and invoke CreateUnicastIpAddressEntry or
    SetUnicastIpAddressEntry.
        
--*/


__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
NotifyUnicastIpAddressChange(
    __in ADDRESS_FAMILY Family,
    __in PUNICAST_IPADDRESS_CHANGE_CALLBACK Callback,
    __in PVOID CallerContext,    
    __in BOOLEAN InitialNotification,
    __inout HANDLE *NotificationHandle
    );
/*++

Routine Description:

    Register for notification for unicast IP address changes.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only register for IPv4 change notifications.

        AF_INET6: Only register for IPv6 change notifications.

        AF_UNSPEC: Register for both IPv4 and IPv6 change notifications.

    Callback - Supplies a callback function.  This function will be invoked
        when an unicast IP address notification is received.

    CallerContext - Provides the user specific caller context.  This context 
        will be supplied to the callback function.

    InitialNotification - Supplies a boolean to indicate whether an 
        initialization notification should be provided. 

    NotificationHandle - Returns a handle to the notification registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    1. Invokation of the callback function is serialized.

    2. Use CancelMibChangeNotify2 to deregister for change notifications.

--*/

typedef
VOID
(NETIOAPI_API_ *PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK) (
    __in PVOID CallerContext,
    __in PMIB_UNICASTIPADDRESS_TABLE AddressTable
    );
    
__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
NotifyStableUnicastIpAddressTable(
    __in ADDRESS_FAMILY Family,
    __deref_out PMIB_UNICASTIPADDRESS_TABLE* Table,
    __in PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK CallerCallback,
    __in PVOID CallerContext,
    __inout HANDLE *NotificationHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
SetUnicastIpAddressEntry(
    __in CONST MIB_UNICASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Set the properties of an unicast IP address. 

Arguments:

    Address - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeUnicastIpAddressEntry must be used to initialize the fields of
    MIB_UNICASTIPADDRESS_ROW with default values.  The caller can then update
    the fields it wishes to modify and invoke SetUnicastIpAddressEntry.

    On input, the following key fields of Row must be initialized after
    invoking InitializeUnicastIpAddressEntry:    
    1. Address to a valid IPv4 or IPv6 unicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.     

--*/

//
// Anycast address management routines.
//

typedef struct _MIB_ANYCASTIPADDRESS_ROW {
    //
    // Key Structure.
    //
    SOCKADDR_INET Address;
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;

    //
    // Read-Only Fields.
    //
    SCOPE_ID ScopeId;
} MIB_ANYCASTIPADDRESS_ROW, *PMIB_ANYCASTIPADDRESS_ROW; 

typedef struct _MIB_ANYCASTIPADDRESS_TABLE {
    ULONG NumEntries;
    MIB_ANYCASTIPADDRESS_ROW Table[ANY_SIZE];
} MIB_ANYCASTIPADDRESS_TABLE, *PMIB_ANYCASTIPADDRESS_TABLE;
    
__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
CreateAnycastIpAddressEntry(
    __in CONST MIB_ANYCASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Create an anycast IP address entry on the local computer. 

Arguments:

    Address - Supplies a MIB_ANYCASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:
    1. Address to a valid IPv4 or IPv6 anycast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
DeleteAnycastIpAddressEntry(
    __in CONST MIB_ANYCASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Delete an anycast IP address entry on the local computer. 

Arguments:

    Address - Supplies a MIB_ANYCASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:
    1. Address to a valid IPv4 or IPv6 anycast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetAnycastIpAddressEntry(
    __inout PMIB_ANYCASTIPADDRESS_ROW Row
    );
/*++

Routine Description:

    Retrieves information for the specified anycast IP address entry on the 
    local computer. 

Arguments:

    Address - Supplies a MIB_ANYCASTIPADDRESS_ROW structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:    
    1. Address to a valid IPv4 or IPv6 anycast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetAnycastIpAddressTable(
    __in ADDRESS_FAMILY Family,
    __deref_out PMIB_ANYCASTIPADDRESS_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the anycast IP address table. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 anycast addresses.

        AF_INET6: Only returns IPv6 anycast addresses.

        AF_UNSPEC: Returns both IPv4 and IPv6 anycast addresses.

    Table - Returns the table of anycast IP addresses in a
        MIB_ANYCASTIPADDRESS_TABLE Structure.  Use FreeMibTable to free this
        buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/


//
// Multicast address management routines.
//
typedef struct _MIB_MULTICASTIPADDRESS_ROW {
    //
    // Key Structure.
    //
    SOCKADDR_INET Address;
    NET_IFINDEX InterfaceIndex;
    NET_LUID InterfaceLuid;

    //
    // Read-Only Fields.
    //
    SCOPE_ID ScopeId;
} MIB_MULTICASTIPADDRESS_ROW, *PMIB_MULTICASTIPADDRESS_ROW;

typedef struct _MIB_MULTICASTIPADDRESS_TABLE {
    ULONG NumEntries;
    MIB_MULTICASTIPADDRESS_ROW Table[ANY_SIZE];
} MIB_MULTICASTIPADDRESS_TABLE, *PMIB_MULTICASTIPADDRESS_TABLE;    

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetMulticastIpAddressEntry(
    __inout PMIB_MULTICASTIPADDRESS_ROW Row
    );
/*++

Routine Description:

    Retrieves information for the specified mulitcast IP address entry on the 
    local computer. 

Arguments:

    Row - Supplies a MIB_MULTICASTIPADDRESS_ROW structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized.
    1. Address to a valid IPv4 or IPv6 multicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetMulticastIpAddressTable(
    __in ADDRESS_FAMILY Family,
    __deref_out PMIB_MULTICASTIPADDRESS_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the multicast IP address table on the local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 multicast addresses.

        AF_INET6: Only returns IPv6 multicast addresses.

        AF_UNSPEC: Returns both IPv4 and IPv6 multicast addresses.

    Table - Returns the table of multicast IP addresses in a 
        MIB_MULTICASTIPADDRESS_TABLE Structure.  Use FreeMibTable to free this 
        buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/

//
// Route management routines.
//

typedef struct _IP_ADDRESS_PREFIX {
    SOCKADDR_INET Prefix;
    UINT8 PrefixLength;
} IP_ADDRESS_PREFIX, *PIP_ADDRESS_PREFIX;    

typedef struct _MIB_IPFORWARD_ROW2 {
    //
    // Key Structure.
    //
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;
    IP_ADDRESS_PREFIX DestinationPrefix;
    SOCKADDR_INET NextHop;

    //
    // Read-Write Fields.
    //
    UCHAR SitePrefixLength;
    ULONG ValidLifetime;
    ULONG PreferredLifetime;
    ULONG Metric;
    NL_ROUTE_PROTOCOL Protocol;
    
    BOOLEAN Loopback;
    BOOLEAN AutoconfigureAddress;
    BOOLEAN Publish;
    BOOLEAN Immortal;

    //
    // Read-Only Fields.
    //
    ULONG Age;
    NL_ROUTE_ORIGIN Origin;
} MIB_IPFORWARD_ROW2, *PMIB_IPFORWARD_ROW2;  

typedef struct _MIB_IPFORWARD_TABLE2 {
    ULONG NumEntries;
    MIB_IPFORWARD_ROW2 Table[ANY_SIZE];
} MIB_IPFORWARD_TABLE2, *PMIB_IPFORWARD_TABLE2;

typedef
VOID
(NETIOAPI_API_ *PIPFORWARD_CHANGE_CALLBACK) (
    __in PVOID CallerContext,
    __in_opt PMIB_IPFORWARD_ROW2 Row,
    __in MIB_NOTIFICATION_TYPE NotificationType
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
CreateIpForwardEntry2(
    __in CONST MIB_IPFORWARD_ROW2 *Row
    );
/*++

Routine Description:

    Create a route on the local computer. 

Arguments:

    Row - Supplies a MIB_IPFORWARD_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeIpForwardEntry must be used to initialize the fields of
    MIB_IPFORWARD_ROW2 with default values.  The caller can then update the
    fields it wishes to modify and invoke CreateIpForwardEntry2.

    On input, the following key fields of Row must be initialized after
    invoking InitializeIpForwardEntry:    
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. DestinationPrefix.
    3. NextHop.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
DeleteIpForwardEntry2(
    __in CONST MIB_IPFORWARD_ROW2 *Row
    );
/*++

Routine Description:

    Delete a route on the local computer. 

Arguments:

    Row - Supplies a MIB_IPFORWARD_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:        
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. DestinationPrefix.
    3. NextHop.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetBestRoute2(
    __in_opt NET_LUID *InterfaceLuid,
    __in NET_IFINDEX InterfaceIndex,
    __in_opt CONST SOCKADDR_INET *SourceAddress,
    __in CONST SOCKADDR_INET *DestinationAddress,
    __in ULONG AddressSortOptions,
    __out PMIB_IPFORWARD_ROW2 BestRoute,
    __out SOCKADDR_INET *BestSourceAddress
    );
/*++

Routine Description:

    Retrieve the best route between source and destination address on a local
        computer. 

Arguments:

    InterfaceLuid - Supplies Luid to specify an interface.

    InterfaceIndex - Supplies Index to specify an interface.

    SourceAddress - Supplies source address.

    DestinationAddress - Supplies destination address.

    AddressSortOptions - Supplies AddressSortOptions.

    BestRoute - Returns the MIB structure that holds the best route.
    
    BestSourceAddress - Returns the source address of the best route. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following parameters must be supplied:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. SourceAddress.
    3. DestinationAddress.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIpForwardEntry2(
    __inout PMIB_IPFORWARD_ROW2 Row
    );
/*++

Routine Description:

    Retrieves information for the specified route entry on the local computer. 

Arguments:

    Route - Supplies a MIB_IPFORWARD_ROW2 structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:    
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. DestinationPrefix and NextHop can be specified.

    On output, the remaining fields of Row are filled in.

    If one or more routes matches the specified criteria,
    this API matches the first entry.
    
--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIpForwardTable2(
    __in ADDRESS_FAMILY Family,
    __deref_out PMIB_IPFORWARD_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the route table on a local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 route entries.

        AF_INET6: Only returns IPv6 route entries.

        AF_UNSPEC: Returns both IPv4 and IPv6 route entries.

    Table - Returns the table of routes in a MIB_IPFORWARD_TABLE2 Structure. 
        Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/

VOID
__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API_
InitializeIpForwardEntry(
    __out PMIB_IPFORWARD_ROW2 Row
    );
/*++

Routine Description:

    Initialize the MIB_IPFORWARD_ROW2 entry for use in SetIpForwardEntry2.

Arguments:

    Row - Returns an initialized PMIB_IPFORWARD_ROW2 structure. 

Return Value:

    None. 

Notes:

    InitializeIpForwardEntry must be used to initialize the fields of 
        MIB_IPFORWARD_ROW2 with default values.  The caller can then update the
        fields it wishes to modify and invoke SetIpForwardEntry2.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
NotifyRouteChange2(
    __in ADDRESS_FAMILY AddressFamily,
    __in PIPFORWARD_CHANGE_CALLBACK Callback,
    __in PVOID CallerContext,    
    __in BOOLEAN InitialNotification,
    __inout HANDLE *NotificationHandle
    );
/*++

Routine Description:

    Register for notification for route changes.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only register for IPv4 route change notifications.

        AF_INET6: Only register for IPv6 route change notifications.

        AF_UNSPEC: Register for both IPv4 and IPv6 route change notifications.

    Callback - Supplies a callback function. This function will be invoked when
        an unicast IP address notification is received.

    CallerContext - Provides the user specific caller context. This context 
        will be supplied to the callback function.

    InitialNotification - Supplies a boolean to indicate whether an 
        initialization notification should be provided. 

    NotificationHandle - Returns a handle to the notification registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    1. Invokation of the callback function is serialized.

    2. Use CancelMibChangeNotify2 to deregister for change notifications.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
SetIpForwardEntry2(
    __in CONST MIB_IPFORWARD_ROW2 *Route
    );
/*++

Routine Description:

    Set the properties of a route entry. 

Arguments:

    Route - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeIpForwardEntry must be used to initialize the fields of
    MIB_IPFORWARD_ROW2 with default values.  The caller can then update the
    fields it wishes to modify and invoke SetIpForwardEntry2.

    On input, the following key fields of Row must be initialized after
    invoking InitializeIpForwardEntry:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.  
    2. DestinationPrefix.
    3. NextHop.

--*/

//
// Path management routines.
//

typedef struct _MIB_IPPATH_ROW {
    //
    // Key.
    //
    
    SOCKADDR_INET Source;    
    SOCKADDR_INET Destination;
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;  

    //
    // RO.
    //
    //
    // The current next hop.  This can change over the lifetime of a path. 
    //
    SOCKADDR_INET CurrentNextHop;

    //
    // MTU of path to destination. Includes the IP header length.
    //
    ULONG PathMtu;

    //
    // Estimated mean RTT.
    //
    ULONG RttMean;

    //
    // Mean deviation of RTT.
    //
    ULONG RttDeviation;
    union {
        ULONG LastReachable;    // Milliseconds.
        ULONG LastUnreachable;  // Milliseconds.
    };
    BOOLEAN IsReachable;

    //
    // Estimated speed.
    //
    ULONG64 LinkTransmitSpeed;
    ULONG64 LinkReceiveSpeed;

} MIB_IPPATH_ROW, *PMIB_IPPATH_ROW;

typedef struct _MIB_IPPATH_TABLE {
    ULONG NumEntries;
    MIB_IPPATH_ROW Table[ANY_SIZE];
} MIB_IPPATH_TABLE, *PMIB_IPPATH_TABLE;


__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
FlushIpPathTable(
    __in ADDRESS_FAMILY Family
    );
/*++

Routine Description:

    Flush the IP Path table on the local computer.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only flush the IPv4 path table.

        AF_INET6: Only flush the IPv6 path table.

        AF_UNSPEC: Flush both IPv4 and IPv6 path table.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/
    
__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIpPathEntry(
    __inout PMIB_IPPATH_ROW Row
    );
/*++

Routine Description:

    Retrieves information for the specified path entry on the local computer. 

Arguments:

    Row - Supplies a MIB_IPPATH_ROW structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:    
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Source.
    3. Destination.

    On output, the remaining fields of Row are filled in.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIpPathTable(
    __in ADDRESS_FAMILY Family,
    __deref_out PMIB_IPPATH_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the path table on a local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 paths.

        AF_INET6: Only returns IPv6 paths.

        AF_UNSPEC: Returns both IPv4 and IPv6 paths.

    Table - Returns the table of paths in a MIB_IPPATH_TABLE
        structure.  Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.

--*/

//
// ARP and IPv6 Neighbor management routines.
//

typedef struct _MIB_IPNET_ROW2 {
    //
    // Key Struture.
    //
    SOCKADDR_INET Address;
    NET_IFINDEX InterfaceIndex;
    NET_LUID InterfaceLuid;

    //
    // Read-Write.
    //
    UCHAR PhysicalAddress[IF_MAX_PHYS_ADDRESS_LENGTH];

    //
    // Read-Only.
    //
    ULONG PhysicalAddressLength;
    NL_NEIGHBOR_STATE State;

    union {
        struct {
            BOOLEAN IsRouter : 1;
            BOOLEAN IsUnreachable : 1;
        };
        UCHAR Flags;
    };

    union {
        ULONG LastReachable;
        ULONG LastUnreachable;
    } ReachabilityTime;
} MIB_IPNET_ROW2, *PMIB_IPNET_ROW2;

typedef struct _MIB_IPNET_TABLE2 {
    ULONG NumEntries;
    MIB_IPNET_ROW2 Table[ANY_SIZE];
} MIB_IPNET_TABLE2, *PMIB_IPNET_TABLE2;

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
CreateIpNetEntry2(
    __in CONST MIB_IPNET_ROW2 *Row
    );
/*++

Routine Description:

    Create a neighbor entry on the local computer. 

Arguments:

    Row - Supplies a MIB_IPNET_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:        
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. Address.
    3. PhysicalAddress.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
DeleteIpNetEntry2(
    __in CONST MIB_IPNET_ROW2 *Row
    );
/*++

Routine Description:

    Delete a neighbor entry on the local computer. 

Arguments:

    Row - Supplies a MIB_IPNET_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. Address.

--*/


__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
FlushIpNetTable2(
    __in ADDRESS_FAMILY Family,
    __in NET_IFINDEX InterfaceIndex
    );
/*++

Routine Description:

    Flush the neighbor entry table on the local computer. 

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only flush the IPv4 neighbor table.

        AF_INET6: Only flush the IPv6 neighbor table.

        AF_UNSPEC: Flush both IPv4 and IPv6 neighbor table.

    InterfaceIndex - Supplies the Interface index.  If the index is specified,
        flush the neighbor entries on a specific interface, otherwise flush the
        neighbor entries on all the interfaces.
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/


__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIpNetEntry2(
    __inout PMIB_IPNET_ROW2 Row
    );
/*++

Routine Description:

    Retrieves information for the specified neighbor entry on the local
    computer.

Arguments:

    Row - Supplies a MIB_IPNET_ROW2 structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Address.

    On output, the remaining fields of Row are filled in.

--*/
    
__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetIpNetTable2(
    __in ADDRESS_FAMILY Family,
    __deref_out PMIB_IPNET_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the neighbor table on the local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 neighbor entries.

        AF_INET6: Only returns IPv6 neighbor entries.

        AF_UNSPEC: Returns both IPv4 and IPv6 neighbor entries.

    Table - Returns the table of neighbor entries in a MIB_IPNET_TABLE2
        structure.  Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.
    
--*/    

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ResolveIpNetEntry2(
    __inout PMIB_IPNET_ROW2 Row,
    __in_opt CONST SOCKADDR_INET *SourceAddress
    );
/*++

Routine Description:

    Resolve the physical address of a specific neighbor. 

Arguments:

    NetEntry - Supplies a MIB_IPNET_ROW2 structure.

    SourceAddress - Supplies the source address.
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    This API flushes any existing neighbor entry and resolves the MAC address
    by sending ARP requests (IPv4) or Neighbor Solicitation (IPv6).
    If source address is not provided, the API will automatically select the
    best interface to send the request on.

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Address.

    On output, the remaining fields of Row are filled in.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
SetIpNetEntry2(
    __in PMIB_IPNET_ROW2 Row
    );
/*++

Routine Description:

    Set the physical address of a neighbor entry. 

Arguments:

    NetEntry - Supplies a MIB_IPNET_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Address.
    3. PhysicalAddress.     

--*/ 

//
// Teredo APIs.
//
#define MIB_INVALID_TEREDO_PORT_NUMBER 0

typedef
VOID
(NETIOAPI_API_ *PTEREDO_PORT_CHANGE_CALLBACK) (
    __in PVOID CallerContext,
    __in USHORT Port,
    __inout MIB_NOTIFICATION_TYPE NotificationType
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
NotifyTeredoPortChange(
    __in PTEREDO_PORT_CHANGE_CALLBACK Callback,
    __in PVOID CallerContext,    
    __in BOOLEAN InitialNotification,
    __inout HANDLE *NotificationHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
GetTeredoPort(
    __out USHORT *Port
    );
/*++

Routine Description:

    Get the Teredo client port. 

Arguments:

    Port - returns the Teredo port. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure.      

--*/ 

#ifndef TEREDO_API_NO_DEPRECATE

//
// Deprecate all of the unsafe functions to generate compiletime errors. 
// Use the following routines instead : FwpmSystemPortsGet
//

#pragma deprecated(NotifyTeredoPortChange)
#pragma deprecated(GetTeredoPort)

#endif // TEREDO_API_NO_DEPRECATE

//
// Generic (not IP-specific) interface definitions.
//

__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API
CancelMibChangeNotify2(
    __in HANDLE NotificationHandle
    );
/*++

Routine Description:

    Deregister for change notifications.

Arguments:

    NotificationHandle - Supplies the handle returned from a notification 
        registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    Blocks until all callback have returned.
    
--*/

VOID
NETIOAPI_API_
FreeMibTable(
    __in PVOID Memory
    ); 
/*++

Routine Description:

    Free the buffer allocated by Get*Table APIs.

Arguments:

    Memory - Supplies the buffer to free.

Return Value:

    None.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
CreateSortedAddressPairs(
    __in_opt const PSOCKADDR_IN6 SourceAddressList,
    __in ULONG SourceAddressCount,
    __in const PSOCKADDR_IN6 DestinationAddressList,
    __in ULONG DestinationAddressCount,
    __in ULONG AddressSortOptions,
    __in PSOCKADDR_IN6_PAIR *SortedAddressPairList,
    __out ULONG *SortedAddressPairCount
    );
/*++

Routine Description:

    Given a list of source and destination addresses, returns a list of
    pairs of addresses in sorted order.  The list is sorted by which address
    pair is best suited for communication between two peers.

    The list of source addresses is optional, in which case the function
    automatically uses all the host machine's local addresses.

Arguments:

    SourceAddressList - Supplies list of potential source addresses.
        If NULL the routine automatically uses all local addresses.
        IPv4 addresses can be specified in IPv4-mapped format.
        Reserved for future use.  Must be NULL.
    
    SourceAddressCount - Supplies the number of addresses in the 
        SourceAddressList.
        Reserved for future use.  Must be 0.        

    DestinationAddressList - Supplies list of potential destination addresses.
        IPv4 addresses can be specified in IPv4-mapped format.

    DestinationAddressCount -  Supplies the number of addresses in the 
        DestinationAddressList.

    AddressSortOptions - Reserved for future use.  Must be 0.

    SortedAddressPairList - Returns a sorted list of pairs of addresses
        in prefered order of communication.  The list must be freed with a
        single call to NetioFreeMemory.

    SortedAddressPairCount - Returns the number of address pairs in
        SortedAddressPairList.

Return Value:

    ERROR_SUCCESS on success.  WIN32 error code on error.

--*/

#endif //_WS2IPDEF_

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceNameToLuidA(
    __in CONST CHAR *InterfaceName,
    __out NET_LUID *InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Name to Luid.

Arguments:

    InterfaceName - Supplies the interface name to be converted.

    InterfaceLuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceNameToLuidW(
    __in CONST WCHAR *InterfaceName,
    __out NET_LUID *InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Name to Luid.

Arguments:

    InterfaceName - Supplies the interface name to be converted.

    InterfaceLuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceLuidToNameA(
    __in CONST NET_LUID *InterfaceLuid,
    __out_ecount(Length) PSTR InterfaceName,
    __in SIZE_T Length
    );
/*++

Routine Description:

    Convert an Interface Luid to Name.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceName - Returns the interface name.

    Lenght - Supplies the length of the InterfaceName buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceLuidToNameW(
    __in CONST NET_LUID *InterfaceLuid,
    __out_ecount(Length) PWSTR InterfaceName,
    __in SIZE_T Length
    );
/*++

Routine Description:

    Convert an Interface Luid to Name.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceName - Returns the interface name.

    Length - Supplies the length of the InterfaceName buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceLuidToIndex(
    __in CONST NET_LUID *InterfaceLuid,
    __out PNET_IFINDEX InterfaceIndex
    );
/*++

Routine Description:

    Convert an Interface Luid to Index.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceName - Returns the interface Index.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceIndexToLuid(
    __in NET_IFINDEX InterfaceIndex,
    __out PNET_LUID InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Index to Luid.

Arguments:

    InterfaceName - Supplies the interface Index to be converted.

    InterfaceLuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceLuidToAlias(
    __in CONST NET_LUID *InterfaceLuid,
    __out_ecount(Length) PWSTR InterfaceAlias,
    __in SIZE_T Length
    );
/*++

Routine Description:

    Convert an Interface Luid to Alias.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceAlias - Returns the interface Alias.

    Length - Supplies the length of InterfaceAlias buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceAliasToLuid(
    IN CONST WCHAR *InterfaceAlias,
    OUT PNET_LUID InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Alias to Luid.

Arguments:

    InterfaceAlias - Supplies the null terminated interface Alias.

    InterfaceLuid - Returns the interface Luid. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceLuidToGuid(
    __in CONST NET_LUID *InterfaceLuid,
    __out GUID *InterfaceGuid
    );
/*++

Routine Description:

    Convert an Interface Luid to Guid.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceGuid - Returns the interface Guid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
__success(return==STATUS_SUCCESS)
NETIOAPI_API
ConvertInterfaceGuidToLuid(
    __in CONST GUID *InterfaceGuid,
    __out PNET_LUID InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Luid to Guid.

Arguments:

    InterfaceGuid - Supplies the interface Guid to be converted.

    InterfaceGuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

#define IF_NAMESIZE NDIS_IF_MAX_STRING_SIZE

NET_IFINDEX
__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API_
if_nametoindex(
    __in PCSTR InterfaceName
    );
/*++

Routine Description:

    Convert an Interface name to Index.

Arguments:

    InterfaceName - Supplies the null terminated interface name to convert.

Return Value:

    Interface index on success, 0 otherwise.

--*/
    
PCHAR
__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API_
if_indextoname(
    __in NET_IFINDEX InterfaceIndex,
    __out_ecount(IF_NAMESIZE) PCHAR InterfaceName
    );
/*++

Routine Description:

    Convert an Interface index to Name.

Arguments:

    InterfaceIndex - Supplies the Interface index to convert.

    InterfaceName - Returns the null terminated interface name.

Return Value:

    Interface name on success, NULL otherwise.

Notes:

    The length of InterfaceName buffer must be equal to or greater than 
        IF_NAMESIZE.

--*/

NET_IF_COMPARTMENT_ID
__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API_
GetCurrentThreadCompartmentId(
    VOID
    );
/*++

Routine Description:

    Get the compartment ID of current thread.

Arguments:

    None.

Return Value:

    The compartment ID of current thread.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API
SetCurrentThreadCompartmentId(
    __in NET_IF_COMPARTMENT_ID CompartmentId
    );
/*++

Routine Description:

    Set the compartment ID of current thread.

Arguments:

    CompartmentId - Supplies the compartment ID to be set.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 


--*/

NET_IF_COMPARTMENT_ID
__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API_
GetSessionCompartmentId(
    __in ULONG SessionId
    );
/*++

Routine Description:

    Get the compartment ID of the session.

Arguments:

    SessionId - Supplies the session ID.

Return Value:

    The compartment ID of the session.

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API
SetSessionCompartmentId(
    __in ULONG SessionId,
    __in NET_IF_COMPARTMENT_ID CompartmentId
    );
/*++

Routine Description:

    Set the compartment ID of the session.

Arguments:

    SessionId - Supplies the session ID.

    CompartmentId - Supplies the compartment ID to be set.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API
GetNetworkInformation(
    __in CONST NET_IF_NETWORK_GUID *NetworkGuid,
    __out PNET_IF_COMPARTMENT_ID CompartmentId,
    __out PULONG SiteId,
    __out_ecount(Length) PWCHAR NetworkName,
    __in ULONG Length
    );
/*++

Routine Description:

    Get the network information.

Arguments:

    NetworkGuid - Supplies the Network GUID.

    CompartmentId - Returns the compartment ID.

    SiteId - Returns Site ID.

    NetowrkName - Returns the network name.

    Length - Supplies the length of NetworkName buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/
    
__drv_maxIRQL(PASSIVE_LEVEL)
NETIOAPI_API
SetNetworkInformation(
    __in CONST NET_IF_NETWORK_GUID *NetworkGuid,
    __in NET_IF_COMPARTMENT_ID CompartmentId,
    __in CONST WCHAR *NetworkName
    );
/*++

Routine Description:

    Set the Network Information.

Arguments:

    NetworkGuid - Supplies the session ID.

    CompartmentId - Supplies the compartment ID to be set.

    NetworkName - Supplies the Network name to be set.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

#pragma warning(pop) 

NETIOAPI_API
ConvertLengthToIpv4Mask(
    __in ULONG MaskLength,
    __out PULONG Mask
    );
/*++

Routine Description:

    Converts a prefixLength to a subnet mask.

Arguments:

    MaskLength - Prefix Length.

    Mask - Mask generated.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/   

NETIOAPI_API
ConvertIpv4MaskToLength(
    __in ULONG Mask,
    __out PUINT8 MaskLength
    );
/*++

Routine Description:

    Converts a subnet mask to a prefix length.

Arguments:

    Mask - Subnet mask to use.

    MaskLength - Prefix length computed.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/   

//
//4201.
//
#ifdef __cplusplus
}
#endif

#endif // _NETIOAPI_H_.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\netfw.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for netfw.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netfw_h__
#define __netfw_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INetFwRemoteAdminSettings_FWD_DEFINED__
#define __INetFwRemoteAdminSettings_FWD_DEFINED__
typedef interface INetFwRemoteAdminSettings INetFwRemoteAdminSettings;
#endif 	/* __INetFwRemoteAdminSettings_FWD_DEFINED__ */


#ifndef __INetFwIcmpSettings_FWD_DEFINED__
#define __INetFwIcmpSettings_FWD_DEFINED__
typedef interface INetFwIcmpSettings INetFwIcmpSettings;
#endif 	/* __INetFwIcmpSettings_FWD_DEFINED__ */


#ifndef __INetFwOpenPort_FWD_DEFINED__
#define __INetFwOpenPort_FWD_DEFINED__
typedef interface INetFwOpenPort INetFwOpenPort;
#endif 	/* __INetFwOpenPort_FWD_DEFINED__ */


#ifndef __INetFwOpenPorts_FWD_DEFINED__
#define __INetFwOpenPorts_FWD_DEFINED__
typedef interface INetFwOpenPorts INetFwOpenPorts;
#endif 	/* __INetFwOpenPorts_FWD_DEFINED__ */


#ifndef __INetFwService_FWD_DEFINED__
#define __INetFwService_FWD_DEFINED__
typedef interface INetFwService INetFwService;
#endif 	/* __INetFwService_FWD_DEFINED__ */


#ifndef __INetFwServices_FWD_DEFINED__
#define __INetFwServices_FWD_DEFINED__
typedef interface INetFwServices INetFwServices;
#endif 	/* __INetFwServices_FWD_DEFINED__ */


#ifndef __INetFwAuthorizedApplication_FWD_DEFINED__
#define __INetFwAuthorizedApplication_FWD_DEFINED__
typedef interface INetFwAuthorizedApplication INetFwAuthorizedApplication;
#endif 	/* __INetFwAuthorizedApplication_FWD_DEFINED__ */


#ifndef __INetFwAuthorizedApplications_FWD_DEFINED__
#define __INetFwAuthorizedApplications_FWD_DEFINED__
typedef interface INetFwAuthorizedApplications INetFwAuthorizedApplications;
#endif 	/* __INetFwAuthorizedApplications_FWD_DEFINED__ */


#ifndef __INetFwRule_FWD_DEFINED__
#define __INetFwRule_FWD_DEFINED__
typedef interface INetFwRule INetFwRule;
#endif 	/* __INetFwRule_FWD_DEFINED__ */


#ifndef __INetFwRule2_FWD_DEFINED__
#define __INetFwRule2_FWD_DEFINED__
typedef interface INetFwRule2 INetFwRule2;
#endif 	/* __INetFwRule2_FWD_DEFINED__ */


#ifndef __INetFwRules_FWD_DEFINED__
#define __INetFwRules_FWD_DEFINED__
typedef interface INetFwRules INetFwRules;
#endif 	/* __INetFwRules_FWD_DEFINED__ */


#ifndef __INetFwServiceRestriction_FWD_DEFINED__
#define __INetFwServiceRestriction_FWD_DEFINED__
typedef interface INetFwServiceRestriction INetFwServiceRestriction;
#endif 	/* __INetFwServiceRestriction_FWD_DEFINED__ */


#ifndef __INetFwProfile_FWD_DEFINED__
#define __INetFwProfile_FWD_DEFINED__
typedef interface INetFwProfile INetFwProfile;
#endif 	/* __INetFwProfile_FWD_DEFINED__ */


#ifndef __INetFwPolicy_FWD_DEFINED__
#define __INetFwPolicy_FWD_DEFINED__
typedef interface INetFwPolicy INetFwPolicy;
#endif 	/* __INetFwPolicy_FWD_DEFINED__ */


#ifndef __INetFwPolicy2_FWD_DEFINED__
#define __INetFwPolicy2_FWD_DEFINED__
typedef interface INetFwPolicy2 INetFwPolicy2;
#endif 	/* __INetFwPolicy2_FWD_DEFINED__ */


#ifndef __INetFwMgr_FWD_DEFINED__
#define __INetFwMgr_FWD_DEFINED__
typedef interface INetFwMgr INetFwMgr;
#endif 	/* __INetFwMgr_FWD_DEFINED__ */


#ifndef __INetFwProduct_FWD_DEFINED__
#define __INetFwProduct_FWD_DEFINED__
typedef interface INetFwProduct INetFwProduct;
#endif 	/* __INetFwProduct_FWD_DEFINED__ */


#ifndef __INetFwProducts_FWD_DEFINED__
#define __INetFwProducts_FWD_DEFINED__
typedef interface INetFwProducts INetFwProducts;
#endif 	/* __INetFwProducts_FWD_DEFINED__ */


#ifndef __INetFwRemoteAdminSettings_FWD_DEFINED__
#define __INetFwRemoteAdminSettings_FWD_DEFINED__
typedef interface INetFwRemoteAdminSettings INetFwRemoteAdminSettings;
#endif 	/* __INetFwRemoteAdminSettings_FWD_DEFINED__ */


#ifndef __INetFwIcmpSettings_FWD_DEFINED__
#define __INetFwIcmpSettings_FWD_DEFINED__
typedef interface INetFwIcmpSettings INetFwIcmpSettings;
#endif 	/* __INetFwIcmpSettings_FWD_DEFINED__ */


#ifndef __INetFwOpenPort_FWD_DEFINED__
#define __INetFwOpenPort_FWD_DEFINED__
typedef interface INetFwOpenPort INetFwOpenPort;
#endif 	/* __INetFwOpenPort_FWD_DEFINED__ */


#ifndef __INetFwOpenPorts_FWD_DEFINED__
#define __INetFwOpenPorts_FWD_DEFINED__
typedef interface INetFwOpenPorts INetFwOpenPorts;
#endif 	/* __INetFwOpenPorts_FWD_DEFINED__ */


#ifndef __INetFwService_FWD_DEFINED__
#define __INetFwService_FWD_DEFINED__
typedef interface INetFwService INetFwService;
#endif 	/* __INetFwService_FWD_DEFINED__ */


#ifndef __INetFwServices_FWD_DEFINED__
#define __INetFwServices_FWD_DEFINED__
typedef interface INetFwServices INetFwServices;
#endif 	/* __INetFwServices_FWD_DEFINED__ */


#ifndef __INetFwAuthorizedApplication_FWD_DEFINED__
#define __INetFwAuthorizedApplication_FWD_DEFINED__
typedef interface INetFwAuthorizedApplication INetFwAuthorizedApplication;
#endif 	/* __INetFwAuthorizedApplication_FWD_DEFINED__ */


#ifndef __INetFwAuthorizedApplications_FWD_DEFINED__
#define __INetFwAuthorizedApplications_FWD_DEFINED__
typedef interface INetFwAuthorizedApplications INetFwAuthorizedApplications;
#endif 	/* __INetFwAuthorizedApplications_FWD_DEFINED__ */


#ifndef __INetFwServiceRestriction_FWD_DEFINED__
#define __INetFwServiceRestriction_FWD_DEFINED__
typedef interface INetFwServiceRestriction INetFwServiceRestriction;
#endif 	/* __INetFwServiceRestriction_FWD_DEFINED__ */


#ifndef __INetFwRule_FWD_DEFINED__
#define __INetFwRule_FWD_DEFINED__
typedef interface INetFwRule INetFwRule;
#endif 	/* __INetFwRule_FWD_DEFINED__ */


#ifndef __INetFwRules_FWD_DEFINED__
#define __INetFwRules_FWD_DEFINED__
typedef interface INetFwRules INetFwRules;
#endif 	/* __INetFwRules_FWD_DEFINED__ */


#ifndef __INetFwProfile_FWD_DEFINED__
#define __INetFwProfile_FWD_DEFINED__
typedef interface INetFwProfile INetFwProfile;
#endif 	/* __INetFwProfile_FWD_DEFINED__ */


#ifndef __INetFwPolicy_FWD_DEFINED__
#define __INetFwPolicy_FWD_DEFINED__
typedef interface INetFwPolicy INetFwPolicy;
#endif 	/* __INetFwPolicy_FWD_DEFINED__ */


#ifndef __INetFwPolicy2_FWD_DEFINED__
#define __INetFwPolicy2_FWD_DEFINED__
typedef interface INetFwPolicy2 INetFwPolicy2;
#endif 	/* __INetFwPolicy2_FWD_DEFINED__ */


#ifndef __INetFwMgr_FWD_DEFINED__
#define __INetFwMgr_FWD_DEFINED__
typedef interface INetFwMgr INetFwMgr;
#endif 	/* __INetFwMgr_FWD_DEFINED__ */


#ifndef __INetFwProduct_FWD_DEFINED__
#define __INetFwProduct_FWD_DEFINED__
typedef interface INetFwProduct INetFwProduct;
#endif 	/* __INetFwProduct_FWD_DEFINED__ */


#ifndef __INetFwProducts_FWD_DEFINED__
#define __INetFwProducts_FWD_DEFINED__
typedef interface INetFwProducts INetFwProducts;
#endif 	/* __INetFwProducts_FWD_DEFINED__ */


#ifndef __NetFwRule_FWD_DEFINED__
#define __NetFwRule_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwRule NetFwRule;
#else
typedef struct NetFwRule NetFwRule;
#endif /* __cplusplus */

#endif 	/* __NetFwRule_FWD_DEFINED__ */


#ifndef __NetFwOpenPort_FWD_DEFINED__
#define __NetFwOpenPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwOpenPort NetFwOpenPort;
#else
typedef struct NetFwOpenPort NetFwOpenPort;
#endif /* __cplusplus */

#endif 	/* __NetFwOpenPort_FWD_DEFINED__ */


#ifndef __NetFwAuthorizedApplication_FWD_DEFINED__
#define __NetFwAuthorizedApplication_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwAuthorizedApplication NetFwAuthorizedApplication;
#else
typedef struct NetFwAuthorizedApplication NetFwAuthorizedApplication;
#endif /* __cplusplus */

#endif 	/* __NetFwAuthorizedApplication_FWD_DEFINED__ */


#ifndef __NetFwPolicy2_FWD_DEFINED__
#define __NetFwPolicy2_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwPolicy2 NetFwPolicy2;
#else
typedef struct NetFwPolicy2 NetFwPolicy2;
#endif /* __cplusplus */

#endif 	/* __NetFwPolicy2_FWD_DEFINED__ */


#ifndef __NetFwProduct_FWD_DEFINED__
#define __NetFwProduct_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwProduct NetFwProduct;
#else
typedef struct NetFwProduct NetFwProduct;
#endif /* __cplusplus */

#endif 	/* __NetFwProduct_FWD_DEFINED__ */


#ifndef __NetFwProducts_FWD_DEFINED__
#define __NetFwProducts_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwProducts NetFwProducts;
#else
typedef struct NetFwProducts NetFwProducts;
#endif /* __cplusplus */

#endif 	/* __NetFwProducts_FWD_DEFINED__ */


#ifndef __NetFwMgr_FWD_DEFINED__
#define __NetFwMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwMgr NetFwMgr;
#else
typedef struct NetFwMgr NetFwMgr;
#endif /* __cplusplus */

#endif 	/* __NetFwMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "icftypes.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __INetFwRemoteAdminSettings_INTERFACE_DEFINED__
#define __INetFwRemoteAdminSettings_INTERFACE_DEFINED__

/* interface INetFwRemoteAdminSettings */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwRemoteAdminSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4BECDDF-6F73-4A83-B832-9C66874CD20E")
    INetFwRemoteAdminSettings : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IpVersion( 
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IpVersion( 
            /* [in] */ NET_FW_IP_VERSION ipVersion) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Scope( 
            /* [in] */ NET_FW_SCOPE scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ __RPC__in BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwRemoteAdminSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwRemoteAdminSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwRemoteAdminSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwRemoteAdminSettings * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IpVersion )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IpVersion )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scope )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [in] */ NET_FW_SCOPE scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [in] */ __RPC__in BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in INetFwRemoteAdminSettings * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        END_INTERFACE
    } INetFwRemoteAdminSettingsVtbl;

    interface INetFwRemoteAdminSettings
    {
        CONST_VTBL struct INetFwRemoteAdminSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwRemoteAdminSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwRemoteAdminSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwRemoteAdminSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwRemoteAdminSettings_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwRemoteAdminSettings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwRemoteAdminSettings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwRemoteAdminSettings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwRemoteAdminSettings_get_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> get_IpVersion(This,ipVersion) ) 

#define INetFwRemoteAdminSettings_put_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> put_IpVersion(This,ipVersion) ) 

#define INetFwRemoteAdminSettings_get_Scope(This,scope)	\
    ( (This)->lpVtbl -> get_Scope(This,scope) ) 

#define INetFwRemoteAdminSettings_put_Scope(This,scope)	\
    ( (This)->lpVtbl -> put_Scope(This,scope) ) 

#define INetFwRemoteAdminSettings_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRemoteAdminSettings_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRemoteAdminSettings_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwRemoteAdminSettings_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwRemoteAdminSettings_INTERFACE_DEFINED__ */


#ifndef __INetFwIcmpSettings_INTERFACE_DEFINED__
#define __INetFwIcmpSettings_INTERFACE_DEFINED__

/* interface INetFwIcmpSettings */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwIcmpSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6207B2E-7CDD-426A-951E-5E1CBC5AFEAD")
    INetFwIcmpSettings : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundDestinationUnreachable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundDestinationUnreachable( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowRedirect( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowRedirect( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowInboundEchoRequest( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowInboundEchoRequest( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundTimeExceeded( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundTimeExceeded( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundParameterProblem( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundParameterProblem( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundSourceQuench( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundSourceQuench( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowInboundRouterRequest( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowInboundRouterRequest( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowInboundTimestampRequest( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowInboundTimestampRequest( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowInboundMaskRequest( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowInboundMaskRequest( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundPacketTooBig( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundPacketTooBig( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwIcmpSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwIcmpSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwIcmpSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwIcmpSettings * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundDestinationUnreachable )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundDestinationUnreachable )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowRedirect )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowRedirect )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowInboundEchoRequest )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowInboundEchoRequest )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundTimeExceeded )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundTimeExceeded )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundParameterProblem )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundParameterProblem )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundSourceQuench )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundSourceQuench )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowInboundRouterRequest )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowInboundRouterRequest )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowInboundTimestampRequest )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowInboundTimestampRequest )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowInboundMaskRequest )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowInboundMaskRequest )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundPacketTooBig )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundPacketTooBig )( 
            __RPC__in INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        END_INTERFACE
    } INetFwIcmpSettingsVtbl;

    interface INetFwIcmpSettings
    {
        CONST_VTBL struct INetFwIcmpSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwIcmpSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwIcmpSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwIcmpSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwIcmpSettings_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwIcmpSettings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwIcmpSettings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwIcmpSettings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwIcmpSettings_get_AllowOutboundDestinationUnreachable(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundDestinationUnreachable(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundDestinationUnreachable(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundDestinationUnreachable(This,allow) ) 

#define INetFwIcmpSettings_get_AllowRedirect(This,allow)	\
    ( (This)->lpVtbl -> get_AllowRedirect(This,allow) ) 

#define INetFwIcmpSettings_put_AllowRedirect(This,allow)	\
    ( (This)->lpVtbl -> put_AllowRedirect(This,allow) ) 

#define INetFwIcmpSettings_get_AllowInboundEchoRequest(This,allow)	\
    ( (This)->lpVtbl -> get_AllowInboundEchoRequest(This,allow) ) 

#define INetFwIcmpSettings_put_AllowInboundEchoRequest(This,allow)	\
    ( (This)->lpVtbl -> put_AllowInboundEchoRequest(This,allow) ) 

#define INetFwIcmpSettings_get_AllowOutboundTimeExceeded(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundTimeExceeded(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundTimeExceeded(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundTimeExceeded(This,allow) ) 

#define INetFwIcmpSettings_get_AllowOutboundParameterProblem(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundParameterProblem(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundParameterProblem(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundParameterProblem(This,allow) ) 

#define INetFwIcmpSettings_get_AllowOutboundSourceQuench(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundSourceQuench(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundSourceQuench(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundSourceQuench(This,allow) ) 

#define INetFwIcmpSettings_get_AllowInboundRouterRequest(This,allow)	\
    ( (This)->lpVtbl -> get_AllowInboundRouterRequest(This,allow) ) 

#define INetFwIcmpSettings_put_AllowInboundRouterRequest(This,allow)	\
    ( (This)->lpVtbl -> put_AllowInboundRouterRequest(This,allow) ) 

#define INetFwIcmpSettings_get_AllowInboundTimestampRequest(This,allow)	\
    ( (This)->lpVtbl -> get_AllowInboundTimestampRequest(This,allow) ) 

#define INetFwIcmpSettings_put_AllowInboundTimestampRequest(This,allow)	\
    ( (This)->lpVtbl -> put_AllowInboundTimestampRequest(This,allow) ) 

#define INetFwIcmpSettings_get_AllowInboundMaskRequest(This,allow)	\
    ( (This)->lpVtbl -> get_AllowInboundMaskRequest(This,allow) ) 

#define INetFwIcmpSettings_put_AllowInboundMaskRequest(This,allow)	\
    ( (This)->lpVtbl -> put_AllowInboundMaskRequest(This,allow) ) 

#define INetFwIcmpSettings_get_AllowOutboundPacketTooBig(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundPacketTooBig(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundPacketTooBig(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundPacketTooBig(This,allow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwIcmpSettings_INTERFACE_DEFINED__ */


#ifndef __INetFwOpenPort_INTERFACE_DEFINED__
#define __INetFwOpenPort_INTERFACE_DEFINED__

/* interface INetFwOpenPort */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwOpenPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E0483BA0-47FF-4D9C-A6D6-7741D0B195F7")
    INetFwOpenPort : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IpVersion( 
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IpVersion( 
            /* [in] */ NET_FW_IP_VERSION ipVersion) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ __RPC__out NET_FW_IP_PROTOCOL *ipProtocol) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Protocol( 
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ __RPC__out LONG *portNumber) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Port( 
            /* [in] */ LONG portNumber) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Scope( 
            /* [in] */ NET_FW_SCOPE scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ __RPC__in BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BuiltIn( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *builtIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwOpenPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwOpenPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwOpenPort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwOpenPort * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwOpenPort * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in INetFwOpenPort * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IpVersion )( 
            __RPC__in INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IpVersion )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            __RPC__in INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_PROTOCOL *ipProtocol);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Protocol )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            __RPC__in INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out LONG *portNumber);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Port )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ LONG portNumber);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            __RPC__in INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scope )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ NET_FW_SCOPE scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            __RPC__in INetFwOpenPort * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ __RPC__in BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in INetFwOpenPort * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BuiltIn )( 
            __RPC__in INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *builtIn);
        
        END_INTERFACE
    } INetFwOpenPortVtbl;

    interface INetFwOpenPort
    {
        CONST_VTBL struct INetFwOpenPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwOpenPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwOpenPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwOpenPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwOpenPort_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwOpenPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwOpenPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwOpenPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwOpenPort_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define INetFwOpenPort_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define INetFwOpenPort_get_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> get_IpVersion(This,ipVersion) ) 

#define INetFwOpenPort_put_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> put_IpVersion(This,ipVersion) ) 

#define INetFwOpenPort_get_Protocol(This,ipProtocol)	\
    ( (This)->lpVtbl -> get_Protocol(This,ipProtocol) ) 

#define INetFwOpenPort_put_Protocol(This,ipProtocol)	\
    ( (This)->lpVtbl -> put_Protocol(This,ipProtocol) ) 

#define INetFwOpenPort_get_Port(This,portNumber)	\
    ( (This)->lpVtbl -> get_Port(This,portNumber) ) 

#define INetFwOpenPort_put_Port(This,portNumber)	\
    ( (This)->lpVtbl -> put_Port(This,portNumber) ) 

#define INetFwOpenPort_get_Scope(This,scope)	\
    ( (This)->lpVtbl -> get_Scope(This,scope) ) 

#define INetFwOpenPort_put_Scope(This,scope)	\
    ( (This)->lpVtbl -> put_Scope(This,scope) ) 

#define INetFwOpenPort_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwOpenPort_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwOpenPort_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwOpenPort_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#define INetFwOpenPort_get_BuiltIn(This,builtIn)	\
    ( (This)->lpVtbl -> get_BuiltIn(This,builtIn) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwOpenPort_INTERFACE_DEFINED__ */


#ifndef __INetFwOpenPorts_INTERFACE_DEFINED__
#define __INetFwOpenPorts_INTERFACE_DEFINED__

/* interface INetFwOpenPorts */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwOpenPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E9D7FA-E07E-430A-B19A-090CE82D92E2")
    INetFwOpenPorts : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt INetFwOpenPort *port) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ LONG portNumber,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ LONG portNumber,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol,
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPort **openPort) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwOpenPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwOpenPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwOpenPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwOpenPorts * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwOpenPorts * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwOpenPorts * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwOpenPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwOpenPorts * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in INetFwOpenPorts * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in INetFwOpenPorts * This,
            /* [in] */ __RPC__in_opt INetFwOpenPort *port);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in INetFwOpenPorts * This,
            /* [in] */ LONG portNumber,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            __RPC__in INetFwOpenPorts * This,
            /* [in] */ LONG portNumber,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol,
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPort **openPort);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in INetFwOpenPorts * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum);
        
        END_INTERFACE
    } INetFwOpenPortsVtbl;

    interface INetFwOpenPorts
    {
        CONST_VTBL struct INetFwOpenPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwOpenPorts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwOpenPorts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwOpenPorts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwOpenPorts_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwOpenPorts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwOpenPorts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwOpenPorts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwOpenPorts_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define INetFwOpenPorts_Add(This,port)	\
    ( (This)->lpVtbl -> Add(This,port) ) 

#define INetFwOpenPorts_Remove(This,portNumber,ipProtocol)	\
    ( (This)->lpVtbl -> Remove(This,portNumber,ipProtocol) ) 

#define INetFwOpenPorts_Item(This,portNumber,ipProtocol,openPort)	\
    ( (This)->lpVtbl -> Item(This,portNumber,ipProtocol,openPort) ) 

#define INetFwOpenPorts_get__NewEnum(This,newEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,newEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwOpenPorts_INTERFACE_DEFINED__ */


#ifndef __INetFwService_INTERFACE_DEFINED__
#define __INetFwService_INTERFACE_DEFINED__

/* interface INetFwService */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79FD57C8-908E-4A36-9888-D5B3F0A444CF")
    INetFwService : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out NET_FW_SERVICE_TYPE *type) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Customized( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *customized) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IpVersion( 
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IpVersion( 
            /* [in] */ NET_FW_IP_VERSION ipVersion) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Scope( 
            /* [in] */ NET_FW_SCOPE scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ __RPC__in BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_GloballyOpenPorts( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPorts **openPorts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwService * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwService * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwService * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in INetFwService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in INetFwService * This,
            /* [retval][out] */ __RPC__out NET_FW_SERVICE_TYPE *type);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Customized )( 
            __RPC__in INetFwService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *customized);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IpVersion )( 
            __RPC__in INetFwService * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IpVersion )( 
            __RPC__in INetFwService * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            __RPC__in INetFwService * This,
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scope )( 
            __RPC__in INetFwService * This,
            /* [in] */ NET_FW_SCOPE scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            __RPC__in INetFwService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            __RPC__in INetFwService * This,
            /* [in] */ __RPC__in BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in INetFwService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in INetFwService * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GloballyOpenPorts )( 
            __RPC__in INetFwService * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPorts **openPorts);
        
        END_INTERFACE
    } INetFwServiceVtbl;

    interface INetFwService
    {
        CONST_VTBL struct INetFwServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwService_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwService_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define INetFwService_get_Type(This,type)	\
    ( (This)->lpVtbl -> get_Type(This,type) ) 

#define INetFwService_get_Customized(This,customized)	\
    ( (This)->lpVtbl -> get_Customized(This,customized) ) 

#define INetFwService_get_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> get_IpVersion(This,ipVersion) ) 

#define INetFwService_put_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> put_IpVersion(This,ipVersion) ) 

#define INetFwService_get_Scope(This,scope)	\
    ( (This)->lpVtbl -> get_Scope(This,scope) ) 

#define INetFwService_put_Scope(This,scope)	\
    ( (This)->lpVtbl -> put_Scope(This,scope) ) 

#define INetFwService_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwService_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwService_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwService_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#define INetFwService_get_GloballyOpenPorts(This,openPorts)	\
    ( (This)->lpVtbl -> get_GloballyOpenPorts(This,openPorts) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwService_INTERFACE_DEFINED__ */


#ifndef __INetFwServices_INTERFACE_DEFINED__
#define __INetFwServices_INTERFACE_DEFINED__

/* interface INetFwServices */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79649BB4-903E-421B-94C9-79848E79F6EE")
    INetFwServices : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ NET_FW_SERVICE_TYPE svcType,
            /* [retval][out] */ __RPC__deref_out_opt INetFwService **service) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwServices * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwServices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwServices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in INetFwServices * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            __RPC__in INetFwServices * This,
            /* [in] */ NET_FW_SERVICE_TYPE svcType,
            /* [retval][out] */ __RPC__deref_out_opt INetFwService **service);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in INetFwServices * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum);
        
        END_INTERFACE
    } INetFwServicesVtbl;

    interface INetFwServices
    {
        CONST_VTBL struct INetFwServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwServices_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwServices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwServices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwServices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwServices_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define INetFwServices_Item(This,svcType,service)	\
    ( (This)->lpVtbl -> Item(This,svcType,service) ) 

#define INetFwServices_get__NewEnum(This,newEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,newEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwServices_INTERFACE_DEFINED__ */


#ifndef __INetFwAuthorizedApplication_INTERFACE_DEFINED__
#define __INetFwAuthorizedApplication_INTERFACE_DEFINED__

/* interface INetFwAuthorizedApplication */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwAuthorizedApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B5E64FFA-C2C5-444E-A301-FB5E00018050")
    INetFwAuthorizedApplication : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ProcessImageFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ProcessImageFileName( 
            /* [in] */ __RPC__in BSTR imageFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IpVersion( 
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IpVersion( 
            /* [in] */ NET_FW_IP_VERSION ipVersion) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Scope( 
            /* [in] */ NET_FW_SCOPE scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ __RPC__in BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwAuthorizedApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwAuthorizedApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwAuthorizedApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessImageFileName )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ProcessImageFileName )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in BSTR imageFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IpVersion )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IpVersion )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scope )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [in] */ NET_FW_SCOPE scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in INetFwAuthorizedApplication * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        END_INTERFACE
    } INetFwAuthorizedApplicationVtbl;

    interface INetFwAuthorizedApplication
    {
        CONST_VTBL struct INetFwAuthorizedApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwAuthorizedApplication_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwAuthorizedApplication_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwAuthorizedApplication_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwAuthorizedApplication_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwAuthorizedApplication_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwAuthorizedApplication_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwAuthorizedApplication_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwAuthorizedApplication_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define INetFwAuthorizedApplication_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define INetFwAuthorizedApplication_get_ProcessImageFileName(This,imageFileName)	\
    ( (This)->lpVtbl -> get_ProcessImageFileName(This,imageFileName) ) 

#define INetFwAuthorizedApplication_put_ProcessImageFileName(This,imageFileName)	\
    ( (This)->lpVtbl -> put_ProcessImageFileName(This,imageFileName) ) 

#define INetFwAuthorizedApplication_get_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> get_IpVersion(This,ipVersion) ) 

#define INetFwAuthorizedApplication_put_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> put_IpVersion(This,ipVersion) ) 

#define INetFwAuthorizedApplication_get_Scope(This,scope)	\
    ( (This)->lpVtbl -> get_Scope(This,scope) ) 

#define INetFwAuthorizedApplication_put_Scope(This,scope)	\
    ( (This)->lpVtbl -> put_Scope(This,scope) ) 

#define INetFwAuthorizedApplication_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwAuthorizedApplication_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwAuthorizedApplication_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwAuthorizedApplication_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwAuthorizedApplication_INTERFACE_DEFINED__ */


#ifndef __INetFwAuthorizedApplications_INTERFACE_DEFINED__
#define __INetFwAuthorizedApplications_INTERFACE_DEFINED__

/* interface INetFwAuthorizedApplications */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwAuthorizedApplications;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("644EFD52-CCF9-486C-97A2-39F352570B30")
    INetFwAuthorizedApplications : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt INetFwAuthorizedApplication *app) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ __RPC__in BSTR imageFileName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ __RPC__in BSTR imageFileName,
            /* [retval][out] */ __RPC__deref_out_opt INetFwAuthorizedApplication **app) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwAuthorizedApplicationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwAuthorizedApplications * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwAuthorizedApplications * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwAuthorizedApplications * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwAuthorizedApplications * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwAuthorizedApplications * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in INetFwAuthorizedApplications * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in_opt INetFwAuthorizedApplication *app);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in BSTR imageFileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            __RPC__in INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in BSTR imageFileName,
            /* [retval][out] */ __RPC__deref_out_opt INetFwAuthorizedApplication **app);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in INetFwAuthorizedApplications * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum);
        
        END_INTERFACE
    } INetFwAuthorizedApplicationsVtbl;

    interface INetFwAuthorizedApplications
    {
        CONST_VTBL struct INetFwAuthorizedApplicationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwAuthorizedApplications_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwAuthorizedApplications_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwAuthorizedApplications_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwAuthorizedApplications_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwAuthorizedApplications_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwAuthorizedApplications_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwAuthorizedApplications_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwAuthorizedApplications_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define INetFwAuthorizedApplications_Add(This,app)	\
    ( (This)->lpVtbl -> Add(This,app) ) 

#define INetFwAuthorizedApplications_Remove(This,imageFileName)	\
    ( (This)->lpVtbl -> Remove(This,imageFileName) ) 

#define INetFwAuthorizedApplications_Item(This,imageFileName,app)	\
    ( (This)->lpVtbl -> Item(This,imageFileName,app) ) 

#define INetFwAuthorizedApplications_get__NewEnum(This,newEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,newEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwAuthorizedApplications_INTERFACE_DEFINED__ */


#ifndef __INetFwRule_INTERFACE_DEFINED__
#define __INetFwRule_INTERFACE_DEFINED__

/* interface INetFwRule */
/* [dual][uuid][object][local] */ 


EXTERN_C const IID IID_INetFwRule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF230D27-BABA-4E42-ACED-F524F22CFCE2")
    INetFwRule : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *desc) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR desc) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ApplicationName( 
            /* [retval][out] */ BSTR *imageFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ApplicationName( 
            /* [in] */ BSTR imageFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceName( 
            /* [retval][out] */ BSTR *serviceName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ServiceName( 
            /* [in] */ BSTR serviceName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ LONG *protocol) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Protocol( 
            /* [in] */ LONG protocol) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LocalPorts( 
            /* [retval][out] */ BSTR *portNumbers) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_LocalPorts( 
            /* [in] */ BSTR portNumbers) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemotePorts( 
            /* [retval][out] */ BSTR *portNumbers) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemotePorts( 
            /* [in] */ BSTR portNumbers) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LocalAddresses( 
            /* [retval][out] */ BSTR *localAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_LocalAddresses( 
            /* [in] */ BSTR localAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IcmpTypesAndCodes( 
            /* [retval][out] */ BSTR *icmpTypesAndCodes) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IcmpTypesAndCodes( 
            /* [in] */ BSTR icmpTypesAndCodes) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ NET_FW_RULE_DIRECTION *dir) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ NET_FW_RULE_DIRECTION dir) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Interfaces( 
            /* [retval][out] */ VARIANT *interfaces) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Interfaces( 
            /* [in] */ VARIANT interfaces) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_InterfaceTypes( 
            /* [retval][out] */ BSTR *interfaceTypes) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_InterfaceTypes( 
            /* [in] */ BSTR interfaceTypes) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Grouping( 
            /* [retval][out] */ BSTR *context) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Grouping( 
            /* [in] */ BSTR context) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Profiles( 
            /* [retval][out] */ long *profileTypesBitmask) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Profiles( 
            /* [in] */ long profileTypesBitmask) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EdgeTraversal( 
            /* [retval][out] */ VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EdgeTraversal( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Action( 
            /* [retval][out] */ NET_FW_ACTION *action) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Action( 
            /* [in] */ NET_FW_ACTION action) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwRuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwRule * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwRule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwRule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwRule * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwRule * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwRule * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwRule * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            INetFwRule * This,
            /* [in] */ BSTR name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *desc);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            INetFwRule * This,
            /* [in] */ BSTR desc);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ApplicationName )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *imageFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ApplicationName )( 
            INetFwRule * This,
            /* [in] */ BSTR imageFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceName )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *serviceName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceName )( 
            INetFwRule * This,
            /* [in] */ BSTR serviceName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            INetFwRule * This,
            /* [retval][out] */ LONG *protocol);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Protocol )( 
            INetFwRule * This,
            /* [in] */ LONG protocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalPorts )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *portNumbers);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LocalPorts )( 
            INetFwRule * This,
            /* [in] */ BSTR portNumbers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemotePorts )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *portNumbers);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemotePorts )( 
            INetFwRule * This,
            /* [in] */ BSTR portNumbers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalAddresses )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *localAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LocalAddresses )( 
            INetFwRule * This,
            /* [in] */ BSTR localAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            INetFwRule * This,
            /* [in] */ BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IcmpTypesAndCodes )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *icmpTypesAndCodes);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IcmpTypesAndCodes )( 
            INetFwRule * This,
            /* [in] */ BSTR icmpTypesAndCodes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            INetFwRule * This,
            /* [retval][out] */ NET_FW_RULE_DIRECTION *dir);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Direction )( 
            INetFwRule * This,
            /* [in] */ NET_FW_RULE_DIRECTION dir);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Interfaces )( 
            INetFwRule * This,
            /* [retval][out] */ VARIANT *interfaces);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Interfaces )( 
            INetFwRule * This,
            /* [in] */ VARIANT interfaces);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InterfaceTypes )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *interfaceTypes);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InterfaceTypes )( 
            INetFwRule * This,
            /* [in] */ BSTR interfaceTypes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            INetFwRule * This,
            /* [retval][out] */ VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            INetFwRule * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Grouping )( 
            INetFwRule * This,
            /* [retval][out] */ BSTR *context);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Grouping )( 
            INetFwRule * This,
            /* [in] */ BSTR context);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Profiles )( 
            INetFwRule * This,
            /* [retval][out] */ long *profileTypesBitmask);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Profiles )( 
            INetFwRule * This,
            /* [in] */ long profileTypesBitmask);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EdgeTraversal )( 
            INetFwRule * This,
            /* [retval][out] */ VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EdgeTraversal )( 
            INetFwRule * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Action )( 
            INetFwRule * This,
            /* [retval][out] */ NET_FW_ACTION *action);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Action )( 
            INetFwRule * This,
            /* [in] */ NET_FW_ACTION action);
        
        END_INTERFACE
    } INetFwRuleVtbl;

    interface INetFwRule
    {
        CONST_VTBL struct INetFwRuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwRule_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwRule_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwRule_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwRule_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwRule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwRule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwRule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwRule_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define INetFwRule_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define INetFwRule_get_Description(This,desc)	\
    ( (This)->lpVtbl -> get_Description(This,desc) ) 

#define INetFwRule_put_Description(This,desc)	\
    ( (This)->lpVtbl -> put_Description(This,desc) ) 

#define INetFwRule_get_ApplicationName(This,imageFileName)	\
    ( (This)->lpVtbl -> get_ApplicationName(This,imageFileName) ) 

#define INetFwRule_put_ApplicationName(This,imageFileName)	\
    ( (This)->lpVtbl -> put_ApplicationName(This,imageFileName) ) 

#define INetFwRule_get_ServiceName(This,serviceName)	\
    ( (This)->lpVtbl -> get_ServiceName(This,serviceName) ) 

#define INetFwRule_put_ServiceName(This,serviceName)	\
    ( (This)->lpVtbl -> put_ServiceName(This,serviceName) ) 

#define INetFwRule_get_Protocol(This,protocol)	\
    ( (This)->lpVtbl -> get_Protocol(This,protocol) ) 

#define INetFwRule_put_Protocol(This,protocol)	\
    ( (This)->lpVtbl -> put_Protocol(This,protocol) ) 

#define INetFwRule_get_LocalPorts(This,portNumbers)	\
    ( (This)->lpVtbl -> get_LocalPorts(This,portNumbers) ) 

#define INetFwRule_put_LocalPorts(This,portNumbers)	\
    ( (This)->lpVtbl -> put_LocalPorts(This,portNumbers) ) 

#define INetFwRule_get_RemotePorts(This,portNumbers)	\
    ( (This)->lpVtbl -> get_RemotePorts(This,portNumbers) ) 

#define INetFwRule_put_RemotePorts(This,portNumbers)	\
    ( (This)->lpVtbl -> put_RemotePorts(This,portNumbers) ) 

#define INetFwRule_get_LocalAddresses(This,localAddrs)	\
    ( (This)->lpVtbl -> get_LocalAddresses(This,localAddrs) ) 

#define INetFwRule_put_LocalAddresses(This,localAddrs)	\
    ( (This)->lpVtbl -> put_LocalAddresses(This,localAddrs) ) 

#define INetFwRule_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRule_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRule_get_IcmpTypesAndCodes(This,icmpTypesAndCodes)	\
    ( (This)->lpVtbl -> get_IcmpTypesAndCodes(This,icmpTypesAndCodes) ) 

#define INetFwRule_put_IcmpTypesAndCodes(This,icmpTypesAndCodes)	\
    ( (This)->lpVtbl -> put_IcmpTypesAndCodes(This,icmpTypesAndCodes) ) 

#define INetFwRule_get_Direction(This,dir)	\
    ( (This)->lpVtbl -> get_Direction(This,dir) ) 

#define INetFwRule_put_Direction(This,dir)	\
    ( (This)->lpVtbl -> put_Direction(This,dir) ) 

#define INetFwRule_get_Interfaces(This,interfaces)	\
    ( (This)->lpVtbl -> get_Interfaces(This,interfaces) ) 

#define INetFwRule_put_Interfaces(This,interfaces)	\
    ( (This)->lpVtbl -> put_Interfaces(This,interfaces) ) 

#define INetFwRule_get_InterfaceTypes(This,interfaceTypes)	\
    ( (This)->lpVtbl -> get_InterfaceTypes(This,interfaceTypes) ) 

#define INetFwRule_put_InterfaceTypes(This,interfaceTypes)	\
    ( (This)->lpVtbl -> put_InterfaceTypes(This,interfaceTypes) ) 

#define INetFwRule_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwRule_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#define INetFwRule_get_Grouping(This,context)	\
    ( (This)->lpVtbl -> get_Grouping(This,context) ) 

#define INetFwRule_put_Grouping(This,context)	\
    ( (This)->lpVtbl -> put_Grouping(This,context) ) 

#define INetFwRule_get_Profiles(This,profileTypesBitmask)	\
    ( (This)->lpVtbl -> get_Profiles(This,profileTypesBitmask) ) 

#define INetFwRule_put_Profiles(This,profileTypesBitmask)	\
    ( (This)->lpVtbl -> put_Profiles(This,profileTypesBitmask) ) 

#define INetFwRule_get_EdgeTraversal(This,enabled)	\
    ( (This)->lpVtbl -> get_EdgeTraversal(This,enabled) ) 

#define INetFwRule_put_EdgeTraversal(This,enabled)	\
    ( (This)->lpVtbl -> put_EdgeTraversal(This,enabled) ) 

#define INetFwRule_get_Action(This,action)	\
    ( (This)->lpVtbl -> get_Action(This,action) ) 

#define INetFwRule_put_Action(This,action)	\
    ( (This)->lpVtbl -> put_Action(This,action) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwRule_INTERFACE_DEFINED__ */


#ifndef __INetFwRule2_INTERFACE_DEFINED__
#define __INetFwRule2_INTERFACE_DEFINED__

/* interface INetFwRule2 */
/* [dual][uuid][object][local] */ 


EXTERN_C const IID IID_INetFwRule2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C27C8DA-189B-4DDE-89F7-8B39A316782C")
    INetFwRule2 : public INetFwRule
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EdgeTraversalOptions( 
            /* [retval][out] */ long *lOptions) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EdgeTraversalOptions( 
            /* [in] */ long lOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwRule2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwRule2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwRule2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwRule2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwRule2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwRule2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwRule2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwRule2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *name);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            INetFwRule2 * This,
            /* [in] */ BSTR name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *desc);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            INetFwRule2 * This,
            /* [in] */ BSTR desc);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ApplicationName )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *imageFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ApplicationName )( 
            INetFwRule2 * This,
            /* [in] */ BSTR imageFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceName )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *serviceName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceName )( 
            INetFwRule2 * This,
            /* [in] */ BSTR serviceName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            INetFwRule2 * This,
            /* [retval][out] */ LONG *protocol);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Protocol )( 
            INetFwRule2 * This,
            /* [in] */ LONG protocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalPorts )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *portNumbers);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LocalPorts )( 
            INetFwRule2 * This,
            /* [in] */ BSTR portNumbers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemotePorts )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *portNumbers);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemotePorts )( 
            INetFwRule2 * This,
            /* [in] */ BSTR portNumbers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalAddresses )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *localAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LocalAddresses )( 
            INetFwRule2 * This,
            /* [in] */ BSTR localAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            INetFwRule2 * This,
            /* [in] */ BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IcmpTypesAndCodes )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *icmpTypesAndCodes);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IcmpTypesAndCodes )( 
            INetFwRule2 * This,
            /* [in] */ BSTR icmpTypesAndCodes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            INetFwRule2 * This,
            /* [retval][out] */ NET_FW_RULE_DIRECTION *dir);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Direction )( 
            INetFwRule2 * This,
            /* [in] */ NET_FW_RULE_DIRECTION dir);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Interfaces )( 
            INetFwRule2 * This,
            /* [retval][out] */ VARIANT *interfaces);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Interfaces )( 
            INetFwRule2 * This,
            /* [in] */ VARIANT interfaces);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InterfaceTypes )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *interfaceTypes);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InterfaceTypes )( 
            INetFwRule2 * This,
            /* [in] */ BSTR interfaceTypes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            INetFwRule2 * This,
            /* [retval][out] */ VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            INetFwRule2 * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Grouping )( 
            INetFwRule2 * This,
            /* [retval][out] */ BSTR *context);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Grouping )( 
            INetFwRule2 * This,
            /* [in] */ BSTR context);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Profiles )( 
            INetFwRule2 * This,
            /* [retval][out] */ long *profileTypesBitmask);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Profiles )( 
            INetFwRule2 * This,
            /* [in] */ long profileTypesBitmask);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EdgeTraversal )( 
            INetFwRule2 * This,
            /* [retval][out] */ VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EdgeTraversal )( 
            INetFwRule2 * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Action )( 
            INetFwRule2 * This,
            /* [retval][out] */ NET_FW_ACTION *action);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Action )( 
            INetFwRule2 * This,
            /* [in] */ NET_FW_ACTION action);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EdgeTraversalOptions )( 
            INetFwRule2 * This,
            /* [retval][out] */ long *lOptions);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EdgeTraversalOptions )( 
            INetFwRule2 * This,
            /* [in] */ long lOptions);
        
        END_INTERFACE
    } INetFwRule2Vtbl;

    interface INetFwRule2
    {
        CONST_VTBL struct INetFwRule2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwRule2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwRule2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwRule2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwRule2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwRule2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwRule2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwRule2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwRule2_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define INetFwRule2_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define INetFwRule2_get_Description(This,desc)	\
    ( (This)->lpVtbl -> get_Description(This,desc) ) 

#define INetFwRule2_put_Description(This,desc)	\
    ( (This)->lpVtbl -> put_Description(This,desc) ) 

#define INetFwRule2_get_ApplicationName(This,imageFileName)	\
    ( (This)->lpVtbl -> get_ApplicationName(This,imageFileName) ) 

#define INetFwRule2_put_ApplicationName(This,imageFileName)	\
    ( (This)->lpVtbl -> put_ApplicationName(This,imageFileName) ) 

#define INetFwRule2_get_ServiceName(This,serviceName)	\
    ( (This)->lpVtbl -> get_ServiceName(This,serviceName) ) 

#define INetFwRule2_put_ServiceName(This,serviceName)	\
    ( (This)->lpVtbl -> put_ServiceName(This,serviceName) ) 

#define INetFwRule2_get_Protocol(This,protocol)	\
    ( (This)->lpVtbl -> get_Protocol(This,protocol) ) 

#define INetFwRule2_put_Protocol(This,protocol)	\
    ( (This)->lpVtbl -> put_Protocol(This,protocol) ) 

#define INetFwRule2_get_LocalPorts(This,portNumbers)	\
    ( (This)->lpVtbl -> get_LocalPorts(This,portNumbers) ) 

#define INetFwRule2_put_LocalPorts(This,portNumbers)	\
    ( (This)->lpVtbl -> put_LocalPorts(This,portNumbers) ) 

#define INetFwRule2_get_RemotePorts(This,portNumbers)	\
    ( (This)->lpVtbl -> get_RemotePorts(This,portNumbers) ) 

#define INetFwRule2_put_RemotePorts(This,portNumbers)	\
    ( (This)->lpVtbl -> put_RemotePorts(This,portNumbers) ) 

#define INetFwRule2_get_LocalAddresses(This,localAddrs)	\
    ( (This)->lpVtbl -> get_LocalAddresses(This,localAddrs) ) 

#define INetFwRule2_put_LocalAddresses(This,localAddrs)	\
    ( (This)->lpVtbl -> put_LocalAddresses(This,localAddrs) ) 

#define INetFwRule2_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRule2_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRule2_get_IcmpTypesAndCodes(This,icmpTypesAndCodes)	\
    ( (This)->lpVtbl -> get_IcmpTypesAndCodes(This,icmpTypesAndCodes) ) 

#define INetFwRule2_put_IcmpTypesAndCodes(This,icmpTypesAndCodes)	\
    ( (This)->lpVtbl -> put_IcmpTypesAndCodes(This,icmpTypesAndCodes) ) 

#define INetFwRule2_get_Direction(This,dir)	\
    ( (This)->lpVtbl -> get_Direction(This,dir) ) 

#define INetFwRule2_put_Direction(This,dir)	\
    ( (This)->lpVtbl -> put_Direction(This,dir) ) 

#define INetFwRule2_get_Interfaces(This,interfaces)	\
    ( (This)->lpVtbl -> get_Interfaces(This,interfaces) ) 

#define INetFwRule2_put_Interfaces(This,interfaces)	\
    ( (This)->lpVtbl -> put_Interfaces(This,interfaces) ) 

#define INetFwRule2_get_InterfaceTypes(This,interfaceTypes)	\
    ( (This)->lpVtbl -> get_InterfaceTypes(This,interfaceTypes) ) 

#define INetFwRule2_put_InterfaceTypes(This,interfaceTypes)	\
    ( (This)->lpVtbl -> put_InterfaceTypes(This,interfaceTypes) ) 

#define INetFwRule2_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwRule2_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#define INetFwRule2_get_Grouping(This,context)	\
    ( (This)->lpVtbl -> get_Grouping(This,context) ) 

#define INetFwRule2_put_Grouping(This,context)	\
    ( (This)->lpVtbl -> put_Grouping(This,context) ) 

#define INetFwRule2_get_Profiles(This,profileTypesBitmask)	\
    ( (This)->lpVtbl -> get_Profiles(This,profileTypesBitmask) ) 

#define INetFwRule2_put_Profiles(This,profileTypesBitmask)	\
    ( (This)->lpVtbl -> put_Profiles(This,profileTypesBitmask) ) 

#define INetFwRule2_get_EdgeTraversal(This,enabled)	\
    ( (This)->lpVtbl -> get_EdgeTraversal(This,enabled) ) 

#define INetFwRule2_put_EdgeTraversal(This,enabled)	\
    ( (This)->lpVtbl -> put_EdgeTraversal(This,enabled) ) 

#define INetFwRule2_get_Action(This,action)	\
    ( (This)->lpVtbl -> get_Action(This,action) ) 

#define INetFwRule2_put_Action(This,action)	\
    ( (This)->lpVtbl -> put_Action(This,action) ) 


#define INetFwRule2_get_EdgeTraversalOptions(This,lOptions)	\
    ( (This)->lpVtbl -> get_EdgeTraversalOptions(This,lOptions) ) 

#define INetFwRule2_put_EdgeTraversalOptions(This,lOptions)	\
    ( (This)->lpVtbl -> put_EdgeTraversalOptions(This,lOptions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwRule2_INTERFACE_DEFINED__ */


#ifndef __INetFwRules_INTERFACE_DEFINED__
#define __INetFwRules_INTERFACE_DEFINED__

/* interface INetFwRules */
/* [dual][uuid][object][local] */ 


EXTERN_C const IID IID_INetFwRules;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C4C6277-5027-441E-AFAE-CA1F542DA009")
    INetFwRules : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *count) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ INetFwRule *rule) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ BSTR name) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ BSTR name,
            /* [retval][out] */ INetFwRule **rule) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **newEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwRulesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwRules * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwRules * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwRules * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwRules * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwRules * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwRules * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwRules * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            INetFwRules * This,
            /* [retval][out] */ long *count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            INetFwRules * This,
            /* [in] */ INetFwRule *rule);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            INetFwRules * This,
            /* [in] */ BSTR name);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            INetFwRules * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ INetFwRule **rule);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            INetFwRules * This,
            /* [retval][out] */ IUnknown **newEnum);
        
        END_INTERFACE
    } INetFwRulesVtbl;

    interface INetFwRules
    {
        CONST_VTBL struct INetFwRulesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwRules_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwRules_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwRules_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwRules_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwRules_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwRules_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwRules_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwRules_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define INetFwRules_Add(This,rule)	\
    ( (This)->lpVtbl -> Add(This,rule) ) 

#define INetFwRules_Remove(This,name)	\
    ( (This)->lpVtbl -> Remove(This,name) ) 

#define INetFwRules_Item(This,name,rule)	\
    ( (This)->lpVtbl -> Item(This,name,rule) ) 

#define INetFwRules_get__NewEnum(This,newEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,newEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwRules_INTERFACE_DEFINED__ */


#ifndef __INetFwServiceRestriction_INTERFACE_DEFINED__
#define __INetFwServiceRestriction_INTERFACE_DEFINED__

/* interface INetFwServiceRestriction */
/* [dual][uuid][object][local] */ 


EXTERN_C const IID IID_INetFwServiceRestriction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8267BBE3-F890-491C-B7B6-2DB1EF0E5D2B")
    INetFwServiceRestriction : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RestrictService( 
            /* [in] */ BSTR serviceName,
            /* [in] */ BSTR appName,
            /* [in] */ VARIANT_BOOL restrictService,
            /* [in] */ VARIANT_BOOL serviceSidRestricted) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ServiceRestricted( 
            /* [in] */ BSTR serviceName,
            /* [in] */ BSTR appName,
            /* [retval][out] */ VARIANT_BOOL *serviceRestricted) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Rules( 
            /* [retval][out] */ INetFwRules **rules) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwServiceRestrictionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwServiceRestriction * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwServiceRestriction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwServiceRestriction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwServiceRestriction * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwServiceRestriction * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwServiceRestriction * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwServiceRestriction * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RestrictService )( 
            INetFwServiceRestriction * This,
            /* [in] */ BSTR serviceName,
            /* [in] */ BSTR appName,
            /* [in] */ VARIANT_BOOL restrictService,
            /* [in] */ VARIANT_BOOL serviceSidRestricted);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ServiceRestricted )( 
            INetFwServiceRestriction * This,
            /* [in] */ BSTR serviceName,
            /* [in] */ BSTR appName,
            /* [retval][out] */ VARIANT_BOOL *serviceRestricted);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rules )( 
            INetFwServiceRestriction * This,
            /* [retval][out] */ INetFwRules **rules);
        
        END_INTERFACE
    } INetFwServiceRestrictionVtbl;

    interface INetFwServiceRestriction
    {
        CONST_VTBL struct INetFwServiceRestrictionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwServiceRestriction_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwServiceRestriction_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwServiceRestriction_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwServiceRestriction_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwServiceRestriction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwServiceRestriction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwServiceRestriction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwServiceRestriction_RestrictService(This,serviceName,appName,restrictService,serviceSidRestricted)	\
    ( (This)->lpVtbl -> RestrictService(This,serviceName,appName,restrictService,serviceSidRestricted) ) 

#define INetFwServiceRestriction_ServiceRestricted(This,serviceName,appName,serviceRestricted)	\
    ( (This)->lpVtbl -> ServiceRestricted(This,serviceName,appName,serviceRestricted) ) 

#define INetFwServiceRestriction_get_Rules(This,rules)	\
    ( (This)->lpVtbl -> get_Rules(This,rules) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwServiceRestriction_INTERFACE_DEFINED__ */


#ifndef __INetFwProfile_INTERFACE_DEFINED__
#define __INetFwProfile_INTERFACE_DEFINED__

/* interface INetFwProfile */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("174A0DDA-E9F9-449D-993B-21AB667CA456")
    INetFwProfile : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out NET_FW_PROFILE_TYPE *type) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FirewallEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FirewallEnabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ExceptionsNotAllowed( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *notAllowed) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ExceptionsNotAllowed( 
            /* [in] */ VARIANT_BOOL notAllowed) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_NotificationsDisabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_NotificationsDisabled( 
            /* [in] */ VARIANT_BOOL disabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UnicastResponsesToMulticastBroadcastDisabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_UnicastResponsesToMulticastBroadcastDisabled( 
            /* [in] */ VARIANT_BOOL disabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAdminSettings( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwRemoteAdminSettings **remoteAdminSettings) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IcmpSettings( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwIcmpSettings **icmpSettings) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_GloballyOpenPorts( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPorts **openPorts) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Services( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwServices **services) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AuthorizedApplications( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwAuthorizedApplications **apps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwProfile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwProfile * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwProfile * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwProfile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwProfile * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__out NET_FW_PROFILE_TYPE *type);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FirewallEnabled )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FirewallEnabled )( 
            __RPC__in INetFwProfile * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExceptionsNotAllowed )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *notAllowed);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ExceptionsNotAllowed )( 
            __RPC__in INetFwProfile * This,
            /* [in] */ VARIANT_BOOL notAllowed);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_NotificationsDisabled )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_NotificationsDisabled )( 
            __RPC__in INetFwProfile * This,
            /* [in] */ VARIANT_BOOL disabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UnicastResponsesToMulticastBroadcastDisabled )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UnicastResponsesToMulticastBroadcastDisabled )( 
            __RPC__in INetFwProfile * This,
            /* [in] */ VARIANT_BOOL disabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAdminSettings )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwRemoteAdminSettings **remoteAdminSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IcmpSettings )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwIcmpSettings **icmpSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GloballyOpenPorts )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPorts **openPorts);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Services )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwServices **services);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AuthorizedApplications )( 
            __RPC__in INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwAuthorizedApplications **apps);
        
        END_INTERFACE
    } INetFwProfileVtbl;

    interface INetFwProfile
    {
        CONST_VTBL struct INetFwProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwProfile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwProfile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwProfile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwProfile_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwProfile_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwProfile_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwProfile_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwProfile_get_Type(This,type)	\
    ( (This)->lpVtbl -> get_Type(This,type) ) 

#define INetFwProfile_get_FirewallEnabled(This,enabled)	\
    ( (This)->lpVtbl -> get_FirewallEnabled(This,enabled) ) 

#define INetFwProfile_put_FirewallEnabled(This,enabled)	\
    ( (This)->lpVtbl -> put_FirewallEnabled(This,enabled) ) 

#define INetFwProfile_get_ExceptionsNotAllowed(This,notAllowed)	\
    ( (This)->lpVtbl -> get_ExceptionsNotAllowed(This,notAllowed) ) 

#define INetFwProfile_put_ExceptionsNotAllowed(This,notAllowed)	\
    ( (This)->lpVtbl -> put_ExceptionsNotAllowed(This,notAllowed) ) 

#define INetFwProfile_get_NotificationsDisabled(This,disabled)	\
    ( (This)->lpVtbl -> get_NotificationsDisabled(This,disabled) ) 

#define INetFwProfile_put_NotificationsDisabled(This,disabled)	\
    ( (This)->lpVtbl -> put_NotificationsDisabled(This,disabled) ) 

#define INetFwProfile_get_UnicastResponsesToMulticastBroadcastDisabled(This,disabled)	\
    ( (This)->lpVtbl -> get_UnicastResponsesToMulticastBroadcastDisabled(This,disabled) ) 

#define INetFwProfile_put_UnicastResponsesToMulticastBroadcastDisabled(This,disabled)	\
    ( (This)->lpVtbl -> put_UnicastResponsesToMulticastBroadcastDisabled(This,disabled) ) 

#define INetFwProfile_get_RemoteAdminSettings(This,remoteAdminSettings)	\
    ( (This)->lpVtbl -> get_RemoteAdminSettings(This,remoteAdminSettings) ) 

#define INetFwProfile_get_IcmpSettings(This,icmpSettings)	\
    ( (This)->lpVtbl -> get_IcmpSettings(This,icmpSettings) ) 

#define INetFwProfile_get_GloballyOpenPorts(This,openPorts)	\
    ( (This)->lpVtbl -> get_GloballyOpenPorts(This,openPorts) ) 

#define INetFwProfile_get_Services(This,services)	\
    ( (This)->lpVtbl -> get_Services(This,services) ) 

#define INetFwProfile_get_AuthorizedApplications(This,apps)	\
    ( (This)->lpVtbl -> get_AuthorizedApplications(This,apps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwProfile_INTERFACE_DEFINED__ */


#ifndef __INetFwPolicy_INTERFACE_DEFINED__
#define __INetFwPolicy_INTERFACE_DEFINED__

/* interface INetFwPolicy */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D46D2478-9AC9-4008-9DC7-5563CE5536CC")
    INetFwPolicy : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentProfile( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwProfile **profile) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetProfileByType( 
            /* [in] */ NET_FW_PROFILE_TYPE profileType,
            /* [retval][out] */ __RPC__deref_out_opt INetFwProfile **profile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwPolicy * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwPolicy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwPolicy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentProfile )( 
            __RPC__in INetFwPolicy * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwProfile **profile);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetProfileByType )( 
            __RPC__in INetFwPolicy * This,
            /* [in] */ NET_FW_PROFILE_TYPE profileType,
            /* [retval][out] */ __RPC__deref_out_opt INetFwProfile **profile);
        
        END_INTERFACE
    } INetFwPolicyVtbl;

    interface INetFwPolicy
    {
        CONST_VTBL struct INetFwPolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwPolicy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwPolicy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwPolicy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwPolicy_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwPolicy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwPolicy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwPolicy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwPolicy_get_CurrentProfile(This,profile)	\
    ( (This)->lpVtbl -> get_CurrentProfile(This,profile) ) 

#define INetFwPolicy_GetProfileByType(This,profileType,profile)	\
    ( (This)->lpVtbl -> GetProfileByType(This,profileType,profile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwPolicy_INTERFACE_DEFINED__ */


#ifndef __INetFwPolicy2_INTERFACE_DEFINED__
#define __INetFwPolicy2_INTERFACE_DEFINED__

/* interface INetFwPolicy2 */
/* [dual][uuid][object][local] */ 


EXTERN_C const IID IID_INetFwPolicy2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98325047-C671-4174-8D81-DEFCD3F03186")
    INetFwPolicy2 : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentProfileTypes( 
            /* [retval][out] */ long *profileTypesBitmask) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FirewallEnabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FirewallEnabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ExcludedInterfaces( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT *interfaces) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ExcludedInterfaces( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT interfaces) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BlockAllInboundTraffic( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT_BOOL *Block) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BlockAllInboundTraffic( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL Block) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_NotificationsDisabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT_BOOL *disabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_NotificationsDisabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL disabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UnicastResponsesToMulticastBroadcastDisabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT_BOOL *disabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_UnicastResponsesToMulticastBroadcastDisabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL disabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Rules( 
            /* [retval][out] */ INetFwRules **rules) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceRestriction( 
            /* [retval][out] */ INetFwServiceRestriction **ServiceRestriction) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EnableRuleGroup( 
            /* [in] */ long profileTypesBitmask,
            /* [in] */ BSTR group,
            /* [in] */ VARIANT_BOOL enable) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsRuleGroupEnabled( 
            /* [in] */ long profileTypesBitmask,
            /* [in] */ BSTR group,
            /* [retval][out] */ VARIANT_BOOL *enabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RestoreLocalFirewallDefaults( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultInboundAction( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ NET_FW_ACTION *action) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DefaultInboundAction( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ NET_FW_ACTION action) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultOutboundAction( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ NET_FW_ACTION *action) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DefaultOutboundAction( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ NET_FW_ACTION action) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IsRuleGroupCurrentlyEnabled( 
            /* [in] */ BSTR group,
            /* [retval][out] */ VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LocalPolicyModifyState( 
            /* [retval][out] */ NET_FW_MODIFY_STATE *modifyState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwPolicy2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwPolicy2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwPolicy2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwPolicy2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwPolicy2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwPolicy2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwPolicy2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwPolicy2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentProfileTypes )( 
            INetFwPolicy2 * This,
            /* [retval][out] */ long *profileTypesBitmask);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FirewallEnabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FirewallEnabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExcludedInterfaces )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT *interfaces);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ExcludedInterfaces )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT interfaces);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BlockAllInboundTraffic )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT_BOOL *Block);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BlockAllInboundTraffic )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL Block);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_NotificationsDisabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT_BOOL *disabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_NotificationsDisabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL disabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UnicastResponsesToMulticastBroadcastDisabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ VARIANT_BOOL *disabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UnicastResponsesToMulticastBroadcastDisabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL disabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rules )( 
            INetFwPolicy2 * This,
            /* [retval][out] */ INetFwRules **rules);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceRestriction )( 
            INetFwPolicy2 * This,
            /* [retval][out] */ INetFwServiceRestriction **ServiceRestriction);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *EnableRuleGroup )( 
            INetFwPolicy2 * This,
            /* [in] */ long profileTypesBitmask,
            /* [in] */ BSTR group,
            /* [in] */ VARIANT_BOOL enable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsRuleGroupEnabled )( 
            INetFwPolicy2 * This,
            /* [in] */ long profileTypesBitmask,
            /* [in] */ BSTR group,
            /* [retval][out] */ VARIANT_BOOL *enabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RestoreLocalFirewallDefaults )( 
            INetFwPolicy2 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultInboundAction )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ NET_FW_ACTION *action);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultInboundAction )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ NET_FW_ACTION action);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultOutboundAction )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ NET_FW_ACTION *action);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultOutboundAction )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ NET_FW_ACTION action);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsRuleGroupCurrentlyEnabled )( 
            INetFwPolicy2 * This,
            /* [in] */ BSTR group,
            /* [retval][out] */ VARIANT_BOOL *enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalPolicyModifyState )( 
            INetFwPolicy2 * This,
            /* [retval][out] */ NET_FW_MODIFY_STATE *modifyState);
        
        END_INTERFACE
    } INetFwPolicy2Vtbl;

    interface INetFwPolicy2
    {
        CONST_VTBL struct INetFwPolicy2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwPolicy2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwPolicy2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwPolicy2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwPolicy2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwPolicy2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwPolicy2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwPolicy2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwPolicy2_get_CurrentProfileTypes(This,profileTypesBitmask)	\
    ( (This)->lpVtbl -> get_CurrentProfileTypes(This,profileTypesBitmask) ) 

#define INetFwPolicy2_get_FirewallEnabled(This,profileType,enabled)	\
    ( (This)->lpVtbl -> get_FirewallEnabled(This,profileType,enabled) ) 

#define INetFwPolicy2_put_FirewallEnabled(This,profileType,enabled)	\
    ( (This)->lpVtbl -> put_FirewallEnabled(This,profileType,enabled) ) 

#define INetFwPolicy2_get_ExcludedInterfaces(This,profileType,interfaces)	\
    ( (This)->lpVtbl -> get_ExcludedInterfaces(This,profileType,interfaces) ) 

#define INetFwPolicy2_put_ExcludedInterfaces(This,profileType,interfaces)	\
    ( (This)->lpVtbl -> put_ExcludedInterfaces(This,profileType,interfaces) ) 

#define INetFwPolicy2_get_BlockAllInboundTraffic(This,profileType,Block)	\
    ( (This)->lpVtbl -> get_BlockAllInboundTraffic(This,profileType,Block) ) 

#define INetFwPolicy2_put_BlockAllInboundTraffic(This,profileType,Block)	\
    ( (This)->lpVtbl -> put_BlockAllInboundTraffic(This,profileType,Block) ) 

#define INetFwPolicy2_get_NotificationsDisabled(This,profileType,disabled)	\
    ( (This)->lpVtbl -> get_NotificationsDisabled(This,profileType,disabled) ) 

#define INetFwPolicy2_put_NotificationsDisabled(This,profileType,disabled)	\
    ( (This)->lpVtbl -> put_NotificationsDisabled(This,profileType,disabled) ) 

#define INetFwPolicy2_get_UnicastResponsesToMulticastBroadcastDisabled(This,profileType,disabled)	\
    ( (This)->lpVtbl -> get_UnicastResponsesToMulticastBroadcastDisabled(This,profileType,disabled) ) 

#define INetFwPolicy2_put_UnicastResponsesToMulticastBroadcastDisabled(This,profileType,disabled)	\
    ( (This)->lpVtbl -> put_UnicastResponsesToMulticastBroadcastDisabled(This,profileType,disabled) ) 

#define INetFwPolicy2_get_Rules(This,rules)	\
    ( (This)->lpVtbl -> get_Rules(This,rules) ) 

#define INetFwPolicy2_get_ServiceRestriction(This,ServiceRestriction)	\
    ( (This)->lpVtbl -> get_ServiceRestriction(This,ServiceRestriction) ) 

#define INetFwPolicy2_EnableRuleGroup(This,profileTypesBitmask,group,enable)	\
    ( (This)->lpVtbl -> EnableRuleGroup(This,profileTypesBitmask,group,enable) ) 

#define INetFwPolicy2_IsRuleGroupEnabled(This,profileTypesBitmask,group,enabled)	\
    ( (This)->lpVtbl -> IsRuleGroupEnabled(This,profileTypesBitmask,group,enabled) ) 

#define INetFwPolicy2_RestoreLocalFirewallDefaults(This)	\
    ( (This)->lpVtbl -> RestoreLocalFirewallDefaults(This) ) 

#define INetFwPolicy2_get_DefaultInboundAction(This,profileType,action)	\
    ( (This)->lpVtbl -> get_DefaultInboundAction(This,profileType,action) ) 

#define INetFwPolicy2_put_DefaultInboundAction(This,profileType,action)	\
    ( (This)->lpVtbl -> put_DefaultInboundAction(This,profileType,action) ) 

#define INetFwPolicy2_get_DefaultOutboundAction(This,profileType,action)	\
    ( (This)->lpVtbl -> get_DefaultOutboundAction(This,profileType,action) ) 

#define INetFwPolicy2_put_DefaultOutboundAction(This,profileType,action)	\
    ( (This)->lpVtbl -> put_DefaultOutboundAction(This,profileType,action) ) 

#define INetFwPolicy2_get_IsRuleGroupCurrentlyEnabled(This,group,enabled)	\
    ( (This)->lpVtbl -> get_IsRuleGroupCurrentlyEnabled(This,group,enabled) ) 

#define INetFwPolicy2_get_LocalPolicyModifyState(This,modifyState)	\
    ( (This)->lpVtbl -> get_LocalPolicyModifyState(This,modifyState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwPolicy2_INTERFACE_DEFINED__ */


#ifndef __INetFwMgr_INTERFACE_DEFINED__
#define __INetFwMgr_INTERFACE_DEFINED__

/* interface INetFwMgr */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7898AF5-CAC4-4632-A2EC-DA06E5111AF2")
    INetFwMgr : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LocalPolicy( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwPolicy **localPolicy) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentProfileType( 
            /* [retval][out] */ __RPC__out NET_FW_PROFILE_TYPE *profileType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RestoreDefaults( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsPortAllowed( 
            /* [in] */ __RPC__in BSTR imageFileName,
            /* [in] */ NET_FW_IP_VERSION ipVersion,
            /* [in] */ LONG portNumber,
            /* [in] */ __RPC__in BSTR localAddress,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol,
            /* [out] */ __RPC__out VARIANT *allowed,
            /* [out] */ __RPC__out VARIANT *restricted) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsIcmpTypeAllowed( 
            /* [in] */ NET_FW_IP_VERSION ipVersion,
            /* [in] */ __RPC__in BSTR localAddress,
            /* [in] */ BYTE type,
            /* [out] */ __RPC__out VARIANT *allowed,
            /* [out] */ __RPC__out VARIANT *restricted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in INetFwMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in INetFwMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in INetFwMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in INetFwMgr * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in INetFwMgr * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in INetFwMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwMgr * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalPolicy )( 
            __RPC__in INetFwMgr * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwPolicy **localPolicy);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentProfileType )( 
            __RPC__in INetFwMgr * This,
            /* [retval][out] */ __RPC__out NET_FW_PROFILE_TYPE *profileType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RestoreDefaults )( 
            __RPC__in INetFwMgr * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsPortAllowed )( 
            __RPC__in INetFwMgr * This,
            /* [in] */ __RPC__in BSTR imageFileName,
            /* [in] */ NET_FW_IP_VERSION ipVersion,
            /* [in] */ LONG portNumber,
            /* [in] */ __RPC__in BSTR localAddress,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol,
            /* [out] */ __RPC__out VARIANT *allowed,
            /* [out] */ __RPC__out VARIANT *restricted);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsIcmpTypeAllowed )( 
            __RPC__in INetFwMgr * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion,
            /* [in] */ __RPC__in BSTR localAddress,
            /* [in] */ BYTE type,
            /* [out] */ __RPC__out VARIANT *allowed,
            /* [out] */ __RPC__out VARIANT *restricted);
        
        END_INTERFACE
    } INetFwMgrVtbl;

    interface INetFwMgr
    {
        CONST_VTBL struct INetFwMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwMgr_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwMgr_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwMgr_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwMgr_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwMgr_get_LocalPolicy(This,localPolicy)	\
    ( (This)->lpVtbl -> get_LocalPolicy(This,localPolicy) ) 

#define INetFwMgr_get_CurrentProfileType(This,profileType)	\
    ( (This)->lpVtbl -> get_CurrentProfileType(This,profileType) ) 

#define INetFwMgr_RestoreDefaults(This)	\
    ( (This)->lpVtbl -> RestoreDefaults(This) ) 

#define INetFwMgr_IsPortAllowed(This,imageFileName,ipVersion,portNumber,localAddress,ipProtocol,allowed,restricted)	\
    ( (This)->lpVtbl -> IsPortAllowed(This,imageFileName,ipVersion,portNumber,localAddress,ipProtocol,allowed,restricted) ) 

#define INetFwMgr_IsIcmpTypeAllowed(This,ipVersion,localAddress,type,allowed,restricted)	\
    ( (This)->lpVtbl -> IsIcmpTypeAllowed(This,ipVersion,localAddress,type,allowed,restricted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwMgr_INTERFACE_DEFINED__ */


#ifndef __INetFwProduct_INTERFACE_DEFINED__
#define __INetFwProduct_INTERFACE_DEFINED__

/* interface INetFwProduct */
/* [dual][uuid][object][local] */ 


EXTERN_C const IID IID_INetFwProduct;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71881699-18f4-458b-b892-3ffce5e07f75")
    INetFwProduct : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RuleCategories( 
            /* [retval][out] */ VARIANT *ruleCategories) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RuleCategories( 
            /* [in] */ VARIANT ruleCategories) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *displayName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ BSTR displayName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PathToSignedProductExe( 
            /* [retval][out] */ BSTR *path) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwProductVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwProduct * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwProduct * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwProduct * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwProduct * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwProduct * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwProduct * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwProduct * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RuleCategories )( 
            INetFwProduct * This,
            /* [retval][out] */ VARIANT *ruleCategories);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RuleCategories )( 
            INetFwProduct * This,
            /* [in] */ VARIANT ruleCategories);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            INetFwProduct * This,
            /* [retval][out] */ BSTR *displayName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            INetFwProduct * This,
            /* [in] */ BSTR displayName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PathToSignedProductExe )( 
            INetFwProduct * This,
            /* [retval][out] */ BSTR *path);
        
        END_INTERFACE
    } INetFwProductVtbl;

    interface INetFwProduct
    {
        CONST_VTBL struct INetFwProductVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwProduct_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwProduct_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwProduct_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwProduct_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwProduct_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwProduct_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwProduct_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwProduct_get_RuleCategories(This,ruleCategories)	\
    ( (This)->lpVtbl -> get_RuleCategories(This,ruleCategories) ) 

#define INetFwProduct_put_RuleCategories(This,ruleCategories)	\
    ( (This)->lpVtbl -> put_RuleCategories(This,ruleCategories) ) 

#define INetFwProduct_get_DisplayName(This,displayName)	\
    ( (This)->lpVtbl -> get_DisplayName(This,displayName) ) 

#define INetFwProduct_put_DisplayName(This,displayName)	\
    ( (This)->lpVtbl -> put_DisplayName(This,displayName) ) 

#define INetFwProduct_get_PathToSignedProductExe(This,path)	\
    ( (This)->lpVtbl -> get_PathToSignedProductExe(This,path) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwProduct_INTERFACE_DEFINED__ */


#ifndef __INetFwProducts_INTERFACE_DEFINED__
#define __INetFwProducts_INTERFACE_DEFINED__

/* interface INetFwProducts */
/* [dual][uuid][object][local] */ 


EXTERN_C const IID IID_INetFwProducts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39EB36E0-2097-40BD-8AF2-63A13B525362")
    INetFwProducts : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *count) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ INetFwProduct *product,
            /* [retval][out] */ IUnknown **registration) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ long index,
            /* [retval][out] */ INetFwProduct **product) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown **newEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwProductsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwProducts * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwProducts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwProducts * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwProducts * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwProducts * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwProducts * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwProducts * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            INetFwProducts * This,
            /* [retval][out] */ long *count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Register )( 
            INetFwProducts * This,
            /* [in] */ INetFwProduct *product,
            /* [retval][out] */ IUnknown **registration);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            INetFwProducts * This,
            /* [in] */ long index,
            /* [retval][out] */ INetFwProduct **product);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            INetFwProducts * This,
            /* [retval][out] */ IUnknown **newEnum);
        
        END_INTERFACE
    } INetFwProductsVtbl;

    interface INetFwProducts
    {
        CONST_VTBL struct INetFwProductsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwProducts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwProducts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwProducts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwProducts_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwProducts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwProducts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwProducts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwProducts_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define INetFwProducts_Register(This,product,registration)	\
    ( (This)->lpVtbl -> Register(This,product,registration) ) 

#define INetFwProducts_Item(This,index,product)	\
    ( (This)->lpVtbl -> Item(This,index,product) ) 

#define INetFwProducts_get__NewEnum(This,newEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,newEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwProducts_INTERFACE_DEFINED__ */



#ifndef __NetFwPublicTypeLib_LIBRARY_DEFINED__
#define __NetFwPublicTypeLib_LIBRARY_DEFINED__

/* library NetFwPublicTypeLib */
/* [version][uuid] */ 



















EXTERN_C const IID LIBID_NetFwPublicTypeLib;

EXTERN_C const CLSID CLSID_NetFwRule;

#ifdef __cplusplus

class DECLSPEC_UUID("2C5BC43E-3369-4C33-AB0C-BE9469677AF4")
NetFwRule;
#endif

EXTERN_C const CLSID CLSID_NetFwOpenPort;

#ifdef __cplusplus

class DECLSPEC_UUID("0CA545C6-37AD-4A6C-BF92-9F7610067EF5")
NetFwOpenPort;
#endif

EXTERN_C const CLSID CLSID_NetFwAuthorizedApplication;

#ifdef __cplusplus

class DECLSPEC_UUID("EC9846B3-2762-4A6B-A214-6ACB603462D2")
NetFwAuthorizedApplication;
#endif

EXTERN_C const CLSID CLSID_NetFwPolicy2;

#ifdef __cplusplus

class DECLSPEC_UUID("E2B3C97F-6AE1-41AC-817A-F6F92166D7DD")
NetFwPolicy2;
#endif

EXTERN_C const CLSID CLSID_NetFwProduct;

#ifdef __cplusplus

class DECLSPEC_UUID("9D745ED8-C514-4D1D-BF42-751FED2D5AC7")
NetFwProduct;
#endif

EXTERN_C const CLSID CLSID_NetFwProducts;

#ifdef __cplusplus

class DECLSPEC_UUID("CC19079B-8272-4D73-BB70-CDB533527B61")
NetFwProducts;
#endif

EXTERN_C const CLSID CLSID_NetFwMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("304CE942-6E39-40D8-943A-B913C40C9CD4")
NetFwMgr;
#endif
#endif /* __NetFwPublicTypeLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\NetSh.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    netsh.h

Abstract:
    This file contains definitions which are needed by all NetSh helper DLLs.

--*/

#ifndef _NETSH_H_
#define _NETSH_H_

#if _MSC_VER > 1000
#pragma once
#endif

#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union

#ifdef __cplusplus
extern "C" {
#endif

//
// Error codes
//
#define NETSH_ERROR_BASE                        15000
#define ERROR_NO_ENTRIES                        (NETSH_ERROR_BASE + 0)
#define ERROR_INVALID_SYNTAX                    (NETSH_ERROR_BASE + 1)
#define ERROR_PROTOCOL_NOT_IN_TRANSPORT         (NETSH_ERROR_BASE + 2)
#define ERROR_NO_CHANGE                         (NETSH_ERROR_BASE + 3)
#define ERROR_CMD_NOT_FOUND                     (NETSH_ERROR_BASE + 4)
#define ERROR_ENTRY_PT_NOT_FOUND                (NETSH_ERROR_BASE + 5)
#define ERROR_DLL_LOAD_FAILED                   (NETSH_ERROR_BASE + 6)
#define ERROR_INIT_DISPLAY                      (NETSH_ERROR_BASE + 7)
#define ERROR_TAG_ALREADY_PRESENT               (NETSH_ERROR_BASE + 8)
#define ERROR_INVALID_OPTION_TAG                (NETSH_ERROR_BASE + 9)
#define ERROR_NO_TAG                            (NETSH_ERROR_BASE + 10)
#define ERROR_MISSING_OPTION                    (NETSH_ERROR_BASE + 11)
#define ERROR_TRANSPORT_NOT_PRESENT             (NETSH_ERROR_BASE + 12)
#define ERROR_SHOW_USAGE                        (NETSH_ERROR_BASE + 13)
#define ERROR_INVALID_OPTION_VALUE              (NETSH_ERROR_BASE + 14)
#define ERROR_OKAY                              (NETSH_ERROR_BASE + 15)
#define ERROR_CONTINUE_IN_PARENT_CONTEXT        (NETSH_ERROR_BASE + 16)
#define ERROR_SUPPRESS_OUTPUT                   (NETSH_ERROR_BASE + 17)
#define ERROR_HELPER_ALREADY_REGISTERED         (NETSH_ERROR_BASE + 18)
#define ERROR_CONTEXT_ALREADY_REGISTERED        (NETSH_ERROR_BASE + 19)
#define ERROR_PARSING_FAILURE                   (NETSH_ERROR_BASE + 20) 
#define NETSH_ERROR_END                ERROR_CONTEXT_ALREADY_REGISTERED

// Flags
enum NS_CMD_FLAGS
{
    CMD_FLAG_PRIVATE     = 0x01, // not valid in sub-contexts
    CMD_FLAG_INTERACTIVE = 0x02, // not valid from outside netsh
    CMD_FLAG_LOCAL       = 0x08, // not valid from a remote machine
    CMD_FLAG_ONLINE      = 0x10, // not valid in offline/non-commit mode
    CMD_FLAG_HIDDEN      = 0x20, // hide from help but allow execution
    CMD_FLAG_LIMIT_MASK  = 0xffff,
    CMD_FLAG_PRIORITY    = 0x80000000 // ulPriority field is used*/
};

typedef enum _NS_REQS
{
    NS_REQ_ZERO           = 0,
    NS_REQ_PRESENT        = 1,
    NS_REQ_ALLOW_MULTIPLE = 2,
    NS_REQ_ONE_OR_MORE    = 3
} NS_REQS;

enum NS_EVENTS
{
    NS_EVENT_LOOP       = 0x00010000,
    NS_EVENT_LAST_N     = 0x00000001,
    NS_EVENT_LAST_SECS  = 0x00000002,
    NS_EVENT_FROM_N     = 0x00000004,
    NS_EVENT_FROM_START = 0x00000008
};

enum NS_MODE_CHANGE
{
    NETSH_COMMIT                   = 0,
    NETSH_UNCOMMIT                 = 1,
    NETSH_FLUSH                    = 2,
    NETSH_COMMIT_STATE             = 3,
    NETSH_SAVE                     = 4
};


#define NS_GET_EVENT_IDS_FN_NAME    "GetEventIds"

#define MAX_NAME_LEN                    MAX_DLL_NAME

#define NETSH_VERSION_50                0x0005000

#define NETSH_ARG_DELIMITER             L"="
#define NETSH_CMD_DELIMITER             L" "

#define NETSH_MAX_TOKEN_LENGTH          64
#define NETSH_MAX_CMD_TOKEN_LENGTH      128

#define NETSH_ROOT_GUID { 0, 0, 0, { 0, 0, 0, 0, 0, 0, 0, 0 } }

#define DEFAULT_CONTEXT_PRIORITY 100

typedef struct _TOKEN_VALUE
{
    LPCWSTR  pwszToken; // literal token string
    DWORD    dwValue;   // ID of info string
} TOKEN_VALUE, *PTOKEN_VALUE;

// Macros
#define CREATE_CMD_ENTRY(t,f)            {CMD_##t, f, HLP_##t, HLP_##t##_EX, CMD_FLAG_PRIVATE, NULL}
#define CREATE_CMD_ENTRY_EX(t,f,i)       {CMD_##t, f, HLP_##t, HLP_##t##_EX, i, NULL}
#define CREATE_CMD_ENTRY_EX_VER(t,f,i,v) {CMD_##t, f, HLP_##t, HLP_##t##_EX, i, v}

#define CREATE_CMD_GROUP_ENTRY(t,s)            {CMD_##t, HLP_##t, sizeof(s)/sizeof(CMD_ENTRY), 0, s, NULL }
#define CREATE_CMD_GROUP_ENTRY_EX(t,s,i)       {CMD_##t, HLP_##t, sizeof(s)/sizeof(CMD_ENTRY), i, s, NULL }
#define CREATE_CMD_GROUP_ENTRY_EX_VER(t,s,i,v) {CMD_##t, HLP_##t, sizeof(s)/sizeof(CMD_ENTRY), i, s, v }

#define NUM_TOKENS_IN_TABLE(TokenArray) sizeof(TokenArray)/sizeof(TOKEN_VALUE)
#define NUM_TAGS_IN_TABLE(TagsArray)    sizeof(TagsArray)/sizeof(TAG_TYPE)

#define GET_RESOURCE_STRING_FN_NAME    "GetResourceString"

// Callbacks

typedef
DWORD
(WINAPI GET_RESOURCE_STRING_FN)(
    IN  DWORD   dwMsgID,         // resource identifier
    OUT LPWSTR  lpBuffer,        // resource buffer
    IN  DWORD   nBufferMax       // size of buffer in characters
    );

typedef GET_RESOURCE_STRING_FN *PGET_RESOURCE_STRING_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_COMMIT_FN)(
    IN  DWORD       dwAction
    );

typedef NS_CONTEXT_COMMIT_FN *PNS_CONTEXT_COMMIT_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_CONNECT_FN)(
    IN  LPCWSTR      pwszMachine
    );

typedef NS_CONTEXT_CONNECT_FN *PNS_CONTEXT_CONNECT_FN;

typedef struct _NS_CONTEXT_ATTRIBUTES NS_CONTEXT_ATTRIBUTES;

typedef
DWORD
(WINAPI NS_CONTEXT_DUMP_FN)(
    IN      LPCWSTR     pwszRouter,
    __deref_inout_ecount(dwArgCount) LPWSTR     *ppwcArguments,
    __in    DWORD       dwArgCount,
    IN      LPCVOID     pvData
    );

typedef NS_CONTEXT_DUMP_FN *PNS_CONTEXT_DUMP_FN;

typedef
DWORD
(WINAPI NS_DLL_STOP_FN)(
    IN  DWORD       dwReserved
    );

typedef NS_DLL_STOP_FN *PNS_DLL_STOP_FN;

typedef
DWORD
(WINAPI NS_HELPER_START_FN)(
    __in  CONST GUID *pguidParent,
    __in  DWORD       dwVersion
    );

typedef NS_HELPER_START_FN *PNS_HELPER_START_FN;

typedef
DWORD
(WINAPI NS_HELPER_STOP_FN)(
    __in  DWORD       dwReserved
    );

typedef NS_HELPER_STOP_FN *PNS_HELPER_STOP_FN;

typedef DWORD (FN_HANDLE_CMD)(
    IN      LPCWSTR   pwszMachine,
    __inout_ecount(dwArgCount) LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );

typedef FN_HANDLE_CMD *PFN_HANDLE_CMD;

typedef
BOOL
(WINAPI NS_OSVERSIONCHECK)(
    __in  UINT     CIMOSType,                   // WMI: Win32_OperatingSystem  OSType
    __in  UINT     CIMOSProductSuite,           // WMI: Win32_OperatingSystem  OSProductSuite
    __in  LPCWSTR  CIMOSVersion,                // WMI: Win32_OperatingSystem  Version
    __in  LPCWSTR  CIMOSBuildNumber,            // WMI: Win32_OperatingSystem  BuildNumber
    __in  LPCWSTR  CIMServicePackMajorVersion,  // WMI: Win32_OperatingSystem  ServicePackMajorVersion
    __in  LPCWSTR  CIMServicePackMinorVersion,  // WMI: Win32_OperatingSystem  ServicePackMinorVersion
    __in  UINT     uiReserved,
    __in  DWORD    dwReserved
    );

typedef NS_OSVERSIONCHECK *PNS_OSVERSIONCHECK;

// Structures
typedef struct _NS_HELPER_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };
        ULONGLONG       _ullAlign;
    };
    GUID                      guidHelper;           // GUID associated with the helper
    PNS_HELPER_START_FN       pfnStart;             // Function to start this helper
    PNS_HELPER_STOP_FN        pfnStop;              // Function to stop this helper
} NS_HELPER_ATTRIBUTES, *PNS_HELPER_ATTRIBUTES;

typedef struct _CMD_ENTRY
{
    LPCWSTR             pwszCmdToken;        // The token for the command
    PFN_HANDLE_CMD      pfnCmdHandler;       // The function which handles this command
    DWORD               dwShortCmdHelpToken; // The short help message
    DWORD               dwCmdHlpToken;       // The message to display if the only thing after the command is a help token (HELP, /?, -?, ?)
    DWORD               dwFlags;             // Flags (see CMD_FLAGS_xxx above)
    PNS_OSVERSIONCHECK  pOsVersionCheck;     // Check for the version of the OS this command can run against
} CMD_ENTRY, *PCMD_ENTRY;

typedef struct _CMD_GROUP_ENTRY
{
    LPCWSTR         pwszCmdGroupToken;      // The token for the command verb
    DWORD           dwShortCmdHelpToken;    // The message to display in a command listing.
    ULONG           ulCmdGroupSize;         // The number of entries in the cmd table
    DWORD           dwFlags;                // Flags (see CMD_FLAG_xxx)
    PCMD_ENTRY      pCmdGroup;              // The command table
    PNS_OSVERSIONCHECK  pOsVersionCheck;    // Check for the version of the OS this command can run against
} CMD_GROUP_ENTRY, *PCMD_GROUP_ENTRY;

typedef struct _NS_CONTEXT_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };
        ULONGLONG       _ullAlign;
    };

    LPWSTR                   pwszContext;          // Name of the context
    GUID                     guidHelper;           // GUID of the helper servicing this context
    DWORD                    dwFlags;              // Flags limiting when context is available. (See CMD_FLAG_xxx)
    ULONG                    ulPriority;           // Priority field is only relevant if CMD_FLAG_PRIORITY is set in dwFlags
    ULONG                    ulNumTopCmds;         // Number of top-level commands
    struct _CMD_ENTRY        (*pTopCmds)[];        // Array of top-level commands
    ULONG                    ulNumGroups;          // Number of command groups
    struct _CMD_GROUP_ENTRY  (*pCmdGroups)[];      // Array of command groups

    PNS_CONTEXT_COMMIT_FN    pfnCommitFn;
    PNS_CONTEXT_DUMP_FN      pfnDumpFn;
    PNS_CONTEXT_CONNECT_FN   pfnConnectFn;
    PVOID                    pReserved;
    PNS_OSVERSIONCHECK       pfnOsVersionCheck;

} NS_CONTEXT_ATTRIBUTES, *PNS_CONTEXT_ATTRIBUTES;

typedef CONST struct _NS_CONTEXT_ATTRIBUTES * PCNS_CONTEXT_ATTRIBUTES;

typedef struct _TAG_TYPE
{
    LPCWSTR  pwszTag;     // tag string
    DWORD    dwRequired;  // required or not
    BOOL     bPresent;    // present or not
} TAG_TYPE, *PTAG_TYPE;

typedef
DWORD
(NS_DLL_INIT_FN)(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    );

typedef NS_DLL_INIT_FN *PNS_DLL_INIT_FN;

DWORD WINAPI MatchEnumTag(
    IN  HANDLE             hModule,
    IN  LPCWSTR            pwcArg,
    IN  DWORD              dwNumArg,
    IN  CONST TOKEN_VALUE *pEnumTable,
    OUT PDWORD             pdwValue
    );

BOOL WINAPI MatchToken(
    IN  LPCWSTR  pwszUserToken,
    IN  LPCWSTR  pwszCmdToken
    );

DWORD WINAPI PreprocessCommand(
    __in_opt                   HANDLE    hModule,
    __inout_ecount(dwArgCount) LPWSTR   *ppwcArguments,
    __in                       DWORD     dwCurrentIndex,
    __in                       DWORD     dwArgCount,
    __inout_opt                TAG_TYPE *pttTags,
    __in                       DWORD     dwTagCount,
    __in                       DWORD     dwMinArgs,
    __in                       DWORD     dwMaxArgs,
    __out_opt                  DWORD    *pdwTagType
    );

DWORD PrintError(
    IN  HANDLE  hModule, OPTIONAL
    IN  DWORD   dwErrId,
    ...
    );

DWORD PrintMessageFromModule(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

DWORD PrintMessage(
    IN  LPCWSTR  pwszFormat,
    ...
    );

DWORD WINAPI RegisterContext(
    IN    CONST NS_CONTEXT_ATTRIBUTES *pChildContext
    );

DWORD WINAPI RegisterHelper(
    IN    CONST GUID                 *pguidParentContext,
    IN    CONST NS_HELPER_ATTRIBUTES *pfnRegisterSubContext
    );

#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif // _NETSH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\netprov.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for netprov.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netprov_h__
#define __netprov_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IProvisioningDomain_FWD_DEFINED__
#define __IProvisioningDomain_FWD_DEFINED__
typedef interface IProvisioningDomain IProvisioningDomain;
#endif 	/* __IProvisioningDomain_FWD_DEFINED__ */


#ifndef __IProvisioningProfileWireless_FWD_DEFINED__
#define __IProvisioningProfileWireless_FWD_DEFINED__
typedef interface IProvisioningProfileWireless IProvisioningProfileWireless;
#endif 	/* __IProvisioningProfileWireless_FWD_DEFINED__ */


#ifndef __NetProvisioning_FWD_DEFINED__
#define __NetProvisioning_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetProvisioning NetProvisioning;
#else
typedef struct NetProvisioning NetProvisioning;
#endif /* __cplusplus */

#endif 	/* __NetProvisioning_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "prsht.h"
#include "msxml.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_netprov_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif




extern RPC_IF_HANDLE __MIDL_itf_netprov_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netprov_0000_0000_v0_0_s_ifspec;

#ifndef __IProvisioningDomain_INTERFACE_DEFINED__
#define __IProvisioningDomain_INTERFACE_DEFINED__

/* interface IProvisioningDomain */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProvisioningDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c96fbd50-24dd-11d8-89fb-00904b2ea9c6")
    IProvisioningDomain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszwPathToFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Query( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszwDomain,
            /* [string][in] */ __RPC__in_string LPCWSTR pszwLanguage,
            /* [string][in] */ __RPC__in_string LPCWSTR pszwXPathQuery,
            /* [out] */ __RPC__deref_out_opt IXMLDOMNodeList **Nodes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvisioningDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProvisioningDomain * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProvisioningDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProvisioningDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IProvisioningDomain * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszwPathToFolder);
        
        HRESULT ( STDMETHODCALLTYPE *Query )( 
            __RPC__in IProvisioningDomain * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszwDomain,
            /* [string][in] */ __RPC__in_string LPCWSTR pszwLanguage,
            /* [string][in] */ __RPC__in_string LPCWSTR pszwXPathQuery,
            /* [out] */ __RPC__deref_out_opt IXMLDOMNodeList **Nodes);
        
        END_INTERFACE
    } IProvisioningDomainVtbl;

    interface IProvisioningDomain
    {
        CONST_VTBL struct IProvisioningDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvisioningDomain_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvisioningDomain_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvisioningDomain_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvisioningDomain_Add(This,pszwPathToFolder)	\
    ( (This)->lpVtbl -> Add(This,pszwPathToFolder) ) 

#define IProvisioningDomain_Query(This,pszwDomain,pszwLanguage,pszwXPathQuery,Nodes)	\
    ( (This)->lpVtbl -> Query(This,pszwDomain,pszwLanguage,pszwXPathQuery,Nodes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvisioningDomain_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netprov_0000_0001 */
/* [local] */ 

//
// WZC Wireless CreateProfile private error codes (returned in *pulStatus)
// WZC_PROFILE_SUCCESS is applicable only if the HRESULT returned is also
// S_OK
//
#define     WZC_PROFILE_SUCCESS                                         0
#define     WZC_PROFILE_XML_ERROR_NO_VERSION                            1
#define     WZC_PROFILE_XML_ERROR_BAD_VERSION                           2
#define     WZC_PROFILE_XML_ERROR_UNSUPPORTED_VERSION                   3
#define     WZC_PROFILE_XML_ERROR_SSID_NOT_FOUND                        4
#define     WZC_PROFILE_XML_ERROR_BAD_SSID                              5
#define     WZC_PROFILE_XML_ERROR_CONNECTION_TYPE                       6
#define     WZC_PROFILE_XML_ERROR_AUTHENTICATION                        7
#define     WZC_PROFILE_XML_ERROR_ENCRYPTION                            8
#define     WZC_PROFILE_XML_ERROR_KEY_PROVIDED_AUTOMATICALLY            9
#define     WZC_PROFILE_XML_ERROR_1X_ENABLED                            10
#define     WZC_PROFILE_XML_ERROR_EAP_METHOD                            11
#define     WZC_PROFILE_XML_ERROR_BAD_KEY_INDEX                         12
#define     WZC_PROFILE_XML_ERROR_KEY_INDEX_RANGE                       13
#define     WZC_PROFILE_XML_ERROR_BAD_NETWORK_KEY                       14
#define     WZC_PROFILE_CONFIG_ERROR_INVALID_AUTH_FOR_CONNECTION_TYPE   15
#define     WZC_PROFILE_CONFIG_ERROR_INVALID_ENCRYPTION_FOR_AUTHMODE    16
#define     WZC_PROFILE_CONFIG_ERROR_KEY_REQUIRED                       17
#define     WZC_PROFILE_CONFIG_ERROR_KEY_INDEX_REQUIRED                 18
#define     WZC_PROFILE_CONFIG_ERROR_KEY_INDEX_NOT_APPLICABLE           19
#define     WZC_PROFILE_CONFIG_ERROR_1X_NOT_ALLOWED                     20
#define     WZC_PROFILE_CONFIG_ERROR_1X_NOT_ALLOWED_KEY_REQUIRED        21
#define     WZC_PROFILE_CONFIG_ERROR_1X_NOT_ENABLED_KEY_PROVIDED        22
#define     WZC_PROFILE_CONFIG_ERROR_EAP_METHOD_REQUIRED                23
#define     WZC_PROFILE_CONFIG_ERROR_EAP_METHOD_NOT_APPLICABLE          24
#define     WZC_PROFILE_CONFIG_ERROR_WPA_NOT_SUPPORTED                  25
#define     WZC_PROFILE_CONFIG_ERROR_WPA_ENCRYPTION_NOT_SUPPORTED       26
#define     WZC_PROFILE_SET_ERROR_DUPLICATE_NETWORK                     27
#define     WZC_PROFILE_SET_ERROR_MEMORY_ALLOCATION                     28
#define     WZC_PROFILE_SET_ERROR_READING_1X_CONFIG                     29
#define     WZC_PROFILE_SET_ERROR_WRITING_1X_CONFIG                     30
#define     WZC_PROFILE_SET_ERROR_WRITING_WZC_CFG                       31
#define     WZC_PROFILE_API_ERROR_NOT_SUPPORTED                         32
#define     WZC_PROFILE_API_ERROR_FAILED_TO_LOAD_XML                    33
#define     WZC_PROFILE_API_ERROR_FAILED_TO_LOAD_SCHEMA                 34
#define     WZC_PROFILE_API_ERROR_XML_VALIDATION_FAILED                 35
#define     WZC_PROFILE_API_ERROR_INTERNAL                              36


extern RPC_IF_HANDLE __MIDL_itf_netprov_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netprov_0000_0001_v0_0_s_ifspec;

#ifndef __IProvisioningProfileWireless_INTERFACE_DEFINED__
#define __IProvisioningProfileWireless_INTERFACE_DEFINED__

/* interface IProvisioningProfileWireless */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProvisioningProfileWireless;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c96fbd51-24dd-11d8-89fb-00904b2ea9c6")
    IProvisioningProfileWireless : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateProfile( 
            /* [in] */ __RPC__in BSTR bstrXMLWirelessConfigProfile,
            /* [in] */ __RPC__in BSTR bstrXMLConnectionConfigProfile,
            /* [in] */ __RPC__in GUID *pAdapterInstanceGuid,
            /* [out] */ __RPC__out ULONG *pulStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvisioningProfileWirelessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProvisioningProfileWireless * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProvisioningProfileWireless * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProvisioningProfileWireless * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProfile )( 
            __RPC__in IProvisioningProfileWireless * This,
            /* [in] */ __RPC__in BSTR bstrXMLWirelessConfigProfile,
            /* [in] */ __RPC__in BSTR bstrXMLConnectionConfigProfile,
            /* [in] */ __RPC__in GUID *pAdapterInstanceGuid,
            /* [out] */ __RPC__out ULONG *pulStatus);
        
        END_INTERFACE
    } IProvisioningProfileWirelessVtbl;

    interface IProvisioningProfileWireless
    {
        CONST_VTBL struct IProvisioningProfileWirelessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvisioningProfileWireless_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvisioningProfileWireless_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvisioningProfileWireless_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvisioningProfileWireless_CreateProfile(This,bstrXMLWirelessConfigProfile,bstrXMLConnectionConfigProfile,pAdapterInstanceGuid,pulStatus)	\
    ( (This)->lpVtbl -> CreateProfile(This,bstrXMLWirelessConfigProfile,bstrXMLConnectionConfigProfile,pAdapterInstanceGuid,pulStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvisioningProfileWireless_INTERFACE_DEFINED__ */



#ifndef __NETPROVLib_LIBRARY_DEFINED__
#define __NETPROVLib_LIBRARY_DEFINED__

/* library NETPROVLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_NETPROVLib;

EXTERN_C const CLSID CLSID_NetProvisioning;

#ifdef __cplusplus

class DECLSPEC_UUID("2aa2b5fe-b846-4d07-810c-b21ee45320e3")
NetProvisioning;
#endif
#endif /* __NETPROVLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\netmon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for netmon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netmon_h__
#define __netmon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDelaydC_FWD_DEFINED__
#define __IDelaydC_FWD_DEFINED__
typedef interface IDelaydC IDelaydC;
#endif 	/* __IDelaydC_FWD_DEFINED__ */


#ifndef __IRTC_FWD_DEFINED__
#define __IRTC_FWD_DEFINED__
typedef interface IRTC IRTC;
#endif 	/* __IRTC_FWD_DEFINED__ */


#ifndef __IStats_FWD_DEFINED__
#define __IStats_FWD_DEFINED__
typedef interface IStats IStats;
#endif 	/* __IStats_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_netmon_0000_0000 */
/* [local] */ 

//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//  MODULE: netmon.h
//
//  This is the consolidated include file for all Network Monitor components.
//
//  It contains the contents of these files from previous SDKs:
//
//      NPPTypes.h
//      Finder.h
//      NMSupp.h
//      BHTypes.h
//      NMErr.h
//      BHFilter.h
//      Frame.h
//      Parser.h
//      IniLib.h
//      NMExpert.h      (previously Expert.h)
//      Netmon.h        (previously bh.h)
//      NMBlob.h        (previously blob.h)
//      NMRegHelp.h     (previously reghelp.h)
//      NMIpStructs.h   (previously IpStructs.h)
//      NMIcmpStructs.h (previously IcmpStructs.h)
//      NMIpxStructs.h  (previously IpxStructs.h)
//      NMTcpStructs.h  (previously TcpStructs.h)
//
//      IDelaydC.idl
//      IRTC.idl
//      IStats.idl
//
//=============================================================================
#include <winerror.h>
#include <winerror.h>

#pragma pack(1)
// For backward compatability with old SDK versions, all structures within this header
// file will be byte packed on x86 platforms. All other platforms will only have those
// structures that will be used to decode network data packed.
#ifdef _X86_
#pragma pack(1)
#else
#pragma pack()
#endif

// yes we know that many of our structures have:
// warning C4200: nonstandard extension used : zero-sized array in struct/union
// this is OK and intended
#pragma warning(disable:4200)
//=============================================================================
//=============================================================================
//  (NPPTypes.h)
//=============================================================================
//=============================================================================
typedef BYTE *LPBYTE;

typedef const void *HBLOB;

//=============================================================================
// General constants.
//=============================================================================
#define	MAC_TYPE_UNKNOWN	( 0 )

#define	MAC_TYPE_ETHERNET	( 1 )

#define	MAC_TYPE_TOKENRING	( 2 )

#define	MAC_TYPE_FDDI	( 3 )

#define	MAC_TYPE_ATM	( 4 )

#define	MAC_TYPE_1394	( 5 )

#define	MACHINE_NAME_LENGTH	( 16 )

#define	USER_NAME_LENGTH	( 32 )

#define	ADAPTER_COMMENT_LENGTH	( 32 )

#define	CONNECTION_FLAGS_WANT_CONVERSATION_STATS	( 0x1 )

//=============================================================================
//  Transmit statistics structure.
//=============================================================================
typedef struct _TRANSMITSTATS
    {
    DWORD TotalFramesSent;
    DWORD TotalBytesSent;
    DWORD TotalTransmitErrors;
    } 	TRANSMITSTATS;

typedef TRANSMITSTATS *LPTRANSMITSTATS;

#define	TRANSMITSTATS_SIZE	( sizeof( TRANSMITSTATS  ) )

//=============================================================================
//  Statistics structure.
//=============================================================================
typedef struct _STATISTICS
    {
    __int64 TimeElapsed;
    DWORD TotalFramesCaptured;
    DWORD TotalBytesCaptured;
    DWORD TotalFramesFiltered;
    DWORD TotalBytesFiltered;
    DWORD TotalMulticastsFiltered;
    DWORD TotalBroadcastsFiltered;
    DWORD TotalFramesSeen;
    DWORD TotalBytesSeen;
    DWORD TotalMulticastsReceived;
    DWORD TotalBroadcastsReceived;
    DWORD TotalFramesDropped;
    DWORD TotalFramesDroppedFromBuffer;
    DWORD MacFramesReceived;
    DWORD MacCRCErrors;
    __int64 MacBytesReceivedEx;
    DWORD MacFramesDropped_NoBuffers;
    DWORD MacMulticastsReceived;
    DWORD MacBroadcastsReceived;
    DWORD MacFramesDropped_HwError;
    } 	STATISTICS;

typedef STATISTICS *LPSTATISTICS;

#define	STATISTICS_SIZE	( sizeof( STATISTICS  ) )

//=============================================================================
//  Address structures
//=============================================================================

// These structures are used to decode network data and so need to be packed

#pragma pack(push, 1)
#define	MAX_NAME_SIZE	( 32 )

#define	IP_ADDRESS_SIZE	( 4 )

#define	MAC_ADDRESS_SIZE	( 6 )

#define	IP6_ADDRESS_SIZE	( 16 )

// Q: What is the maximum address size that we could have to copy?
// A: IP6 
#define	MAX_ADDRESS_SIZE	( 16 )

#define	ADDRESS_TYPE_ETHERNET	( 0 )

#define	ADDRESS_TYPE_IP	( 1 )

#define	ADDRESS_TYPE_IPX	( 2 )

#define	ADDRESS_TYPE_TOKENRING	( 3 )

#define	ADDRESS_TYPE_FDDI	( 4 )

#define	ADDRESS_TYPE_XNS	( 5 )

#define	ADDRESS_TYPE_ANY	( 6 )

#define	ADDRESS_TYPE_ANY_GROUP	( 7 )

#define	ADDRESS_TYPE_FIND_HIGHEST	( 8 )

#define	ADDRESS_TYPE_VINES_IP	( 9 )

#define	ADDRESS_TYPE_LOCAL_ONLY	( 10 )

#define	ADDRESS_TYPE_ATM	( 11 )

#define	ADDRESS_TYPE_1394	( 12 )

#define	ADDRESS_TYPE_IP6	( 13 )

#define	ADDRESSTYPE_FLAGS_NORMALIZE	( 0x1 )

#define	ADDRESSTYPE_FLAGS_BIT_REVERSE	( 0x2 )

// Vines IP Address Structure
typedef struct _VINES_IP_ADDRESS
    {
    DWORD NetID;
    WORD SubnetID;
    } 	VINES_IP_ADDRESS;

typedef VINES_IP_ADDRESS *LPVINES_IP_ADDRESS;

#define	VINES_IP_ADDRESS_SIZE	( sizeof( VINES_IP_ADDRESS  ) )

// IPX Address Structure
typedef struct _IPX_ADDR
    {
    BYTE Subnet[ 4 ];
    BYTE Address[ 6 ];
    } 	IPX_ADDR;

typedef IPX_ADDR *LPIPX_ADDR;

#define	IPX_ADDR_SIZE	( sizeof( IPX_ADDR  ) )

// XNS Address Structure
typedef IPX_ADDR XNS_ADDRESS;

typedef IPX_ADDR *LPXNS_ADDRESS;

// ETHERNET SOURCE ADDRESS
typedef struct _ETHERNET_SRC_ADDRESS
{
    BYTE    RoutingBit:     1;
    BYTE    LocalBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];

} ETHERNET_SRC_ADDRESS;
typedef ETHERNET_SRC_ADDRESS *LPETHERNET_SRC_ADDRESS;
// ETHERNET DESTINATION ADDRESS
typedef struct _ETHERNET_DST_ADDRESS
{
    BYTE    GroupBit:       1;
    BYTE    AdminBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];
} ETHERNET_DST_ADDRESS;
typedef ETHERNET_DST_ADDRESS *LPETHERNET_DST_ADDRESS;

// FDDI addresses
typedef ETHERNET_SRC_ADDRESS FDDI_SRC_ADDRESS;
typedef ETHERNET_DST_ADDRESS FDDI_DST_ADDRESS;

typedef FDDI_SRC_ADDRESS *LPFDDI_SRC_ADDRESS;
typedef FDDI_DST_ADDRESS *LPFDDI_DST_ADDRESS;

// TOKENRING Source Address
typedef struct _TOKENRING_SRC_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    LocalBit:       1;
    BYTE    RoutingBit:     1;
    BYTE    Byte1;
    BYTE    Byte2:          7;
    BYTE    Functional:     1;
    BYTE    Reserved[3];
} TOKENRING_SRC_ADDRESS;
typedef TOKENRING_SRC_ADDRESS *LPTOKENRING_SRC_ADDRESS;

// TOKENRING Destination Address
typedef struct _TOKENRING_DST_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    AdminBit:       1;
    BYTE    GroupBit:       1;
    BYTE    Reserved[5];
} TOKENRING_DST_ADDRESS;
typedef TOKENRING_DST_ADDRESS *LPTOKENRING_DST_ADDRESS;
// Address Structure
typedef struct _ADDRESS2
{
    DWORD                       Type;

    union
    {
        // ADDRESS_TYPE_ETHERNET
        // ADDRESS_TYPE_TOKENRING
        // ADDRESS_TYPE_FDDI
        BYTE                    MACAddress[MAC_ADDRESS_SIZE];

        // IP
        BYTE                    IPAddress[IP_ADDRESS_SIZE];

        // IP6
        BYTE                    IP6Address[IP6_ADDRESS_SIZE];

        // raw IPX
        BYTE                    IPXRawAddress[IPX_ADDR_SIZE];

        // real IPX
        IPX_ADDR                IPXAddress;

        // raw Vines IP
        BYTE                    VinesIPRawAddress[VINES_IP_ADDRESS_SIZE];

        // real Vines IP
        VINES_IP_ADDRESS        VinesIPAddress;

        // ethernet with bits defined
        ETHERNET_SRC_ADDRESS    EthernetSrcAddress;

        // ethernet with bits defined
        ETHERNET_DST_ADDRESS    EthernetDstAddress;

        // tokenring with bits defined
        TOKENRING_SRC_ADDRESS   TokenringSrcAddress;

        // tokenring with bits defined
        TOKENRING_DST_ADDRESS   TokenringDstAddress;

        // fddi with bits defined
        FDDI_SRC_ADDRESS        FddiSrcAddress;

        // fddi with bits defined
        FDDI_DST_ADDRESS        FddiDstAddress;
    };
    
    WORD                        Flags;
} ADDRESS2;
typedef ADDRESS2 *LPADDRESS2;
#define ADDRESS2_SIZE   sizeof(ADDRESS2)


#pragma pack(pop)
//=============================================================================
//  Address Pair Structure
//=============================================================================
#define	ADDRESS_FLAGS_MATCH_DST	( 0x1 )

#define	ADDRESS_FLAGS_MATCH_SRC	( 0x2 )

#define	ADDRESS_FLAGS_EXCLUDE	( 0x4 )

#define	ADDRESS_FLAGS_DST_GROUP_ADDR	( 0x8 )

#define	ADDRESS_FLAGS_MATCH_BOTH	( 0x3 )

typedef struct _ADDRESSPAIR2
{
    WORD        AddressFlags;
    WORD        NalReserved;
    ADDRESS2    DstAddress;
    ADDRESS2    SrcAddress;

} ADDRESSPAIR2;
typedef ADDRESSPAIR2 *LPADDRESSPAIR2;
#define ADDRESSPAIR2_SIZE  sizeof(ADDRESSPAIR2)
//=============================================================================
//  Address table.
//=============================================================================
#define	MAX_ADDRESS_PAIRS	( 8 )

typedef struct _ADDRESSTABLE2
{
    DWORD           nAddressPairs;
    DWORD           nNonMacAddressPairs;
    ADDRESSPAIR2    AddressPair[MAX_ADDRESS_PAIRS];

} ADDRESSTABLE2;

typedef ADDRESSTABLE2 *LPADDRESSTABLE2;
#define ADDRESSTABLE2_SIZE sizeof(ADDRESSTABLE2)
//=============================================================================
//  Network information.
//=============================================================================
#define	NETWORKINFO_FLAGS_PMODE_NOT_SUPPORTED	( 0x1 )

#define	NETWORKINFO_FLAGS_REMOTE_NAL	( 0x4 )

#define	NETWORKINFO_FLAGS_REMOTE_NAL_CONNECTED	( 0x8 )

#define	NETWORKINFO_FLAGS_REMOTE_CARD	( 0x10 )

#define	NETWORKINFO_FLAGS_RAS	( 0x20 )

#define NETWORKINFO_RESERVED_FIELD_SIZE (FIELD_OFFSET(ADDRESS2,IPXAddress) + sizeof(IPX_ADDR))
typedef struct _NETWORKINFO
{
    BYTE            PermanentAddr[6];       //... Permanent MAC address
    BYTE            CurrentAddr[6];         //... Current  MAC address
    BYTE            Reserved[NETWORKINFO_RESERVED_FIELD_SIZE];
    DWORD           LinkSpeed;              //... Link speed in Mbits.
    DWORD           MacType;                //... Media type.
    DWORD           MaxFrameSize;           //... Max frame size allowed.
    DWORD           Flags;                  //... Informational flags.
    DWORD           TimestampScaleFactor;   //... 1 = 1/1 ms, 10 = 1/10 ms, 100 = 1/100 ms, etc.
    BYTE            NodeName[32];           //... Name of remote workstation.
    BOOL            PModeSupported;         //... Card claims to support P-Mode
    BYTE            Comment[ADAPTER_COMMENT_LENGTH]; // Adapter comment field.

} NETWORKINFO;
typedef NETWORKINFO *LPNETWORKINFO;
#define NETWORKINFO_SIZE    sizeof(NETWORKINFO)
#define	MINIMUM_FRAME_SIZE	( 32 )

//=============================================================================
//  Pattern structure.
//=============================================================================
#define	MAX_PATTERN_LENGTH	( 16 )

// When set this flag will cause those frames which do NOT have the specified pattern
// in the proper stop to be kept.
#define	PATTERN_MATCH_FLAGS_NOT	( 0x1 )

#define	PATTERN_MATCH_FLAGS_RESERVED_1	( 0x2 )

// When set this flag indicates that the user is not interested in a pattern match within 
// IP or IPX, but in the protocol that follows.  The driver will ensure that the protocol
// given in OffsetBasis is there and then that the port in the fram matches the port given.
// It will then calculate the offset from the beginning of the protocol that follows IP or IPX.
// NOTE: This flag is ignored if it is used with any OffsetBasis other than 
// OFFSET_BASIS_RELATIVE_TO_IPX or OFFSET_BASIS_RELATIVE_TO_IP
#define	PATTERN_MATCH_FLAGS_PORT_SPECIFIED	( 0x8 )

// The offset given is relative to the beginning of the frame. The 
// PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define	OFFSET_BASIS_RELATIVE_TO_FRAME	( 0 )

// The offset given is relative to the beginning of the Effective Protocol.
// The Effective Protocol is defined as the protocol that follows
// the last protocol that determines Etype/SAP. In normal terms this means 
// that the Effective Protocol will be IP, IPX, XNS, or any of their ilk.
// The PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define	OFFSET_BASIS_RELATIVE_TO_EFFECTIVE_PROTOCOL	( 1 )

// The offset given is relative to the beginning of IPX. If IPX is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IPX.
#define	OFFSET_BASIS_RELATIVE_TO_IPX	( 2 )

// The offset given is relative to the beginning of IP. If IP is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IP.
#define	OFFSET_BASIS_RELATIVE_TO_IP	( 3 )

// The offset given is relative to the beginning of IP6. If IP6 is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IP6.
#define	OFFSET_BASIS_RELATIVE_TO_IP6	( 4 )

typedef /* [public][public][public][public][public][public][public][public][public] */ union __MIDL___MIDL_itf_netmon_0000_0000_0001
    {
    BYTE NextHeader;
    BYTE IPPort;
    WORD ByteSwappedIPXPort;
    } 	GENERIC_PORT;

typedef struct _PATTERNMATCH
    {
    DWORD Flags;
    BYTE OffsetBasis;
    GENERIC_PORT Port;
    WORD Offset;
    WORD Length;
    BYTE PatternToMatch[ 16 ];
    } 	PATTERNMATCH;

typedef PATTERNMATCH *LPPATTERNMATCH;

#define	PATTERNMATCH_SIZE	( sizeof( PATTERNMATCH  ) )

//=============================================================================
//  Expression structure.
//=============================================================================
#define	MAX_PATTERNS	( 4 )

typedef struct _ANDEXP
    {
    DWORD nPatternMatches;
    PATTERNMATCH PatternMatch[ 4 ];
    } 	ANDEXP;

typedef ANDEXP *LPANDEXP;

#define	ANDEXP_SIZE	( sizeof( ANDEXP  ) )

typedef struct _EXPRESSION
    {
    DWORD nAndExps;
    ANDEXP AndExp[ 4 ];
    } 	EXPRESSION;

typedef EXPRESSION *LPEXPRESSION;

#define	EXPRESSION_SIZE	( sizeof( EXPRESSION  ) )

//=============================================================================
//  Trigger.
//=============================================================================
#define	TRIGGER_TYPE_PATTERN_MATCH	( 1 )

#define	TRIGGER_TYPE_BUFFER_CONTENT	( 2 )

#define	TRIGGER_TYPE_PATTERN_MATCH_THEN_BUFFER_CONTENT	( 3 )

#define	TRIGGER_TYPE_BUFFER_CONTENT_THEN_PATTERN_MATCH	( 4 )

#define	TRIGGER_FLAGS_FRAME_RELATIVE	( 0 )

#define	TRIGGER_FLAGS_DATA_RELATIVE	( 0x1 )

#define	TRIGGER_ACTION_NOTIFY	( 0 )

#define	TRIGGER_ACTION_STOP	( 0x2 )

#define	TRIGGER_ACTION_PAUSE	( 0x3 )

#define	TRIGGER_BUFFER_FULL_25_PERCENT	( 0 )

#define	TRIGGER_BUFFER_FULL_50_PERCENT	( 1 )

#define	TRIGGER_BUFFER_FULL_75_PERCENT	( 2 )

#define	TRIGGER_BUFFER_FULL_100_PERCENT	( 3 )

typedef struct _TRIGGER
    {
    BOOL TriggerActive;
    BYTE TriggerType;
    BYTE TriggerAction;
    DWORD TriggerFlags;
    PATTERNMATCH TriggerPatternMatch;
    DWORD TriggerBufferSize;
    DWORD TriggerReserved;
    char TriggerCommandLine[ 260 ];
    } 	TRIGGER;

typedef TRIGGER *LPTRIGGER;

#define	TRIGGER_SIZE	( sizeof( TRIGGER  ) )

//=============================================================================
//  Capture filter.
//=============================================================================
//  Capture filter flags. By default all frames are rejected and
//  Network Monitor enables them based on the CAPTUREFILTER flags
//  defined below.
#define	CAPTUREFILTER_FLAGS_INCLUDE_ALL_SAPS	( 0x1 )

#define	CAPTUREFILTER_FLAGS_INCLUDE_ALL_ETYPES	( 0x2 )

#define	CAPTUREFILTER_FLAGS_TRIGGER	( 0x4 )

#define	CAPTUREFILTER_FLAGS_LOCAL_ONLY	( 0x8 )

// throw away our internal comment frames
#define	CAPTUREFILTER_FLAGS_DISCARD_COMMENTS	( 0x10 )

// Keep SMT and Token Ring MAC frames
#define	CAPTUREFILTER_FLAGS_KEEP_RAW	( 0x20 )

#define	CAPTUREFILTER_FLAGS_INCLUDE_ALL	( 0x3 )

#define	BUFFER_FULL_25_PERCENT	( 0 )

#define	BUFFER_FULL_50_PERCENT	( 1 )

#define	BUFFER_FULL_75_PERCENT	( 2 )

#define	BUFFER_FULL_100_PERCENT	( 3 )

typedef struct _CAPTUREFILTER
{
    DWORD           FilterFlags;      
    LPBYTE          lpSapTable;       
    LPWORD          lpEtypeTable;     
    WORD            nSaps;            
    WORD            nEtypes;          
    LPADDRESSTABLE2 AddressTable;     
    EXPRESSION      FilterExpression; 
    TRIGGER         Trigger;          
    DWORD           nFrameBytesToCopy;
    DWORD           Reserved;

} CAPTUREFILTER;
typedef CAPTUREFILTER *LPCAPTUREFILTER;
#define CAPTUREFILTER_SIZE    sizeof(CAPTUREFILTER)
//=============================================================================
//  Frame type.
//=============================================================================
//  TimeStamp is in 1/1,000,000th seconds.
typedef struct _FRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    BYTE MacFrame[ 1 ];
    } 	FRAME;

typedef FRAME *LPFRAME;

typedef FRAME UNALIGNED *ULPFRAME;
#define	FRAME_SIZE	( sizeof( FRAME  ) )

//=============================================================================
//  Frame descriptor type.
//=============================================================================
#define	LOW_PROTOCOL_IPX	( OFFSET_BASIS_RELATIVE_TO_IPX )

#define	LOW_PROTOCOL_IP	( OFFSET_BASIS_RELATIVE_TO_IP )

#define	LOW_PROTOCOL_IP6	( OFFSET_BASIS_RELATIVE_TO_IP6 )

#define	LOW_PROTOCOL_UNKNOWN	( ( BYTE  )-1 )

typedef struct _FRAME_DESCRIPTOR
    {
    LPBYTE FramePointer;
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    WORD Etype;
    BYTE Sap;
    BYTE LowProtocol;
    WORD LowProtocolOffset;
    /* [switch_type] */ union 
        {
        WORD Reserved;
        BYTE IPPort;
        WORD ByteSwappedIPXPort;
        } 	HighPort;
    WORD HighProtocolOffset;
    } 	FRAME_DESCRIPTOR;

typedef FRAME_DESCRIPTOR *LPFRAME_DESCRIPTOR;

#define	FRAME_DESCRIPTOR_SIZE	( sizeof( FRAME_DESCRIPTOR  ) )

//=============================================================================
//  Frame descriptor table.
//=============================================================================
typedef struct _FRAMETABLE
    {
    DWORD FrameTableLength;
    DWORD StartIndex;
    DWORD EndIndex;
    DWORD FrameCount;
    FRAME_DESCRIPTOR Frames[ 1 ];
    } 	FRAMETABLE;

typedef FRAMETABLE *LPFRAMETABLE;

//=============================================================================
//  Station statistics.
//=============================================================================
#define	STATIONSTATS_FLAGS_INITIALIZED	( 0x1 )

#define	STATIONSTATS_FLAGS_EVENTPOSTED	( 0x2 )

#define	STATIONSTATS_POOL_SIZE	( 100 )

typedef struct _STATIONSTATS
    {
    DWORD NextStationStats;
    DWORD SessionPartnerList;
    DWORD Flags;
    BYTE StationAddress[ 6 ];
    WORD Pad;
    DWORD TotalPacketsReceived;
    DWORD TotalDirectedPacketsSent;
    DWORD TotalBroadcastPacketsSent;
    DWORD TotalMulticastPacketsSent;
    DWORD TotalBytesReceived;
    DWORD TotalBytesSent;
    } 	STATIONSTATS;

typedef STATIONSTATS *LPSTATIONSTATS;

#define	STATIONSTATS_SIZE	( sizeof( STATIONSTATS  ) )

//=============================================================================
//  Session statistics.
//=============================================================================
#define	SESSION_FLAGS_INITIALIZED	( 0x1 )

#define	SESSION_FLAGS_EVENTPOSTED	( 0x2 )

#define	SESSION_POOL_SIZE	( 100 )

typedef struct _SESSIONSTATS
    {
    DWORD NextSession;
    DWORD StationOwner;
    DWORD StationPartner;
    DWORD Flags;
    DWORD TotalPacketsSent;
    } 	SESSIONSTATS;

typedef SESSIONSTATS *LPSESSIONSTATS;

#define	SESSIONSTATS_SIZE	( sizeof( SESSIONSTATS  ) )

//=============================================================================
//  Station Query
//=============================================================================

// These structures are obsolete and should not be used
// They are included so that our interfaces need not change

#pragma pack(push, 1)
typedef struct _STATIONQUERY
    {
    DWORD Flags;
    BYTE BCDVerMinor;
    BYTE BCDVerMajor;
    DWORD LicenseNumber;
    BYTE MachineName[ 16 ];
    BYTE UserName[ 32 ];
    BYTE Reserved[ 32 ];
    BYTE AdapterAddress[ 6 ];
    WCHAR WMachineName[ 16 ];
    WCHAR WUserName[ 32 ];
    } 	STATIONQUERY;

typedef STATIONQUERY *LPSTATIONQUERY;

#define	STATIONQUERY_SIZE	( sizeof( STATIONQUERY  ) )


#pragma pack(pop)
//=============================================================================
//   structure.
//=============================================================================
typedef struct _QUERYTABLE
    {
    DWORD nStationQueries;
    STATIONQUERY StationQuery[ 1 ];
    } 	QUERYTABLE;

typedef QUERYTABLE *LPQUERYTABLE;

#define	QUERYTABLE_SIZE	( sizeof( QUERYTABLE  ) )

//=============================================================================
//  The LINK structure is used to chain structures together into a list.
//=============================================================================
typedef struct _LINK *LPLINK;

typedef struct _LINK
    {
    LPLINK PrevLink;
    LPLINK NextLink;
    } 	LINK;

//=============================================================================
//  Security Response packet
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
#define	MAX_SECURITY_BREACH_REASON_SIZE	( 100 )

#define	MAX_SIGNATURE_LENGTH	( 128 )

#define	MAX_USER_NAME_LENGTH	( 256 )

typedef struct _SECURITY_PERMISSION_RESPONSE
    {
    UINT Version;
    DWORD RandomNumber;
    BYTE MachineName[ 16 ];
    BYTE Address[ 6 ];
    BYTE UserName[ 256 ];
    BYTE Reason[ 100 ];
    DWORD SignatureLength;
    BYTE Signature[ 128 ];
    } 	SECURITY_PERMISSION_RESPONSE;

typedef SECURITY_PERMISSION_RESPONSE *LPSECURITY_PERMISSION_RESPONSE;

typedef SECURITY_PERMISSION_RESPONSE UNALIGNED * ULPSECURITY_PERMISSION_RESPONSE;
#define	SECURITY_PERMISSION_RESPONSE_SIZE	( sizeof( SECURITY_PERMISSION_RESPONSE  ) )


#pragma pack(pop)
//=============================================================================
//  Callback type
//=============================================================================
// generic events
#define	UPDATE_EVENT_TERMINATE_THREAD	( 0 )

#define	UPDATE_EVENT_NETWORK_STATUS	( 0x1 )

// rtc events
#define	UPDATE_EVENT_RTC_INTERVAL_ELAPSED	( 0x2 )

#define	UPDATE_EVENT_RTC_FRAME_TABLE_FULL	( 0x3 )

#define	UPDATE_EVENT_RTC_BUFFER_FULL	( 0x4 )

// delayed events
#define	UPDATE_EVENT_TRIGGER_BUFFER_CONTENT	( 0x5 )

#define	UPDATE_EVENT_TRIGGER_PATTERN_MATCH	( 0x6 )

#define	UPDATE_EVENT_TRIGGER_BUFFER_PATTERN	( 0x7 )

#define	UPDATE_EVENT_TRIGGER_PATTERN_BUFFER	( 0x8 )

// transmit events
#define	UPDATE_EVENT_TRANSMIT_STATUS	( 0x9 )

// Security events
#define	UPDATE_EVENT_SECURITY_BREACH	( 0xa )

// Remote failure event
#define	UPDATE_EVENT_REMOTE_FAILURE	( 0xb )

// actions
#define	UPDATE_ACTION_TERMINATE_THREAD	( 0 )

#define	UPDATE_ACTION_NOTIFY	( 0x1 )

#define	UPDATE_ACTION_STOP_CAPTURE	( 0x2 )

#define	UPDATE_ACTION_PAUSE_CAPTURE	( 0x3 )

#define	UPDATE_ACTION_RTC_BUFFER_SWITCH	( 0x4 )

typedef struct _UPDATE_EVENT
    {
    USHORT Event;
    DWORD Action;
    DWORD Status;
    DWORD Value;
    __int64 TimeStamp;
    DWORD_PTR lpUserContext;
    DWORD_PTR lpReserved;
    UINT FramesDropped;
    /* [switch_type] */ union 
        {
        DWORD Reserved;
        LPFRAMETABLE lpFrameTable;
        DWORD_PTR lpPacketQueue;
        SECURITY_PERMISSION_RESPONSE SecurityResponse;
        } 	;
    LPSTATISTICS lpFinalStats;
    } 	UPDATE_EVENT;

typedef UPDATE_EVENT *PUPDATE_EVENT;

// note for c++ users:
// the declaration for this callback should be in the public part of the header file:
// static WINAPI DWORD NetworkCallback( UPDATE_EVENT events);
// and the implementation should be, in the protected section of the cpp file:
// DWORD WINAPI ClassName::NetworkCallback( UPDATE_EVENT events) {};
//typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
//=============================================================================
//  NETWORKSTATUS data structure.
//=============================================================================
typedef struct _NETWORKSTATUS
    {
    DWORD State;
    DWORD Flags;
    } 	NETWORKSTATUS;

typedef NETWORKSTATUS *LPNETWORKSTATUS;

#define	NETWORKSTATUS_SIZE	( sizeof( NETWORKSTATUS  ) )

#define	NETWORKSTATUS_STATE_VOID	( 0 )

#define	NETWORKSTATUS_STATE_INIT	( 1 )

#define	NETWORKSTATUS_STATE_CAPTURING	( 2 )

#define	NETWORKSTATUS_STATE_PAUSED	( 3 )

#define	NETWORKSTATUS_FLAGS_TRIGGER_PENDING	( 0x1 )

#define MAKE_WORD(l, h)         (((WORD) (l)) | (((WORD) (h)) << 8))
#define MAKE_LONG(l, h)         (((DWORD) (l)) | (((DWORD) (h)) << 16L))
#define MAKE_SIG(a, b, c, d)    MAKE_LONG(MAKE_WORD(a, b), MAKE_WORD(c, d))
//=============================================================================
//  STATISTICS parameter structure.
//=============================================================================
#define	MAX_SESSIONS	( 100 )

#define	MAX_STATIONS	( 100 )

typedef struct _STATISTICSPARAM
    {
    DWORD StatisticsSize;
    STATISTICS Statistics;
    DWORD StatisticsTableEntries;
    STATIONSTATS StatisticsTable[ 100 ];
    DWORD SessionTableEntries;
    SESSIONSTATS SessionTable[ 100 ];
    } 	STATISTICSPARAM;

typedef STATISTICSPARAM *LPSTATISTICSPARAM;

#define	STATISTICSPARAM_SIZE	( sizeof( STATISTICSPARAM  ) )

//=============================================================================
//  Capture file header.
//=============================================================================

// This structure is used to decode file data and so needs to be packed

#pragma pack(push, 1)
#define	CAPTUREFILE_VERSION_MAJOR	( 2 )

#define	CAPTUREFILE_VERSION_MINOR	( 0 )

#define MakeVersion(Major, Minor)   ((DWORD) MAKEWORD(Minor, Major))
#define GetCurrentVersion()         MakeVersion(CAPTUREFILE_VERSION_MAJOR, CAPTUREFILE_VERSION_MINOR)
#define NETMON_1_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('R', 'T', 'S', 'S')
#define NETMON_2_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('G', 'M', 'B', 'U')
typedef struct _CAPTUREFILE_HEADER_VALUES
    {
    DWORD Signature;
    BYTE BCDVerMinor;
    BYTE BCDVerMajor;
    WORD MacType;
    SYSTEMTIME TimeStamp;
    DWORD FrameTableOffset;
    DWORD FrameTableLength;
    DWORD UserDataOffset;
    DWORD UserDataLength;
    DWORD CommentDataOffset;
    DWORD CommentDataLength;
    DWORD StatisticsOffset;
    DWORD StatisticsLength;
    DWORD NetworkInfoOffset;
    DWORD NetworkInfoLength;
    DWORD ConversationStatsOffset;
    DWORD ConversationStatsLength;
    } 	CAPTUREFILE_HEADER_VALUES;

typedef CAPTUREFILE_HEADER_VALUES *LPCAPTUREFILE_HEADER_VALUES;

#define	CAPTUREFILE_HEADER_VALUES_SIZE	( sizeof( CAPTUREFILE_HEADER_VALUES  ) )


#pragma pack(pop)
//=============================================================================
//  Capture file.
//=============================================================================

// This structure is used to decode file data and so needs to be packed

#pragma pack(push, 1)
typedef struct _CAPTUREFILE_HEADER
    {
    union 
        {
        CAPTUREFILE_HEADER_VALUES ActualHeader;
        BYTE Buffer[ 72 ];
        } 	;
    BYTE Reserved[ 56 ];
    } 	CAPTUREFILE_HEADER;

typedef CAPTUREFILE_HEADER *LPCAPTUREFILE_HEADER;

#define	CAPTUREFILE_HEADER_SIZE	( sizeof( CAPTUREFILE_HEADER  ) )


#pragma pack(pop)
//=============================================================================
//  Stats Frame definitions.
//=============================================================================

// These structures are used to create network data and so need to be packed

#pragma pack(push, 1)
typedef struct _EFRAMEHDR
    {
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    WORD Length;
    BYTE DSAP;
    BYTE SSAP;
    BYTE Control;
    BYTE ProtocolID[ 3 ];
    WORD EtherType;
    } 	EFRAMEHDR;

typedef struct _TRFRAMEHDR
    {
    BYTE AC;
    BYTE FC;
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    BYTE DSAP;
    BYTE SSAP;
    BYTE Control;
    BYTE ProtocolID[ 3 ];
    WORD EtherType;
    } 	TRFRAMEHDR;

#define	DEFAULT_TR_AC	( 0 )

#define	DEFAULT_TR_FC	( 0x40 )

#define	DEFAULT_SAP	( 0xaa )

#define	DEFAULT_CONTROL	( 0x3 )

#define	DEFAULT_ETHERTYPE	( 0x8419 )

typedef struct _FDDIFRAMEHDR
    {
    BYTE FC;
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    BYTE DSAP;
    BYTE SSAP;
    BYTE Control;
    BYTE ProtocolID[ 3 ];
    WORD EtherType;
    } 	FDDIFRAMEHDR;

#define	DEFAULT_FDDI_FC	( 0x10 )

typedef struct _FDDISTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    FDDIFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	FDDISTATFRAME;

typedef FDDISTATFRAME *LPFDDISTATFRAME;

typedef FDDISTATFRAME UNALIGNED *ULPFDDISTATFRAME;
#define	FDDISTATFRAME_SIZE	( sizeof( FDDISTATFRAME  ) )

typedef struct _ATMFRAMEHDR
    {
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    WORD Vpi;
    WORD Vci;
    } 	ATMFRAMEHDR;

typedef struct _ATMSTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    ATMFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	ATMSTATFRAME;

typedef ATMSTATFRAME *LPATMSTATFRAME;

typedef ATMSTATFRAME UNALIGNED *ULPATMSTATFRAME;
#define	ATMSTATFRAME_SIZE	( sizeof( ATMSTATFRAME  ) )

typedef struct _TRSTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    TRFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	TRSTATFRAME;

typedef TRSTATFRAME *LPTRSTATFRAME;

typedef TRSTATFRAME UNALIGNED *ULPTRSTATFRAME;
#define	TRSTATFRAME_SIZE	( sizeof( TRSTATFRAME  ) )

typedef struct _ESTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    EFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	ESTATFRAME;

typedef ESTATFRAME *LPESTATFRAME;

typedef ESTATFRAME UNALIGNED *ULPESTATFRAME;
#define	ESTATFRAME_SIZE	( sizeof( ESTATFRAME  ) )

#define	STATISTICS_VERSION_1_0	( 0 )

#define	STATISTICS_VERSION_2_0	( 0x20 )

#define	MAX_STATSFRAME_SIZE	( sizeof( TRSTATFRAME  ) )

#define	STATS_FRAME_TYPE	( 103 )


#pragma pack(pop)
//****************************************************************************
//****************************************************************************
// Obsolete structures
// The newer structures (named with a 2 appended) should be used
//****************************************************************************
//****************************************************************************

#pragma pack(push, 1)
// Address Structure
// Obsolete, ADDRESS2 should be used
typedef struct _ADDRESS
{
    DWORD                       Type;

    union
    {
        // ADDRESS_TYPE_ETHERNET
        // ADDRESS_TYPE_TOKENRING
        // ADDRESS_TYPE_FDDI
        BYTE                    MACAddress[MAC_ADDRESS_SIZE];

        // IP
        BYTE                    IPAddress[IP_ADDRESS_SIZE];

        // raw IPX
        BYTE                    IPXRawAddress[IPX_ADDR_SIZE];

        // real IPX
        IPX_ADDR                IPXAddress;

        // raw Vines IP
        BYTE                    VinesIPRawAddress[VINES_IP_ADDRESS_SIZE];

        // real Vines IP
        VINES_IP_ADDRESS        VinesIPAddress;

        // ethernet with bits defined
        ETHERNET_SRC_ADDRESS    EthernetSrcAddress;

        // ethernet with bits defined
        ETHERNET_DST_ADDRESS    EthernetDstAddress;

        // tokenring with bits defined
        TOKENRING_SRC_ADDRESS   TokenringSrcAddress;

        // tokenring with bits defined
        TOKENRING_DST_ADDRESS   TokenringDstAddress;

        // fddi with bits defined
        FDDI_SRC_ADDRESS        FddiSrcAddress;

        // fddi with bits defined
        FDDI_DST_ADDRESS        FddiDstAddress;
    };
    
    WORD                        Flags;
} ADDRESS;
typedef ADDRESS *LPADDRESS;
#define ADDRESS_SIZE   sizeof(ADDRESS)


#pragma pack(pop)
// Obsolete, ADDRESSPAIR2 should be used
typedef struct _ADDRESSPAIR
{
    WORD        AddressFlags;
    WORD        NalReserved;
    ADDRESS     DstAddress;
    ADDRESS     SrcAddress;

} ADDRESSPAIR;
typedef ADDRESSPAIR *LPADDRESSPAIR;
#define ADDRESSPAIR_SIZE  sizeof(ADDRESSPAIR)
// Obsolete, ADDRESSTABLE2 should be used
typedef struct _ADDRESSTABLE
{
    DWORD           nAddressPairs;
    DWORD           nNonMacAddressPairs;
    ADDRESSPAIR     AddressPair[MAX_ADDRESS_PAIRS];

} ADDRESSTABLE;

typedef ADDRESSTABLE *LPADDRESSTABLE;
#define ADDRESSTABLE_SIZE sizeof(ADDRESSTABLE)
// Obsolete, ADDRESSINFO2 should be used
typedef struct _ADDRESSINFO
{
    ADDRESS        Address;
    WCHAR          Name[MAX_NAME_SIZE];
    DWORD          Flags;
    LPVOID         lpAddressInstData;

} ADDRESSINFO;
typedef struct _ADDRESSINFO *LPADDRESSINFO;
#define ADDRESSINFO_SIZE    sizeof(ADDRESSINFO)
// Obsolete, ADDRESSINFOTABLE2 should be used
typedef struct _ADDRESSINFOTABLE
{
    DWORD         nAddressInfos;
    LPADDRESSINFO lpAddressInfo[0];

} ADDRESSINFOTABLE;
typedef ADDRESSINFOTABLE *LPADDRESSINFOTABLE;
#define ADDRESSINFOTABLE_SIZE   sizeof(ADDRESSINFOTABLE)
//****************************************************************************
//****************************************************************************
// Obsolete functions
// The newer functions should be used
//****************************************************************************
//****************************************************************************
// Obsolete, SetNPPAddress2FilterInBlob should be used
DWORD _cdecl SetNPPAddressFilterInBlob( HBLOB hBlob,
                                 LPADDRESSTABLE pAddressTable);
// Obsolete, GetNPPAddress2FilterFromBlob should be used
DWORD _cdecl GetNPPAddressFilterFromBlob( HBLOB hBlob,
                                   LPADDRESSTABLE pAddressTable,
                                   HBLOB hErrorBlob);
//=============================================================================
//=============================================================================
//  (NMEvent.h)
//=============================================================================
//=============================================================================

#pragma pack(push, 8)
// NMCOLUMNTYPE
typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_netmon_0000_0000_0005
    {	NMCOLUMNTYPE_UINT8	= 0,
	NMCOLUMNTYPE_SINT8	= ( NMCOLUMNTYPE_UINT8 + 1 ) ,
	NMCOLUMNTYPE_UINT16	= ( NMCOLUMNTYPE_SINT8 + 1 ) ,
	NMCOLUMNTYPE_SINT16	= ( NMCOLUMNTYPE_UINT16 + 1 ) ,
	NMCOLUMNTYPE_UINT32	= ( NMCOLUMNTYPE_SINT16 + 1 ) ,
	NMCOLUMNTYPE_SINT32	= ( NMCOLUMNTYPE_UINT32 + 1 ) ,
	NMCOLUMNTYPE_FLOAT64	= ( NMCOLUMNTYPE_SINT32 + 1 ) ,
	NMCOLUMNTYPE_FRAME	= ( NMCOLUMNTYPE_FLOAT64 + 1 ) ,
	NMCOLUMNTYPE_YESNO	= ( NMCOLUMNTYPE_FRAME + 1 ) ,
	NMCOLUMNTYPE_ONOFF	= ( NMCOLUMNTYPE_YESNO + 1 ) ,
	NMCOLUMNTYPE_TRUEFALSE	= ( NMCOLUMNTYPE_ONOFF + 1 ) ,
	NMCOLUMNTYPE_MACADDR	= ( NMCOLUMNTYPE_TRUEFALSE + 1 ) ,
	NMCOLUMNTYPE_IPXADDR	= ( NMCOLUMNTYPE_MACADDR + 1 ) ,
	NMCOLUMNTYPE_IPADDR	= ( NMCOLUMNTYPE_IPXADDR + 1 ) ,
	NMCOLUMNTYPE_VARTIME	= ( NMCOLUMNTYPE_IPADDR + 1 ) ,
	NMCOLUMNTYPE_STRING	= ( NMCOLUMNTYPE_VARTIME + 1 ) 
    } 	NMCOLUMNTYPE;

// NMCOLUMNVARIANT
typedef struct _NMCOLUMNVARIANT
    {
    NMCOLUMNTYPE Type;
    union 
        {
        BYTE Uint8Val;
        char Sint8Val;
        WORD Uint16Val;
        short Sint16Val;
        DWORD Uint32Val;
        long Sint32Val;
        DOUBLE Float64Val;
        DWORD FrameVal;
        BOOL YesNoVal;
        BOOL OnOffVal;
        BOOL TrueFalseVal;
        BYTE MACAddrVal[ 6 ];
        IPX_ADDR IPXAddrVal;
        DWORD IPAddrVal;
        DOUBLE VarTimeVal;
        LPCSTR pStringVal;
        } 	Value;
    } 	NMCOLUMNVARIANT;

// COLUMNINFO
typedef struct _NMCOLUMNINFO
    {
    LPSTR szColumnName;
    NMCOLUMNVARIANT VariantData;
    } 	NMCOLUMNINFO;

typedef NMCOLUMNINFO *PNMCOLUMNINFO;

// JTYPE
typedef LPSTR JTYPE;

// EVENTDATA
#ifdef MIDL_PASS
typedef struct _NMEVENTDATA
    {
    LPSTR pszReserved;
    BYTE Version;
    DWORD EventIdent;
    DWORD Flags;
    DWORD Severity;
    BYTE NumColumns;
    LPSTR szSourceName;
    LPSTR szEventName;
    LPSTR szDescription;
    LPSTR szMachine;
    JTYPE Justification;
    PVOID pvReserved;
    SYSTEMTIME SysTime;
    NMCOLUMNINFO Column[ 1 ];
    } 	NMEVENTDATA;

#else  // MIDL_PASS
typedef struct _NMEVENTDATA 
{                            
    LPSTR      pszReserved;  // Reserved
    BYTE       Version;      // Version for this structure (must be 0)
    DWORD      EventIdent;   // ID for this event
    DWORD      Flags;        // Flags for Expert generated and others
    DWORD      Severity;     // Severity level
    BYTE       NumColumns;   // Number of optional columns for this event
    LPSTR      szSourceName; // Name of Expert
    LPSTR      szEventName;  // Name of event
    LPSTR      szDescription;// Description of event
    LPSTR      szMachine;    // Name (or IPADDRESS?) of the machine supplying the event (NULL for Experts usually)
    JTYPE      Justification;// Justification pane info (currently a string, but possible structure)
    PVOID      pvReserved;   // Reserved
    SYSTEMTIME SysTime;      // Systemtime of the event
    NMCOLUMNINFO Column[0];    
} NMEVENTDATA;
#endif // MIDL_PASS
typedef NMEVENTDATA *PNMEVENTDATA;


#pragma pack(pop)
// EVENT FLAGS
#define	NMEVENTFLAG_EXPERT	( 0x1 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_SEVERITY	( 0x80000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_SOURCE	( 0x40000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_EVENT_NAME	( 0x20000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_DESCRIPTION	( 0x10000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_MACHINE	( 0x8000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_TIME	( 0x4000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_DATE	( 0x2000000 )

//#define NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS (NMEVENTFLAG_DO_NOT_DISPLAY_SEVERITY   | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_SOURCE     | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_EVENT_NAME | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_DESCRIPTION| \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_MACHINE    | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_TIME       | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_DATE )
#define	NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS	( 0xfe000000 )


enum _NMEVENT_SEVERITIES
    {	NMEVENT_SEVERITY_INFORMATIONAL	= 0,
	NMEVENT_SEVERITY_WARNING	= ( NMEVENT_SEVERITY_INFORMATIONAL + 1 ) ,
	NMEVENT_SEVERITY_STRONG_WARNING	= ( NMEVENT_SEVERITY_WARNING + 1 ) ,
	NMEVENT_SEVERITY_ERROR	= ( NMEVENT_SEVERITY_STRONG_WARNING + 1 ) ,
	NMEVENT_SEVERITY_SEVERE_ERROR	= ( NMEVENT_SEVERITY_ERROR + 1 ) ,
	NMEVENT_SEVERITY_CRITICAL_ERROR	= ( NMEVENT_SEVERITY_SEVERE_ERROR + 1 ) 
    } ;
//=============================================================================
//=============================================================================
// (Finder.h)
//=============================================================================
//=============================================================================
//=============================================================================
// Structures use by NPPs & the Finder
//=============================================================================
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0007
    {
    DWORD dwNumBlobs;
    HBLOB hBlobs[ 1 ];
    } 	BLOB_TABLE;

typedef BLOB_TABLE *PBLOB_TABLE;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0008
    {
    DWORD size;
    BYTE *pBytes;
    } 	MBLOB;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0009
    {
    DWORD dwNumBlobs;
    MBLOB mBlobs[ 1 ];
    } 	MBLOB_TABLE;

typedef MBLOB_TABLE *PMBLOB_TABLE;

//=============================================================================
// Functions called by monitors, tools, netmon
//=============================================================================
DWORD _cdecl GetNPPBlobTable(HBLOB          hFilterBlob,  
                      PBLOB_TABLE*   ppBlobTable);

DWORD _cdecl GetNPPBlobFromUI(HWND          hwnd,
                       HBLOB         hFilterBlob,
                       HBLOB*        phBlob);          

DWORD _cdecl GetNPPBlobFromUIExU(HWND          hwnd,
                          HBLOB         hFilterBlob,
                          HBLOB*        phBlob,
                          char*         szHelpFileName);          

DWORD _cdecl SelectNPPBlobFromTable( HWND   hwnd,
                              PBLOB_TABLE    pBlobTable,
                              HBLOB*         hBlob);

DWORD _cdecl SelectNPPBlobFromTableExU( HWND   hwnd,
                                 PBLOB_TABLE    pBlobTable,
                                 HBLOB*         hBlob,
                                 char*          szHelpFileName);

//=============================================================================
// Helper functions provided by the Finder
//=============================================================================

__inline DWORD BLOB_TABLE_SIZE(DWORD dwNumBlobs)
{
    return (DWORD) (sizeof(BLOB_TABLE)+dwNumBlobs*sizeof(HBLOB));
}

__inline PBLOB_TABLE  AllocBlobTable(DWORD dwNumBlobs)
{
    DWORD size = BLOB_TABLE_SIZE(dwNumBlobs);

    return (PBLOB_TABLE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

__inline DWORD MBLOB_TABLE_SIZE(DWORD dwNumBlobs)
{
    return (DWORD) (sizeof(MBLOB_TABLE)+dwNumBlobs*sizeof(MBLOB));
}

__inline PMBLOB_TABLE  AllocMBlobTable(DWORD dwNumBlobs)
{
    DWORD size = MBLOB_TABLE_SIZE(dwNumBlobs);

    return (PMBLOB_TABLE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

//=============================================================================
// Functions provided by NPPs, called by the Finder
//=============================================================================

// For NPP's that can return a Blob table without additional configuration.
DWORD _cdecl GetNPPBlobs(PBLOB_TABLE*       ppBlobTable);
typedef DWORD (_cdecl FAR* BLOBSPROC) (PBLOB_TABLE*       ppBlobTable);

// For NPP's that need additional information to return a Blob table.
DWORD _cdecl GetConfigBlob(HBLOB*      phBlob);
typedef DWORD (_cdecl FAR* GETCFGBLOB) (HBLOB, HBLOB*);
typedef DWORD (_cdecl FAR* CFGPROC) (HWND               hwnd,
                              HBLOB              SpecialBlob,
                              PBLOB_TABLE*       ppBlobTable);

//=============================================================================
// Handy functions
//=============================================================================
BOOL  _cdecl FilterNPPBlob(HBLOB hBlob, HBLOB FilterBlob);

BOOL  _cdecl RaiseNMEvent(HINSTANCE    hInstance,
                   WORD         EventType, 
                   DWORD        EventID,
                   WORD         nStrings, 
                   const char** aInsertStrs,
                   LPVOID       lpvData,
                   DWORD        dwDataSize);

//=============================================================================
//=============================================================================
//  (NMmonitor.h)
//=============================================================================
//=============================================================================
//=============================================================================
//=============================================================================
//  (NMSupp.h)
//=============================================================================
//=============================================================================

#ifndef __cplusplus
#ifndef try
#define try                         __try
#endif // try

#ifndef except
#define except                      __except
#endif // except
#endif // __cplusplus
//=============================================================================
//  Windows version constants.
//=============================================================================
#define	WINDOWS_VERSION_UNKNOWN	( 0 )

#define	WINDOWS_VERSION_WIN32S	( 1 )

#define	WINDOWS_VERSION_WIN32C	( 2 )

#define	WINDOWS_VERSION_WIN32	( 3 )

//=============================================================================
//  Frame masks.
//=============================================================================
#define	FRAME_MASK_ETHERNET	( ( BYTE  )~0x1 )

#define	FRAME_MASK_TOKENRING	( ( BYTE  )~0x80 )

#define	FRAME_MASK_FDDI	( ( BYTE  )~0x1 )

//=============================================================================
//  Object heap type.
//=============================================================================
typedef LPVOID HOBJECTHEAP;

//=============================================================================
//  Object cleanup procedure.
//=============================================================================

typedef VOID (WINAPI *OBJECTPROC)(HOBJECTHEAP, LPVOID);

//=============================================================================
//  Network Monitor timers.
//=============================================================================
typedef struct _TIMER *HTIMER;

typedef VOID (WINAPI *BHTIMERPROC)(LPVOID);

HTIMER WINAPI BhSetTimer(BHTIMERPROC TimerProc, LPVOID InstData, DWORD TimeOut);

VOID   WINAPI BhKillTimer(HTIMER hTimer);

//=============================================================================
//  Network Monitor global error API.
//=============================================================================

DWORD  WINAPI BhGetLastError(VOID);

DWORD  WINAPI BhSetLastError(DWORD Error);

//=============================================================================
//  Object manager function prototypes.
//=============================================================================

HOBJECTHEAP WINAPI CreateObjectHeap(DWORD ObjectSize, OBJECTPROC ObjectProc);

HOBJECTHEAP WINAPI DestroyObjectHeap(HOBJECTHEAP hObjectHeap);

LPVOID      WINAPI AllocObject(HOBJECTHEAP hObjectHeap);

LPVOID      WINAPI FreeObject(HOBJECTHEAP hObjectHeap, LPVOID ObjectMemory);

DWORD       WINAPI GrowObjectHeap(HOBJECTHEAP hObjectHeap, DWORD nObjects);

DWORD       WINAPI GetObjectHeapSize(HOBJECTHEAP hObjectHeap);

VOID        WINAPI PurgeObjectHeap(HOBJECTHEAP hObjectHeap);

//=============================================================================
//  Memory functions.
//=============================================================================

LPVOID     WINAPI AllocMemory(SIZE_T size);

LPVOID     WINAPI ReallocMemory(LPVOID ptr, SIZE_T NewSize);

VOID       WINAPI FreeMemory(LPVOID ptr);

VOID       WINAPI TestMemory(LPVOID ptr);

SIZE_T     WINAPI MemorySize(LPVOID ptr);

HANDLE     WINAPI MemoryHandle(LPBYTE ptr);

//=============================================================================
//  EXPRESSION API's
//=============================================================================

LPEXPRESSION         WINAPI InitializeExpression(LPEXPRESSION Expression);

LPPATTERNMATCH       WINAPI InitializePattern(LPPATTERNMATCH Pattern, LPVOID ptr, DWORD offset, DWORD length);

LPEXPRESSION         WINAPI AndExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

LPEXPRESSION         WINAPI OrExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

LPPATTERNMATCH       WINAPI NegatePattern(LPPATTERNMATCH Pattern);

LPADDRESSTABLE2      WINAPI AdjustOperatorPrecedence(LPADDRESSTABLE2 AddressTable);

LPADDRESS2           WINAPI NormalizeAddress(LPADDRESS2 Address);

LPADDRESSTABLE2      WINAPI NormalizeAddressTable(LPADDRESSTABLE2 AddressTable);

//=============================================================================
//  MISC. API's
//=============================================================================

DWORD                WINAPI BhGetWindowsVersion(VOID);

BOOL                 WINAPI IsDaytona(VOID);

VOID                 _cdecl dprintf(__in LPSTR format, ...);

//=============================================================================
//=============================================================================
//  (BHTypes.h)
//=============================================================================
//=============================================================================
//=============================================================================
//  Unaligned base type definitions.
//=============================================================================
typedef VOID        UNALIGNED   *ULPVOID;
typedef BYTE        UNALIGNED   *ULPBYTE;
typedef WORD        UNALIGNED   *ULPWORD;
typedef DWORD       UNALIGNED   *ULPDWORD;
typedef CHAR        UNALIGNED   *ULPSTR;
typedef SYSTEMTIME  UNALIGNED   *ULPSYSTEMTIME;
//=============================================================================
//  Handle definitions.
//=============================================================================
typedef struct _PARSER *HPARSER;

typedef struct _CAPFRAMEDESC *HFRAME;

typedef struct _CAPTURE *HCAPTURE;

typedef struct _FILTER *HFILTER;

typedef struct _ADDRESSDB *HADDRESSDB;

typedef struct _PROTOCOL *HPROTOCOL;

typedef DWORD_PTR HPROPERTY;

typedef HPROTOCOL *LPHPROTOCOL;

//=============================================================================
//  GetTableSize() -- The following macro is used to calculate the actual
//                    length of Network Monitor variable-length table structures.
//
//  EXAMPLE:
//
//  GetTableSize(PROTOCOLTABLESIZE, 
//               ProtocolTable->nProtocols, 
//               sizeof(HPROTOCOL))
//=============================================================================
#define GetTableSize(TableBaseSize, nElements, ElementSize) ((TableBaseSize) + ((nElements) * (ElementSize)))
//=============================================================================
//  Object type identifiers.
//=============================================================================
typedef DWORD OBJECTTYPE;

#ifndef MAKE_IDENTIFIER
#define MAKE_IDENTIFIER(a, b, c, d)     ((DWORD) MAKELONG(MAKEWORD(a, b), MAKEWORD(c, d)))
#endif // MAKE_IDENTIFIER
#define HANDLE_TYPE_INVALID             MAKE_IDENTIFIER(-1, -1, -1, -1)
#define HANDLE_TYPE_CAPTURE             MAKE_IDENTIFIER('C', 'A', 'P', '$')
#define HANDLE_TYPE_PARSER              MAKE_IDENTIFIER('P', 'S', 'R', '$')
#define HANDLE_TYPE_ADDRESSDB           MAKE_IDENTIFIER('A', 'D', 'R', '$')
#define HANDLE_TYPE_PROTOCOL            MAKE_IDENTIFIER('P', 'R', 'T', '$')
#define HANDLE_TYPE_BUFFER              MAKE_IDENTIFIER('B', 'U', 'F', '$')
//=============================================================================
//  Network Monitor constant definitions.
//=============================================================================
#define INLINE  __inline
#define BHAPI   WINAPI
#define	MAX_NAME_LENGTH	( 16 )

#define	MAX_ADDR_LENGTH	( 6 )

//=============================================================================
//  Ethernet type (ETYPE) constant definitions.
//=============================================================================
#define	ETYPE_LOOP	( 0x9000 )

#define	ETYPE_3COM_NETMAP1	( 0x9001 )

#define	ETYPE_3COM_NETMAP2	( 0x9002 )

#define	ETYPE_IBM_RT	( 0x80d5 )

#define	ETYPE_NETWARE	( 0x8137 )

#define	ETYPE_XNS1	( 0x600 )

#define	ETYPE_XNS2	( 0x807 )

#define	ETYPE_3COM_NBP0	( 0x3c00 )

#define	ETYPE_3COM_NBP1	( 0x3c01 )

#define	ETYPE_3COM_NBP2	( 0x3c02 )

#define	ETYPE_3COM_NBP3	( 0x3c03 )

#define	ETYPE_3COM_NBP4	( 0x3c04 )

#define	ETYPE_3COM_NBP5	( 0x3c05 )

#define	ETYPE_3COM_NBP6	( 0x3c06 )

#define	ETYPE_3COM_NBP7	( 0x3c07 )

#define	ETYPE_3COM_NBP8	( 0x3c08 )

#define	ETYPE_3COM_NBP9	( 0x3c09 )

#define	ETYPE_3COM_NBP10	( 0x3c0a )

#define	ETYPE_IP	( 0x800 )

#define	ETYPE_ARP1	( 0x806 )

#define	ETYPE_ARP2	( 0x807 )

#define	ETYPE_RARP	( 0x8035 )

#define	ETYPE_TRLR0	( 0x1000 )

#define	ETYPE_TRLR1	( 0x1001 )

#define	ETYPE_TRLR2	( 0x1002 )

#define	ETYPE_TRLR3	( 0x1003 )

#define	ETYPE_TRLR4	( 0x1004 )

#define	ETYPE_TRLR5	( 0x1005 )

#define	ETYPE_PUP	( 0x200 )

#define	ETYPE_PUP_ARP	( 0x201 )

#define	ETYPE_APPLETALK_ARP	( 0x80f3 )

#define	ETYPE_APPLETALK_LAP	( 0x809b )

#define	ETYPE_SNMP	( 0x814c )

//=============================================================================
//  LLC (802.2) SAP constant definitions.
//=============================================================================
#define	SAP_SNAP	( 0xaa )

#define	SAP_BPDU	( 0x42 )

#define	SAP_IBM_NM	( 0xf4 )

#define	SAP_IBM_NETBIOS	( 0xf0 )

#define	SAP_SNA1	( 0x4 )

#define	SAP_SNA2	( 0x5 )

#define	SAP_SNA3	( 0x8 )

#define	SAP_SNA4	( 0xc )

#define	SAP_NETWARE1	( 0x10 )

#define	SAP_NETWARE2	( 0xe0 )

#define	SAP_NETWARE3	( 0xfe )

#define	SAP_IP	( 0x6 )

#define	SAP_X25	( 0x7e )

#define	SAP_RPL1	( 0xf8 )

#define	SAP_RPL2	( 0xfc )

#define	SAP_UB	( 0xfa )

#define	SAP_XNS	( 0x80 )

//=============================================================================
//  Property constants
//=============================================================================
// data types
#define	PROP_TYPE_VOID	( 0 )

#define	PROP_TYPE_SUMMARY	( 0x1 )

#define	PROP_TYPE_BYTE	( 0x2 )

#define	PROP_TYPE_WORD	( 0x3 )

#define	PROP_TYPE_DWORD	( 0x4 )

#define	PROP_TYPE_LARGEINT	( 0x5 )

#define	PROP_TYPE_ADDR	( 0x6 )

#define	PROP_TYPE_TIME	( 0x7 )

#define	PROP_TYPE_STRING	( 0x8 )

#define	PROP_TYPE_IP_ADDRESS	( 0x9 )

#define	PROP_TYPE_IPX_ADDRESS	( 0xa )

#define	PROP_TYPE_BYTESWAPPED_WORD	( 0xb )

#define	PROP_TYPE_BYTESWAPPED_DWORD	( 0xc )

#define	PROP_TYPE_TYPED_STRING	( 0xd )

#define	PROP_TYPE_RAW_DATA	( 0xe )

#define	PROP_TYPE_COMMENT	( 0xf )

#define	PROP_TYPE_SRCFRIENDLYNAME	( 0x10 )

#define	PROP_TYPE_DSTFRIENDLYNAME	( 0x11 )

#define	PROP_TYPE_TOKENRING_ADDRESS	( 0x12 )

#define	PROP_TYPE_FDDI_ADDRESS	( 0x13 )

#define	PROP_TYPE_ETHERNET_ADDRESS	( 0x14 )

#define	PROP_TYPE_OBJECT_IDENTIFIER	( 0x15 )

#define	PROP_TYPE_VINES_IP_ADDRESS	( 0x16 )

#define	PROP_TYPE_VAR_LEN_SMALL_INT	( 0x17 )

#define	PROP_TYPE_ATM_ADDRESS	( 0x18 )

#define	PROP_TYPE_1394_ADDRESS	( 0x19 )

#define	PROP_TYPE_IP6_ADDRESS	( 0x1a )

// data qualifiers
#define	PROP_QUAL_NONE	( 0 )

#define	PROP_QUAL_RANGE	( 0x1 )

#define	PROP_QUAL_SET	( 0x2 )

#define	PROP_QUAL_BITFIELD	( 0x3 )

#define	PROP_QUAL_LABELED_SET	( 0x4 )

#define	PROP_QUAL_LABELED_BITFIELD	( 0x8 )

#define	PROP_QUAL_CONST	( 0x9 )

#define	PROP_QUAL_FLAGS	( 0xa )

#define	PROP_QUAL_ARRAY	( 0xb )

//=============================================================================
//  LARGEINT structure defined in winnt.h
//=============================================================================
typedef LARGE_INTEGER *LPLARGEINT;

typedef LARGE_INTEGER UNALIGNED *ULPLARGEINT;
//=============================================================================
//  Range structure.
//=============================================================================
typedef struct _RANGE
    {
    DWORD MinValue;
    DWORD MaxValue;
    } 	RANGE;

typedef RANGE *LPRANGE;

//=============================================================================
//  LABELED_BYTE structure
//=============================================================================
typedef struct _LABELED_BYTE
    {
    BYTE Value;
    LPSTR Label;
    } 	LABELED_BYTE;

typedef LABELED_BYTE *LPLABELED_BYTE;

//=============================================================================
//  LABELED_WORD structure
//=============================================================================
typedef struct _LABELED_WORD
    {
    WORD Value;
    LPSTR Label;
    } 	LABELED_WORD;

typedef LABELED_WORD *LPLABELED_WORD;

//=============================================================================
//  LABELED_DWORD structure
//=============================================================================
typedef struct _LABELED_DWORD
    {
    DWORD Value;
    LPSTR Label;
    } 	LABELED_DWORD;

typedef LABELED_DWORD *LPLABELED_DWORD;

//=============================================================================
//  LABELED_LARGEINT structure
//=============================================================================
typedef struct _LABELED_LARGEINT
    {
    LARGE_INTEGER Value;
    LPSTR Label;
    } 	LABELED_LARGEINT;

typedef LABELED_LARGEINT *LPLABELED_LARGEINT;

//=============================================================================
//  LABELED_SYSTEMTIME structure
//=============================================================================
typedef struct _LABELED_SYSTEMTIME
    {
    SYSTEMTIME Value;
    LPSTR Label;
    } 	LABELED_SYSTEMTIME;

typedef LABELED_SYSTEMTIME *LPLABELED_SYSTEMTIME;

//=============================================================================
//  LABELED_BIT structure
//=============================================================================
// BitNumber starts at 0, up to 256 bits.
typedef struct _LABELED_BIT
    {
    BYTE BitNumber;
    LPSTR LabelOff;
    LPSTR LabelOn;
    } 	LABELED_BIT;

typedef LABELED_BIT *LPLABELED_BIT;

//=============================================================================
//  TYPED_STRING structure
//=============================================================================
#define	TYPED_STRING_NORMAL	( 1 )

#define	TYPED_STRING_UNICODE	( 2 )

#define	TYPED_STRING_EXFLAG	( 1 )

// Typed Strings are always Ex, so to actually Ex we set fStringEx and put the Ex data in Byte
typedef struct _TYPED_STRING
{
    BYTE    StringType:7;
    BYTE    fStringEx:1;
    LPSTR   lpString;
    BYTE    Byte[0];
} TYPED_STRING;

typedef TYPED_STRING *LPTYPED_STRING;
//=============================================================================
//  OBJECT_IDENTIFIER structure
//=============================================================================
typedef struct _OBJECT_IDENTIFIER
    {
    DWORD Length;
    LPDWORD lpIdentifier;
    } 	OBJECT_IDENTIFIER;

typedef OBJECT_IDENTIFIER *LPOBJECT_IDENTIFIER;

//=============================================================================
//  Set structure.
//=============================================================================
typedef struct _SET
    {
    DWORD nEntries;
    union 
        {
        LPVOID lpVoidTable;
        LPBYTE lpByteTable;
        LPWORD lpWordTable;
        LPDWORD lpDwordTable;
        LPLARGEINT lpLargeIntTable;
        LPSYSTEMTIME lpSystemTimeTable;
        LPLABELED_BYTE lpLabeledByteTable;
        LPLABELED_WORD lpLabeledWordTable;
        LPLABELED_DWORD lpLabeledDwordTable;
        LPLABELED_LARGEINT lpLabeledLargeIntTable;
        LPLABELED_SYSTEMTIME lpLabeledSystemTimeTable;
        LPLABELED_BIT lpLabeledBit;
        } 	;
    } 	SET;

typedef SET *LPSET;

//=============================================================================
//  String table.
//=============================================================================
typedef struct _STRINGTABLE
{
    DWORD           nStrings;
    LPSTR           String[0];

} STRINGTABLE;

typedef STRINGTABLE *LPSTRINGTABLE;
#define STRINGTABLE_SIZE    sizeof(STRINGTABLE)

//=============================================================================
//  RECOGNIZEDATA structure.
//
//  This structure to keep track of the start of each recognized protocol.
//=============================================================================
typedef struct _RECOGNIZEDATA
    {
    WORD ProtocolID;
    WORD nProtocolOffset;
    LPVOID InstData;
    } 	RECOGNIZEDATA;

typedef RECOGNIZEDATA *LPRECOGNIZEDATA;

//=============================================================================
//  RECOGNIZEDATATABLE structure.
//
//  This structure to keep track of the start of each RECOGNIZEDATA structure
//=============================================================================
typedef struct _RECOGNIZEDATATABLE
{
    WORD            nRecognizeDatas;    //... number of RECOGNIZEDATA structures
    RECOGNIZEDATA   RecognizeData[0];   //... array of RECOGNIZEDATA structures follows

} RECOGNIZEDATATABLE;

typedef RECOGNIZEDATATABLE * LPRECOGNIZEDATATABLE;

//=============================================================================
//  Property information structure.
//=============================================================================
typedef struct _PROPERTYINFO
    {
    HPROPERTY hProperty;
    DWORD Version;
    LPSTR Label;
    LPSTR Comment;
    BYTE DataType;
    BYTE DataQualifier;
    union 
        {
        LPVOID lpExtendedInfo;
        LPRANGE lpRange;
        LPSET lpSet;
        DWORD Bitmask;
        DWORD Value;
        } 	;
    WORD FormatStringSize;
    LPVOID InstanceData;
    } 	PROPERTYINFO;

typedef PROPERTYINFO *LPPROPERTYINFO;

#define	PROPERTYINFO_SIZE	( sizeof( PROPERTYINFO  ) )

//=============================================================================
//  Property instance Extended structure.
//=============================================================================
typedef struct _PROPERTYINSTEX
{
    WORD        Length;         //... length of raw data in frame
    WORD        LengthEx;       //... number of bytes following
    ULPVOID     lpData;         //... pointer to raw data in frame

    union
    {
        BYTE            Byte[];     //... table of bytes follows
        WORD            Word[];     //... table of words follows
        DWORD           Dword[];    //... table of Dwords follows
        LARGE_INTEGER   LargeInt[]; //... table of LARGEINT structures to follow
        SYSTEMTIME      SysTime[];  //... table of SYSTEMTIME structures follows
        TYPED_STRING    TypedString;//... a typed_string that may have extended data
    };
} PROPERTYINSTEX;
typedef PROPERTYINSTEX *LPPROPERTYINSTEX;
typedef PROPERTYINSTEX UNALIGNED *ULPPROPERTYINSTEX;
#define PROPERTYINSTEX_SIZE     sizeof(PROPERTYINSTEX)
//=============================================================================
//  Property instance structure.
//=============================================================================
typedef struct _PROPERTYINST
{
    LPPROPERTYINFO          lpPropertyInfo;     // pointer to property info
    LPSTR                   szPropertyText;     // pointer to string description

    union
    {
        LPVOID              lpData;             // pointer to data
        ULPBYTE             lpByte;             // bytes
        ULPWORD             lpWord;             // words
        ULPDWORD            lpDword;            // dwords

        ULPLARGEINT         lpLargeInt;         // LargeInt
        ULPSYSTEMTIME       lpSysTime;          // pointer to SYSTEMTIME structures
        LPPROPERTYINSTEX    lpPropertyInstEx;   // pointer to propertyinstex (if DataLength = -1)
    };

    WORD                    DataLength;         // length of data, or flag for propertyinstex struct
    WORD                    Level   : 4  ;      // level information        ............1111
    WORD                    HelpID  : 12 ;      // context ID for helpfile  111111111111....
                     //    ---------------
                     // total of 16 bits == 1 WORD == DWORD ALIGNED structure
                            // Interpretation Flags:  Flags that define attach time information to the
                            // interpretation of the property.  For example, in RPC, the client can be
                            // Intel format and the server can be non-Intel format... thus the property
                            // database cannot describe the property at database creation time.
    DWORD                   IFlags;

} PROPERTYINST;
typedef PROPERTYINST *LPPROPERTYINST;
#define PROPERTYINST_SIZE   sizeof(PROPERTYINST)

// Flags passed at AttachPropertyInstance and AttachPropertyInstanceEx time in the IFlags field:
// flag for error condition ...............1
#define	IFLAG_ERROR	( 0x1 )

// is the WORD or DWORD byte non-Intel format at attach time?
#define	IFLAG_SWAPPED	( 0x2 )

// is the STRING UNICODE at attach time?
#define	IFLAG_UNICODE	( 0x4 )

//=============================================================================
//  Property instance table structure.
//=============================================================================
typedef struct _PROPERTYINSTTABLE
    {
    WORD nPropertyInsts;
    WORD nPropertyInstIndex;
    } 	PROPERTYINSTTABLE;

typedef PROPERTYINSTTABLE *LPPROPERTYINSTTABLE;

#define	PROPERTYINSTTABLE_SIZE	( sizeof( PROPERTYINSTTABLE  ) )

//=============================================================================
//  Property table structure.
//=============================================================================
typedef struct _PROPERTYTABLE
{
    LPVOID                  lpFormatBuffer;             //... Opaque.                       (PRIVATE)
    DWORD                   FormatBufferLength;         //... Opaque.                       (PRIVATE)
    DWORD                   nTotalPropertyInsts;        //... total number of propertyinstances in array
    LPPROPERTYINST          lpFirstPropertyInst;        //... array of property instances
    BYTE                    nPropertyInstTables;        //... total PropertyIndexTables following
    PROPERTYINSTTABLE       PropertyInstTable[0];       //... array of propertyinstance index table structures

} PROPERTYTABLE;

typedef PROPERTYTABLE *LPPROPERTYTABLE;

#define PROPERTYTABLE_SIZE sizeof(PROPERTYTABLE)
//=============================================================================
//  Protocol entry points.
//=============================================================================

typedef VOID    (WINAPI *REGISTER)(HPROTOCOL);

typedef VOID    (WINAPI *DEREGISTER)(HPROTOCOL);

typedef LPBYTE  (WINAPI *RECOGNIZEFRAME)(HFRAME, ULPBYTE, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, PDWORD_PTR);

typedef LPBYTE  (WINAPI *ATTACHPROPERTIES)(HFRAME, ULPBYTE, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, DWORD_PTR);

typedef DWORD   (WINAPI *FORMATPROPERTIES)(HFRAME, ULPBYTE, ULPBYTE, DWORD, LPPROPERTYINST);

//=============================================================================
//  Protocol entry point structure.
//=============================================================================

typedef struct _ENTRYPOINTS
{
    REGISTER            Register;               //... Protocol Register() entry point.
    DEREGISTER          Deregister;             //... Protocol Deregister() entry point.
    RECOGNIZEFRAME      RecognizeFrame;         //... Protocol RecognizeFrame() entry point.
    ATTACHPROPERTIES    AttachProperties;       //... Protocol AttachProperties() entry point.
    FORMATPROPERTIES    FormatProperties;       //... Protocol FormatProperties() entry point.

} ENTRYPOINTS;

typedef ENTRYPOINTS *LPENTRYPOINTS;

#define ENTRYPOINTS_SIZE sizeof(ENTRYPOINTS)

//=============================================================================
//  Property database structure.
//=============================================================================
typedef struct _PROPERTYDATABASE
{
    DWORD           nProperties;                 //... Number of properties in database.
    LPPROPERTYINFO  PropertyInfo[0];             //... Array of property info pointers.

} PROPERTYDATABASE;
#define PROPERTYDATABASE_SIZE   sizeof(PROPERTYDATABASE)
typedef PROPERTYDATABASE *LPPROPERTYDATABASE;

//=============================================================================
//  Protocol info structure (PUBLIC portion of HPROTOCOL).
//=============================================================================
typedef struct _PROTOCOLINFO
{
    DWORD               ProtocolID;             //... Prootocol ID of owning protocol.
    LPPROPERTYDATABASE  PropertyDatabase;       //... Property database.
    BYTE                ProtocolName[16];       //... Protocol name.
    BYTE                HelpFile[16];           //... Optional helpfile name.
    BYTE                Comment[128];           //... Comment describing protocol.
} PROTOCOLINFO;
typedef PROTOCOLINFO *LPPROTOCOLINFO;
#define PROTOCOLINFO_SIZE   sizeof(PROTOCOLINFO)

//=============================================================================
//  Protocol Table.
//=============================================================================
typedef struct _PROTOCOLTABLE
    {
    DWORD nProtocols;
    HPROTOCOL hProtocol[ 1 ];
    } 	PROTOCOLTABLE;

typedef PROTOCOLTABLE *LPPROTOCOLTABLE;

#define	PROTOCOLTABLE_SIZE	( ( sizeof( PROTOCOLTABLE  ) - sizeof( HPROTOCOL  ) )  )

#define PROTOCOLTABLE_ACTUAL_SIZE(p) GetTableSize(PROTOCOLTABLE_SIZE, (p)->nProtocols, sizeof(HPROTOCOL))
//=============================================================================
//  AddressInfo structure
//=============================================================================
#define	SORT_BYADDRESS	( 0 )

#define	SORT_BYNAME	( 1 )

#define	PERMANENT_NAME	( 0x100 )

typedef struct _ADDRESSINFO2
{
    ADDRESS2       Address;
    WCHAR          Name[MAX_NAME_SIZE];
    DWORD          Flags;
    LPVOID         lpAddressInstData;

} ADDRESSINFO2;
typedef struct _ADDRESSINFO2 *LPADDRESSINFO2;
#define ADDRESSINFO2_SIZE    sizeof(ADDRESSINFO2)
//=============================================================================
//  AddressInfoTable
//=============================================================================
typedef struct _ADDRESSINFOTABLE2
{
    DWORD         nAddressInfos;
    LPADDRESSINFO2 lpAddressInfo[0];

} ADDRESSINFOTABLE2;
typedef ADDRESSINFOTABLE2 *LPADDRESSINFOTABLE2;
#define ADDRESSINFOTABLE2_SIZE   sizeof(ADDRESSINFOTABLE2)
//=============================================================================
//  callback procedures.
//=============================================================================

typedef DWORD (WINAPI *FILTERPROC)(HCAPTURE, HFRAME, LPVOID);

//=============================================================================
//=============================================================================
//  (NMErr.h)
//=============================================================================
//=============================================================================
//  The operation succeeded.
#define	NMERR_SUCCESS	( 0 )

//  An error occured creating a memory-mapped file.
#define	NMERR_MEMORY_MAPPED_FILE_ERROR	( 1 )

//  The handle to a filter is invalid.
#define	NMERR_INVALID_HFILTER	( 2 )

//  Capturing has already been started.
#define	NMERR_CAPTURING	( 3 )

//  Capturing has not been started.
#define	NMERR_NOT_CAPTURING	( 4 )

//  The are no frames available.
#define	NMERR_NO_MORE_FRAMES	( 5 )

//  The buffer is too small to complete the operation.
#define	NMERR_BUFFER_TOO_SMALL	( 6 )

//  No protocol was able to recognize the frame.
#define	NMERR_FRAME_NOT_RECOGNIZED	( 7 )

//  The file already exists.
#define	NMERR_FILE_ALREADY_EXISTS	( 8 )

//  A needed device driver was not found or is not loaded.
#define	NMERR_DRIVER_NOT_FOUND	( 9 )

//  This address aready exists in the database.
#define	NMERR_ADDRESS_ALREADY_EXISTS	( 10 )

//  The frame handle is invalid.
#define	NMERR_INVALID_HFRAME	( 11 )

//  The protocol handle is invalid.
#define	NMERR_INVALID_HPROTOCOL	( 12 )

//  The property handle is invalid.
#define	NMERR_INVALID_HPROPERTY	( 13 )

//  The the object has been locked.  
#define	NMERR_LOCKED	( 14 )

//  A pop operation was attempted on an empty stack.
#define	NMERR_STACK_EMPTY	( 15 )

//  A push operation was attempted on an full stack.
#define	NMERR_STACK_OVERFLOW	( 16 )

//  There are too many protocols active.
#define	NMERR_TOO_MANY_PROTOCOLS	( 17 )

//  The file was not found.
#define	NMERR_FILE_NOT_FOUND	( 18 )

//  No memory was available.  Shut down windows to free up resources.
#define	NMERR_OUT_OF_MEMORY	( 19 )

//  The capture is already in the paused state.
#define	NMERR_CAPTURE_PAUSED	( 20 )

//  There are no buffers available or present.
#define	NMERR_NO_BUFFERS	( 21 )

//  There are already buffers present.
#define	NMERR_BUFFERS_ALREADY_EXIST	( 22 )

//  The object is not locked.
#define	NMERR_NOT_LOCKED	( 23 )

//  A integer type was out of range.
#define	NMERR_OUT_OF_RANGE	( 24 )

//  An object was locked too many times.
#define	NMERR_LOCK_NESTING_TOO_DEEP	( 25 )

//  A parser failed to load.
#define	NMERR_LOAD_PARSER_FAILED	( 26 )

//  A parser failed to unload.
#define	NMERR_UNLOAD_PARSER_FAILED	( 27 )

//  The address database handle is invalid.
#define	NMERR_INVALID_HADDRESSDB	( 28 )

//  The MAC address was not found in the database.
#define	NMERR_ADDRESS_NOT_FOUND	( 29 )

//  The network software was not found in the system.
#define	NMERR_NETWORK_NOT_PRESENT	( 30 )

//  There is no property database for a protocol.
#define	NMERR_NO_PROPERTY_DATABASE	( 31 )

//  A property was not found in the database.
#define	NMERR_PROPERTY_NOT_FOUND	( 32 )

//  The property database handle is in valid.
#define	NMERR_INVALID_HPROPERTYDB	( 33 )

//  The protocol has not been enabled.
#define	NMERR_PROTOCOL_NOT_ENABLED	( 34 )

//  The protocol DLL could not be found.
#define	NMERR_PROTOCOL_NOT_FOUND	( 35 )

//  The parser DLL is not valid.
#define	NMERR_INVALID_PARSER_DLL	( 36 )

//  There are no properties attached.
#define	NMERR_NO_ATTACHED_PROPERTIES	( 37 )

//  There are no frames in the buffer.
#define	NMERR_NO_FRAMES	( 38 )

//  The capture file format is not valid.
#define	NMERR_INVALID_FILE_FORMAT	( 39 )

//  The OS could not create a temporary file.
#define	NMERR_COULD_NOT_CREATE_TEMPFILE	( 40 )

//  There is not enough MS-DOS memory available.
#define	NMERR_OUT_OF_DOS_MEMORY	( 41 )

//  There are no protocols enabled.
#define	NMERR_NO_PROTOCOLS_ENABLED	( 42 )

//  The MAC type is invalid or unsupported.
#define	NMERR_UNKNOWN_MACTYPE	( 46 )

//  There is no routing information present in the MAC frame.
#define	NMERR_ROUTING_INFO_NOT_PRESENT	( 47 )

//  The network handle is invalid.
#define	NMERR_INVALID_HNETWORK	( 48 )

//  The network is already open.
#define	NMERR_NETWORK_ALREADY_OPENED	( 49 )

//  The network is not open.
#define	NMERR_NETWORK_NOT_OPENED	( 50 )

//  The frame was not found in the buffer.
#define	NMERR_FRAME_NOT_FOUND	( 51 )

//  There are no handles available.
#define	NMERR_NO_HANDLES	( 53 )

//  The network ID is invalid.
#define	NMERR_INVALID_NETWORK_ID	( 54 )

//  The capture handle is invalid.
#define	NMERR_INVALID_HCAPTURE	( 55 )

//  The protocol has already been enabled.
#define	NMERR_PROTOCOL_ALREADY_ENABLED	( 56 )

//  The filter expression is invalid.
#define	NMERR_FILTER_INVALID_EXPRESSION	( 57 )

//  A transmit error occured.
#define	NMERR_TRANSMIT_ERROR	( 58 )

//  The buffer handle is invalid.
#define	NMERR_INVALID_HBUFFER	( 59 )

//  The specified data is unknown or invalid.
#define	NMERR_INVALID_DATA	( 60 )

//  The MS-DOS/NDIS 2.0 network driver is not loaded.
#define	NMERR_MSDOS_DRIVER_NOT_LOADED	( 61 )

//  The Windows VxD/NDIS 3.0 network driver is not loaded.
#define	NMERR_WINDOWS_DRIVER_NOT_LOADED	( 62 )

//  The MS-DOS/NDIS 2.0 driver had an init-time failure.
#define	NMERR_MSDOS_DRIVER_INIT_FAILURE	( 63 )

//  The Windows/NDIS 3.0 driver had an init-time failure.
#define	NMERR_WINDOWS_DRIVER_INIT_FAILURE	( 64 )

//  The network driver is busy and cannot handle requests.
#define	NMERR_NETWORK_BUSY	( 65 )

//  The capture is not paused.
#define	NMERR_CAPTURE_NOT_PAUSED	( 66 )

//  The frame/packet length is not valid.
#define	NMERR_INVALID_PACKET_LENGTH	( 67 )

//  An internal exception occured.
#define	NMERR_INTERNAL_EXCEPTION	( 69 )

//  The MAC driver does not support promiscious mode.
#define	NMERR_PROMISCUOUS_MODE_NOT_SUPPORTED	( 70 )

//  The MAC driver failed to open.
#define	NMERR_MAC_DRIVER_OPEN_FAILURE	( 71 )

//  The protocol went off the end of the frame.
#define	NMERR_RUNAWAY_PROTOCOL	( 72 )

//  An asynchronous operation is still pending.
#define	NMERR_PENDING	( 73 )

//  Access is denied.
#define	NMERR_ACCESS_DENIED	( 74 )

//  The password handle is invalid.
#define	NMERR_INVALID_HPASSWORD	( 75 )

//  A bad parameter was detected.
#define	NMERR_INVALID_PARAMETER	( 76 )

//  An error occured reading the file.
#define	NMERR_FILE_READ_ERROR	( 77 )

//  An error occured writing to the file.
#define	NMERR_FILE_WRITE_ERROR	( 78 )

//  The protocol has not been registered
#define	NMERR_PROTOCOL_NOT_REGISTERED	( 79 )

//  The frame does not contain an IP address.
#define	NMERR_IP_ADDRESS_NOT_FOUND	( 80 )

//  The transmit request was cancelled.
#define	NMERR_TRANSMIT_CANCELLED	( 81 )

//  The operation cannot be performed on a capture with 1 or more locked frames.
#define	NMERR_LOCKED_FRAMES	( 82 )

//  A cancel transmit request was submitted but there were no transmits pending.
#define	NMERR_NO_TRANSMITS_PENDING	( 83 )

//  Path not found.
#define	NMERR_PATH_NOT_FOUND	( 84 )

//  A windows error has occured.
#define	NMERR_WINDOWS_ERROR	( 85 )

//  The handle to the frame has no frame number.
#define	NMERR_NO_FRAME_NUMBER	( 86 )

//  The frame is not associated with any capture.
#define	NMERR_FRAME_HAS_NO_CAPTURE	( 87 )

//  The frame is already associated with a capture.
#define	NMERR_FRAME_ALREADY_HAS_CAPTURE	( 88 )

//  The NAL is not remotable.
#define	NMERR_NAL_IS_NOT_REMOTE	( 89 )

//  The API is not supported
#define	NMERR_NOT_SUPPORTED	( 90 )

//  Network Monitor should discard the current frame. 
//  This error code is only used during a filtered SaveCapture() API call.
#define	NMERR_DISCARD_FRAME	( 91 )

//  Network Monitor should cancel the current save. 
//  This error code is only used during a filtered SaveCapture() API call.
#define	NMERR_CANCEL_SAVE_CAPTURE	( 92 )

//  The connection to the remote machine has been lost
#define	NMERR_LOST_CONNECTION	( 93 )

//  The media/mac type is not valid.
#define	NMERR_INVALID_MEDIA_TYPE	( 94 )

//  The Remote Agent is currently in use
#define	NMERR_AGENT_IN_USE	( 95 )

//  The request has timed out
#define	NMERR_TIMEOUT	( 96 )

//  The remote agent has been disconnected
#define	NMERR_DISCONNECTED	( 97 )

//  A timer required for operation failed creation
#define	NMERR_SETTIMER_FAILED	( 98 )

//  A network error occured.
#define	NMERR_NETWORK_ERROR	( 99 )

//  Frame callback procedure is not valid
#define	NMERR_INVALID_FRAMESPROC	( 100 )

//  Capture type specified is unknown
#define	NMERR_UNKNOWN_CAPTURETYPE	( 101 )

// The NPP is not connected to a network.
#define	NMERR_NOT_CONNECTED	( 102 )

// The NPP is already connected to a network.
#define	NMERR_ALREADY_CONNECTED	( 103 )

// The registry tag does not indicate a known configuration.
#define	NMERR_INVALID_REGISTRY_CONFIGURATION	( 104 )

// The NPP is currently configured for delayed capturing.
#define	NMERR_DELAYED	( 105 )

// The NPP is not currently configured for delayed capturing.
#define	NMERR_NOT_DELAYED	( 106 )

// The NPP is currently configured for real time capturing.
#define	NMERR_REALTIME	( 107 )

// The NPP is not currently configured for real time capturing.
#define	NMERR_NOT_REALTIME	( 108 )

// The NPP is currently configured for stats only capturing.
#define	NMERR_STATS_ONLY	( 109 )

// The NPP is not currently configured for stats only capturing.
#define	NMERR_NOT_STATS_ONLY	( 110 )

// The NPP is currently configured for transmitting.
#define	NMERR_TRANSMIT	( 111 )

// The NPP is not currently configured for transmitting.
#define	NMERR_NOT_TRANSMIT	( 112 )

// The NPP is currently transmitting
#define	NMERR_TRANSMITTING	( 113 )

// The specified capture file hard disk is not local
#define	NMERR_DISK_NOT_LOCAL_FIXED	( 114 )

// Could not create the default capture directory on the given disk
#define	NMERR_COULD_NOT_CREATE_DIRECTORY	( 115 )

// The default capture directory was not set in the registry:
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\nm\Parameters\CapturePath
#define	NMERR_NO_DEFAULT_CAPTURE_DIRECTORY	( 116 )

//  The capture file is an uplevel version that this netmon does not understand
#define	NMERR_UPLEVEL_CAPTURE_FILE	( 117 )

//  An expert failed to load.
#define	NMERR_LOAD_EXPERT_FAILED	( 118 )

//  An expert failed to report its EXPERT_INFO structs.
#define	NMERR_EXPERT_REPORT_FAILED	( 119 )

//  Registry API call failed.
#define	NMERR_REG_OPERATION_FAILED	( 120 )

//  Registry API call failed.
#define	NMERR_NO_DLLS_FOUND	( 121 )

//  There are no conversation stats, they were not asked for.
#define	NMERR_NO_CONVERSATION_STATS	( 122 )

//  We have received a security response packet from a security monitor.
#define	NMERR_SECURITY_BREACH_CAPTURE_DELETED	( 123 )

//  The given frame failed the display filter.
#define	NMERR_FRAME_FAILED_FILTER	( 124 )

//  Netmon wants the Expert to stop running.
#define	NMERR_EXPERT_TERMINATE	( 125 )

//  Netmon needs the remote machine to be a server.
#define	NMERR_REMOTE_NOT_A_SERVER	( 126 )

//  Netmon needs the remote machine to be a server.
#define	NMERR_REMOTE_VERSION_OUTOFSYNC	( 127 )

//  The supplied group is an invalid handle
#define	NMERR_INVALID_EXPERT_GROUP	( 128 )

//  The supplied expert name cannot be found
#define	NMERR_INVALID_EXPERT_NAME	( 129 )

//  The supplied expert name cannot be found
#define	NMERR_INVALID_EXPERT_HANDLE	( 130 )

//  The supplied group name already exists
#define	NMERR_GROUP_NAME_ALREADY_EXISTS	( 131 )

//  The supplied group name is invalid
#define	NMERR_INVALID_GROUP_NAME	( 132 )

//  The supplied Expert is already in the group.  
#define	NMERR_EXPERT_ALREADY_IN_GROUP	( 133 )

//  The Expert cannot be deleted from the group because it is not in the group
#define	NMERR_EXPERT_NOT_IN_GROUP	( 134 )

//  The COM object has not been initialized
#define	NMERR_NOT_INITIALIZED	( 135 )

//  Cannot perform function to Root group
#define	NMERR_INVALID_GROUP_ROOT	( 136 )

//  Potential data structure mismatch between NdisNpp and Driver.
#define	NMERR_BAD_VERSION	( 137 )

// The NPP is currently configured for ESP capturing.
#define	NMERR_ESP	( 138 )

// The NPP is not currently configured for ESP capturing.
#define	NMERR_NOT_ESP	( 139 )

//=============================================================================
// Blob Errors
//=============================================================================
#define	NMERR_BLOB_NOT_INITIALIZED	( 1000 )

#define	NMERR_INVALID_BLOB	( 1001 )

#define	NMERR_UPLEVEL_BLOB	( 1002 )

#define	NMERR_BLOB_ENTRY_ALREADY_EXISTS	( 1003 )

#define	NMERR_BLOB_ENTRY_DOES_NOT_EXIST	( 1004 )

#define	NMERR_AMBIGUOUS_SPECIFIER	( 1005 )

#define	NMERR_BLOB_OWNER_NOT_FOUND	( 1006 )

#define	NMERR_BLOB_CATEGORY_NOT_FOUND	( 1007 )

#define	NMERR_UNKNOWN_CATEGORY	( 1008 )

#define	NMERR_UNKNOWN_TAG	( 1009 )

#define	NMERR_BLOB_CONVERSION_ERROR	( 1010 )

#define	NMERR_ILLEGAL_TRIGGER	( 1011 )

#define	NMERR_BLOB_STRING_INVALID	( 1012 )

//=============================================================================
// FINDER errors
//=============================================================================
#define	NMERR_UNABLE_TO_LOAD_LIBRARY	( 1013 )

#define	NMERR_UNABLE_TO_GET_PROCADDR	( 1014 )

#define	NMERR_CLASS_NOT_REGISTERED	( 1015 )

#define	NMERR_INVALID_REMOTE_COMPUTERNAME	( 1016 )

#define	NMERR_RPC_REMOTE_FAILURE	( 1017 )

#define	NMERR_NO_NPPS	( 3016 )

#define	NMERR_NO_MATCHING_NPPS	( 3017 )

#define	NMERR_NO_NPP_SELECTED	( 3018 )

#define	NMERR_NO_INPUT_BLOBS	( 3019 )

#define	NMERR_NO_NPP_DLLS	( 3020 )

#define	NMERR_NO_VALID_NPP_DLLS	( 3021 )

//=============================================================================
// Error Macros
//=============================================================================
#ifndef INLINE
#define INLINE __inline
#endif // INLINE
// normal Network Monitor errors will be put into the code portion of an hresult
// for return from OLE objects:
// these two macros will help to create and crack the scode
INLINE HRESULT NMERR_TO_HRESULT( DWORD nmerror )
{
    HRESULT hResult;
    if (nmerror == NMERR_SUCCESS)
        hResult = NOERROR;
    else
        hResult = MAKE_HRESULT( SEVERITY_ERROR,FACILITY_ITF, (WORD)nmerror) ;

    return hResult;
}
//We use to decide whether the first bit was set to 1 or 0, not regarding 
//whether the result passed with a warning set in the low word.  Now we 
//disregard the first bit and pass back the warning.
INLINE DWORD HRESULT_TO_NMERR( HRESULT hResult )
{
    return HRESULT_CODE(hResult);
}
//=============================================================================
//=============================================================================
//  (BHFilter.h)
//=============================================================================
//=============================================================================
//============================================================================
//  types
//============================================================================
typedef HFILTER *LPHFILTER;

typedef DWORD FILTERACTIONTYPE;

typedef DWORD VALUETYPE;

// check for protocols existing in the frame.

// ProtocolPart
// this is the raw data for a Protocol based expression
//
// WHAT             FIELD          DESCRIPTION                  EXAMPLE
// ----             -----          -----------                  -------
// Count of Protocol(nPropertyDBs) Number of protocols to pass  5
// PropertyDB Table (PropertyDB)    Table of HPROTOCOL        SMB, LLC, MAC
//
// NOTE: the nPropertyDBs field may also be the following, which implies that
// all are selected but that none have actually been put into the structure
#define	PROTOCOL_NUM_ANY	( -1 )

typedef PROTOCOLTABLE PROTOCOLTABLETYPE;

typedef PROTOCOLTABLETYPE *LPPROTOCOLTABLETYPE;

// filter bits stores who passed what filter per frame to speed up
//  the filter process...  This is actually an array.
typedef DWORD FILTERBITS;

typedef FILTERBITS *LPFILTERBITS;

typedef SYSTEMTIME *LPTIME;

typedef SYSTEMTIME UNALIGNED * ULPTIME;
// The Filter Object is the basic unit of the postfix stack.
// I need to restart the convert property to value if the comparison does not match.
// To do this, I need the original pointer to the property.  Pull the hProperty out of
// the union so that the pointer to the property is saved.
typedef struct _FILTEROBJECT2
{
    FILTERACTIONTYPE    Action;     // Object action, see codes below
    HPROPERTY           hProperty;  // property key
    union
    {
        VALUETYPE           Value;           // value of the object.
        HPROTOCOL           hProtocol;       // protocol key.
        LPVOID              lpArray;         // if array, length is ItemCount below.
        LPPROTOCOLTABLETYPE lpProtocolTable; // list of protocols to see if exist in frame.
        LPADDRESS2          lpAddress;       // kernel type address, mac or ip
        ULPLARGEINT         lpLargeInt;      // Double DWORD used by NT
        ULPTIME             lpTime;          // pointer to SYSTEMTIME
        LPOBJECT_IDENTIFIER lpOID;           // pointer to OBJECT_IDENTIFIER

    };
    union
    {
        WORD            ByteCount;      // Number of BYTES!
        WORD            ByteOffset;     // offset for array compare
    };

    struct _FILTEROBJECT2 * pNext;   // reserved

} FILTEROBJECT2;

typedef FILTEROBJECT2 * LPFILTEROBJECT2;

#define FILTERINFO_SIZE (sizeof(FILTEROBJECT2) )



typedef struct _FILTERDESC2
{
    WORD            NumEntries;
    WORD            Flags;          // private
    LPFILTEROBJECT2 lpStack;
    LPFILTEROBJECT2 lpKeepLast;
    LPVOID          UIInstanceData; // UI specific information.
    LPFILTERBITS    lpFilterBits;   // cache who passed
    LPFILTERBITS    lpCheckBits;    // have we looked at it yet?
    
} FILTERDESC2;

typedef FILTERDESC2 * LPFILTERDESC2;

#define FILTERDESC2_SIZE sizeof(FILTERDESC2)
// Obsolete, FILTEROBJECT2 should be used
typedef struct _FILTEROBJECT
{
    FILTERACTIONTYPE    Action;     // Object action, see codes below
    HPROPERTY           hProperty;  // property key
    union
    {
        VALUETYPE           Value;           // value of the object.
        HPROTOCOL           hProtocol;       // protocol key.
        LPVOID              lpArray;         // if array, length is ItemCount below.
        LPPROTOCOLTABLETYPE lpProtocolTable; // list of protocols to see if exist in frame.
        LPADDRESS           lpAddress;       // kernel type address, mac or ip
        ULPLARGEINT         lpLargeInt;      // Double DWORD used by NT
        ULPTIME             lpTime;          // pointer to SYSTEMTIME
        LPOBJECT_IDENTIFIER lpOID;           // pointer to OBJECT_IDENTIFIER

    };
    union
    {
        WORD            ByteCount;      // Number of BYTES!
        WORD            ByteOffset;     // offset for array compare
    };

    struct _FILTEROBJECT * pNext;   // reserved

} FILTEROBJECT;
typedef FILTEROBJECT * LPFILTEROBJECT;
// Obsolete, FILTERDESC2 should be used
typedef struct _FILTERDESC
{
    WORD            NumEntries;
    WORD            Flags;          // private
    LPFILTEROBJECT  lpStack;
    LPFILTEROBJECT  lpKeepLast;
    LPVOID          UIInstanceData; // UI specific information.
    LPFILTERBITS    lpFilterBits;   // cache who passed
    LPFILTERBITS    lpCheckBits;    // have we looked at it yet?
    
} FILTERDESC;
typedef FILTERDESC * LPFILTERDESC;
#define FILTERDESC_SIZE sizeof(FILTERDESC)
//============================================================================
//  Macros.
//============================================================================
#define FilterGetUIInstanceData(hfilt)         (((LPFILTERDESC2)hfilt)->UIInstanceData)
#define FilterSetUIInstanceData(hfilt,inst)    (((LPFILTERDESC2)hfilt)->UIInstanceData = (LPVOID)inst)
//============================================================================
//  defines
//============================================================================
#define	FILTERFREEPOOLSTART	( 20 )

#define	INVALIDELEMENT	( -1 )

#define	INVALIDVALUE	( ( VALUETYPE  )-9999 )

// use filter failed to check the return code on FilterFrame.
#define	FILTER_FAIL_WITH_ERROR	( -1 )

#define	FILTER_PASSED	( TRUE )

#define	FILTER_FAILED	( FALSE )

#define	FILTERACTION_INVALID	( 0 )

#define	FILTERACTION_PROPERTY	( 1 )

#define	FILTERACTION_VALUE	( 2 )

#define	FILTERACTION_STRING	( 3 )

#define	FILTERACTION_ARRAY	( 4 )

#define	FILTERACTION_AND	( 5 )

#define	FILTERACTION_OR	( 6 )

#define	FILTERACTION_XOR	( 7 )

#define	FILTERACTION_PROPERTYEXIST	( 8 )

#define	FILTERACTION_CONTAINSNC	( 9 )

#define	FILTERACTION_CONTAINS	( 10 )

#define	FILTERACTION_NOT	( 11 )

#define	FILTERACTION_EQUALNC	( 12 )

#define	FILTERACTION_EQUAL	( 13 )

#define	FILTERACTION_NOTEQUALNC	( 14 )

#define	FILTERACTION_NOTEQUAL	( 15 )

#define	FILTERACTION_GREATERNC	( 16 )

#define	FILTERACTION_GREATER	( 17 )

#define	FILTERACTION_LESSNC	( 18 )

#define	FILTERACTION_LESS	( 19 )

#define	FILTERACTION_GREATEREQUALNC	( 20 )

#define	FILTERACTION_GREATEREQUAL	( 21 )

#define	FILTERACTION_LESSEQUALNC	( 22 )

#define	FILTERACTION_LESSEQUAL	( 23 )

#define	FILTERACTION_PLUS	( 24 )

#define	FILTERACTION_MINUS	( 25 )

#define	FILTERACTION_ADDRESS	( 26 )

#define	FILTERACTION_ADDRESSANY	( 27 )

#define	FILTERACTION_FROM	( 28 )

#define	FILTERACTION_TO	( 29 )

#define	FILTERACTION_FROMTO	( 30 )

#define	FILTERACTION_AREBITSON	( 31 )

#define	FILTERACTION_AREBITSOFF	( 32 )

#define	FILTERACTION_PROTOCOLSEXIST	( 33 )

#define	FILTERACTION_PROTOCOLEXIST	( 34 )

#define	FILTERACTION_ARRAYEQUAL	( 35 )

#define	FILTERACTION_DEREFPROPERTY	( 36 )

#define	FILTERACTION_LARGEINT	( 37 )

#define	FILTERACTION_TIME	( 38 )

#define	FILTERACTION_ADDR_ETHER	( 39 )

#define	FILTERACTION_ADDR_TOKEN	( 40 )

#define	FILTERACTION_ADDR_FDDI	( 41 )

#define	FILTERACTION_ADDR_IPX	( 42 )

#define	FILTERACTION_ADDR_IP	( 43 )

#define	FILTERACTION_OID	( 44 )

#define	FILTERACTION_OID_CONTAINS	( 45 )

#define	FILTERACTION_OID_BEGINS_WITH	( 46 )

#define	FILTERACTION_OID_ENDS_WITH	( 47 )

#define	FILTERACTION_ADDR_VINES	( 48 )

#define	FILTERACTION_ADDR_IP6	( 49 )

#define	FILTERACTION_EXPRESSION	( 97 )

#define	FILTERACTION_BOOL	( 98 )

#define	FILTERACTION_NOEVAL	( 99 )

#define	FILTER_NO_MORE_FRAMES	( 0xffffffff )

#define	FILTER_CANCELED	( 0xfffffffe )

#define	FILTER_DIRECTION_NEXT	( TRUE )

#define	FILTER_DIRECTION_PREV	( FALSE )

//============================================================================
//  Helper functions.
//============================================================================
typedef BOOL (WINAPI *STATUSPROC)(DWORD, HCAPTURE, HFILTER, LPVOID);
//=============================================================================
//  FILTER API's.
//=============================================================================

HFILTER  WINAPI CreateFilter(VOID);

DWORD    WINAPI DestroyFilter(HFILTER hFilter);

HFILTER  WINAPI FilterDuplicate(HFILTER hFilter);

DWORD    WINAPI DisableParserFilter(HFILTER hFilter, HPARSER hParser);

DWORD    WINAPI EnableParserFilter(HFILTER hFilter, HPARSER hParser);

DWORD    WINAPI FilterAddObject(HFILTER hFilter, LPFILTEROBJECT2 lpFilterObject );

VOID     WINAPI FilterFlushBits(HFILTER hFilter);

DWORD    WINAPI FilterFrame(HFRAME hFrame, HFILTER hFilter, HCAPTURE hCapture);
    // returns -1 == check BH set last error
    //          0 == FALSE
    //          1 == TRUE

BOOL     WINAPI FilterAttachesProperties(HFILTER hFilter);

DWORD WINAPI FilterFindFrame (  HFILTER     hFilter,
                                HCAPTURE    hCapture,
                                DWORD       nFrame,
                                STATUSPROC  StatusProc,
                                LPVOID      UIInstance,
                                DWORD       TimeDelta,
                                BOOL        FilterDirection );

HFRAME FilterFindPropertyInstance ( HFRAME          hFrame, 
                                    HFILTER         hMasterFilter, 
                                    HCAPTURE        hCapture,
                                    HFILTER         hInstanceFilter,
                                    LPPROPERTYINST  *lpPropRestartKey,
                                    STATUSPROC      StatusProc,
                                    LPVOID          UIInstance,
                                    DWORD           TimeDelta,
                                    BOOL            FilterForward );


VOID WINAPI SetCurrentFilter(HFILTER);
HFILTER WINAPI GetCurrentFilter(VOID);

//=============================================================================
//=============================================================================
//  (Frame.h)
//=============================================================================
//=============================================================================
//=============================================================================
//  802.3 and ETHERNET MAC structure.
//=============================================================================
typedef struct _ETHERNET
{
    BYTE    DstAddr[MAX_ADDR_LENGTH];   //... destination address.
    BYTE    SrcAddr[MAX_ADDR_LENGTH];   //... source address.
    union
    {
        WORD    Length;                 //... 802.3 length field.
        WORD    Type;                   //... Ethernet type field.
    };
    BYTE    Info[0];                    //... information field.

} ETHERNET;
typedef ETHERNET *LPETHERNET;
typedef ETHERNET UNALIGNED *ULPETHERNET;
#define ETHERNET_SIZE   sizeof(ETHERNET)
#define	ETHERNET_HEADER_LENGTH	( 14 )

#define	ETHERNET_DATA_LENGTH	( 0x5dc )

#define	ETHERNET_FRAME_LENGTH	( 0x5ea )

#define	ETHERNET_FRAME_TYPE	( 0x600 )

//=============================================================================
//  Header for NM_ATM Packets.
//=============================================================================

typedef struct _NM_ATM
    {
    UCHAR DstAddr[ 6 ];
    UCHAR SrcAddr[ 6 ];
    ULONG Vpi;
    ULONG Vci;
    } 	NM_ATM;

typedef NM_ATM *PNM_ATM;

typedef NM_ATM *UPNM_ATM;

#define NM_ATM_HEADER_LENGTH sizeof(NM_ATM)

#pragma pack(push, 1)
typedef struct _NM_1394
    {
    UCHAR DstAddr[ 6 ];
    UCHAR SrcAddr[ 6 ];
    ULONGLONG VcId;
    } 	NM_1394;

typedef NM_1394 *PNM_1394;

typedef NM_1394 *UPNM_1394;

#define NM_1394_HEADER_LENGTH sizeof(NM_1394)
//=============================================================================
//  802.5 (TOKENRING) MAC structure.
//=============================================================================

// This structure is used to decode network data and so needs to be packed
typedef struct _TOKENRING
{
    BYTE    AccessCtrl;                 //... access control field.
    BYTE    FrameCtrl;                  //... frame control field.
    BYTE    DstAddr[MAX_ADDR_LENGTH];   //... destination address.
    BYTE    SrcAddr[MAX_ADDR_LENGTH];   //... source address.
    union
    {
        BYTE    Info[0];                //... information field.
        WORD    RoutingInfo[0];         //... routing information field.
    };
} TOKENRING;

typedef TOKENRING *LPTOKENRING;
typedef TOKENRING UNALIGNED *ULPTOKENRING;
#define TOKENRING_SIZE  sizeof(TOKENRING)
#define	TOKENRING_HEADER_LENGTH	( 14 )

#define	TOKENRING_SA_ROUTING_INFO	( 0x80 )

#define	TOKENRING_SA_LOCAL	( 0x40 )

#define	TOKENRING_DA_LOCAL	( 0x40 )

#define	TOKENRING_DA_GROUP	( 0x80 )

#define	TOKENRING_RC_LENGTHMASK	( 0x1f )

#define	TOKENRING_BC_MASK	( 0xe0 )

#define	TOKENRING_TYPE_MAC	( 0 )

#define	TOKENRING_TYPE_LLC	( 0x40 )


#pragma pack(pop)
//=============================================================================
//  FDDI MAC structure.
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
typedef struct _FDDI
{
    BYTE    FrameCtrl;                  //... frame control field.
    BYTE    DstAddr[MAX_ADDR_LENGTH];   //... destination address.
    BYTE    SrcAddr[MAX_ADDR_LENGTH];   //... source address.
    BYTE    Info[0];                    //... information field.

} FDDI;
#define FDDI_SIZE       sizeof(FDDI)
typedef FDDI *LPFDDI;
typedef FDDI UNALIGNED *ULPFDDI;
#define	FDDI_HEADER_LENGTH	( 13 )

#define	FDDI_TYPE_MAC	( 0 )

#define	FDDI_TYPE_LLC	( 0x10 )

#define	FDDI_TYPE_LONG_ADDRESS	( 0x40 )


#pragma pack(pop)
//=============================================================================
//  LLC (802.2)
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
typedef struct _LLC
    {
    BYTE dsap;
    BYTE ssap;
    struct 
        {
        union 
            {
            BYTE Command;
            BYTE NextSend;
            } 	;
        union 
            {
            BYTE NextRecv;
            BYTE Data[ 1 ];
            } 	;
        } 	ControlField;
    } 	LLC;

typedef LLC *LPLLC;

typedef LLC UNALIGNED *ULPLLC;
#define	LLC_SIZE	( sizeof( LLC  ) )


#pragma pack(pop)
//=============================================================================
//  Helper macros.
//=============================================================================

#define IsRoutingInfoPresent(f) ((((ULPTOKENRING) (f))->SrcAddr[0] & TOKENRING_SA_ROUTING_INFO) ? TRUE : FALSE)

#define GetRoutingInfoLength(f) (IsRoutingInfoPresent(f) \
                                 ? (((ULPTOKENRING) (f))->RoutingInfo[0] & TOKENRING_RC_LENGTHMASK) : 0)

//=============================================================================
//=============================================================================
//  (Parser.h)
//=============================================================================
//=============================================================================

//=============================================================================
//  Format Procedure Type.
//
//  NOTE: All format functions *must* be declared as WINAPIV not WINAPI!
//=============================================================================

typedef VOID (WINAPIV *FORMAT)(LPPROPERTYINST, ...);

//  The protocol recognized the frame and moved the pointer to end of its
//  protocol header. Network Monitor uses the protocols follow set to continue
//  parsing.
#define	PROTOCOL_STATUS_RECOGNIZED	( 0 )

//  The protocol did not recognized the frame and did not move the pointer
//  (i.e. the start data pointer which was passed in). Network Monitor uses the
//  protocols follow set to continue parsing.
#define	PROTOCOL_STATUS_NOT_RECOGNIZED	( 1 )

//  The protocol recognized the frame and claimed it all for itself,
//  and parsing terminates.
#define	PROTOCOL_STATUS_CLAIMED	( 2 )

//  The protocol recognized the frame and moved the pointer to end of its
//  protocol header. The current protocol requests that Network Monitor 
//  continue parsing at a known next protocol by returning the next protocols
//  handle back to Network Monitor. In this case, the follow of the current 
//  protocol, if any, is not used.
#define	PROTOCOL_STATUS_NEXT_PROTOCOL	( 3 )

//=============================================================================
//  Macros.
//=============================================================================

extern  BYTE HexTable[];

#define XCHG(x)         MAKEWORD( HIBYTE(x), LOBYTE(x) )

#define DXCHG(x)        MAKELONG( XCHG(HIWORD(x)), XCHG(LOWORD(x)) )

#define LONIBBLE(b) ((BYTE) ((b) & 0x0F))

#define HINIBBLE(b)     ((BYTE) ((b) >> 4))

#define HEX(b)          (HexTable[LONIBBLE(b)])

#define SWAPBYTES(w)    ((w) = XCHG(w))

#define SWAPWORDS(d)    ((d) = DXCHG(d))

//=============================================================================
//  All the MAC frame types combined.
//=============================================================================
typedef union _MACFRAME
{
    LPBYTE      MacHeader;              //... generic pointer.
    LPETHERNET  Ethernet;               //... ethernet pointer.
    LPTOKENRING Tokenring;              //... tokenring pointer.
    LPFDDI      Fddi;                   //... FDDI pointer.

} MACFRAME;
typedef MACFRAME *LPMACFRAME;

#define HOT_SIGNATURE       MAKE_IDENTIFIER('H', 'O', 'T', '$')
#define HOE_SIGNATURE       MAKE_IDENTIFIER('H', 'O', 'E', '$')
typedef struct _HANDOFFENTRY
    {
    DWORD hoe_sig;
    DWORD hoe_ProtIdentNumber;
    HPROTOCOL hoe_ProtocolHandle;
    DWORD hoe_ProtocolData;
    } 	HANDOFFENTRY;

typedef HANDOFFENTRY *LPHANDOFFENTRY;

typedef struct _HANDOFFTABLE
    {
    DWORD hot_sig;
    DWORD hot_NumEntries;
    LPHANDOFFENTRY hot_Entries;
    } 	HANDOFFTABLE;

typedef struct _HANDOFFTABLE *LPHANDOFFTABLE;

//=============================================================================
//  Parser helper macros.
//=============================================================================

INLINE LPVOID GetPropertyInstanceData(LPPROPERTYINST PropertyInst)
{
    if ( PropertyInst->DataLength != (WORD) -1 )
    {
        return PropertyInst->lpData;
    }

    return (LPVOID) PropertyInst->lpPropertyInstEx->Byte;
}

#define GetPropertyInstanceDataValue(p, type)  ((type *) GetPropertyInstanceData(p))[0]

INLINE DWORD GetPropertyInstanceFrameDataLength(LPPROPERTYINST PropertyInst)
{
    if ( PropertyInst->DataLength != (WORD) -1 )
    {
        return PropertyInst->DataLength;
    }

    return PropertyInst->lpPropertyInstEx->Length;
}

INLINE DWORD GetPropertyInstanceExDataLength(LPPROPERTYINST PropertyInst)
{
    if ( PropertyInst->DataLength == (WORD) -1 )
    {
        PropertyInst->lpPropertyInstEx->Length;
    }

    return (WORD) -1;
}

//=============================================================================
//  Parser helper functions.
//=============================================================================

LPLABELED_WORD  WINAPI GetProtocolDescriptionTable(LPDWORD TableSize);

LPLABELED_WORD  WINAPI GetProtocolDescription(DWORD ProtocolID);

DWORD        WINAPI GetMacHeaderLength(LPVOID MacHeader, DWORD MacType);

DWORD        WINAPI GetLLCHeaderLength(LPLLC Frame);

DWORD        WINAPI GetEtype(LPVOID MacHeader, DWORD MacType);

DWORD        WINAPI GetSaps(LPVOID MacHeader, DWORD MacType);

BOOL         WINAPI IsLLCPresent(LPVOID MacHeader, DWORD MacType);

VOID         WINAPI CanonicalizeHexString(LPSTR hex, LPSTR dest, DWORD len);

void         WINAPI CanonHex(UCHAR * pDest, UCHAR * pSource, int iLen, BOOL fOx );

DWORD        WINAPI ByteToBinary(LPSTR string, DWORD ByteValue);

DWORD        WINAPI WordToBinary(LPSTR string, DWORD WordValue);

DWORD        WINAPI DwordToBinary(LPSTR string, DWORD DwordValue);

LPSTR        WINAPI AddressToString(__out_ecount(MAX_ADDR_LENGTH) LPSTR string,
                                    __in_ecount(MAX_ADDR_LENGTH)  BYTE *lpAddress);

LPBYTE       WINAPI StringToAddress(__out_ecount(MAX_ADDR_LENGTH*2) LPBYTE lpAddress,
                                    __in_ecount(MAX_ADDR_LENGTH*2) LPSTR string);

LPDWORD      WINAPI VarLenSmallIntToDword( LPBYTE  pValue, 
                                                  WORD    ValueLen, 
                                                  BOOL    fIsByteswapped,
                                                  LPDWORD lpDword );

LPBYTE       WINAPI LookupByteSetString (LPSET lpSet, BYTE Value);

LPBYTE       WINAPI LookupWordSetString (LPSET lpSet, WORD Value);

LPBYTE       WINAPI LookupDwordSetString (LPSET lpSet, DWORD Value);

DWORD        WINAPIV FormatByteFlags(__out_ecount(8) LPSTR string, DWORD ByteValue, DWORD BitMask);

DWORD        WINAPIV FormatWordFlags(__out_ecount(16) LPSTR string, DWORD WordValue, DWORD BitMask);

DWORD        WINAPIV FormatDwordFlags(__out_ecount(32) LPSTR string, DWORD DwordValue, DWORD BitMask);

LPSTR        WINAPIV FormatTimeAsString(SYSTEMTIME *time, __inout_ecount(MAX_PATH) LPSTR string);

VOID         WINAPIV FormatLabeledByteSetAsFlags(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledWordSetAsFlags(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledDwordSetAsFlags(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsByte(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatPropertyDataAsWord(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatPropertyDataAsDword(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatLabeledByteSet(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledWordSet(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledDwordSet(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsInt64(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatPropertyDataAsTime(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsString(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsHexString(LPPROPERTYINST lpPropertyInst);

// Parsers should NOT call LockFrame().  If a parser takes a lock and then gets
// faulted or returns without unlocking, it leaves the system in a state where
// it cannot change protocols or cut/copy frames.  Parsers should use ParserTemporaryLockFrame
// which grants a lock ONLY during the context of the api entry into the parser.  The 
// lock is released on exit from the parser for that frame.
ULPBYTE       WINAPI ParserTemporaryLockFrame(HFRAME hFrame);

LPVOID       WINAPI GetCCInstPtr(VOID);
VOID         WINAPI SetCCInstPtr(LPVOID lpCurCaptureInst);
LPVOID       WINAPI CCHeapAlloc(DWORD dwBytes, BOOL bZeroInit);
LPVOID       WINAPI CCHeapReAlloc(LPVOID lpMem, DWORD dwBytes, BOOL bZeroInit);
BOOL         WINAPI CCHeapFree(LPVOID lpMem);
SIZE_T       WINAPI CCHeapSize(LPVOID lpMem);

BOOL _cdecl BERGetInteger( ULPBYTE  pCurrentPointer,
                           ULPBYTE *ppValuePointer,
                           LPDWORD pHeaderLength,
                           LPDWORD pDataLength,
                           ULPBYTE *ppNext);
BOOL _cdecl BERGetString( ULPBYTE  pCurrentPointer,
                          ULPBYTE *ppValuePointer,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext);
BOOL _cdecl BERGetHeader( ULPBYTE  pCurrentPointer,
                          ULPBYTE  pTag,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext);

//=============================================================================
//  Parser Finder Structures.
//=============================================================================
#define	MAX_PROTOCOL_COMMENT_LEN	( 256 )

#define	NETMON_MAX_PROTOCOL_NAME_LEN	( 16 )

// the constant MAX_PROTOCOL_NAME_LEN conflicts with one of the same name
// but different size in rtutils.h.
// So if both headers are included, we do not define MAX_PROTOCOL_NAME_LEN.
#ifndef MAX_PROTOCOL_NAME_LEN
#define	MAX_PROTOCOL_NAME_LEN	( NETMON_MAX_PROTOCOL_NAME_LEN )

#else
#undef MAX_PROTOCOL_NAME_LEN
#endif
// Handoff Value Format Base
typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_netmon_0000_0000_0015
    {	HANDOFF_VALUE_FORMAT_BASE_UNKNOWN	= 0,
	HANDOFF_VALUE_FORMAT_BASE_DECIMAL	= 10,
	HANDOFF_VALUE_FORMAT_BASE_HEX	= 16
    } 	PF_HANDOFFVALUEFORMATBASE;

// PF_HANDOFFENTRY
typedef struct _PF_HANDOFFENTRY
    {
    char szIniFile[ 260 ];
    char szIniSection[ 260 ];
    char szProtocol[ 16 ];
    DWORD dwHandOffValue;
    PF_HANDOFFVALUEFORMATBASE ValueFormatBase;
    } 	PF_HANDOFFENTRY;

typedef PF_HANDOFFENTRY *PPF_HANDOFFENTRY;

// PF_HANDOFFSET
typedef struct _PF_HANDOFFSET
{
    DWORD           nEntries;
    PF_HANDOFFENTRY Entry[0];

} PF_HANDOFFSET;
typedef PF_HANDOFFSET* PPF_HANDOFFSET;
// FOLLOWENTRY
typedef struct _PF_FOLLOWENTRY
    {
    char szProtocol[ 16 ];
    } 	PF_FOLLOWENTRY;

typedef PF_FOLLOWENTRY *PPF_FOLLOWENTRY;

// PF_FOLLOWSET
typedef struct _PF_FOLLOWSET
{
    DWORD           nEntries;
    PF_FOLLOWENTRY  Entry[0];

} PF_FOLLOWSET;
typedef PF_FOLLOWSET* PPF_FOLLOWSET;

// PARSERINFO - contains information about a single parser
typedef struct _PF_PARSERINFO
{
    char szProtocolName[NETMON_MAX_PROTOCOL_NAME_LEN];
    char szComment[MAX_PROTOCOL_COMMENT_LEN];
    char szHelpFile[MAX_PATH];

    PPF_FOLLOWSET pWhoCanPrecedeMe;
    PPF_FOLLOWSET pWhoCanFollowMe;

    PPF_HANDOFFSET pWhoHandsOffToMe;
    PPF_HANDOFFSET pWhoDoIHandOffTo;

} PF_PARSERINFO;
typedef PF_PARSERINFO* PPF_PARSERINFO;

// PF_PARSERDLLINFO - contains information about a single parser DLL
typedef struct _PF_PARSERDLLINFO
{             
//    char          szDLLName[MAX_PATH];
    DWORD         nParsers;
    PF_PARSERINFO ParserInfo[0];

} PF_PARSERDLLINFO;
typedef PF_PARSERDLLINFO* PPF_PARSERDLLINFO;
//=============================================================================
//=============================================================================
//  (IniLib.h)
//=============================================================================
//=============================================================================
#define	INI_PATH_LENGTH	( 256 )

#define	MAX_HANDOFF_ENTRY_LENGTH	( 80 )

#define	MAX_PROTOCOL_NAME	( 40 )

#define	NUMALLOCENTRIES	( 10 )

#define	RAW_INI_STR_LEN	( 200 )

#define PARSERS_SUBDIR              "PARSERS"
#define INI_EXTENSION               "INI"
#define BASE10_FORMAT_STR           "%ld=%s %ld"
#define BASE16_FORMAT_STR           "%lx=%s %lx"
// Given "XNS" or "TCP" or whatever BuildINIPath will return fully qual. path to "XNS.INI" or "TCP.INI"
LPSTR _cdecl BuildINIPath( __out_ecount(MAX_PATH) LPSTR FullPath,
                           __in LPSTR                   IniFileName );

// Builds Handoff Set
DWORD     WINAPI CreateHandoffTable(__in LPSTR          secName,
                                    __in LPSTR          iniFile,
                                    LPHANDOFFTABLE *    hTable,
                                    DWORD               nMaxProtocolEntries,
                                    DWORD               base);

HPROTOCOL WINAPI GetProtocolFromTable(LPHANDOFFTABLE  hTable, // lp to Handoff Table...
                                      DWORD           ItemToFind,       // port number etc...
                                      PDWORD_PTR      lpInstData );   // inst data to give to next protocol

VOID      WINAPI DestroyHandoffTable( LPHANDOFFTABLE hTable );

BOOLEAN WINAPI IsRawIPXEnabled(__in LPSTR secName,
                               __in LPSTR iniFile,
                               __in LPSTR CurProtocol );

//=============================================================================
//=============================================================================
//  (NMExpert.h)
//=============================================================================
//=============================================================================
#define	EXPERTSTRINGLENGTH	( 260 )

#define	EXPERTGROUPNAMELENGTH	( 25 )

// HEXPERTKEY tracks running experts. It is only used by experts for 
// self reference. It refers to a RUNNINGEXPERT (an internal only structure)..
typedef LPVOID HEXPERTKEY;

typedef HEXPERTKEY *PHEXPERTKEY;

// HEXPERT tracks loaded experts. It refers to an EXPERTENUMINFO.
typedef LPVOID HEXPERT;

typedef HEXPERT *PHEXPERT;

// HRUNNINGEXPERT tracks a currently running expert.
// It refers to a RUNNINGEXPERT (an internal only structure).
typedef LPVOID HRUNNINGEXPERT;

typedef HRUNNINGEXPERT *PHRUNNINGEXPERT;

typedef struct _EXPERTENUMINFO * PEXPERTENUMINFO;
typedef struct _EXPERTCONFIG   * PEXPERTCONFIG;
typedef struct _EXPERTSTARTUPINFO * PEXPERTSTARTUPINFO;
// Definitions needed to call experts
#define EXPERTENTRY_REGISTER      "Register"
#define EXPERTENTRY_CONFIGURE     "Configure"
#define EXPERTENTRY_RUN           "Run"
typedef BOOL (WINAPI * PEXPERTREGISTERPROC)( PEXPERTENUMINFO );
typedef BOOL (WINAPI * PEXPERTCONFIGPROC)  ( HEXPERTKEY, PEXPERTCONFIG*, PEXPERTSTARTUPINFO, DWORD, HWND );
typedef BOOL (WINAPI * PEXPERTRUNPROC)     ( HEXPERTKEY, PEXPERTCONFIG, PEXPERTSTARTUPINFO, DWORD, HWND);
// EXPERTENUMINFO describes an expert that NetMon has loaded from disk. 
// It does not include any configuration or runtime information.
typedef struct _EXPERTENUMINFO
{
    char      szName[EXPERTSTRINGLENGTH];
    char      szVendor[EXPERTSTRINGLENGTH];
    char      szDescription[EXPERTSTRINGLENGTH];
    DWORD     Version;    
    DWORD     Flags;
    char      szDllName[MAX_PATH];      // private, dont' touch
    HEXPERT   hExpert;                  // private, don't touch
    HINSTANCE hModule;                  // private, don't touch
    PEXPERTREGISTERPROC pRegisterProc;  // private, don't touch
    PEXPERTCONFIGPROC   pConfigProc;    // private, don't touch
    PEXPERTRUNPROC      pRunProc;       // private, don't touch

} EXPERTENUMINFO;
typedef EXPERTENUMINFO * PEXPERTENUMINFO;
#define	EXPERT_ENUM_FLAG_CONFIGURABLE	( 0x1 )

#define	EXPERT_ENUM_FLAG_VIEWER_PRIVATE	( 0x2 )

#define	EXPERT_ENUM_FLAG_NO_VIEWER	( 0x4 )

#define	EXPERT_ENUM_FLAG_ADD_ME_TO_RMC_IN_SUMMARY	( 0x10 )

#define	EXPERT_ENUM_FLAG_ADD_ME_TO_RMC_IN_DETAIL	( 0x20 )

// EXPERTSTARTUPINFO
// This gives the Expert an indication of where he came from.
// Note: if the lpPropertyInst->PropertyInfo->DataQualifier == PROP_QUAL_FLAGS
// then the sBitField structure is filled in
typedef struct _EXPERTSTARTUPINFO
{
    DWORD           Flags;
    HCAPTURE        hCapture;
    char            szCaptureFile[MAX_PATH];
    DWORD           dwFrameNumber;
    HPROTOCOL       hProtocol;

    LPPROPERTYINST  lpPropertyInst;

    struct
    {
        BYTE    BitNumber;
        BOOL    bOn;
    } sBitfield;

} EXPERTSTARTUPINFO;
// EXPERTCONFIG
// This is a generic holder for an Expert's config data.
typedef struct  _EXPERTCONFIG
{
    DWORD   RawConfigLength;
    BYTE    RawConfigData[0];

} EXPERTCONFIG;
typedef EXPERTCONFIG * PEXPERTCONFIG;
// CONFIGUREDEXPERT
// This structure associates a loaded expert with its configuration data.
typedef struct
{
    HEXPERT         hExpert;
    DWORD           StartupFlags;
    PEXPERTCONFIG   pConfig;
} CONFIGUREDEXPERT;
typedef CONFIGUREDEXPERT * PCONFIGUREDEXPERT;
// EXPERTFRAMEDESCRIPTOR - passed back to the expert to fulfil the request for a frame
typedef struct
{
    DWORD                FrameNumber;         // Frame Number.
    HFRAME               hFrame;              // Handle to the frame.
    ULPFRAME             pFrame;              // pointer to frame.
    LPRECOGNIZEDATATABLE lpRecognizeDataTable;// pointer to table of RECOGNIZEDATA structures.
    LPPROPERTYTABLE      lpPropertyTable;     // pointer to property table.

} EXPERTFRAMEDESCRIPTOR;
typedef EXPERTFRAMEDESCRIPTOR * LPEXPERTFRAMEDESCRIPTOR;
#define	GET_SPECIFIED_FRAME	( 0 )

#define	GET_FRAME_NEXT_FORWARD	( 1 )

#define	GET_FRAME_NEXT_BACKWARD	( 2 )

#define	FLAGS_DEFER_TO_UI_FILTER	( 0x1 )

#define	FLAGS_ATTACH_PROPERTIES	( 0x2 )

// EXPERTSTATUSENUM
// gives the possible values for the status field in the EXPERTSTATUS structure
typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_netmon_0000_0000_0016
    {	EXPERTSTATUS_INACTIVE	= 0,
	EXPERTSTATUS_STARTING	= ( EXPERTSTATUS_INACTIVE + 1 ) ,
	EXPERTSTATUS_RUNNING	= ( EXPERTSTATUS_STARTING + 1 ) ,
	EXPERTSTATUS_PROBLEM	= ( EXPERTSTATUS_RUNNING + 1 ) ,
	EXPERTSTATUS_ABORTED	= ( EXPERTSTATUS_PROBLEM + 1 ) ,
	EXPERTSTATUS_DONE	= ( EXPERTSTATUS_ABORTED + 1 ) 
    } 	EXPERTSTATUSENUMERATION;

// EXPERTSUBSTATUS bitfield 
// gives the possible values for the substatus field in the EXPERTSTATUS structure
#define	EXPERTSUBSTATUS_ABORTED_USER	( 0x1 )

#define	EXPERTSUBSTATUS_ABORTED_LOAD_FAIL	( 0x2 )

#define	EXPERTSUBSTATUS_ABORTED_THREAD_FAIL	( 0x4 )

#define	EXPERTSUBSTATUS_ABORTED_BAD_ENTRY	( 0x8 )

// EXPERTSTATUS
// Indicates the current status of a running expert.
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0017
    {
    EXPERTSTATUSENUMERATION Status;
    DWORD SubStatus;
    DWORD PercentDone;
    DWORD Frame;
    char szStatusText[ 260 ];
    } 	EXPERTSTATUS;

typedef EXPERTSTATUS *PEXPERTSTATUS;

// EXPERT STARTUP FLAGS
#define	EXPERT_STARTUP_FLAG_USE_STARTUP_DATA_OVER_CONFIG_DATA	( 0x1 )

//=============================================================================
//=============================================================================
//  (NetMon.h)
//=============================================================================
//=============================================================================
//  A frame with no number contains this value as its frame number.
#define	INVALID_FRAME_NUMBER	( ( DWORD  )-1 )

//=============================================================================
//  Capture file flags.
//=============================================================================
#define CAPTUREFILE_OPEN                OPEN_EXISTING
#define CAPTUREFILE_CREATE              CREATE_NEW
//=============================================================================
//  CAPTURE CONTEXT API's.
//=============================================================================

LPSYSTEMTIME         WINAPI GetCaptureTimeStamp(HCAPTURE hCapture);

DWORD                WINAPI GetCaptureMacType(HCAPTURE hCapture);

DWORD                WINAPI GetCaptureTotalFrames(HCAPTURE hCapture);

LPSTR                WINAPI GetCaptureComment(HCAPTURE hCapture);

//=============================================================================
//  FRAME HELP API's.
//=============================================================================

DWORD                WINAPI MacTypeToAddressType(DWORD MacType);

DWORD                WINAPI AddressTypeToMacType(DWORD AddressType);

DWORD                WINAPI GetFrameDstAddressOffset(HFRAME hFrame, DWORD AddressType, LPDWORD AddressLength);

DWORD                WINAPI GetFrameSrcAddressOffset(HFRAME hFrame, DWORD AddressType, LPDWORD AddressLength);

HCAPTURE             WINAPI GetFrameCaptureHandle(HFRAME hFrame);


DWORD                WINAPI GetFrameDestAddress(HFRAME       hFrame,
                                                       LPADDRESS2    lpAddress,
                                                       DWORD        AddressType,
                                                       DWORD        Flags);

DWORD                WINAPI GetFrameSourceAddress(HFRAME     hFrame,
                                                         LPADDRESS2  lpAddress,
                                                         DWORD      AddressType,
                                                         DWORD      Flags);

DWORD                WINAPI GetFrameMacHeaderLength(HFRAME hFrame);

BOOL                 WINAPI CompareFrameDestAddress(HFRAME hFrame, LPADDRESS2 lpAddress);

BOOL                 WINAPI CompareFrameSourceAddress(HFRAME hFrame, LPADDRESS2 lpAddress);

DWORD                WINAPI GetFrameLength(HFRAME hFrame);

DWORD                WINAPI GetFrameStoredLength(HFRAME hFrame);

DWORD                WINAPI GetFrameMacType(HFRAME hFrame);

DWORD                WINAPI GetFrameMacHeaderLength(HFRAME hFrame);

DWORD                WINAPI GetFrameNumber(HFRAME hFrame);

__int64              WINAPI GetFrameTimeStamp(HFRAME hFrame);

ULPFRAME             WINAPI GetFrameFromFrameHandle(HFRAME hFrame);

//=============================================================================
//  FRAME API's.
//=============================================================================

HFRAME               WINAPI ModifyFrame(HCAPTURE hCapture,
                                               DWORD    FrameNumber,
                                               LPBYTE   FrameData,
                                               DWORD    FrameLength,
                                               __int64  TimeStamp);

HFRAME               WINAPI FindNextFrame(HFRAME hCurrentFrame,
                                                __in LPSTR ProtocolName,
                                                LPADDRESS2 lpDestAddress,
                                                LPADDRESS2 lpSrcAddress,
                                                LPWORD ProtocolOffset,
                                                DWORD  OriginalFrameNumber,
                                                DWORD  nHighestFrame);

HFRAME               WINAPI FindPreviousFrame(HFRAME hCurrentFrame,
                                                    __in LPSTR ProtocolName,
                                                    LPADDRESS2 lpDstAddress,
                                                    LPADDRESS2 lpSrcAddress,
                                                    LPWORD ProtocolOffset,
                                                    DWORD  OriginalFrameNumber,
                                                    DWORD  nLowestFrame );

HCAPTURE             WINAPI GetFrameCaptureHandle(HFRAME);

HFRAME               WINAPI GetFrame(HCAPTURE hCapture, DWORD FrameNumber);

LPRECOGNIZEDATATABLE WINAPI GetFrameRecognizeData(HFRAME hFrame);

//=============================================================================
//  Protocol API's.
//=============================================================================

HPROTOCOL            WINAPI CreateProtocol(__in LPSTR ProtocolName,
                                                  LPENTRYPOINTS lpEntryPoints,
                                                  DWORD cbEntryPoints);

VOID                 WINAPI DestroyProtocol(HPROTOCOL hProtocol);

LPPROTOCOLINFO       WINAPI GetProtocolInfo(HPROTOCOL hProtocol);

HPROPERTY            WINAPI GetProperty(HPROTOCOL hProtocol, __in LPSTR PropertyName);

HPROTOCOL            WINAPI GetProtocolFromName(__in LPSTR ProtocolName);

DWORD                WINAPI GetProtocolStartOffset(HFRAME hFrame, __in LPSTR ProtocolName);

DWORD                WINAPI GetProtocolStartOffsetHandle(HFRAME hFrame, HPROTOCOL hProtocol);

DWORD                WINAPI GetPreviousProtocolOffsetByName(HFRAME hFrame,
                                                                   DWORD  dwStartOffset,
                                                                   __in LPSTR  szProtocolName,
                                                                   DWORD* pdwPreviousOffset);

LPPROTOCOLTABLE      WINAPI GetEnabledProtocols(HCAPTURE hCapture);

//=============================================================================
//  Property API's.
//=============================================================================

DWORD                WINAPI CreatePropertyDatabase(HPROTOCOL hProtocol, DWORD nProperties);

DWORD                WINAPI DestroyPropertyDatabase(HPROTOCOL hProtocol);

HPROPERTY            WINAPI AddProperty(HPROTOCOL hProtocol, LPPROPERTYINFO PropertyInfo);

BOOL                 WINAPI AttachPropertyInstance(HFRAME    hFrame,
                                                          HPROPERTY hProperty,
                                                          DWORD     Length,
                                                          ULPVOID   lpData,
                                                          DWORD     HelpID,
                                                          DWORD     Level,
                                                          DWORD     IFlags);

BOOL                 WINAPI AttachPropertyInstanceEx(HFRAME      hFrame,
                                                            HPROPERTY   hProperty,
                                                            DWORD       Length,
                                                            ULPVOID     lpData,
                                                            DWORD       ExLength,
                                                            ULPVOID     lpExData,
                                                            DWORD       HelpID,
                                                            DWORD       Level,
                                                            DWORD       IFlags);

LPPROPERTYINST       WINAPI FindPropertyInstance(HFRAME hFrame, HPROPERTY hProperty);

LPPROPERTYINST       WINAPI FindPropertyInstanceRestart (HFRAME      hFrame, 
                                                                HPROPERTY   hProperty, 
                                                                LPPROPERTYINST *lpRestartKey, 
                                                                BOOL        DirForward );

LPPROPERTYINFO       WINAPI GetPropertyInfo(HPROPERTY hProperty);

LPSTR                WINAPI GetPropertyText(HFRAME hFrame, LPPROPERTYINST lpPI, __out_ecount(BufferSize) LPSTR szBuffer, DWORD BufferSize);

DWORD                WINAPI ResetPropertyInstanceLength( LPPROPERTYINST lpProp, 
                                                                WORD nOrgLen, 
                                                                WORD nNewLen );
//=============================================================================
//  MISC. API's.
//=============================================================================

DWORD                WINAPI GetCaptureCommentFromFilename(__in LPSTR lpFilename, __out_ecount(CommentSize) LPSTR lpComment, DWORD CommentSize);

int                  WINAPI CompareAddresses(LPADDRESS2 lpAddress1, LPADDRESS2 lpAddress2);

DWORD                WINAPIV FormatPropertyInstance(LPPROPERTYINST lpPropertyInst, ...);

SYSTEMTIME *         WINAPI AdjustSystemTime(SYSTEMTIME *SystemTime, __int64 TimeDelta);

LPSTR                WINAPI NMRtlIpv6AddressToStringA(const BYTE IP6Addr[], __out_ecount(MAX_PATH) LPSTR S);

LPWSTR               WINAPI NMRtlIpv6AddressToStringW(const BYTE IP6Addr[], __out_ecount(IPV6_STR_LENGTH*4) LPWSTR S);

ULONG                WINAPI NMRtlIpv6StringToAddressA(LPCSTR S, LPCSTR *Terminator, BYTE IP6Addr[]);

ULONG                WINAPI NMRtlIpv6StringToAddressW(LPCWSTR S, LPCWSTR *Terminator, BYTE IP6Addr[]);

//=============================================================================
//  EXPERT API's for use by Experts
//=============================================================================

DWORD WINAPI ExpertGetFrame( IN HEXPERTKEY hExpertKey,
                                    IN DWORD Direction,
                                    IN DWORD RequestFlags,
                                    IN DWORD RequestedFrameNumber,
                                    IN HFILTER hFilter,
                                    OUT LPEXPERTFRAMEDESCRIPTOR pEFrameDescriptor);

LPVOID WINAPI ExpertAllocMemory( IN  HEXPERTKEY hExpertKey,
                                        IN  SIZE_T nBytes,
                                        OUT DWORD* pError);

LPVOID WINAPI ExpertReallocMemory( IN  HEXPERTKEY hExpertKey,
                                          IN  LPVOID pOriginalMemory,
                                          IN  SIZE_T nBytes,
                                          OUT DWORD* pError);

DWORD WINAPI ExpertFreeMemory( IN HEXPERTKEY hExpertKey,
                                      IN LPVOID pOriginalMemory);

SIZE_T WINAPI ExpertMemorySize( IN HEXPERTKEY hExpertKey,
                                       IN LPVOID pOriginalMemory);

DWORD WINAPI ExpertIndicateStatus( IN HEXPERTKEY              hExpertKey, 
                                          IN EXPERTSTATUSENUMERATION Status,
                                          IN DWORD                   SubStatus,
                                          IN const char *            szText,
                                          IN LONG                    PercentDone);

DWORD WINAPI ExpertSubmitEvent( IN HEXPERTKEY   hExpertKey,
                                       IN PNMEVENTDATA pExpertEvent);

DWORD WINAPI ExpertGetStartupInfo( IN  HEXPERTKEY hExpertKey,
                                          OUT PEXPERTSTARTUPINFO pExpertStartupInfo);

//=============================================================================
//  DEBUG API's.
//=============================================================================
#ifdef DEBUG

//=============================================================================
//  BreakPoint() macro.
//=============================================================================
// We do not want breakpoints in our code any more...
// so we are defining DebugBreak(), usually a system call, to be
// just a dprintf. BreakPoint() is still defined as DebugBreak().

#ifdef DebugBreak
#undef DebugBreak
#endif // DebugBreak

#define DebugBreak()    dprintf("DebugBreak Called at %s:%s", __FILE__, __LINE__);
#define BreakPoint()    DebugBreak()

#endif // DEBUG
//=============================================================================
//=============================================================================
//  (NMBlob.h)
//=============================================================================
//=============================================================================
//=============================================================================
// Blob Constants
//=============================================================================
#define	INITIAL_RESTART_KEY	( 0xffffffff )

//=============================================================================
// Blob Core Helper Routines 
//=============================================================================
DWORD _cdecl CreateBlob(HBLOB * phBlob);

DWORD _cdecl DestroyBlob(HBLOB hBlob);

DWORD _cdecl SetStringInBlob(HBLOB  hBlob,        
                      const char * pOwnerName,    
                      const char * pCategoryName, 
                      const char * pTagName,      
                      const char * pString);      

DWORD _cdecl SetWStringInBlob(HBLOB  hBlob,       
                      const char * pOwnerName,    
                      const char * pCategoryName, 
                      const char * pTagName,      
                      const WCHAR * pwString);    

DWORD _cdecl ConvertWStringToHexString(const WCHAR *pwsz,
                        char ** ppsz);

DWORD _cdecl GetStringFromBlob(HBLOB   hBlob,
                        const char *  pOwnerName,
                        const char *  pCategoryName,
                        const char *  pTagName,
                        const char ** ppString);

DWORD _cdecl ConvertHexStringToWString(CHAR *psz,
                        WCHAR **ppwsz);

DWORD _cdecl GetWStringFromBlob(HBLOB   hBlob,
                        const char *  pOwnerName,
                        const char *  pCategoryName,
                        const char *  pTagName,
                        WCHAR ** ppwString);

DWORD _cdecl GetStringsFromBlob(HBLOB   hBlob,
                         const char * pRequestedOwnerName,
                         const char * pRequestedCategoryName,
                         const char * pRequestedTagName,
                         const char ** ppReturnedOwnerName,
                         const char ** ppReturnedCategoryName,
                         const char ** ppReturnedTagName,
                         const char ** ppReturnedString,
                         DWORD *       pRestartKey);

DWORD _cdecl RemoveFromBlob(HBLOB   hBlob,
                     const char *  pOwnerName,
                     const char *  pCategoryName,
                     const char *  pTagName);

DWORD _cdecl LockBlob(HBLOB hBlob);

DWORD _cdecl UnlockBlob(HBLOB hBlob);

DWORD _cdecl FindUnknownBlobCategories( HBLOB hBlob,
                                 const char *  pOwnerName,
                                 const char *  pKnownCategoriesTable[],
                                 HBLOB hUnknownCategoriesBlob);

//=============================================================================
// Blob Helper Routines 
//=============================================================================
DWORD _cdecl MergeBlob(HBLOB hDstBlob,
                HBLOB hSrcBlob); 

DWORD _cdecl DuplicateBlob (HBLOB hSrcBlob,
                     HBLOB *hBlobThatWillBeCreated ); 

DWORD _cdecl WriteBlobToFile(HBLOB  hBlob,
                      const char * pFileName);

DWORD _cdecl ReadBlobFromFile(HBLOB* phBlob,
                       const char * pFileName);

DWORD _cdecl RegCreateBlobKey(HKEY hkey, const char* szBlobName, HBLOB hBlob);

DWORD _cdecl RegOpenBlobKey(HKEY hkey, const char* szBlobName, HBLOB* phBlob);

DWORD _cdecl MarshalBlob(HBLOB hBlob, DWORD* pSize, BYTE** ppBytes);

DWORD _cdecl UnMarshalBlob(HBLOB* phBlob, DWORD Size, BYTE* pBytes);

DWORD _cdecl SetDwordInBlob(HBLOB hBlob,
                     const char *  pOwnerName,
                     const char *  pCategoryName,
                     const char *  pTagName,
                     DWORD         Dword);

DWORD _cdecl GetDwordFromBlob(HBLOB   hBlob,
                       const char *  pOwnerName,
                       const char *  pCategoryName,
                       const char *  pTagName,
                       DWORD      *  pDword);

DWORD _cdecl SetBoolInBlob(HBLOB   hBlob,
                    const char *  pOwnerName,
                    const char *  pCategoryName,
                    const char *  pTagName,
                    BOOL          Bool);

DWORD _cdecl GetBoolFromBlob(HBLOB   hBlob,
                      const char *  pOwnerName,
                      const char *  pCategoryName,
                      const char *  pTagName,
                      BOOL       *  pBool);

DWORD _cdecl GetMacAddressFromBlob(HBLOB   hBlob,
                            const char *  pOwnerName,
                            const char *  pCategoryName,
                            const char *  pTagName,
                            BYTE *  pMacAddress);

DWORD _cdecl SetMacAddressInBlob(HBLOB   hBlob,
                          const char *  pOwnerName,
                          const char *  pCategoryName,
                          const char *  pTagName,
                          const BYTE *  pMacAddress);

DWORD _cdecl FindUnknownBlobTags( HBLOB hBlob,
                           const char *  pOwnerName,
                           const char *  pCategoryName,
                           const char *  pKnownTagsTable[],
                           HBLOB hUnknownTagsBlob);

//=============================================================================
// Blob NPP Helper Routines
//=============================================================================
DWORD _cdecl SetNetworkInfoInBlob(HBLOB hBlob, 
                           LPNETWORKINFO lpNetworkInfo);

DWORD _cdecl GetNetworkInfoFromBlob(HBLOB hBlob, 
                             LPNETWORKINFO lpNetworkInfo);

DWORD _cdecl CreateNPPInterface ( HBLOB hBlob,
                           REFIID iid,
                           void ** ppvObject);

DWORD _cdecl SetClassIDInBlob(HBLOB hBlob,
                       const char* pOwnerName,
                       const char* pCategoryName,
                       const char* pTagName,
                       const CLSID*  pClsID);

DWORD _cdecl GetClassIDFromBlob(HBLOB hBlob,
                         const char* pOwnerName,
                         const char* pCategoryName,
                         const char* pTagName,
                         CLSID * pClsID);

DWORD _cdecl SetNPPPatternFilterInBlob( HBLOB hBlob,
                                 LPEXPRESSION pExpression,
                                 HBLOB hErrorBlob);

DWORD _cdecl GetNPPPatternFilterFromBlob( HBLOB hBlob,
                                   LPEXPRESSION pExpression,
                                   HBLOB hErrorBlob);

DWORD _cdecl SetNPPAddress2FilterInBlob( HBLOB hBlob,
                                 LPADDRESSTABLE2 pAddressTable);

DWORD _cdecl GetNPPAddress2FilterFromBlob( HBLOB hBlob,
                                   LPADDRESSTABLE2 pAddressTable,
                                   HBLOB hErrorBlob);

DWORD _cdecl SetNPPTriggerInBlob( HBLOB hBlob,
                           LPTRIGGER   pTrigger,
                           HBLOB hErrorBlob);

DWORD _cdecl GetNPPTriggerFromBlob( HBLOB hBlob,
                             LPTRIGGER   pTrigger,
                             HBLOB hErrorBlob);

DWORD _cdecl SetNPPEtypeSapFilter(HBLOB  hBlob, 
                           WORD   nSaps,
                           WORD   nEtypes,
                           LPBYTE lpSapTable,
                           LPWORD lpEtypeTable,
                           DWORD  FilterFlags,
                           HBLOB  hErrorBlob);

DWORD _cdecl GetNPPEtypeSapFilter(HBLOB  hBlob, 
                           WORD   *pnSaps,
                           WORD   *pnEtypes,
                           LPBYTE *ppSapTable,
                           LPWORD *ppEtypeTable,
                           DWORD  *pFilterFlags,
                           HBLOB  hErrorBlob);

// GetNPPMacTypeAsNumber maps the tag NPP:NetworkInfo:MacType to the MAC_TYPE_*
// defined in the NPPTYPES.h.  If the tag is unavailable, the API returns MAC_TYPE_UNKNOWN.
DWORD _cdecl GetNPPMacTypeAsNumber(HBLOB hBlob, 
                            LPDWORD lpMacType);

// See if a remote catagory exists... and make sure that the remote computername
// isn't the same as the local computername.
BOOL  _cdecl IsRemoteNPP ( HBLOB hBLOB);

//=============================================================================
// npp tag definitions
//=============================================================================
#define OWNER_NPP               "NPP"

#define CATEGORY_NETWORKINFO        "NetworkInfo"
#define TAG_MACTYPE                     "MacType"
#define TAG_CURRENTADDRESS              "CurrentAddress"
#define TAG_LINKSPEED                   "LinkSpeed"
#define TAG_MAXFRAMESIZE                "MaxFrameSize"
#define TAG_FLAGS                       "Flags"
#define TAG_TIMESTAMPSCALEFACTOR        "TimeStampScaleFactor"
#define TAG_COMMENT                     "Comment"
#define TAG_NODENAME                    "NodeName"
#define TAG_NAME                        "Name"
#define TAG_FAKENPP                     "Fake"
#define TAG_PROMISCUOUS_MODE            "PMode"

#define CATEGORY_LOCATION           "Location"
#define TAG_RAS                         "Dial-up Connection"
#define TAG_MACADDRESS                  "MacAddress"
#define TAG_CLASSID                     "ClassID"
#define TAG_NAME                        "Name"
#define TAG_CONNECTIONNAME              "Connection Name"
#define TAG_FRIENDLYNAME                "Friendly Name"

#define CATEGORY_CONFIG             "Config"
#define TAG_FRAME_SIZE                  "FrameSize"
#define TAG_UPDATE_FREQUENCY            "UpdateFreq"
#define TAG_BUFFER_SIZE                 "BufferSize"
#define TAG_PATTERN_DESIGNATOR          "PatternMatch"
#define TAG_PATTERN                     "Pattern"
#define TAG_ADDRESS_PAIR                "AddressPair"
#define TAG_CONNECTIONFLAGS             "ConnectionFlags"
#define TAG_ETYPES                      "Etypes"
#define TAG_SAPS                        "Saps"
#define TAG_NO_CONVERSATION_STATS       "NoConversationStats"
#define TAG_NO_STATS_FRAME              "NoStatsFrame"
#define TAG_DONT_DELETE_EMPTY_CAPTURE   "DontDeleteEmptyCapture"
#define TAG_WANT_PROTOCOL_INFO          "WantProtocolInfo"
#define TAG_INTERFACE_DELAYED_CAPTURE   "IDdC"
#define TAG_INTERFACE_REALTIME_CAPTURE  "IRTC"
#define TAG_INTERFACE_STATS             "ISts"
#define TAG_INTERFACE_TRANSMIT          "IXmt"
#define TAG_LOCAL_ONLY                  "LocalOnly"
// Is_Remote is set to TRUE by NPPs that go remote.  Note that when you
//  are looking for a remote NPP, you probably also need to ask for
//  blobs that have the TAG_GET_SPECIAL_BLOBS bool set
#define TAG_IS_REMOTE                   "IsRemote"


#define CATEGORY_TRIGGER            "Trigger"
#define TAG_TRIGGER                     "Trigger"

#define CATEGORY_FINDER             "Finder"
#define TAG_ROOT                        "Root"
#define TAG_PROCNAME                    "ProcName"
#define TAG_DISP_STRING                 "Display"
#define TAG_DLL_FILENAME                "DLLName"
#define TAG_GET_SPECIAL_BLOBS           "Specials"

#define CATEGORY_REMOTE              "Remote"
#define TAG_REMOTECOMPUTER              "RemoteComputer"
#define TAG_REMOTECLASSID               "ClassID"


//=============================================================================
// npp value definitions
//=============================================================================
// Mac types
#define PROTOCOL_STRING_ETHERNET_TXT   "ETHERNET"
#define PROTOCOL_STRING_TOKENRING_TXT  "TOKENRING"
#define PROTOCOL_STRING_FDDI_TXT       "FDDI"
#define PROTOCOL_STRING_ATM_TXT        "ATM"
#define PROTOCOL_STRING_1394_TXT       "IP/1394"

// lower protocols
#define PROTOCOL_STRING_IP_TXT         "IP"
#define PROTOCOL_STRING_IP6_TXT        "IP6"
#define PROTOCOL_STRING_IPX_TXT        "IPX"
#define PROTOCOL_STRING_XNS_TXT        "XNS"
#define PROTOCOL_STRING_VINES_IP_TXT   "VINES IP"

// upper protocols
#define PROTOCOL_STRING_ICMP_TXT       "ICMP"
#define PROTOCOL_STRING_TCP_TXT        "TCP"
#define PROTOCOL_STRING_UDP_TXT        "UDP"
#define PROTOCOL_STRING_SPX_TXT        "SPX"
#define PROTOCOL_STRING_NCP_TXT        "NCP"

// pseudo protocols
#define PROTOCOL_STRING_ANY_TXT        "ANY"
#define PROTOCOL_STRING_ANY_GROUP_TXT  "ANY GROUP"
#define PROTOCOL_STRING_HIGHEST_TXT    "HIGHEST"
#define PROTOCOL_STRING_LOCAL_ONLY_TXT "LOCAL ONLY"
#define PROTOCOL_STRING_UNKNOWN_TXT    "UNKNOWN"
#define PROTOCOL_STRING_DATA_TXT       "DATA"
#define PROTOCOL_STRING_FRAME_TXT      "FRAME"
#define PROTOCOL_STRING_NONE_TXT       "NONE"
#define PROTOCOL_STRING_EFFECTIVE_TXT  "EFFECTIVE"

#define ADDRESS_PAIR_INCLUDE_TXT    "INCLUDE"
#define ADDRESS_PAIR_EXCLUDE_TXT    "EXCLUDE"

#define INCLUDE_ALL_EXCEPT_TXT      "INCLUDE ALL EXCEPT"
#define EXCLUDE_ALL_EXCEPT_TXT      "EXCLUDE ALL EXCEPT"

#define PATTERN_MATCH_OR_TXT        "OR("
#define PATTERN_MATCH_AND_TXT       "AND("

#define TRIGGER_PATTERN_TXT               "PATTERN MATCH"
#define TRIGGER_BUFFER_TXT                "BUFFER CONTENT"

#define TRIGGER_NOTIFY_TXT      "NOTIFY"
#define TRIGGER_STOP_TXT        "STOP"
#define TRIGGER_PAUSE_TXT       "PAUSE"

#define TRIGGER_25_PERCENT_TXT  "25 PERCENT"
#define TRIGGER_50_PERCENT_TXT  "50 PERCENT"
#define TRIGGER_75_PERCENT_TXT  "75 PERCENT"
#define TRIGGER_100_PERCENT_TXT "100 PERCENT"

#define PATTERN_MATCH_NOT_TXT   "NOT"

//=============================================================================
//=============================================================================
// (NMRegHelp.h)
//=============================================================================
//=============================================================================

// Registry helpers
LPCSTR _cdecl FindOneOf(LPCSTR p1, LPCSTR p2);

LONG _cdecl recursiveDeleteKey(HKEY hKeyParent,            // Parent of key to delete.
                        const char* lpszKeyChild);  // Key to delete.

BOOL _cdecl SubkeyExists(const char* pszPath,              // Path of key to check
                  const char* szSubkey);            // Key to check

BOOL _cdecl setKeyAndValue(const char* szKey, 
                    const char* szSubkey, 
                    const char* szValue,
                    const char* szName) ;

//=============================================================================
//=============================================================================
// (NMIpStructs.h)
//=============================================================================
//=============================================================================

// These structures are used to decode network data and so need to be packed

#pragma pack(push, 1)
//
// IP Packet Structure
//
typedef struct _IP 
{
    union 
    {
        BYTE   Version;
        BYTE   HdrLen;
    };
    BYTE ServiceType;
    WORD TotalLen;
    WORD ID;
    union 
    {
        WORD   Flags;
        WORD   FragOff;
    };
    BYTE TimeToLive;
    BYTE Protocol;
    WORD HdrChksum;
    DWORD   SrcAddr;
    DWORD   DstAddr;
    BYTE Options[0];
} IP;

typedef IP * LPIP;
typedef IP UNALIGNED * ULPIP;
// Psuedo Header used for CheckSum Calculations
typedef struct _PSUHDR
    {
    DWORD ph_SrcIP;
    DWORD ph_DstIP;
    UCHAR ph_Zero;
    UCHAR ph_Proto;
    WORD ph_ProtLen;
    } 	PSUHDR;

typedef PSUHDR UNALIGNED * LPPSUHDR;
//
// IP Bitmasks that are useful
// (and the appropriate bit shifts, as well)
//

#define IP_VERSION_MASK ((BYTE) 0xf0)
#define IP_VERSION_SHIFT (4)
#define IP_HDRLEN_MASK  ((BYTE) 0x0f)
#define IP_HDRLEN_SHIFT (0)
#define IP_PRECEDENCE_MASK ((BYTE) 0xE0)
#define IP_PRECEDENCE_SHIFT   (5)
#define IP_TOS_MASK ((BYTE) 0x1E)
#define IP_TOS_SHIFT   (1)
#define IP_DELAY_MASK   ((BYTE) 0x10)
#define IP_THROUGHPUT_MASK ((BYTE) 0x08)
#define IP_RELIABILITY_MASK   ((BYTE) 0x04)
#define IP_FLAGS_MASK   ((BYTE) 0xE0)
#define IP_FLAGS_SHIFT  (13)
#define IP_DF_MASK   ((BYTE) 0x40)
#define IP_MF_MASK   ((BYTE) 0x20)
#define IP_MF_SHIFT     (5)
#define IP_FRAGOFF_MASK ((WORD) 0x1FFF)
#define IP_FRAGOFF_SHIFT   (3)
#define IP_TCC_MASK  ((DWORD) 0xFFFFFF00)
#define IP_TIME_OPTS_MASK  ((BYTE) 0x0F)
#define IP_MISS_STNS_MASK  ((BYTE) 0xF0)

#define IP_TIME_OPTS_SHIFT (0)
#define IP_MISS_STNS_SHIFT  (4)

//
// Offset to checksum field in ip header
//
#define IP_CHKSUM_OFF   10

INLINE BYTE IP_Version(ULPIP pIP)
{
    return (pIP->Version & IP_VERSION_MASK) >> IP_VERSION_SHIFT;
}

INLINE DWORD IP_HdrLen(ULPIP pIP)
{
    return ((pIP->HdrLen & IP_HDRLEN_MASK) >> IP_HDRLEN_SHIFT) << 2;
}

INLINE WORD IP_FragOff(ULPIP pIP)
{
    return (XCHG(pIP->FragOff) & IP_FRAGOFF_MASK) << IP_FRAGOFF_SHIFT;
}

INLINE DWORD IP_TotalLen(ULPIP pIP)
{
    return XCHG(pIP->TotalLen);
}

INLINE DWORD IP_MoreFragments(ULPIP pIP)
{
    return (pIP->Flags & IP_MF_MASK) >> IP_MF_SHIFT;
}
//
// Well known ports in the TCP/IP protocol (See RFC 1060)
//
#define PORT_TCPMUX              1  // TCP Port Service Multiplexer
#define PORT_RJE                 5  // Remote Job Entry
#define PORT_ECHO                7  // Echo
#define PORT_DISCARD             9  // Discard
#define PORT_USERS              11  // Active users
#define PORT_DAYTIME            13  // Daytime
#define PORT_NETSTAT            15  // Netstat
#define PORT_QUOTE              17  // Quote of the day
#define PORT_CHARGEN            19  // Character Generator
#define PORT_FTPDATA            20  // File transfer [default data]
#define PORT_FTP                21  // File transfer [Control]
#define PORT_TELNET             23  // Telnet
#define PORT_SMTP               25  // Simple Mail Transfer
#define PORT_NSWFE              27  // NSW User System FE
#define PORT_MSGICP             29  // MSG ICP
#define PORT_MSGAUTH            31  // MSG Authentication
#define PORT_DSP                33  // Display Support
#define PORT_PRTSERVER          35  // any private printer server
#define PORT_TIME               37  // Time
#define PORT_RLP                39  // Resource Location Protocol
#define PORT_GRAPHICS           41  // Graphics
#define PORT_NAMESERVER         42  // Host Name Server
#define PORT_NICNAME            43  // Who is
#define PORT_MPMFLAGS           44  // MPM Flags 
#define PORT_MPM                45  // Message Processing Module [recv]
#define PORT_MPMSND             46  // MPM [default send]
#define PORT_NIFTP              47  // NI FTP
#define PORT_LOGIN              49  // Login Host Protocol
#define PORT_LAMAINT            51  // IMP Logical Address Maintenance
#define PORT_DOMAIN             53  // Domain Name Server
#define PORT_ISIGL              55  // ISI Graphics Language
#define PORT_ANYTERMACC         57  // any private terminal access
#define PORT_ANYFILESYS         59  // any private file service
#define PORT_NIMAIL             61  // NI Mail
#define PORT_VIAFTP             63  // VIA Systems - FTP
#define PORT_TACACSDS           65  // TACACS - Database Service
#define PORT_BOOTPS             67  // Bootstrap Protocol server
#define PORT_BOOTPC             68  // Bootstrap Protocol client
#define PORT_TFTP               69  // Trivial File Transfer
#define PORT_NETRJS1            71  // Remote Job service
#define PORT_NETRJS2            72  // Remote Job service
#define PORT_NETRJS3            73  // Remote Job service
#define PORT_NETRJS4            74  // Remote Job service
#define PORT_ANYDIALOUT         75  // any private dial out service
#define PORT_ANYRJE             77  // any private RJE service
#define PORT_FINGER             79  // Finger
#define PORT_HTTP               80  // HTTP (www)
#define PORT_HOSTS2NS           81  // Hosts2 Name Server
#define PORT_MITMLDEV1          83  // MIT ML Device
#define PORT_MITMLDEV2          85  // MIT ML Device
#define PORT_ANYTERMLINK        87  // any private terminal link
#define PORT_SUMITTG            89  // SU/MIT Telnet Gateway
#define PORT_MITDOV             91  // MIT Dover Spooler
#define PORT_DCP                93  // Device Control Protocol
#define PORT_SUPDUP             95  // SUPDUP
#define PORT_SWIFTRVF           97  // Swift Remote Vitural File Protocol
#define PORT_TACNEWS            98  // TAC News
#define PORT_METAGRAM           99  // Metagram Relay
#define PORT_NEWACCT           100  // [Unauthorized use]
#define PORT_HOSTNAME          101  // NIC Host Name Server
#define PORT_ISOTSAP           102  // ISO-TSAP
#define PORT_X400              103  // X400
#define PORT_X400SND           104  // X400 - SND
#define PORT_CSNETNS           105  // Mailbox Name Nameserver
#define PORT_RTELNET           107  // Remote Telnet Service
#define PORT_POP2              109  // Post Office Protocol - version 2
#define PORT_POP3              110  // Post Office Protocol - version 3
#define PORT_SUNRPC            111  // SUN Remote Procedure Call
#define PORT_AUTH              113  // Authentication
#define PORT_SFTP              115  // Simple File Transfer Protocol
#define PORT_UUCPPATH          117  // UUCP Path Service
#define PORT_NNTP              119  // Network News Transfer Protocol
#define PORT_ERPC              121  // Encore Expedited Remote Proc. Call
#define PORT_NTP               123  // Network Time Protocol
#define PORT_LOCUSMAP          125  // Locus PC-Interface Net Map Sesrver
#define PORT_LOCUSCON          127  // Locus PC-Interface Conn Server
#define PORT_PWDGEN            129  // Password Generator Protocol
#define PORT_CISCOFNA          130  // CISCO FNATIVE
#define PORT_CISCOTNA          131  // CISCO TNATIVE
#define PORT_CISCOSYS          132  // CISCO SYSMAINT
#define PORT_STATSRV           133  // Statistics Service
#define PORT_INGRESNET         134  // Ingres net service
#define PORT_LOCSRV            135  // Location Service
#define PORT_PROFILE           136  // PROFILE Naming System
#define PORT_NETBIOSNS         137  // NETBIOS Name Service
#define PORT_NETBIOSDGM        138  // NETBIOS Datagram Service
#define PORT_NETBIOSSSN        139  // NETBIOS Session Service
#define PORT_EMFISDATA         140  // EMFIS Data Service
#define PORT_EMFISCNTL         141  // EMFIS Control Service
#define PORT_BLIDM             142  // Britton-Lee IDM
#define PORT_IMAP2             143  // Interim Mail Access Protocol v2
#define PORT_NEWS              144  // NewS
#define PORT_UAAC              145  // UAAC protocol
#define PORT_ISOTP0            146  // ISO-IP0
#define PORT_ISOIP             147  // ISO-IP
#define PORT_CRONUS            148  // CRONUS-Support
#define PORT_AED512            149  // AED 512 Emulation Service
#define PORT_SQLNET            150  // SQL-NET
#define PORT_HEMS              151  // HEMS
#define PORT_BFTP              152  // Background File Transfer Protocol
#define PORT_SGMP              153  // SGMP
#define PORT_NETSCPROD         154  // NETSC
#define PORT_NETSCDEV          155  // NETSC
#define PORT_SQLSRV            156  // SQL service
#define PORT_KNETCMP           157  // KNET/VM Command/Message Protocol
#define PORT_PCMAILSRV         158  // PCMail server
#define PORT_NSSROUTING        159  // NSS routing
#define PORT_SGMPTRAPS         160  // SGMP-TRAPS
#define PORT_SNMP              161  // SNMP
#define PORT_SNMPTRAP          162  // SNMPTRAP
#define PORT_CMIPMANAGE        163  // CMIP/TCP Manager
#define PORT_CMIPAGENT         164  // CMIP/TCP Agent
#define PORT_XNSCOURIER        165  // Xerox
#define PORT_SNET              166  // Sirius Systems
#define PORT_NAMP              167  // NAMP
#define PORT_RSVD              168  // RSVC
#define PORT_SEND              169  // SEND
#define PORT_PRINTSRV          170  // Network Postscript
#define PORT_MULTIPLEX         171  // Network Innovations Multiples
#define PORT_CL1               172  // Network Innovations CL/1
#define PORT_XYPLEXMUX         173  // Xyplex
#define PORT_MAILQ             174  // MAILQ
#define PORT_VMNET             175  // VMNET
#define PORT_GENRADMUX         176  // GENRAD-MUX
#define PORT_XDMCP             177  // X Display Manager Control Protocol
#define PORT_NEXTSTEP          178  // NextStep Window Server
#define PORT_BGP               179  // Border Gateway Protocol
#define PORT_RIS               180  // Intergraph
#define PORT_UNIFY             181  // Unify
#define PORT_UNISYSCAM         182  // Unisys-Cam
#define PORT_OCBINDER          183  // OCBinder
#define PORT_OCSERVER          184  // OCServer
#define PORT_REMOTEKIS         185  // Remote-KIS
#define PORT_KIS               186  // KIS protocol
#define PORT_ACI               187  // Application Communication Interface
#define PORT_MUMPS             188  // MUMPS
#define PORT_QFT               189  // Queued File Transport
#define PORT_GACP              190  // Gateway Access Control Protocol
#define PORT_PROSPERO          191  // Prospero
#define PORT_OSUNMS            192  // OSU Network Monitoring System
#define PORT_SRMP              193  // Spider Remote Monitoring Protocol
#define PORT_IRC               194  // Internet Relay Chat Protocol
#define PORT_DN6NLMAUD         195  // DNSIX Network Level Module Audit
#define PORT_DN6SMMRED         196  // DSNIX Session Mgt Module Audit Redirector
#define PORT_DLS               197  // Directory Location Service
#define PORT_DLSMON            198  // Directory Location Service Monitor
#define PORT_ATRMTP            201  // AppleTalk Routing Maintenance
#define PORT_ATNBP             202  // AppleTalk Name Binding
#define PORT_AT3               203  // AppleTalk Unused
#define PORT_ATECHO            204  // AppleTalk Echo
#define PORT_AT5               205  // AppleTalk Unused
#define PORT_ATZIS             206  // AppleTalk Zone Information
#define PORT_AT7               207  // AppleTalk Unused
#define PORT_AT8               208  // AppleTalk Unused
#define PORT_SURMEAS           243  // Survey Measurement
#define PORT_LINK              245  // LINK
#define PORT_DSP3270           246  // Display Systems Protocol
#define PORT_LDAP1             389  // LDAP
#define PORT_ISAKMP            500  // ISAKMP
#define PORT_REXEC             512  // Remote Process Execution
#define PORT_RLOGIN            513  // Remote login a la telnet
#define PORT_RSH               514  // Remote command
#define PORT_LPD               515  // Line printer spooler - LPD
#define PORT_RIP               520  // TCP=? / UDP=RIP
#define PORT_TEMPO             526  // Newdate
#define PORT_COURIER           530  // rpc
#define PORT_NETNEWS           532  // READNEWS
#define PORT_UUCPD             540  // UUCPD
#define PORT_KLOGIN            543  //
#define PORT_KSHELL            544  // krcmd
#define PORT_DSF               555  //
#define PORT_REMOTEEFS         556  // RFS server
#define PORT_CHSHELL           562  // chmod
#define PORT_METER             570  // METER
#define PORT_PCSERVER          600  // SUN IPC Server
#define PORT_NQS               607  // NQS
#define PORT_HMMP_INDICATION   612  //     
#define PORT_HMMP_OPERATION    613  //     
#define PORT_MDQS              666  // MDQS
#define PORT_LPD721            721  // LPD Client (lpd client ports 721 - 731)
#define PORT_LPD722            722  // LPD Client (see RFC 1179)
#define PORT_LPD723            723  // LPD Client
#define PORT_LPD724            724  // LPD Client
#define PORT_LPD725            725  // LPD Client
#define PORT_LPD726            726  // LPD Client
#define PORT_LPD727            727  // LPD Client
#define PORT_LPD728            728  // LPD Client
#define PORT_LPD729            729  // LPD Client
#define PORT_LPD730            730  // LPD Client
#define PORT_LPD731            731  // LPD Client
#define PORT_RFILE             750  // RFILE
#define PORT_PUMP              751  // PUMP
#define PORT_QRH               752  // QRH
#define PORT_RRH               753  // RRH
#define PORT_TELL              754  // TELL
#define PORT_NLOGIN            758  // NLOGIN
#define PORT_CON               759  // CON
#define PORT_NS                760  // NS
#define PORT_RXE               761  // RXE
#define PORT_QUOTAD            762  // QUOTAD
#define PORT_CYCLESERV         763  // CYCLESERV
#define PORT_OMSERV            764  // OMSERV
#define PORT_WEBSTER           765  // WEBSTER
#define PORT_PHONEBOOK         767  // PHONE
#define PORT_VID               769  // VID
#define PORT_RTIP              771  // RTIP
#define PORT_CYCLESERV2        772  // CYCLESERV-2
#define PORT_SUBMIT            773  // submit
#define PORT_RPASSWD           774  // RPASSWD
#define PORT_ENTOMB            775  // ENTOMB
#define PORT_WPAGES            776  // WPAGES
#define PORT_WPGS              780  // wpgs
#define PORT_MDBSDAEMON        800  // MDBS DAEMON
#define PORT_DEVICE            801  // DEVICE
#define PORT_MAITRD            997  // MAITRD
#define PORT_BUSBOY            998  // BUSBOY
#define PORT_GARCON            999  // GARCON
#define PORT_NFS              2049  // NFS
#define PORT_LDAP2            3268  // LDAP
#define PORT_PPTP             5678  // PPTP

//=============================================================================
//=============================================================================
// (NMIcmpStructs.h)
//=============================================================================
//=============================================================================

//
// ICMP Frame Structure
//
typedef struct _RequestReplyFields
    {
    WORD ID;
    WORD SeqNo;
    } 	ReqReply;

typedef struct _ParameterProblemFields
    {
    BYTE Pointer;
    BYTE junk[ 3 ];
    } 	ParmProb;

typedef struct _TimestampFields
    {
    DWORD tsOrig;
    DWORD tsRecv;
    DWORD tsXmit;
    } 	TS;

typedef struct _RouterAnnounceHeaderFields
    {
    BYTE NumAddrs;
    BYTE AddrEntrySize;
    WORD Lifetime;
    } 	RouterAH;

typedef struct _RouterAnnounceEntry
    {
    DWORD Address;
    DWORD PreferenceLevel;
    } 	RouterAE;

typedef struct _ICMP 
{
   BYTE Type;
   BYTE Code;
   WORD Checksum;
   union
   {
      DWORD    Unused;
      DWORD    Address;
      ReqReply RR;
      ParmProb PP;
      RouterAH RAH;     
   };

   union
   {
      TS       Time;
      IP       IP;
      RouterAE RAE[0];
   };
} ICMP;

typedef ICMP * LPICMP;
typedef ICMP UNALIGNED * ULPICMP;
#define	ICMP_HEADER_LENGTH	( 8 )

// # of *BYTES* of IP data to attach to
// datagram in addition to IP header
#define	ICMP_IP_DATA_LENGTH	( 8 )

//
// ICMP Packet Types
//
#define	ECHO_REPLY	( 0 )

#define	DESTINATION_UNREACHABLE	( 3 )

#define	SOURCE_QUENCH	( 4 )

#define	REDIRECT	( 5 )

#define	ECHO	( 8 )

#define	ROUTER_ADVERTISEMENT	( 9 )

#define	ROUTER_SOLICITATION	( 10 )

#define	TIME_EXCEEDED	( 11 )

#define	PARAMETER_PROBLEM	( 12 )

#define	TIMESTAMP	( 13 )

#define	TIMESTAMP_REPLY	( 14 )

#define	INFORMATION_REQUEST	( 15 )

#define	INFORMATION_REPLY	( 16 )

#define	ADDRESS_MASK_REQUEST	( 17 )

#define	ADDRESS_MASK_REPLY	( 18 )

//=============================================================================
//=============================================================================
// (NMIpxStructs.h)
//=============================================================================
//=============================================================================
//  IPX
typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0018
    {
    UCHAR ha_address[ 6 ];
    } 	HOST_ADDRESS;

typedef struct _IPXADDRESS
    {
    ULONG ipx_NetNumber;
    HOST_ADDRESS ipx_HostAddr;
    } 	IPXADDRESS;

typedef IPXADDRESS UNALIGNED * PIPXADDRESS;
typedef struct _NET_ADDRESS
    {
    IPXADDRESS na_IPXAddr;
    USHORT na_socket;
    } 	NET_ADDRESS;

typedef NET_ADDRESS UNALIGNED * UPNET_ADDRESS;
// IPX Internetwork Packet eXchange Protocol Header.
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0019
    {
    USHORT ipx_checksum;
    USHORT ipx_length;
    UCHAR ipx_xport_control;
    UCHAR ipx_packet_type;
    NET_ADDRESS ipx_dest;
    NET_ADDRESS ipx_source;
    } 	IPX_HDR;

typedef IPX_HDR UNALIGNED * ULPIPX_HDR;
//  SPX - Sequenced Packet Protocol
typedef struct _SPX_HDR
    {
    IPX_HDR spx_idp_hdr;
    UCHAR spx_conn_ctrl;
    UCHAR spx_data_type;
    USHORT spx_src_conn_id;
    USHORT spx_dest_conn_id;
    USHORT spx_sequence_num;
    USHORT spx_ack_num;
    USHORT spx_alloc_num;
    } 	SPX_HDR;

typedef SPX_HDR UNALIGNED *PSPX_HDR;
//=============================================================================
//=============================================================================
// (NMTcpStructs.h)
//=============================================================================
//=============================================================================
//
// TCP Packet Structure
//
typedef struct _TCP
    {
    WORD SrcPort;
    WORD DstPort;
    DWORD SeqNum;
    DWORD AckNum;
    BYTE DataOff;
    BYTE Flags;
    WORD Window;
    WORD Chksum;
    WORD UrgPtr;
    } 	TCP;

typedef TCP *LPTCP;

typedef TCP UNALIGNED * ULPTCP;
INLINE DWORD TCP_HdrLen(ULPTCP pTCP)
{
    return (pTCP->DataOff & 0xf0) >> 2;
}

INLINE DWORD TCP_SrcPort(ULPTCP pTCP)
{
    return XCHG(pTCP->SrcPort);
}

INLINE DWORD TCP_DstPort(ULPTCP pTCP)
{
    return XCHG(pTCP->DstPort);
}
//
// TCP Option Opcodes
//
#define	TCP_OPTION_ENDOFOPTIONS	( 0 )

#define	TCP_OPTION_NOP	( 1 )

#define	TCP_OPTION_MAXSEGSIZE	( 2 )

#define	TCP_OPTION_WSCALE	( 3 )

#define	TCP_OPTION_SACK_PERMITTED	( 4 )

#define	TCP_OPTION_SACK	( 5 )

#define	TCP_OPTION_TIMESTAMPS	( 8 )

//
// TCP Flags
//
#define	TCP_FLAG_URGENT	( 0x20 )

#define	TCP_FLAG_ACK	( 0x10 )

#define	TCP_FLAG_PUSH	( 0x8 )

#define	TCP_FLAG_RESET	( 0x4 )

#define	TCP_FLAG_SYN	( 0x2 )

#define	TCP_FLAG_FIN	( 0x1 )

//
// TCP Field Masks
//
#define	TCP_RESERVED_MASK	( 0xfc0 )


#pragma pack(pop)
//****************************************************************************
//****************************************************************************
// IDelaydC - used by a consumer to get frames after a capture has completed.
//****************************************************************************
//****************************************************************************
#define	DEFAULT_DELAYED_BUFFER_SIZE	( 1 )

#define	USE_DEFAULT_DRIVE_LETTER	( 0 )

#define	RTC_FRAME_SIZE_FULL	( 0 )



extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0000_v0_0_s_ifspec;

#ifndef __IDelaydC_INTERFACE_DEFINED__
#define __IDelaydC_INTERFACE_DEFINED__

/* interface IDelaydC */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDelaydC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BFF9C030-B58F-11ce-B5B0-00AA006CB37D")
    IDelaydC : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [out] */ char *pFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [out] */ LPSTATISTICS lpStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDelaydCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDelaydC * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDelaydC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IDelaydC * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IDelaydC * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IDelaydC * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IDelaydC * This,
            /* [out] */ char *pFileName);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDelaydC * This,
            /* [out] */ LPSTATISTICS lpStats);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IDelaydC * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalStatistics )( 
            IDelaydC * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversationStatistics )( 
            IDelaydC * This,
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpecialFrame )( 
            IDelaydC * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IDelaydC * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IDelaydCVtbl;

    interface IDelaydC
    {
        CONST_VTBL struct IDelaydCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDelaydC_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDelaydC_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDelaydC_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDelaydC_Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)	\
    ( (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob) ) 

#define IDelaydC_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IDelaydC_QueryStatus(This,pNetworkStatus)	\
    ( (This)->lpVtbl -> QueryStatus(This,pNetworkStatus) ) 

#define IDelaydC_Configure(This,hConfigurationBlob,hErrorBlob)	\
    ( (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob) ) 

#define IDelaydC_Start(This,pFileName)	\
    ( (This)->lpVtbl -> Start(This,pFileName) ) 

#define IDelaydC_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IDelaydC_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IDelaydC_Stop(This,lpStats)	\
    ( (This)->lpVtbl -> Stop(This,lpStats) ) 

#define IDelaydC_GetControlState(This,IsRunnning,IsPaused)	\
    ( (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused) ) 

#define IDelaydC_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading) ) 

#define IDelaydC_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading) ) 

#define IDelaydC_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    ( (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength) ) 

#define IDelaydC_QueryStations(This,lpQueryTable)	\
    ( (This)->lpVtbl -> QueryStations(This,lpQueryTable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDelaydC_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0000_0001 */
/* [local] */ 

//****************************************************************************
//****************************************************************************
// IRTC - used by a consumer to get an interface to local entry points
// necessary to do real time capture processing.  It includes a method
// for handing a callback to the NPP.
//****************************************************************************
//****************************************************************************
#define	DEFAULT_RTC_BUFFER_SIZE	( 0x100000 )



extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0001_v0_0_s_ifspec;

#ifndef __IRTC_INTERFACE_DEFINED__
#define __IRTC_INTERFACE_DEFINED__

/* interface IRTC */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRTC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4811EA40-B582-11ce-B5AF-00AA006CB37D")
    IRTC : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID FramesCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRTC * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRTC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IRTC * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID FramesCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IRTC * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IRTC * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IRTC * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalStatistics )( 
            IRTC * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversationStatistics )( 
            IRTC * This,
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpecialFrame )( 
            IRTC * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IRTC * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IRTCVtbl;

    interface IRTC
    {
        CONST_VTBL struct IRTCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTC_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTC_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTC_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTC_Connect(This,hInputBlob,StatusCallbackProc,FramesCallbackProc,UserContext,hErrorBlob)	\
    ( (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,FramesCallbackProc,UserContext,hErrorBlob) ) 

#define IRTC_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IRTC_QueryStatus(This,pNetworkStatus)	\
    ( (This)->lpVtbl -> QueryStatus(This,pNetworkStatus) ) 

#define IRTC_Configure(This,hConfigurationBlob,hErrorBlob)	\
    ( (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob) ) 

#define IRTC_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define IRTC_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IRTC_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IRTC_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IRTC_GetControlState(This,IsRunnning,IsPaused)	\
    ( (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused) ) 

#define IRTC_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading) ) 

#define IRTC_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading) ) 

#define IRTC_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    ( (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength) ) 

#define IRTC_QueryStations(This,lpQueryTable)	\
    ( (This)->lpVtbl -> QueryStations(This,lpQueryTable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTC_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0000_0002 */
/* [local] */ 

//****************************************************************************
//****************************************************************************
// IStats - used by a consumer to get just statistics, no frames.
//****************************************************************************
//****************************************************************************


extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0002_v0_0_s_ifspec;

#ifndef __IStats_INTERFACE_DEFINED__
#define __IStats_INTERFACE_DEFINED__

/* interface IStats */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("944AD530-B09D-11ce-B59C-00AA006CB37D")
    IStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStats * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IStats * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IStats * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IStats * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IStats * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalStatistics )( 
            IStats * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversationStatistics )( 
            IStats * This,
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpecialFrame )( 
            IStats * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IStats * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IStatsVtbl;

    interface IStats
    {
        CONST_VTBL struct IStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStats_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStats_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStats_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStats_Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)	\
    ( (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob) ) 

#define IStats_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IStats_QueryStatus(This,pNetworkStatus)	\
    ( (This)->lpVtbl -> QueryStatus(This,pNetworkStatus) ) 

#define IStats_Configure(This,hConfigurationBlob,hErrorBlob)	\
    ( (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob) ) 

#define IStats_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define IStats_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IStats_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IStats_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IStats_GetControlState(This,IsRunnning,IsPaused)	\
    ( (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused) ) 

#define IStats_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading) ) 

#define IStats_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading) ) 

#define IStats_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    ( (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength) ) 

#define IStats_QueryStations(This,lpQueryTable)	\
    ( (This)->lpVtbl -> QueryStations(This,lpQueryTable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStats_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0000_0003 */
/* [local] */ 

#pragma warning(default:4200)

#pragma pack()


extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\nsemail.h ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// File:     nsemail.h
//
// Abstract: NS_EMAIL namespace related definitions
//
//----------------------------------------------------------------------------

#ifndef _NSEMAIL_H_
#define _NSEMAIL_H_

typedef enum napi_provider_type_tag
{ 
    ProviderType_Application = 1, 
    ProviderType_Service, 
} NAPI_PROVIDER_TYPE;

typedef enum napi_provider_level_tag
{ 
    ProviderLevel_None = 0,
    ProviderLevel_Secondary, 
    ProviderLevel_Primary
} NAPI_PROVIDER_LEVEL;

//-----------------------------------------------------------------------------
// 
// Layout of Installation Blob for Email Naming NSPv2 Providers:
//
// +-------------------------------------------------------------------------+
// |                     NAPI_PROVIDER_INSTALLATION_BLOB                     |
// | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
// | dwVersion                                                               |
// | dwProviderType                                                          |
// | fSupportsWildCard                                                       |
// | cDomains (equal to N in this example)                                   |
// | OffsetFirstDomain (aligned offset of NAPI_DOMAIN_DESCRIPTION_BLOB # 1)  |
// | +---------------------------------------------------------------------+ |
// | |                   NAPI_DOMAIN_DESCRIPTION_BLOB # 1                  | |
// | | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + |
// | | AuthLevel                                                           | |
// | | cchDomainName                                                       | |
// | | OffsetNextDomainDescription (aligned offset of Domain Blob # 2)     | |
// | | OffsetThisDomainName (aligned offset of Domain Name 1)              | |
// | +---------------------------------------------------------------------+ |
// | +---------------------------------------------------------------------+ |
// | |                   NAPI_DOMAIN_DESCRIPTION_BLOB # 2                  | |
// | | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + |
// | | AuthLevel                                                           | |
// | | cchDomainName                                                       | |
// | | OffsetNextDomainDescription (aligned offset of Domain Blob # 3)     | |
// | | OffsetThisDomainName (aligned offset of Domain Name 2)              | |
// | +---------------------------------------------------------------------+ |
// | ... ... ...                                                             |
// | ... ... ...                                                             |
// | ... ... ...                                                             |
// | +---------------------------------------------------------------------+ |
// | |                   NAPI_DOMAIN_DESCRIPTION_BLOB # N                  | |
// | | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + |
// | | AuthLevel                                                           | |
// | | cchDomainName                                                       | |
// | | OffsetNextDomainDescription (should be 0 if N is the last domain)   | |
// | | OffsetThisDomainName (aligned offset of Domain Name N)              | |
// | +---------------------------------------------------------------------+ |
// | Domain Name 1                                                           |
// | Domain Name 2                                                           |
// | ... ... ...                                                             |
// | Domain Name N                                                           |
// +-------------------------------------------------------------------------+
//
// Notes: - The above NAPI_PROVIDER_INSTALLATION_BLOB must be passed to 
//          WSCInstallNameSpaceEx encapsulated in a winsock2.h's BLOB 
//          (typedef struct _BLOB { ULONG  cbSize; BYTE * pBlobData;} BLOB;)
//          by storing its address in pBlobData, and its total size in 
//          cbSize.
//        - The NAPI_PROVIDER_INSTALLATION_BLOB must be at an address at
//          least 4-bytes aligned, better if machine-pointer-size aligned.
//        - Domain Blob (NAPI_DOMAIN_DESCRIPTION_BLOB) offsets need to be 
//          4-bytes aligned. 
//        - Domain Name offsets need to be 2-bytes aligned.
//        - Domain Names are strings of UNICODE chars and they must be at
//          least cchDomainName UNICODE chars long. Zero-termination is 
//          recommended but not required.
//        - Domain Blobs (NAPI_DOMAIN_DESCRIPTION_BLOBs) do not need to be 
//          contiguous and Domain Name strings do not need to be in order 
//          or grouped after the Domain Blobs, as in the example above.
//          They may appear in any order and also interleaved with Domain 
//          Blobs, as long as the alignment rules are respected.
//       
//-----------------------------------------------------------------------------

typedef struct napi_domain_description_blob_tag
{
    DWORD   AuthLevel;
    DWORD   cchDomainName;
    DWORD   OffsetNextDomainDescription;
    DWORD   OffsetThisDomainName;
} NAPI_DOMAIN_DESCRIPTION_BLOB;

typedef struct napi_provider_installation_blob_tag
{
    DWORD   dwVersion;
    DWORD   dwProviderType;
    DWORD   fSupportsWildCard;
    ULONG   cDomains;
    ULONG   OffsetFirstDomain;
} NAPI_PROVIDER_INSTALLATION_BLOB;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\nsscore.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for nsscore.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __nsscore_h__
#define __nsscore_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSClassObject_FWD_DEFINED__
#define __IWMSClassObject_FWD_DEFINED__
typedef interface IWMSClassObject IWMSClassObject;
#endif 	/* __IWMSClassObject_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmscontext.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_nsscore_0000_0000 */
/* [local] */ 

//*****************************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// Automatically generated by Midl from nsscore.idl
//
// DO NOT EDIT THIS FILE.
//
//*****************************************************************************
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_IWMSClassObject, 0xF54E23A4,0x1B1A,0x11d1,0x9E,0x90,0x00,0x60,0x97,0xD2,0xD7,0xCF );


extern RPC_IF_HANDLE __MIDL_itf_nsscore_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_nsscore_0000_0000_v0_0_s_ifspec;

#ifndef __IWMSClassObject_INTERFACE_DEFINED__
#define __IWMSClassObject_INTERFACE_DEFINED__

/* interface IWMSClassObject */
/* [object][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IWMSClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F54E23A4-1B1A-11d1-9E90-006097D2D7CF")
    IWMSClassObject : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocIWMSPacket( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocIWMSPacketList( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocIWMSContext( 
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ WMS_CONTEXT_TYPE ContextType,
            /* [in] */ __RPC__in_opt IUnknown *pRelatedContext,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocIWMSCommandContext( 
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ __RPC__in_opt IUnknown *pRelatedContext,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSClassObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocIWMSPacket )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocIWMSPacketList )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocIWMSContext )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ WMS_CONTEXT_TYPE ContextType,
            /* [in] */ __RPC__in_opt IUnknown *pRelatedContext,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocIWMSCommandContext )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ __RPC__in_opt IUnknown *pRelatedContext,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        END_INTERFACE
    } IWMSClassObjectVtbl;

    interface IWMSClassObject
    {
        CONST_VTBL struct IWMSClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSClassObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSClassObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSClassObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSClassObject_CreateInstance(This,riid,ppunk)	\
    ( (This)->lpVtbl -> CreateInstance(This,riid,ppunk) ) 

#define IWMSClassObject_AllocIWMSPacket(This,riid,ppunk)	\
    ( (This)->lpVtbl -> AllocIWMSPacket(This,riid,ppunk) ) 

#define IWMSClassObject_AllocIWMSPacketList(This,riid,ppunk)	\
    ( (This)->lpVtbl -> AllocIWMSPacketList(This,riid,ppunk) ) 

#define IWMSClassObject_AllocIWMSContext(This,riid,ContextType,pRelatedContext,ppunk)	\
    ( (This)->lpVtbl -> AllocIWMSContext(This,riid,ContextType,pRelatedContext,ppunk) ) 

#define IWMSClassObject_AllocIWMSCommandContext(This,riid,pRelatedContext,ppunk)	\
    ( (This)->lpVtbl -> AllocIWMSCommandContext(This,riid,pRelatedContext,ppunk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSClassObject_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\notesdeviceservice.h ===
/*
 *  NotesDeviceService.h
 *
 *  Contains declarations for the Notes Device Service
 *
 *  Copyright (c) Microsoft Corporation, All Rights Reserved.
 *
 */

#ifndef _NOTESDEVICESERVICE_H_
#define _NOTESDEVICESERVICE_H_

#include <DeviceServices.h>
#include <MessageDeviceService.h>


/*****************************************************************************/
/*  Notes Service Info                                                       */
/*****************************************************************************/

DEFINE_DEVSVCGUID(SERVICE_Notes,
    0x5c017aea, 0xe706, 0x4719, 0x8c, 0xc0, 0xa3, 0x03, 0x83, 0x6f, 0xd3, 0x21);

#define NAME_NotesSvc                       L"Notes"
#define TYPE_NotesSvc                       DEVSVCTYPE_DEFAULT


/*****************************************************************************/
/*  Notes Service Object Formats                                             */
/*****************************************************************************/

/*  FORMAT_AbstractNote
 */

DEFINE_DEVSVCGUID(FORMAT_AbstractNote,
    0xb3d1b688, 0x39f6, 0x4703, 0xb3, 0x39, 0xc6, 0x9b, 0x7d, 0x2a, 0xbb, 0x3f);

#define NAME_AbstractNote                   L"AbstractNote"


/*****************************************************************************/
/*  Notes Service Object Property Keys                                       */
/*****************************************************************************/

DEFINE_DEVSVCGUID(NAMESPACE_NotesObj,
    0x5FFBFC7B, 0x7483, 0x41AD, 0xAF, 0xB9, 0xDA, 0x3F, 0x4E, 0x59, 0x2B, 0x8D);

#endif  /* _NOTESDEVICESERVICE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\NtDDPSch.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ntddpsch.h

Abstract:

    defines that are exported to user mode

Author:

Revision History:

--*/

#ifndef _NTDDPSCH_
#define _NTDDPSCH_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// flow data returned in the Stats structure
//

#pragma pack(1)
typedef struct _PS_COMPONENT_STATS {

#define PS_COMPONENT_ADAPTER        1
#define PS_COMPONENT_FLOW           2
#define PS_COMPONENT_CONFORMER      3
#define PS_COMPONENT_SHAPER         4
#define PS_COMPONENT_DRRSEQ         5

    ULONG Type;
    ULONG Length;
    UCHAR Stats[1];
} PS_COMPONENT_STATS, *PPS_COMPONENT_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_CONFORMER_STATS {
    ULONG NonconformingPacketsScheduled;
} PS_CONFORMER_STATS, *PPS_CONFORMER_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_SHAPER_STATS {
    ULONG MaxPacketsInShaper;
    ULONG AveragePacketsInShaper;
} PS_SHAPER_STATS, *PPS_SHAPER_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_DRRSEQ_STATS {
    ULONG MaxPacketsInNetcard;
    ULONG AveragePacketsInNetcard;
    ULONG MaxPacketsInSequencer;
    ULONG AveragePacketsInSequencer;
    ULONG NonconformingPacketsTransmitted;
} PS_DRRSEQ_STATS, *PPS_DRRSEQ_STATS;
#pragma pack()


#pragma pack(1)
typedef struct _PS_FLOW_STATS {

    ULONG DroppedPackets;
    ULONG PacketsScheduled;
	ULONG PacketsTransmitted;
    LARGE_INTEGER BytesScheduled;
    LARGE_INTEGER BytesTransmitted;
} PS_FLOW_STATS, *PPS_FLOW_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_ADAPTER_STATS {

    //
    // OutOfPackets is incremented when no packets for sending/receive packet
    // indications are available.
    //

    ULONG OutOfPackets;

    //
    // general flow stats
    //

    ULONG FlowsOpened;
    ULONG FlowsClosed;
    ULONG FlowsRejected;
    ULONG FlowsModified;
    ULONG FlowModsRejected;
    ULONG MaxSimultaneousFlows;

} PS_ADAPTER_STATS, *PPS_ADAPTER_STATS;
#pragma pack()

//
// Defines that can be used for OID_QOS_FLOW_MODE
//
#define ADAPTER_FLOW_MODE_DIFFSERV           1
#define ADAPTER_FLOW_MODE_STANDARD           2


#ifdef __cplusplus
}
#endif

#endif /* _NTDDPSCH_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\newdev.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    newdev.h

Abstract:

    Public header file for Windows NT Driver Installation DLL.

--*/

#ifndef _INC_NEWDEV
#define _INC_NEWDEV

#include <pshpack1.h>   // Assume byte packing throughout
#include <setupapi.h>   // for HDEVINFO, PSP_DEVINFO_DATA, and PSP_DRVINFO_DATA

#ifdef __cplusplus
extern "C" {
#endif

//
// Flags for UpdateDriverForPlugAndPlayDevices
//
#define INSTALLFLAG_FORCE               0x00000001  // Force the installation of the specified driver
#define INSTALLFLAG_READONLY            0x00000002  // Do a read-only install (no file copy)
#define INSTALLFLAG_NONINTERACTIVE      0x00000004  // No UI shown at all. API will fail if any UI must be shown.
#define INSTALLFLAG_BITS                0x00000007

#if (WINVER >= _WIN32_WINNT_WIN2K)

BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesA(
    __in_opt  HWND hwndParent,
    __in      LPCSTR HardwareId,
    __in      LPCSTR FullInfPath,
    __in      DWORD InstallFlags,
    __out_opt PBOOL bRebootRequired
    );

BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesW(
    __in_opt  HWND hwndParent,
    __in      LPCWSTR HardwareId,
    __in      LPCWSTR FullInfPath,
    __in      DWORD InstallFlags,
    __out_opt PBOOL bRebootRequired
    );

#ifdef UNICODE
#define UpdateDriverForPlugAndPlayDevices UpdateDriverForPlugAndPlayDevicesW
#else
#define UpdateDriverForPlugAndPlayDevices UpdateDriverForPlugAndPlayDevicesA
#endif
#endif // (WINVER >= _WIN32_WINNT_WIN2K)

#if (WINVER >= _WIN32_WINNT_LONGHORN)
//
// Flags for DiInstallDevice
//
#define DIIDFLAG_SHOWSEARCHUI           0x00000001      // Show search UI if no drivers can be found.
#define DIIDFLAG_NOFINISHINSTALLUI      0x00000002      // Do NOT show the finish install UI.
#define DIIDFLAG_INSTALLNULLDRIVER      0x00000004      // Install the NULL driver on this device.
#define DIIDFLAG_BITS                   0x00000007

BOOL
WINAPI
DiInstallDevice(
    __in_opt  HWND hwndParent,
    __in      HDEVINFO DeviceInfoSet,
    __in      PSP_DEVINFO_DATA DeviceInfoData,
    __in_opt  PSP_DRVINFO_DATA DriverInfoData,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)

#if (WINVER >= _WIN32_WINNT_LONGHORN)

//
// Flags for DiInstallDriver
//
#define DIIRFLAG_INF_ALREADY_COPIED 0x00000001   // Don't copy inf, it has been published
#define DIIRFLAG_FORCE_INF          0x00000002   // use the inf as if users picked it.
#define DIIRFLAG_HW_USING_THE_INF   0x00000004   // limit installs on hw using the inf
#define DIIRFLAG_HOTPATCH           0x00000008   // Perform a hotpatch service pack install
#define DIIRFLAG_NOBACKUP           0x00000010   // install w/o backup and no rollback
#define DIIRFLAG_BITS ( DIIRFLAG_FORCE_INF | DIIRFLAG_HOTPATCH)
#define DIIRFLAG_SYSTEM_BITS ( DIIRFLAG_INF_ALREADY_COPIED |\
                               DIIRFLAG_FORCE_INF |\
                               DIIRFLAG_HW_USING_THE_INF |\
                               DIIRFLAG_HOTPATCH |\
                               DIIRFLAG_NOBACKUP )

BOOL
WINAPI
DiInstallDriverW(
    __in_opt  HWND hwndParent,
    __in      LPCWSTR InfPath,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );

BOOL
WINAPI
DiInstallDriverA(
    __in_opt  HWND hwndParent,
    __in      LPCSTR InfPath,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );


#ifdef UNICODE
#define DiInstallDriver DiInstallDriverW
#else
#define DiInstallDriver DiInstallDriverA
#endif
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)


#if (WINVER >= _WIN32_WINNT_WIN7)
BOOL
WINAPI
DiUninstallDevice(
    __in      HWND hwndParent,
    __in      HDEVINFO DeviceInfoSet,
    __in      PSP_DEVINFO_DATA DeviceInfoData,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );
#endif // (WINVER >= _WIN32_WINNT_WIN7)


#if (WINVER >= _WIN32_WINNT_LONGHORN)
BOOL
WINAPI
DiShowUpdateDevice(
    __in_opt  HWND hwndParent,
    __in      HDEVINFO DeviceInfoSet,
    __in      PSP_DEVINFO_DATA DeviceInfoData,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );


//
// DiRollbackDriver Flag values
//
#define ROLLBACK_FLAG_NO_UI             0x00000001  // don't show any UI (this could cause failures if UI must be displayed)
#define ROLLBACK_BITS                   0x00000001


BOOL
WINAPI
DiRollbackDriver(
    __in      HDEVINFO DeviceInfoSet,
    __in      PSP_DEVINFO_DATA DeviceInfoData,
    __in_opt  HWND hwndParent,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)


#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _INC_NEWDEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\Npapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    npapi.h

Abstract:

    Network Provider API prototypes and manifests.  A network provider
    is a client of the Win32 WNet APIs.  See the "NT/Win32 Network
    Provider API Specification" document for further details.

Environment:

    User Mode -Win32

--*/

#ifndef _NPAPI_INCLUDED
#define _NPAPI_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
//  CONNECTIONS
//

DWORD APIENTRY
NPAddConnection (
    __in     LPNETRESOURCEW lpNetResource,
    __in_opt LPWSTR         lpPassword,
    __in_opt LPWSTR         lpUserName
    );

typedef DWORD (APIENTRY *PF_NPAddConnection) (
    __in     LPNETRESOURCEW lpNetResource,
    __in_opt LPWSTR         lpPassword,
    __in_opt LPWSTR         lpUserName
    );


DWORD APIENTRY
NPAddConnection3 (
    __in_opt HWND           hwndOwner,
    __in     LPNETRESOURCEW lpNetResource,
    __in_opt LPWSTR         lpPassword,
    __in_opt LPWSTR         lpUserName,
    __in     DWORD          dwFlags
    );

typedef DWORD (APIENTRY *PF_NPAddConnection3) (
    __in_opt HWND           hwndOwner,
    __in     LPNETRESOURCEW lpNetResource,
    __in_opt LPWSTR         lpPassword,
    __in_opt LPWSTR         lpUserName,
    __in     DWORD          dwFlags
    );


DWORD APIENTRY
NPCancelConnection (
    __in LPWSTR  lpName,
    __in BOOL    fForce
    );

typedef DWORD (APIENTRY *PF_NPCancelConnection) (
    __in LPWSTR  lpName,
    __in BOOL    fForce
    );


DWORD APIENTRY
NPGetConnection (
    __in LPWSTR     lpLocalName,
    __out_ecount_opt(*lpnBufferLen) LPWSTR lpRemoteName,
    __inout LPDWORD lpnBufferLen
    );

typedef DWORD (APIENTRY *PF_NPGetConnection) (
    __in LPWSTR   lpLocalName,
    __out_ecount_opt(*lpnBufferLen) LPWSTR lpRemoteName,
    __inout LPDWORD lpnBufferLen
    );


#define WNGETCON_CONNECTED      0x00000000
#define WNGETCON_DISCONNECTED   0x00000001

DWORD APIENTRY
NPGetConnection3 (
    __in LPCWSTR    lpLocalName,
    __in DWORD      dwLevel,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

typedef DWORD (APIENTRY *PF_NPGetConnection3) (
    __in LPCWSTR    lpLocalName,
    __in DWORD      dwLevel,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );


DWORD APIENTRY
NPGetUniversalName (
    __in LPCWSTR    lpLocalPath,
    __in DWORD      dwInfoLevel,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

typedef DWORD (APIENTRY *PF_NPGetUniversalName) (
    __in LPCWSTR    lpLocalPath,
    __in DWORD      dwInfoLevel,
    __out_bcount(*lpnBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpnBufferSize
    );

DWORD APIENTRY
NPGetConnectionPerformance (
    __in  LPCWSTR                lpRemoteName,
    __out LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    );

typedef DWORD (APIENTRY *PF_NPGetConnectionPerformance) (
    __in  LPCWSTR                lpRemoteName,
    __out LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    );


DWORD APIENTRY
NPOpenEnum (
    __in     DWORD          dwScope,
    __in     DWORD          dwType,
    __in     DWORD          dwUsage,
    __in_opt LPNETRESOURCEW lpNetResource,
    __out    LPHANDLE       lphEnum
    );

typedef DWORD (APIENTRY *PF_NPOpenEnum) (
    __in     DWORD          dwScope,
    __in     DWORD          dwType,
    __in     DWORD          dwUsage,
    __in_opt LPNETRESOURCEW lpNetResource,
    __out    LPHANDLE       lphEnum
    );

DWORD APIENTRY
NPEnumResource (
    __in    HANDLE  hEnum,
    __inout LPDWORD lpcCount,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

typedef DWORD (APIENTRY *PF_NPEnumResource) (
    __in    HANDLE  hEnum,
    __inout LPDWORD lpcCount,
    __out_bcount(*lpbufferSize) LPVOID  lpBuffer,
    __inout LPDWORD lpBufferSize
    );

DWORD APIENTRY
NPCloseEnum (
    __in HANDLE   hEnum
    );

typedef DWORD (APIENTRY *PF_NPCloseEnum) (
    __in HANDLE   hEnum
    );


//
//  CAPABILITIES
//

#define WNNC_SPEC_VERSION                0x00000001
#define WNNC_SPEC_VERSION51              0x00050001

#define WNNC_NET_TYPE                    0x00000002
#define WNNC_NET_NONE                    0x00000000

#define WNNC_DRIVER_VERSION              0x00000003

#define WNNC_USER                        0x00000004
#define WNNC_USR_GETUSER                 0x00000001

#define WNNC_CONNECTION                  0x00000006
#define WNNC_CON_ADDCONNECTION           0x00000001
#define WNNC_CON_CANCELCONNECTION        0x00000002
#define WNNC_CON_GETCONNECTIONS          0x00000004
#define WNNC_CON_ADDCONNECTION3          0x00000008
#define WNNC_CON_GETPERFORMANCE          0x00000040
#define WNNC_CON_DEFER                   0x00000080

#define WNNC_DIALOG                      0x00000008
#define WNNC_DLG_DEVICEMODE              0x00000001
#define WNNC_DLG_PROPERTYDIALOG          0x00000020
#define WNNC_DLG_SEARCHDIALOG            0x00000040
#define WNNC_DLG_FORMATNETWORKNAME       0x00000080
#define WNNC_DLG_PERMISSIONEDITOR        0x00000100
#define WNNC_DLG_GETRESOURCEPARENT       0x00000200
#define WNNC_DLG_GETRESOURCEINFORMATION  0x00000800

#define WNNC_ADMIN                       0x00000009
#define WNNC_ADM_GETDIRECTORYTYPE        0x00000001
#define WNNC_ADM_DIRECTORYNOTIFY         0x00000002

#define WNNC_ENUMERATION                 0x0000000B
#define WNNC_ENUM_GLOBAL                 0x00000001
#define WNNC_ENUM_LOCAL                  0x00000002
#define WNNC_ENUM_CONTEXT                0x00000004
#define WNNC_ENUM_SHAREABLE              0x00000008

#define WNNC_START                       0x0000000C
#define WNNC_WAIT_FOR_START              0x00000001

#define WNNC_CONNECTION_FLAGS            0x0000000D
#define WNNC_CF_DEFAULT ( CONNECT_TEMPORARY | CONNECT_INTERACTIVE | CONNECT_PROMPT )
#define WNNC_CF_MAXIMUM (WNNC_CF_DEFAULT | CONNECT_DEFERRED | CONNECT_COMMANDLINE | CONNECT_CMD_SAVECRED | CONNECT_CRED_RESET)



DWORD APIENTRY
NPGetCaps (
    __in DWORD ndex
    );

typedef DWORD (APIENTRY *PF_NPGetCaps) (
    __in DWORD ndex
    );

//
//  OTHER
//

DWORD APIENTRY
NPGetUser (
    __in    LPWSTR  lpName,
    __out_ecount(*lpnBufferLen) LPWSTR lpUserName,
    __inout LPDWORD lpnBufferLen
    );

typedef DWORD (APIENTRY *PF_NPGetUser) (
    __in    LPWSTR  lpName,
    __out_ecount(*lpnBufferLen) LPWSTR lpUserName,
    __inout LPDWORD lpnBufferLen
    );

#define WNTYPE_DRIVE    1
#define WNTYPE_FILE     2
#define WNTYPE_PRINTER  3
#define WNTYPE_COMM     4

#define WNPS_FILE       0
#define WNPS_DIR        1
#define WNPS_MULT       2

DWORD APIENTRY
NPDeviceMode(
    __in HWND hParent
    );

typedef DWORD (APIENTRY *PF_NPDeviceMode) (
    __in HWND hParent
    );

// flag for search dialog
#define WNSRCH_REFRESH_FIRST_LEVEL 0x00000001

DWORD APIENTRY
NPSearchDialog(
    __in     HWND   hwndParent,
    __in_opt LPNETRESOURCEW lpNetResource,
    __out_ecount(cbBuffer) LPVOID lpBuffer,
    __in     DWORD   cbBuffer,
    __out    LPDWORD lpnFlags
    );

typedef DWORD (APIENTRY *PF_NPSearchDialog) (
    __in     HWND   hwndParent,
    __in_opt LPNETRESOURCEW lpNetResource,
    __out_ecount(cbBuffer) LPVOID lpBuffer,
    __in     DWORD   cbBuffer,
    __out    LPDWORD lpnFlags
    );

DWORD APIENTRY
NPGetResourceParent(
    __in LPNETRESOURCEW lpNetResource,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

typedef DWORD (APIENTRY *PF_NPGetResourceParent) (
    __in LPNETRESOURCEW lpNetResource,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize
    );

DWORD APIENTRY NPGetResourceInformation(
    __in LPNETRESOURCEW lpNetResource,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize,
    __deref_out LPWSTR *lplpSystem
    );

typedef DWORD (APIENTRY *PF_NPGetResourceInformation) (
    __in LPNETRESOURCEW lpNetResource,
    __out_bcount(*lpBufferSize) LPVOID lpBuffer,
    __inout LPDWORD lpBufferSize,
    __deref_out LPWSTR *lplpSystem
    );

DWORD APIENTRY
NPFormatNetworkName(
    __in    LPWSTR   lpRemoteName,
    __out_ecount(*lpnLength) LPWSTR lpFormattedName,
    __inout LPDWORD  lpnLength,
    __in    DWORD    dwFlags,
    __in    DWORD    dwAveCharPerLine
    );

typedef DWORD (APIENTRY *PF_NPFormatNetworkName) (
    __in    LPWSTR   lpRemoteName,
    __out_ecount(*lpnLength) LPWSTR lpFormattedName,
    __inout LPDWORD  lpnLength,
    __in    DWORD    dwFlags,
    __in    DWORD    dwAveCharPerLine
    );

DWORD APIENTRY
NPGetPropertyText(
    __in DWORD  iButton,
    __in DWORD  nPropSel,
    __in LPWSTR lpName,
    __out_ecount(nButtonNameLen) LPWSTR lpButtonName,
    __in DWORD  nButtonNameLen,
    __in DWORD  nType
    );

typedef DWORD (APIENTRY *PF_NPGetPropertyText) (
    __in DWORD  iButton,
    __in DWORD  nPropSel,
    __in LPWSTR lpName,
    __out_ecount(nButtonNameLen) LPWSTR lpButtonName,
    __in DWORD  nButtonNameLen,
    __in DWORD  nType
    );

DWORD APIENTRY
NPPropertyDialog(
    __in HWND   hwndParent,
    __in DWORD  iButtonDlg,
    __in DWORD  nPropSel,
    __in LPWSTR lpFileName,
    __in DWORD  nType
    );

typedef DWORD (APIENTRY *PF_NPPropertyDialog) (
    __in HWND   hwndParent,
    __in DWORD  iButtonDlg,
    __in DWORD  nPropSel,
    __in LPWSTR lpFileName,
    __in DWORD  nType
    );


//
//  ADMIN
//

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR    1
#define WNDN_RMDIR    2
#define WNDN_MVDIR    3

DWORD APIENTRY
NPGetDirectoryType (
    __in LPWSTR  lpName,
    __in LPINT   lpType,
    __in BOOL    bFlushCache
    );

typedef DWORD (APIENTRY *PF_NPGetDirectoryType) (
    __in LPWSTR  lpName,
    __in LPINT   lpType,
    __in BOOL    bFlushCache
    );

DWORD APIENTRY
NPDirectoryNotify (
    __in HWND    hwnd,
    __in LPWSTR  lpDir,
    __in DWORD   dwOper
    );

typedef DWORD (APIENTRY *PF_NPDirectoryNotify) (
    __in HWND    hwnd,
    __in LPWSTR  lpDir,
    __in DWORD   dwOper
    );

VOID
WNetSetLastErrorA(
    __in DWORD   err,
    __in LPSTR   lpError,
    __in LPSTR   lpProviders
    );

VOID
WNetSetLastErrorW(
    __in DWORD   err,
    __in LPWSTR  lpError,
    __in LPWSTR  lpProviders
    );

#ifdef UNICODE
#define WNetSetLastError   WNetSetLastErrorW
#else
#define WNetSetLastError   WNetSetLastErrorA
#endif  // UNICODE

//
//  CREDENTIAL MANAGEMENT and other classes of providers
//


// Define the Net/Authentication and othr Provider Classes
#define WN_NETWORK_CLASS            0x00000001
#define WN_CREDENTIAL_CLASS         0x00000002
#define WN_PRIMARY_AUTHENT_CLASS    0x00000004
#define WN_SERVICE_CLASS            0x00000008

#define WN_VALID_LOGON_ACCOUNT      0x00000001
#define WN_NT_PASSWORD_CHANGED      0x00000002

DWORD APIENTRY
NPLogonNotify (
    __in     PLUID               lpLogonId,
    __in     LPCWSTR             lpAuthentInfoType,
    __in     LPVOID              lpAuthentInfo,
    __in_opt LPCWSTR             lpPreviousAuthentInfoType,
    __in_opt LPVOID              lpPreviousAuthentInfo,
    __in     LPWSTR              lpStationName,
    __in_opt LPVOID              StationHandle,
    __out    LPWSTR              *lpLogonScript
    );

typedef DWORD (APIENTRY *PF_NPLogonNotify) (
    __in     PLUID               lpLogonId,
    __in     LPCWSTR             lpAuthentInfoType,
    __in     LPVOID              lpAuthentInfo,
    __in_opt LPCWSTR             lpPreviousAuthentInfoType,
    __in_opt LPVOID              lpPreviousAuthentInfo,
    __in     LPWSTR              lpStationName,
    __in_opt LPVOID              StationHandle,
    __out    LPWSTR              *lpLogonScript
    );

DWORD APIENTRY
NPPasswordChangeNotify (
    __in     LPCWSTR             lpAuthentInfoType,
    __in     LPVOID              lpAuthentInfo,
    __in     LPCWSTR             lpPreviousAuthentInfoType,
    __in     LPVOID              lpPreviousAuthentInfo,
    __in     LPWSTR              lpStationName,
    __in_opt LPVOID              StationHandle,
    __in     DWORD               dwChangeInfo
    );

typedef DWORD (APIENTRY *PF_NPPasswordChangeNotify) (
    __in     LPCWSTR             lpAuthentInfoType,
    __in     LPVOID              lpAuthentInfo,
    __in     LPCWSTR             lpPreviousAuthentInfoType,
    __in     LPVOID              lpPreviousAuthentInfo,
    __in     LPWSTR              lpStationName,
    __in_opt LPVOID              StationHandle,
    __in     DWORD               dwChangeInfo
    );

//
//  CONNECTION NOTIFICATION
//

//
// NotifyStatus
//
#define NOTIFY_PRE      0x00000001
#define NOTIFY_POST     0x00000002

typedef struct _NOTIFYINFO {
    DWORD       dwNotifyStatus;
    DWORD       dwOperationStatus;
    LPVOID      lpContext;
} NOTIFYINFO, *LPNOTIFYINFO;

typedef struct _NOTIFYADD {
    HWND            hwndOwner;
    NETRESOURCE     NetResource;
    DWORD           dwAddFlags;
} NOTIFYADD, *LPNOTIFYADD;

typedef struct _NOTIFYCANCEL {
    LPWSTR      lpName;
    LPWSTR      lpProvider;
    DWORD       dwFlags;
    BOOL        fForce;
} NOTIFYCANCEL, *LPNOTIFYCANCEL;


DWORD APIENTRY
AddConnectNotify (
    __inout LPNOTIFYINFO lpNotifyInfo,
    __in    LPNOTIFYADD  lpAddInfo
    );

typedef DWORD (APIENTRY *PF_AddConnectNotify) (
    __inout LPNOTIFYINFO lpNotifyInfo,
    __in    LPNOTIFYADD  lpAddInfo
    );

DWORD APIENTRY
CancelConnectNotify (
    __inout LPNOTIFYINFO   lpNotifyInfo,
    __in    LPNOTIFYCANCEL lpCancelInfo
    );

typedef DWORD (APIENTRY *PF_CancelConnectNotify) (
    __inout LPNOTIFYINFO   lpNotifyInfo,
    __in    LPNOTIFYCANCEL lpCancelInfo
    );

//
// Permission editor dialogs
//

//
// Capabilities bits of permission editor dialogs
//
#define WNPERMC_PERM  0x00000001
#define WNPERMC_AUDIT 0x00000002
#define WNPERMC_OWNER 0x00000004

DWORD APIENTRY
NPFMXGetPermCaps (
    __in LPWSTR lpDriveName
    );

typedef DWORD (APIENTRY *PF_NPFMXGetPermCaps) (
    __in LPWSTR lpDriveName
    );

//
// Type of security dialog
//
#define WNPERM_DLG_PERM   0
#define WNPERM_DLG_AUDIT  1
#define WNPERM_DLG_OWNER  2

DWORD APIENTRY
NPFMXEditPerm (
    __in LPWSTR lpDriveName,
    __in HWND   hwndFMX,
    __in DWORD  nDialogType
    );

typedef DWORD (APIENTRY *PF_NPFMXEditPerm) (
    __in LPWSTR lpDriveName,
    __in HWND   hwndFMX,
    __in DWORD  nDialogType
    );

DWORD APIENTRY
NPFMXGetPermHelp (
    __in    LPWSTR  lpDriveName,
    __in    DWORD   nDialogType,
    __in    BOOL    fDirectory,
    __out_ecount(*lpBufferSize) LPVOID lpFileNameBuffer,
    __inout LPDWORD lpBufferSize,
    __out   LPDWORD lpnHelpContext
    );

typedef DWORD (APIENTRY *PF_NPFMXGetPermHelp) (
    __in    LPWSTR  lpDriveName,
    __in    DWORD   nDialogType,
    __in    BOOL    fDirectory,
    __out_ecount(*lpBufferSize) LPVOID lpFileNameBuffer,
    __inout LPDWORD lpBufferSize,
    __out   LPDWORD lpnHelpContext
    );

#ifdef __cplusplus
}
#endif

#endif  // _NPAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\NtDDNdis.h ===
/*++ BUILD Version: 0001        // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddndis.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Network driver interface device.

Author:

    NDIS/ATM Development Team

Revision History:

    added the correct values for NDIS 3.0.
    added Pnp IoCTLs and structures
    added general co ndis oids.
    added PnP and PM OIDs.

--*/

#ifndef _NTDDNDIS_
#define _NTDDNDIS_

#if _MSC_VER > 1000
#pragma once
#endif

//disable warnings
#if _MSC_VER >= 1200

#pragma warning(push)

#endif

#pragma warning(disable:4201) // named type definition in parentheses

#ifdef __cplusplus
extern "C" {
#endif

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
#include <ifdef.h>
#include <devpkey.h>
#include <pciprop.h>
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//
// Something to identify new (Win7 and up) applications. 
// User-mode only. For drivers, NDIS_SUPPORT_NDIS620 is already
// defined in ndismain.w.
//
#if !defined(NDIS_SUPPORT_NDIS620)
#if  (defined (UM_NDIS620))
#define NDIS_SUPPORT_NDIS620      1
#else
#define NDIS_SUPPORT_NDIS620      0
#endif
#endif // !defined(NDIS_SUPPORT_NDIS620)

//
// Something to identify new (LH Server and up) applications. 
// User-mode only. For drivers, NDIS_SUPPORT_NDIS61 is already
// defined in ndismain.w.
//
#if !defined(NDIS_SUPPORT_NDIS61)
#if  (defined (UM_NDIS61) || defined (UM_NDIS620))
#define NDIS_SUPPORT_NDIS61      1
#else
#define NDIS_SUPPORT_NDIS61      0
#endif
#endif // !defined(NDIS_SUPPORT_NDIS61)

//
// Device Name - this string is the name of the device. It is the name
// that should be passed to NtOpenFile when accessing the device.

//
// Note: For devices that support multiple units, it should be suffixed
//       with the Ascii representation of the unit number.
//

#define DD_NDIS_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning: Remember that the low two bits of the code specify how the
//          buffers are passed to the driver!
//

#define _NDIS_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, request, method, FILE_ANY_ACCESS)

#define IOCTL_NDIS_QUERY_GLOBAL_STATS   _NDIS_CONTROL_CODE(0, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_QUERY_ALL_STATS      _NDIS_CONTROL_CODE(1, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_DO_PNP_OPERATION     _NDIS_CONTROL_CODE(2, METHOD_BUFFERED)
#define IOCTL_NDIS_QUERY_SELECTED_STATS _NDIS_CONTROL_CODE(3, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_ENUMERATE_INTERFACES _NDIS_CONTROL_CODE(4, METHOD_BUFFERED)
#define IOCTL_NDIS_ADD_TDI_DEVICE       _NDIS_CONTROL_CODE(5, METHOD_BUFFERED)
#define IOCTL_NDIS_GET_LOG_DATA         _NDIS_CONTROL_CODE(7, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_GET_VERSION          _NDIS_CONTROL_CODE(8, METHOD_BUFFERED)

#define IOCTL_NDIS_RESERVED1            _NDIS_CONTROL_CODE(9, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED2            _NDIS_CONTROL_CODE(0xA, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED3            _NDIS_CONTROL_CODE(0xB, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED4            _NDIS_CONTROL_CODE(0xC, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED5    CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, 0xD, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_NDIS_RESERVED6    CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, 0xE, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_NDIS_RESERVED7            _NDIS_CONTROL_CODE(0xF, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_RESERVED8            _NDIS_CONTROL_CODE(0x10, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED9            _NDIS_CONTROL_CODE(0x11, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED10           _NDIS_CONTROL_CODE(0x12, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED11           _NDIS_CONTROL_CODE(0x13, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED12           _NDIS_CONTROL_CODE(0x14, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED13           _NDIS_CONTROL_CODE(0x15, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED14           _NDIS_CONTROL_CODE(0x16, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED15           _NDIS_CONTROL_CODE(0x17, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED16           _NDIS_CONTROL_CODE(0x18, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED17           _NDIS_CONTROL_CODE(0x19, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED18           _NDIS_CONTROL_CODE(0x1A, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED19           _NDIS_CONTROL_CODE(0x1B, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED20           _NDIS_CONTROL_CODE(0x1C, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED21           _NDIS_CONTROL_CODE(0x1D, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED22           _NDIS_CONTROL_CODE(0x1E, METHOD_BUFFERED)


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

//
// This is the type of an NDIS OID value.
//

typedef ULONG NDIS_OID, *PNDIS_OID;

//
// IOCTL_NDIS_QUERY_ALL_STATS returns a sequence of these, packed
// together.  This structure is unaligned because not all statistics
// have a length that is a ULONG multiple.
//

typedef struct _NDIS_STATISTICS_VALUE
{
    NDIS_OID    Oid;
    ULONG       DataLength;
    UCHAR       Data[1];            // variable length
} NDIS_STATISTICS_VALUE;

typedef NDIS_STATISTICS_VALUE UNALIGNED *PNDIS_STATISTICS_VALUE;

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
typedef struct _NDIS_STATISTICS_VALUE_EX
{
    NDIS_OID    Oid;
    ULONG       DataLength;         // the length of the OID data
    ULONG       Length;             // the length of this instance of NDIS_STATISTICS_VALUE_EX
    UCHAR       Data[1];            // variable length
} NDIS_STATISTICS_VALUE_EX;

typedef NDIS_STATISTICS_VALUE_EX UNALIGNED *PNDIS_STATISTICS_VALUE_EX;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//
// Structure used to define a self-contained variable data structure
//
typedef struct _NDIS_VAR_DATA_DESC
{
    USHORT      Length;         // # of octects of data
    USHORT      MaximumLength;  // # of octects available
    ULONG_PTR   Offset;         // Offset of data relative to the descriptor
} NDIS_VAR_DATA_DESC, *PNDIS_VAR_DATA_DESC;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif // !GUID_DEFINED

//
// NDIS Object Types used in NDIS_OBJECT_HEADER
//
#define NDIS_OBJECT_TYPE_DEFAULT                            0x80    // used when object type is implicit in the API call
#define NDIS_OBJECT_TYPE_MINIPORT_INIT_PARAMETERS           0x81    // used by NDIS in NDIS_MINIPORT_INIT_PARAMETERS
#define NDIS_OBJECT_TYPE_SG_DMA_DESCRIPTION                 0x83    // used by miniport drivers in NDIS_SG_DMA_DESCRIPTION
#define NDIS_OBJECT_TYPE_MINIPORT_INTERRUPT                 0x84    // used by miniport drivers in NDIS_MINIPORT_INTERRUPT_EX
#define NDIS_OBJECT_TYPE_DEVICE_OBJECT_ATTRIBUTES           0x85    // used by miniport or filter drivers in NDIS_DEVICE_OBJECT_ATTRIBUTES
#define NDIS_OBJECT_TYPE_BIND_PARAMETERS                    0x86    // used by NDIS in NDIS_BIND_PARAMETERS
#define NDIS_OBJECT_TYPE_OPEN_PARAMETERS                    0x87    // used by protocols in NDIS_OPEN_PARAMETERS
#define NDIS_OBJECT_TYPE_RSS_CAPABILITIES                   0x88    // used by miniport in NDIS_RECEIVE_SCALE_CAPABILITIES
#define NDIS_OBJECT_TYPE_RSS_PARAMETERS                     0x89    // used by miniport and protocol in NDIS_RECEIVE_SCALE_PARAMETERS
#define NDIS_OBJECT_TYPE_MINIPORT_DRIVER_CHARACTERISTICS    0x8A
#define NDIS_OBJECT_TYPE_FILTER_DRIVER_CHARACTERISTICS      0x8B
#define NDIS_OBJECT_TYPE_FILTER_PARTIAL_CHARACTERISTICS     0x8C
#define NDIS_OBJECT_TYPE_FILTER_ATTRIBUTES                  0x8D
#define NDIS_OBJECT_TYPE_CLIENT_CHIMNEY_OFFLOAD_GENERIC_CHARACTERISTICS     0x8E
#define NDIS_OBJECT_TYPE_PROVIDER_CHIMNEY_OFFLOAD_GENERIC_CHARACTERISTICS   0x8F
#define NDIS_OBJECT_TYPE_CO_PROTOCOL_CHARACTERISTICS        0x90
#define NDIS_OBJECT_TYPE_CO_MINIPORT_CHARACTERISTICS        0x91
#define NDIS_OBJECT_TYPE_MINIPORT_PNP_CHARACTERISTICS       0x92
#define NDIS_OBJECT_TYPE_CLIENT_CHIMNEY_OFFLOAD_CHARACTERISTICS     0x93
#define NDIS_OBJECT_TYPE_PROVIDER_CHIMNEY_OFFLOAD_CHARACTERISTICS   0x94
#define NDIS_OBJECT_TYPE_PROTOCOL_DRIVER_CHARACTERISTICS    0x95
#define NDIS_OBJECT_TYPE_REQUEST_EX                         0x96
#define NDIS_OBJECT_TYPE_OID_REQUEST                        0x96
#define NDIS_OBJECT_TYPE_TIMER_CHARACTERISTICS              0x97
#define NDIS_OBJECT_TYPE_STATUS_INDICATION                  0x98
#define NDIS_OBJECT_TYPE_FILTER_ATTACH_PARAMETERS           0x99
#define NDIS_OBJECT_TYPE_FILTER_PAUSE_PARAMETERS            0x9A
#define NDIS_OBJECT_TYPE_FILTER_RESTART_PARAMETERS          0x9B
#define NDIS_OBJECT_TYPE_PORT_CHARACTERISTICS               0x9C
#define NDIS_OBJECT_TYPE_PORT_STATE                         0x9D
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES       0x9E
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES            0x9F
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES            0xA0
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES      0xA1
#define NDIS_OBJECT_TYPE_RESTART_GENERAL_ATTRIBUTES                     0xA2
#define NDIS_OBJECT_TYPE_PROTOCOL_RESTART_PARAMETERS                    0xA3
#define NDIS_OBJECT_TYPE_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES    0xA4
#define NDIS_OBJECT_TYPE_CO_CALL_MANAGER_OPTIONAL_HANDLERS              0xA5
#define NDIS_OBJECT_TYPE_CO_CLIENT_OPTIONAL_HANDLERS                    0xA6
#define NDIS_OBJECT_TYPE_OFFLOAD                                        0xA7
#define NDIS_OBJECT_TYPE_OFFLOAD_ENCAPSULATION                          0xA8
#define NDIS_OBJECT_TYPE_CONFIGURATION_OBJECT                           0xA9
#define NDIS_OBJECT_TYPE_DRIVER_WRAPPER_OBJECT                          0xAA
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OBJECT_TYPE_HD_SPLIT_ATTRIBUTES                            0xAB
#endif // (NDIS_SUPPORT_NDIS61)
#define NDIS_OBJECT_TYPE_NSI_NETWORK_RW_STRUCT                          0xAC
#define NDIS_OBJECT_TYPE_NSI_COMPARTMENT_RW_STRUCT                      0xAD
#define NDIS_OBJECT_TYPE_NSI_INTERFACE_PERSIST_RW_STRUCT                0xAE
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES    0xAF
#endif // (NDIS_SUPPORT_NDIS61)
#if (NDIS_SUPPORT_NDIS620)
#define NDIS_OBJECT_TYPE_SHARED_MEMORY_PROVIDER_CHARACTERISTICS         0xB0
#define NDIS_OBJECT_TYPE_RSS_PROCESSOR_INFO                             0xB1
#endif // (NDIS_SUPPORT_NDIS620)



typedef struct _NDIS_OBJECT_HEADER
{
    UCHAR   Type;
    UCHAR   Revision;
    USHORT  Size;
} NDIS_OBJECT_HEADER, *PNDIS_OBJECT_HEADER;

#define NDIS_OBJECT_REVISION_1                  1

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)

//
// flags for NDIS_STATISTICS_INFO->SupportedStatistics structure
//
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_FRAMES_RCV             0x00000001
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_FRAMES_RCV            0x00000002
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_FRAMES_RCV            0x00000004
#define NDIS_STATISTICS_FLAGS_VALID_BYTES_RCV                       0x00000008
#define NDIS_STATISTICS_FLAGS_VALID_RCV_DISCARDS                    0x00000010
#define NDIS_STATISTICS_FLAGS_VALID_RCV_ERROR                       0x00000020
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_FRAMES_XMIT            0x00000040
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_FRAMES_XMIT           0x00000080
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_FRAMES_XMIT           0x00000100
#define NDIS_STATISTICS_FLAGS_VALID_BYTES_XMIT                      0x00000200
#define NDIS_STATISTICS_FLAGS_VALID_XMIT_ERROR                      0x00000400
#define NDIS_STATISTICS_FLAGS_VALID_XMIT_DISCARDS                   0x00008000
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_BYTES_RCV              0x00010000
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_BYTES_RCV             0x00020000
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_BYTES_RCV             0x00040000
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_BYTES_XMIT             0x00080000
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_BYTES_XMIT            0x00100000
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_BYTES_XMIT            0x00200000


#define NDIS_STATISTICS_INFO_REVISION_1  1

//
// structure used in OID_GEN_STATISTICS
//
typedef struct _NDIS_STATISTICS_INFO
{
    NDIS_OBJECT_HEADER          Header;
    ULONG                       SupportedStatistics;
    ULONG64                     ifInDiscards;           // OID_GEN_RCV_ERROR + OID_GEN_RCV_NO_BUFFER = OID_GEN_RCV_DISCARDS
    ULONG64                     ifInErrors;             // OID_GEN_RCV_ERROR
    ULONG64                     ifHCInOctets;           // OID_GEN_BYTES_RCV = OID_GEN_DIRECTED_BYTES_RCV + OID_GEN_MULTICAST_BYTES_RCV + OID_GEN_BROADCAST_BYTES_RCV
    ULONG64                     ifHCInUcastPkts;        // OID_GEN_DIRECTED_FRAMES_RCV
    ULONG64                     ifHCInMulticastPkts;    // OID_GEN_MULTICAST_FRAMES_RCV
    ULONG64                     ifHCInBroadcastPkts;    // OID_GEN_BROADCAST_FRAMES_RCV
    ULONG64                     ifHCOutOctets;          // OID_GEN_BYTES_XMIT = OID_GEN_DIRECTED_BYTES_XMIT + OID_GEN_MULTICAST_BYTES_XMIT + OID_GEN_BROADCAST_BYTES_XMIT
    ULONG64                     ifHCOutUcastPkts;       // OID_GEN_DIRECTED_FRAMES_XMIT
    ULONG64                     ifHCOutMulticastPkts;   // OID_GEN_MULTICAST_FRAMES_XMIT
    ULONG64                     ifHCOutBroadcastPkts;   // OID_GEN_BROADCAST_FRAMES_XMIT
    ULONG64                     ifOutErrors;            // OID_GEN_XMIT_ERROR
    ULONG64                     ifOutDiscards;          // OID_GEN_XMIT_DISCARDS
    ULONG64                     ifHCInUcastOctets;      // OID_GEN_DIRECTED_BYTES_RCV    
    ULONG64                     ifHCInMulticastOctets;  // OID_GEN_MULTICAST_BYTES_RCV
    ULONG64                     ifHCInBroadcastOctets;  // OID_GEN_BROADCAST_BYTES_RCV        
    ULONG64                     ifHCOutUcastOctets;     // OID_GEN_DIRECTED_BYTES_XMIT    
    ULONG64                     ifHCOutMulticastOctets; // OID_GEN_MULTICAST_BYTES_XMIT
    ULONG64                     ifHCOutBroadcastOctets; // OID_GEN_BROADCAST_BYTES_XMIT                

}NDIS_STATISTICS_INFO, *PNDIS_STATISTICS_INFO;

#define NDIS_SIZEOF_STATISTICS_INFO_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_STATISTICS_INFO, ifHCOutBroadcastOctets)



//
//  interrupt moderation structures and definitions
//

//
// enum value used in NDIS_INTERRUPT_MODERATION_PARAMETERS structure
//
typedef enum _NDIS_INTERRUPT_MODERATION
{
    NdisInterruptModerationUnknown,
    NdisInterruptModerationNotSupported,
    NdisInterruptModerationEnabled,
    NdisInterruptModerationDisabled
} NDIS_INTERRUPT_MODERATION, *PNDIS_INTERRUPT_MODERATION;

//
// Bits used in Flags parameter of NDIS_INTERRUPT_MODERATION_PARAMETERS structure:
//    
#define NDIS_INTERRUPT_MODERATION_CHANGE_NEEDS_RESET            0x00000001
#define NDIS_INTERRUPT_MODERATION_CHANGE_NEEDS_REINITIALIZE     0x00000002


//
// structure used in OID_GEN_INTERRUPT_MODERATION
//

#define NDIS_INTERRUPT_MODERATION_PARAMETERS_REVISION_1    1

typedef struct _NDIS_INTERRUPT_MODERATION_PARAMETERS
{
    NDIS_OBJECT_HEADER Header;
    ULONG Flags;
    NDIS_INTERRUPT_MODERATION InterruptModeration;
}NDIS_INTERRUPT_MODERATION_PARAMETERS, *PNDIS_INTERRUPT_MODERATION_PARAMETERS;

#define NDIS_SIZEOF_INTERRUPT_MODERATION_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_INTERRUPT_MODERATION_PARAMETERS, InterruptModeration)

//
// structure used in OID_GEN_TIMEOUT_DPC_REQUEST_CAPABILITIES
//

#define NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES_REVISION_1  1

typedef struct _NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES
{
    NDIS_OBJECT_HEADER      Header;
    ULONG                   Flags;
    ULONG                   TimeoutArrayLength;
    ULONG                   TimeoutArray[1];
}NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES, *PNDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES;

#define NDIS_SIZEOF_TIMEOUT_DPC_REQUEST_CAPABILITIES_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES, TimeoutArray)

//
// PCI custom properties. used in OID_GEN_PCI_DEVICE_CUSTOM_PROPERTIES
//

#define NDIS_OBJECT_TYPE_PCI_DEVICE_CUSTOM_PROPERTIES_REVISION_1  1

#if ((NTDDI_VERSION >= NTDDI_WIN7) || NDIS_SUPPORT_NDIS620)
#define NDIS_OBJECT_TYPE_PCI_DEVICE_CUSTOM_PROPERTIES_REVISION_2  2
#endif
    
typedef struct _NDIS_PCI_DEVICE_CUSTOM_PROPERTIES
{
    NDIS_OBJECT_HEADER              Header;
    UINT32                          DeviceType;             // conventional, PCI-X, PCI-E, etc.
    UINT32                          CurrentSpeedAndMode;    // PCI_DEVICE_CONVENTIONAL_xx or PCIX_MODExxx. valid only for conventional and PCI-X devices
    UINT32                          CurrentPayloadSize;     // PCI_EXPRESS_MAX_PAYLOAD_SIZE, valid only for PCI-E devices
    UINT32                          MaxPayloadSize;         // PCI_EXPRESS_MAX_PAYLOAD_SIZE, valid only for PCI-E devices
    UINT32                          MaxReadRequestSize;     // PCI_EXPRESS_MAX_PAYLOAD_SIZE, valid only for PCI-E devices
    UINT32                          CurrentLinkSpeed;       // PCI_EXPRESS_LINK_SPEED_xxx. valid only for PCI-E devices 
    UINT32                          CurrentLinkWidth;       // PCI_EXPRESS_LINK_WIDTH_xx. valid only for PCI-E devices
    UINT32                          MaxLinkSpeed;           // PCI_EXPRESS_LINK_SPEED_xxx. valid only for PCI-E devices
    UINT32                          MaxLinkWidth;           // PCI_EXPRESS_LINK_WIDTH_xx. valid only for PCI-E devices
#if ((NTDDI_VERSION >= NTDDI_WIN7) || NDIS_SUPPORT_NDIS620)
    UINT32                          PciExpressVersion;      // DevProp_PciExpressDevice_Spec_Version_xx, valid for PCI -E devices
    UINT32                          InterruptType;          // DevProp_PciDevice_InterruptType_xx
    UINT32                          MaxInterruptMessages;
#endif
} NDIS_PCI_DEVICE_CUSTOM_PROPERTIES, *PNDIS_PCI_DEVICE_CUSTOM_PROPERTIES;

#define NDIS_SIZEOF_PCI_DEVICE_CUSTOM_PROPERTIES_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PCI_DEVICE_CUSTOM_PROPERTIES, MaxLinkWidth)

#if ((NTDDI_VERSION >= NTDDI_WIN7) || NDIS_SUPPORT_NDIS620)
#define NDIS_SIZEOF_PCI_DEVICE_CUSTOM_PROPERTIES_REVISION_2    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PCI_DEVICE_CUSTOM_PROPERTIES, MaxInterruptMessages)
#endif

#endif // (NTDDI_VERSION >= NTDDI_VISTA)



//
// General Objects
//

//
//  Required OIDs
//
#define OID_GEN_SUPPORTED_LIST                  0x00010101
#define OID_GEN_HARDWARE_STATUS                 0x00010102
#define OID_GEN_MEDIA_SUPPORTED                 0x00010103
#define OID_GEN_MEDIA_IN_USE                    0x00010104
#define OID_GEN_MAXIMUM_LOOKAHEAD               0x00010105
#define OID_GEN_MAXIMUM_FRAME_SIZE              0x00010106
#define OID_GEN_LINK_SPEED                      0x00010107
#define OID_GEN_TRANSMIT_BUFFER_SPACE           0x00010108
#define OID_GEN_RECEIVE_BUFFER_SPACE            0x00010109
#define OID_GEN_TRANSMIT_BLOCK_SIZE             0x0001010A
#define OID_GEN_RECEIVE_BLOCK_SIZE              0x0001010B
#define OID_GEN_VENDOR_ID                       0x0001010C
#define OID_GEN_VENDOR_DESCRIPTION              0x0001010D
#define OID_GEN_CURRENT_PACKET_FILTER           0x0001010E
#define OID_GEN_CURRENT_LOOKAHEAD               0x0001010F
#define OID_GEN_DRIVER_VERSION                  0x00010110
#define OID_GEN_MAXIMUM_TOTAL_SIZE              0x00010111
#define OID_GEN_PROTOCOL_OPTIONS                0x00010112
#define OID_GEN_MAC_OPTIONS                     0x00010113
#define OID_GEN_MEDIA_CONNECT_STATUS            0x00010114
#define OID_GEN_MAXIMUM_SEND_PACKETS            0x00010115

//
//  Optional OIDs
//
#define OID_GEN_VENDOR_DRIVER_VERSION           0x00010116
#define OID_GEN_SUPPORTED_GUIDS                 0x00010117
#define OID_GEN_NETWORK_LAYER_ADDRESSES         0x00010118  // Set only
#define OID_GEN_TRANSPORT_HEADER_OFFSET         0x00010119  // Set only
#define OID_GEN_MEDIA_CAPABILITIES              0x00010201
#define OID_GEN_PHYSICAL_MEDIUM                 0x00010202

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
//
// new optional for NDIS 6.0
//
#define OID_GEN_RECEIVE_SCALE_CAPABILITIES      0x00010203  // query only
#define OID_GEN_RECEIVE_SCALE_PARAMETERS        0x00010204  // query and set

//
// new for NDIS 6.0. NDIS will handle on behalf of the miniports
//
#define OID_GEN_MAC_ADDRESS                     0x00010205  // query and set
#define OID_GEN_MAX_LINK_SPEED                  0x00010206  // query only
#define OID_GEN_LINK_STATE                      0x00010207  // query only

//
// new and required for NDIS 6 miniports
//
#define OID_GEN_LINK_PARAMETERS                 0x00010208  // set only
#define OID_GEN_INTERRUPT_MODERATION            0x00010209  // query and set
#define OID_GEN_NDIS_RESERVED_3                 0x0001020A
#define OID_GEN_NDIS_RESERVED_4                 0x0001020B
#define OID_GEN_NDIS_RESERVED_5                 0x0001020C


//
// Port related OIDs
//
#define OID_GEN_ENUMERATE_PORTS                 0x0001020D  // query only, handled by NDIS
#define OID_GEN_PORT_STATE                      0x0001020E  // query only, handled by NDIS
#define OID_GEN_PORT_AUTHENTICATION_PARAMETERS  0x0001020F  // Set only

//
// optional OID for NDIS 6 miniports
//
#define OID_GEN_TIMEOUT_DPC_REQUEST_CAPABILITIES 0x00010210 // query only

//
// this OID is handled by NDIS for PCI devices
//
#define OID_GEN_PCI_DEVICE_CUSTOM_PROPERTIES    0x00010211  // query only
#define OID_GEN_NDIS_RESERVED_6                 0x00010212
#define OID_GEN_PHYSICAL_MEDIUM_EX              0x00010213  // query only


#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define OID_GEN_MACHINE_NAME                    0x0001021A  // set only
#define OID_GEN_RNDIS_CONFIG_PARAMETER          0x0001021B  // Set only
#define OID_GEN_VLAN_ID                         0x0001021C

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
#define OID_GEN_RECEIVE_HASH                    0x0001021F  // query and set
#define OID_GEN_MINIPORT_RESTART_ATTRIBUTES     0x0001021D

#if (NDIS_SUPPORT_NDIS61)
//
// Optional OID for header data/split
//
#define OID_GEN_HD_SPLIT_PARAMETERS             0x0001021E  // Set only
#define OID_GEN_HD_SPLIT_CURRENT_CONFIG         0x00010220  // Query only
#endif // (NDIS_SUPPORT_NDIS61)

//
// the following OIDs are used in querying interfaces
//
#define OID_GEN_PROMISCUOUS_MODE                0x00010280  // used in querying interfaces
#define OID_GEN_LAST_CHANGE                     0x00010281  // used in querying interfaces
#define OID_GEN_DISCONTINUITY_TIME              0x00010282  // used in querying interfaces
#define OID_GEN_OPERATIONAL_STATUS              0x00010283  // used in querying interfaces
#define OID_GEN_XMIT_LINK_SPEED                 0x00010284  // used in querying interfaces
#define OID_GEN_RCV_LINK_SPEED                  0x00010285  // used in querying interfaces
#define OID_GEN_UNKNOWN_PROTOS                  0x00010286  // used in querying interfaces
#define OID_GEN_INTERFACE_INFO                  0x00010287  // used in querying interfaces
#define OID_GEN_ADMIN_STATUS                    0x00010288  // used in querying interfaces
#define OID_GEN_ALIAS                           0x00010289  // used in querying interfaces
#define OID_GEN_MEDIA_CONNECT_STATUS_EX         0x0001028A  // used in querying interfaces
#define OID_GEN_LINK_SPEED_EX                   0x0001028B  // used in querying interfaces
#define OID_GEN_MEDIA_DUPLEX_STATE              0x0001028C  // used in querying interfaces
#define OID_GEN_IP_OPER_STATUS                  0x0001028D  // used in querying interfaces

//
// WWAN specific oids
//
#define OID_WWAN_DRIVER_CAPS			0x0e010100
#define OID_WWAN_DEVICE_CAPS			0x0e010101
#define OID_WWAN_READY_INFO			0x0e010102
#define OID_WWAN_RADIO_STATE			0x0e010103
#define OID_WWAN_PIN				0x0e010104
#define OID_WWAN_PIN_LIST			0x0e010105
#define OID_WWAN_HOME_PROVIDER			0x0e010106
#define OID_WWAN_PREFERRED_PROVIDERS		0x0e010107
#define OID_WWAN_VISIBLE_PROVIDERS		0x0e010108
#define OID_WWAN_REGISTER_STATE			0x0e010109
#define OID_WWAN_PACKET_SERVICE			0x0e01010a
#define OID_WWAN_SIGNAL_STATE			0x0e01010b
#define OID_WWAN_CONNECT			0x0e01010c
#define OID_WWAN_PROVISIONED_CONTEXTS		0x0e01010d
#define OID_WWAN_SERVICE_ACTIVATION		0x0e01010e
#define OID_WWAN_SMS_CONFIGURATION		0x0e01010f
#define OID_WWAN_SMS_READ			0x0e010110
#define OID_WWAN_SMS_SEND			0x0e010111
#define OID_WWAN_SMS_DELETE			0x0e010112
#define OID_WWAN_SMS_STATUS			0x0e010113
#define OID_WWAN_VENDOR_SPECIFIC		0x0e010114

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//
//  Required statistics
//
#define OID_GEN_XMIT_OK                         0x00020101
#define OID_GEN_RCV_OK                          0x00020102
#define OID_GEN_XMIT_ERROR                      0x00020103
#define OID_GEN_RCV_ERROR                       0x00020104
#define OID_GEN_RCV_NO_BUFFER                   0x00020105

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
//
// mandatory for NDIS 6.0 and higher miniports
//
#define OID_GEN_STATISTICS                      0x00020106
#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//
//  Optional statistics
//
#define OID_GEN_DIRECTED_BYTES_XMIT             0x00020201
#define OID_GEN_DIRECTED_FRAMES_XMIT            0x00020202
#define OID_GEN_MULTICAST_BYTES_XMIT            0x00020203
#define OID_GEN_MULTICAST_FRAMES_XMIT           0x00020204
#define OID_GEN_BROADCAST_BYTES_XMIT            0x00020205
#define OID_GEN_BROADCAST_FRAMES_XMIT           0x00020206
#define OID_GEN_DIRECTED_BYTES_RCV              0x00020207
#define OID_GEN_DIRECTED_FRAMES_RCV             0x00020208
#define OID_GEN_MULTICAST_BYTES_RCV             0x00020209
#define OID_GEN_MULTICAST_FRAMES_RCV            0x0002020A
#define OID_GEN_BROADCAST_BYTES_RCV             0x0002020B
#define OID_GEN_BROADCAST_FRAMES_RCV            0x0002020C
#define OID_GEN_RCV_CRC_ERROR                   0x0002020D
#define OID_GEN_TRANSMIT_QUEUE_LENGTH           0x0002020E

#define OID_GEN_GET_TIME_CAPS                   0x0002020F
#define OID_GEN_GET_NETCARD_TIME                0x00020210
#define OID_GEN_NETCARD_LOAD                    0x00020211
#define OID_GEN_DEVICE_PROFILE                  0x00020212

//
// The following are exported by NDIS itself and are only queryable. 
//

//
// the time in milliseconds a driver took to initialize.
//
#define OID_GEN_INIT_TIME_MS                    0x00020213

//
// the number of times the miniport adapter was reset
//
#define OID_GEN_RESET_COUNTS                    0x00020214

//
// the number of timer the miniport reported a media state change
//
#define OID_GEN_MEDIA_SENSE_COUNTS              0x00020215

//
// the friendly name of the adapter
//
#define OID_GEN_FRIENDLY_NAME                   0x00020216

//
// returns miniport information such as whether the driver is serialized or not
// if it supports sending multiple packets, etc. refer to NDIS_MINIPORT_XXX flags
//
#define OID_GEN_NDIS_RESERVED_1                 0x00020217

//
// handled by NDIS to reset the test verification paramters on the
// miniport
//
#define OID_GEN_NDIS_RESERVED_2                 0x00020218
#define OID_GEN_NDIS_RESERVED_5                 0x0001020C

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
//
// more optional OIDs new for NDIS 6.0
//

#define OID_GEN_BYTES_RCV                       0x00020219
#define OID_GEN_BYTES_XMIT                      0x0002021A
#define OID_GEN_RCV_DISCARDS                    0x0002021B
#define OID_GEN_XMIT_DISCARDS                   0x0002021C
#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//
//  These are connection-oriented general OIDs.
//  These replace the above OIDs for connection-oriented media.
//
#define OID_GEN_CO_SUPPORTED_LIST               OID_GEN_SUPPORTED_LIST
#define OID_GEN_CO_HARDWARE_STATUS              OID_GEN_HARDWARE_STATUS
#define OID_GEN_CO_MEDIA_SUPPORTED              OID_GEN_MEDIA_SUPPORTED
#define OID_GEN_CO_MEDIA_IN_USE                 OID_GEN_MEDIA_IN_USE
#define OID_GEN_CO_LINK_SPEED                   OID_GEN_LINK_SPEED
#define OID_GEN_CO_VENDOR_ID                    OID_GEN_VENDOR_ID
#define OID_GEN_CO_VENDOR_DESCRIPTION           OID_GEN_VENDOR_DESCRIPTION
#define OID_GEN_CO_DRIVER_VERSION               OID_GEN_DRIVER_VERSION
#define OID_GEN_CO_PROTOCOL_OPTIONS             OID_GEN_PROTOCOL_OPTIONS
#define OID_GEN_CO_MAC_OPTIONS                  OID_GEN_MAC_OPTIONS
#define OID_GEN_CO_MEDIA_CONNECT_STATUS         OID_GEN_MEDIA_CONNECT_STATUS
#define OID_GEN_CO_VENDOR_DRIVER_VERSION        OID_GEN_VENDOR_DRIVER_VERSION
#define OID_GEN_CO_SUPPORTED_GUIDS              OID_GEN_SUPPORTED_GUIDS
#define OID_GEN_CO_GET_TIME_CAPS                OID_GEN_GET_TIME_CAPS
#define OID_GEN_CO_GET_NETCARD_TIME             OID_GEN_GET_NETCARD_TIME
#define OID_GEN_CO_MINIMUM_LINK_SPEED           0x00020120

//
//  These are connection-oriented statistics OIDs.
//
#define OID_GEN_CO_XMIT_PDUS_OK                 OID_GEN_XMIT_OK
#define OID_GEN_CO_RCV_PDUS_OK                  OID_GEN_RCV_OK
#define OID_GEN_CO_XMIT_PDUS_ERROR              OID_GEN_XMIT_ERROR
#define OID_GEN_CO_RCV_PDUS_ERROR               OID_GEN_RCV_ERROR
#define OID_GEN_CO_RCV_PDUS_NO_BUFFER           OID_GEN_RCV_NO_BUFFER


#define OID_GEN_CO_RCV_CRC_ERROR                OID_GEN_RCV_CRC_ERROR
#define OID_GEN_CO_TRANSMIT_QUEUE_LENGTH        OID_GEN_TRANSMIT_QUEUE_LENGTH
#define OID_GEN_CO_BYTES_XMIT                   OID_GEN_DIRECTED_BYTES_XMIT
#define OID_GEN_CO_BYTES_RCV                    OID_GEN_DIRECTED_BYTES_RCV
#define OID_GEN_CO_NETCARD_LOAD                 OID_GEN_NETCARD_LOAD
#define OID_GEN_CO_DEVICE_PROFILE               OID_GEN_DEVICE_PROFILE
#define OID_GEN_CO_BYTES_XMIT_OUTSTANDING       0x00020221


//
// 802.3 Objects (Ethernet)
//
#define OID_802_3_PERMANENT_ADDRESS             0x01010101
#define OID_802_3_CURRENT_ADDRESS               0x01010102
#define OID_802_3_MULTICAST_LIST                0x01010103
#define OID_802_3_MAXIMUM_LIST_SIZE             0x01010104
//
// This OID has been deprecated for NDIS 6 drivers. 
//
#define OID_802_3_MAC_OPTIONS                   0x01010105  // deprecated


//
// This Flag has been deprecated for NDIS 6 drivers.
//
#define NDIS_802_3_MAC_OPTION_PRIORITY          0x00000001  // deprecated

#define OID_802_3_RCV_ERROR_ALIGNMENT           0x01020101
#define OID_802_3_XMIT_ONE_COLLISION            0x01020102
#define OID_802_3_XMIT_MORE_COLLISIONS          0x01020103

#define OID_802_3_XMIT_DEFERRED                 0x01020201
#define OID_802_3_XMIT_MAX_COLLISIONS           0x01020202
#define OID_802_3_RCV_OVERRUN                   0x01020203
#define OID_802_3_XMIT_UNDERRUN                 0x01020204
#define OID_802_3_XMIT_HEARTBEAT_FAILURE        0x01020205
#define OID_802_3_XMIT_TIMES_CRS_LOST           0x01020206
#define OID_802_3_XMIT_LATE_COLLISIONS          0x01020207

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
//
// new for NDIS 6
//
#define OID_802_3_ADD_MULTICAST_ADDRESS         0x01010208
#define OID_802_3_DELETE_MULTICAST_ADDRESS      0x01010209
#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//
// 802.5 Objects (Token-Ring)
//
#define OID_802_5_PERMANENT_ADDRESS             0x02010101
#define OID_802_5_CURRENT_ADDRESS               0x02010102
#define OID_802_5_CURRENT_FUNCTIONAL            0x02010103
#define OID_802_5_CURRENT_GROUP                 0x02010104
#define OID_802_5_LAST_OPEN_STATUS              0x02010105
#define OID_802_5_CURRENT_RING_STATUS           0x02010106
#define OID_802_5_CURRENT_RING_STATE            0x02010107


#define OID_802_5_LINE_ERRORS                   0x02020101
#define OID_802_5_LOST_FRAMES                   0x02020102

#define OID_802_5_BURST_ERRORS                  0x02020201
#define OID_802_5_AC_ERRORS                     0x02020202
#define OID_802_5_ABORT_DELIMETERS              0x02020203
#define OID_802_5_FRAME_COPIED_ERRORS           0x02020204
#define OID_802_5_FREQUENCY_ERRORS              0x02020205
#define OID_802_5_TOKEN_ERRORS                  0x02020206
#define OID_802_5_INTERNAL_ERRORS               0x02020207


//
// FDDI Objects
//
#define OID_FDDI_LONG_PERMANENT_ADDR            0x03010101
#define OID_FDDI_LONG_CURRENT_ADDR              0x03010102
#define OID_FDDI_LONG_MULTICAST_LIST            0x03010103
#define OID_FDDI_LONG_MAX_LIST_SIZE             0x03010104
#define OID_FDDI_SHORT_PERMANENT_ADDR           0x03010105
#define OID_FDDI_SHORT_CURRENT_ADDR             0x03010106
#define OID_FDDI_SHORT_MULTICAST_LIST           0x03010107
#define OID_FDDI_SHORT_MAX_LIST_SIZE            0x03010108

#define OID_FDDI_ATTACHMENT_TYPE                0x03020101
#define OID_FDDI_UPSTREAM_NODE_LONG             0x03020102
#define OID_FDDI_DOWNSTREAM_NODE_LONG           0x03020103
#define OID_FDDI_FRAME_ERRORS                   0x03020104
#define OID_FDDI_FRAMES_LOST                    0x03020105
#define OID_FDDI_RING_MGT_STATE                 0x03020106
#define OID_FDDI_LCT_FAILURES                   0x03020107
#define OID_FDDI_LEM_REJECTS                    0x03020108
#define OID_FDDI_LCONNECTION_STATE              0x03020109

#define OID_FDDI_SMT_STATION_ID                 0x03030201
#define OID_FDDI_SMT_OP_VERSION_ID              0x03030202
#define OID_FDDI_SMT_HI_VERSION_ID              0x03030203
#define OID_FDDI_SMT_LO_VERSION_ID              0x03030204
#define OID_FDDI_SMT_MANUFACTURER_DATA          0x03030205
#define OID_FDDI_SMT_USER_DATA                  0x03030206
#define OID_FDDI_SMT_MIB_VERSION_ID             0x03030207
#define OID_FDDI_SMT_MAC_CT                     0x03030208
#define OID_FDDI_SMT_NON_MASTER_CT              0x03030209
#define OID_FDDI_SMT_MASTER_CT                  0x0303020A
#define OID_FDDI_SMT_AVAILABLE_PATHS            0x0303020B
#define OID_FDDI_SMT_CONFIG_CAPABILITIES        0x0303020C
#define OID_FDDI_SMT_CONFIG_POLICY              0x0303020D
#define OID_FDDI_SMT_CONNECTION_POLICY          0x0303020E
#define OID_FDDI_SMT_T_NOTIFY                   0x0303020F
#define OID_FDDI_SMT_STAT_RPT_POLICY            0x03030210
#define OID_FDDI_SMT_TRACE_MAX_EXPIRATION       0x03030211
#define OID_FDDI_SMT_PORT_INDEXES               0x03030212
#define OID_FDDI_SMT_MAC_INDEXES                0x03030213
#define OID_FDDI_SMT_BYPASS_PRESENT             0x03030214
#define OID_FDDI_SMT_ECM_STATE                  0x03030215
#define OID_FDDI_SMT_CF_STATE                   0x03030216
#define OID_FDDI_SMT_HOLD_STATE                 0x03030217
#define OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG     0x03030218
#define OID_FDDI_SMT_STATION_STATUS             0x03030219
#define OID_FDDI_SMT_PEER_WRAP_FLAG             0x0303021A
#define OID_FDDI_SMT_MSG_TIME_STAMP             0x0303021B
#define OID_FDDI_SMT_TRANSITION_TIME_STAMP      0x0303021C
#define OID_FDDI_SMT_SET_COUNT                  0x0303021D
#define OID_FDDI_SMT_LAST_SET_STATION_ID        0x0303021E
#define OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS     0x0303021F
#define OID_FDDI_MAC_BRIDGE_FUNCTIONS           0x03030220
#define OID_FDDI_MAC_T_MAX_CAPABILITY           0x03030221
#define OID_FDDI_MAC_TVX_CAPABILITY             0x03030222
#define OID_FDDI_MAC_AVAILABLE_PATHS            0x03030223
#define OID_FDDI_MAC_CURRENT_PATH               0x03030224
#define OID_FDDI_MAC_UPSTREAM_NBR               0x03030225
#define OID_FDDI_MAC_DOWNSTREAM_NBR             0x03030226
#define OID_FDDI_MAC_OLD_UPSTREAM_NBR           0x03030227
#define OID_FDDI_MAC_OLD_DOWNSTREAM_NBR         0x03030228
#define OID_FDDI_MAC_DUP_ADDRESS_TEST           0x03030229
#define OID_FDDI_MAC_REQUESTED_PATHS            0x0303022A
#define OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE       0x0303022B
#define OID_FDDI_MAC_INDEX                      0x0303022C
#define OID_FDDI_MAC_SMT_ADDRESS                0x0303022D
#define OID_FDDI_MAC_LONG_GRP_ADDRESS           0x0303022E
#define OID_FDDI_MAC_SHORT_GRP_ADDRESS          0x0303022F
#define OID_FDDI_MAC_T_REQ                      0x03030230
#define OID_FDDI_MAC_T_NEG                      0x03030231
#define OID_FDDI_MAC_T_MAX                      0x03030232
#define OID_FDDI_MAC_TVX_VALUE                  0x03030233
#define OID_FDDI_MAC_T_PRI0                     0x03030234
#define OID_FDDI_MAC_T_PRI1                     0x03030235
#define OID_FDDI_MAC_T_PRI2                     0x03030236
#define OID_FDDI_MAC_T_PRI3                     0x03030237
#define OID_FDDI_MAC_T_PRI4                     0x03030238
#define OID_FDDI_MAC_T_PRI5                     0x03030239
#define OID_FDDI_MAC_T_PRI6                     0x0303023A
#define OID_FDDI_MAC_FRAME_CT                   0x0303023B
#define OID_FDDI_MAC_COPIED_CT                  0x0303023C
#define OID_FDDI_MAC_TRANSMIT_CT                0x0303023D
#define OID_FDDI_MAC_TOKEN_CT                   0x0303023E
#define OID_FDDI_MAC_ERROR_CT                   0x0303023F
#define OID_FDDI_MAC_LOST_CT                    0x03030240
#define OID_FDDI_MAC_TVX_EXPIRED_CT             0x03030241
#define OID_FDDI_MAC_NOT_COPIED_CT              0x03030242
#define OID_FDDI_MAC_LATE_CT                    0x03030243
#define OID_FDDI_MAC_RING_OP_CT                 0x03030244
#define OID_FDDI_MAC_FRAME_ERROR_THRESHOLD      0x03030245
#define OID_FDDI_MAC_FRAME_ERROR_RATIO          0x03030246
#define OID_FDDI_MAC_NOT_COPIED_THRESHOLD       0x03030247
#define OID_FDDI_MAC_NOT_COPIED_RATIO           0x03030248
#define OID_FDDI_MAC_RMT_STATE                  0x03030249
#define OID_FDDI_MAC_DA_FLAG                    0x0303024A
#define OID_FDDI_MAC_UNDA_FLAG                  0x0303024B
#define OID_FDDI_MAC_FRAME_ERROR_FLAG           0x0303024C
#define OID_FDDI_MAC_NOT_COPIED_FLAG            0x0303024D
#define OID_FDDI_MAC_MA_UNITDATA_AVAILABLE      0x0303024E
#define OID_FDDI_MAC_HARDWARE_PRESENT           0x0303024F
#define OID_FDDI_MAC_MA_UNITDATA_ENABLE         0x03030250
#define OID_FDDI_PATH_INDEX                     0x03030251
#define OID_FDDI_PATH_RING_LATENCY              0x03030252
#define OID_FDDI_PATH_TRACE_STATUS              0x03030253
#define OID_FDDI_PATH_SBA_PAYLOAD               0x03030254
#define OID_FDDI_PATH_SBA_OVERHEAD              0x03030255
#define OID_FDDI_PATH_CONFIGURATION             0x03030256
#define OID_FDDI_PATH_T_R_MODE                  0x03030257
#define OID_FDDI_PATH_SBA_AVAILABLE             0x03030258
#define OID_FDDI_PATH_TVX_LOWER_BOUND           0x03030259
#define OID_FDDI_PATH_T_MAX_LOWER_BOUND         0x0303025A
#define OID_FDDI_PATH_MAX_T_REQ                 0x0303025B
#define OID_FDDI_PORT_MY_TYPE                   0x0303025C
#define OID_FDDI_PORT_NEIGHBOR_TYPE             0x0303025D
#define OID_FDDI_PORT_CONNECTION_POLICIES       0x0303025E
#define OID_FDDI_PORT_MAC_INDICATED             0x0303025F
#define OID_FDDI_PORT_CURRENT_PATH              0x03030260
#define OID_FDDI_PORT_REQUESTED_PATHS           0x03030261
#define OID_FDDI_PORT_MAC_PLACEMENT             0x03030262
#define OID_FDDI_PORT_AVAILABLE_PATHS           0x03030263
#define OID_FDDI_PORT_MAC_LOOP_TIME             0x03030264
#define OID_FDDI_PORT_PMD_CLASS                 0x03030265
#define OID_FDDI_PORT_CONNECTION_CAPABILITIES   0x03030266
#define OID_FDDI_PORT_INDEX                     0x03030267
#define OID_FDDI_PORT_MAINT_LS                  0x03030268
#define OID_FDDI_PORT_BS_FLAG                   0x03030269
#define OID_FDDI_PORT_PC_LS                     0x0303026A
#define OID_FDDI_PORT_EB_ERROR_CT               0x0303026B
#define OID_FDDI_PORT_LCT_FAIL_CT               0x0303026C
#define OID_FDDI_PORT_LER_ESTIMATE              0x0303026D
#define OID_FDDI_PORT_LEM_REJECT_CT             0x0303026E
#define OID_FDDI_PORT_LEM_CT                    0x0303026F
#define OID_FDDI_PORT_LER_CUTOFF                0x03030270
#define OID_FDDI_PORT_LER_ALARM                 0x03030271
#define OID_FDDI_PORT_CONNNECT_STATE            0x03030272
#define OID_FDDI_PORT_PCM_STATE                 0x03030273
#define OID_FDDI_PORT_PC_WITHHOLD               0x03030274
#define OID_FDDI_PORT_LER_FLAG                  0x03030275
#define OID_FDDI_PORT_HARDWARE_PRESENT          0x03030276
#define OID_FDDI_SMT_STATION_ACTION             0x03030277
#define OID_FDDI_PORT_ACTION                    0x03030278
#define OID_FDDI_IF_DESCR                       0x03030279
#define OID_FDDI_IF_TYPE                        0x0303027A
#define OID_FDDI_IF_MTU                         0x0303027B
#define OID_FDDI_IF_SPEED                       0x0303027C
#define OID_FDDI_IF_PHYS_ADDRESS                0x0303027D
#define OID_FDDI_IF_ADMIN_STATUS                0x0303027E
#define OID_FDDI_IF_OPER_STATUS                 0x0303027F
#define OID_FDDI_IF_LAST_CHANGE                 0x03030280
#define OID_FDDI_IF_IN_OCTETS                   0x03030281
#define OID_FDDI_IF_IN_UCAST_PKTS               0x03030282
#define OID_FDDI_IF_IN_NUCAST_PKTS              0x03030283
#define OID_FDDI_IF_IN_DISCARDS                 0x03030284
#define OID_FDDI_IF_IN_ERRORS                   0x03030285
#define OID_FDDI_IF_IN_UNKNOWN_PROTOS           0x03030286
#define OID_FDDI_IF_OUT_OCTETS                  0x03030287
#define OID_FDDI_IF_OUT_UCAST_PKTS              0x03030288
#define OID_FDDI_IF_OUT_NUCAST_PKTS             0x03030289
#define OID_FDDI_IF_OUT_DISCARDS                0x0303028A
#define OID_FDDI_IF_OUT_ERRORS                  0x0303028B
#define OID_FDDI_IF_OUT_QLEN                    0x0303028C
#define OID_FDDI_IF_SPECIFIC                    0x0303028D

//
// WAN objects
//
#define OID_WAN_PERMANENT_ADDRESS               0x04010101
#define OID_WAN_CURRENT_ADDRESS                 0x04010102
#define OID_WAN_QUALITY_OF_SERVICE              0x04010103
#define OID_WAN_PROTOCOL_TYPE                   0x04010104
#define OID_WAN_MEDIUM_SUBTYPE                  0x04010105
#define OID_WAN_HEADER_FORMAT                   0x04010106

#define OID_WAN_GET_INFO                        0x04010107
#define OID_WAN_SET_LINK_INFO                   0x04010108
#define OID_WAN_GET_LINK_INFO                   0x04010109

#define OID_WAN_LINE_COUNT                      0x0401010A
#define OID_WAN_PROTOCOL_CAPS                   0x0401010B

#define OID_WAN_GET_BRIDGE_INFO                 0x0401020A
#define OID_WAN_SET_BRIDGE_INFO                 0x0401020B
#define OID_WAN_GET_COMP_INFO                   0x0401020C
#define OID_WAN_SET_COMP_INFO                   0x0401020D
#define OID_WAN_GET_STATS_INFO                  0x0401020E

//
//  These are connection-oriented WAN OIDs.
//  These replace the above OIDs for CoNDIS WAN Miniports
//
#define OID_WAN_CO_GET_INFO                     0x04010180
#define OID_WAN_CO_SET_LINK_INFO                0x04010181
#define OID_WAN_CO_GET_LINK_INFO                0x04010182
#define OID_WAN_CO_GET_COMP_INFO                0x04010280
#define OID_WAN_CO_SET_COMP_INFO                0x04010281
#define OID_WAN_CO_GET_STATS_INFO               0x04010282


//
// LocalTalk objects
//
#define OID_LTALK_CURRENT_NODE_ID               0x05010102

#define OID_LTALK_IN_BROADCASTS                 0x05020101
#define OID_LTALK_IN_LENGTH_ERRORS              0x05020102

#define OID_LTALK_OUT_NO_HANDLERS               0x05020201
#define OID_LTALK_COLLISIONS                    0x05020202
#define OID_LTALK_DEFERS                        0x05020203
#define OID_LTALK_NO_DATA_ERRORS                0x05020204
#define OID_LTALK_RANDOM_CTS_ERRORS             0x05020205
#define OID_LTALK_FCS_ERRORS                    0x05020206


//
// Arcnet objects
//
#define OID_ARCNET_PERMANENT_ADDRESS            0x06010101
#define OID_ARCNET_CURRENT_ADDRESS              0x06010102

#define OID_ARCNET_RECONFIGURATIONS             0x06020201

//
// TAPI objects
//
#define OID_TAPI_ACCEPT                         0x07030101
#define OID_TAPI_ANSWER                         0x07030102
#define OID_TAPI_CLOSE                          0x07030103
#define OID_TAPI_CLOSE_CALL                     0x07030104
#define OID_TAPI_CONDITIONAL_MEDIA_DETECTION    0x07030105
#define OID_TAPI_CONFIG_DIALOG                  0x07030106
#define OID_TAPI_DEV_SPECIFIC                   0x07030107
#define OID_TAPI_DIAL                           0x07030108
#define OID_TAPI_DROP                           0x07030109
#define OID_TAPI_GET_ADDRESS_CAPS               0x0703010A
#define OID_TAPI_GET_ADDRESS_ID                 0x0703010B
#define OID_TAPI_GET_ADDRESS_STATUS             0x0703010C
#define OID_TAPI_GET_CALL_ADDRESS_ID            0x0703010D
#define OID_TAPI_GET_CALL_INFO                  0x0703010E
#define OID_TAPI_GET_CALL_STATUS                0x0703010F
#define OID_TAPI_GET_DEV_CAPS                   0x07030110
#define OID_TAPI_GET_DEV_CONFIG                 0x07030111
#define OID_TAPI_GET_EXTENSION_ID               0x07030112
#define OID_TAPI_GET_ID                         0x07030113
#define OID_TAPI_GET_LINE_DEV_STATUS            0x07030114
#define OID_TAPI_MAKE_CALL                      0x07030115
#define OID_TAPI_NEGOTIATE_EXT_VERSION          0x07030116
#define OID_TAPI_OPEN                           0x07030117
#define OID_TAPI_PROVIDER_INITIALIZE            0x07030118
#define OID_TAPI_PROVIDER_SHUTDOWN              0x07030119
#define OID_TAPI_SECURE_CALL                    0x0703011A
#define OID_TAPI_SELECT_EXT_VERSION             0x0703011B
#define OID_TAPI_SEND_USER_USER_INFO            0x0703011C
#define OID_TAPI_SET_APP_SPECIFIC               0x0703011D
#define OID_TAPI_SET_CALL_PARAMS                0x0703011E
#define OID_TAPI_SET_DEFAULT_MEDIA_DETECTION    0x0703011F
#define OID_TAPI_SET_DEV_CONFIG                 0x07030120
#define OID_TAPI_SET_MEDIA_MODE                 0x07030121
#define OID_TAPI_SET_STATUS_MESSAGES            0x07030122
#define OID_TAPI_GATHER_DIGITS                  0x07030123
#define OID_TAPI_MONITOR_DIGITS                 0x07030124

//
// ATM Connection Oriented OIDs
//
#define OID_ATM_SUPPORTED_VC_RATES              0x08010101
#define OID_ATM_SUPPORTED_SERVICE_CATEGORY      0x08010102
#define OID_ATM_SUPPORTED_AAL_TYPES             0x08010103
#define OID_ATM_HW_CURRENT_ADDRESS              0x08010104
#define OID_ATM_MAX_ACTIVE_VCS                  0x08010105
#define OID_ATM_MAX_ACTIVE_VCI_BITS             0x08010106
#define OID_ATM_MAX_ACTIVE_VPI_BITS             0x08010107
#define OID_ATM_MAX_AAL0_PACKET_SIZE            0x08010108
#define OID_ATM_MAX_AAL1_PACKET_SIZE            0x08010109
#define OID_ATM_MAX_AAL34_PACKET_SIZE           0x0801010A
#define OID_ATM_MAX_AAL5_PACKET_SIZE            0x0801010B

#define OID_ATM_SIGNALING_VPIVCI                0x08010201
#define OID_ATM_ASSIGNED_VPI                    0x08010202
#define OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES    0x08010203
#define OID_ATM_RELEASE_ACCESS_NET_RESOURCES    0x08010204
#define OID_ATM_ILMI_VPIVCI                     0x08010205
#define OID_ATM_DIGITAL_BROADCAST_VPIVCI        0x08010206
#define OID_ATM_GET_NEAREST_FLOW                0x08010207
#define OID_ATM_ALIGNMENT_REQUIRED              0x08010208
#define OID_ATM_LECS_ADDRESS                    0x08010209
#define OID_ATM_SERVICE_ADDRESS                 0x0801020A

#define OID_ATM_CALL_PROCEEDING                 0x0801020B  // UNI 4.0
#define OID_ATM_CALL_ALERTING                   0x0801020C  // UNI 4.0
#define OID_ATM_PARTY_ALERTING                  0x0801020D  // UNI 4.0
#define OID_ATM_CALL_NOTIFY                     0x0801020E  // UNI 4.0

#define OID_ATM_MY_IP_NM_ADDRESS                0x0801020F


//
//  ATM specific statistics OIDs.
//
#define OID_ATM_RCV_CELLS_OK                    0x08020101
#define OID_ATM_XMIT_CELLS_OK                   0x08020102
#define OID_ATM_RCV_CELLS_DROPPED               0x08020103

#define OID_ATM_RCV_INVALID_VPI_VCI             0x08020201
#define OID_ATM_CELLS_HEC_ERROR                 0x08020202
#define OID_ATM_RCV_REASSEMBLY_ERROR            0x08020203


//
// IEEE 802.11 OIDs
//
#define OID_802_11_BSSID                        0x0D010101
#define OID_802_11_SSID                         0x0D010102
#define OID_802_11_NETWORK_TYPES_SUPPORTED      0x0D010203
#define OID_802_11_NETWORK_TYPE_IN_USE          0x0D010204
#define OID_802_11_TX_POWER_LEVEL               0x0D010205
#define OID_802_11_RSSI                         0x0D010206
#define OID_802_11_RSSI_TRIGGER                 0x0D010207
#define OID_802_11_INFRASTRUCTURE_MODE          0x0D010108
#define OID_802_11_FRAGMENTATION_THRESHOLD      0x0D010209
#define OID_802_11_RTS_THRESHOLD                0x0D01020A
#define OID_802_11_NUMBER_OF_ANTENNAS           0x0D01020B
#define OID_802_11_RX_ANTENNA_SELECTED          0x0D01020C
#define OID_802_11_TX_ANTENNA_SELECTED          0x0D01020D
#define OID_802_11_SUPPORTED_RATES              0x0D01020E
#define OID_802_11_DESIRED_RATES                0x0D010210
#define OID_802_11_CONFIGURATION                0x0D010211
#define OID_802_11_STATISTICS                   0x0D020212
#define OID_802_11_ADD_WEP                      0x0D010113
#define OID_802_11_REMOVE_WEP                   0x0D010114
#define OID_802_11_DISASSOCIATE                 0x0D010115
#define OID_802_11_POWER_MODE                   0x0D010216
#define OID_802_11_BSSID_LIST                   0x0D010217
#define OID_802_11_AUTHENTICATION_MODE          0x0D010118
#define OID_802_11_PRIVACY_FILTER               0x0D010119
#define OID_802_11_BSSID_LIST_SCAN              0x0D01011A
#define OID_802_11_WEP_STATUS                   0x0D01011B
// Renamed to reflect better the extended set of encryption status
#define OID_802_11_ENCRYPTION_STATUS            OID_802_11_WEP_STATUS
#define OID_802_11_RELOAD_DEFAULTS              0x0D01011C
// Added to allow key mapping and default keys
#define OID_802_11_ADD_KEY                      0x0D01011D
#define OID_802_11_REMOVE_KEY                   0x0D01011E
#define OID_802_11_ASSOCIATION_INFORMATION      0x0D01011F
#define OID_802_11_TEST                         0x0D010120
#define OID_802_11_MEDIA_STREAM_MODE            0x0D010121
#define OID_802_11_CAPABILITY                   0x0D010122
#define OID_802_11_PMKID                        0x0D010123
#define OID_802_11_NON_BCAST_SSID_LIST          0x0D010124
#define OID_802_11_RADIO_STATUS                 0x0D010125


//
// some of well known Ethernet frame types (in big endian notation)
//
#define NDIS_ETH_TYPE_IPV4              0x0800  // IPV4
#define NDIS_ETH_TYPE_ARP               0x0806  // ARP
#define NDIS_ETH_TYPE_IPV6              0x86dd  // IPV6
#define NDIS_ETH_TYPE_802_1X            0x888e  // 802.1x
#define NDIS_ETH_TYPE_802_1Q            0x8100  // 802.1p
#define NDIS_ETH_TYPE_SLOW_PROTOCOL     0x8809  // Slow protocols (LACP, etc.)

#define NDIS_802_11_LENGTH_SSID         32
#define NDIS_802_11_LENGTH_RATES        8
#define NDIS_802_11_LENGTH_RATES_EX     16

//
// IEEE 802.11 Structures and definitions
//
// new types for Media Specific Indications
typedef enum _NDIS_802_11_STATUS_TYPE
{
    Ndis802_11StatusType_Authentication,
    Ndis802_11StatusType_MediaStreamMode,
    Ndis802_11StatusType_PMKID_CandidateList,
    Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;

typedef UCHAR   NDIS_802_11_MAC_ADDRESS[6];

typedef struct _NDIS_802_11_STATUS_INDICATION
{
    NDIS_802_11_STATUS_TYPE StatusType;
} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;

// mask for authentication/integrity fields
#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS		0x0f

#define NDIS_802_11_AUTH_REQUEST_REAUTH				0x01
#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE			0x02
#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E

typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
{
    ULONG Length;            // Length of structure
    NDIS_802_11_MAC_ADDRESS Bssid;
    ULONG Flags;
} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;

//Added new types for PMKID Candidate lists.
typedef struct _PMKID_CANDIDATE {
    NDIS_802_11_MAC_ADDRESS BSSID;
    ULONG Flags;
} PMKID_CANDIDATE, *PPMKID_CANDIDATE;

typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST
{
    ULONG Version;       // Version of the structure
    ULONG NumCandidates; // No. of pmkid candidates
    PMKID_CANDIDATE CandidateList[1];
} NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;

//Flags for PMKID Candidate list structure
#define NDIS_802_11_PMKID_CANDIDATE_PREAUTH_ENABLED	0x01

// Added new types for OFDM 5G and 2.4G
typedef enum _NDIS_802_11_NETWORK_TYPE
{
    Ndis802_11FH,
    Ndis802_11DS,
    Ndis802_11OFDM5,
    Ndis802_11OFDM24,
    Ndis802_11Automode,
    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;

typedef struct _NDIS_802_11_NETWORK_TYPE_LIST
{
    ULONG                       NumberOfItems;  // in list below, at least 1
    NDIS_802_11_NETWORK_TYPE    NetworkType [1];
} NDIS_802_11_NETWORK_TYPE_LIST, *PNDIS_802_11_NETWORK_TYPE_LIST;

typedef enum _NDIS_802_11_POWER_MODE
{
    Ndis802_11PowerModeCAM,
    Ndis802_11PowerModeMAX_PSP,
    Ndis802_11PowerModeFast_PSP,
    Ndis802_11PowerModeMax      // not a real mode, defined as an upper bound
} NDIS_802_11_POWER_MODE, *PNDIS_802_11_POWER_MODE;

typedef ULONG   NDIS_802_11_TX_POWER_LEVEL; // in milliwatts

//
// Received Signal Strength Indication
//
typedef LONG   NDIS_802_11_RSSI;           // in dBm

typedef struct _NDIS_802_11_CONFIGURATION_FH
{
    ULONG           Length;             // Length of structure
    ULONG           HopPattern;         // As defined by 802.11, MSB set
    ULONG           HopSet;             // to one if non-802.11
    ULONG           DwellTime;          // units are Kusec
} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;

typedef struct _NDIS_802_11_CONFIGURATION
{
    ULONG           Length;             // Length of structure
    ULONG           BeaconPeriod;       // units are Kusec
    ULONG           ATIMWindow;         // units are Kusec
    ULONG           DSConfig;           // Frequency, units are kHz
    NDIS_802_11_CONFIGURATION_FH    FHConfig;
} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;

typedef struct _NDIS_802_11_STATISTICS
{
    ULONG           Length;             // Length of structure
    LARGE_INTEGER   TransmittedFragmentCount;
    LARGE_INTEGER   MulticastTransmittedFrameCount;
    LARGE_INTEGER   FailedCount;
    LARGE_INTEGER   RetryCount;
    LARGE_INTEGER   MultipleRetryCount;
    LARGE_INTEGER   RTSSuccessCount;
    LARGE_INTEGER   RTSFailureCount;
    LARGE_INTEGER   ACKFailureCount;
    LARGE_INTEGER   FrameDuplicateCount;
    LARGE_INTEGER   ReceivedFragmentCount;
    LARGE_INTEGER   MulticastReceivedFrameCount;
    LARGE_INTEGER   FCSErrorCount;
    LARGE_INTEGER   TKIPLocalMICFailures;
    LARGE_INTEGER   TKIPICVErrorCount;
    LARGE_INTEGER   TKIPCounterMeasuresInvoked;
    LARGE_INTEGER   TKIPReplays;
    LARGE_INTEGER   CCMPFormatErrors;
    LARGE_INTEGER   CCMPReplays;
    LARGE_INTEGER   CCMPDecryptErrors;
    LARGE_INTEGER   FourWayHandshakeFailures;
    LARGE_INTEGER   WEPUndecryptableCount;
    LARGE_INTEGER   WEPICVErrorCount;
    LARGE_INTEGER   DecryptSuccessCount;
    LARGE_INTEGER   DecryptFailureCount;
} NDIS_802_11_STATISTICS, *PNDIS_802_11_STATISTICS;

typedef  ULONG  NDIS_802_11_KEY_INDEX;
typedef ULONGLONG   NDIS_802_11_KEY_RSC;

// Key mapping keys require a BSSID
typedef struct _NDIS_802_11_KEY
{
    ULONG           Length;             // Length of this structure
    ULONG           KeyIndex;
    ULONG           KeyLength;          // length of key in bytes
    NDIS_802_11_MAC_ADDRESS BSSID;
    NDIS_802_11_KEY_RSC KeyRSC;
    UCHAR           KeyMaterial[1];     // variable length depending on above field
} NDIS_802_11_KEY, *PNDIS_802_11_KEY;

typedef struct _NDIS_802_11_REMOVE_KEY
{
    ULONG           Length;             // Length of this structure
    ULONG           KeyIndex;
    NDIS_802_11_MAC_ADDRESS BSSID;
} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;

typedef struct _NDIS_802_11_WEP
{
    ULONG           Length;             // Length of this structure
    ULONG           KeyIndex;           // 0 is the per-client key, 1-N are the
                                        // global keys
    ULONG           KeyLength;          // length of key in bytes
    UCHAR           KeyMaterial[1];     // variable length depending on above field
} NDIS_802_11_WEP, *PNDIS_802_11_WEP;


typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
{
    Ndis802_11IBSS,
    Ndis802_11Infrastructure,
    Ndis802_11AutoUnknown,
    Ndis802_11InfrastructureMax         // Not a real value, defined as upper bound
} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;

// Add new authentication modes
typedef enum _NDIS_802_11_AUTHENTICATION_MODE
{
    Ndis802_11AuthModeOpen,
    Ndis802_11AuthModeShared,
    Ndis802_11AuthModeAutoSwitch,
    Ndis802_11AuthModeWPA,
    Ndis802_11AuthModeWPAPSK,
    Ndis802_11AuthModeWPANone,
    Ndis802_11AuthModeWPA2,
    Ndis802_11AuthModeWPA2PSK,
    Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;

typedef UCHAR   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
typedef UCHAR   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates

typedef struct _NDIS_802_11_SSID
{
    ULONG   SsidLength;         // length of SSID field below, in bytes;
                                // this can be zero.
    UCHAR   Ssid[NDIS_802_11_LENGTH_SSID];           // SSID information field
} NDIS_802_11_SSID, *PNDIS_802_11_SSID;


typedef struct _NDIS_WLAN_BSSID
{
    ULONG                               Length;             // Length of this structure
    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
    UCHAR                               Reserved[2];
    NDIS_802_11_SSID                    Ssid;               // SSID
    ULONG                               Privacy;            // WEP encryption requirement
    NDIS_802_11_RSSI                    Rssi;               // receive signal
                                                            // strength in dBm
    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
    NDIS_802_11_CONFIGURATION           Configuration;
    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
    NDIS_802_11_RATES                   SupportedRates;
} NDIS_WLAN_BSSID, *PNDIS_WLAN_BSSID;

typedef struct _NDIS_802_11_BSSID_LIST
{
    ULONG           NumberOfItems;      // in list below, at least 1
    NDIS_WLAN_BSSID Bssid[1];
} NDIS_802_11_BSSID_LIST, *PNDIS_802_11_BSSID_LIST;

// Added Capabilities, IELength and IEs for each BSSID
typedef struct _NDIS_WLAN_BSSID_EX
{
    ULONG                               Length;             // Length of this structure
    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
    UCHAR                               Reserved[2];
    NDIS_802_11_SSID                    Ssid;               // SSID
    ULONG                               Privacy;            // WEP encryption requirement
    NDIS_802_11_RSSI                    Rssi;               // receive signal
                                                            // strength in dBm
    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
    NDIS_802_11_CONFIGURATION           Configuration;
    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
    NDIS_802_11_RATES_EX                SupportedRates;
    ULONG                               IELength;
    UCHAR                               IEs[1];
} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;

typedef struct _NDIS_802_11_BSSID_LIST_EX
{
    ULONG           NumberOfItems;      // in list below, at least 1
    NDIS_WLAN_BSSID_EX Bssid[1];
} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;

typedef struct _NDIS_802_11_FIXED_IEs
{
	UCHAR Timestamp[8];
	USHORT BeaconInterval;
	USHORT Capabilities;
} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;

typedef struct _NDIS_802_11_VARIABLE_IEs
{
	UCHAR ElementID;
	UCHAR Length;	// Number of bytes in data field
	UCHAR data[1];
} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;

typedef  ULONG   NDIS_802_11_FRAGMENTATION_THRESHOLD;

typedef  ULONG   NDIS_802_11_RTS_THRESHOLD;

typedef  ULONG   NDIS_802_11_ANTENNA;

typedef enum _NDIS_802_11_PRIVACY_FILTER
{
    Ndis802_11PrivFilterAcceptAll,
    Ndis802_11PrivFilter8021xWEP
} NDIS_802_11_PRIVACY_FILTER, *PNDIS_802_11_PRIVACY_FILTER;

// Added new encryption types
// Also aliased typedef to new name
typedef enum _NDIS_802_11_WEP_STATUS
{
    Ndis802_11WEPEnabled,
    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
    Ndis802_11WEPDisabled,
    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
    Ndis802_11WEPKeyAbsent,
    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
    Ndis802_11WEPNotSupported,
    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
    Ndis802_11Encryption2Enabled,
    Ndis802_11Encryption2KeyAbsent,
    Ndis802_11Encryption3Enabled,
    Ndis802_11Encryption3KeyAbsent
} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;

typedef enum _NDIS_802_11_RELOAD_DEFAULTS
{
    Ndis802_11ReloadWEPKeys
} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;

#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4

#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
#define NDIS_802_11_AI_RESFI_STATUSCODE        2
#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4

typedef struct _NDIS_802_11_AI_REQFI
{
    USHORT Capabilities;
    USHORT ListenInterval;
    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;

typedef struct _NDIS_802_11_AI_RESFI
{
    USHORT Capabilities;
    USHORT StatusCode;
    USHORT AssociationId;
} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;

typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
{
    ULONG Length;
    USHORT AvailableRequestFixedIEs;
    NDIS_802_11_AI_REQFI    RequestFixedIEs;
    ULONG RequestIELength;
    ULONG OffsetRequestIEs;
    USHORT AvailableResponseFixedIEs;
    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
    ULONG ResponseIELength;
    ULONG OffsetResponseIEs;
} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;

typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
{
    NDIS_802_11_STATUS_INDICATION       Status;
    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;

typedef struct _NDIS_802_11_TEST
{
    ULONG Length;
    ULONG Type;
    union
    {
        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
        NDIS_802_11_RSSI RssiTrigger;
    };
} NDIS_802_11_TEST, *PNDIS_802_11_TEST;

// 802.11 Media stream constraints, associated with OID_802_11_MEDIA_STREAM_MODE
typedef enum _NDIS_802_11_MEDIA_STREAM_MODE
{
    Ndis802_11MediaStreamOff,
    Ndis802_11MediaStreamOn,
} NDIS_802_11_MEDIA_STREAM_MODE, *PNDIS_802_11_MEDIA_STREAM_MODE;

// PMKID Structures
typedef UCHAR   NDIS_802_11_PMKID_VALUE[16];

typedef struct _BSSID_INFO
{
    NDIS_802_11_MAC_ADDRESS BSSID;
    NDIS_802_11_PMKID_VALUE PMKID;
} BSSID_INFO, *PBSSID_INFO;

typedef struct _NDIS_802_11_PMKID
{
    ULONG Length;
    ULONG BSSIDInfoCount;
    BSSID_INFO BSSIDInfo[1];
} NDIS_802_11_PMKID, *PNDIS_802_11_PMKID;

typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION
{
    NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
    NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
} NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;

typedef struct _NDIS_802_11_CAPABILITY
{
    ULONG Length;
    ULONG Version;
    ULONG NoOfPMKIDs;
    ULONG NoOfAuthEncryptPairsSupported;
    NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
} NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;

typedef struct _NDIS_802_11_NON_BCAST_SSID_LIST
{
    ULONG               NumberOfItems;
    NDIS_802_11_SSID    Non_Bcast_Ssid[1];
} NDIS_802_11_NON_BCAST_SSID_LIST, *PNDIS_802_11_NON_BCAST_SSID_LIST;

// for OID_802_11_RADIO_STATUS
typedef enum _NDIS_802_11_RADIO_STATUS
{
    Ndis802_11RadioStatusOn,
    Ndis802_11RadioStatusHardwareOff,
    Ndis802_11RadioStatusSoftwareOff,
    Ndis802_11RadioStatusHardwareSoftwareOff,
    Ndis802_11RadioStatusMax      // not a real mode, defined as an upper bound
}
NDIS_802_11_RADIO_STATUS, *PNDIS_802_11_RADIO_STATUS;

//
// IRDA objects
//
#define OID_IRDA_RECEIVING                      0x0A010100
#define OID_IRDA_TURNAROUND_TIME                0x0A010101
#define OID_IRDA_SUPPORTED_SPEEDS               0x0A010102
#define OID_IRDA_LINK_SPEED                     0x0A010103
#define OID_IRDA_MEDIA_BUSY                     0x0A010104

#define OID_IRDA_EXTRA_RCV_BOFS                 0x0A010200
#define OID_IRDA_RATE_SNIFF                     0x0A010201
#define OID_IRDA_UNICAST_LIST                   0x0A010202
#define OID_IRDA_MAX_UNICAST_LIST_SIZE          0x0A010203
#define OID_IRDA_MAX_RECEIVE_WINDOW_SIZE        0x0A010204
#define OID_IRDA_MAX_SEND_WINDOW_SIZE           0x0A010205
#define OID_IRDA_RESERVED1                      0x0A01020A  // The range between OID_IRDA_RESERVED1
#define OID_IRDA_RESERVED2                      0x0A01020F  // and OID_IRDA_RESERVED2 is reserved


//
// IEEE1394 mandatory general OIDs.
//
#define OID_1394_LOCAL_NODE_INFO                0x0C010101
#define OID_1394_VC_INFO                        0x0C010102

//
// The following OIDs are not specific to a media.
//

//
// These are objects for Connection-oriented media call-managers.
//
#define OID_CO_ADD_PVC                          0xFE000001
#define OID_CO_DELETE_PVC                       0xFE000002
#define OID_CO_GET_CALL_INFORMATION             0xFE000003
#define OID_CO_ADD_ADDRESS                      0xFE000004
#define OID_CO_DELETE_ADDRESS                   0xFE000005
#define OID_CO_GET_ADDRESSES                    0xFE000006
#define OID_CO_ADDRESS_CHANGE                   0xFE000007
#define OID_CO_SIGNALING_ENABLED                0xFE000008
#define OID_CO_SIGNALING_DISABLED               0xFE000009
#define OID_CO_AF_CLOSE                         0xFE00000A

//
// Objects for call-managers and MCMs that support TAPI access.
//
#define OID_CO_TAPI_CM_CAPS                     0xFE001001
#define OID_CO_TAPI_LINE_CAPS                   0xFE001002
#define OID_CO_TAPI_ADDRESS_CAPS                0xFE001003
#define OID_CO_TAPI_TRANSLATE_TAPI_CALLPARAMS   0xFE001004
#define OID_CO_TAPI_TRANSLATE_NDIS_CALLPARAMS   0xFE001005
#define OID_CO_TAPI_TRANSLATE_TAPI_SAP          0xFE001006
#define OID_CO_TAPI_GET_CALL_DIAGNOSTICS        0xFE001007
#define OID_CO_TAPI_REPORT_DIGITS               0xFE001008
#define OID_CO_TAPI_DONT_REPORT_DIGITS          0xFE001009

//
//  PnP and PM OIDs
//
#define OID_PNP_CAPABILITIES                    0xFD010100
#define OID_PNP_SET_POWER                       0xFD010101
#define OID_PNP_QUERY_POWER                     0xFD010102
#define OID_PNP_ADD_WAKE_UP_PATTERN             0xFD010103
#define OID_PNP_REMOVE_WAKE_UP_PATTERN          0xFD010104
#define OID_PNP_WAKE_UP_PATTERN_LIST            0xFD010105
#define OID_PNP_ENABLE_WAKE_UP                  0xFD010106

//
//  PnP/PM Statistics (Optional).
//
#define OID_PNP_WAKE_UP_OK                      0xFD020200
#define OID_PNP_WAKE_UP_ERROR                   0xFD020201

#if ((NTDDI_VERSION >= NTDDI_WIN7) || NDIS_SUPPORT_NDIS620)
//
// new power management OIDs for NDIS 6.20 drivers
//

#define OID_PM_CURRENT_CAPABILITIES             0xFD010107
#define OID_PM_HARDWARE_CAPABILITIES            0xFD010108
#define OID_PM_PARAMETERS                       0xFD010109
#define OID_PM_ADD_WOL_PATTERN                  0xFD01010A
#define OID_PM_REMOVE_WOL_PATTERN               0xFD01010B
#define OID_PM_WOL_PATTERN_LIST                 0xFD01010C
#define OID_PM_ADD_PROTOCOL_OFFLOAD             0xFD01010D 
#define OID_PM_GET_PROTOCOL_OFFLOAD             0xFD01010E 
#define OID_PM_REMOVE_PROTOCOL_OFFLOAD          0xFD01010F
#define OID_PM_PROTOCOL_OFFLOAD_LIST            0xFD010110

//
// new NDIS 6.20 OIDs for generic packet filtering
//
#define OID_RECEIVE_FILTER_HARDWARE_CAPABILITIES        0x00010221  // query only
#define OID_RECEIVE_FILTER_GLOBAL_PARAMETERS            0x00010222  // query only
#define OID_RECEIVE_FILTER_ALLOCATE_QUEUE               0x00010223  // method only
#define OID_RECEIVE_FILTER_FREE_QUEUE                   0x00010224  // set only 
#define OID_RECEIVE_FILTER_ENUM_QUEUES                  0x00010225  // query only
#define OID_RECEIVE_FILTER_QUEUE_PARAMETERS             0x00010226  // method and set
#define OID_RECEIVE_FILTER_SET_FILTER                   0x00010227  // method only
#define OID_RECEIVE_FILTER_CLEAR_FILTER                 0x00010228  // set only
#define OID_RECEIVE_FILTER_ENUM_FILTERS                 0x00010229  // method only
#define OID_RECEIVE_FILTER_PARAMETERS                   0x0001022A  // method only
#define OID_RECEIVE_FILTER_QUEUE_ALLOCATION_COMPLETE    0x0001022B  // method only
#define OID_RECEIVE_FILTER_CURRENT_CAPABILITIES         0x0001022D  // query only
#define OID_NIC_SWITCH_HARDWARE_CAPABILITIES            0x0001022E  // query only
#define OID_NIC_SWITCH_CURRENT_CAPABILITIES             0x0001022F  // query only


#define OID_VLAN_RESERVED1                              0x00010231  
#define OID_VLAN_RESERVED2                              0x00010232  
#define OID_VLAN_RESERVED3                              0x00010233  
#define OID_VLAN_RESERVED4                              0x00010234  

#endif // ((NTDDI_VERSION >= NTDDI_WIN7) || NDIS_SUPPORT_NDIS620)


//
//  The following bits are defined for OID_PNP_ENABLE_WAKE_UP
//
#define NDIS_PNP_WAKE_UP_MAGIC_PACKET           0x00000001
#define NDIS_PNP_WAKE_UP_PATTERN_MATCH          0x00000002
#define NDIS_PNP_WAKE_UP_LINK_CHANGE            0x00000004

//
//  TCP/IP OIDs
//
#define OID_TCP_TASK_OFFLOAD                    0xFC010201
#define OID_TCP_TASK_IPSEC_ADD_SA               0xFC010202
#define OID_TCP_TASK_IPSEC_DELETE_SA            0xFC010203
#define OID_TCP_SAN_SUPPORT                     0xFC010204
#define OID_TCP_TASK_IPSEC_ADD_UDPESP_SA        0xFC010205
#define OID_TCP_TASK_IPSEC_DELETE_UDPESP_SA     0xFC010206
#define OID_TCP4_OFFLOAD_STATS                  0xFC010207
#define OID_TCP6_OFFLOAD_STATS                  0xFC010208
#define OID_IP4_OFFLOAD_STATS                   0xFC010209
#define OID_IP6_OFFLOAD_STATS                   0xFC01020A

//
// new offload OIDs for NDIS 6
//
#define OID_TCP_OFFLOAD_CURRENT_CONFIG          0xFC01020B          // query only, handled by NDIS
#define OID_TCP_OFFLOAD_PARAMETERS              0xFC01020C          // set only
#define OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES   0xFC01020D          // query only
#define OID_TCP_CONNECTION_OFFLOAD_CURRENT_CONFIG 0xFC01020E        // query only
#define OID_TCP_CONNECTION_OFFLOAD_HARDWARE_CAPABILITIES 0xFC01020F // query only
#define OID_OFFLOAD_ENCAPSULATION               0x0101010A

#if (NDIS_SUPPORT_NDIS61)
//
// IPsec Task offload V2 OIDs
//
#define OID_TCP_TASK_IPSEC_OFFLOAD_V2_ADD_SA    0xFC030202
#define OID_TCP_TASK_IPSEC_OFFLOAD_V2_DELETE_SA 0xFC030203
#define OID_TCP_TASK_IPSEC_OFFLOAD_V2_UPDATE_SA 0xFC030204
#endif // (NDIS_SUPPORT_NDIS61)

//
//  Defines for FFP, obsolete
//
#define OID_FFP_SUPPORT                         0xFC010210
#define OID_FFP_FLUSH                           0xFC010211
#define OID_FFP_CONTROL                         0xFC010212
#define OID_FFP_PARAMS                          0xFC010213
#define OID_FFP_DATA                            0xFC010214

#define OID_FFP_DRIVER_STATS                    0xFC020210
#define OID_FFP_ADAPTER_STATS                   0xFC020211


//
// TCP Connection offload OID
//
#define OID_TCP_CONNECTION_OFFLOAD_PARAMETERS   0xFC030201

#if ((NTDDI_VERSION >= NTDDI_WIN7) || NDIS_SUPPORT_NDIS620)
//
// New Tunnel driver direct OIDs for NDIS 6.20
//
#define OID_TUNNEL_INTERFACE_SET_OID            0x0f010106
#define OID_TUNNEL_INTERFACE_RELEASE_OID        0x0f010107
#endif // ((NTDDI_VERSION >= NTDDI_WIN7) || NDIS_SUPPORT_NDIS620)


//
//  Defines for QOS
//
#define OID_QOS_RESERVED1                       0xFB010100
#define OID_QOS_RESERVED2                       0xFB010101
#define OID_QOS_RESERVED3                       0xFB010102
#define OID_QOS_RESERVED4                       0xFB010103
#define OID_QOS_RESERVED5                       0xFB010104
#define OID_QOS_RESERVED6                       0xFB010105
#define OID_QOS_RESERVED7                       0xFB010106
#define OID_QOS_RESERVED8                       0xFB010107
#define OID_QOS_RESERVED9                       0xFB010108
#define OID_QOS_RESERVED10                      0xFB010109
#define OID_QOS_RESERVED11                      0xFB01010A
#define OID_QOS_RESERVED12                      0xFB01010B
#define OID_QOS_RESERVED13                      0xFB01010C
#define OID_QOS_RESERVED14                      0xFB01010D
#define OID_QOS_RESERVED15                      0xFB01010E
#define OID_QOS_RESERVED16                      0xFB01010F
#define OID_QOS_RESERVED17                      0xFB010110
#define OID_QOS_RESERVED18                      0xFB010111
#define OID_QOS_RESERVED19                      0xFB010112
#define OID_QOS_RESERVED20                      0xFB010113


//
// NDIS Proxy OID_GEN_CO_DEVICE_PROFILE structure. The optional OID and
// this structure is a generic means of describing a CO device's
// capabilites, and is used by the NDIS Proxy to construct a TAPI device
// capabilities structure.
//
typedef struct NDIS_CO_DEVICE_PROFILE
{
    NDIS_VAR_DATA_DESC  DeviceDescription;  // e.g. 'GigabitATMNet'
    NDIS_VAR_DATA_DESC  DevSpecificInfo;    // special features

    ULONG   ulTAPISupplementaryPassThru;// reserved in NT5
    ULONG   ulAddressModes;
    ULONG   ulNumAddresses;
    ULONG   ulBearerModes;
    ULONG   ulMaxTxRate; // bytes per second
    ULONG   ulMinTxRate; // bytes per second
    ULONG   ulMaxRxRate; // bytes per second
    ULONG   ulMinRxRate; // bytes per second
    ULONG   ulMediaModes;

    //
    // Tone/digit generation and recognition capabilities
    //
    ULONG   ulGenerateToneModes;
    ULONG   ulGenerateToneMaxNumFreq;
    ULONG   ulGenerateDigitModes;
    ULONG   ulMonitorToneMaxNumFreq;
    ULONG   ulMonitorToneMaxNumEntries;
    ULONG   ulMonitorDigitModes;
    ULONG   ulGatherDigitsMinTimeout;// milliseconds
    ULONG   ulGatherDigitsMaxTimeout;// milliseconds

    ULONG   ulDevCapFlags;          // Misc. capabilities
    ULONG   ulMaxNumActiveCalls;    // (This * ulMinRate) = total bandwidth (which may equal ulMaxRate)
    ULONG   ulAnswerMode;           // Effect of answering a new call when an
                                    // existing call is non-idle
    //
    // User-User info sizes allowed to accompany each operation
    //
    ULONG   ulUUIAcceptSize;    // bytes
    ULONG   ulUUIAnswerSize;    // bytes
    ULONG   ulUUIMakeCallSize;  // bytes
    ULONG   ulUUIDropSize;      // bytes
    ULONG   ulUUISendUserUserInfoSize; // bytes
    ULONG   ulUUICallInfoSize;  // bytes

} NDIS_CO_DEVICE_PROFILE, *PNDIS_CO_DEVICE_PROFILE;

//
//  Structures for TCP IPsec.
//
#ifndef IP_EXPORT_INCLUDED
typedef ULONG   IPAddr, IPMask;
#endif
typedef ULONG   SPI_TYPE;

typedef enum    _OFFLOAD_OPERATION_E
{
    AUTHENTICATE = 1,
    ENCRYPT
}
    OFFLOAD_OPERATION_E;

typedef struct _OFFLOAD_ALGO_INFO
{
    ULONG   algoIdentifier;
    ULONG   algoKeylen;
    ULONG   algoRounds;
}
    OFFLOAD_ALGO_INFO,
    *POFFLOAD_ALGO_INFO;

typedef enum _OFFLOAD_CONF_ALGO
{
    OFFLOAD_IPSEC_CONF_NONE,
    OFFLOAD_IPSEC_CONF_DES,
    OFFLOAD_IPSEC_CONF_RESERVED,
    OFFLOAD_IPSEC_CONF_3_DES,
    OFFLOAD_IPSEC_CONF_MAX
}
    OFFLOAD_CONF_ALGO;

typedef enum _OFFLOAD_INTEGRITY_ALGO
{
    OFFLOAD_IPSEC_INTEGRITY_NONE,
    OFFLOAD_IPSEC_INTEGRITY_MD5,
    OFFLOAD_IPSEC_INTEGRITY_SHA,
    OFFLOAD_IPSEC_INTEGRITY_MAX
}
    OFFLOAD_INTEGRITY_ALGO;

typedef struct _OFFLOAD_SECURITY_ASSOCIATION
{
    OFFLOAD_OPERATION_E     Operation;
    SPI_TYPE                SPI;
    OFFLOAD_ALGO_INFO       IntegrityAlgo;
    OFFLOAD_ALGO_INFO       ConfAlgo;
    OFFLOAD_ALGO_INFO       Reserved;
}
    OFFLOAD_SECURITY_ASSOCIATION,
    *POFFLOAD_SECURITY_ASSOCIATION;

#define OFFLOAD_MAX_SAS             3

#define OFFLOAD_INBOUND_SA          0x0001
#define OFFLOAD_OUTBOUND_SA         0x0002

typedef struct _OFFLOAD_IPSEC_ADD_SA
{
    IPAddr                          SrcAddr;
    IPMask                          SrcMask;
    IPAddr                          DestAddr;
    IPMask                          DestMask;
    ULONG                           Protocol;
    USHORT                          SrcPort;
    USHORT                          DestPort;
    IPAddr                          SrcTunnelAddr;
    IPAddr                          DestTunnelAddr;
    USHORT                          Flags;
    SHORT                           NumSAs;
    OFFLOAD_SECURITY_ASSOCIATION    SecAssoc[OFFLOAD_MAX_SAS];
    HANDLE                          OffloadHandle;
    ULONG                           KeyLen;
    UCHAR                           KeyMat[1];
} OFFLOAD_IPSEC_ADD_SA, *POFFLOAD_IPSEC_ADD_SA;

typedef struct _OFFLOAD_IPSEC_DELETE_SA
{
    HANDLE                          OffloadHandle;
} OFFLOAD_IPSEC_DELETE_SA, *POFFLOAD_IPSEC_DELETE_SA;


typedef enum _UDP_ENCAP_TYPE
{
    OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_IKE,
    OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_OTHER
} UDP_ENCAP_TYPE, * PUDP_ENCAP_TYPE;


typedef struct _OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY
{
    UDP_ENCAP_TYPE                  UdpEncapType;
    USHORT                          DstEncapPort;
} OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY, * POFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY;


typedef struct _OFFLOAD_IPSEC_ADD_UDPESP_SA
{
    IPAddr                                  SrcAddr;
    IPMask                                  SrcMask;
    IPAddr                                  DstAddr;
    IPMask                                  DstMask;
    ULONG                                   Protocol;
    USHORT                                  SrcPort;
    USHORT                                  DstPort;
    IPAddr                                  SrcTunnelAddr;
    IPAddr                                  DstTunnelAddr;
    USHORT                                  Flags;
    SHORT                                   NumSAs;
    OFFLOAD_SECURITY_ASSOCIATION            SecAssoc[OFFLOAD_MAX_SAS];
    HANDLE                                  OffloadHandle;
    OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY    EncapTypeEntry;
    HANDLE                                  EncapTypeEntryOffldHandle;
    ULONG                                   KeyLen;
    UCHAR                                   KeyMat[1];
} OFFLOAD_IPSEC_ADD_UDPESP_SA, * POFFLOAD_IPSEC_ADD_UDPESP_SA;


typedef struct _OFFLOAD_IPSEC_DELETE_UDPESP_SA
{
    HANDLE                                  OffloadHandle;
    HANDLE                                  EncapTypeEntryOffldHandle;
} OFFLOAD_IPSEC_DELETE_UDPESP_SA, * POFFLOAD_IPSEC_DELETE_UDPESP_SA;


//
// Type to go with OID_GEN_VLAN_ID: the least significant 12 bits are
// used as the VLAN ID (VID) per IEEE 802.1Q. Higher order bits are
// reserved and must be set to 0.
//
typedef ULONG NDIS_VLAN_ID;

//
// Medium the Ndis Driver is running on (OID_GEN_MEDIA_SUPPORTED/ OID_GEN_MEDIA_IN_USE).
//
typedef enum _NDIS_MEDIUM
{
    NdisMedium802_3,
    NdisMedium802_5,
    NdisMediumFddi,
    NdisMediumWan,
    NdisMediumLocalTalk,
    NdisMediumDix,              // defined for convenience, not a real medium
    NdisMediumArcnetRaw,
    NdisMediumArcnet878_2,
    NdisMediumAtm,
    NdisMediumWirelessWan,
    NdisMediumIrda,
    NdisMediumBpc,
    NdisMediumCoWan,
    NdisMedium1394,
    NdisMediumInfiniBand,
#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
    NdisMediumTunnel,
    NdisMediumNative802_11,
    NdisMediumLoopback,
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WIN7)
    NdisMediumWiMAX,
    NdisMediumIP,
#endif

    NdisMediumMax               // Not a real medium, defined as an upper-bound
} NDIS_MEDIUM, *PNDIS_MEDIUM;


//
// Physical Medium Type definitions. Used with OID_GEN_PHYSICAL_MEDIUM.
//
typedef enum _NDIS_PHYSICAL_MEDIUM
{
    NdisPhysicalMediumUnspecified,
    NdisPhysicalMediumWirelessLan,
    NdisPhysicalMediumCableModem,
    NdisPhysicalMediumPhoneLine,
    NdisPhysicalMediumPowerLine,
    NdisPhysicalMediumDSL,      // includes ADSL and UADSL (G.Lite)
    NdisPhysicalMediumFibreChannel,
    NdisPhysicalMedium1394,
    NdisPhysicalMediumWirelessWan,
    NdisPhysicalMediumNative802_11,
    NdisPhysicalMediumBluetooth,
    NdisPhysicalMediumInfiniband,
    NdisPhysicalMediumWiMax,
    NdisPhysicalMediumUWB,
    NdisPhysicalMedium802_3,
    NdisPhysicalMedium802_5,
    NdisPhysicalMediumIrda,
    NdisPhysicalMediumWiredWAN,
    NdisPhysicalMediumWiredCoWan,
    NdisPhysicalMediumOther,
    NdisPhysicalMediumMax       // Not a real physical type, defined as an upper-bound
} NDIS_PHYSICAL_MEDIUM, *PNDIS_PHYSICAL_MEDIUM;


//
//  Protocol types supported by ndis. These values need to be consistent with ADDRESS_TYPE_XXX defined in TDI.H
//
#define NDIS_PROTOCOL_ID_DEFAULT        0x00
#define NDIS_PROTOCOL_ID_TCP_IP         0x02
#define NDIS_PROTOCOL_ID_IPX            0x06
#define NDIS_PROTOCOL_ID_NBF            0x07
#define NDIS_PROTOCOL_ID_MAX            0x0F
#define NDIS_PROTOCOL_ID_MASK           0x0F

//
// The following is used with OID_GEN_TRANSPORT_HEADER_OFFSET to indicate the length of the layer-2 header
// for packets sent by a particular protocol.
//
typedef struct _TRANSPORT_HEADER_OFFSET
{
    USHORT      ProtocolType;       // The protocol that is sending this OID (NDIS_PROTOCOL_ID_XXX above)
    USHORT      HeaderOffset;       // The header offset
} TRANSPORT_HEADER_OFFSET, *PTRANSPORT_HEADER_OFFSET;


//
// The structures below need to be consistent with TRANSPORT_ADDRESS structures in TDI.H
//
typedef struct _NETWORK_ADDRESS
{
    USHORT      AddressLength;      // length in bytes of Address[] in this
    USHORT      AddressType;        // type of this address (NDIS_PROTOCOL_ID_XXX above)
    UCHAR       Address[1];         // actually AddressLength bytes long
} NETWORK_ADDRESS, *PNETWORK_ADDRESS;

//
// The following is used with OID_GEN_NETWORK_LAYER_ADDRESSES to set network layer addresses on an interface
//
typedef struct _NETWORK_ADDRESS_LIST
{
    LONG        AddressCount;       // number of addresses following
    USHORT      AddressType;        // type of this address (NDIS_PROTOCOL_ID_XXX above)
    NETWORK_ADDRESS Address[1];     // actually AddressCount elements long
} NETWORK_ADDRESS_LIST, *PNETWORK_ADDRESS_LIST;

//
// IP address - This must remain consistent with TDI_ADDRESS_IP in tdi.h
//
typedef struct _NETWORK_ADDRESS_IP
{
    USHORT      sin_port;
    ULONG       in_addr;
    UCHAR       sin_zero[8];
} NETWORK_ADDRESS_IP, *PNETWORK_ADDRESS_IP;

#define NETWORK_ADDRESS_LENGTH_IP sizeof (NETWORK_ADDRESS_IP)

//
// IPX address - This must remain consistent with TDI_ADDRESS_IPX in tdi.h.
//
typedef struct _NETWORK_ADDRESS_IPX
{
    ULONG       NetworkAddress;
    UCHAR       NodeAddress[6];
    USHORT      Socket;
} NETWORK_ADDRESS_IPX, *PNETWORK_ADDRESS_IPX;

#define NETWORK_ADDRESS_LENGTH_IPX sizeof (NETWORK_ADDRESS_IPX)

//
// Hardware status codes (OID_GEN_HARDWARE_STATUS).
//

typedef enum _NDIS_HARDWARE_STATUS
{
    NdisHardwareStatusReady,
    NdisHardwareStatusInitializing,
    NdisHardwareStatusReset,
    NdisHardwareStatusClosing,
    NdisHardwareStatusNotReady
} NDIS_HARDWARE_STATUS, *PNDIS_HARDWARE_STATUS;


//
// this is the type passed in the OID_GEN_GET_TIME_CAPS request
//
typedef struct _GEN_GET_TIME_CAPS
{
    ULONG                       Flags;  // Bits defined below
    ULONG                       ClockPrecision;
} GEN_GET_TIME_CAPS, *PGEN_GET_TIME_CAPS;

#define READABLE_LOCAL_CLOCK                    0x00000001
#define CLOCK_NETWORK_DERIVED                   0x00000002
#define CLOCK_PRECISION                         0x00000004
#define RECEIVE_TIME_INDICATION_CAPABLE         0x00000008
#define TIMED_SEND_CAPABLE                      0x00000010
#define TIME_STAMP_CAPABLE                      0x00000020

//
// this is the type passed in the OID_GEN_GET_NETCARD_TIME request
//
typedef struct _GEN_GET_NETCARD_TIME
{
    ULONGLONG                   ReadTime;
} GEN_GET_NETCARD_TIME, *PGEN_GET_NETCARD_TIME;

//
//  NDIS PnP routines and definitions.
//
typedef struct _NDIS_PM_PACKET_PATTERN
{
    ULONG   Priority;                   // Importance of the given pattern.
    ULONG   Reserved;                   // Context information for transports.
    ULONG   MaskSize;                   // Size in bytes of the pattern mask.
    ULONG   PatternOffset;              // Offset from beginning of this
                                        // structure to the pattern bytes.
    ULONG   PatternSize;                // Size in bytes of the pattern.
    ULONG   PatternFlags;               // Flags (TBD).
} NDIS_PM_PACKET_PATTERN, *PNDIS_PM_PACKET_PATTERN;


//
//  The following structure defines the device power states.
//
typedef enum _NDIS_DEVICE_POWER_STATE
{
    NdisDeviceStateUnspecified = 0,
    NdisDeviceStateD0,
    NdisDeviceStateD1,
    NdisDeviceStateD2,
    NdisDeviceStateD3,
    NdisDeviceStateMaximum
} NDIS_DEVICE_POWER_STATE, *PNDIS_DEVICE_POWER_STATE;

//
//  The following structure defines the wake-up capabilities of the device.
//
typedef struct _NDIS_PM_WAKE_UP_CAPABILITIES
{
    NDIS_DEVICE_POWER_STATE MinMagicPacketWakeUp;
    NDIS_DEVICE_POWER_STATE MinPatternWakeUp;
    NDIS_DEVICE_POWER_STATE MinLinkChangeWakeUp;
} NDIS_PM_WAKE_UP_CAPABILITIES, *PNDIS_PM_WAKE_UP_CAPABILITIES;

//
// the following flags define the -enabled- wake-up capabilities of the device
// passed in the Flags field of NDIS_PNP_CAPABILITIES structure
//
#define NDIS_DEVICE_WAKE_UP_ENABLE                          0x00000001
#define NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE            0x00000002
#define NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE             0x00000004

//
//  This structure defines general PnP capabilities of the miniport driver.
//
typedef struct _NDIS_PNP_CAPABILITIES
{
    ULONG                           Flags;
    NDIS_PM_WAKE_UP_CAPABILITIES    WakeUpCapabilities;
} NDIS_PNP_CAPABILITIES, *PNDIS_PNP_CAPABILITIES;

//
// Defines the attachment types for FDDI (OID_FDDI_ATTACHMENT_TYPE).
//
typedef enum _NDIS_FDDI_ATTACHMENT_TYPE
{
    NdisFddiTypeIsolated = 1,
    NdisFddiTypeLocalA,
    NdisFddiTypeLocalB,
    NdisFddiTypeLocalAB,
    NdisFddiTypeLocalS,
    NdisFddiTypeWrapA,
    NdisFddiTypeWrapB,
    NdisFddiTypeWrapAB,
    NdisFddiTypeWrapS,
    NdisFddiTypeCWrapA,
    NdisFddiTypeCWrapB,
    NdisFddiTypeCWrapS,
    NdisFddiTypeThrough
} NDIS_FDDI_ATTACHMENT_TYPE, *PNDIS_FDDI_ATTACHMENT_TYPE;


//
// Defines the ring management states for FDDI (OID_FDDI_RING_MGT_STATE).
//
typedef enum _NDIS_FDDI_RING_MGT_STATE
{
    NdisFddiRingIsolated = 1,
    NdisFddiRingNonOperational,
    NdisFddiRingOperational,
    NdisFddiRingDetect,
    NdisFddiRingNonOperationalDup,
    NdisFddiRingOperationalDup,
    NdisFddiRingDirected,
    NdisFddiRingTrace
} NDIS_FDDI_RING_MGT_STATE, *PNDIS_FDDI_RING_MGT_STATE;


//
// Defines the Lconnection state for FDDI (OID_FDDI_LCONNECTION_STATE).
//
typedef enum _NDIS_FDDI_LCONNECTION_STATE
{
    NdisFddiStateOff = 1,
    NdisFddiStateBreak,
    NdisFddiStateTrace,
    NdisFddiStateConnect,
    NdisFddiStateNext,
    NdisFddiStateSignal,
    NdisFddiStateJoin,
    NdisFddiStateVerify,
    NdisFddiStateActive,
    NdisFddiStateMaintenance
} NDIS_FDDI_LCONNECTION_STATE, *PNDIS_FDDI_LCONNECTION_STATE;


//
// Defines the medium subtypes for WAN medium (OID_WAN_MEDIUM_SUBTYPE).
// Sub-medium used only by connection-oriented WAN devices
// i.e. NdisMediumWan, NdisMediumCoWan.
//
typedef enum _NDIS_WAN_MEDIUM_SUBTYPE
{
    NdisWanMediumHub,
    NdisWanMediumX_25,
    NdisWanMediumIsdn,
    NdisWanMediumSerial,
    NdisWanMediumFrameRelay,
    NdisWanMediumAtm,
    NdisWanMediumSonet,
    NdisWanMediumSW56K,
    NdisWanMediumPPTP,
    NdisWanMediumL2TP,
    NdisWanMediumIrda,
    NdisWanMediumParallel,
    NdisWanMediumPppoe,
#if (NTDDI_VERSION >= NTDDI_VISTA)
    NdisWanMediumSSTP,
    NdisWanMediumAgileVPN,
#endif //(NTDDI_VERSION >= NTDDI_VISTA)

} NDIS_WAN_MEDIUM_SUBTYPE, *PNDIS_WAN_MEDIUM_SUBTYPE;


//
// Defines the header format for WAN medium (OID_WAN_HEADER_FORMAT).
//
typedef enum _NDIS_WAN_HEADER_FORMAT
{
    NdisWanHeaderNative,        // src/dest based on subtype, followed by NLPID
    NdisWanHeaderEthernet       // emulation of ethernet header
} NDIS_WAN_HEADER_FORMAT, *PNDIS_WAN_HEADER_FORMAT;


//
// Defines the line quality on a WAN line (OID_WAN_QUALITY_OF_SERVICE).
//
typedef enum _NDIS_WAN_QUALITY
{
    NdisWanRaw,
    NdisWanErrorControl,
    NdisWanReliable
} NDIS_WAN_QUALITY, *PNDIS_WAN_QUALITY;


//
// Defines a protocol's WAN specific capabilities (OID_WAN_PROTOCOL_CAPS).
//
typedef struct _NDIS_WAN_PROTOCOL_CAPS
{
    __in  ULONG   Flags;
    __in  ULONG   Reserved;
} NDIS_WAN_PROTOCOL_CAPS, *PNDIS_WAN_PROTOCOL_CAPS;


//
// Flags used in NDIS_WAN_PROTOCOL_CAPS
//
#define WAN_PROTOCOL_KEEPS_STATS    0x00000001


//
// Defines the state of a token-ring adapter (OID_802_5_CURRENT_RING_STATE).
//
typedef enum _NDIS_802_5_RING_STATE
{
    NdisRingStateOpened = 1,
    NdisRingStateClosed,
    NdisRingStateOpening,
    NdisRingStateClosing,
    NdisRingStateOpenFailure,
    NdisRingStateRingFailure
} NDIS_802_5_RING_STATE, *PNDIS_802_5_RING_STATE;

//
// Defines the state of the LAN media
//
typedef enum _NDIS_MEDIA_STATE
{
    NdisMediaStateConnected,
    NdisMediaStateDisconnected
} NDIS_MEDIA_STATE, *PNDIS_MEDIA_STATE;

//
// The following is set on a per-packet basis as OOB data with NdisClass802_3Priority
//
typedef ULONG   Priority_802_3;         // 0-7 priority levels

//
//  The following structure is used to query OID_GEN_CO_LINK_SPEED and
//  OID_GEN_CO_MINIMUM_LINK_SPEED. The first OID will return the current
//  link speed of the adapter. The second will return the minimum link speed
//  the adapter is capable of.
//
typedef struct _NDIS_CO_LINK_SPEED
{
    ULONG   Outbound;
    ULONG   Inbound;
} NDIS_CO_LINK_SPEED, *PNDIS_CO_LINK_SPEED;

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)

//
// The following structure is used in OID_GEN_LINK_SPEED_EX for interfaces
// and is expressed in bits per second.
//
typedef struct _NDIS_LINK_SPEED
{
    ULONG64     XmitLinkSpeed;
    ULONG64     RcvLinkSpeed;
} NDIS_LINK_SPEED, *PNDIS_LINK_SPEED;



// miniports or interfaces that do not know their current link speed
// can report NDIS_LINK_SPEED_UNKNOWN == ((ULONG64)-1)
#define NDIS_LINK_SPEED_UNKNOWN NET_IF_LINK_SPEED_UNKNOWN
#endif

#ifndef _NDIS_
typedef int NDIS_STATUS, *PNDIS_STATUS;
#endif

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
// Native 802.11 Definitions
#ifndef __WINDOT11_H__
#include <windot11.h>
#endif
#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//
//  Structure to be used for OID_GEN_SUPPORTED_GUIDS.
//  This structure describes an OID to GUID mapping.
//  Or a Status to GUID mapping.
//  When ndis receives a request for a give GUID it will
//  query the miniport with the supplied OID.
//
typedef struct _NDIS_GUID
{
    GUID            Guid;
    union
    {
        NDIS_OID    Oid;
        NDIS_STATUS Status;
    };
    ULONG       Size;               //  Size of the data element. If the GUID
                                    //  represents an array then this is the
                                    //  size of an element in the array.
                                    //  This is -1 for strings.
    ULONG       Flags;
} NDIS_GUID, *PNDIS_GUID;

#define fNDIS_GUID_TO_OID                   0x00000001
#define fNDIS_GUID_TO_STATUS                0x00000002
#define fNDIS_GUID_ANSI_STRING              0x00000004
#define fNDIS_GUID_UNICODE_STRING           0x00000008
#define fNDIS_GUID_ARRAY                    0x00000010
#define fNDIS_GUID_ALLOW_READ               0x00000020
#define fNDIS_GUID_ALLOW_WRITE              0x00000040
#define fNDIS_GUID_METHOD                   0x00000080
#define fNDIS_GUID_NDIS_RESERVED            0x00000100 
#define fNDIS_GUID_SUPPORT_COMMON_HEADER    0x00000200

//
// Ndis Packet Filter Bits (OID_GEN_CURRENT_PACKET_FILTER).
//
#define NDIS_PACKET_TYPE_DIRECTED               0x00000001
#define NDIS_PACKET_TYPE_MULTICAST              0x00000002
#define NDIS_PACKET_TYPE_ALL_MULTICAST          0x00000004
#define NDIS_PACKET_TYPE_BROADCAST              0x00000008
#define NDIS_PACKET_TYPE_SOURCE_ROUTING         0x00000010
#define NDIS_PACKET_TYPE_PROMISCUOUS            0x00000020
#define NDIS_PACKET_TYPE_SMT                    0x00000040
#define NDIS_PACKET_TYPE_ALL_LOCAL              0x00000080
#define NDIS_PACKET_TYPE_GROUP                  0x00001000
#define NDIS_PACKET_TYPE_ALL_FUNCTIONAL         0x00002000
#define NDIS_PACKET_TYPE_FUNCTIONAL             0x00004000
#define NDIS_PACKET_TYPE_MAC_FRAME              0x00008000
#define NDIS_PACKET_TYPE_NO_LOCAL               0x00010000


//
// Ndis Token-Ring Ring Status Codes (OID_802_5_CURRENT_RING_STATUS).
//
#define NDIS_RING_SIGNAL_LOSS                   0x00008000
#define NDIS_RING_HARD_ERROR                    0x00004000
#define NDIS_RING_SOFT_ERROR                    0x00002000
#define NDIS_RING_TRANSMIT_BEACON               0x00001000
#define NDIS_RING_LOBE_WIRE_FAULT               0x00000800
#define NDIS_RING_AUTO_REMOVAL_ERROR            0x00000400
#define NDIS_RING_REMOVE_RECEIVED               0x00000200
#define NDIS_RING_COUNTER_OVERFLOW              0x00000100
#define NDIS_RING_SINGLE_STATION                0x00000080
#define NDIS_RING_RING_RECOVERY                 0x00000040


//
// Ndis protocol option bits (OID_GEN_PROTOCOL_OPTIONS).
//
#define NDIS_PROT_OPTION_ESTIMATED_LENGTH               0x00000001
#define NDIS_PROT_OPTION_NO_LOOPBACK                    0x00000002
#define NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT              0x00000004
#define NDIS_PROT_OPTION_SEND_RESTRICTED                0x00000008

//
// Ndis MAC option bits (OID_GEN_MAC_OPTIONS).
//
#define NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA             0x00000001
#define NDIS_MAC_OPTION_RECEIVE_SERIALIZED              0x00000002
#define NDIS_MAC_OPTION_TRANSFERS_NOT_PEND              0x00000004
#define NDIS_MAC_OPTION_NO_LOOPBACK                     0x00000008

//
// This flag has been deprecated. Deserialized drivers are
// full duplex drivers
//
#define NDIS_MAC_OPTION_FULL_DUPLEX                     0x00000010  // deprecated


#define NDIS_MAC_OPTION_EOTX_INDICATION                 0x00000020
#define NDIS_MAC_OPTION_8021P_PRIORITY                  0x00000040
#define NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE  0x00000080
#define NDIS_MAC_OPTION_RECEIVE_AT_DPC                  0x00000100
#define NDIS_MAC_OPTION_8021Q_VLAN                      0x00000200
#define NDIS_MAC_OPTION_RESERVED                        0x80000000

//
//  NDIS media capabilities bits (OID_GEN_MEDIA_CAPABILITIES).
//
#define NDIS_MEDIA_CAP_TRANSMIT                 0x00000001  // Supports sending data
#define NDIS_MEDIA_CAP_RECEIVE                  0x00000002  // Supports receiving data

//
//  NDIS MAC option bits for OID_GEN_CO_MAC_OPTIONS.
//
#define NDIS_CO_MAC_OPTION_DYNAMIC_LINK_SPEED   0x00000001

//
// The following is set on a per-packet basis as OOB data with NdisClassIrdaPacketInfo
// This is the per-packet info specified on a per-packet basis
//
typedef struct _NDIS_IRDA_PACKET_INFO
{
    ULONG                       ExtraBOFs;
    ULONG                       MinTurnAroundTime;
} NDIS_IRDA_PACKET_INFO, *PNDIS_IRDA_PACKET_INFO;



#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)

//
// The following macro is used to build a NET_LUID
//

#define NDIS_MAKE_NET_LUID(_pNetLuid, _IfType, _NetLuidIndex)       \
{                                                                   \
    (_pNetLuid)->Info.IfType = _IfType;                             \
    (_pNetLuid)->Info.NetLuidIndex = _NetLuidIndex;                 \
    (_pNetLuid)->Info.Reserved = 0;                                 \
}

#define NDIS_IF_MAX_STRING_SIZE IF_MAX_STRING_SIZE
typedef IF_COUNTED_STRING NDIS_IF_COUNTED_STRING, *PNDIS_IF_COUNTED_STRING;

#define NDIS_MAX_PHYS_ADDRESS_LENGTH IF_MAX_PHYS_ADDRESS_LENGTH
typedef IF_PHYSICAL_ADDRESS NDIS_IF_PHYSICAL_ADDRESS, *PNDIS_IF_PHYSICAL_ADDRESS;

//
// NDIS_MEDIA_CONNECT_STATE enum type is used in OID_GEN_MEDIA_CONNECT_STATUS_EX
//
typedef NET_IF_MEDIA_CONNECT_STATE NDIS_MEDIA_CONNECT_STATE, *PNDIS_MEDIA_CONNECT_STATE;

//
// NET_IF_MEDIA_DUPLEX_STATE enum type is used in OID_GEN_MEDIA_DUPLEX_STATE
//
typedef NET_IF_MEDIA_DUPLEX_STATE NDIS_MEDIA_DUPLEX_STATE, *PNDIS_MEDIA_DUPLEX_STATE;

typedef enum _NDIS_SUPPORTED_PAUSE_FUNCTIONS
{
    NdisPauseFunctionsUnsupported,
    NdisPauseFunctionsSendOnly,
    NdisPauseFunctionsReceiveOnly,
    NdisPauseFunctionsSendAndReceive,
    NdisPauseFunctionsUnknown
} NDIS_SUPPORTED_PAUSE_FUNCTIONS, *PNDIS_SUPPORTED_PAUSE_FUNCTIONS;

#define NDIS_LINK_STATE_XMIT_LINK_SPEED_AUTO_NEGOTIATED         0x00000001
#define NDIS_LINK_STATE_RCV_LINK_SPEED_AUTO_NEGOTIATED          0x00000002
#define NDIS_LINK_STATE_DUPLEX_AUTO_NEGOTIATED                  0x00000004
#define NDIS_LINK_STATE_PAUSE_FUNCTIONS_AUTO_NEGOTIATED         0x00000008

    

//
// structure used in NDIS_STATUS_LINK_STATE and OID_GEN_LINK_STATE
//

#define NDIS_LINK_STATE_REVISION_1      1

typedef struct _NDIS_LINK_STATE
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    NDIS_MEDIA_DUPLEX_STATE         MediaDuplexState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NDIS_SUPPORTED_PAUSE_FUNCTIONS  PauseFunctions;
    ULONG                           AutoNegotiationFlags;
} NDIS_LINK_STATE, *PNDIS_LINK_STATE;

#define NDIS_SIZEOF_LINK_STATE_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_LINK_STATE, AutoNegotiationFlags)

//
// the following structure is used in OID_GEN_LINK_PARAMETERS
//

#define NDIS_LINK_PARAMETERS_REVISION_1      1

typedef struct _NDIS_LINK_PARAMETERS
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_MEDIA_DUPLEX_STATE         MediaDuplexState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NDIS_SUPPORTED_PAUSE_FUNCTIONS  PauseFunctions;
    ULONG                           AutoNegotiationFlags;    
} NDIS_LINK_PARAMETERS, *PNDIS_LINK_PARAMETERS;

#define NDIS_SIZEOF_LINK_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_LINK_PARAMETERS, AutoNegotiationFlags)

//
// structure used in NDIS_STATUS_LINK_STATE and OID_GEN_LINK_STATE
//

#define NDIS_OPER_STATE_REVISION_1      1

typedef struct _NDIS_OPER_STATE
{
    NDIS_OBJECT_HEADER              Header;
    NET_IF_OPER_STATUS              OperationalStatus;
    ULONG                           OperationalStatusFlags;
} NDIS_OPER_STATE, *PNDIS_OPER_STATE;

#define NDIS_SIZEOF_OPER_STATE_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_OPER_STATE, OperationalStatusFlags)


//
// Structure used in OID_GEN_IP_OPER_STATUS.
//

typedef struct _NDIS_IP_OPER_STATUS 
{
    ULONG AddressFamily;
    NET_IF_OPER_STATUS OperationalStatus;
    ULONG OperationalStatusFlags;
} NDIS_IP_OPER_STATUS, *PNDIS_IP_OPER_STATUS;

//
// Don't change the value for this macro definition.
//
#define MAXIMUM_IP_OPER_STATUS_ADDRESS_FAMILIES_SUPPORTED 32

#define NDIS_IP_OPER_STATUS_INFO_REVISION_1 1

typedef struct _NDIS_IP_OPER_STATUS_INFO
{
    NDIS_OBJECT_HEADER Header;
    ULONG Flags;
    ULONG NumberofAddressFamiliesReturned;
    NDIS_IP_OPER_STATUS IpOperationalStatus[MAXIMUM_IP_OPER_STATUS_ADDRESS_FAMILIES_SUPPORTED];
} NDIS_IP_OPER_STATUS_INFO, *PNDIS_IP_OPER_STATUS_INFO;

#define NDIS_SIZEOF_IP_OPER_STATUS_INFO_REVISION_1    \
        FIELD_OFFSET(NDIS_IP_OPER_STATUS_INFO, IpOperationalStatus) + \
        MAXIMUM_IP_OPER_STATUS_ADDRESS_FAMILIES_SUPPORTED * sizeof(NDIS_IP_OPER_STATUS)

//
// structure used in NDIS_STATUS_IP_OPER_STATUS
//

#define NDIS_IP_OPER_STATE_REVISION_1    1

typedef struct _NDIS_IP_OPER_STATE
{
    NDIS_OBJECT_HEADER Header;
    ULONG Flags;    
    NDIS_IP_OPER_STATUS IpOperationalStatus;
} NDIS_IP_OPER_STATE, *PNDIS_IP_OPER_STATE;

#define NDIS_SIZEOF_IP_OPER_STATE_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_IP_OPER_STATE, IpOperationalStatus)

//
// These defines and structures are used with 
// OID_TCP_OFFLOAD_PARAMETERS
//

#define NDIS_OFFLOAD_PARAMETERS_NO_CHANGE                  0

//
// values used in IPv4Checksum, TCPIPv4Checksum, UDPIPv4Checksum
// TCPIPv6Checksum and UDPIPv6Checksum
//
#define NDIS_OFFLOAD_PARAMETERS_TX_RX_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_TX_ENABLED_RX_DISABLED     2
#define NDIS_OFFLOAD_PARAMETERS_RX_ENABLED_TX_DISABLED     3
#define NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED              4

//
// values used in LsoV1
//
#define NDIS_OFFLOAD_PARAMETERS_LSOV1_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_LSOV1_ENABLED              2

//
// values used in IPsecV1
//
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_AH_ENABLED           2
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_ESP_ENABLED          3
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_AH_AND_ESP_ENABLED   4

//
// values used in LsoV2
//
#define NDIS_OFFLOAD_PARAMETERS_LSOV2_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED              2

#if (NDIS_SUPPORT_NDIS61)
//
// values used in IPsecV2 and IPsecV2IPv4
//
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_AH_ENABLED           2
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_ESP_ENABLED          3
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_AH_AND_ESP_ENABLED   4
#endif // (NDIS_SUPPORT_NDIS61)


//
// values used in TcpConnectionIPv4 and TcpConnectionIPv6 fields
// of NDIS_OFFLOAD_PARAMETERS
//
#define NDIS_OFFLOAD_PARAMETERS_CONNECTION_OFFLOAD_DISABLED     1
#define NDIS_OFFLOAD_PARAMETERS_CONNECTION_OFFLOAD_ENABLED      2

//
// Used in OID_TCP_OFFLOAD_PARAMETERS for setting 
// the offload parameters of a NIC
//

#define NDIS_OFFLOAD_PARAMETERS_REVISION_1            1

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OFFLOAD_PARAMETERS_REVISION_2            2
#endif // (NDIS_SUPPORT_NDIS61)


typedef struct _NDIS_OFFLOAD_PARAMETERS
{
    NDIS_OBJECT_HEADER      Header;

    UCHAR                   IPv4Checksum;
    UCHAR                   TCPIPv4Checksum;
    UCHAR                   UDPIPv4Checksum;
    
    UCHAR                   TCPIPv6Checksum;
    UCHAR                   UDPIPv6Checksum;

    UCHAR                   LsoV1;
    UCHAR                   IPsecV1;
    
    UCHAR                   LsoV2IPv4;
    UCHAR                   LsoV2IPv6;

    UCHAR                   TcpConnectionIPv4;
    UCHAR                   TcpConnectionIPv6;
    
    ULONG                   Flags;

#if (NDIS_SUPPORT_NDIS61)
    UCHAR                   IPsecV2;
    UCHAR                   IPsecV2IPv4;


            UCHAR           Reserved1;
            UCHAR           Reserved2;


#endif // (NDIS_SUPPORT_NDIS61)
} NDIS_OFFLOAD_PARAMETERS, *PNDIS_OFFLOAD_PARAMETERS;

#define NDIS_SIZEOF_OFFLOAD_PARAMETERS_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD_PARAMETERS, Flags)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_OFFLOAD_PARAMETERS_REVISION_2 RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD_PARAMETERS, IPsecV2IPv4)
#endif // (NDIS_SUPPORT_NDIS61)


#define NDIS_OFFLOAD_NOT_SUPPORTED             0
#define NDIS_OFFLOAD_SUPPORTED                 1

#define NDIS_OFFLOAD_SET_NO_CHANGE             0
#define NDIS_OFFLOAD_SET_ON                    1
#define NDIS_OFFLOAD_SET_OFF                   2

//
// Encapsulation types that are used during offload in query and set
//
#define NDIS_ENCAPSULATION_NOT_SUPPORTED                0x00000000                         
#define NDIS_ENCAPSULATION_NULL                         0x00000001
#define NDIS_ENCAPSULATION_IEEE_802_3                   0x00000002
#define NDIS_ENCAPSULATION_IEEE_802_3_P_AND_Q           0x00000004
#define NDIS_ENCAPSULATION_IEEE_802_3_P_AND_Q_IN_OOB    0x00000008
#define NDIS_ENCAPSULATION_IEEE_LLC_SNAP_ROUTED         0x00000010

#pragma warning(push)
#pragma warning(disable:4214) //nonstandard extension used : bit field types other than int

//
// Describes the large send offload version 1 capabilities
// or configuration of the NIC. Used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_TCP_LARGE_SEND_OFFLOAD_V1
{

    struct
    {
        ULONG     Encapsulation;
        ULONG     MaxOffLoadSize;
        ULONG     MinSegmentCount;
        ULONG     TcpOptions:2;
        ULONG     IpOptions:2;
    } IPv4;
   
} NDIS_TCP_LARGE_SEND_OFFLOAD_V1, *PNDIS_TCP_LARGE_SEND_OFFLOAD_V1;


//
// Describes the checksum task offload capabilities or configuration 
// of the NIC. used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_TCP_IP_CHECKSUM_OFFLOAD
{

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;
        ULONG       IpChecksum:2;
    } IPv4Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;
        ULONG       IpChecksum:2;
    } IPv4Receive;


    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;

    } IPv6Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;

    } IPv6Receive;

} NDIS_TCP_IP_CHECKSUM_OFFLOAD, *PNDIS_TCP_IP_CHECKSUM_OFFLOAD;


//
// Describes the IPsec task offload version 1 capabilities 
// or configuration of the NIC. Used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_IPSEC_OFFLOAD_V1
{
    struct
    {
        ULONG   Encapsulation;
        ULONG   AhEspCombined;
        ULONG   TransportTunnelCombined;
        ULONG   IPv4Options;
        ULONG   Flags;
    } Supported;

    struct
    {
        ULONG   Md5:2;
        ULONG   Sha_1:2;
        ULONG   Transport:2;
        ULONG   Tunnel:2;
        ULONG   Send:2;
        ULONG   Receive:2;
    } IPv4AH;

    struct
    {
        ULONG   Des:2;
        ULONG   Reserved:2;
        ULONG   TripleDes:2;
        ULONG   NullEsp:2;
        ULONG   Transport:2;
        ULONG   Tunnel:2;
        ULONG   Send:2;
        ULONG   Receive:2;
    } IPv4ESP;

} NDIS_IPSEC_OFFLOAD_V1, *PNDIS_IPSEC_OFFLOAD_V1;

//
// Describes the large send offload version 2 capabilities
// or configuration of the NIC. Used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_TCP_LARGE_SEND_OFFLOAD_V2
{
    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
    }IPv4;

    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
         ULONG     IpExtensionHeadersSupported:2;
         ULONG     TcpOptionsSupported:2;
    }IPv6;

} NDIS_TCP_LARGE_SEND_OFFLOAD_V2, *PNDIS_TCP_LARGE_SEND_OFFLOAD_V2;

#if (NDIS_SUPPORT_NDIS61)
//
//  Structures for IPSec Task Offload V2.
//

//
// IPsec Algorithms for Authentication used in AuthenticationAlgorithms field
// of NDIS_IPSEC_OFFLOAD_V2 structure
//
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_MD5                      0x00000001
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_SHA_1                    0x00000002
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_SHA_256                  0x00000004
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_AES_GCM_128              0x00000008
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_AES_GCM_192              0x00000010
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_AES_GCM_256              0x00000020

//
// IPsec Algorithms for Encryption used in EncryptionAlgorithms field of
// NDIS_IPSEC_OFFLOAD_V2 structure
//
#define IPSEC_OFFLOAD_V2_ENCRYPTION_NONE                          0x00000001
#define IPSEC_OFFLOAD_V2_ENCRYPTION_DES_CBC                       0x00000002
#define IPSEC_OFFLOAD_V2_ENCRYPTION_3_DES_CBC                     0x00000004
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_GCM_128                   0x00000008
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_GCM_192                   0x00000010
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_GCM_256                   0x00000020
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_CBC_128                   0x00000040
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_CBC_192                   0x00000080
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_CBC_256                   0x00000100

//
// IPsec offload V2 capabilities used in  NDIS_OFFLOAD
//
typedef struct _NDIS_IPSEC_OFFLOAD_V2
{
    ULONG       Encapsulation;      // MAC encap types supported
    BOOLEAN     IPv6Supported;      // IPv6 Supported
    BOOLEAN     IPv4Options;                           // Supports offload of packets with IPv4 options
    BOOLEAN     IPv6NonIPsecExtensionHeaders;          // Supports offload of packets with non IPsec Extension headers
    BOOLEAN     Ah;
    BOOLEAN     Esp;
    BOOLEAN     AhEspCombined;
    BOOLEAN     Transport;
    BOOLEAN     Tunnel;
    BOOLEAN     TransportTunnelCombined;
    BOOLEAN     LsoSupported;
    BOOLEAN     ExtendedSequenceNumbers;
    ULONG       UdpEsp;
    ULONG       AuthenticationAlgorithms;     // Bit Mask of Authentication Algorithms
    ULONG       EncryptionAlgorithms;         // Bit Mask of Encryption Algorithms
    ULONG       SaOffloadCapacity;            // Number of SAs that can be offloaded
} NDIS_IPSEC_OFFLOAD_V2, *PNDIS_IPSEC_OFFLOAD_V2;

#endif // (NDIS_SUPPORT_NDIS61)

#pragma warning(pop)


//
// flags used in Flags field of NDIS_OFFLOAD structure
//
#define NDIS_OFFLOAD_FLAGS_GROUP_CHECKSUM_CAPABILITIES  0x00000001

//
// Describes TCP/IP task offload capabilities or configuration 
// of the NIC. Used in OID_TCP_OFFLOAD_CURRENT_CONFIG
// and OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES
//
#define NDIS_OFFLOAD_REVISION_1    1
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OFFLOAD_REVISION_2    2
#endif // (NDIS_SUPPORT_NDIS61)


typedef struct _NDIS_OFFLOAD
{
    NDIS_OBJECT_HEADER                  Header;

    //
    // Checksum Offload information
    //
    NDIS_TCP_IP_CHECKSUM_OFFLOAD        Checksum;

    //
    // Large Send Offload information
    //
    NDIS_TCP_LARGE_SEND_OFFLOAD_V1      LsoV1;

    //
    // IPsec Offload Information
    //
    NDIS_IPSEC_OFFLOAD_V1               IPsecV1;
    //
    // Large Send Offload version 2Information
    //
    NDIS_TCP_LARGE_SEND_OFFLOAD_V2      LsoV2;

    ULONG                               Flags;

#if (NDIS_SUPPORT_NDIS61)
    //
    //IPsec offload V2
    //
    NDIS_IPSEC_OFFLOAD_V2               IPsecV2;
#endif // (NDIS_SUPPORT_NDIS61)


}NDIS_OFFLOAD, *PNDIS_OFFLOAD;

#define NDIS_SIZEOF_NDIS_OFFLOAD_REVISION_1   RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD, Flags)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_NDIS_OFFLOAD_REVISION_2   RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD, IPsecV2) 
#endif // (NDIS_SUPPORT_NDIS61)


//
// The following data structures are used with offload related WMI
// guids. NDIS will trnaslate these data structures to those used 
// in OID and status indications
//
typedef struct _NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1
{

    struct
    {
        ULONG     Encapsulation;
        ULONG     MaxOffLoadSize;
        ULONG     MinSegmentCount;
        ULONG     TcpOptions;
        ULONG     IpOptions;
    } IPv4;
   
} NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1, *PNDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1;

typedef struct _NDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD
{

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;
        ULONG       IpChecksum;
    } IPv4Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;
        ULONG       IpChecksum;
    } IPv4Receive;


    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;

    } IPv6Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;

    } IPv6Receive;

} NDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD, *PNDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD;

typedef struct _NDIS_WMI_IPSEC_OFFLOAD_V1
{
    struct
    {
        ULONG   Encapsulation;
        ULONG   AhEspCombined;
        ULONG   TransportTunnelCombined;
        ULONG   IPv4Options;
        ULONG   Flags;
    } Supported;

    struct
    {
        ULONG   Md5;
        ULONG   Sha_1;
        ULONG   Transport;
        ULONG   Tunnel;
        ULONG   Send;
        ULONG   Receive;
    } IPv4AH;

    struct
    {
        ULONG   Des;
        ULONG   Reserved;
        ULONG   TripleDes;
        ULONG   NullEsp;
        ULONG   Transport;
        ULONG   Tunnel;
        ULONG   Send;
        ULONG   Receive;
    } IPv4ESP;

} NDIS_WMI_IPSEC_OFFLOAD_V1, *PNDIS_WMI_IPSEC_OFFLOAD_V1;

typedef struct _NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2
{
    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
    }IPv4;

    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
         ULONG     IpExtensionHeadersSupported;
         ULONG     TcpOptionsSupported;
    }IPv6;

} NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2, *PNDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2;


typedef struct _NDIS_WMI_OFFLOAD
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_OFFLOAD;
    // Header.Size = sizeof(NDIS_OFFLOAD);
    // Header.Revision  = NDIS_OFFLOAD_REVISION_1;
    //
    NDIS_OBJECT_HEADER                  Header;

    //
    // Checksum Offload information
    //
    NDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD    Checksum;

    //
    // Large Send Offload information
    //
    NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1   LsoV1;

    //
    // IPsec Offload Information
    //
    NDIS_WMI_IPSEC_OFFLOAD_V1           IPsecV1;
    //
    // Large Send Offload version 2 Information
    //
    NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2  LsoV2;

    ULONG                               Flags;

#if (NDIS_SUPPORT_NDIS61)
    //
    // IPsec offload version 2 information
    //
    NDIS_IPSEC_OFFLOAD_V2               IPsecV2;
#endif // (NDIS_SUPPORT_NDIS61)


}NDIS_WMI_OFFLOAD, *PNDIS_WMI_OFFLOAD;

#define NDIS_SIZEOF_NDIS_WMI_OFFLOAD_REVISION_1   RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_OFFLOAD, Flags) 
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_NDIS_WMI_OFFLOAD_REVISION_2   RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_OFFLOAD, IPsecV2) 
#endif // (NDIS_SUPPORT_NDIS61)


#pragma warning(push)
#pragma warning(disable:4214) //nonstandard extension used : bit field types other than int

//
// Describes TCP connection offload capabilities or configuration  
// of the NIC. Used in OID_TCP_CONNECTION_OFFLOAD_CURRENT_CONFIG,
// OID_TCP_CONNECTION_OFFLOAD_HARDWARE_CAPABILITIES and 
// NDIS_STATUS_OFFLOAD_RESUME
//
#define NDIS_TCP_CONNECTION_OFFLOAD_REVISION_1              1
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_TCP_CONNECTION_OFFLOAD_REVISION_2              2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_TCP_CONNECTION_OFFLOAD
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;         
    // Header.Revision = NDIS_TCP_CONNECTION_OFFLOAD_REVISION_1;
    // Header.Size = sizeof(NDIS_TCP_CONNECTION_OFFLOAD);
    //
    NDIS_OBJECT_HEADER Header;
    ULONG Encapsulation;
    ULONG SupportIPv4:2;
    ULONG SupportIPv6:2;
    ULONG SupportIPv6ExtensionHeaders:2;
    ULONG SupportSack:2;
#if (NDIS_SUPPORT_NDIS61)
    ULONG CongestionAlgorithm:4;
#endif // (NDIS_SUPPORT_NDIS61)
    ULONG TcpConnectionOffloadCapacity;
    ULONG Flags;
} NDIS_TCP_CONNECTION_OFFLOAD, *PNDIS_TCP_CONNECTION_OFFLOAD;

#define NDIS_SIZEOF_TCP_CONNECTION_OFFLOAD_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_TCP_CONNECTION_OFFLOAD, Flags)
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_TCP_CONNECTION_OFFLOAD_REVISION_2 RTL_SIZEOF_THROUGH_FIELD(NDIS_TCP_CONNECTION_OFFLOAD, Flags)
#endif // (NDIS_SUPPORT_NDIS61)

#pragma warning(pop)

typedef struct _NDIS_WMI_TCP_CONNECTION_OFFLOAD
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;         
    // Header.Revision = NDIS_TCP_CONNECTION_OFFLOAD_REVISION_1;
    // Header.Size = sizeof(NDIS_TCP_CONNECTION_OFFLOAD);
    //
    NDIS_OBJECT_HEADER Header;
    ULONG Encapsulation;
    ULONG SupportIPv4;
    ULONG SupportIPv6;
    ULONG SupportIPv6ExtensionHeaders;
    ULONG SupportSack;
    ULONG TcpConnectionOffloadCapacity;
    ULONG Flags;
} NDIS_WMI_TCP_CONNECTION_OFFLOAD, *PNDIS_WMI_TCP_CONNECTION_OFFLOAD;

#define NDIS_SIZEOF_WMI_TCP_CONNECTION_OFFLOAD_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_TCP_CONNECTION_OFFLOAD, Flags)

#define NDIS_MAXIMUM_PORTS 0x1000000

//
// definitions for NDIS PORTs
//

typedef ULONG NDIS_PORT_NUMBER, *PNDIS_PORT_NUMBER;

//
// port related data structures
//
#define NDIS_DEFAULT_PORT_NUMBER ((NDIS_PORT_NUMBER)0)
    
//
// NDIS_PORT_TYPE defines the application of a port 
//
typedef enum _NDIS_PORT_TYPE
{
    NdisPortTypeUndefined,
    NdisPortTypeBridge,
    NdisPortTypeRasConnection,
    NdisPortType8021xSupplicant,
    NdisPortTypeMax,
}NDIS_PORT_TYPE, *PNDIS_PORT_TYPE;
    
    
//
// NDIS_PORT_AUTHENTICATION_STATE defines the authentication state of a port
// on a particular data path
//
typedef enum _NDIS_PORT_AUTHORIZATION_STATE
{
    NdisPortAuthorizationUnknown,
    NdisPortAuthorized,
    NdisPortUnauthorized,
    NdisPortReauthorizing
} NDIS_PORT_AUTHORIZATION_STATE, *PNDIS_PORT_AUTHORIZATION_STATE;


//
// NDIS_PORT_CONTROLL_STATE specifies if a port is "controlled" 
// i.e. if it needs authentication, on a particular data path
//

typedef enum _NDIS_PORT_CONTROL_STATE
{
    NdisPortControlStateUnknown,
    NdisPortControlStateControlled,
    NdisPortControlStateUncontrolled
} NDIS_PORT_CONTROLL_STATE, *PNDIS_PORT_CONTROLL_STATE;
    
    
    
//
// NDIS_PORT_STATE is used in port state change status indications
// as well as OID_GEN_PORT_STATE query OID
//

#define NDIS_PORT_STATE_REVISION_1     1
typedef struct _NDIS_PORT_STATE
{
    NDIS_OBJECT_HEADER              Header;    
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NET_IF_DIRECTION_TYPE           Direction;
    NDIS_PORT_CONTROLL_STATE        SendControlState;
    NDIS_PORT_CONTROLL_STATE        RcvControlState;
    NDIS_PORT_AUTHORIZATION_STATE   SendAuthorizationState;
    NDIS_PORT_AUTHORIZATION_STATE   RcvAuthorizationState;
    ULONG                           Flags;
}NDIS_PORT_STATE, *PNDIS_PORT_STATE;

#define NDIS_SIZEOF_PORT_STATE_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_STATE, Flags)

//
// NDIS_PORT_PARAMETERS is used in OID_GEN_PORT_PARAMETERS set OID
//
#define NDIS_PORT_AUTHENTICATION_PARAMETERS_REVISION_1     1

typedef struct _NDIS_PORT_AUTHENTICATION_PARAMETERS
{
    NDIS_OBJECT_HEADER              Header;    
    NDIS_PORT_CONTROLL_STATE        SendControlState;
    NDIS_PORT_CONTROLL_STATE        RcvControlState;
    NDIS_PORT_AUTHORIZATION_STATE   SendAuthorizationState;
    NDIS_PORT_AUTHORIZATION_STATE   RcvAuthorizationState;
}NDIS_PORT_AUTHENTICATION_PARAMETERS, *PNDIS_PORT_AUTHENTICATION_PARAMETERS;

#define NDIS_SIZEOF_PORT_AUTHENTICATION_PARAMETERS_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_AUTHENTICATION_PARAMETERS, RcvAuthorizationState)


//
// Flags used in NDIS_PORT_CHARACTERISTICS Flags field.
//
#define  NDIS_PORT_CHAR_USE_DEFAULT_AUTH_SETTINGS             0x00000001

//
// NDIS_PORT_CHARACTERISTICS is used in port allocation and 
// arrival notification as part of NDIS_PORT structure
//
#define NDIS_PORT_CHARACTERISTICS_REVISION_1     1
typedef struct _NDIS_PORT_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_PORT_NUMBER                PortNumber;
    ULONG                           Flags;
    NDIS_PORT_TYPE                  Type;
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NET_IF_DIRECTION_TYPE           Direction;
    NDIS_PORT_CONTROLL_STATE        SendControlState;
    NDIS_PORT_CONTROLL_STATE        RcvControlState;
    NDIS_PORT_AUTHORIZATION_STATE   SendAuthorizationState;
    NDIS_PORT_AUTHORIZATION_STATE   RcvAuthorizationState;
} NDIS_PORT_CHARACTERISTICS, *PNDIS_PORT_CHARACTERISTICS;
   
#define NDIS_SIZEOF_PORT_CHARACTERISTICS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_CHARACTERISTICS, RcvAuthorizationState)
    
//
// NDIS_PORT structure is used in port activation 
// PnP notification
//
typedef struct _NDIS_PORT NDIS_PORT, *PNDIS_PORT;

struct _NDIS_PORT
{
    PNDIS_PORT                  Next;
    PVOID                       NdisReserved;
    PVOID                       MiniportReserved;
    PVOID                       ProtocolReserved;
    NDIS_PORT_CHARACTERISTICS   PortCharacteristics;
};


#define NDIS_PORT_ARRAY_REVISION_1                1
//
// NDIS_PORT_ARRAY is used in enumerating the ports
//
typedef struct _NDIS_PORT_ARRAY
{
    NDIS_OBJECT_HEADER              Header;
    ULONG                           NumberOfPorts;
    ULONG                           OffsetFirstPort;
    ULONG                           ElementSize;
    NDIS_PORT_CHARACTERISTICS       Ports[1];
}NDIS_PORT_ARRAY, *PNDIS_PORT_ARRAY;

#define NDIS_SIZEOF_PORT_ARRAY_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_ARRAY, Ports)

typedef enum _NDIS_NETWORK_CHANGE_TYPE
{
    NdisPossibleNetworkChange = 1,
    NdisDefinitelyNetworkChange,
    NdisNetworkChangeFromMediaConnect,
    NdisNetworkChangeMax
} NDIS_NETWORK_CHANGE_TYPE, *PNDIS_NETWORK_CHANGE_TYPE;


#define  NDIS_WMI_DEFAULT_METHOD_ID             1

#define  NDIS_WMI_OBJECT_TYPE_SET               0x01
#define  NDIS_WMI_OBJECT_TYPE_METHOD            0x02
#define  NDIS_WMI_OBJECT_TYPE_EVENT             0x03
#define  NDIS_WMI_OBJECT_TYPE_ENUM_ADAPTER      0x04
#define  NDIS_WMI_OBJECT_TYPE_OUTPUT_INFO       0x05

#define NDIS_WMI_METHOD_HEADER_REVISION_1       1 

typedef struct _NDIS_WMI_METHOD_HEADER
{
    NDIS_OBJECT_HEADER   Header;
    NDIS_PORT_NUMBER     PortNumber;
    NET_LUID             NetLuid;
    ULONG64              RequestId;
    ULONG                Timeout;
    UCHAR                Padding[4];
} NDIS_WMI_METHOD_HEADER, *PNDIS_WMI_METHOD_HEADER;

#define NDIS_SIZEOF_WMI_METHOD_HEADER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_METHOD_HEADER, Padding)
       
#define NDIS_WMI_SET_HEADER_REVISION_1         1

typedef struct _NDIS_WMI_SET_HEADER
{
    NDIS_OBJECT_HEADER   Header;
    NDIS_PORT_NUMBER     PortNumber;
    NET_LUID             NetLuid;
    ULONG64              RequestId;
    ULONG                Timeout;
    UCHAR                Padding[4];
} NDIS_WMI_SET_HEADER, *PNDIS_WMI_SET_HEADER;

#define NDIS_SIZEOF_WMI_SET_HEADER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_SET_HEADER, Padding)

#define NDIS_WMI_EVENT_HEADER_REVISION_1      1

typedef struct _NDIS_WMI_EVENT_HEADER
{
    NDIS_OBJECT_HEADER   Header;
    NET_IFINDEX          IfIndex;
    NET_LUID             NetLuid;
    ULONG64              RequestId;    
    NDIS_PORT_NUMBER     PortNumber;
    ULONG                DeviceNameLength;
    ULONG                DeviceNameOffset;
    UCHAR                Padding[4];
} NDIS_WMI_EVENT_HEADER, *PNDIS_WMI_EVENT_HEADER;

#define NDIS_SIZEOF_WMI_EVENT_HEADER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_EVENT_HEADER, Padding)

#define NDIS_WMI_ENUM_ADAPTER_REVISION_1       1

typedef struct _NDIS_WMI_ENUM_ADAPTER
{
    NDIS_OBJECT_HEADER   Header;
    NET_IFINDEX          IfIndex;
    NET_LUID             NetLuid;
    USHORT               DeviceNameLength;
    CHAR                 DeviceName[1];
}NDIS_WMI_ENUM_ADAPTER, *PNDIS_WMI_ENUM_ADAPTER;

#define NDIS_SIZEOF_WMI_ENUM_ADAPTER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_ENUM_ADAPTER, DeviceName)
        
//
// Flags used in standardized keyword *NdisDeviceType
//
#define NDIS_DEVICE_TYPE_ENDPOINT           0x00000001


#if (NDIS_SUPPORT_NDIS61)

//
// Structure and defines for 
// OID_GEN_HD_SPLIT_PARAMETERS
//
#define NDIS_HD_SPLIT_PARAMETERS_REVISION_1      1

typedef struct _NDIS_HD_SPLIT_PARAMETERS
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    // Header.Revision = NDIS_HD_SPLIT_PARAMETERS_REVISION_1;
    // Header.Size = sizeof(NDIS_HD_SPLIT_PARAMETERS);
    // 
    NDIS_OBJECT_HEADER      Header;
    ULONG                   HDSplitCombineFlags;
}NDIS_HD_SPLIT_PARAMETERS, *PNDIS_HD_SPLIT_PARAMETERS;

#define NDIS_SIZEOF_HD_SPLIT_PARAMETERS_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_HD_SPLIT_PARAMETERS, HDSplitCombineFlags)

//
// Flags used in NDIS_HD_SPLIT_PARAMETERS->HDSplitCombineFlags 
// and NDIS_HD_SPLIT_CURRENT_CONFIG->HDSplitCombineFlags
//
#define NDIS_HD_SPLIT_COMBINE_ALL_HEADERS          0x00000001

//
// Structure and defines for 
// OID_GEN_HD_SPLIT_CURRENT_CONFIG
//
#define NDIS_HD_SPLIT_CURRENT_CONFIG_REVISION_1      1

typedef struct _NDIS_HD_SPLIT_CURRENT_CONFIG
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    // Header.Revision = NDIS_HD_SPLIT_CURRENT_CONFIG_REVISION_1;
    // Header.Size = sizeof(NDIS_HD_SPLIT_CURRENT_CONFIG);
    // 
    NDIS_OBJECT_HEADER          Header;    
    ULONG                       HardwareCapabilities;
    ULONG                       CurrentCapabilities;
    ULONG                       HDSplitFlags;
    ULONG                       HDSplitCombineFlags;
    ULONG                       BackfillSize;
    ULONG                       MaxHeaderSize;
} NDIS_HD_SPLIT_CURRENT_CONFIG, *PNDIS_HD_SPLIT_CURRENT_CONFIG;

#define NDIS_SIZEOF_HD_SPLIT_CURRENT_CONFIG_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_HD_SPLIT_CURRENT_CONFIG, MaxHeaderSize)

//
// Flags used in NDIS_HD_SPLIT_ATTRIBUTES->HardwareCapabilities
// and NDIS_HD_SPLIT_ATTRIBUTES->CurrentCapabilities. They are also
// used in NDIS_HD_SPLIT_CURRENT_CONFIG->HardwareCapabilities
// and NDIS_HD_SPLIT_CURRENT_CONFIG->CurrentCapabilities. 
//
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_HEADER_DATA_SPLIT         0x00000001
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_IPV4_OPTIONS              0x00000002
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_IPV6_EXTENSION_HEADERS    0x00000004
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_TCP_OPTIONS               0x00000008

//
// Flags used in NDIS_HD_SPLIT_ATTRIBUTES->HDSplitFlags and
// NDIS_HD_SPLIT_CURRENT_CONFIG->HDSplitFlags
//
#define NDIS_HD_SPLIT_ENABLE_HEADER_DATA_SPLIT     0x00000001

#endif // (NDIS_SUPPORT_NDIS61)

#define NDIS_WMI_OUTPUT_INFO_REVISION_1    1;

typedef struct NDIS_WMI_OUTPUT_INFO
{
    NDIS_OBJECT_HEADER   Header;
    ULONG                Flags;
    UCHAR                SupportedRevision;
    ULONG                DataOffset;
    
} NDIS_WMI_OUTPUT_INFO, *PNDIS_WMI_OUTPUT_INFO;

#define NDIS_SIZEOF_WMI_OUTPUT_INFO_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_OUTPUT_INFO, DataOffset)


#if (NDIS_SUPPORT_NDIS620)

//
// NDIS 6.20 power management
//

//
// flags used in SupportedWoLPatterns field of NDIS_PM_CAPABILITIES
// to advertise WOL pattern capabilities
// 
#define NDIS_PM_WOL_BITMAP_PATTERN_SUPPORTED                    0x00000001
#define NDIS_PM_WOL_MAGIC_PACKET_SUPPORTED                      0x00000002
#define NDIS_PM_WOL_IPV4_TCP_SYN_SUPPORTED                      0x00000004
#define NDIS_PM_WOL_IPV6_TCP_SYN_SUPPORTED                      0x00000008
#define NDIS_PM_WOL_IPV4_DEST_ADDR_WILDCARD_SUPPORTED           0x00000200
#define NDIS_PM_WOL_IPV6_DEST_ADDR_WILDCARD_SUPPORTED           0x00000800
#define NDIS_PM_WOL_EAPOL_REQUEST_ID_MESSAGE_SUPPORTED          0x00010000

// 
// flags used in EnabledWoLPacketPatterns field of NDIS_PM_PARAMETERS
// to advertise WOL pattern capabilities
// 
#define NDIS_PM_WOL_BITMAP_PATTERN_ENABLED                      0x00000001
#define NDIS_PM_WOL_MAGIC_PACKET_ENABLED                        0x00000002
#define NDIS_PM_WOL_IPV4_TCP_SYN_ENABLED                        0x00000004
#define NDIS_PM_WOL_IPV6_TCP_SYN_ENABLED                        0x00000008
#define NDIS_PM_WOL_IPV4_DEST_ADDR_WILDCARD_ENABLED             0x00000200
#define NDIS_PM_WOL_IPV6_DEST_ADDR_WILDCARD_ENABLED             0x00000800
#define NDIS_PM_WOL_EAPOL_REQUEST_ID_MESSAGE_ENABLED            0x00010000

//
// Values used in Priority field of NDIS_PM_WOL_PATTERN
//
#define NDIS_PM_WOL_PRIORITY_LOWEST                             0xFFFFFFFF
#define NDIS_PM_WOL_PRIORITY_NORMAL                             0x10000000
#define NDIS_PM_WOL_PRIORITY_HIGHEST                            0x00000001

//
// flags used in SupportedProtocolOffloads field of NDIS_PM_CAPABILITIES
// to advertise protocol offload capabilities
//
#define NDIS_PM_PROTOCOL_OFFLOAD_ARP_SUPPORTED                    0x00000001
#define NDIS_PM_PROTOCOL_OFFLOAD_NS_SUPPORTED                     0x00000002
#define NDIS_PM_PROTOCOL_OFFLOAD_80211_RSN_REKEY_SUPPORTED        0x00000080

//
// flags used in EnabledProtocolOffloads field of NDIS_PM_PARAMETERS
// to advertise protocol offload capabilities
//
#define NDIS_PM_PROTOCOL_OFFLOAD_ARP_ENABLED                      0x00000001
#define NDIS_PM_PROTOCOL_OFFLOAD_NS_ENABLED                       0x00000002
#define NDIS_PM_PROTOCOL_OFFLOAD_80211_RSN_REKEY_ENABLED          0x00000080

//
// Values used in Priority field of NDIS_PM_PROTOCOL_OFFLOAD
//
#define NDIS_PM_PROTOCOL_OFFLOAD_PRIORITY_LOWEST                  0xFFFFFFFF
#define NDIS_PM_PROTOCOL_OFFLOAD_PRIORITY_NORMAL                  0x10000000
#define NDIS_PM_PROTOCOL_OFFLOAD_PRIORITY_HIGHEST                 0x00000001


//
// Values used in WakeUpFlags field of NDIS_PM_PARAMETERS
//
#define NDIS_PM_WAKE_ON_LINK_CHANGE_ENABLED                       0x00000001

//
// enum type for wake on lan patterns based on packet type
// used in WoLPacketType field of NDIS_PM_WOL_PATTERN structure
//
typedef enum _NDIS_PM_WOL_PACKET
{
    NdisPMWoLPacketUnspecified,
    NdisPMWoLPacketBitmapPattern,
    NdisPMWoLPacketMagicPacket,
    NdisPMWoLPacketIPv4TcpSyn,
    NdisPMWoLPacketIPv6TcpSyn,    
    NdisPMWoLPacketEapolRequestIdMessage,
    NdisPMWoLPacketMaximum 
}NDIS_PM_WOL_PACKET, *PNDIS_PM_WOL_PACKET;

//
// enum types for offloaded protocols used in ProtocolOffloadType
// field of NDIS_PM_PROTOCOL_OFFLOAD structure
//  
typedef enum _NDIS_PM_PROTOCOL_OFFLOAD_TYPE
{
    NdisPMProtocolOffloadIdUnspecified,
    NdisPMProtocolOffloadIdIPv4ARP,
    NdisPMProtocolOffloadIdIPv6NS,
    NdisPMProtocolOffload80211RSNRekey,
    NdisPMProtocolOffloadIdMaximum
}NDIS_PM_PROTOCOL_OFFLOAD_TYPE, *PNDIS_PM_PROTOCOL_OFFLOAD_TYPE;

//
// Limited size string used in NSID power management structures 
//
#define NDIS_PM_MAX_STRING_SIZE 64

typedef struct _NDIS_PM_COUNTED_STRING
{
    USHORT      Length; // in -Bytes-
    WCHAR       String[NDIS_PM_MAX_STRING_SIZE + 1];
} NDIS_PM_COUNTED_STRING, *PNDIS_PM_COUNTED_STRING;


//
// NDIS_PM_CAPABILITIES structure is used in PowerManagementCapabilitiesEx field of 
// NDIS_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES and NDIS_BIND_PARAMETERS
//
#define NDIS_PM_CAPABILITIES_REVISION_1              1

typedef struct _NDIS_PM_CAPABILITIES
{
    NDIS_OBJECT_HEADER      Header;
    ULONG                   Flags;
    ULONG                   SupportedWoLPacketPatterns;
    ULONG                   NumTotalWoLPatterns;
    ULONG                   MaxWoLPatternSize;              // maximum bytes that can be compared against a pattern
    ULONG                   MaxWoLPatternOffset;            // strting from MAC header, how many bytes in the packet can be examined
    ULONG                   MaxWoLPacketSaveBuffer;         // how many bytes of WOL packet can be saved to a buffer and indicated up
    ULONG                   SupportedProtocolOffloads;
    ULONG                   NumArpOffloadIPv4Addresses;
    ULONG                   NumNSOffloadIPv6Addresses;
    NDIS_DEVICE_POWER_STATE MinMagicPacketWakeUp;
    NDIS_DEVICE_POWER_STATE MinPatternWakeUp;
    NDIS_DEVICE_POWER_STATE MinLinkChangeWakeUp;
}NDIS_PM_CAPABILITIES, *PNDIS_PM_CAPABILITIES;

#define NDIS_SIZEOF_NDIS_PM_CAPABILITIES_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_PM_CAPABILITIES, MinLinkChangeWakeUp)


//
// NDIS_PM_PARAMETERS structure is used in OID_PM_PARAMETERS for quering and 
// updating currently enabled power management hardware capabilities.
//
#define NDIS_PM_PARAMETERS_REVISION_1              1

typedef struct _NDIS_PM_PARAMETERS
{
    NDIS_OBJECT_HEADER      Header;
    ULONG                   EnabledWoLPacketPatterns; // NDIS_PM_WOL_XXX flags
    ULONG                   EnabledProtocolOffloads;  // NDIS_PM_PROTOCOL_OFFLOAD_XXX flags    
    ULONG                   WakeUpFlags;              // NDIS_PM_WAKE_XXX flags
    
} NDIS_PM_PARAMETERS, *PNDIS_PM_PARAMETERS;

#define NDIS_SIZEOF_NDIS_PM_PARAMETERS_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_PM_PARAMETERS, WakeUpFlags)


//        
// Used in _EAPOL_REQUEST_ID_MESSAGE_WOL_PACKET_PARAMETERS
// When the following flag is set, the packet must be encrypted.
//
#define EAPOL_REQUEST_ID_WOL_FLAG_MUST_ENCRYPT		0x00000001

//
// Pattern IDs above this number are treated as pre-assigned 
//
#define NDIS_PM_MAX_PATTERN_ID  0x0000FFFF

//
// This value is used in the Flags field of the NDIS_PM_WOL_PATTERN structure 
// It indicates that the a pre-assigned ID is used 
//
#define NDIS_PM_PRIVATE_PATTERN_ID  0x00000001


//
// structure used in OID_PM_ADD_WOL_PATTERN and OID_PM_WOL_PATTERN_LIST
//
#define NDIS_PM_WOL_PATTERN_REVISION_1              1


typedef struct _NDIS_PM_WOL_PATTERN
{
    NDIS_OBJECT_HEADER          Header;
    ULONG                       Flags;
    ULONG                       Priority;
    NDIS_PM_WOL_PACKET          WoLPacketType;
    NDIS_PM_COUNTED_STRING      FriendlyName;
    ULONG                       PatternId;   // Pattern ID set by NDIS 
    ULONG                       NextWoLPatternOffset;
    
    union _WOL_PATTERN
    {   
        //
        // IPv4 TCP SYN information
        //
        struct _IPV4_TCP_SYN_WOL_PACKET_PARAMETERS
        {
            ULONG   Flags;                  
            UCHAR   IPv4SourceAddress[4];   // IPv4 source address
            UCHAR   IPv4DestAddress[4];     // IPv4 destination address
            USHORT  TCPSourcePortNumber;    // TCP source port
            USHORT  TCPDestPortNumber;      // TCP destination port
            
        }IPv4TcpSynParameters;

        //
        // IPv6 TCP SYN information
        //
        struct _IPV6_TCP_SYN_WOL_PACKET_PARAMETERS
        {
            ULONG   Flags;                  
            UCHAR   IPv6SourceAddress[16];  // source IPv6 address
            UCHAR   IPv6DestAddress[16];    // destination IPv6 address
            USHORT  TCPSourcePortNumber;    // source TCP port
            USHORT  TCPDestPortNumber;      // destination TCP port
        }IPv6TcpSynParameters;
        
        //
        // 802.1X EAPOL request identity message parameters 
        //
        struct _EAPOL_REQUEST_ID_MESSAGE_WOL_PACKET_PARAMETERS
        {
            ULONG   Flags;
        } EapolRequestIdMessageParameters;
        
        struct _WOL_BITMAP_PATTERN
        {
            ULONG   Flags;                  
            ULONG   MaskOffset;     // offset for mask buffer from the beginning of NDIS_PM_WOL_PATTERN structure
            ULONG   MaskSize;       // Mask size                
            ULONG   PatternOffset;  // offset for pattern buffer from the beginning of NDIS_PM_WOL_PATTERN structure
            ULONG   PatternSize;    // pattern size
        }WoLBitMapPattern;
    }WoLPattern;
    
}NDIS_PM_WOL_PATTERN, *PNDIS_PM_WOL_PATTERN;


#define NDIS_SIZEOF_NDIS_PM_WOL_PATTERN_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_PM_WOL_PATTERN, WoLPattern)


//
// 802.11 RSN handshake values 
// Used in DOT11_RSN_REKEY_PARAMETERS structure 
//
#define DOT11_RSN_KEK_LENGTH              	16
#define DOT11_RSN_KCK_LENGTH              	16

//
// structure is used in OID_PM_ADD_PROTOCOL_OFFLOAD and
// OID_PM_PROTOCOL_OFFLOAD_LIST OID requests
//
#define NDIS_PM_PROTOCOL_OFFLOAD_REVISION_1             1

typedef struct _NDIS_PM_PROTOCOL_OFFLOAD
{
    NDIS_OBJECT_HEADER            Header;
    ULONG                         Flags;
    ULONG                         Priority;
    NDIS_PM_PROTOCOL_OFFLOAD_TYPE ProtocolOffloadType;
    NDIS_PM_COUNTED_STRING        FriendlyName;
    ULONG                         ProtocolOffloadId; // offloaded protocol ID set by NDIS
    ULONG                         NextProtocolOffloadOffset;
    
    union _PROTOCOL_OFFLOAD_PARAMETERS
    {
        //
        // IPv4 ARP
        //
        struct _IPV4_ARP_PARAMETERS
        {
            ULONG   Flags;                  
            UCHAR   RemoteIPv4Address[4];   // source IPv4 address (optional)
            UCHAR   HostIPv4Address[4];     // destination IPv4 address
            UCHAR   MacAddress[6];          // MAC address                        
        }IPv4ARPParameters;

        //
        // IPv6 NS. ICMPv6 type 135
        // flags determine link local or global address. Discovery, reachability or dup address detection
        // multicat MAC address: 3333WXYZ where WXYZ is the least significant 4 bytes from 
        // the solicited node IPv6 address
        //
        struct  _IPV6_NS_PARAMETERS
        {
            ULONG   Flags;                              
            UCHAR   RemoteIPv6Address[16];              // source IPv6 address (optional)
            UCHAR   SolicitedNodeIPv6Address[16];       // solicited node IPv6 address
            UCHAR   MacAddress[6];                      // MAC address     
            UCHAR   TargetIPv6Addresses[2][16];         // An array of local IPv6 addesses           
        }IPv6NSParameters;
                        
        //
        // 802.11 RSN handshake
        //
        struct _DOT11_RSN_REKEY_PARAMETERS
        {
            ULONG   Flags;                  
            UCHAR   KCK[DOT11_RSN_KCK_LENGTH];
            UCHAR   KEK[DOT11_RSN_KEK_LENGTH];
            ULONGLONG KeyReplayCounter;
        }Dot11RSNRekeyParameters;
        
    }ProtocolOffloadParameters;
    
}NDIS_PM_PROTOCOL_OFFLOAD, *PNDIS_PM_PROTOCOL_OFFLOAD;

#define NDIS_SIZEOF_NDIS_PM_PROTOCOL_OFFLOAD_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_PM_PROTOCOL_OFFLOAD, ProtocolOffloadParameters)


//
// enum values used in NDIS_WMI_PM_ADMIN_CONFIG structure
//
typedef enum _NDIS_PM_ADMIN_CONFIG_STATE
{
    NdisPMAdminConfigUnspecified = 0,
    NdisPMAdminConfigDisabled = 1,
    NdisPMAdminConfigEnabled = 2
} NDIS_PM_ADMIN_CONFIG_STATE, *PNDIS_PM_ADMIN_CONFIG_STATE;

//
// NDIS_WMI_PM_ADMIN_CONFIG struct is used with 
// GUID_NDIS_PM_ADMIN_CONFIG WMI method
//
#define NDIS_WMI_PM_ADMIN_CONFIG_REVISION_1     1

typedef struct _NDIS_WMI_PM_ADMIN_CONFIG
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;         
    // Header.Revision = NDIS_WMI_PM_ADMIN_CONFIG_REVISION_1;
    // Header.Size = sizeof(NDIS_WMI_PM_ADMIN_CONFIG);
    //
    NDIS_OBJECT_HEADER Header;

    NDIS_PM_ADMIN_CONFIG_STATE   WakeOnPattern;
    NDIS_PM_ADMIN_CONFIG_STATE   WakeOnMagicPacket;
    NDIS_PM_ADMIN_CONFIG_STATE   DeviceSleepOnDisconnect;
    NDIS_PM_ADMIN_CONFIG_STATE   PMARPOffload;
    NDIS_PM_ADMIN_CONFIG_STATE   PMNSOffload;
    NDIS_PM_ADMIN_CONFIG_STATE   PMWiFiRekeyOffload;    
    
} NDIS_WMI_PM_ADMIN_CONFIG, *PNDIS_WMI_PM_ADMIN_CONFIG;

#define NDIS_SIZEOF_WMI_PM_ADMIN_CONFIG_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_PM_ADMIN_CONFIG, PMWiFiRekeyOffload)

//
// enum values used in NDIS_WMI_PM_ACTIVE_CAPABILITIES structure
//
typedef enum _NDIS_PM_CAPABILITY_STATE
{
    NdisPMAdminConfigUnsupported = 0,
    NdisPMAdminConfigInactive = 1,
    NdisPMAdminConfigActive = 2
} NDIS_PM_CAPABILITY_STATE, *PNDIS_PM_CAPABILITY_STATE;

//
// NDIS_WMI_PM_ACTIVE_CAPABILITIES struct is used with 
// GUID_NDIS_PM_ACTIVE_CAPABILITIES WMI method
//
#define NDIS_WMI_PM_ACTIVE_CAPABILITIES_REVISION_1     1

typedef struct _NDIS_WMI_PM_ACTIVE_CAPABILITIES
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;         
    // Header.Revision = NDIS_WMI_PM_ACTIVE_CAPABILITIES_REVISION_1;
    // Header.Size = sizeof(NDIS_WMI_PM_ACTIVE_CAPABILITIES);
    //
    NDIS_OBJECT_HEADER Header;

    NDIS_PM_CAPABILITY_STATE   WakeOnPattern;
    NDIS_PM_CAPABILITY_STATE   WakeOnMagicPacket;
    NDIS_PM_CAPABILITY_STATE   DeviceSleepOnDisconnect;
    NDIS_PM_CAPABILITY_STATE   PMARPOffload;
    NDIS_PM_CAPABILITY_STATE   PMNSOffload;
    NDIS_PM_CAPABILITY_STATE   PMWiFiRekeyOffload;    
    
} NDIS_WMI_PM_ACTIVE_CAPABILITIES, *PNDIS_WMI_PM_ACTIVE_CAPABILITIES;

#define NDIS_SIZEOF_WMI_PM_ACTIVE_CAPABILITIES_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_PM_ACTIVE_CAPABILITIES, PMWiFiRekeyOffload)


//
// receive filter data structures and definitions
//


//
// used in SupportedHeaders field of NDIS_RECEIVE_FILTER_CAPABILITIES
// structure
//
#define NDIS_RECEIVE_FILTER_MAC_HEADER_SUPPORTED            0x00000001


//
// used in SupportedMacHeaderFields field of NDIS_RECEIVE_FILTER_CAPABILITIES
// structure
//
#define NDIS_RECEIVE_FILTER_MAC_HEADER_DEST_ADDR_SUPPORTED      0x00000001
#define NDIS_RECEIVE_FILTER_MAC_HEADER_SOURCE_ADDR_SUPPORTED    0x00000002
#define NDIS_RECEIVE_FILTER_MAC_HEADER_PROTOCOL_SUPPORTED       0x00000004
#define NDIS_RECEIVE_FILTER_MAC_HEADER_VLAN_ID_SUPPORTED        0x00000008
#define NDIS_RECEIVE_FILTER_MAC_HEADER_PRIORITY_SUPPORTED       0x00000010



//
// used in SupportedFilterTests field of NDIS_RECEIVE_FILTER_CAPABILITIES
// structure
//
#define NDIS_RECEIVE_FILTER_TEST_HEADER_FIELD_EQUAL_SUPPORTED               0x00000001
#define NDIS_RECEIVE_FILTER_TEST_HEADER_FIELD_MASK_EQUAL_SUPPORTED          0x00000002


//
// used in SupportedQueueProperties field of NDIS_RECEIVE_FILTER_CAPABILITIES
// structure
//
#define NDIS_RECEIVE_FILTER_MSI_X_SUPPORTED                         0x00000001
#define NDIS_RECEIVE_FILTER_VM_QUEUE_SUPPORTED                      0x00000002
#define NDIS_RECEIVE_FILTER_LOOKAHEAD_SPLIT_SUPPORTED               0x00000004



//
// The following bits are used in EnabledFilterTypes field of
// NDIS_RECEIVE_FILTER_GLOBAL_PARAMETERS structure and 
// EnabledFilterTypes field of NDIS_RECEIVE_FILTER_CAPABILITIES structure
//
#define NDIS_RECEIVE_FILTER_VMQ_FILTERS_ENABLED                     0x00000001



//
// The following bits are used in EnabledQueueTypes field of
// NDIS_RECEIVE_FILTER_GLOBAL_PARAMETERS structure and
// EnabledQueueTypes field of NDIS_RECEIVE_FILTER_CAPABILITIES structure
//
#define NDIS_RECEIVE_FILTER_VM_QUEUES_ENABLED                       0x00000001



//
// Data structures for advertising generic filtering capabilities
// in ReceiveFilterCapabilities field of NDIS_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES 
// structure, OID_RECEIVE_FILTER_HARDWARE_CAPABILITIES  and
// OID_RECEIVE_FILTER_CURRENT_CAPABILITIES query OIDs
//
#define NDIS_RECEIVE_FILTER_CAPABILITIES_REVISION_1     1
typedef struct _NDIS_RECEIVE_FILTER_CAPABILITIES
{
    __in  NDIS_OBJECT_HEADER          Header;
    __in  ULONG                       Flags;
    __in  ULONG                       EnabledFilterTypes;
    __in  ULONG                       EnabledQueueTypes;
    __in  ULONG                       NumQueues;
    __in  ULONG                       SupportedQueueProperties;
    __in  ULONG                       SupportedFilterTests;
    __in  ULONG                       SupportedHeaders;
    __in  ULONG                       SupportedMacHeaderFields;
    __in  ULONG                       MaxMacHeaderFilters;
    __in  ULONG                       MaxQueueGroups;
    __in  ULONG                       MaxQueuesPerQueueGroup;
    __in  ULONG                       MinLookaheadSplitSize;
    __in  ULONG                       MaxLookaheadSplitSize;
} NDIS_RECEIVE_FILTER_CAPABILITIES, *PNDIS_RECEIVE_FILTER_CAPABILITIES;

#define NDIS_SIZEOF_RECEIVE_FILTER_CAPABILITIES_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_FILTER_CAPABILITIES, MaxLookaheadSplitSize)


//
// Data structure for advertising the NIC VMQ capabilities
// Used in HardwareNicSwitchCapabilities and CurrentNicSwitchCapabilities
// fields of NDIS_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES,
// OID_NIC_SWITCH_HARDWARE_CAPABILITIES and OID_NIC_SWITCH_CURRENT_CAPABILITIES
//
#define NDIS_NIC_SWITCH_CAPABILITIES_REVISION_1        1
typedef struct _NDIS_NIC_SWITCH_CAPABILITIES
{
    __in  NDIS_OBJECT_HEADER          Header;
    __in  ULONG                       Flags;
    __in  ULONG                       NdisReserved1;
    __in  ULONG                       NumTotalMacAddresses;
    __in  ULONG                       NumMacAddressesPerPort;
    __in  ULONG                       NumVlansPerPort;
    __in  ULONG                       NdisReserved2;
    __in  ULONG                       NdisReserved3;
}NDIS_NIC_SWITCH_CAPABILITIES, *PNDIS_NIC_SWITCH_CAPABILITIES;

#define NDIS_SIZEOF_NIC_SWITCH_CAPABILITIES_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_NIC_SWITCH_CAPABILITIES, NdisReserved3)

//
// NDIS_RECEIVE_FILTER_GLOBAL_PARAMETERS is used in 
// OID_RECEIVE_FILTER_GLOBAL_PARAMETERS query OID
// in order to query particular aspects 
// of receive filtering for a miniport adapter
//
#define NDIS_RECEIVE_FILTER_GLOBAL_PARAMETERS_REVISION_1       1
typedef struct _NDIS_RECEIVE_FILTER_GLOBAL_PARAMETERS
{
    __in  NDIS_OBJECT_HEADER          Header;
    __in  ULONG                       Flags;
    __in  ULONG                       EnabledFilterTypes;
    __in  ULONG                       EnabledQueueTypes;
} NDIS_RECEIVE_FILTER_GLOBAL_PARAMETERS, *PNDIS_RECEIVE_FILTER_GLOBAL_PARAMETERS;

#define NDIS_SIZEOF_RECEIVE_FILTER_GLOBAL_PARAMETERS_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_FILTER_GLOBAL_PARAMETERS, EnabledQueueTypes)

typedef ULONG NDIS_RECEIVE_QUEUE_ID, *PNDIS_RECEIVE_QUEUE_ID;
typedef ULONG NDIS_RECEIVE_QUEUE_GROUP_ID, *PNDIS_RECEIVE_QUEUE_GROUP_ID;

#define NDIS_DEFAULT_RECEIVE_QUEUE_ID               0
#define NDIS_DEFAULT_RECEIVE_QUEUE_GROUP_ID         0
#define NDIS_DEFAULT_RECEIVE_FILTER_ID              0

typedef ULONG NDIS_RECEIVE_FILTER_ID, *PNDIS_RECEIVE_FILTER_ID;

typedef enum _NDIS_RECEIVE_FILTER_TYPE
{
    NdisReceiveFilterTypeUndefined,
    NdisReceiveFilterTypeVMQueue,
    NdisReceiveFilterTypeMaximum
}NDIS_RECEIVE_FILTER_TYPE, *PNDIS_RECEIVE_FILTER_TYPE;

typedef enum _NDIS_FRAME_HEADER
{
    NdisFrameHeaderUndefined,
    NdisFrameHeaderMac,
    NdisFrameHeaderMaximum
}NDIS_FRAME_HEADER, *PNDIS_FRAME_HEADER;

typedef enum _NDIS_MAC_HEADER_FIELD
{
    NdisMacHeaderFieldUndefined,
    NdisMacHeaderFieldDestinationAddress,
    NdisMacHeaderFieldSourceAddress,
    NdisMacHeaderFieldProtocol,
    NdisMacHeaderFieldVlanId,
    NdisMacHeaderFieldPriority,
    NdisMacHeaderFieldMaximum
}NDIS_MAC_HEADER_FIELD, *PNDIS_MAC_HEADER_FIELD;


typedef enum _NDIS_RECEIVE_FILTER_TEST
{
    NdisReceiveFilterTestUndefined,
    NdisReceiveFilterTestEqual,
    NdisReceiveFilterTestMaskEqual,
    NdisReceiveFilterTestMaximum
}NDIS_RECEIVE_FILTER_TEST, *PNDIS_RECEIVE_FILTER_TEST;



//
// Flags used in NDIS_RECEIVE_FILTER_FIELD_PARAMETERS.Flags field
//
#define NDIS_RECEIVE_FILTER_FIELD_MAC_HEADER_VLAN_UNTAGGED_OR_ZERO         0x00000001

//
// NDIS_RECEIVE_FILTER_FIELD_PARAMETERS is used in
// NDIS_RECEIVE_FILTER_PARAMETERS structure
//
#define NDIS_RECEIVE_FILTER_FIELD_PARAMETERS_REVISION_1       1

typedef struct _NDIS_RECEIVE_FILTER_FIELD_PARAMETERS
{
    __in NDIS_OBJECT_HEADER       Header;
    __in ULONG                    Flags;
    __in NDIS_FRAME_HEADER        FrameHeader;
    __in NDIS_RECEIVE_FILTER_TEST ReceiveFilterTest;
    __in union _HEADER_FIELD
    {
        NDIS_MAC_HEADER_FIELD       MacHeaderField;
    }HeaderField;
    
    __in union _FIELD_VALUE
    {   
        UCHAR               FieldByteValue;
        USHORT              FieldShortValue;
        ULONG               FieldLongValue;
        ULONG64             FieldLong64Value;
        UCHAR               FieldByteArrayValue[16];
    }FieldValue;

    __in union _RESULT_VALUE                          // used when test operation is MaskEqual
    {   
        UCHAR               ResultByteValue;
        USHORT              ResultShortValue;
        ULONG               ResultLongValue;
        ULONG64             ResultLong64Value;
        UCHAR               ResultByteArrayValue[16];
    }ResultValue;

}NDIS_RECEIVE_FILTER_FIELD_PARAMETERS, *PNDIS_RECEIVE_FILTER_FIELD_PARAMETERS;

#define NDIS_SIZEOF_RECEIVE_FILTER_FIELD_PARAMETERS_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_FILTER_FIELD_PARAMETERS, ResultValue)


//
// NDIS_RECEIVE_FILTER_PARAMETERS is used in
// OID_RECEIVE_FILTER_PARAMETERS and OID_RECEIVE_FILTER_SET_FILTER
//
#define NDIS_RECEIVE_FILTER_PARAMETERS_REVISION_1       1

typedef struct _NDIS_RECEIVE_FILTER_PARAMETERS
{
    __in    NDIS_OBJECT_HEADER                     Header;
    __in    ULONG                                  Flags;
    __in    NDIS_RECEIVE_FILTER_TYPE               FilterType;
    __in    NDIS_RECEIVE_QUEUE_ID                  QueueId;
    __inout NDIS_RECEIVE_FILTER_ID                 FilterId;
    __in    ULONG                                  FieldParametersArrayOffset; // from the beginning of this structure
    __in    ULONG                                  FieldParametersArrayNumElements;
    __in    ULONG                                  FieldParametersArrayElementSize;
    __in    ULONG                                  RequestedFilterIdBitCount;
}NDIS_RECEIVE_FILTER_PARAMETERS, *PNDIS_RECEIVE_FILTER_PARAMETERS;

#define NDIS_SIZEOF_RECEIVE_FILTER_PARAMETERS_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_FILTER_PARAMETERS, RequestedFilterIdBitCount)


//
// NDIS_RECEIVE_FILTER_CLEAR_PARAMETERS is used in
// OID_RECEIVE_FILTER_CLEAR_FILTER
//
#define NDIS_RECEIVE_FILTER_CLEAR_PARAMETERS_REVISION_1       1

typedef struct _NDIS_RECEIVE_FILTER_CLEAR_PARAMETERS
{
    __in NDIS_OBJECT_HEADER                           Header;
    __in ULONG                                        Flags;
    __in NDIS_RECEIVE_QUEUE_ID                        QueueId;
    __in NDIS_RECEIVE_FILTER_ID                       FilterId;
}NDIS_RECEIVE_FILTER_CLEAR_PARAMETERS, *PNDIS_RECEIVE_FILTER_CLEAR_PARAMETERS;

#define NDIS_SIZEOF_RECEIVE_FILTER_CLEAR_PARAMETERS_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_FILTER_CLEAR_PARAMETERS, FilterId)



//
// enum value used in QueueType field of NDIS_RECEIVE_QUEUE_PARAMETERS structure
//
typedef enum _NDIS_RECEIVE_QUEUE_TYPE
{
    NdisReceiveQueueTypeUnspecified,
    NdisReceiveQueueTypeVMQueue,
    NdisReceiveQueueTypeMaximum
}NDIS_RECEIVE_QUEUE_TYPE, *PNDIS_RECEIVE_QUEUE_TYPE;



//
// bits used in Flags field of NDIS_RECEIVE_QUEUE_PARAMETERS in OID_RECEIVE_FILTER_ALLOCATE_QUEUE
// and OID_RECEIVE_FILTER_QUEUE_PARAMETERS -query- OID
// 
#define NDIS_RECEIVE_QUEUE_PARAMETERS_PER_QUEUE_RECEIVE_INDICATION              0x00000001
#define NDIS_RECEIVE_QUEUE_PARAMETERS_LOOKAHEAD_SPLIT_REQUIRED                  0x00000002

//
// bits used in Flags field of NDIS_RECEIVE_QUEUE_PARAMETERS in OID_RECEIVE_FILTER_QUEUE_PARAMETERS -set- OID 
// 
#define NDIS_RECEIVE_QUEUE_PARAMETERS_FLAGS_CHANGED                             0x00010000
#define NDIS_RECEIVE_QUEUE_PARAMETERS_PROCESSOR_AFFINITY_CHANGED                0x00020000
#define NDIS_RECEIVE_QUEUE_PARAMETERS_SUGGESTED_RECV_BUFFER_NUMBERS_CHANGED     0x00040000
#define NDIS_RECEIVE_QUEUE_PARAMETERS_NAME_CHANGED                              0x00080000


#define NDIS_RECEIVE_QUEUE_PARAMETERS_CHANGE_MASK                               0xFFFF0000

typedef NDIS_IF_COUNTED_STRING NDIS_QUEUE_NAME, *PNDIS_QUEUE_NAME;
typedef NDIS_IF_COUNTED_STRING NDIS_VM_NAME, *PNDIS_VM_NAME;

//
// NDIS_RECEIVE_QUEUE_PARAMETERS is used in 
// OID_RECEIVE_FILTER_ALLOCATE_QUEUE and OID_RECEIVE_FILTER_QUEUE_PARAMETERS
//
#define NDIS_RECEIVE_QUEUE_PARAMETERS_REVISION_1       1

typedef struct _NDIS_RECEIVE_QUEUE_PARAMETERS
{
    __in    NDIS_OBJECT_HEADER               Header;
    __inout ULONG                            Flags;
    __in    NDIS_RECEIVE_QUEUE_TYPE          QueueType;
    __inout NDIS_RECEIVE_QUEUE_ID            QueueId;
    __in    NDIS_RECEIVE_QUEUE_GROUP_ID      QueueGroupId;
    __in    GROUP_AFFINITY                   ProcessorAffinity;
    __in    ULONG                            NumSuggestedReceiveBuffers;
   __out    ULONG                            MSIXTableEntry;
    __in    ULONG                            LookaheadSize;
    __in    NDIS_VM_NAME                     VmName;       
    __in    NDIS_QUEUE_NAME                  QueueName;
}NDIS_RECEIVE_QUEUE_PARAMETERS, *PNDIS_RECEIVE_QUEUE_PARAMETERS;

#define NDIS_SIZEOF_RECEIVE_QUEUE_PARAMETERS_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_QUEUE_PARAMETERS, QueueName)


//
// NDIS_RECEIVE_QUEUE_FREE_PARAMETERS is used in 
// OID_RECEIVE_FILTER_FREE_QUEUE
//
#define NDIS_RECEIVE_QUEUE_FREE_PARAMETERS_REVISION_1       1

typedef struct _NDIS_RECEIVE_QUEUE_FREE_PARAMETERS
{
    __in NDIS_OBJECT_HEADER                   Header;
    __in ULONG                                Flags;
    __in NDIS_RECEIVE_QUEUE_ID                QueueId;
}NDIS_RECEIVE_QUEUE_FREE_PARAMETERS, *PNDIS_RECEIVE_QUEUE_FREE_PARAMETERS;

#define NDIS_SIZEOF_RECEIVE_QUEUE_FREE_PARAMETERS_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_QUEUE_FREE_PARAMETERS, QueueId)

//
// the following enum type is used in NDIS_RECEIVE_QUEUE_STATE
// and NDIS_RECEIVE_QUEUE_INFO
//
typedef enum _NDIS_RECEIVE_QUEUE_OPERATIONAL_STATE
{
    NdisReceiveQueueOperationalStateUndefined,
    NdisReceiveQueueOperationalStateRunning,
    NdisReceiveQueueOperationalStatePaused,
    NdisReceiveQueueOperationalStateDmaStopped,
    NdisReceiveQueueOperationalStateMaximum
}NDIS_RECEIVE_QUEUE_OPERATIONAL_STATE, *PNDIS_RECEIVE_QUEUE_OPERATIONAL_STATE;

//
// NDIS_RECEIVE_QUEUE_INFO is used with NDIS_RECEIVE_QUEUE_INFO_ARRAY
// in OID_RECEIVE_FILTER_ENUM_QUEUES that enumerates receive queues 
// on a miniport or open
//
#define NDIS_RECEIVE_QUEUE_INFO_REVISION_1              1

typedef struct _NDIS_RECEIVE_QUEUE_INFO
{   
    NDIS_OBJECT_HEADER                  Header;
    ULONG                               Flags;
    NDIS_RECEIVE_QUEUE_TYPE             QueueType;
    NDIS_RECEIVE_QUEUE_ID               QueueId;
    NDIS_RECEIVE_QUEUE_GROUP_ID         QueueGroupId;
    NDIS_RECEIVE_QUEUE_OPERATIONAL_STATE QueueState;
    GROUP_AFFINITY                      ProcessorAffinity;
    ULONG                               NumSuggestedReceiveBuffers;
    ULONG                               MSIXTableEntry;
    ULONG                               LookaheadSize;
    NDIS_VM_NAME                        VmName;       
    NDIS_QUEUE_NAME                     QueueName;
}NDIS_RECEIVE_QUEUE_INFO, *PNDIS_RECEIVE_QUEUE_INFO;

#define NDIS_SIZEOF_RECEIVE_QUEUE_INFO_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_QUEUE_INFO, QueueName)


//
// NDIS_RECEIVE_QUEUE_INFO_ARRAY is used in OID_RECEIVE_FILTER_ENUM_QUEUES
// that enumerates receive queues on a miniport or open. Each element in the 
// array is an NDIS_RECEIVE_QUEUE_INFO structure
//
#define NDIS_RECEIVE_QUEUE_INFO_ARRAY_REVISION_1             1

typedef struct _NDIS_RECEIVE_QUEUE_INFO_ARRAY
{
    NDIS_OBJECT_HEADER                          Header;
    ULONG                                       FirstElementOffset;
    ULONG                                       NumElements;
    ULONG                                       ElementSize;
}NDIS_RECEIVE_QUEUE_INFO_ARRAY, *PNDIS_RECEIVE_QUEUE_INFO_ARRAY;

#define NDIS_SIZEOF_RECEIVE_QUEUE_INFO_ARRAY_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_QUEUE_INFO_ARRAY, ElementSize)


//
// NDIS_RECEIVE_FILTER_INFO is used with NDIS_RECEIVE_FILTER_INFO_ARRAY
// in OID_RECEIVE_FILTER_ENUM_FILTERS that enumerates receive 
// filters on a queue
//
#define NDIS_RECEIVE_FILTER_INFO_REVISION_1             1

typedef struct _NDIS_RECEIVE_FILTER_INFO
{
    NDIS_OBJECT_HEADER                       Header;
    ULONG                                    Flags;
    NDIS_RECEIVE_FILTER_TYPE                 FilterType;
    NDIS_RECEIVE_FILTER_ID                   FilterId;
}NDIS_RECEIVE_FILTER_INFO, *PNDIS_RECEIVE_FILTER_INFO;

#define NDIS_SIZEOF_RECEIVE_FILTER_INFO_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_FILTER_INFO, FilterId)


//
// NDIS_RECEIVE_FILTER_INFO_ARRAY is used in OID_RECEIVE_FILTER_ENUM_FILTERS
// that enumerates receive filters on a queue. Each element in the array
// is an NDIS_RECEIVE_FILTER_INFO structure
//
#define NDIS_RECEIVE_FILTER_INFO_ARRAY_REVISION_1             1

typedef struct _NDIS_RECEIVE_FILTER_INFO_ARRAY
{
    NDIS_OBJECT_HEADER                          Header;
    NDIS_RECEIVE_QUEUE_ID                       QueueId;
    ULONG                                       FirstElementOffset;
    ULONG                                       NumElements;
    ULONG                                       ElementSize;
}NDIS_RECEIVE_FILTER_INFO_ARRAY, *PNDIS_RECEIVE_FILTER_INFO_ARRAY;

#define NDIS_SIZEOF_RECEIVE_FILTER_INFO_ARRAY_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_FILTER_INFO_ARRAY, ElementSize)

//
// NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_PARAMETERS is used 
// in OID_RECEIVE_FILTER_QUEUE_ALLOCATION_COMPLETE OID.
//
#define NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_PARAMETERS_REVISION_1    1

typedef struct _NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_PARAMETERS
{
    __in  NDIS_OBJECT_HEADER      Header;
    __in  ULONG                   Flags;
    __in  NDIS_RECEIVE_QUEUE_ID   QueueId;
    __out NDIS_STATUS             CompletionStatus;    
}NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_PARAMETERS, *PNDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_PARAMETERS;

#define NDIS_SIZEOF_RECEIVE_QUEUE_ALLOCATION_COMPLETE_PARAMETERS_REVISION_1 \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_PARAMETERS, CompletionStatus)

//
// NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_ARRAY is used in
// OID_RECEIVE_FILTER_QUEUE_ALLOCATION_COMPLETE OID request.
// Each element in array is an NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_PARAMETERS
// structure.
//
#define NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_ARRAY_REVISION_1         1

typedef struct _NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_ARRAY
{
    NDIS_OBJECT_HEADER                          Header;
    ULONG                                       Flags;
    ULONG                                       FirstElementOffset; // offset to an array of NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_PARAMETERS
    ULONG                                       NumElements;
    ULONG                                       ElementSize;    
}NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_ARRAY, *PNDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_ARRAY;

#define NDIS_SIZEOF_RECEIVE_QUEUE_ALLOCATION_COMPLETE_ARRAY_REVISION_1 \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_QUEUE_ALLOCATION_COMPLETE_ARRAY, ElementSize)


#endif // #if (NDIS_SUPPORT_NDIS620)

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6) 

#define NDIS_RECEIVE_SCALE_CAPABILITIES_REVISION_1     1

//
// What kind the receive scale capabilities the miniport can support, miniport drivers return
// some of these flags as CapabilitiesFlags in a structure _NDIS_RECEIVE_SCALE_CAPABILITIES 
// when they get a query about theire receive side scale capabilities.
//
#define NDIS_RSS_CAPS_MESSAGE_SIGNALED_INTERRUPTS                    0x01000000
#define NDIS_RSS_CAPS_CLASSIFICATION_AT_ISR                          0x02000000
#define NDIS_RSS_CAPS_CLASSIFICATION_AT_DPC                          0x04000000

#if NDIS_SUPPORT_NDIS620

#define NDIS_RSS_CAPS_USING_MSI_X                                    0x08000000

#endif
//
// What kind of hash field type the miniport can support
//
#define NDIS_RSS_CAPS_HASH_TYPE_TCP_IPV4                             0x00000100
#define NDIS_RSS_CAPS_HASH_TYPE_TCP_IPV6                             0x00000200
#define NDIS_RSS_CAPS_HASH_TYPE_TCP_IPV6_EX                          0x00000400

//
// the following structure defines the Receive scale capabilities of the miniport
//
typedef struct _NDIS_RECEIVE_SCALE_CAPABILITIES
{
    NDIS_OBJECT_HEADER  Header;
    ULONG   CapabilitiesFlags;
    ULONG   NumberOfInterruptMessages;
    ULONG   NumberOfReceiveQueues;
} NDIS_RECEIVE_SCALE_CAPABILITIES, *PNDIS_RECEIVE_SCALE_CAPABILITIES;

#define NDIS_SIZEOF_RECEIVE_SCALE_CAPABILITIES_REVISION_1   \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_SCALE_CAPABILITIES, NumberOfReceiveQueues)

//
// What hash functions does NDIS support
//
#define NdisHashFunctionToeplitz                            0x00000001 // supported hash function 1 -- Main RSS hash function 
#define NdisHashFunctionReserved1                           0x00000002 // supported hash function 2
#define NdisHashFunctionReserved2                           0x00000004 // supported hash function 3
#define NdisHashFunctionReserved3                           0x00000008 // supported hash function 4

#define NDIS_HASH_FUNCTION_MASK                             0x000000FF
#define NDIS_HASH_TYPE_MASK                                 0x00FFFF00

#define NDIS_RSS_HASH_FUNC_FROM_HASH_INFO(_HashInfo)  \
        ((_HashInfo) & (NDIS_HASH_FUNCTION_MASK))

#define NDIS_RSS_HASH_TYPE_FROM_HASH_INFO(_HashInfo)  \
        ((_HashInfo) & (NDIS_HASH_TYPE_MASK))

#define NDIS_RSS_HASH_INFO_FROM_TYPE_AND_FUNC(_HashType, _HashFunction) \
        ((_HashType) | (_HashFunction))

//
// What kind of hash field type the protocol what the miniport to do
//
#define NDIS_HASH_IPV4                                      0x00000100
#define NDIS_HASH_TCP_IPV4                                  0x00000200
#define NDIS_HASH_IPV6                                      0x00000400
#define NDIS_HASH_IPV6_EX                                   0x00000800
#define NDIS_HASH_TCP_IPV6                                  0x00001000
#define NDIS_HASH_TCP_IPV6_EX                               0x00002000

//
// Flags to denote the parameters that are kept unmodified.
//
#define NDIS_RSS_PARAM_FLAG_BASE_CPU_UNCHANGED              0x0001
#define NDIS_RSS_PARAM_FLAG_HASH_INFO_UNCHANGED             0x0002
#define NDIS_RSS_PARAM_FLAG_ITABLE_UNCHANGED                0x0004
#define NDIS_RSS_PARAM_FLAG_HASH_KEY_UNCHANGED              0x0008
#define NDIS_RSS_PARAM_FLAG_DISABLE_RSS                     0x0010

#define NDIS_RSS_INDIRECTION_TABLE_SIZE_REVISION_1          128
#define NDIS_RSS_HASH_SECRET_KEY_SIZE_REVISION_1            40

//
// used in OID_GEN_RECEIVE_SCALE_PARAMETERS
//
#define NDIS_RECEIVE_SCALE_PARAMETERS_REVISION_1     1

#if NDIS_SUPPORT_NDIS620

#define NDIS_RECEIVE_SCALE_PARAMETERS_REVISION_2     2

#endif

typedef struct _NDIS_RECEIVE_SCALE_PARAMETERS
{
    NDIS_OBJECT_HEADER      Header;

    // Qualifies the rest of the information.
    USHORT                  Flags;

    // The base CPU number to do receive processing. not used.
    USHORT                  BaseCpuNumber;

    // This describes the hash function and type being enabled.
    ULONG                   HashInformation;

    // The size of indirection table array.
    USHORT                  IndirectionTableSize;    
    // The offset of the indirection table from the beginning of this structure.
    ULONG                   IndirectionTableOffset;  

    // The size of the secret key.
    USHORT                  HashSecretKeySize;   
    // The offset of the secret key from the beginning of this structure.
    ULONG                   HashSecretKeyOffset; 

#if NDIS_SUPPORT_NDIS620
    ULONG                   ProcessorMasksOffset;     //
    ULONG                   NumberOfProcessorMasks;   // Array of type GROUP_AFFINITY representing procs used in the indirection table 
    ULONG                   ProcessorMasksEntrySize;  //
#endif

    // The hash map table is a CCHAR array for Revision 1.
    // It is a PROCESSOR_NUMBER array for Revision 2
} NDIS_RECEIVE_SCALE_PARAMETERS, *PNDIS_RECEIVE_SCALE_PARAMETERS;

#define NDIS_SIZEOF_RECEIVE_SCALE_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_SCALE_PARAMETERS, HashSecretKeyOffset)

//
// Maximum indirection table and private key sizes for revision 1
//
#define NDIS_RSS_INDIRECTION_TABLE_MAX_SIZE_REVISION_1      128
#define NDIS_RSS_HASH_SECRET_KEY_MAX_SIZE_REVISION_1        40

#if NDIS_SUPPORT_NDIS620

#define NDIS_SIZEOF_RECEIVE_SCALE_PARAMETERS_REVISION_2    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_SCALE_PARAMETERS, ProcessorMasksEntrySize)

//
// Maximum indirection table and private key sizes for revision 2
//
#define NDIS_RSS_INDIRECTION_TABLE_MAX_SIZE_REVISION_2      (128*sizeof(PROCESSOR_NUMBER))
#define NDIS_RSS_HASH_SECRET_KEY_MAX_SIZE_REVISION_2        40

#endif

//
// Used in OID_GEN_RECEIVE_HASH
//
#define NDIS_RECEIVE_HASH_FLAG_ENABLE_HASH                      0x00000001
#define NDIS_RECEIVE_HASH_FLAG_HASH_INFO_UNCHANGED              0x00000002
#define NDIS_RECEIVE_HASH_FLAG_HASH_KEY_UNCHANGED               0x00000004

#define NDIS_RECEIVE_HASH_PARAMETERS_REVISION_1                 1

typedef struct _NDIS_RECEIVE_HASH_PARAMETERS
{
    NDIS_OBJECT_HEADER      Header;

    // Qualifies the rest of the information.
    ULONG                   Flags;

    // This describes the hash function and type being enabled.
    ULONG                   HashInformation;

    // The size of the secret key.
    USHORT                  HashSecretKeySize;
    
    // The offset of the secret key from the beginning of this structure.
    ULONG                   HashSecretKeyOffset; 
} NDIS_RECEIVE_HASH_PARAMETERS, *PNDIS_RECEIVE_HASH_PARAMETERS;

#define NDIS_SIZEOF_RECEIVE_HASH_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RECEIVE_HASH_PARAMETERS, HashSecretKeyOffset)


typedef enum _NDIS_PROCESSOR_VENDOR
{
    NdisProcessorVendorUnknown,
    NdisProcessorVendorGenuinIntel,
    NdisProcessorVendorGenuineIntel = NdisProcessorVendorGenuinIntel,
    NdisProcessorVendorAuthenticAMD
} NDIS_PROCESSOR_VENDOR, *PNDIS_PROCESSOR_VENDOR;

#if NDIS_SUPPORT_NDIS620

//
// Used in the RssProcessorArray in NDIS_RSS_PROCESSOR_INFO
//
typedef struct _NDIS_RSS_PROCESSOR
{
    PROCESSOR_NUMBER ProcNum;
    USHORT           PreferenceIndex;
    USHORT           Reserved;
} NDIS_RSS_PROCESSOR, *PNDIS_RSS_PROCESSOR;

#define NDIS_SIZEOF_RSS_PROCESSOR_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RSS_PROCESSOR, PreferenceIndex)

#define NDIS_RSS_PROCESSOR_INFO_REVISION_1      1

//
// Used in NdisGetRssProcessorInformation API
//
typedef struct _NDIS_RSS_PROCESSOR_INFO
{
    NDIS_OBJECT_HEADER      Header;
    ULONG                   Flags;
    PROCESSOR_NUMBER        RssBaseProcessor;
    ULONG                   MaxNumRssProcessors;
    USHORT                  PreferredNumaNode;

    ULONG                   RssProcessorArrayOffset;// |
    ULONG                   RssProcessorCount;      // | Array of NDIS_RSS_PROCESSOR
    ULONG                   RssProcessorEntrySize;  // |

} NDIS_RSS_PROCESSOR_INFO, *PNDIS_RSS_PROCESSOR_INFO;

C_ASSERT(sizeof(NDIS_RSS_PROCESSOR_INFO) % __alignof(NDIS_RSS_PROCESSOR) == 0);

#define NDIS_SIZEOF_RSS_PROCESSOR_INFO_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_RSS_PROCESSOR_INFO, RssProcessorEntrySize)


//
// Used in ProcessorInfo array in NDIS_SYSTEM_PROCESSOR_INFO_EX
//
typedef struct _NDIS_PROCESSOR_INFO_EX
{
    PROCESSOR_NUMBER ProcNum;
    ULONG            SocketId;
    ULONG            CoreId;
    ULONG            HyperThreadId;
    USHORT           NodeId;
    USHORT           NodeDistance;
}NDIS_PROCESSOR_INFO_EX, *PNDIS_PROCESSOR_INFO_EX;

#define NDIS_SYSTEM_PROCESSOR_INFO_EX_REVISION_1 1

//
// Used in NdisGetProcessorInformationEx API
//
typedef struct _NDIS_SYSTEM_PROCESSOR_INFO_EX
{
    NDIS_OBJECT_HEADER      Header;
    ULONG                   Flags;
    NDIS_PROCESSOR_VENDOR   ProcessorVendor;
    ULONG                   NumSockets;
    ULONG                   NumCores;    
    ULONG                   NumCoresPerSocket;
    ULONG                   MaxHyperThreadingProcsPerCore;
    
    ULONG                   ProcessorInfoOffset;      // |
    ULONG                   NumberOfProcessors;       // | Array of NDIS_PROCESSOR_INFO_EX
    ULONG                   ProcessorInfoEntrySize;   // |

} NDIS_SYSTEM_PROCESSOR_INFO_EX, *PNDIS_SYSTEM_PROCESSOR_INFO_EX;

C_ASSERT(sizeof(NDIS_SYSTEM_PROCESSOR_INFO_EX) % __alignof(NDIS_PROCESSOR_INFO_EX) == 0);

#define NDIS_SIZEOF_SYSTEM_PROCESSOR_INFO_EX_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_SYSTEM_PROCESSOR_INFO_EX, ProcessorInfoEntrySize)

//
// Enum to identify Hypervisor Parition type
// Used in NDIS_HYPERVISOR_INFO.PartitionType
//
typedef enum _NDIS_HYPERVISOR_PARTITION_TYPE
{
    NdisHypervisorPartitionTypeUnknown,
    NdisHypervisorPartitionTypeMsHvParent,
    NdisHypervisorPartitionMsHvChild,
    NdisHypervisorPartitionTypeMax
} NDIS_HYPERVISOR_PARTITION_TYPE, *PNDIS_HYPERVISOR_PARTITION_TYPE;

//
// Flags used in NDIS_HYPERVISOR_INFO.Flags field
//
#define NDIS_HYPERVISOR_INFO_FLAG_HYPERVISOR_PRESENT            0x00000001

#define NDIS_HYPERVISOR_INFO_REVISION_1 1

//
// Structure used to return Hypervisor related information
// in NdisGetHypervisorInfo API
//
typedef struct _NDIS_HYPERVISOR_INFO
{
    NDIS_OBJECT_HEADER                  Header;
    ULONG                               Flags;
    NDIS_HYPERVISOR_PARTITION_TYPE      PartitionType;
} NDIS_HYPERVISOR_INFO, *PNDIS_HYPERVISOR_INFO;

#define NDIS_SIZEOF_HYPERVISOR_INFO_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_HYPERVISOR_INFO, PartitionType)

//
// The following data structures are used with Receive Queue related WMI
// guids. NDIS will translate these data structures to those used 
// in OIDs
//

typedef struct _NDIS_WMI_GROUP_AFFINITY {
    ULONG64             Mask;
    USHORT              Group;
    USHORT              Reserved[3];
} NDIS_WMI_GROUP_AFFINITY, *PNDIS_WMI_GROUP_AFFINITY;

//
// NDIS_WMI_RECEIVE_QUEUE_PARAMETERS is used in GUID_NDIS_RECEIVE_FILTER_QUEUE_PARAMETERS
//
#define NDIS_WMI_RECEIVE_QUEUE_PARAMETERS_REVISION_1       1

typedef struct _NDIS_WMI_RECEIVE_QUEUE_PARAMETERS
{
    NDIS_OBJECT_HEADER               Header;
    ULONG                            Flags;
    NDIS_RECEIVE_QUEUE_TYPE          QueueType;
    NDIS_RECEIVE_QUEUE_ID            QueueId;
    NDIS_RECEIVE_QUEUE_GROUP_ID      QueueGroupId;
    NDIS_WMI_GROUP_AFFINITY          ProcessorAffinity;
    ULONG                            NumSuggestedReceiveBuffers;
    ULONG                            MSIXTableEntry;
    ULONG                            LookaheadSize;
    NDIS_VM_NAME                     VmName;       
    NDIS_QUEUE_NAME                  QueueName;
}NDIS_WMI_RECEIVE_QUEUE_PARAMETERS, *PNDIS_WMI_RECEIVE_QUEUE_PARAMETERS;

#define NDIS_SIZEOF_WMI_RECEIVE_QUEUE_PARAMETERS_REVISION_1     \
    RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_RECEIVE_QUEUE_PARAMETERS, QueueName)

//
// NDIS_WMI_RECEIVE_QUEUE_INFO is used in GUID_NDIS_RECEIVE_FILTER_ENUM_QUEUES
//
#define NDIS_WMI_RECEIVE_QUEUE_INFO_REVISION_1              1

typedef struct _NDIS_WMI_RECEIVE_QUEUE_INFO
{   
    NDIS_OBJECT_HEADER                  Header;
    ULONG                               Flags;
    NDIS_RECEIVE_QUEUE_TYPE             QueueType;
    NDIS_RECEIVE_QUEUE_ID               QueueId;
    NDIS_RECEIVE_QUEUE_GROUP_ID         QueueGroupId;
    NDIS_RECEIVE_QUEUE_OPERATIONAL_STATE QueueState;
    NDIS_WMI_GROUP_AFFINITY             ProcessorAffinity;
    ULONG                               NumSuggestedReceiveBuffers;
    ULONG                               MSIXTableEntry;
    ULONG                               LookaheadSize;
    NDIS_VM_NAME                        VmName;       
    NDIS_QUEUE_NAME                     QueueName;       
}NDIS_WMI_RECEIVE_QUEUE_INFO, *PNDIS_WMI_RECEIVE_QUEUE_INFO;

#define NDIS_SIZEOF_WMI_RECEIVE_QUEUE_INFO_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_RECEIVE_QUEUE_INFO, QueueName)    
        

#endif // NDIS_SUPPORT_NDIS620

#endif // ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6) 

#endif // NTDDI_VERSION >= NTDDI_VISTA

#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200

#pragma warning(pop)

#else

#endif

#endif // _NTDDNDIS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\nserror.h ===
/*++

  Microsoft Windows Media Technology
  Copyright (C) Microsoft Corporation.  All Rights Reserved.

Module Name:

    nserror.mc

Abstract:

    Definitions for Windows Media events.

Author:


Revision History:

Notes:

    This file is used by the MC tool to generate the nserror.h file

**************************** READ ME ******************************************

 Here are the commented error ranges for the Windows Media Technologies Group


 LEGACY RANGES

     0  -  199 = General NetShow errors

   200  -  399 = NetShow error events

   400  -  599 = NetShow monitor events

   600  -  799 = NetShow IMmsAutoServer errors

  1000  - 1199 = NetShow MCMADM errors


 NEW RANGES

  2000 -  2999 = ASF (defined in ASFERR.MC)

  3000 -  3999 = Windows Media SDK

  4000 -  4999 = Windows Media Player

  5000 -  5999 = Windows Media Server

  6000 -  6999 = Windows Media HTTP/RTSP result codes (defined in NETERROR.MC)

  7000 -  7999 = Windows Media Tools

  8000 -  8999 = Windows Media Content Discovery

  9000 -  9999 = Windows Media Real Time Collaboration

 10000 - 10999 = Windows Media Digital Rights Management

 11000 - 11999 = Windows Media Setup

 12000 - 12999 = Windows Media Networking

 13000 - 13999 = Windows Media Client Media Services

**************************** READ ME ******************************************

--*/

#ifndef _NSERROR_H
#define _NSERROR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)

#ifdef RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) _sc
#else // RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#endif // RC_INVOKED


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Success Events
//
/////////////////////////////////////////////////////////////////////////

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS_WIN32                0x7
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: NS_S_CALLPENDING
//
// MessageText:
//
// The requested operation is pending completion.%0
//
#define NS_S_CALLPENDING                 _HRESULT_TYPEDEF_(0x000D0000L)

//
// MessageId: NS_S_CALLABORTED
//
// MessageText:
//
// The requested operation was aborted by the client.%0
//
#define NS_S_CALLABORTED                 _HRESULT_TYPEDEF_(0x000D0001L)

//
// MessageId: NS_S_STREAM_TRUNCATED
//
// MessageText:
//
// The stream was purposefully stopped before completion.%0
//
#define NS_S_STREAM_TRUNCATED            _HRESULT_TYPEDEF_(0x000D0002L)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Warning Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_W_SERVER_BANDWIDTH_LIMIT
//
// MessageText:
//
// The maximum filebitrate value specified is greater than the server's configured maximum bandwidth.%0
//
#define NS_W_SERVER_BANDWIDTH_LIMIT      _HRESULT_TYPEDEF_(0x800D0003L)

//
// MessageId: NS_W_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
// The maximum bandwidth value specified is less than the maximum filebitrate.%0
//
#define NS_W_FILE_BANDWIDTH_LIMIT        _HRESULT_TYPEDEF_(0x800D0004L)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_NOCONNECTION
//
// MessageText:
//
// There is no connection established with the Windows Media server. The operation failed.%0
//
#define NS_E_NOCONNECTION                _HRESULT_TYPEDEF_(0xC00D0005L)

//
// MessageId: NS_E_CANNOTCONNECT
//
// MessageText:
//
// Unable to establish a connection to the server.%0
//
#define NS_E_CANNOTCONNECT               _HRESULT_TYPEDEF_(0xC00D0006L)

//
// MessageId: NS_E_CANNOTDESTROYTITLE
//
// MessageText:
//
// Unable to destroy the title.%0
//
#define NS_E_CANNOTDESTROYTITLE          _HRESULT_TYPEDEF_(0xC00D0007L)

//
// MessageId: NS_E_CANNOTRENAMETITLE
//
// MessageText:
//
// Unable to rename the title.%0
//
#define NS_E_CANNOTRENAMETITLE           _HRESULT_TYPEDEF_(0xC00D0008L)

//
// MessageId: NS_E_CANNOTOFFLINEDISK
//
// MessageText:
//
// Unable to offline disk.%0
//
#define NS_E_CANNOTOFFLINEDISK           _HRESULT_TYPEDEF_(0xC00D0009L)

//
// MessageId: NS_E_CANNOTONLINEDISK
//
// MessageText:
//
// Unable to online disk.%0
//
#define NS_E_CANNOTONLINEDISK            _HRESULT_TYPEDEF_(0xC00D000AL)

//
// MessageId: NS_E_NOREGISTEREDWALKER
//
// MessageText:
//
// There is no file parser registered for this type of file.%0
//
#define NS_E_NOREGISTEREDWALKER          _HRESULT_TYPEDEF_(0xC00D000BL)

//
// MessageId: NS_E_NOFUNNEL
//
// MessageText:
//
// There is no data connection established.%0
//
#define NS_E_NOFUNNEL                    _HRESULT_TYPEDEF_(0xC00D000CL)

//
// MessageId: NS_E_NO_LOCALPLAY
//
// MessageText:
//
// Failed to load the local play DLL.%0
//
#define NS_E_NO_LOCALPLAY                _HRESULT_TYPEDEF_(0xC00D000DL)

//
// MessageId: NS_E_NETWORK_BUSY
//
// MessageText:
//
// The network is busy.%0
//
#define NS_E_NETWORK_BUSY                _HRESULT_TYPEDEF_(0xC00D000EL)

//
// MessageId: NS_E_TOO_MANY_SESS
//
// MessageText:
//
// The server session limit was exceeded.%0
//
#define NS_E_TOO_MANY_SESS               _HRESULT_TYPEDEF_(0xC00D000FL)

//
// MessageId: NS_E_ALREADY_CONNECTED
//
// MessageText:
//
// The network connection already exists.%0
//
#define NS_E_ALREADY_CONNECTED           _HRESULT_TYPEDEF_(0xC00D0010L)

//
// MessageId: NS_E_INVALID_INDEX
//
// MessageText:
//
// Index %1 is invalid.%0
//
#define NS_E_INVALID_INDEX               _HRESULT_TYPEDEF_(0xC00D0011L)

//
// MessageId: NS_E_PROTOCOL_MISMATCH
//
// MessageText:
//
// There is no protocol or protocol version supported by both the client and the server.%0
//
#define NS_E_PROTOCOL_MISMATCH           _HRESULT_TYPEDEF_(0xC00D0012L)

//
// MessageId: NS_E_TIMEOUT
//
// MessageText:
//
// The server, a computer set up to offer multimedia content to other computers, could not handle your request for multimedia content in a timely manner.  Please try again later.%0
//
#define NS_E_TIMEOUT                     _HRESULT_TYPEDEF_(0xC00D0013L)

//
// MessageId: NS_E_NET_WRITE
//
// MessageText:
//
// Error writing to the network.%0
//
#define NS_E_NET_WRITE                   _HRESULT_TYPEDEF_(0xC00D0014L)

//
// MessageId: NS_E_NET_READ
//
// MessageText:
//
// Error reading from the network.%0
//
#define NS_E_NET_READ                    _HRESULT_TYPEDEF_(0xC00D0015L)

//
// MessageId: NS_E_DISK_WRITE
//
// MessageText:
//
// Error writing to a disk.%0
//
#define NS_E_DISK_WRITE                  _HRESULT_TYPEDEF_(0xC00D0016L)

//
// MessageId: NS_E_DISK_READ
//
// MessageText:
//
// Error reading from a disk.%0
//
#define NS_E_DISK_READ                   _HRESULT_TYPEDEF_(0xC00D0017L)

//
// MessageId: NS_E_FILE_WRITE
//
// MessageText:
//
// Error writing to a file.%0
//
#define NS_E_FILE_WRITE                  _HRESULT_TYPEDEF_(0xC00D0018L)

//
// MessageId: NS_E_FILE_READ
//
// MessageText:
//
// Error reading from a file.%0
//
#define NS_E_FILE_READ                   _HRESULT_TYPEDEF_(0xC00D0019L)

//
// MessageId: NS_E_FILE_NOT_FOUND
//
// MessageText:
//
// The system cannot find the file specified.%0
//
#define NS_E_FILE_NOT_FOUND              _HRESULT_TYPEDEF_(0xC00D001AL)

//
// MessageId: NS_E_FILE_EXISTS
//
// MessageText:
//
// The file already exists.%0
//
#define NS_E_FILE_EXISTS                 _HRESULT_TYPEDEF_(0xC00D001BL)

//
// MessageId: NS_E_INVALID_NAME
//
// MessageText:
//
// The file name, directory name, or volume label syntax is incorrect.%0
//
#define NS_E_INVALID_NAME                _HRESULT_TYPEDEF_(0xC00D001CL)

//
// MessageId: NS_E_FILE_OPEN_FAILED
//
// MessageText:
//
// Failed to open a file.%0
//
#define NS_E_FILE_OPEN_FAILED            _HRESULT_TYPEDEF_(0xC00D001DL)

//
// MessageId: NS_E_FILE_ALLOCATION_FAILED
//
// MessageText:
//
// Unable to allocate a file.%0
//
#define NS_E_FILE_ALLOCATION_FAILED      _HRESULT_TYPEDEF_(0xC00D001EL)

//
// MessageId: NS_E_FILE_INIT_FAILED
//
// MessageText:
//
// Unable to initialize a file.%0
//
#define NS_E_FILE_INIT_FAILED            _HRESULT_TYPEDEF_(0xC00D001FL)

//
// MessageId: NS_E_FILE_PLAY_FAILED
//
// MessageText:
//
// Unable to play a file.%0
//
#define NS_E_FILE_PLAY_FAILED            _HRESULT_TYPEDEF_(0xC00D0020L)

//
// MessageId: NS_E_SET_DISK_UID_FAILED
//
// MessageText:
//
// Could not set the disk UID.%0
//
#define NS_E_SET_DISK_UID_FAILED         _HRESULT_TYPEDEF_(0xC00D0021L)

//
// MessageId: NS_E_INDUCED
//
// MessageText:
//
// An error was induced for testing purposes.%0
//
#define NS_E_INDUCED                     _HRESULT_TYPEDEF_(0xC00D0022L)

//
// MessageId: NS_E_CCLINK_DOWN
//
// MessageText:
//
// Two Content Servers failed to communicate.%0
//
#define NS_E_CCLINK_DOWN                 _HRESULT_TYPEDEF_(0xC00D0023L)

//
// MessageId: NS_E_INTERNAL
//
// MessageText:
//
// An unknown error occurred.%0
//
#define NS_E_INTERNAL                    _HRESULT_TYPEDEF_(0xC00D0024L)

//
// MessageId: NS_E_BUSY
//
// MessageText:
//
// The requested resource is in use.%0
//
#define NS_E_BUSY                        _HRESULT_TYPEDEF_(0xC00D0025L)

//
// MessageId: NS_E_UNRECOGNIZED_STREAM_TYPE
//
// MessageText:
//
// The specified protocol is not recognized. Be sure that the file name and syntax, such as slashes, are correct for the protocol.%0
//
#define NS_E_UNRECOGNIZED_STREAM_TYPE    _HRESULT_TYPEDEF_(0xC00D0026L)

//
// MessageId: NS_E_NETWORK_SERVICE_FAILURE
//
// MessageText:
//
// The network service provider failed.%0
//
#define NS_E_NETWORK_SERVICE_FAILURE     _HRESULT_TYPEDEF_(0xC00D0027L)

//
// MessageId: NS_E_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
// An attempt to acquire a network resource failed.%0
//
#define NS_E_NETWORK_RESOURCE_FAILURE    _HRESULT_TYPEDEF_(0xC00D0028L)

//
// MessageId: NS_E_CONNECTION_FAILURE
//
// MessageText:
//
// The network connection has failed.%0
//
#define NS_E_CONNECTION_FAILURE          _HRESULT_TYPEDEF_(0xC00D0029L)

//
// MessageId: NS_E_SHUTDOWN
//
// MessageText:
//
// The session is being terminated locally.%0
//
#define NS_E_SHUTDOWN                    _HRESULT_TYPEDEF_(0xC00D002AL)

//
// MessageId: NS_E_INVALID_REQUEST
//
// MessageText:
//
// The request is invalid in the current state.%0
//
#define NS_E_INVALID_REQUEST             _HRESULT_TYPEDEF_(0xC00D002BL)

//
// MessageId: NS_E_INSUFFICIENT_BANDWIDTH
//
// MessageText:
//
// There is insufficient bandwidth available to fulfill the request.%0
//
#define NS_E_INSUFFICIENT_BANDWIDTH      _HRESULT_TYPEDEF_(0xC00D002CL)

//
// MessageId: NS_E_NOT_REBUILDING
//
// MessageText:
//
// The disk is not rebuilding.%0
//
#define NS_E_NOT_REBUILDING              _HRESULT_TYPEDEF_(0xC00D002DL)

//
// MessageId: NS_E_LATE_OPERATION
//
// MessageText:
//
// An operation requested for a particular time could not be carried out on schedule.%0
//
#define NS_E_LATE_OPERATION              _HRESULT_TYPEDEF_(0xC00D002EL)

//
// MessageId: NS_E_INVALID_DATA
//
// MessageText:
//
// Invalid or corrupt data was encountered.%0
//
#define NS_E_INVALID_DATA                _HRESULT_TYPEDEF_(0xC00D002FL)

//
// MessageId: NS_E_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
// The bandwidth required to stream a file is higher than the maximum file bandwidth allowed on the server.%0
//
#define NS_E_FILE_BANDWIDTH_LIMIT        _HRESULT_TYPEDEF_(0xC00D0030L)

//
// MessageId: NS_E_OPEN_FILE_LIMIT
//
// MessageText:
//
// The client cannot have any more files open simultaneously.%0
//
#define NS_E_OPEN_FILE_LIMIT             _HRESULT_TYPEDEF_(0xC00D0031L)

//
// MessageId: NS_E_BAD_CONTROL_DATA
//
// MessageText:
//
// The server received invalid data from the client on the control connection.%0
//
#define NS_E_BAD_CONTROL_DATA            _HRESULT_TYPEDEF_(0xC00D0032L)

//
// MessageId: NS_E_NO_STREAM
//
// MessageText:
//
// There is no stream available.%0
//
#define NS_E_NO_STREAM                   _HRESULT_TYPEDEF_(0xC00D0033L)

//
// MessageId: NS_E_STREAM_END
//
// MessageText:
//
// There is no more data in the stream.%0
//
#define NS_E_STREAM_END                  _HRESULT_TYPEDEF_(0xC00D0034L)

//
// MessageId: NS_E_SERVER_NOT_FOUND
//
// MessageText:
//
// The specified server could not be found.%0
//
#define NS_E_SERVER_NOT_FOUND            _HRESULT_TYPEDEF_(0xC00D0035L)

//
// MessageId: NS_E_DUPLICATE_NAME
//
// MessageText:
//
// The specified name is already in use.
//
#define NS_E_DUPLICATE_NAME              _HRESULT_TYPEDEF_(0xC00D0036L)

//
// MessageId: NS_E_DUPLICATE_ADDRESS
//
// MessageText:
//
// The specified address is already in use.
//
#define NS_E_DUPLICATE_ADDRESS           _HRESULT_TYPEDEF_(0xC00D0037L)

//
// MessageId: NS_E_BAD_MULTICAST_ADDRESS
//
// MessageText:
//
// The specified address is not a valid multicast address.
//
#define NS_E_BAD_MULTICAST_ADDRESS       _HRESULT_TYPEDEF_(0xC00D0038L)

//
// MessageId: NS_E_BAD_ADAPTER_ADDRESS
//
// MessageText:
//
// The specified adapter address is invalid.
//
#define NS_E_BAD_ADAPTER_ADDRESS         _HRESULT_TYPEDEF_(0xC00D0039L)

//
// MessageId: NS_E_BAD_DELIVERY_MODE
//
// MessageText:
//
// The specified delivery mode is invalid.
//
#define NS_E_BAD_DELIVERY_MODE           _HRESULT_TYPEDEF_(0xC00D003AL)

//
// MessageId: NS_E_INVALID_CHANNEL
//
// MessageText:
//
// The specified station does not exist.
//
#define NS_E_INVALID_CHANNEL             _HRESULT_TYPEDEF_(0xC00D003BL)

//
// MessageId: NS_E_INVALID_STREAM
//
// MessageText:
//
// The specified stream does not exist.
//
#define NS_E_INVALID_STREAM              _HRESULT_TYPEDEF_(0xC00D003CL)

//
// MessageId: NS_E_INVALID_ARCHIVE
//
// MessageText:
//
// The specified archive could not be opened.
//
#define NS_E_INVALID_ARCHIVE             _HRESULT_TYPEDEF_(0xC00D003DL)

//
// MessageId: NS_E_NOTITLES
//
// MessageText:
//
// The system cannot find any titles on the server.%0
//
#define NS_E_NOTITLES                    _HRESULT_TYPEDEF_(0xC00D003EL)

//
// MessageId: NS_E_INVALID_CLIENT
//
// MessageText:
//
// The system cannot find the client specified.%0
//
#define NS_E_INVALID_CLIENT              _HRESULT_TYPEDEF_(0xC00D003FL)

//
// MessageId: NS_E_INVALID_BLACKHOLE_ADDRESS
//
// MessageText:
//
// The Blackhole Address is not initialized.%0
//
#define NS_E_INVALID_BLACKHOLE_ADDRESS   _HRESULT_TYPEDEF_(0xC00D0040L)

//
// MessageId: NS_E_INCOMPATIBLE_FORMAT
//
// MessageText:
//
// The station does not support the stream format.
//
#define NS_E_INCOMPATIBLE_FORMAT         _HRESULT_TYPEDEF_(0xC00D0041L)

//
// MessageId: NS_E_INVALID_KEY
//
// MessageText:
//
// The specified key is not valid.
//
#define NS_E_INVALID_KEY                 _HRESULT_TYPEDEF_(0xC00D0042L)

//
// MessageId: NS_E_INVALID_PORT
//
// MessageText:
//
// The specified port is not valid.
//
#define NS_E_INVALID_PORT                _HRESULT_TYPEDEF_(0xC00D0043L)

//
// MessageId: NS_E_INVALID_TTL
//
// MessageText:
//
// The specified TTL is not valid.
//
#define NS_E_INVALID_TTL                 _HRESULT_TYPEDEF_(0xC00D0044L)

//
// MessageId: NS_E_STRIDE_REFUSED
//
// MessageText:
//
// The request to fast forward or rewind could not be fulfilled.
//
#define NS_E_STRIDE_REFUSED              _HRESULT_TYPEDEF_(0xC00D0045L)

//
// IMmsAutoServer Errors
//
//
// MessageId: NS_E_MMSAUTOSERVER_CANTFINDWALKER
//
// MessageText:
//
// Unable to load the appropriate file parser.%0
//
#define NS_E_MMSAUTOSERVER_CANTFINDWALKER _HRESULT_TYPEDEF_(0xC00D0046L)

//
// MessageId: NS_E_MAX_BITRATE
//
// MessageText:
//
// Cannot exceed the maximum bandwidth limit.%0
//
#define NS_E_MAX_BITRATE                 _HRESULT_TYPEDEF_(0xC00D0047L)

//
// MessageId: NS_E_LOGFILEPERIOD
//
// MessageText:
//
// Invalid value for LogFilePeriod.%0
//
#define NS_E_LOGFILEPERIOD               _HRESULT_TYPEDEF_(0xC00D0048L)

//
// MessageId: NS_E_MAX_CLIENTS
//
// MessageText:
//
// Cannot exceed the maximum client limit.%0
// 
//
#define NS_E_MAX_CLIENTS                 _HRESULT_TYPEDEF_(0xC00D0049L)

//
// MessageId: NS_E_LOG_FILE_SIZE
//
// MessageText:
//
// The maximum log file size has been reached.%0
// 
//
#define NS_E_LOG_FILE_SIZE               _HRESULT_TYPEDEF_(0xC00D004AL)

//
// MessageId: NS_E_MAX_FILERATE
//
// MessageText:
//
// Cannot exceed the maximum file rate.%0
//
#define NS_E_MAX_FILERATE                _HRESULT_TYPEDEF_(0xC00D004BL)

//
// File Walker Errors
//
//
// MessageId: NS_E_WALKER_UNKNOWN
//
// MessageText:
//
// Unknown file type.%0
//
#define NS_E_WALKER_UNKNOWN              _HRESULT_TYPEDEF_(0xC00D004CL)

//
// MessageId: NS_E_WALKER_SERVER
//
// MessageText:
//
// The specified file, %1, cannot be loaded onto the specified server, %2.%0
//
#define NS_E_WALKER_SERVER               _HRESULT_TYPEDEF_(0xC00D004DL)

//
// MessageId: NS_E_WALKER_USAGE
//
// MessageText:
//
// There was a usage error with file parser.%0
//
#define NS_E_WALKER_USAGE                _HRESULT_TYPEDEF_(0xC00D004EL)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
/////////////////////////////////////////////////////////////////////////


 // Tiger Events

 // %1 is the tiger name

//
// MessageId: NS_I_TIGER_START
//
// MessageText:
//
// The Title Server %1 is running.%0
//
#define NS_I_TIGER_START                 _HRESULT_TYPEDEF_(0x400D004FL)

//
// MessageId: NS_E_TIGER_FAIL
//
// MessageText:
//
// The Title Server %1 has failed.%0
//
#define NS_E_TIGER_FAIL                  _HRESULT_TYPEDEF_(0xC00D0050L)


 // Cub Events

 // %1 is the cub ID
 // %2 is the cub name

//
// MessageId: NS_I_CUB_START
//
// MessageText:
//
// Content Server %1 (%2) is starting.%0
//
#define NS_I_CUB_START                   _HRESULT_TYPEDEF_(0x400D0051L)

//
// MessageId: NS_I_CUB_RUNNING
//
// MessageText:
//
// Content Server %1 (%2) is running.%0
//
#define NS_I_CUB_RUNNING                 _HRESULT_TYPEDEF_(0x400D0052L)

//
// MessageId: NS_E_CUB_FAIL
//
// MessageText:
//
// Content Server %1 (%2) has failed.%0
//
#define NS_E_CUB_FAIL                    _HRESULT_TYPEDEF_(0xC00D0053L)


 // Disk Events

 // %1 is the tiger disk ID
 // %2 is the device name
 // %3 is the cub ID
//
// MessageId: NS_I_DISK_START
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, is running.%0
//
#define NS_I_DISK_START                  _HRESULT_TYPEDEF_(0x400D0054L)

//
// MessageId: NS_E_DISK_FAIL
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, has failed.%0
//
#define NS_E_DISK_FAIL                   _HRESULT_TYPEDEF_(0xC00D0055L)

//
// MessageId: NS_I_DISK_REBUILD_STARTED
//
// MessageText:
//
// Started rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_STARTED        _HRESULT_TYPEDEF_(0x400D0056L)

//
// MessageId: NS_I_DISK_REBUILD_FINISHED
//
// MessageText:
//
// Finished rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_FINISHED       _HRESULT_TYPEDEF_(0x400D0057L)

//
// MessageId: NS_I_DISK_REBUILD_ABORTED
//
// MessageText:
//
// Aborted rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_ABORTED        _HRESULT_TYPEDEF_(0x400D0058L)


 // Admin Events

//
// MessageId: NS_I_LIMIT_FUNNELS
//
// MessageText:
//
// A NetShow administrator at network location %1 set the data stream limit to %2 streams.%0
//
#define NS_I_LIMIT_FUNNELS               _HRESULT_TYPEDEF_(0x400D0059L)

//
// MessageId: NS_I_START_DISK
//
// MessageText:
//
// A NetShow administrator at network location %1 started disk %2.%0
//
#define NS_I_START_DISK                  _HRESULT_TYPEDEF_(0x400D005AL)

//
// MessageId: NS_I_STOP_DISK
//
// MessageText:
//
// A NetShow administrator at network location %1 stopped disk %2.%0
//
#define NS_I_STOP_DISK                   _HRESULT_TYPEDEF_(0x400D005BL)

//
// MessageId: NS_I_STOP_CUB
//
// MessageText:
//
// A NetShow administrator at network location %1 stopped Content Server %2.%0
//
#define NS_I_STOP_CUB                    _HRESULT_TYPEDEF_(0x400D005CL)

//
// MessageId: NS_I_KILL_USERSESSION
//
// MessageText:
//
// A NetShow administrator at network location %1 aborted user session %2 from the system.%0
//
#define NS_I_KILL_USERSESSION            _HRESULT_TYPEDEF_(0x400D005DL)

//
// MessageId: NS_I_KILL_CONNECTION
//
// MessageText:
//
// A NetShow administrator at network location %1 aborted obsolete connection %2 from the system.%0
//
#define NS_I_KILL_CONNECTION             _HRESULT_TYPEDEF_(0x400D005EL)

//
// MessageId: NS_I_REBUILD_DISK
//
// MessageText:
//
// A NetShow administrator at network location %1 started rebuilding disk %2.%0
//
#define NS_I_REBUILD_DISK                _HRESULT_TYPEDEF_(0x400D005FL)

//
// MessageId: NS_W_UNKNOWN_EVENT
//
// MessageText:
//
// Unknown %1 event encountered.%0
//
#define NS_W_UNKNOWN_EVENT               _HRESULT_TYPEDEF_(0x800D0060L)


 // Alerts

//
// MessageId: NS_E_MAX_FUNNELS_ALERT
//
// MessageText:
//
// The NetShow data stream limit of %1 streams was reached.%0
//
#define NS_E_MAX_FUNNELS_ALERT           _HRESULT_TYPEDEF_(0xC00D0060L)

//
// MessageId: NS_E_ALLOCATE_FILE_FAIL
//
// MessageText:
//
// The NetShow Video Server was unable to allocate a %1 block file named %2.%0
//
#define NS_E_ALLOCATE_FILE_FAIL          _HRESULT_TYPEDEF_(0xC00D0061L)

//
// MessageId: NS_E_PAGING_ERROR
//
// MessageText:
//
// A Content Server was unable to page a block.%0
//
#define NS_E_PAGING_ERROR                _HRESULT_TYPEDEF_(0xC00D0062L)

//
// MessageId: NS_E_BAD_BLOCK0_VERSION
//
// MessageText:
//
// Disk %1 has unrecognized control block version %2.%0
//
#define NS_E_BAD_BLOCK0_VERSION          _HRESULT_TYPEDEF_(0xC00D0063L)

//
// MessageId: NS_E_BAD_DISK_UID
//
// MessageText:
//
// Disk %1 has incorrect uid %2.%0
//
#define NS_E_BAD_DISK_UID                _HRESULT_TYPEDEF_(0xC00D0064L)

//
// MessageId: NS_E_BAD_FSMAJOR_VERSION
//
// MessageText:
//
// Disk %1 has unsupported file system major version %2.%0
//
#define NS_E_BAD_FSMAJOR_VERSION         _HRESULT_TYPEDEF_(0xC00D0065L)

//
// MessageId: NS_E_BAD_STAMPNUMBER
//
// MessageText:
//
// Disk %1 has bad stamp number in control block.%0
//
#define NS_E_BAD_STAMPNUMBER             _HRESULT_TYPEDEF_(0xC00D0066L)

//
// MessageId: NS_E_PARTIALLY_REBUILT_DISK
//
// MessageText:
//
// Disk %1 is partially reconstructed.%0
//
#define NS_E_PARTIALLY_REBUILT_DISK      _HRESULT_TYPEDEF_(0xC00D0067L)

//
// MessageId: NS_E_ENACTPLAN_GIVEUP
//
// MessageText:
//
// EnactPlan gives up.%0
//
#define NS_E_ENACTPLAN_GIVEUP            _HRESULT_TYPEDEF_(0xC00D0068L)


 // MCMADM warnings/errors

//
// MessageId: MCMADM_I_NO_EVENTS
//
// MessageText:
//
// Event initialization failed, there will be no MCM events.%0
//
#define MCMADM_I_NO_EVENTS               _HRESULT_TYPEDEF_(0x400D0069L)

//
// MessageId: MCMADM_E_REGKEY_NOT_FOUND
//
// MessageText:
//
// The key was not found in the registry.%0
//
#define MCMADM_E_REGKEY_NOT_FOUND        _HRESULT_TYPEDEF_(0xC00D006AL)

//
// MessageId: NS_E_NO_FORMATS
//
// MessageText:
//
// The publishing point cannot be started because the server does not have the appropriate stream formats. Use the Multicast Announcement Wizard to create a new announcement for this publishing point.%0
//
#define NS_E_NO_FORMATS                  _HRESULT_TYPEDEF_(0xC00D006BL)

//
// MessageId: NS_E_NO_REFERENCES
//
// MessageText:
//
// No reference URLs were found in an ASX file.%0
//
#define NS_E_NO_REFERENCES               _HRESULT_TYPEDEF_(0xC00D006CL)

//
// MessageId: NS_E_WAVE_OPEN
//
// MessageText:
//
// Error opening wave device, the device might be in use.%0
//
#define NS_E_WAVE_OPEN                   _HRESULT_TYPEDEF_(0xC00D006DL)

//
// MessageId: NS_I_LOGGING_FAILED
//
// MessageText:
//
// The logging operation failed.
//
#define NS_I_LOGGING_FAILED              _HRESULT_TYPEDEF_(0x400D006EL)

//
// MessageId: NS_E_CANNOTCONNECTEVENTS
//
// MessageText:
//
// Unable to establish a connection to the NetShow event monitor service.%0
//
#define NS_E_CANNOTCONNECTEVENTS         _HRESULT_TYPEDEF_(0xC00D006FL)

//
// MessageId: NS_I_LIMIT_BANDWIDTH
//
// MessageText:
//
// A NetShow administrator at network location %1 set the maximum bandwidth limit to %2 bps.%0
//
#define NS_I_LIMIT_BANDWIDTH             _HRESULT_TYPEDEF_(0x400D0070L)

//
// MessageId: NS_E_NO_DEVICE
//
// MessageText:
//
// No device driver is present on the system.%0
//
#define NS_E_NO_DEVICE                   _HRESULT_TYPEDEF_(0xC00D0071L)

//
// MessageId: NS_E_NO_SPECIFIED_DEVICE
//
// MessageText:
//
// No specified device driver is present.%0
//
#define NS_E_NO_SPECIFIED_DEVICE         _HRESULT_TYPEDEF_(0xC00D0072L)


// NOTENOTE!!!
//
// Due to legacy problems these error codes live inside the ASF error code range
//
//
// MessageId: NS_E_NOTHING_TO_DO
//
// MessageText:
//
//  NS_E_NOTHING_TO_DO
//
#define NS_E_NOTHING_TO_DO               _HRESULT_TYPEDEF_(0xC00D07F1L)

//
// MessageId: NS_E_NO_MULTICAST
//
// MessageText:
//
// Not receiving data from the server.%0
//
#define NS_E_NO_MULTICAST                _HRESULT_TYPEDEF_(0xC00D07F2L)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
// IdRange = 200..399
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_MONITOR_GIVEUP
//
// MessageText:
//
// Netshow Events Monitor is not operational and has been disconnected.%0
//
#define NS_E_MONITOR_GIVEUP              _HRESULT_TYPEDEF_(0xC00D00C8L)

//
// MessageId: NS_E_REMIRRORED_DISK
//
// MessageText:
//
// Disk %1 is remirrored.%0
//
#define NS_E_REMIRRORED_DISK             _HRESULT_TYPEDEF_(0xC00D00C9L)

//
// MessageId: NS_E_INSUFFICIENT_DATA
//
// MessageText:
//
// Insufficient data found.%0
//
#define NS_E_INSUFFICIENT_DATA           _HRESULT_TYPEDEF_(0xC00D00CAL)

//
// MessageId: NS_E_ASSERT
//
// MessageText:
//
// %1 failed in file %2 line %3.%0
//
#define NS_E_ASSERT                      _HRESULT_TYPEDEF_(0xC00D00CBL)

//
// MessageId: NS_E_BAD_ADAPTER_NAME
//
// MessageText:
//
// The specified adapter name is invalid.%0
//
#define NS_E_BAD_ADAPTER_NAME            _HRESULT_TYPEDEF_(0xC00D00CCL)

//
// MessageId: NS_E_NOT_LICENSED
//
// MessageText:
//
// The application is not licensed for this feature.%0
//
#define NS_E_NOT_LICENSED                _HRESULT_TYPEDEF_(0xC00D00CDL)

//
// MessageId: NS_E_NO_SERVER_CONTACT
//
// MessageText:
//
// Unable to contact the server.%0
//
#define NS_E_NO_SERVER_CONTACT           _HRESULT_TYPEDEF_(0xC00D00CEL)

//
// MessageId: NS_E_TOO_MANY_TITLES
//
// MessageText:
//
// Maximum number of titles exceeded.%0
//
#define NS_E_TOO_MANY_TITLES             _HRESULT_TYPEDEF_(0xC00D00CFL)

//
// MessageId: NS_E_TITLE_SIZE_EXCEEDED
//
// MessageText:
//
// Maximum size of a title exceeded.%0
//
#define NS_E_TITLE_SIZE_EXCEEDED         _HRESULT_TYPEDEF_(0xC00D00D0L)

//
// MessageId: NS_E_UDP_DISABLED
//
// MessageText:
//
// UDP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_UDP_DISABLED                _HRESULT_TYPEDEF_(0xC00D00D1L)

//
// MessageId: NS_E_TCP_DISABLED
//
// MessageText:
//
// TCP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_TCP_DISABLED                _HRESULT_TYPEDEF_(0xC00D00D2L)

//
// MessageId: NS_E_HTTP_DISABLED
//
// MessageText:
//
// HTTP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_HTTP_DISABLED               _HRESULT_TYPEDEF_(0xC00D00D3L)

//
// MessageId: NS_E_LICENSE_EXPIRED
//
// MessageText:
//
// The product license has expired.%0
//
#define NS_E_LICENSE_EXPIRED             _HRESULT_TYPEDEF_(0xC00D00D4L)

//
// MessageId: NS_E_TITLE_BITRATE
//
// MessageText:
//
// Source file exceeds the per title maximum bitrate. See NetShow Theater documentation for more information.%0
//
#define NS_E_TITLE_BITRATE               _HRESULT_TYPEDEF_(0xC00D00D5L)

//
// MessageId: NS_E_EMPTY_PROGRAM_NAME
//
// MessageText:
//
// The program name cannot be empty.%0
//
#define NS_E_EMPTY_PROGRAM_NAME          _HRESULT_TYPEDEF_(0xC00D00D6L)

//
// MessageId: NS_E_MISSING_CHANNEL
//
// MessageText:
//
// Station %1 does not exist.%0
//
#define NS_E_MISSING_CHANNEL             _HRESULT_TYPEDEF_(0xC00D00D7L)

//
// MessageId: NS_E_NO_CHANNELS
//
// MessageText:
//
// You need to define at least one station before this operation can complete.%0
//
#define NS_E_NO_CHANNELS                 _HRESULT_TYPEDEF_(0xC00D00D8L)


/////////////////////////////////////////////////////////////////////
// This error message is to replace previous NS_E_INVALID_INDEX which
// takes an index value for the error message string.  For some application
// obtain the idex value at reporting error time is very difficult, so we
// use this string to avoid the problem.
//////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INDEX2
//
// MessageText:
//
// The index specified is invalid.%0
//
#define NS_E_INVALID_INDEX2              _HRESULT_TYPEDEF_(0xC00D00D9L)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
// IdRange = 400..599
//
// Admin Events:
//
// Alerts:
//
// Title Server:
//      %1 is the Title Server name
//
// Content Server:
//      %1 is the Content Server ID
//      %2 is the Content Server name
//      %3 is the Peer Content Server name (optional)
//
// Disks:
//      %1 is the Title Server disk ID
//      %2 is the device name
//      %3 is the Content Server ID
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_CUB_FAIL_LINK
//
// MessageText:
//
// Content Server %1 (%2) has failed its link to Content Server %3.%0
//
#define NS_E_CUB_FAIL_LINK               _HRESULT_TYPEDEF_(0xC00D0190L)

//
// MessageId: NS_I_CUB_UNFAIL_LINK
//
// MessageText:
//
// Content Server %1 (%2) has established its link to Content Server %3.%0
//
#define NS_I_CUB_UNFAIL_LINK             _HRESULT_TYPEDEF_(0x400D0191L)

//
// MessageId: NS_E_BAD_CUB_UID
//
// MessageText:
//
// Content Server %1 (%2) has incorrect uid %3.%0
//
#define NS_E_BAD_CUB_UID                 _HRESULT_TYPEDEF_(0xC00D0192L)

//
// MessageId: NS_I_RESTRIPE_START
//
// MessageText:
//
// Restripe operation has started.%0
//
#define NS_I_RESTRIPE_START              _HRESULT_TYPEDEF_(0x400D0193L)

//
// MessageId: NS_I_RESTRIPE_DONE
//
// MessageText:
//
// Restripe operation has completed.%0
//
#define NS_I_RESTRIPE_DONE               _HRESULT_TYPEDEF_(0x400D0194L)

//
// MessageId: NS_E_GLITCH_MODE
//
// MessageText:
//
// Server unreliable because multiple components failed.%0
//
#define NS_E_GLITCH_MODE                 _HRESULT_TYPEDEF_(0xC00D0195L)

//
// MessageId: NS_I_RESTRIPE_DISK_OUT
//
// MessageText:
//
// Content disk %1 (%2) on Content Server %3 has been restriped out.%0
//
#define NS_I_RESTRIPE_DISK_OUT           _HRESULT_TYPEDEF_(0x400D0196L)

//
// MessageId: NS_I_RESTRIPE_CUB_OUT
//
// MessageText:
//
// Content server %1 (%2) has been restriped out.%0
//
#define NS_I_RESTRIPE_CUB_OUT            _HRESULT_TYPEDEF_(0x400D0197L)

//
// MessageId: NS_I_DISK_STOP
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, has been offlined.%0
//
#define NS_I_DISK_STOP                   _HRESULT_TYPEDEF_(0x400D0198L)

//
// MessageId: NS_I_CATATONIC_FAILURE
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, will be failed because it is catatonic.%0
//
#define NS_I_CATATONIC_FAILURE           _HRESULT_TYPEDEF_(0x800D0199L)

//
// MessageId: NS_I_CATATONIC_AUTO_UNFAIL
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, auto online from catatonic state.%0
//
#define NS_I_CATATONIC_AUTO_UNFAIL       _HRESULT_TYPEDEF_(0x800D019AL)

//
// MessageId: NS_E_NO_MEDIA_PROTOCOL
//
// MessageText:
//
// Content Server %1 (%2) is unable to communicate with the Media System Network Protocol.%0
//
#define NS_E_NO_MEDIA_PROTOCOL           _HRESULT_TYPEDEF_(0xC00D019BL)


//
// Advanced Streaming Format (ASF) codes occupy MessageIds 2000-2999
//
// See ASFErr.mc for more details - please do not define any symbols
// in that range in this file.
//


/////////////////////////////////////////////////////////////////////////
//
// Windows Media SDK Errors
//
// IdRange = 3000-3199
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INPUT_FORMAT
//
// MessageText:
//
// The input media format is invalid.%0
//
#define NS_E_INVALID_INPUT_FORMAT        _HRESULT_TYPEDEF_(0xC00D0BB8L)

//
// MessageId: NS_E_MSAUDIO_NOT_INSTALLED
//
// MessageText:
//
// The MSAudio codec is not installed on this system.%0
//
#define NS_E_MSAUDIO_NOT_INSTALLED       _HRESULT_TYPEDEF_(0xC00D0BB9L)

//
// MessageId: NS_E_UNEXPECTED_MSAUDIO_ERROR
//
// MessageText:
//
// An unexpected error occurred with the MSAudio codec.%0
//
#define NS_E_UNEXPECTED_MSAUDIO_ERROR    _HRESULT_TYPEDEF_(0xC00D0BBAL)

//
// MessageId: NS_E_INVALID_OUTPUT_FORMAT
//
// MessageText:
//
// The output media format is invalid.%0
//
#define NS_E_INVALID_OUTPUT_FORMAT       _HRESULT_TYPEDEF_(0xC00D0BBBL)

//
// MessageId: NS_E_NOT_CONFIGURED
//
// MessageText:
//
// The object must be fully configured before audio samples can be processed.%0
//
#define NS_E_NOT_CONFIGURED              _HRESULT_TYPEDEF_(0xC00D0BBCL)

//
// MessageId: NS_E_PROTECTED_CONTENT
//
// MessageText:
//
// You need a license to perform the requested operation on this media file.%0
//
#define NS_E_PROTECTED_CONTENT           _HRESULT_TYPEDEF_(0xC00D0BBDL)

//
// MessageId: NS_E_LICENSE_REQUIRED
//
// MessageText:
//
// You need a license to perform the requested operation on this media file.%0
//
#define NS_E_LICENSE_REQUIRED            _HRESULT_TYPEDEF_(0xC00D0BBEL)

//
// MessageId: NS_E_TAMPERED_CONTENT
//
// MessageText:
//
// This media file is corrupted or invalid. Contact the content provider for a new file.%0
//
#define NS_E_TAMPERED_CONTENT            _HRESULT_TYPEDEF_(0xC00D0BBFL)

//
// MessageId: NS_E_LICENSE_OUTOFDATE
//
// MessageText:
//
// The license for this media file has expired. Get a new license or contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_OUTOFDATE           _HRESULT_TYPEDEF_(0xC00D0BC0L)

//
// MessageId: NS_E_LICENSE_INCORRECT_RIGHTS
//
// MessageText:
//
// You are not allowed to open this file. Contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_INCORRECT_RIGHTS    _HRESULT_TYPEDEF_(0xC00D0BC1L)

//
// MessageId: NS_E_AUDIO_CODEC_NOT_INSTALLED
//
// MessageText:
//
// The requested audio codec is not installed on this system.%0
//
#define NS_E_AUDIO_CODEC_NOT_INSTALLED   _HRESULT_TYPEDEF_(0xC00D0BC2L)

//
// MessageId: NS_E_AUDIO_CODEC_ERROR
//
// MessageText:
//
// An unexpected error occurred with the audio codec.%0
//
#define NS_E_AUDIO_CODEC_ERROR           _HRESULT_TYPEDEF_(0xC00D0BC3L)

//
// MessageId: NS_E_VIDEO_CODEC_NOT_INSTALLED
//
// MessageText:
//
// The requested video codec is not installed on this system.%0
//
#define NS_E_VIDEO_CODEC_NOT_INSTALLED   _HRESULT_TYPEDEF_(0xC00D0BC4L)

//
// MessageId: NS_E_VIDEO_CODEC_ERROR
//
// MessageText:
//
// An unexpected error occurred with the video codec.%0
//
#define NS_E_VIDEO_CODEC_ERROR           _HRESULT_TYPEDEF_(0xC00D0BC5L)

//
// MessageId: NS_E_INVALIDPROFILE
//
// MessageText:
//
// The Profile is invalid.%0
//
#define NS_E_INVALIDPROFILE              _HRESULT_TYPEDEF_(0xC00D0BC6L)

//
// MessageId: NS_E_INCOMPATIBLE_VERSION
//
// MessageText:
//
// A new version of the SDK is needed to play the requested content.%0
//
#define NS_E_INCOMPATIBLE_VERSION        _HRESULT_TYPEDEF_(0xC00D0BC7L)

//
// MessageId: NS_S_REBUFFERING
//
// MessageText:
//
// The requested operation has caused the source to rebuffer.%0
//
#define NS_S_REBUFFERING                 _HRESULT_TYPEDEF_(0x000D0BC8L)

//
// MessageId: NS_S_DEGRADING_QUALITY
//
// MessageText:
//
// The requested operation has caused the source to degrade codec quality.%0
//
#define NS_S_DEGRADING_QUALITY           _HRESULT_TYPEDEF_(0x000D0BC9L)

//
// MessageId: NS_E_OFFLINE_MODE
//
// MessageText:
//
// The requested URL is not available in offline mode.%0
//
#define NS_E_OFFLINE_MODE                _HRESULT_TYPEDEF_(0xC00D0BCAL)

//
// MessageId: NS_E_NOT_CONNECTED
//
// MessageText:
//
// The requested URL cannot be accessed because there is no network connection.%0
//
#define NS_E_NOT_CONNECTED               _HRESULT_TYPEDEF_(0xC00D0BCBL)

//
// MessageId: NS_E_TOO_MUCH_DATA
//
// MessageText:
//
// The encoding process was unable to keep up with the amount of supplied data.%0
//
#define NS_E_TOO_MUCH_DATA               _HRESULT_TYPEDEF_(0xC00D0BCCL)

//
// MessageId: NS_E_UNSUPPORTED_PROPERTY
//
// MessageText:
//
// The given property is not supported.%0
//
#define NS_E_UNSUPPORTED_PROPERTY        _HRESULT_TYPEDEF_(0xC00D0BCDL)

//
// MessageId: NS_E_8BIT_WAVE_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player cannot copy the files to the CD because they are 8-bit. Convert the files to 16-bit, 44-kHz stereo files by using Sound Recorder or another audio-processing program, and then try again.%0
//
#define NS_E_8BIT_WAVE_UNSUPPORTED       _HRESULT_TYPEDEF_(0xC00D0BCEL)

//
// MessageId: NS_E_NO_MORE_SAMPLES
//
// MessageText:
//
// There are no more samples in the current range.%0
//
#define NS_E_NO_MORE_SAMPLES             _HRESULT_TYPEDEF_(0xC00D0BCFL)

//
// MessageId: NS_E_INVALID_SAMPLING_RATE
//
// MessageText:
//
// The given sampling rate is invalid.%0
//
#define NS_E_INVALID_SAMPLING_RATE       _HRESULT_TYPEDEF_(0xC00D0BD0L)

//
// MessageId: NS_E_MAX_PACKET_SIZE_TOO_SMALL
//
// MessageText:
//
// The given maximum packet size is too small to accommodate this profile
//
#define NS_E_MAX_PACKET_SIZE_TOO_SMALL   _HRESULT_TYPEDEF_(0xC00D0BD1L)

//
// MessageId: NS_E_LATE_PACKET
//
// MessageText:
//
// The packet arrived too late to be of use
//
#define NS_E_LATE_PACKET                 _HRESULT_TYPEDEF_(0xC00D0BD2L)

//
// MessageId: NS_E_DUPLICATE_PACKET
//
// MessageText:
//
// The packet is a duplicate of one received before
//
#define NS_E_DUPLICATE_PACKET            _HRESULT_TYPEDEF_(0xC00D0BD3L)

//
// MessageId: NS_E_SDK_BUFFERTOOSMALL
//
// MessageText:
//
// Supplied buffer is too small
//
#define NS_E_SDK_BUFFERTOOSMALL          _HRESULT_TYPEDEF_(0xC00D0BD4L)

//
// MessageId: NS_E_INVALID_NUM_PASSES
//
// MessageText:
//
// The wrong number of preprocessing passes was used for the stream's output type
//
#define NS_E_INVALID_NUM_PASSES          _HRESULT_TYPEDEF_(0xC00D0BD5L)

//
// MessageId: NS_E_ATTRIBUTE_READ_ONLY
//
// MessageText:
//
// An attempt was made to add, modify, or delete a read only attribute
//
#define NS_E_ATTRIBUTE_READ_ONLY         _HRESULT_TYPEDEF_(0xC00D0BD6L)

//
// MessageId: NS_E_ATTRIBUTE_NOT_ALLOWED
//
// MessageText:
//
// An attempt was made to add attribute that is not allowed for the given media type
//
#define NS_E_ATTRIBUTE_NOT_ALLOWED       _HRESULT_TYPEDEF_(0xC00D0BD7L)

//
// MessageId: NS_E_INVALID_EDL
//
// MessageText:
//
// The EDL provided is invalid
//
#define NS_E_INVALID_EDL                 _HRESULT_TYPEDEF_(0xC00D0BD8L)

//
// MessageId: NS_E_DATA_UNIT_EXTENSION_TOO_LARGE
//
// MessageText:
//
// The Data Unit Extension data was too large to be used.%0
//
#define NS_E_DATA_UNIT_EXTENSION_TOO_LARGE _HRESULT_TYPEDEF_(0xC00D0BD9L)

//
// MessageId: NS_E_CODEC_DMO_ERROR
//
// MessageText:
//
// An unexpected error occurred with a DMO codec.%0
//
#define NS_E_CODEC_DMO_ERROR             _HRESULT_TYPEDEF_(0xC00D0BDAL)

//
// MessageId: NS_S_TRANSCRYPTOR_EOF
//
// MessageText:
//
// The transcryptor object has reached end of file.%0
//
#define NS_S_TRANSCRYPTOR_EOF            _HRESULT_TYPEDEF_(0x000D0BDBL)

//
// MessageId: NS_E_FEATURE_DISABLED_BY_GROUP_POLICY
//
// MessageText:
//
// This feature has been disabled by group policy.%0
//
#define NS_E_FEATURE_DISABLED_BY_GROUP_POLICY _HRESULT_TYPEDEF_(0xC00D0BDCL)

//
// MessageId: NS_E_FEATURE_DISABLED_IN_SKU
//
// MessageText:
//
// This feature is disabled in this SKU.%0
//
#define NS_E_FEATURE_DISABLED_IN_SKU     _HRESULT_TYPEDEF_(0xC00D0BDDL)



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Player Errors
//
// IdRange = 4000 - 4999
//
/////////////////////////////////////////////////////////////////////////

//
// WMP CD Filter Error codes
//
//
// MessageId: NS_E_NO_CD
//
// MessageText:
//
// There is no CD in the CD drive. Insert a CD, and then try again.%0
//
#define NS_E_NO_CD                       _HRESULT_TYPEDEF_(0xC00D0FA0L)

//
// MessageId: NS_E_CANT_READ_DIGITAL
//
// MessageText:
//
// Windows Media Player could not use digital playback to play the CD. To switch to analog playback, Click Organize, click Options, and then click the Devices tab. Double-click the CD drive, and then in the Playback area, click Analog.%0
//
#define NS_E_CANT_READ_DIGITAL           _HRESULT_TYPEDEF_(0xC00D0FA1L)

//
// MessageId: NS_E_DEVICE_DISCONNECTED
//
// MessageText:
//
// Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and then try syncing the file again.%0
//
#define NS_E_DEVICE_DISCONNECTED         _HRESULT_TYPEDEF_(0xC00D0FA2L)

//
// MessageId: NS_E_DEVICE_NOT_SUPPORT_FORMAT
//
// MessageText:
//
// Windows Media Player cannot play the file. The portable device does not support the specified file type.%0
//
#define NS_E_DEVICE_NOT_SUPPORT_FORMAT   _HRESULT_TYPEDEF_(0xC00D0FA3L)

//
// MessageId: NS_E_SLOW_READ_DIGITAL
//
// MessageText:
//
// Windows Media Player could not use digital playback to play the CD. The Player has automatically switched the CD drive to analog playback. To switch back to digital CD playback, click Organize, click Options, and then use the Devices tab.%0
//
#define NS_E_SLOW_READ_DIGITAL           _HRESULT_TYPEDEF_(0xC00D0FA4L)

//
// MessageId: NS_E_MIXER_INVALID_LINE
//
// MessageText:
//
// An invalid line error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_LINE          _HRESULT_TYPEDEF_(0xC00D0FA5L)

//
// MessageId: NS_E_MIXER_INVALID_CONTROL
//
// MessageText:
//
// An invalid control error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_CONTROL       _HRESULT_TYPEDEF_(0xC00D0FA6L)

//
// MessageId: NS_E_MIXER_INVALID_VALUE
//
// MessageText:
//
// An invalid value error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_VALUE         _HRESULT_TYPEDEF_(0xC00D0FA7L)

//
// MessageId: NS_E_MIXER_UNKNOWN_MMRESULT
//
// MessageText:
//
// An unrecognized MMRESULT occurred in the mixer.%0
//
#define NS_E_MIXER_UNKNOWN_MMRESULT      _HRESULT_TYPEDEF_(0xC00D0FA8L)

//
// MessageId: NS_E_USER_STOP
//
// MessageText:
//
// User has stopped the operation.%0
//
#define NS_E_USER_STOP                   _HRESULT_TYPEDEF_(0xC00D0FA9L)

//
// MessageId: NS_E_MP3_FORMAT_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot rip the track because a compatible MP3 encoder is not installed on your computer. Install a compatible MP3 encoder or choose a different format to rip to (such as Windows Media Audio).%0
//
#define NS_E_MP3_FORMAT_NOT_FOUND        _HRESULT_TYPEDEF_(0xC00D0FAAL)

//
// MessageId: NS_E_CD_READ_ERROR_NO_CORRECTION
//
// MessageText:
//
// Windows Media Player cannot read the CD. The disc might be dirty or damaged. Turn on error correction, and then try again.%0
//
#define NS_E_CD_READ_ERROR_NO_CORRECTION _HRESULT_TYPEDEF_(0xC00D0FABL)

//
// MessageId: NS_E_CD_READ_ERROR
//
// MessageText:
//
// Windows Media Player cannot read the CD. The disc might be dirty or damaged or the CD drive might be malfunctioning.%0
//
#define NS_E_CD_READ_ERROR               _HRESULT_TYPEDEF_(0xC00D0FACL)

//
// MessageId: NS_E_CD_SLOW_COPY
//
// MessageText:
//
// For best performance, do not play CD tracks while ripping them.%0
//
#define NS_E_CD_SLOW_COPY                _HRESULT_TYPEDEF_(0xC00D0FADL)

//
// MessageId: NS_E_CD_COPYTO_CD
//
// MessageText:
//
// It is not possible to directly burn tracks from one CD to another CD. You must first rip the tracks from the CD to your computer, and then burn the files to a blank CD.%0
//
#define NS_E_CD_COPYTO_CD                _HRESULT_TYPEDEF_(0xC00D0FAEL)

//
// MessageId: NS_E_MIXER_NODRIVER
//
// MessageText:
//
// Could not open a sound mixer driver.%0
//
#define NS_E_MIXER_NODRIVER              _HRESULT_TYPEDEF_(0xC00D0FAFL)

//
// MessageId: NS_E_REDBOOK_ENABLED_WHILE_COPYING
//
// MessageText:
//
// Windows Media Player cannot rip tracks from the CD correctly because the CD drive settings in Device Manager do not match the CD drive settings in the Player.%0
//
#define NS_E_REDBOOK_ENABLED_WHILE_COPYING _HRESULT_TYPEDEF_(0xC00D0FB0L)

//
// MessageId: NS_E_CD_REFRESH
//
// MessageText:
//
// Windows Media Player is busy reading the CD.%0
//
#define NS_E_CD_REFRESH                  _HRESULT_TYPEDEF_(0xC00D0FB1L)

//
// MessageId: NS_E_CD_DRIVER_PROBLEM
//
// MessageText:
//
// Windows Media Player could not use digital playback to play the CD. The Player has automatically switched the CD drive to analog playback. To switch back to digital CD playback, click Organize, click options, and use the Devices tab.%0
//
#define NS_E_CD_DRIVER_PROBLEM           _HRESULT_TYPEDEF_(0xC00D0FB2L)

//
// MessageId: NS_E_WONT_DO_DIGITAL
//
// MessageText:
//
// Windows Media Player could not use digital playback to play the CD. The Player has automatically switched the CD drive to analog playback. To switch back to digital CD playback, click Organize, click options,and use the Devices tab.%0
//
#define NS_E_WONT_DO_DIGITAL             _HRESULT_TYPEDEF_(0xC00D0FB3L)

//
// WMP IWMPXMLParser Error codes
//
//
// MessageId: NS_E_WMPXML_NOERROR
//
// MessageText:
//
// A call was made to GetParseError on the XML parser but there was no error to retrieve.%0
//
#define NS_E_WMPXML_NOERROR              _HRESULT_TYPEDEF_(0xC00D0FB4L)

//
// MessageId: NS_E_WMPXML_ENDOFDATA
//
// MessageText:
//
// The XML Parser ran out of data while parsing.%0
//
#define NS_E_WMPXML_ENDOFDATA            _HRESULT_TYPEDEF_(0xC00D0FB5L)

//
// MessageId: NS_E_WMPXML_PARSEERROR
//
// MessageText:
//
// A generic parse error occurred in the XML parser but no information is available.%0
//
#define NS_E_WMPXML_PARSEERROR           _HRESULT_TYPEDEF_(0xC00D0FB6L)

//
// MessageId: NS_E_WMPXML_ATTRIBUTENOTFOUND
//
// MessageText:
//
// A call get GetNamedAttribute or GetNamedAttributeIndex on the XML parser resulted in the index not being found.%0
//
#define NS_E_WMPXML_ATTRIBUTENOTFOUND    _HRESULT_TYPEDEF_(0xC00D0FB7L)

//
// MessageId: NS_E_WMPXML_PINOTFOUND
//
// MessageText:
//
// A call was made go GetNamedPI on the XML parser, but the requested Processing Instruction was not found.%0
//
#define NS_E_WMPXML_PINOTFOUND           _HRESULT_TYPEDEF_(0xC00D0FB8L)

//
// MessageId: NS_E_WMPXML_EMPTYDOC
//
// MessageText:
//
// Persist was called on the XML parser, but the parser has no data to persist.%0
//
#define NS_E_WMPXML_EMPTYDOC             _HRESULT_TYPEDEF_(0xC00D0FB9L)

//
// Miscellaneous Media Player Error codes
//
//
// MessageId: NS_E_WMP_PATH_ALREADY_IN_LIBRARY
//
// MessageText:
//
// This file path is already in the library.%0
//
#define NS_E_WMP_PATH_ALREADY_IN_LIBRARY _HRESULT_TYPEDEF_(0xC00D0FBAL)

//
// MessageId: NS_E_WMP_FILESCANALREADYSTARTED
//
// MessageText:
//
// Windows Media Player is already searching for files to add to your library. Wait for the current process to finish before attempting to search again.%0
//
#define NS_E_WMP_FILESCANALREADYSTARTED  _HRESULT_TYPEDEF_(0xC00D0FBEL)

//
// MessageId: NS_E_WMP_HME_INVALIDOBJECTID
//
// MessageText:
//
// Windows Media Player is unable to find the media you are looking for.%0
//
#define NS_E_WMP_HME_INVALIDOBJECTID     _HRESULT_TYPEDEF_(0xC00D0FBFL)

//
// MessageId: NS_E_WMP_MF_CODE_EXPIRED
//
// MessageText:
//
// A component of Windows Media Player is out-of-date. If you are running a pre-release version of Windows, try upgrading to a more recent version.%0
//
#define NS_E_WMP_MF_CODE_EXPIRED         _HRESULT_TYPEDEF_(0xC00D0FC0L)

//
// MessageId: NS_E_WMP_HME_NOTSEARCHABLEFORITEMS
//
// MessageText:
//
// This container does not support search on items.%0
//
#define NS_E_WMP_HME_NOTSEARCHABLEFORITEMS _HRESULT_TYPEDEF_(0xC00D0FC1L)

//
// MessageId: NS_E_WMP_HME_STALEREQUEST
//
// MessageText:
//
// The request could not be completed because the request does not match the current state of the media library.%0
//
#define NS_E_WMP_HME_STALEREQUEST        _HRESULT_TYPEDEF_(0xC00D0FC2L)

//
// MessageId: NS_E_WMP_ADDTOLIBRARY_FAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while adding one or more files to the library.%0
//
#define NS_E_WMP_ADDTOLIBRARY_FAILED     _HRESULT_TYPEDEF_(0xC00D0FC7L)

//
// MessageId: NS_E_WMP_WINDOWSAPIFAILURE
//
// MessageText:
//
// A Windows API call failed but no error information was available.%0
//
#define NS_E_WMP_WINDOWSAPIFAILURE       _HRESULT_TYPEDEF_(0xC00D0FC8L)

//
// MessageId: NS_E_WMP_RECORDING_NOT_ALLOWED
//
// MessageText:
//
// This file does not have burn rights. If you obtained this file from an online store, go to the online store to get burn rights.%0
//
#define NS_E_WMP_RECORDING_NOT_ALLOWED   _HRESULT_TYPEDEF_(0xC00D0FC9L)

//
// MessageId: NS_E_DEVICE_NOT_READY
//
// MessageText:
//
// Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and then try to sync the file again.%0
//
#define NS_E_DEVICE_NOT_READY            _HRESULT_TYPEDEF_(0xC00D0FCAL)

//
// MessageId: NS_E_DAMAGED_FILE
//
// MessageText:
//
// Windows Media Player cannot play the file because it is corrupted.%0
//
#define NS_E_DAMAGED_FILE                _HRESULT_TYPEDEF_(0xC00D0FCBL)

//
// MessageId: NS_E_MPDB_GENERIC
//
// MessageText:
//
// Windows Media Player encountered an error while attempting to access information in the library. Try restarting the Player.%0
//
#define NS_E_MPDB_GENERIC                _HRESULT_TYPEDEF_(0xC00D0FCCL)

//
// MessageId: NS_E_FILE_FAILED_CHECKS
//
// MessageText:
//
// The file cannot be added to the library.%0
//
#define NS_E_FILE_FAILED_CHECKS          _HRESULT_TYPEDEF_(0xC00D0FCDL)

//
// MessageId: NS_E_MEDIA_LIBRARY_FAILED
//
// MessageText:
//
// Windows Media Player cannot create the library. You must be logged on as an administrator or a member of the Administrators group to install the Player. For more information, contact your system administrator.%0
//
#define NS_E_MEDIA_LIBRARY_FAILED        _HRESULT_TYPEDEF_(0xC00D0FCEL)

//
// MessageId: NS_E_SHARING_VIOLATION
//
// MessageText:
//
// The file is already in use. Close other programs that might be using the file, or stop playing the file, and then try again.%0
//
#define NS_E_SHARING_VIOLATION           _HRESULT_TYPEDEF_(0xC00D0FCFL)

//
// MessageId: NS_E_NO_ERROR_STRING_FOUND
//
// MessageText:
//
// Windows Media Player has encountered an unknown error.%0
//
#define NS_E_NO_ERROR_STRING_FOUND       _HRESULT_TYPEDEF_(0xC00D0FD0L)

//
// MessageId: NS_E_WMPOCX_NO_REMOTE_CORE
//
// MessageText:
//
// The Windows Media Player ActiveX control cannot connect to remote media services, but will continue with local media services.%0
//
#define NS_E_WMPOCX_NO_REMOTE_CORE       _HRESULT_TYPEDEF_(0xC00D0FD1L)

//
// MessageId: NS_E_WMPOCX_NO_ACTIVE_CORE
//
// MessageText:
//
// The requested method or property is not available because the Windows Media Player ActiveX control has not been properly activated.%0
//
#define NS_E_WMPOCX_NO_ACTIVE_CORE       _HRESULT_TYPEDEF_(0xC00D0FD2L)

//
// MessageId: NS_E_WMPOCX_NOT_RUNNING_REMOTELY
//
// MessageText:
//
// The Windows Media Player ActiveX control is not running in remote mode.%0
//
#define NS_E_WMPOCX_NOT_RUNNING_REMOTELY _HRESULT_TYPEDEF_(0xC00D0FD3L)

//
// MessageId: NS_E_WMPOCX_NO_REMOTE_WINDOW
//
// MessageText:
//
// An error occurred while trying to get the remote Windows Media Player window.%0
//
#define NS_E_WMPOCX_NO_REMOTE_WINDOW     _HRESULT_TYPEDEF_(0xC00D0FD4L)

//
// MessageId: NS_E_WMPOCX_ERRORMANAGERNOTAVAILABLE
//
// MessageText:
//
// Windows Media Player has encountered an unknown error.%0
//
#define NS_E_WMPOCX_ERRORMANAGERNOTAVAILABLE _HRESULT_TYPEDEF_(0xC00D0FD5L)

//
// MessageId: NS_E_PLUGIN_NOTSHUTDOWN
//
// MessageText:
//
// Windows Media Player was not closed properly. A damaged or incompatible plug-in might have caused the problem to occur. As a precaution, all optional plug-ins have been disabled.%0
//
#define NS_E_PLUGIN_NOTSHUTDOWN          _HRESULT_TYPEDEF_(0xC00D0FD6L)

//
// MessageId: NS_E_WMP_CANNOT_FIND_FOLDER
//
// MessageText:
//
// Windows Media Player cannot find the specified path. Verify that the path is typed correctly. If it is, the path does not exist in the specified location, or the computer where the path is located is not available.%0
//
#define NS_E_WMP_CANNOT_FIND_FOLDER      _HRESULT_TYPEDEF_(0xC00D0FD7L)

//
// MessageId: NS_E_WMP_STREAMING_RECORDING_NOT_ALLOWED
//
// MessageText:
//
// Windows Media Player cannot save a file that is being streamed.%0
//
#define NS_E_WMP_STREAMING_RECORDING_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D0FD8L)

//
// MessageId: NS_E_WMP_PLUGINDLL_NOTFOUND
//
// MessageText:
//
// Windows Media Player cannot find the selected plug-in. The Player will try to remove it from the menu. To use this plug-in, install it again.%0
//
#define NS_E_WMP_PLUGINDLL_NOTFOUND      _HRESULT_TYPEDEF_(0xC00D0FD9L)

//
// MessageId: NS_E_NEED_TO_ASK_USER
//
// MessageText:
//
// Action requires input from the user.%0
//
#define NS_E_NEED_TO_ASK_USER            _HRESULT_TYPEDEF_(0xC00D0FDAL)

//
// MessageId: NS_E_WMPOCX_PLAYER_NOT_DOCKED
//
// MessageText:
//
// The Windows Media Player ActiveX control must be in a docked state for this action to be performed.%0
//
#define NS_E_WMPOCX_PLAYER_NOT_DOCKED    _HRESULT_TYPEDEF_(0xC00D0FDBL)

//
// MessageId: NS_E_WMP_EXTERNAL_NOTREADY
//
// MessageText:
//
// The Windows Media Player external object is not ready.%0
//
#define NS_E_WMP_EXTERNAL_NOTREADY       _HRESULT_TYPEDEF_(0xC00D0FDCL)

//
// MessageId: NS_E_WMP_MLS_STALE_DATA
//
// MessageText:
//
// Windows Media Player cannot perform the requested action. Your computer's time and date might not be set correctly.%0
//
#define NS_E_WMP_MLS_STALE_DATA          _HRESULT_TYPEDEF_(0xC00D0FDDL)    

//
// Generic Media PlayerUI error codes
//
//
// MessageId: NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED
//
// MessageText:
//
// The control (%s) does not support creation of sub-controls, yet (%d) sub-controls have been specified.%0
//
#define NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED _HRESULT_TYPEDEF_(0xC00D0FDEL)

//
// MessageId: NS_E_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
// Version mismatch: (%.1f required, %.1f found).%0
//
#define NS_E_WMP_UI_VERSIONMISMATCH      _HRESULT_TYPEDEF_(0xC00D0FDFL)

//
// MessageId: NS_E_WMP_UI_NOTATHEMEFILE
//
// MessageText:
//
// The layout manager was given valid XML that wasn't a theme file.%0
//
#define NS_E_WMP_UI_NOTATHEMEFILE        _HRESULT_TYPEDEF_(0xC00D0FE0L)

//
// MessageId: NS_E_WMP_UI_SUBELEMENTNOTFOUND
//
// MessageText:
//
// The %s subelement could not be found on the %s object.%0
//
#define NS_E_WMP_UI_SUBELEMENTNOTFOUND   _HRESULT_TYPEDEF_(0xC00D0FE1L)

//
// MessageId: NS_E_WMP_UI_VERSIONPARSE
//
// MessageText:
//
// An error occurred parsing the version tag.\nValid version tags are of the form:\n\n\t<?wmp version='1.0'?>.%0
//
#define NS_E_WMP_UI_VERSIONPARSE         _HRESULT_TYPEDEF_(0xC00D0FE2L)

//
// MessageId: NS_E_WMP_UI_VIEWIDNOTFOUND
//
// MessageText:
//
// The view specified in for the 'currentViewID' property (%s) was not found in this theme file.%0
//
#define NS_E_WMP_UI_VIEWIDNOTFOUND       _HRESULT_TYPEDEF_(0xC00D0FE3L)

//
// MessageId: NS_E_WMP_UI_PASSTHROUGH
//
// MessageText:
//
// This error used internally for hit testing.%0
//
#define NS_E_WMP_UI_PASSTHROUGH          _HRESULT_TYPEDEF_(0xC00D0FE4L)

//
// MessageId: NS_E_WMP_UI_OBJECTNOTFOUND
//
// MessageText:
//
// Attributes were specified for the %s object, but the object was not available to send them to.%0
//
#define NS_E_WMP_UI_OBJECTNOTFOUND       _HRESULT_TYPEDEF_(0xC00D0FE5L)

//
// MessageId: NS_E_WMP_UI_SECONDHANDLER
//
// MessageText:
//
// The %s event already has a handler, the second handler was ignored.%0
//
#define NS_E_WMP_UI_SECONDHANDLER        _HRESULT_TYPEDEF_(0xC00D0FE6L)

//
// MessageId: NS_E_WMP_UI_NOSKININZIP
//
// MessageText:
//
// No .wms file found in skin archive.%0
//
#define NS_E_WMP_UI_NOSKININZIP          _HRESULT_TYPEDEF_(0xC00D0FE7L)

//
// MessageId: NS_S_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
// An upgrade might be needed for the theme manager to correctly show this skin. Skin reports version: %.1f.%0
//
#define NS_S_WMP_UI_VERSIONMISMATCH      _HRESULT_TYPEDEF_(0x000D0FE8L)

//
// MessageId: NS_S_WMP_EXCEPTION
//
// MessageText:
//
// An error occurred in one of the UI components.%0
//
#define NS_S_WMP_EXCEPTION               _HRESULT_TYPEDEF_(0x000D0FE9L)

//
// MessageId: NS_E_WMP_URLDOWNLOADFAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while downloading the file.%0
//
#define NS_E_WMP_URLDOWNLOADFAILED       _HRESULT_TYPEDEF_(0xC00D0FEAL)

//
// MessageId: NS_E_WMPOCX_UNABLE_TO_LOAD_SKIN
//
// MessageText:
//
// The Windows Media Player ActiveX control cannot load the requested uiMode and cannot roll back to the existing uiMode.%0
//
#define NS_E_WMPOCX_UNABLE_TO_LOAD_SKIN  _HRESULT_TYPEDEF_(0xC00D0FEBL)

//
// MessageId: NS_E_WMP_INVALID_SKIN
//
// MessageText:
//
// Windows Media Player encountered a problem with the skin file. The skin file might not be valid.%0
//
#define NS_E_WMP_INVALID_SKIN            _HRESULT_TYPEDEF_(0xC00D0FECL)

//
// MessageId: NS_E_WMP_SENDMAILFAILED
//
// MessageText:
//
// Windows Media Player cannot send the link because your e-mail program is not responding. Verify that your e-mail program is configured properly, and then try again.%0
//
#define NS_E_WMP_SENDMAILFAILED          _HRESULT_TYPEDEF_(0xC00D0FEDL)

//
// MessageId: NS_E_WMP_LOCKEDINSKINMODE
//
// MessageText:
//
// Windows Media Player cannot switch to full mode because your computer administrator has locked this skin.%0
//
#define NS_E_WMP_LOCKEDINSKINMODE        _HRESULT_TYPEDEF_(0xC00D0FEEL)

//
// MessageId: NS_E_WMP_FAILED_TO_SAVE_FILE
//
// MessageText:
//
// Windows Media Player encountered a problem while saving the file.%0
//
#define NS_E_WMP_FAILED_TO_SAVE_FILE     _HRESULT_TYPEDEF_(0xC00D0FEFL)

//Save As
//
// MessageId: NS_E_WMP_SAVEAS_READONLY
//
// MessageText:
//
// Windows Media Player cannot overwrite a read-only file. Try using a different file name.%0
//
#define NS_E_WMP_SAVEAS_READONLY         _HRESULT_TYPEDEF_(0xC00D0FF0L)

//
// MessageId: NS_E_WMP_FAILED_TO_SAVE_PLAYLIST
//
// MessageText:
//
// Windows Media Player encountered a problem while creating or saving the playlist.%0
//
#define NS_E_WMP_FAILED_TO_SAVE_PLAYLIST _HRESULT_TYPEDEF_(0xC00D0FF1L)

//
// MessageId: NS_E_WMP_FAILED_TO_OPEN_WMD
//
// MessageText:
//
// Windows Media Player cannot open the Windows Media Download file. The file might be damaged.%0
//
#define NS_E_WMP_FAILED_TO_OPEN_WMD      _HRESULT_TYPEDEF_(0xC00D0FF2L)

//
// MessageId: NS_E_WMP_CANT_PLAY_PROTECTED
//
// MessageText:
//
// The file cannot be added to the library because it is a protected DVR-MS file. This content cannot be played back by Windows Media Player.%0
//
#define NS_E_WMP_CANT_PLAY_PROTECTED     _HRESULT_TYPEDEF_(0xC00D0FF3L)

//
// MessageId: NS_E_SHARING_STATE_OUT_OF_SYNC
//
// MessageText:
//
// Media sharing has been turned off because a required Windows setting or component has changed.%0
//
#define NS_E_SHARING_STATE_OUT_OF_SYNC   _HRESULT_TYPEDEF_(0xC00D0FF4L)

// Additional remoting error(s)
//
// MessageId: NS_E_WMPOCX_REMOTE_PLAYER_ALREADY_RUNNING
//
// MessageText:
//
// Exclusive Services launch failed because the Windows Media Player is already running.%0
//
#define NS_E_WMPOCX_REMOTE_PLAYER_ALREADY_RUNNING _HRESULT_TYPEDEF_(0xC00D0FFAL)

//
// WMP Regional button control
//
//
// MessageId: NS_E_WMP_RBC_JPGMAPPINGIMAGE
//
// MessageText:
//
// JPG Images are not recommended for use as a mappingImage.%0
//
#define NS_E_WMP_RBC_JPGMAPPINGIMAGE     _HRESULT_TYPEDEF_(0xC00D1004L)

//
// MessageId: NS_E_WMP_JPGTRANSPARENCY
//
// MessageText:
//
// JPG Images are not recommended when using a transparencyColor.%0
//
#define NS_E_WMP_JPGTRANSPARENCY         _HRESULT_TYPEDEF_(0xC00D1005L)

//
// WMP Slider control
//
//
// MessageId: NS_E_WMP_INVALID_MAX_VAL
//
// MessageText:
//
// The Max property cannot be less than Min property.%0
//
#define NS_E_WMP_INVALID_MAX_VAL         _HRESULT_TYPEDEF_(0xC00D1009L)

//
// MessageId: NS_E_WMP_INVALID_MIN_VAL
//
// MessageText:
//
// The Min property cannot be greater than Max property.%0
//
#define NS_E_WMP_INVALID_MIN_VAL         _HRESULT_TYPEDEF_(0xC00D100AL)

//
// WMP CustomSlider control
//
//
// MessageId: NS_E_WMP_CS_JPGPOSITIONIMAGE
//
// MessageText:
//
// JPG Images are not recommended for use as a positionImage.%0
//
#define NS_E_WMP_CS_JPGPOSITIONIMAGE     _HRESULT_TYPEDEF_(0xC00D100EL)

//
// MessageId: NS_E_WMP_CS_NOTEVENLYDIVISIBLE
//
// MessageText:
//
// The (%s) image's size is not evenly divisible by the positionImage's size.%0
//
#define NS_E_WMP_CS_NOTEVENLYDIVISIBLE   _HRESULT_TYPEDEF_(0xC00D100FL)

//
// WMP ZIP Decoder
//
//
// MessageId: NS_E_WMPZIP_NOTAZIPFILE
//
// MessageText:
//
// The ZIP reader opened a file and its signature did not match that of the ZIP files.%0
//
#define NS_E_WMPZIP_NOTAZIPFILE          _HRESULT_TYPEDEF_(0xC00D1018L)

//
// MessageId: NS_E_WMPZIP_CORRUPT
//
// MessageText:
//
// The ZIP reader has detected that the file is corrupted.%0
//
#define NS_E_WMPZIP_CORRUPT              _HRESULT_TYPEDEF_(0xC00D1019L)

//
// MessageId: NS_E_WMPZIP_FILENOTFOUND
//
// MessageText:
//
// GetFileStream, SaveToFile, or SaveTemp file was called on the ZIP reader with a file name that was not found in the ZIP file.%0
//
#define NS_E_WMPZIP_FILENOTFOUND         _HRESULT_TYPEDEF_(0xC00D101AL)

//
// WMP Image Decoding Error codes
//
//
// MessageId: NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED
//
// MessageText:
//
// Image type not supported.%0
//
#define NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D1022L)

//
// MessageId: NS_E_WMP_IMAGE_INVALID_FORMAT
//
// MessageText:
//
// Image file might be corrupt.%0
//
#define NS_E_WMP_IMAGE_INVALID_FORMAT    _HRESULT_TYPEDEF_(0xC00D1023L)

//
// MessageId: NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
// Unexpected end of file. GIF file might be corrupt.%0
//
#define NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE _HRESULT_TYPEDEF_(0xC00D1024L)

//
// MessageId: NS_E_WMP_GIF_INVALID_FORMAT
//
// MessageText:
//
// Invalid GIF file.%0
//
#define NS_E_WMP_GIF_INVALID_FORMAT      _HRESULT_TYPEDEF_(0xC00D1025L)

//
// MessageId: NS_E_WMP_GIF_BAD_VERSION_NUMBER
//
// MessageText:
//
// Invalid GIF version. Only 87a or 89a supported.%0
//
#define NS_E_WMP_GIF_BAD_VERSION_NUMBER  _HRESULT_TYPEDEF_(0xC00D1026L)

//
// MessageId: NS_E_WMP_GIF_NO_IMAGE_IN_FILE
//
// MessageText:
//
// No images found in GIF file.%0
//
#define NS_E_WMP_GIF_NO_IMAGE_IN_FILE    _HRESULT_TYPEDEF_(0xC00D1027L)

//
// MessageId: NS_E_WMP_PNG_INVALIDFORMAT
//
// MessageText:
//
// Invalid PNG image file format.%0
//
#define NS_E_WMP_PNG_INVALIDFORMAT       _HRESULT_TYPEDEF_(0xC00D1028L)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH
//
// MessageText:
//
// PNG bitdepth not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH _HRESULT_TYPEDEF_(0xC00D1029L)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
// Compression format defined in PNG file not supported,%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION _HRESULT_TYPEDEF_(0xC00D102AL)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_FILTER
//
// MessageText:
//
// Filter method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_FILTER  _HRESULT_TYPEDEF_(0xC00D102BL)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_INTERLACE
//
// MessageText:
//
// Interlace method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_INTERLACE _HRESULT_TYPEDEF_(0xC00D102CL)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC
//
// MessageText:
//
// Bad CRC in PNG file.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC _HRESULT_TYPEDEF_(0xC00D102DL)

//
// MessageId: NS_E_WMP_BMP_INVALID_BITMASK
//
// MessageText:
//
// Invalid bitmask in BMP file.%0
//
#define NS_E_WMP_BMP_INVALID_BITMASK     _HRESULT_TYPEDEF_(0xC00D102EL)

//
// MessageId: NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED
//
// MessageText:
//
// Topdown DIB not supported.%0
//
#define NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D102FL)

//
// MessageId: NS_E_WMP_BMP_BITMAP_NOT_CREATED
//
// MessageText:
//
// Bitmap could not be created.%0
//
#define NS_E_WMP_BMP_BITMAP_NOT_CREATED  _HRESULT_TYPEDEF_(0xC00D1030L)

//
// MessageId: NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED
//
// MessageText:
//
// Compression format defined in BMP not supported.%0
//
#define NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D1031L)

//
// MessageId: NS_E_WMP_BMP_INVALID_FORMAT
//
// MessageText:
//
// Invalid Bitmap format.%0
//
#define NS_E_WMP_BMP_INVALID_FORMAT      _HRESULT_TYPEDEF_(0xC00D1032L)

//
// MessageId: NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL
//
// MessageText:
//
// JPEG Arithmetic coding not supported.%0
//
#define NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL _HRESULT_TYPEDEF_(0xC00D1033L)

//
// MessageId: NS_E_WMP_JPG_INVALID_FORMAT
//
// MessageText:
//
// Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_INVALID_FORMAT      _HRESULT_TYPEDEF_(0xC00D1034L)

//
// MessageId: NS_E_WMP_JPG_BAD_DCTSIZE
//
// MessageText:
//
// Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_BAD_DCTSIZE         _HRESULT_TYPEDEF_(0xC00D1035L)

//
// MessageId: NS_E_WMP_JPG_BAD_VERSION_NUMBER
//
// MessageText:
//
// Internal version error. Unexpected JPEG library version.%0
//
#define NS_E_WMP_JPG_BAD_VERSION_NUMBER  _HRESULT_TYPEDEF_(0xC00D1036L)

//
// MessageId: NS_E_WMP_JPG_BAD_PRECISION
//
// MessageText:
//
// Internal JPEG Library error. Unsupported JPEG data precision.%0
//
#define NS_E_WMP_JPG_BAD_PRECISION       _HRESULT_TYPEDEF_(0xC00D1037L)

//
// MessageId: NS_E_WMP_JPG_CCIR601_NOTIMPL
//
// MessageText:
//
// JPEG CCIR601 not supported.%0
//
#define NS_E_WMP_JPG_CCIR601_NOTIMPL     _HRESULT_TYPEDEF_(0xC00D1038L)

//
// MessageId: NS_E_WMP_JPG_NO_IMAGE_IN_FILE
//
// MessageText:
//
// No image found in JPEG file.%0
//
#define NS_E_WMP_JPG_NO_IMAGE_IN_FILE    _HRESULT_TYPEDEF_(0xC00D1039L)

//
// MessageId: NS_E_WMP_JPG_READ_ERROR
//
// MessageText:
//
// Could not read JPEG file.%0
//
#define NS_E_WMP_JPG_READ_ERROR          _HRESULT_TYPEDEF_(0xC00D103AL)

//
// MessageId: NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL
//
// MessageText:
//
// JPEG Fractional sampling not supported.%0
//
#define NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL _HRESULT_TYPEDEF_(0xC00D103BL)

//
// MessageId: NS_E_WMP_JPG_IMAGE_TOO_BIG
//
// MessageText:
//
// JPEG image too large. Maximum image size supported is 65500 X 65500.%0
//
#define NS_E_WMP_JPG_IMAGE_TOO_BIG       _HRESULT_TYPEDEF_(0xC00D103CL)

//
// MessageId: NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
// Unexpected end of file reached in JPEG file.%0
//
#define NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE _HRESULT_TYPEDEF_(0xC00D103DL)

//
// MessageId: NS_E_WMP_JPG_SOF_UNSUPPORTED
//
// MessageText:
//
// Unsupported JPEG SOF marker found.%0
//
#define NS_E_WMP_JPG_SOF_UNSUPPORTED     _HRESULT_TYPEDEF_(0xC00D103EL)

//
// MessageId: NS_E_WMP_JPG_UNKNOWN_MARKER
//
// MessageText:
//
// Unknown JPEG marker found.%0
//
#define NS_E_WMP_JPG_UNKNOWN_MARKER      _HRESULT_TYPEDEF_(0xC00D103FL)

//
// MessageId: NS_S_WMP_LOADED_GIF_IMAGE
//
// MessageText:
//
// Successfully loaded a GIF file.%0
//
#define NS_S_WMP_LOADED_GIF_IMAGE        _HRESULT_TYPEDEF_(0x000D1040L)

//
// MessageId: NS_S_WMP_LOADED_PNG_IMAGE
//
// MessageText:
//
// Successfully loaded a PNG file.%0
//
#define NS_S_WMP_LOADED_PNG_IMAGE        _HRESULT_TYPEDEF_(0x000D1041L)

//
// MessageId: NS_S_WMP_LOADED_BMP_IMAGE
//
// MessageText:
//
// Successfully loaded a BMP file.%0
//
#define NS_S_WMP_LOADED_BMP_IMAGE        _HRESULT_TYPEDEF_(0x000D1042L)

//
// MessageId: NS_S_WMP_LOADED_JPG_IMAGE
//
// MessageText:
//
// Successfully loaded a JPG file.%0
//
#define NS_S_WMP_LOADED_JPG_IMAGE        _HRESULT_TYPEDEF_(0x000D1043L)

//
// MessageId: NS_E_WMP_FAILED_TO_OPEN_IMAGE
//
// MessageText:
//
// Windows Media Player cannot display the picture file. The player either does not support the picture type or the picture is corrupted.%0
//
#define NS_E_WMP_FAILED_TO_OPEN_IMAGE    _HRESULT_TYPEDEF_(0xC00D1044L)

//
// WMP DAI Error code
//
//
// MessageId: NS_E_WMP_DAI_SONGTOOSHORT
//
// MessageText:
//
// Windows Media Player cannot compute a Digital Audio Id for the song. It is too short.%0
//
#define NS_E_WMP_DAI_SONGTOOSHORT        _HRESULT_TYPEDEF_(0xC00D1049L)

//
// WMP WM Runtime Error codes
//
//
// MessageId: NS_E_WMG_RATEUNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot play the file at the requested speed.%0
//
#define NS_E_WMG_RATEUNAVAILABLE         _HRESULT_TYPEDEF_(0xC00D104AL)

//
// MessageId: NS_E_WMG_PLUGINUNAVAILABLE
//
// MessageText:
//
// The rendering or digital signal processing plug-in cannot be instantiated.%0
//
#define NS_E_WMG_PLUGINUNAVAILABLE       _HRESULT_TYPEDEF_(0xC00D104BL)

//
// MessageId: NS_E_WMG_CANNOTQUEUE
//
// MessageText:
//
// The file cannot be queued for seamless playback.%0
//
#define NS_E_WMG_CANNOTQUEUE             _HRESULT_TYPEDEF_(0xC00D104CL)

//
// MessageId: NS_E_WMG_PREROLLLICENSEACQUISITIONNOTALLOWED
//
// MessageText:
//
// Windows Media Player cannot download media usage rights for a file in the playlist.%0
//
#define NS_E_WMG_PREROLLLICENSEACQUISITIONNOTALLOWED _HRESULT_TYPEDEF_(0xC00D104DL)

//
// MessageId: NS_E_WMG_UNEXPECTEDPREROLLSTATUS
//
// MessageText:
//
// Windows Media Player encountered an error while trying to queue a file.%0
//
#define NS_E_WMG_UNEXPECTEDPREROLLSTATUS _HRESULT_TYPEDEF_(0xC00D104EL)

//
// MessageId: NS_S_WMG_FORCE_DROP_FRAME
//
// MessageText:
//
// Drop this frame.%0
//
#define NS_S_WMG_FORCE_DROP_FRAME        _HRESULT_TYPEDEF_(0x000D104FL)

//
// MessageId: NS_E_WMG_INVALID_COPP_CERTIFICATE
//
// MessageText:
//
// Windows Media Player cannot play the protected file. The Player cannot verify that the connection to your video card is secure. Try installing an updated device driver for your video card.%0
//
#define NS_E_WMG_INVALID_COPP_CERTIFICATE _HRESULT_TYPEDEF_(0xC00D1051L)

//
// MessageId: NS_E_WMG_COPP_SECURITY_INVALID
//
// MessageText:
//
// Windows Media Player cannot play the protected file. The Player detected that the connection to your hardware might not be secure.%0
//
#define NS_E_WMG_COPP_SECURITY_INVALID   _HRESULT_TYPEDEF_(0xC00D1052L)

//
// MessageId: NS_E_WMG_COPP_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player output link protection is unsupported on this system.%0
//
#define NS_E_WMG_COPP_UNSUPPORTED        _HRESULT_TYPEDEF_(0xC00D1053L)

//
// MessageId: NS_E_WMG_INVALIDSTATE
//
// MessageText:
//
// Operation attempted in an invalid graph state.%0
//
#define NS_E_WMG_INVALIDSTATE            _HRESULT_TYPEDEF_(0xC00D1054L)

//
// MessageId: NS_E_WMG_SINKALREADYEXISTS
//
// MessageText:
//
// A renderer cannot be inserted in a stream while one already exists.%0
//
#define NS_E_WMG_SINKALREADYEXISTS       _HRESULT_TYPEDEF_(0xC00D1055L)

//
// MessageId: NS_E_WMG_NOSDKINTERFACE
//
// MessageText:
//
// The Windows Media SDK interface needed to complete the operation does not exist at this time.%0
//
#define NS_E_WMG_NOSDKINTERFACE          _HRESULT_TYPEDEF_(0xC00D1056L)

//
// MessageId: NS_E_WMG_NOTALLOUTPUTSRENDERED
//
// MessageText:
//
// Windows Media Player cannot play a portion of the file because it requires a codec that either could not be downloaded or that is not supported by the Player.%0
//
#define NS_E_WMG_NOTALLOUTPUTSRENDERED   _HRESULT_TYPEDEF_(0xC00D1057L)

//
// MessageId: NS_E_WMG_FILETRANSFERNOTALLOWED
//
// MessageText:
//
// File transfer streams are not allowed in the standalone Player.%0
//
#define NS_E_WMG_FILETRANSFERNOTALLOWED  _HRESULT_TYPEDEF_(0xC00D1058L)

//
// MessageId: NS_E_WMR_UNSUPPORTEDSTREAM
//
// MessageText:
//
// Windows Media Player cannot play the file. The Player does not support the format you are trying to play.%0
//
#define NS_E_WMR_UNSUPPORTEDSTREAM       _HRESULT_TYPEDEF_(0xC00D1059L)

//
// MessageId: NS_E_WMR_PINNOTFOUND
//
// MessageText:
//
// An operation was attempted on a pin that does not exist in the DirectShow filter graph.%0
//
#define NS_E_WMR_PINNOTFOUND             _HRESULT_TYPEDEF_(0xC00D105AL)

//
// MessageId: NS_E_WMR_WAITINGONFORMATSWITCH
//
// MessageText:
//
// Specified operation cannot be completed while waiting for a media format change from the SDK.%0
//
#define NS_E_WMR_WAITINGONFORMATSWITCH   _HRESULT_TYPEDEF_(0xC00D105BL)

//
// MessageId: NS_E_WMR_NOSOURCEFILTER
//
// MessageText:
//
// Specified operation cannot be completed because the source filter does not exist.%0
//
#define NS_E_WMR_NOSOURCEFILTER          _HRESULT_TYPEDEF_(0xC00D105CL)

//
// MessageId: NS_E_WMR_PINTYPENOMATCH
//
// MessageText:
//
// The specified type does not match this pin.%0
//
#define NS_E_WMR_PINTYPENOMATCH          _HRESULT_TYPEDEF_(0xC00D105DL)

//
// MessageId: NS_E_WMR_NOCALLBACKAVAILABLE
//
// MessageText:
//
// The WMR Source Filter does not have a callback available.%0
//
#define NS_E_WMR_NOCALLBACKAVAILABLE     _HRESULT_TYPEDEF_(0xC00D105EL)

//
// MessageId: NS_S_WMR_ALREADYRENDERED
//
// MessageText:
//
// The specified stream has already been rendered.%0
//
#define NS_S_WMR_ALREADYRENDERED         _HRESULT_TYPEDEF_(0x000D105FL)

//
// MessageId: NS_S_WMR_PINTYPEPARTIALMATCH
//
// MessageText:
//
// The specified type partially matches this pin type.%0
//
#define NS_S_WMR_PINTYPEPARTIALMATCH     _HRESULT_TYPEDEF_(0x000D1060L)

//
// MessageId: NS_S_WMR_PINTYPEFULLMATCH
//
// MessageText:
//
// The specified type fully matches this pin type.%0
//
#define NS_S_WMR_PINTYPEFULLMATCH        _HRESULT_TYPEDEF_(0x000D1061L)

//
// MessageId: NS_E_WMR_SAMPLEPROPERTYNOTSET
//
// MessageText:
//
// The specified property has not been set on this sample.%0
//
#define NS_E_WMR_SAMPLEPROPERTYNOTSET    _HRESULT_TYPEDEF_(0xC00D1062L)

//
// MessageId: NS_E_WMR_CANNOT_RENDER_BINARY_STREAM
//
// MessageText:
//
// A plug-in is required to correctly play the file. To determine if the plug-in is available to download, click Web Help.%0
//
#define NS_E_WMR_CANNOT_RENDER_BINARY_STREAM _HRESULT_TYPEDEF_(0xC00D1063L)

//
// MessageId: NS_E_WMG_LICENSE_TAMPERED
//
// MessageText:
//
// Windows Media Player cannot play the file because your media usage rights are corrupted. If you previously backed up your media usage rights, try restoring them.%0
//
#define NS_E_WMG_LICENSE_TAMPERED        _HRESULT_TYPEDEF_(0xC00D1064L)

//
// MessageId: NS_E_WMR_WILLNOT_RENDER_BINARY_STREAM
//
// MessageText:
//
// Windows Media Player cannot play protected files that contain binary streams.%0
//
#define NS_E_WMR_WILLNOT_RENDER_BINARY_STREAM _HRESULT_TYPEDEF_(0xC00D1065L)

//
// MessageId: NS_S_WMG_ADVISE_DROP_FRAME
//
// MessageText:
//
// The timestamp is late compared to the current render position. Advise dropping this frame.%0
//
#define NS_S_WMG_ADVISE_DROP_FRAME       _HRESULT_TYPEDEF_(0x000D1066L)

//
// MessageId: NS_S_WMG_ADVISE_DROP_TO_KEYFRAME
//
// MessageText:
//
// The timestamp is severely late compared to the current render position. Advise dropping everything up to the next key frame.%0
//
#define NS_S_WMG_ADVISE_DROP_TO_KEYFRAME _HRESULT_TYPEDEF_(0x000D1067L)

//
// WMP Playlist Error codes
//
//
// MessageId: NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT
//
// MessageText:
//
// Windows Media Player cannot play the playlist because it is not valid.%0
//
#define NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT _HRESULT_TYPEDEF_(0xC00D1068L)

//
// MessageId: NS_E_ASX_INVALIDFORMAT
//
// MessageText:
//
// Windows Media Player cannot play the playlist because it is not valid.%0
//
#define NS_E_ASX_INVALIDFORMAT           _HRESULT_TYPEDEF_(0xC00D1069L)

//
// MessageId: NS_E_ASX_INVALIDVERSION
//
// MessageText:
//
// A later version of Windows Media Player might be required to play this playlist.%0
//
#define NS_E_ASX_INVALIDVERSION          _HRESULT_TYPEDEF_(0xC00D106AL)

//
// MessageId: NS_E_ASX_INVALID_REPEAT_BLOCK
//
// MessageText:
//
// The format of a REPEAT loop within the current playlist file is not valid.%0
//
#define NS_E_ASX_INVALID_REPEAT_BLOCK    _HRESULT_TYPEDEF_(0xC00D106BL)

//
// MessageId: NS_E_ASX_NOTHING_TO_WRITE
//
// MessageText:
//
// Windows Media Player cannot save the playlist because it does not contain any items.%0
//
#define NS_E_ASX_NOTHING_TO_WRITE        _HRESULT_TYPEDEF_(0xC00D106CL)

//
// MessageId: NS_E_URLLIST_INVALIDFORMAT
//
// MessageText:
//
// Windows Media Player cannot play the playlist because it is not valid.%0
//
#define NS_E_URLLIST_INVALIDFORMAT       _HRESULT_TYPEDEF_(0xC00D106DL)

//
// MessageId: NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST
//
// MessageText:
//
// The specified attribute does not exist.%0
//
#define NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST _HRESULT_TYPEDEF_(0xC00D106EL)

//
// MessageId: NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS
//
// MessageText:
//
// The specified attribute already exists.%0
//
#define NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS _HRESULT_TYPEDEF_(0xC00D106FL)

//
// MessageId: NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE
//
// MessageText:
//
// Cannot retrieve the specified attribute.%0
//
#define NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE _HRESULT_TYPEDEF_(0xC00D1070L)

//
// MessageId: NS_E_WMX_ITEM_DOES_NOT_EXIST
//
// MessageText:
//
// The specified item does not exist in the current playlist.%0
//
#define NS_E_WMX_ITEM_DOES_NOT_EXIST     _HRESULT_TYPEDEF_(0xC00D1071L)

//
// MessageId: NS_E_WMX_ITEM_TYPE_ILLEGAL
//
// MessageText:
//
// Items of the specified type cannot be created within the current playlist.%0
//
#define NS_E_WMX_ITEM_TYPE_ILLEGAL       _HRESULT_TYPEDEF_(0xC00D1072L)

//
// MessageId: NS_E_WMX_ITEM_UNSETTABLE
//
// MessageText:
//
// The specified item cannot be set in the current playlist.%0
//
#define NS_E_WMX_ITEM_UNSETTABLE         _HRESULT_TYPEDEF_(0xC00D1073L)

//
// MessageId: NS_E_WMX_PLAYLIST_EMPTY
//
// MessageText:
//
// Windows Media Player cannot perform the requested action because the playlist does not contain any items.%0
//
#define NS_E_WMX_PLAYLIST_EMPTY          _HRESULT_TYPEDEF_(0xC00D1074L)

//
// MessageId: NS_E_MLS_SMARTPLAYLIST_FILTER_NOT_REGISTERED
//
// MessageText:
//
// The specified auto playlist contains a filter type that is either not valid or is not installed on this computer.%0
//
#define NS_E_MLS_SMARTPLAYLIST_FILTER_NOT_REGISTERED _HRESULT_TYPEDEF_(0xC00D1075L)

//
// MessageId: NS_E_WMX_INVALID_FORMAT_OVER_NESTING
//
// MessageText:
//
// Windows Media Player cannot play the file because the associated playlist contains too many nested playlists.%0
//
#define NS_E_WMX_INVALID_FORMAT_OVER_NESTING _HRESULT_TYPEDEF_(0xC00D1076L)

//
// WMP Core  Error codes
//
//
// MessageId: NS_E_WMPCORE_NOSOURCEURLSTRING
//
// MessageText:
//
// Windows Media Player cannot find the file. Verify that the path is typed correctly. If it is, the file might not exist in the specified location, or the computer where the file is stored might not be available.%0
//
#define NS_E_WMPCORE_NOSOURCEURLSTRING   _HRESULT_TYPEDEF_(0xC00D107CL)

//
// MessageId: NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT
//
// MessageText:
//
// Failed to create the Global Interface Table.%0
//
#define NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT _HRESULT_TYPEDEF_(0xC00D107DL)

//
// MessageId: NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE
//
// MessageText:
//
// Failed to get the marshaled graph event handler interface.%0
//
#define NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE _HRESULT_TYPEDEF_(0xC00D107EL)

//
// MessageId: NS_E_WMPCORE_BUFFERTOOSMALL
//
// MessageText:
//
// Buffer is too small for copying media type.%0
//
#define NS_E_WMPCORE_BUFFERTOOSMALL      _HRESULT_TYPEDEF_(0xC00D107FL)

//
// MessageId: NS_E_WMPCORE_UNAVAILABLE
//
// MessageText:
//
// The current state of the Player does not allow this operation.%0
//
#define NS_E_WMPCORE_UNAVAILABLE         _HRESULT_TYPEDEF_(0xC00D1080L)

//
// MessageId: NS_E_WMPCORE_INVALIDPLAYLISTMODE
//
// MessageText:
//
// The playlist manager does not understand the current play mode (for example, shuffle or normal).%0
//
#define NS_E_WMPCORE_INVALIDPLAYLISTMODE _HRESULT_TYPEDEF_(0xC00D1081L)

//
// MessageId: NS_E_WMPCORE_ITEMNOTINPLAYLIST
//
// MessageText:
//
// Windows Media Player cannot play the file because it is not in the current playlist.%0
//
#define NS_E_WMPCORE_ITEMNOTINPLAYLIST   _HRESULT_TYPEDEF_(0xC00D1086L)

//
// MessageId: NS_E_WMPCORE_PLAYLISTEMPTY
//
// MessageText:
//
// There are no items in the playlist. Add items to the playlist, and then try again.%0
//
#define NS_E_WMPCORE_PLAYLISTEMPTY       _HRESULT_TYPEDEF_(0xC00D1087L)

//
// MessageId: NS_E_WMPCORE_NOBROWSER
//
// MessageText:
//
// The website cannot be displayed because no web browser is installed on your computer.%0
//
#define NS_E_WMPCORE_NOBROWSER           _HRESULT_TYPEDEF_(0xC00D1088L)

//
// MessageId: NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL
//
// MessageText:
//
// Windows Media Player cannot find the specified file. Verify the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is not available.%0
//
#define NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL _HRESULT_TYPEDEF_(0xC00D1089L)

//
// MessageId: NS_E_WMPCORE_GRAPH_NOT_IN_LIST
//
// MessageText:
//
// Graph with the specified URL was not found in the prerolled graph list.%0
//
#define NS_E_WMPCORE_GRAPH_NOT_IN_LIST   _HRESULT_TYPEDEF_(0xC00D108AL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA
//
// MessageText:
//
// Windows Media Player cannot perform the requested operation because there is only one item in the playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA _HRESULT_TYPEDEF_(0xC00D108BL)

//
// MessageId: NS_E_WMPCORE_ERRORSINKNOTREGISTERED
//
// MessageText:
//
// An error sink was never registered for the calling object.%0
//
#define NS_E_WMPCORE_ERRORSINKNOTREGISTERED _HRESULT_TYPEDEF_(0xC00D108CL)

//
// MessageId: NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE
//
// MessageText:
//
// The error manager is not available to respond to errors.%0
//
#define NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE _HRESULT_TYPEDEF_(0xC00D108DL)

//
// MessageId: NS_E_WMPCORE_WEBHELPFAILED
//
// MessageText:
//
// The Web Help URL cannot be opened.%0
//
#define NS_E_WMPCORE_WEBHELPFAILED       _HRESULT_TYPEDEF_(0xC00D108EL)

//
// MessageId: NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED
//
// MessageText:
//
// Could not resume playing next item in playlist.%0
//
#define NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED _HRESULT_TYPEDEF_(0xC00D108FL)

//
// MessageId: NS_E_WMPCORE_NO_REF_IN_ENTRY
//
// MessageText:
//
// Windows Media Player cannot play the file because the associated playlist does not contain any items or the playlist is not valid.%0
//
#define NS_E_WMPCORE_NO_REF_IN_ENTRY     _HRESULT_TYPEDEF_(0xC00D1090L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
// An empty string for playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY _HRESULT_TYPEDEF_(0xC00D1091L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
// A playlist attribute name that is not valid was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL _HRESULT_TYPEDEF_(0xC00D1092L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
// An empty string for a playlist attribute value was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY _HRESULT_TYPEDEF_(0xC00D1093L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL
//
// MessageText:
//
// An illegal value for a playlist attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL _HRESULT_TYPEDEF_(0xC00D1094L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
// An empty string for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY _HRESULT_TYPEDEF_(0xC00D1095L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
// An illegal value for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL _HRESULT_TYPEDEF_(0xC00D1096L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
// An illegal value for a playlist item attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY _HRESULT_TYPEDEF_(0xC00D1097L)

//
// MessageId: NS_E_WMPCORE_LIST_ENTRY_NO_REF
//
// MessageText:
//
// The playlist does not contain any items.%0
//
#define NS_E_WMPCORE_LIST_ENTRY_NO_REF   _HRESULT_TYPEDEF_(0xC00D1098L)

//
// MessageId: NS_E_WMPCORE_MISNAMED_FILE
//
// MessageText:
//
// Windows Media Player cannot play the file. The file is either corrupted or the Player does not support the format you are trying to play.%0
//
#define NS_E_WMPCORE_MISNAMED_FILE       _HRESULT_TYPEDEF_(0xC00D1099L)

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_TRUSTED
//
// MessageText:
//
// The codec downloaded for this file does not appear to be properly signed, so it cannot be installed.%0
//
#define NS_E_WMPCORE_CODEC_NOT_TRUSTED   _HRESULT_TYPEDEF_(0xC00D109AL)

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot play the file. One or more codecs required to play the file could not be found.%0
//
#define NS_E_WMPCORE_CODEC_NOT_FOUND     _HRESULT_TYPEDEF_(0xC00D109BL)

//
// MessageId: NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED
//
// MessageText:
//
// Windows Media Player cannot play the file because a required codec is not installed on your computer. To try downloading the codec, turn on the "Download codecs automatically" option.%0
//
#define NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D109CL)

//
// MessageId: NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST
//
// MessageText:
//
// Windows Media Player encountered a problem while downloading the playlist.%0
//
#define NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST _HRESULT_TYPEDEF_(0xC00D109DL)

//
// MessageId: NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST
//
// MessageText:
//
// Failed to build the playlist.%0
//
#define NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST _HRESULT_TYPEDEF_(0xC00D109EL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE
//
// MessageText:
//
// Playlist has no alternates to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE _HRESULT_TYPEDEF_(0xC00D109FL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED
//
// MessageText:
//
// No more playlist alternates available to switch to.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED _HRESULT_TYPEDEF_(0xC00D10A0L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND
//
// MessageText:
//
// Could not find the name of the alternate playlist to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D10A1L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED
//
// MessageText:
//
// Failed to switch to an alternate for this media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED _HRESULT_TYPEDEF_(0xC00D10A2L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED
//
// MessageText:
//
// Failed to initialize an alternate for the media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED _HRESULT_TYPEDEF_(0xC00D10A3L)

//
// MessageId: NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY
//
// MessageText:
//
// No URL specified for the roll over Refs in the playlist file.%0
//
#define NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY _HRESULT_TYPEDEF_(0xC00D10A4L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME
//
// MessageText:
//
// Encountered a playlist with no name.%0
//
#define NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME _HRESULT_TYPEDEF_(0xC00D10A5L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT
//
// MessageText:
//
// A required attribute in the event block of the playlist was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT _HRESULT_TYPEDEF_(0xC00D10A6L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY
//
// MessageText:
//
// No items were found in the event block of the playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY _HRESULT_TYPEDEF_(0xC00D10A7L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_STACK_EMPTY
//
// MessageText:
//
// No playlist was found while returning from a nested playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_STACK_EMPTY _HRESULT_TYPEDEF_(0xC00D10A8L)

//
// MessageId: NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE
//
// MessageText:
//
// The media item is not active currently.%0
//
#define NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE _HRESULT_TYPEDEF_(0xC00D10A9L)

//
// MessageId: NS_E_WMPCORE_USER_CANCEL
//
// MessageText:
//
// Windows Media Player cannot perform the requested action because you chose to cancel it.%0
//
#define NS_E_WMPCORE_USER_CANCEL         _HRESULT_TYPEDEF_(0xC00D10ABL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY
//
// MessageText:
//
// Windows Media Player encountered a problem with the playlist. The format of the playlist is not valid.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY _HRESULT_TYPEDEF_(0xC00D10ACL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE
//
// MessageText:
//
// Media object corresponding to start of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE _HRESULT_TYPEDEF_(0xC00D10ADL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE
//
// MessageText:
//
// Media object corresponding to the end of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE _HRESULT_TYPEDEF_(0xC00D10AEL)

//
// MessageId: NS_E_WMPCORE_INVALID_PLAYLIST_URL
//
// MessageText:
//
// The playlist URL supplied to the playlist manager is not valid.%0
//
#define NS_E_WMPCORE_INVALID_PLAYLIST_URL _HRESULT_TYPEDEF_(0xC00D10AFL)

//
// MessageId: NS_E_WMPCORE_MISMATCHED_RUNTIME
//
// MessageText:
//
// Windows Media Player cannot play the file because it is corrupted.%0
//
#define NS_E_WMPCORE_MISMATCHED_RUNTIME  _HRESULT_TYPEDEF_(0xC00D10B0L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS
//
// MessageText:
//
// Windows Media Player cannot add the playlist to the library because the playlist does not contain any items.%0
//
#define NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS _HRESULT_TYPEDEF_(0xC00D10B1L)

//
// MessageId: NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION
//
// MessageText:
//
// An error has occurred that could prevent the changing of the video contrast on this media.%0
//
#define NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION _HRESULT_TYPEDEF_(0xC00D10B2L)

//
// MessageId: NS_E_WMPCORE_MEDIA_UNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot play the file. If the file is located on the Internet, connect to the Internet. If the file is located on a removable storage card, insert the storage card.%0
//
#define NS_E_WMPCORE_MEDIA_UNAVAILABLE   _HRESULT_TYPEDEF_(0xC00D10B3L)

//
// MessageId: NS_E_WMPCORE_WMX_ENTRYREF_NO_REF
//
// MessageText:
//
// The playlist contains an ENTRYREF for which no href was parsed. Check the syntax of playlist file.%0
//
#define NS_E_WMPCORE_WMX_ENTRYREF_NO_REF _HRESULT_TYPEDEF_(0xC00D10B4L)

//
// MessageId: NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST
//
// MessageText:
//
// Windows Media Player cannot play any items in the playlist. To find information about the problem, click the icon next to each file in the list pane.%0
//
#define NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST _HRESULT_TYPEDEF_(0xC00D10B5L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS
//
// MessageText:
//
// Windows Media Player cannot play some or all of the items in the playlist because the playlist is nested.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS _HRESULT_TYPEDEF_(0xC00D10B6L)

//
// MessageId: NS_E_WMPCORE_BUSY
//
// MessageText:
//
// Windows Media Player cannot play the file at this time. Try again later.%0
//
#define NS_E_WMPCORE_BUSY                _HRESULT_TYPEDEF_(0xC00D10B7L)

//
// MessageId: NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE
//
// MessageText:
//
// There is no child playlist available for this media item at this time.%0
//
#define NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE _HRESULT_TYPEDEF_(0xC00D10B8L)

//
// MessageId: NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST
//
// MessageText:
//
// There is no child playlist for this media item.%0
//
#define NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST _HRESULT_TYPEDEF_(0xC00D10B9L)

//
// MessageId: NS_E_WMPCORE_FILE_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot find the file. The link from the item in the library to its associated digital media file might be broken. To fix the problem, try repairing the link or removing the item from the library.%0
//
#define NS_E_WMPCORE_FILE_NOT_FOUND      _HRESULT_TYPEDEF_(0xC00D10BAL)

//
// MessageId: NS_E_WMPCORE_TEMP_FILE_NOT_FOUND
//
// MessageText:
//
// The temporary file was not found.%0
//
#define NS_E_WMPCORE_TEMP_FILE_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D10BBL)

//
// MessageId: NS_E_WMDM_REVOKED
//
// MessageText:
//
// Windows Media Player cannot sync the file because the device needs to be updated.%0
//
#define NS_E_WMDM_REVOKED                _HRESULT_TYPEDEF_(0xC00D10BCL)

//
// MessageId: NS_E_DDRAW_GENERIC
//
// MessageText:
//
// Windows Media Player cannot play the video because there is a problem with your video card.%0
//
#define NS_E_DDRAW_GENERIC               _HRESULT_TYPEDEF_(0xC00D10BDL)

//
// MessageId: NS_E_DISPLAY_MODE_CHANGE_FAILED
//
// MessageText:
//
// Windows Media Player failed to change the screen mode for full-screen video playback.%0
//
#define NS_E_DISPLAY_MODE_CHANGE_FAILED  _HRESULT_TYPEDEF_(0xC00D10BEL)

//
// MessageId: NS_E_PLAYLIST_CONTAINS_ERRORS
//
// MessageText:
//
// Windows Media Player cannot play one or more files.  For additional information, right-click an item that cannot be played, and then click Error Details.%0
//
#define NS_E_PLAYLIST_CONTAINS_ERRORS    _HRESULT_TYPEDEF_(0xC00D10BFL)

//
// MessageId: NS_E_CHANGING_PROXY_NAME
//
// MessageText:
//
// Cannot change the proxy name if the proxy setting is not set to custom.%0
//
#define NS_E_CHANGING_PROXY_NAME         _HRESULT_TYPEDEF_(0xC00D10C0L)

//
// MessageId: NS_E_CHANGING_PROXY_PORT
//
// MessageText:
//
// Cannot change the proxy port if the proxy setting is not set to custom.%0
//
#define NS_E_CHANGING_PROXY_PORT         _HRESULT_TYPEDEF_(0xC00D10C1L)

//
// MessageId: NS_E_CHANGING_PROXY_EXCEPTIONLIST
//
// MessageText:
//
// Cannot change the proxy exception list if the proxy setting is not set to custom.%0
//
#define NS_E_CHANGING_PROXY_EXCEPTIONLIST _HRESULT_TYPEDEF_(0xC00D10C2L)

//
// MessageId: NS_E_CHANGING_PROXYBYPASS
//
// MessageText:
//
// Cannot change the proxy bypass flag if the proxy setting is not set to custom.%0
//
#define NS_E_CHANGING_PROXYBYPASS        _HRESULT_TYPEDEF_(0xC00D10C3L)

//
// MessageId: NS_E_CHANGING_PROXY_PROTOCOL_NOT_FOUND
//
// MessageText:
//
// Cannot find the specified protocol.%0
//
#define NS_E_CHANGING_PROXY_PROTOCOL_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D10C4L)

//
// MessageId: NS_E_GRAPH_NOAUDIOLANGUAGE
//
// MessageText:
//
// Cannot change the language settings. Either the graph has no audio or the audio only supports one language.%0
//
#define NS_E_GRAPH_NOAUDIOLANGUAGE       _HRESULT_TYPEDEF_(0xC00D10C5L)

//
// MessageId: NS_E_GRAPH_NOAUDIOLANGUAGESELECTED
//
// MessageText:
//
// The graph has no audio language selected.%0
//
#define NS_E_GRAPH_NOAUDIOLANGUAGESELECTED _HRESULT_TYPEDEF_(0xC00D10C6L)

//
// MessageId: NS_E_CORECD_NOTAMEDIACD
//
// MessageText:
//
// This is not a media CD.%0
//
#define NS_E_CORECD_NOTAMEDIACD          _HRESULT_TYPEDEF_(0xC00D10C7L)

//
// MessageId: NS_E_WMPCORE_MEDIA_URL_TOO_LONG
//
// MessageText:
//
// Windows Media Player cannot play the file because the URL is too long.%0
//
#define NS_E_WMPCORE_MEDIA_URL_TOO_LONG  _HRESULT_TYPEDEF_(0xC00D10C8L)

//
// MessageId: NS_E_WMPFLASH_CANT_FIND_COM_SERVER
//
// MessageText:
//
// To play the selected item, you must install the Adobe Flash Player. To download the Adobe Flash Player, go to the Adobe Web site.%0
//
#define NS_E_WMPFLASH_CANT_FIND_COM_SERVER _HRESULT_TYPEDEF_(0xC00D10C9L)

//
// MessageId: NS_E_WMPFLASH_INCOMPATIBLEVERSION
//
// MessageText:
//
// To play the selected item, you must install a later version of the Adobe Flash Player. To download the Adobe Flash Player, go to the Adobe website.%0
//
#define NS_E_WMPFLASH_INCOMPATIBLEVERSION _HRESULT_TYPEDEF_(0xC00D10CAL)

//
// MessageId: NS_E_WMPOCXGRAPH_IE_DISALLOWS_ACTIVEX_CONTROLS
//
// MessageText:
//
// Windows Media Player cannot play the file because your Internet security settings prohibit the use of ActiveX controls.%0
//
#define NS_E_WMPOCXGRAPH_IE_DISALLOWS_ACTIVEX_CONTROLS _HRESULT_TYPEDEF_(0xC00D10CBL)

//
// MessageId: NS_E_NEED_CORE_REFERENCE
//
// MessageText:
//
// The use of this method requires an existing reference to the Player object.%0
//
#define NS_E_NEED_CORE_REFERENCE         _HRESULT_TYPEDEF_(0xC00D10CCL)

//
// MessageId: NS_E_MEDIACD_READ_ERROR
//
// MessageText:
//
// Windows Media Player cannot play the CD. The disc might be dirty or damaged.%0
//
#define NS_E_MEDIACD_READ_ERROR          _HRESULT_TYPEDEF_(0xC00D10CDL)

//
// MessageId: NS_E_IE_DISALLOWS_ACTIVEX_CONTROLS
//
// MessageText:
//
// Windows Media Player cannot play the file because your Internet security settings prohibit the use of ActiveX controls.%0
//
#define NS_E_IE_DISALLOWS_ACTIVEX_CONTROLS _HRESULT_TYPEDEF_(0xC00D10CEL)

//
// MessageId: NS_E_FLASH_PLAYBACK_NOT_ALLOWED
//
// MessageText:
//
// Flash playback has been turned off in Windows Media Player.%0
//
#define NS_E_FLASH_PLAYBACK_NOT_ALLOWED  _HRESULT_TYPEDEF_(0xC00D10CFL)

//
// MessageId: NS_E_UNABLE_TO_CREATE_RIP_LOCATION
//
// MessageText:
//
// Windows Media Player cannot rip the CD because a valid rip location cannot be created.%0
//
#define NS_E_UNABLE_TO_CREATE_RIP_LOCATION _HRESULT_TYPEDEF_(0xC00D10D0L)

//
// MessageId: NS_E_WMPCORE_SOME_CODECS_MISSING
//
// MessageText:
//
// Windows Media Player cannot play the file because a required codec is not installed on your computer.%0
//
#define NS_E_WMPCORE_SOME_CODECS_MISSING _HRESULT_TYPEDEF_(0xC00D10D1L)

//
// MessageId: NS_E_WMP_RIP_FAILED
//
// MessageText:
//
// Windows Media Player cannot rip one or more tracks from the CD.%0
//
#define NS_E_WMP_RIP_FAILED              _HRESULT_TYPEDEF_(0xC00D10D2L)

//
// MessageId: NS_E_WMP_FAILED_TO_RIP_TRACK
//
// MessageText:
//
// Windows Media Player encountered a problem while ripping the track from the CD.%0
//
#define NS_E_WMP_FAILED_TO_RIP_TRACK     _HRESULT_TYPEDEF_(0xC00D10D3L)

//
// MessageId: NS_E_WMP_ERASE_FAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while erasing the disc.%0
//
#define NS_E_WMP_ERASE_FAILED            _HRESULT_TYPEDEF_(0xC00D10D4L)

//
// MessageId: NS_E_WMP_FORMAT_FAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while formatting the device.%0
//
#define NS_E_WMP_FORMAT_FAILED           _HRESULT_TYPEDEF_(0xC00D10D5L)

//
// MessageId: NS_E_WMP_CANNOT_BURN_NON_LOCAL_FILE
//
// MessageText:
//
// This file cannot be burned to a CD because it is not located on your computer.%0
//
#define NS_E_WMP_CANNOT_BURN_NON_LOCAL_FILE _HRESULT_TYPEDEF_(0xC00D10D6L)

//
// MessageId: NS_E_WMP_FILE_TYPE_CANNOT_BURN_TO_AUDIO_CD
//
// MessageText:
//
// It is not possible to burn this file type to an audio CD. Windows Media Player can burn the following file types to an audio CD: WMA, MP3, or WAV.%0
//
#define NS_E_WMP_FILE_TYPE_CANNOT_BURN_TO_AUDIO_CD _HRESULT_TYPEDEF_(0xC00D10D7L)

//
// MessageId: NS_E_WMP_FILE_DOES_NOT_FIT_ON_CD
//
// MessageText:
//
// This file is too large to fit on a disc.%0
//
#define NS_E_WMP_FILE_DOES_NOT_FIT_ON_CD _HRESULT_TYPEDEF_(0xC00D10D8L)

//
// MessageId: NS_E_WMP_FILE_NO_DURATION
//
// MessageText:
//
// It is not possible to determine if this file can fit on a disc because Windows Media Player cannot detect the length of the file. Playing the file before burning might enable the Player to detect the file length.%0
//
#define NS_E_WMP_FILE_NO_DURATION        _HRESULT_TYPEDEF_(0xC00D10D9L)

//
// MessageId: NS_E_PDA_FAILED_TO_BURN
//
// MessageText:
//
// Windows Media Player encountered a problem while burning the file to the disc.%0
//
#define NS_E_PDA_FAILED_TO_BURN          _HRESULT_TYPEDEF_(0xC00D10DAL)

//
// MessageId: NS_S_NEED_TO_BUY_BURN_RIGHTS
//
// MessageText:
//
// No burn rights. You will be prompted to buy burn rights when you try to burn this file to an audio CD.%0
//
#define NS_S_NEED_TO_BUY_BURN_RIGHTS     _HRESULT_TYPEDEF_(0x000D10DBL)

//
// MessageId: NS_E_FAILED_DOWNLOAD_ABORT_BURN
//
// MessageText:
//
// Windows Media Player cannot burn the audio CD because some items in the list that you chose to buy could not be downloaded from the online store.%0
//
#define NS_E_FAILED_DOWNLOAD_ABORT_BURN  _HRESULT_TYPEDEF_(0xC00D10DCL)

//
// MessageId: NS_E_WMPCORE_DEVICE_DRIVERS_MISSING
//
// MessageText:
//
// Windows Media Player cannot play the file. Try using Windows Update or Device Manager to update the device drivers for your audio and video cards. For information about using Windows Update or Device Manager, see Windows Help.%0
//
#define NS_E_WMPCORE_DEVICE_DRIVERS_MISSING _HRESULT_TYPEDEF_(0xC00D10DDL)

//
// WMP Core  Success codes
//
//
// MessageId: NS_S_WMPCORE_PLAYLISTCLEARABORT
//
// MessageText:
//
// Failed to clear playlist because it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTCLEARABORT  _HRESULT_TYPEDEF_(0x000D10FEL)

//
// MessageId: NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT
//
// MessageText:
//
// Failed to remove item in the playlist since it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT _HRESULT_TYPEDEF_(0x000D10FFL)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_CREATION_PENDING
//
// MessageText:
//
// Playlist is being generated asynchronously.%0
//
#define NS_S_WMPCORE_PLAYLIST_CREATION_PENDING _HRESULT_TYPEDEF_(0x000D1102L)

//
// MessageId: NS_S_WMPCORE_MEDIA_VALIDATION_PENDING
//
// MessageText:
//
// Validation of the media is pending...%0
//
#define NS_S_WMPCORE_MEDIA_VALIDATION_PENDING _HRESULT_TYPEDEF_(0x000D1103L)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED
//
// MessageText:
//
// Encountered more than one Repeat block during ASX processing.%0
//
#define NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED _HRESULT_TYPEDEF_(0x000D1104L)

//
// MessageId: NS_S_WMPCORE_COMMAND_NOT_AVAILABLE
//
// MessageText:
//
// Current state of WMP disallows calling this method or property.%0
//
#define NS_S_WMPCORE_COMMAND_NOT_AVAILABLE _HRESULT_TYPEDEF_(0x000D1105L)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED
//
// MessageText:
//
// Name for the playlist has been auto generated.%0
//
#define NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED _HRESULT_TYPEDEF_(0x000D1106L)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS
//
// MessageText:
//
// The imported playlist does not contain all items from the original.%0
//
#define NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS _HRESULT_TYPEDEF_(0x000D1107L)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA
//
// MessageText:
//
// The M3U playlist has been ignored because it only contains one item.%0
//
#define NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA _HRESULT_TYPEDEF_(0x000D1108L)

//
// MessageId: NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING
//
// MessageText:
//
// The open for the child playlist associated with this media is pending.%0
//
#define NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING _HRESULT_TYPEDEF_(0x000D1109L)

//
// MessageId: NS_S_WMPCORE_MORE_NODES_AVAIABLE
//
// MessageText:
//
// More nodes support the interface requested, but the array for returning them is full.%0
//
#define NS_S_WMPCORE_MORE_NODES_AVAIABLE _HRESULT_TYPEDEF_(0x000D110AL)

//
// WMP Internet Manager error codes
//
//
// MessageId: NS_E_WMPIM_USEROFFLINE
//
// MessageText:
//
// Windows Media Player has detected that you are not connected to the Internet. Connect to the Internet, and then try again.%0
//
#define NS_E_WMPIM_USEROFFLINE           _HRESULT_TYPEDEF_(0xC00D1126L)

//
// MessageId: NS_E_WMPIM_USERCANCELED
//
// MessageText:
//
// The attempt to connect to the Internet was canceled.%0
//
#define NS_E_WMPIM_USERCANCELED          _HRESULT_TYPEDEF_(0xC00D1127L)

//
// MessageId: NS_E_WMPIM_DIALUPFAILED
//
// MessageText:
//
// The attempt to connect to the Internet failed.%0
//
#define NS_E_WMPIM_DIALUPFAILED          _HRESULT_TYPEDEF_(0xC00D1128L)

//
// MessageId: NS_E_WINSOCK_ERROR_STRING
//
// MessageText:
//
// Windows Media Player has encountered an unknown network error.%0
//
#define NS_E_WINSOCK_ERROR_STRING        _HRESULT_TYPEDEF_(0xC00D1129L)

//
// WMP Backup and restore error and success codes
//
//
// MessageId: NS_E_WMPBR_NOLISTENER
//
// MessageText:
//
// No window is currently listening to Backup and Restore events.%0
//
#define NS_E_WMPBR_NOLISTENER            _HRESULT_TYPEDEF_(0xC00D1130L)

//
// MessageId: NS_E_WMPBR_BACKUPCANCEL
//
// MessageText:
//
// Your media usage rights were not backed up because the backup was canceled.%0
//
#define NS_E_WMPBR_BACKUPCANCEL          _HRESULT_TYPEDEF_(0xC00D1131L)

//
// MessageId: NS_E_WMPBR_RESTORECANCEL
//
// MessageText:
//
// Your media usage rights were not restored because the restoration was canceled.%0
//
#define NS_E_WMPBR_RESTORECANCEL         _HRESULT_TYPEDEF_(0xC00D1132L)

//
// MessageId: NS_E_WMPBR_ERRORWITHURL
//
// MessageText:
//
// An error occurred while backing up or restoring your media usage rights. A required web page cannot be displayed.%0
//
#define NS_E_WMPBR_ERRORWITHURL          _HRESULT_TYPEDEF_(0xC00D1133L)

//
// MessageId: NS_E_WMPBR_NAMECOLLISION
//
// MessageText:
//
// Your media usage rights were not backed up because the backup was canceled.%0
//
#define NS_E_WMPBR_NAMECOLLISION         _HRESULT_TYPEDEF_(0xC00D1134L)

//
// MessageId: NS_S_WMPBR_SUCCESS
//
// MessageText:
//
// Backup or Restore successful!.%0
//
#define NS_S_WMPBR_SUCCESS               _HRESULT_TYPEDEF_(0x000D1135L)

//
// MessageId: NS_S_WMPBR_PARTIALSUCCESS
//
// MessageText:
//
// Transfer complete with limitations.%0
//
#define NS_S_WMPBR_PARTIALSUCCESS        _HRESULT_TYPEDEF_(0x000D1136L)

//
// MessageId: NS_E_WMPBR_DRIVE_INVALID
//
// MessageText:
//
// Windows Media Player cannot restore your media usage rights from the specified location. Choose another location, and then try again.%0
//
#define NS_E_WMPBR_DRIVE_INVALID         _HRESULT_TYPEDEF_(0xC00D1137L)

//
// MessageId: NS_E_WMPBR_BACKUPRESTOREFAILED
//
// MessageText:
//
// Windows Media Player cannot backup or restore your media usage rights.%0
//
#define NS_E_WMPBR_BACKUPRESTOREFAILED   _HRESULT_TYPEDEF_(0xC00D1138L)

//
// WMP Effects Success codes
//
//
// MessageId: NS_S_WMPEFFECT_TRANSPARENT
//
// MessageText:
//
// Request to the effects control to change transparency status to transparent.%0
//
#define NS_S_WMPEFFECT_TRANSPARENT       _HRESULT_TYPEDEF_(0x000D1144L)

//
// MessageId: NS_S_WMPEFFECT_OPAQUE
//
// MessageText:
//
// Request to the effects control to change transparency status to opaque.%0
//
#define NS_S_WMPEFFECT_OPAQUE            _HRESULT_TYPEDEF_(0x000D1145L)

//
// WMP Application Success codes
//
//
// MessageId: NS_S_OPERATION_PENDING
//
// MessageText:
//
// The requested application pane is performing an operation and will not be released.%0
//
#define NS_S_OPERATION_PENDING           _HRESULT_TYPEDEF_(0x000D114EL)

//
// WMP Convert Plugin error codes
//
//
// MessageId: NS_E_WMP_CONVERT_FILE_FAILED
//
// MessageText:
//
// Windows Media Player cannot add the file to the library.%0
//
#define NS_E_WMP_CONVERT_FILE_FAILED     _HRESULT_TYPEDEF_(0xC00D1158L)

//
// MessageId: NS_E_WMP_CONVERT_NO_RIGHTS_ERRORURL
//
// MessageText:
//
// Windows Media Player cannot add the file to the library because the content provider prohibits it. For assistance, contact the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_NO_RIGHTS_ERRORURL _HRESULT_TYPEDEF_(0xC00D1159L)

//
// MessageId: NS_E_WMP_CONVERT_NO_RIGHTS_NOERRORURL
//
// MessageText:
//
// Windows Media Player cannot add the file to the library because the content provider prohibits it. For assistance, contact the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_NO_RIGHTS_NOERRORURL _HRESULT_TYPEDEF_(0xC00D115AL)

//
// MessageId: NS_E_WMP_CONVERT_FILE_CORRUPT
//
// MessageText:
//
// Windows Media Player cannot add the file to the library. The file might not be valid.%0
//
#define NS_E_WMP_CONVERT_FILE_CORRUPT    _HRESULT_TYPEDEF_(0xC00D115BL)

//
// MessageId: NS_E_WMP_CONVERT_PLUGIN_UNAVAILABLE_ERRORURL
//
// MessageText:
//
// Windows Media Player cannot add the file to the library. The plug-in required to add the file is not installed properly. For assistance, click Web Help to display the website of the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_PLUGIN_UNAVAILABLE_ERRORURL _HRESULT_TYPEDEF_(0xC00D115CL)

//
// MessageId: NS_E_WMP_CONVERT_PLUGIN_UNAVAILABLE_NOERRORURL
//
// MessageText:
//
// Windows Media Player cannot add the file to the library. The plug-in required to add the file is not installed properly. For assistance, contact the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_PLUGIN_UNAVAILABLE_NOERRORURL _HRESULT_TYPEDEF_(0xC00D115DL)

//
// MessageId: NS_E_WMP_CONVERT_PLUGIN_UNKNOWN_FILE_OWNER
//
// MessageText:
//
// Windows Media Player cannot add the file to the library. The plug-in required to add the file is not installed properly. For assistance, contact the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_PLUGIN_UNKNOWN_FILE_OWNER _HRESULT_TYPEDEF_(0xC00D115EL)

//
// WMP DVD Error Codes
//
//
// MessageId: NS_E_DVD_DISC_COPY_PROTECT_OUTPUT_NS
//
// MessageText:
//
// Windows Media Player cannot play this DVD. Try installing an updated driver for your video card or obtaining a newer video card.%0
//
#define NS_E_DVD_DISC_COPY_PROTECT_OUTPUT_NS _HRESULT_TYPEDEF_(0xC00D1160L)

//
// MessageId: NS_E_DVD_DISC_COPY_PROTECT_OUTPUT_FAILED
//
// MessageText:
//
// This DVD's resolution exceeds the maximum allowed by your component video outputs. Try reducing your screen resolution to 640 x 480, or turn off analog component outputs and use a VGA connection to your monitor.%0
//
#define NS_E_DVD_DISC_COPY_PROTECT_OUTPUT_FAILED _HRESULT_TYPEDEF_(0xC00D1161L)

//
// MessageId: NS_E_DVD_NO_SUBPICTURE_STREAM
//
// MessageText:
//
// Windows Media Player cannot display subtitles or highlights in DVD menus. Reinstall the DVD decoder or contact the DVD drive manufacturer to obtain an updated decoder.%0
//
#define NS_E_DVD_NO_SUBPICTURE_STREAM    _HRESULT_TYPEDEF_(0xC00D1162L)

//
// MessageId: NS_E_DVD_COPY_PROTECT
//
// MessageText:
//
// Windows Media Player cannot play this DVD because there is a problem with digital copy protection between your DVD drive, decoder, and video card. Try installing an updated driver for your video card.%0
//
#define NS_E_DVD_COPY_PROTECT            _HRESULT_TYPEDEF_(0xC00D1163L)

//
// MessageId: NS_E_DVD_AUTHORING_PROBLEM
//
// MessageText:
//
// Windows Media Player cannot play the DVD. The disc was created in a manner that the Player does not support.%0
//
#define NS_E_DVD_AUTHORING_PROBLEM       _HRESULT_TYPEDEF_(0xC00D1164L)

//
// MessageId: NS_E_DVD_INVALID_DISC_REGION
//
// MessageText:
//
// Windows Media Player cannot play the DVD because the disc prohibits playback in your region of the world. You must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_INVALID_DISC_REGION     _HRESULT_TYPEDEF_(0xC00D1165L)

//
// MessageId: NS_E_DVD_COMPATIBLE_VIDEO_CARD
//
// MessageText:
//
// Windows Media Player cannot play the DVD because your video card does not support DVD playback.%0
//
#define NS_E_DVD_COMPATIBLE_VIDEO_CARD   _HRESULT_TYPEDEF_(0xC00D1166L)

//
// MessageId: NS_E_DVD_MACROVISION
//
// MessageText:
//
// Windows Media Player cannot play this DVD because it is not possible to turn on analog copy protection on the output display. Try installing an updated driver for your video card.%0
//
#define NS_E_DVD_MACROVISION             _HRESULT_TYPEDEF_(0xC00D1167L)

//
// MessageId: NS_E_DVD_SYSTEM_DECODER_REGION
//
// MessageText:
//
// Windows Media Player cannot play the DVD because the region assigned to your DVD drive does not match the region assigned to your DVD decoder.%0
//
#define NS_E_DVD_SYSTEM_DECODER_REGION   _HRESULT_TYPEDEF_(0xC00D1168L)

//
// MessageId: NS_E_DVD_DISC_DECODER_REGION
//
// MessageText:
//
// Windows Media Player cannot play the DVD because the disc prohibits playback in your region of the world. You must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_DISC_DECODER_REGION     _HRESULT_TYPEDEF_(0xC00D1169L)

//
// MessageId: NS_E_DVD_NO_VIDEO_STREAM
//
// MessageText:
//
// Windows Media Player cannot play DVD video. You might need to adjust your Windows display settings. Open display settings in Control Panel, and then try lowering your screen resolution and color quality settings.%0
//
#define NS_E_DVD_NO_VIDEO_STREAM         _HRESULT_TYPEDEF_(0xC00D116AL)

//
// MessageId: NS_E_DVD_NO_AUDIO_STREAM
//
// MessageText:
//
// Windows Media Player cannot play DVD audio. Verify that your sound card is set up correctly, and then try again.%0
//
#define NS_E_DVD_NO_AUDIO_STREAM         _HRESULT_TYPEDEF_(0xC00D116BL)

//
// MessageId: NS_E_DVD_GRAPH_BUILDING
//
// MessageText:
//
// Windows Media Player cannot play DVD video. Close any open files and quit any other programs, and then try again. If the problem persists, restart your computer.%0
//
#define NS_E_DVD_GRAPH_BUILDING          _HRESULT_TYPEDEF_(0xC00D116CL)

//
// MessageId: NS_E_DVD_NO_DECODER
//
// MessageText:
//
// Windows Media Player cannot play the DVD because a compatible DVD decoder is not installed on your computer.%0
//
#define NS_E_DVD_NO_DECODER              _HRESULT_TYPEDEF_(0xC00D116DL)

//
// MessageId: NS_E_DVD_PARENTAL
//
// MessageText:
//
// Windows Media Player cannot play the scene because it has a parental rating higher than the rating that you are authorized to view.%0
//
#define NS_E_DVD_PARENTAL                _HRESULT_TYPEDEF_(0xC00D116EL)

//
// MessageId: NS_E_DVD_CANNOT_JUMP
//
// MessageText:
//
// Windows Media Player cannot skip to the requested location on the DVD.%0
//
#define NS_E_DVD_CANNOT_JUMP             _HRESULT_TYPEDEF_(0xC00D116FL)

//
// MessageId: NS_E_DVD_DEVICE_CONTENTION
//
// MessageText:
//
// Windows Media Player cannot play the DVD because it is currently in use by another program. Quit the other program that is using the DVD, and then try again.%0
//
#define NS_E_DVD_DEVICE_CONTENTION       _HRESULT_TYPEDEF_(0xC00D1170L)

//
// MessageId: NS_E_DVD_NO_VIDEO_MEMORY
//
// MessageText:
//
// Windows Media Player cannot play DVD video. You might need to adjust your Windows display settings. Open display settings in Control Panel, and then try lowering your screen resolution and color quality settings.%0
//
#define NS_E_DVD_NO_VIDEO_MEMORY         _HRESULT_TYPEDEF_(0xC00D1171L)

//
// MessageId: NS_E_DVD_CANNOT_COPY_PROTECTED
//
// MessageText:
//
// Windows Media Player cannot rip the DVD because it is copy protected.%0
//
#define NS_E_DVD_CANNOT_COPY_PROTECTED   _HRESULT_TYPEDEF_(0xC00D1172L)

//
// MessageId: NS_E_DVD_REQUIRED_PROPERTY_NOT_SET
//
// MessageText:
//
// One of more of the required properties has not been set.%0
//
#define NS_E_DVD_REQUIRED_PROPERTY_NOT_SET _HRESULT_TYPEDEF_(0xC00D1173L)

//
// MessageId: NS_E_DVD_INVALID_TITLE_CHAPTER
//
// MessageText:
//
// The specified title and/or chapter number does not exist on this DVD.%0
//
#define NS_E_DVD_INVALID_TITLE_CHAPTER   _HRESULT_TYPEDEF_(0xC00D1174L)

//
// WMP PDA Error codes
//
//
// MessageId: NS_E_NO_CD_BURNER
//
// MessageText:
//
// Windows Media Player cannot burn the files because the Player cannot find a burner. If the burner is connected properly, try using Windows Update to install the latest device driver.%0
//
#define NS_E_NO_CD_BURNER                _HRESULT_TYPEDEF_(0xC00D1176L)

//
// MessageId: NS_E_DEVICE_IS_NOT_READY
//
// MessageText:
//
// Windows Media Player does not detect storage media in the selected device. Insert storage media into the device, and then try again.%0
//
#define NS_E_DEVICE_IS_NOT_READY         _HRESULT_TYPEDEF_(0xC00D1177L)

//
// MessageId: NS_E_PDA_UNSUPPORTED_FORMAT
//
// MessageText:
//
// Windows Media Player cannot sync this file. The Player might not support the file type.%0
//
#define NS_E_PDA_UNSUPPORTED_FORMAT      _HRESULT_TYPEDEF_(0xC00D1178L)

//
// MessageId: NS_E_NO_PDA
//
// MessageText:
//
// Windows Media Player does not detect a portable device. Connect your portable device, and then try again.%0
//
#define NS_E_NO_PDA                      _HRESULT_TYPEDEF_(0xC00D1179L)

//
// MessageId: NS_E_PDA_UNSPECIFIED_ERROR
//
// MessageText:
//
// Windows Media Player encountered an error while communicating with the device. The storage card on the device might be full, the device might be turned off, or the device might not allow playlists or folders to be created on it.%0
//
#define NS_E_PDA_UNSPECIFIED_ERROR       _HRESULT_TYPEDEF_(0xC00D117AL)

//
// MessageId: NS_E_MEMSTORAGE_BAD_DATA
//
// MessageText:
//
// Windows Media Player encountered an error while burning a CD.%0
//
#define NS_E_MEMSTORAGE_BAD_DATA         _HRESULT_TYPEDEF_(0xC00D117BL)

//
// MessageId: NS_E_PDA_FAIL_SELECT_DEVICE
//
// MessageText:
//
// Windows Media Player encountered an error while communicating with a portable device or CD drive.%0
//
#define NS_E_PDA_FAIL_SELECT_DEVICE      _HRESULT_TYPEDEF_(0xC00D117CL)

//
// MessageId: NS_E_PDA_FAIL_READ_WAVE_FILE
//
// MessageText:
//
// Windows Media Player cannot open the WAV file.%0
//
#define NS_E_PDA_FAIL_READ_WAVE_FILE     _HRESULT_TYPEDEF_(0xC00D117DL)

//
// MessageId: NS_E_IMAPI_LOSSOFSTREAMING
//
// MessageText:
//
// Windows Media Player failed to burn all the files to the CD. Select a slower recording speed, and then try again.%0
//
#define NS_E_IMAPI_LOSSOFSTREAMING       _HRESULT_TYPEDEF_(0xC00D117EL)

//
// MessageId: NS_E_PDA_DEVICE_FULL
//
// MessageText:
//
// There is not enough storage space on the portable device to complete this operation. Delete some unneeded files on the portable device, and then try again.%0
//
#define NS_E_PDA_DEVICE_FULL             _HRESULT_TYPEDEF_(0xC00D117FL)

//
// MessageId: NS_E_FAIL_LAUNCH_ROXIO_PLUGIN
//
// MessageText:
//
// Windows Media Player cannot burn the files. Verify that your burner is connected properly, and then try again. If the problem persists, reinstall the Player.%0
//
#define NS_E_FAIL_LAUNCH_ROXIO_PLUGIN    _HRESULT_TYPEDEF_(0xC00D1180L)

//
// MessageId: NS_E_PDA_DEVICE_FULL_IN_SESSION
//
// MessageText:
//
// Windows Media Player did not sync some files to the device because there is not enough storage space on the device.%0
//
#define NS_E_PDA_DEVICE_FULL_IN_SESSION  _HRESULT_TYPEDEF_(0xC00D1181L)

//
// MessageId: NS_E_IMAPI_MEDIUM_INVALIDTYPE
//
// MessageText:
//
// The disc in the burner is not valid. Insert a blank disc into the burner, and then try again.%0
//
#define NS_E_IMAPI_MEDIUM_INVALIDTYPE    _HRESULT_TYPEDEF_(0xC00D1182L)

//
// MessageId: NS_E_PDA_MANUALDEVICE
//
// MessageText:
//
// Windows Media Player cannot perform the requested action because the device does not support sync.%0
//
#define NS_E_PDA_MANUALDEVICE            _HRESULT_TYPEDEF_(0xC00D1183L)

//
// MessageId: NS_E_PDA_PARTNERSHIPNOTEXIST
//
// MessageText:
//
// To perform the requested action, you must first set up sync with the device.%0
//
#define NS_E_PDA_PARTNERSHIPNOTEXIST     _HRESULT_TYPEDEF_(0xC00D1184L)

//
// MessageId: NS_E_PDA_CANNOT_CREATE_ADDITIONAL_SYNC_RELATIONSHIP
//
// MessageText:
//
// You have already created sync partnerships with 16 devices. To create a new sync partnership, you must first end an existing partnership.%0
//
#define NS_E_PDA_CANNOT_CREATE_ADDITIONAL_SYNC_RELATIONSHIP _HRESULT_TYPEDEF_(0xC00D1185L)

//
// MessageId: NS_E_PDA_NO_TRANSCODE_OF_DRM
//
// MessageText:
//
// Windows Media Player cannot sync the file because protected files cannot be converted to the required quality level or file format.%0
//
#define NS_E_PDA_NO_TRANSCODE_OF_DRM     _HRESULT_TYPEDEF_(0xC00D1186L)

//
// MessageId: NS_E_PDA_TRANSCODECACHEFULL
//
// MessageText:
//
// The folder that stores converted files is full. Either empty the folder or increase its size, and then try again.%0
//
#define NS_E_PDA_TRANSCODECACHEFULL      _HRESULT_TYPEDEF_(0xC00D1187L)

//
// MessageId: NS_E_PDA_TOO_MANY_FILE_COLLISIONS
//
// MessageText:
//
// There are too many files with the same name in the folder on the device. Change the file name or sync to a different folder.%0
//
#define NS_E_PDA_TOO_MANY_FILE_COLLISIONS _HRESULT_TYPEDEF_(0xC00D1188L)

//
// MessageId: NS_E_PDA_CANNOT_TRANSCODE
//
// MessageText:
//
// Windows Media Player cannot convert the file to the format required by the device.%0
//
#define NS_E_PDA_CANNOT_TRANSCODE        _HRESULT_TYPEDEF_(0xC00D1189L)

//
// MessageId: NS_E_PDA_TOO_MANY_FILES_IN_DIRECTORY
//
// MessageText:
//
// You have reached the maximum number of files your device allows in a folder. If your device supports playback from subfolders, try creating subfolders on the device and storing some files in them.%0
//
#define NS_E_PDA_TOO_MANY_FILES_IN_DIRECTORY _HRESULT_TYPEDEF_(0xC00D118AL)

//
// MessageId: NS_E_PROCESSINGSHOWSYNCWIZARD
//
// MessageText:
//
// Windows Media Player is already trying to start the Device Setup Wizard.%0
//
#define NS_E_PROCESSINGSHOWSYNCWIZARD    _HRESULT_TYPEDEF_(0xC00D118BL)

//
// MessageId: NS_E_PDA_TRANSCODE_NOT_PERMITTED
//
// MessageText:
//
// Windows Media Player cannot convert this file format. If an updated version of the codec used to compress this file is available, install it and then try to sync the file again.%0
//
#define NS_E_PDA_TRANSCODE_NOT_PERMITTED _HRESULT_TYPEDEF_(0xC00D118CL)

//
// MessageId: NS_E_PDA_INITIALIZINGDEVICES
//
// MessageText:
//
// Windows Media Player is busy setting up devices. Try again later.%0
//
#define NS_E_PDA_INITIALIZINGDEVICES     _HRESULT_TYPEDEF_(0xC00D118DL)

//
// MessageId: NS_E_PDA_OBSOLETE_SP
//
// MessageText:
//
// Your device is using an outdated driver that is no longer supported by Windows Media Player.%0
//
#define NS_E_PDA_OBSOLETE_SP             _HRESULT_TYPEDEF_(0xC00D118EL)

//
// MessageId: NS_E_PDA_TITLE_COLLISION
//
// MessageText:
//
// Windows Media Player cannot sync the file because a file with the same name already exists on the device. Change the file name or try to sync the file to a different folder.%0
//
#define NS_E_PDA_TITLE_COLLISION         _HRESULT_TYPEDEF_(0xC00D118FL)

//
// MessageId: NS_E_PDA_DEVICESUPPORTDISABLED
//
// MessageText:
//
// Automatic and manual sync have been turned off temporarily. To sync to a device, restart Windows Media Player.%0
//
#define NS_E_PDA_DEVICESUPPORTDISABLED   _HRESULT_TYPEDEF_(0xC00D1190L)

//
// MessageId: NS_E_PDA_NO_LONGER_AVAILABLE
//
// MessageText:
//
// This device is not available. Connect the device to the computer, and then try again.%0
//
#define NS_E_PDA_NO_LONGER_AVAILABLE     _HRESULT_TYPEDEF_(0xC00D1191L)

//
// MessageId: NS_E_PDA_ENCODER_NOT_RESPONDING
//
// MessageText:
//
// Windows Media Player cannot sync the file because an error occurred while converting the file to another quality level or format. If the problem persists, remove the file from the list of files to sync.%0
//
#define NS_E_PDA_ENCODER_NOT_RESPONDING  _HRESULT_TYPEDEF_(0xC00D1192L)

//
// MessageId: NS_E_PDA_CANNOT_SYNC_FROM_LOCATION
//
// MessageText:
//
// Windows Media Player cannot sync the file to your device. The file might be stored in a location that is not supported. Copy the file from its current location to your hard disk, add it to your library, and then try to sync the file again.%0
//
#define NS_E_PDA_CANNOT_SYNC_FROM_LOCATION _HRESULT_TYPEDEF_(0xC00D1193L)

//
// General Remapped Error codes in WMP
//
//
// MessageId: NS_E_WMP_PROTOCOL_PROBLEM
//
// MessageText:
//
// Windows Media Player cannot open the specified URL. Verify that the Player is configured to use all available protocols, and then try again.%0
//
#define NS_E_WMP_PROTOCOL_PROBLEM        _HRESULT_TYPEDEF_(0xC00D1194L)

//
// MessageId: NS_E_WMP_NO_DISK_SPACE
//
// MessageText:
//
// Windows Media Player cannot perform the requested action because there is not enough storage space on your computer. Delete some unneeded files on your hard disk, and then try again.%0
//
#define NS_E_WMP_NO_DISK_SPACE           _HRESULT_TYPEDEF_(0xC00D1195L)

//
// MessageId: NS_E_WMP_LOGON_FAILURE
//
// MessageText:
//
// The server denied access to the file. Verify that you are using the correct user name and password.%0
//
#define NS_E_WMP_LOGON_FAILURE           _HRESULT_TYPEDEF_(0xC00D1196L)

//
// MessageId: NS_E_WMP_CANNOT_FIND_FILE
//
// MessageText:
//
// Windows Media Player cannot find the file. If you are trying to play, burn, or sync an item that is in your library, the item might point to a file that has been moved, renamed, or deleted.%0
//
#define NS_E_WMP_CANNOT_FIND_FILE        _HRESULT_TYPEDEF_(0xC00D1197L)

//
// MessageId: NS_E_WMP_SERVER_INACCESSIBLE
//
// MessageText:
//
// Windows Media Player cannot connect to the server. The server name might not be correct, the server might not be available, or your proxy settings might not be correct.%0
//
#define NS_E_WMP_SERVER_INACCESSIBLE     _HRESULT_TYPEDEF_(0xC00D1198L)

//
// MessageId: NS_E_WMP_UNSUPPORTED_FORMAT
//
// MessageText:
//
// Windows Media Player cannot play the file. The Player might not support the file type or might not support the codec that was used to compress the file.%0
//
#define NS_E_WMP_UNSUPPORTED_FORMAT      _HRESULT_TYPEDEF_(0xC00D1199L)

//
// MessageId: NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT
//
// MessageText:
//
// Windows Media Player cannot play the file. The Player might not support the file type or a required codec might not be installed on your computer.%0
//
#define NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT _HRESULT_TYPEDEF_(0xC00D119AL)

//
// MessageId: NS_E_WMP_PLAYLIST_EXISTS
//
// MessageText:
//
// Windows Media Player cannot create the playlist because the name already exists. Type a different playlist name.%0
//
#define NS_E_WMP_PLAYLIST_EXISTS         _HRESULT_TYPEDEF_(0xC00D119BL)

//
// MessageId: NS_E_WMP_NONMEDIA_FILES
//
// MessageText:
//
// Windows Media Player cannot delete the playlist because it contains items that are not digital media files. Any digital media files in the playlist were deleted.%0
//
#define NS_E_WMP_NONMEDIA_FILES          _HRESULT_TYPEDEF_(0xC00D119CL)

//
// MessageId: NS_E_WMP_INVALID_ASX
//
// MessageText:
//
// The playlist cannot be opened because it is stored in a shared folder on another computer. If possible, move the playlist to the playlists folder on your computer.%0
//
#define NS_E_WMP_INVALID_ASX             _HRESULT_TYPEDEF_(0xC00D119DL)

//
// MessageId: NS_E_WMP_ALREADY_IN_USE
//
// MessageText:
//
// Windows Media Player is already in use. Stop playing any items, close all Player dialog boxes, and then try again.%0
//
#define NS_E_WMP_ALREADY_IN_USE          _HRESULT_TYPEDEF_(0xC00D119EL)

//
// MessageId: NS_E_WMP_IMAPI_FAILURE
//
// MessageText:
//
// Windows Media Player encountered an error while burning. Verify that the burner is connected properly and that the disc is clean and not damaged.%0
//
#define NS_E_WMP_IMAPI_FAILURE           _HRESULT_TYPEDEF_(0xC00D119FL)

//
// MessageId: NS_E_WMP_WMDM_FAILURE
//
// MessageText:
//
// Windows Media Player has encountered an unknown error with your portable device. Reconnect your portable device, and then try again.%0
//
#define NS_E_WMP_WMDM_FAILURE            _HRESULT_TYPEDEF_(0xC00D11A0L)

//
// MessageId: NS_E_WMP_CODEC_NEEDED_WITH_4CC
//
// MessageText:
//
// A codec is required to play this file. To determine if this codec is available to download from the web, click Web Help.%0
//
#define NS_E_WMP_CODEC_NEEDED_WITH_4CC   _HRESULT_TYPEDEF_(0xC00D11A1L)

//
// MessageId: NS_E_WMP_CODEC_NEEDED_WITH_FORMATTAG
//
// MessageText:
//
// An audio codec is needed to play this file. To determine if this codec is available to download from the web, click Web Help.%0
//
#define NS_E_WMP_CODEC_NEEDED_WITH_FORMATTAG _HRESULT_TYPEDEF_(0xC00D11A2L)

//
// MessageId: NS_E_WMP_MSSAP_NOT_AVAILABLE
//
// MessageText:
//
// To play the file, you must install the latest Windows service pack. To install the service pack from the Windows Update website, click Web Help.%0
//
#define NS_E_WMP_MSSAP_NOT_AVAILABLE     _HRESULT_TYPEDEF_(0xC00D11A3L)

//
// MessageId: NS_E_WMP_WMDM_INTERFACEDEAD
//
// MessageText:
//
// Windows Media Player no longer detects a portable device. Reconnect your portable device, and then try again.%0
//
#define NS_E_WMP_WMDM_INTERFACEDEAD      _HRESULT_TYPEDEF_(0xC00D11A4L)

//
// MessageId: NS_E_WMP_WMDM_NOTCERTIFIED
//
// MessageText:
//
// Windows Media Player cannot sync the file because the portable device does not support protected files.%0
//
#define NS_E_WMP_WMDM_NOTCERTIFIED       _HRESULT_TYPEDEF_(0xC00D11A5L)

//
// MessageId: NS_E_WMP_WMDM_LICENSE_NOTEXIST
//
// MessageText:
//
// This file does not have sync rights. If you obtained this file from an online store, go to the online store to get sync rights.%0
//
#define NS_E_WMP_WMDM_LICENSE_NOTEXIST   _HRESULT_TYPEDEF_(0xC00D11A6L)

//
// MessageId: NS_E_WMP_WMDM_LICENSE_EXPIRED
//
// MessageText:
//
// Windows Media Player cannot sync the file because the sync rights have expired. Go to the content provider's online store to get new sync rights.%0
//
#define NS_E_WMP_WMDM_LICENSE_EXPIRED    _HRESULT_TYPEDEF_(0xC00D11A7L)

//
// MessageId: NS_E_WMP_WMDM_BUSY
//
// MessageText:
//
// The portable device is already in use. Wait until the current task finishes or quit other programs that might be using the portable device, and then try again.%0
//
#define NS_E_WMP_WMDM_BUSY               _HRESULT_TYPEDEF_(0xC00D11A8L)

//
// MessageId: NS_E_WMP_WMDM_NORIGHTS
//
// MessageText:
//
// Windows Media Player cannot sync the file because the content provider or device prohibits it. You might be able to resolve this problem by going to the content provider's online store to get sync rights.%0
//
#define NS_E_WMP_WMDM_NORIGHTS           _HRESULT_TYPEDEF_(0xC00D11A9L)

//
// MessageId: NS_E_WMP_WMDM_INCORRECT_RIGHTS
//
// MessageText:
//
// The content provider has not granted you the right to sync this file. Go to the content provider's online store to get sync rights.%0
//
#define NS_E_WMP_WMDM_INCORRECT_RIGHTS   _HRESULT_TYPEDEF_(0xC00D11AAL)

//
// MessageId: NS_E_WMP_IMAPI_GENERIC
//
// MessageText:
//
// Windows Media Player cannot burn the files to the CD. Verify that the disc is clean and not damaged. If necessary, select a slower recording speed or try a different brand of blank discs.%0
//
#define NS_E_WMP_IMAPI_GENERIC           _HRESULT_TYPEDEF_(0xC00D11ABL)

//
// MessageId: NS_E_WMP_IMAPI_DEVICE_NOTPRESENT
//
// MessageText:
//
// Windows Media Player cannot burn the files. Verify that the burner is connected properly, and then try again.%0
//
#define NS_E_WMP_IMAPI_DEVICE_NOTPRESENT _HRESULT_TYPEDEF_(0xC00D11ADL)

//
// MessageId: NS_E_WMP_IMAPI_DEVICE_BUSY
//
// MessageText:
//
// Windows Media Player cannot burn the files. Verify that the burner is connected properly and that the disc is clean and not damaged. If the burner is already in use, wait until the current task finishes or quit other programs that might be using the burner.%0
//
#define NS_E_WMP_IMAPI_DEVICE_BUSY       _HRESULT_TYPEDEF_(0xC00D11AEL)

//
// MessageId: NS_E_WMP_IMAPI_LOSS_OF_STREAMING
//
// MessageText:
//
// Windows Media Player cannot burn the files to the CD.%0
//
#define NS_E_WMP_IMAPI_LOSS_OF_STREAMING _HRESULT_TYPEDEF_(0xC00D11AFL)

//
// MessageId: NS_E_WMP_SERVER_UNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot play the file. The server might not be available or there might be a problem with your network or firewall settings.%0
//
#define NS_E_WMP_SERVER_UNAVAILABLE      _HRESULT_TYPEDEF_(0xC00D11B0L)

//
// MessageId: NS_E_WMP_FILE_OPEN_FAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while playing the file.%0
//
#define NS_E_WMP_FILE_OPEN_FAILED        _HRESULT_TYPEDEF_(0xC00D11B1L)

//
// MessageId: NS_E_WMP_VERIFY_ONLINE
//
// MessageText:
//
// Windows Media Player must connect to the Internet to verify the file's media usage rights. Connect to the Internet, and then try again.%0
//
#define NS_E_WMP_VERIFY_ONLINE           _HRESULT_TYPEDEF_(0xC00D11B2L)

//
// MessageId: NS_E_WMP_SERVER_NOT_RESPONDING
//
// MessageText:
//
// Windows Media Player cannot play the file because a network error occurred. The server might not be available. Verify that you are connected to the network and that your proxy settings are correct.%0
//
#define NS_E_WMP_SERVER_NOT_RESPONDING   _HRESULT_TYPEDEF_(0xC00D11B3L)

//
// MessageId: NS_E_WMP_DRM_CORRUPT_BACKUP
//
// MessageText:
//
// Windows Media Player cannot restore your media usage rights because it could not find any backed up rights on your computer.%0
//
#define NS_E_WMP_DRM_CORRUPT_BACKUP      _HRESULT_TYPEDEF_(0xC00D11B4L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_SERVER_UNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot download media usage rights because the server is not available (for example, the server might be busy or not online).%0
//
#define NS_E_WMP_DRM_LICENSE_SERVER_UNAVAILABLE _HRESULT_TYPEDEF_(0xC00D11B5L)

//
// MessageId: NS_E_WMP_NETWORK_FIREWALL
//
// MessageText:
//
// Windows Media Player cannot play the file. A network firewall might be preventing the Player from opening the file by using the UDP transport protocol. If you typed a URL in the Open URL dialog box, try using a different transport protocol (for example, "http:").%0
//
#define NS_E_WMP_NETWORK_FIREWALL        _HRESULT_TYPEDEF_(0xC00D11B6L)

//
// MessageId: NS_E_WMP_NO_REMOVABLE_MEDIA
//
// MessageText:
//
// Insert the removable media, and then try again.%0
//
#define NS_E_WMP_NO_REMOVABLE_MEDIA      _HRESULT_TYPEDEF_(0xC00D11B7L)

//
// MessageId: NS_E_WMP_PROXY_CONNECT_TIMEOUT
//
// MessageText:
//
// Windows Media Player cannot play the file because the proxy server is not responding. The proxy server might be temporarily unavailable or your Player proxy settings might not be valid.%0
//
#define NS_E_WMP_PROXY_CONNECT_TIMEOUT   _HRESULT_TYPEDEF_(0xC00D11B8L)

//
// MessageId: NS_E_WMP_NEED_UPGRADE
//
// MessageText:
//
// To play the file, you might need to install a later version of Windows Media Player. On the Help menu, click Check for Updates, and then follow the instructions.%0
//
#define NS_E_WMP_NEED_UPGRADE            _HRESULT_TYPEDEF_(0xC00D11B9L)

//
// MessageId: NS_E_WMP_AUDIO_HW_PROBLEM
//
// MessageText:
//
// Windows Media Player cannot play the file because there is a problem with your sound device. There might not be a sound device installed on your computer, it might be in use by another program, or it might not be functioning properly.%0
//
#define NS_E_WMP_AUDIO_HW_PROBLEM        _HRESULT_TYPEDEF_(0xC00D11BAL)

//
// MessageId: NS_E_WMP_INVALID_PROTOCOL
//
// MessageText:
//
// Windows Media Player cannot play the file because the specified protocol is not supported. If you typed a URL in the Open URL dialog box, try using a different transport protocol (for example, "http:" or "rtsp:").%0
//
#define NS_E_WMP_INVALID_PROTOCOL        _HRESULT_TYPEDEF_(0xC00D11BBL)

//
// MessageId: NS_E_WMP_INVALID_LIBRARY_ADD
//
// MessageText:
//
// Windows Media Player cannot add the file to the library because the file format is not supported.%0
//
#define NS_E_WMP_INVALID_LIBRARY_ADD     _HRESULT_TYPEDEF_(0xC00D11BCL)

//
// MessageId: NS_E_WMP_MMS_NOT_SUPPORTED
//
// MessageText:
//
// Windows Media Player cannot play the file because the specified protocol is not supported. If you typed a URL in the Open URL dialog box, try using a different transport protocol (for example, "mms:").%0
//
#define NS_E_WMP_MMS_NOT_SUPPORTED       _HRESULT_TYPEDEF_(0xC00D11BDL)

//
// MessageId: NS_E_WMP_NO_PROTOCOLS_SELECTED
//
// MessageText:
//
// Windows Media Player cannot play the file because there are no streaming protocols selected. Select one or more protocols, and then try again.%0
//
#define NS_E_WMP_NO_PROTOCOLS_SELECTED   _HRESULT_TYPEDEF_(0xC00D11BEL)

//
// MessageId: NS_E_WMP_GOFULLSCREEN_FAILED
//
// MessageText:
//
// Windows Media Player cannot switch to Full Screen. You might need to adjust your Windows display settings. Open display settings in Control Panel, and then try setting Hardware acceleration to Full.%0
//
#define NS_E_WMP_GOFULLSCREEN_FAILED     _HRESULT_TYPEDEF_(0xC00D11BFL)

//
// MessageId: NS_E_WMP_NETWORK_ERROR
//
// MessageText:
//
// Windows Media Player cannot play the file because a network error occurred. The server might not be available (for example, the server is busy or not online) or you might not be connected to the network.%0
//
#define NS_E_WMP_NETWORK_ERROR           _HRESULT_TYPEDEF_(0xC00D11C0L)

//
// MessageId: NS_E_WMP_CONNECT_TIMEOUT
//
// MessageText:
//
// Windows Media Player cannot play the file because the server is not responding. Verify that you are connected to the network, and then try again later.%0
//
#define NS_E_WMP_CONNECT_TIMEOUT         _HRESULT_TYPEDEF_(0xC00D11C1L)

//
// MessageId: NS_E_WMP_MULTICAST_DISABLED
//
// MessageText:
//
// Windows Media Player cannot play the file because the multicast protocol is not enabled. On the Tools menu, click Options, click the Network tab, and then select the Multicast check box.%0
//
#define NS_E_WMP_MULTICAST_DISABLED      _HRESULT_TYPEDEF_(0xC00D11C2L)

//
// MessageId: NS_E_WMP_SERVER_DNS_TIMEOUT
//
// MessageText:
//
// Windows Media Player cannot play the file because a network problem occurred. Verify that you are connected to the network, and then try again later.%0
//
#define NS_E_WMP_SERVER_DNS_TIMEOUT      _HRESULT_TYPEDEF_(0xC00D11C3L)

//
// MessageId: NS_E_WMP_PROXY_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot play the file because the network proxy server cannot be found. Verify that your proxy settings are correct, and then try again.%0
//
#define NS_E_WMP_PROXY_NOT_FOUND         _HRESULT_TYPEDEF_(0xC00D11C4L)

//
// MessageId: NS_E_WMP_TAMPERED_CONTENT
//
// MessageText:
//
// Windows Media Player cannot play the file because it is corrupted.%0
//
#define NS_E_WMP_TAMPERED_CONTENT        _HRESULT_TYPEDEF_(0xC00D11C5L)

//
// MessageId: NS_E_WMP_OUTOFMEMORY
//
// MessageText:
//
// Your computer is running low on memory. Quit other programs, and then try again.%0
//
#define NS_E_WMP_OUTOFMEMORY             _HRESULT_TYPEDEF_(0xC00D11C6L)

//
// MessageId: NS_E_WMP_AUDIO_CODEC_NOT_INSTALLED
//
// MessageText:
//
// Windows Media Player cannot play, burn, rip, or sync the file because a required audio codec is not installed on your computer.%0
//
#define NS_E_WMP_AUDIO_CODEC_NOT_INSTALLED _HRESULT_TYPEDEF_(0xC00D11C7L)

//
// MessageId: NS_E_WMP_VIDEO_CODEC_NOT_INSTALLED
//
// MessageText:
//
// Windows Media Player cannot play the file because the required video codec is not installed on your computer.%0
//
#define NS_E_WMP_VIDEO_CODEC_NOT_INSTALLED _HRESULT_TYPEDEF_(0xC00D11C8L)

//
// MessageId: NS_E_WMP_IMAPI_DEVICE_INVALIDTYPE
//
// MessageText:
//
// Windows Media Player cannot burn the files. If the burner is busy, wait for the current task to finish. If necessary, verify that the burner is connected properly and that you have installed the latest device driver.%0
//
#define NS_E_WMP_IMAPI_DEVICE_INVALIDTYPE _HRESULT_TYPEDEF_(0xC00D11C9L)

//
// MessageId: NS_E_WMP_DRM_DRIVER_AUTH_FAILURE
//
// MessageText:
//
// Windows Media Player cannot play the protected file because there is a problem with your sound device. Try installing a new device driver or use a different sound device.%0
//
#define NS_E_WMP_DRM_DRIVER_AUTH_FAILURE _HRESULT_TYPEDEF_(0xC00D11CAL)

//
// MessageId: NS_E_WMP_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
// Windows Media Player encountered a network error. Restart the Player.%0
//
#define NS_E_WMP_NETWORK_RESOURCE_FAILURE _HRESULT_TYPEDEF_(0xC00D11CBL)

//
// MessageId: NS_E_WMP_UPGRADE_APPLICATION
//
// MessageText:
//
// Windows Media Player is not installed properly. Reinstall the Player.%0
//
#define NS_E_WMP_UPGRADE_APPLICATION     _HRESULT_TYPEDEF_(0xC00D11CCL)

//
// MessageId: NS_E_WMP_UNKNOWN_ERROR
//
// MessageText:
//
// Windows Media Player encountered an unknown error.%0
//
#define NS_E_WMP_UNKNOWN_ERROR           _HRESULT_TYPEDEF_(0xC00D11CDL)

//
// MessageId: NS_E_WMP_INVALID_KEY
//
// MessageText:
//
// Windows Media Player cannot play the file because the required codec is not valid.%0
//
#define NS_E_WMP_INVALID_KEY             _HRESULT_TYPEDEF_(0xC00D11CEL)

//
// MessageId: NS_E_WMP_CD_ANOTHER_USER
//
// MessageText:
//
// The CD drive is in use by another user. Wait for the task to complete, and then try again.%0
//
#define NS_E_WMP_CD_ANOTHER_USER         _HRESULT_TYPEDEF_(0xC00D11CFL)

//
// MessageId: NS_E_WMP_DRM_NEEDS_AUTHORIZATION
//
// MessageText:
//
// Windows Media Player cannot play, sync, or burn the protected file because a problem occurred with the Windows Media Digital Rights Management (DRM) system. You might need to connect to the Internet to update your DRM components.%0
//
#define NS_E_WMP_DRM_NEEDS_AUTHORIZATION _HRESULT_TYPEDEF_(0xC00D11D0L)

//
// MessageId: NS_E_WMP_BAD_DRIVER
//
// MessageText:
//
// Windows Media Player cannot play the file because there might be a problem with your sound or video device. Try installing an updated device driver.%0
//
#define NS_E_WMP_BAD_DRIVER              _HRESULT_TYPEDEF_(0xC00D11D1L)

//
// MessageId: NS_E_WMP_ACCESS_DENIED
//
// MessageText:
//
// Windows Media Player cannot access the file. The file might be in use, you might not have access to the computer where the file is stored, or your proxy settings might not be correct.%0
//
#define NS_E_WMP_ACCESS_DENIED           _HRESULT_TYPEDEF_(0xC00D11D2L)

//
// MessageId: NS_E_WMP_LICENSE_RESTRICTS
//
// MessageText:
//
// The content provider prohibits this action. Go to the content provider's online store to get new media usage rights.%0
//
#define NS_E_WMP_LICENSE_RESTRICTS       _HRESULT_TYPEDEF_(0xC00D11D3L)

//
// MessageId: NS_E_WMP_INVALID_REQUEST
//
// MessageText:
//
// Windows Media Player cannot perform the requested action at this time.%0
//
#define NS_E_WMP_INVALID_REQUEST         _HRESULT_TYPEDEF_(0xC00D11D4L)

//
// MessageId: NS_E_WMP_CD_STASH_NO_SPACE
//
// MessageText:
//
// Windows Media Player cannot burn the files because there is not enough free disk space to store the temporary files. Delete some unneeded files on your hard disk, and then try again.%0
//
#define NS_E_WMP_CD_STASH_NO_SPACE       _HRESULT_TYPEDEF_(0xC00D11D5L)

//
// MessageId: NS_E_WMP_DRM_NEW_HARDWARE
//
// MessageText:
//
// Your media usage rights have become corrupted or are no longer valid. This might happen if you have replaced hardware components in your computer.%0
//
#define NS_E_WMP_DRM_NEW_HARDWARE        _HRESULT_TYPEDEF_(0xC00D11D6L)

//
// MessageId: NS_E_WMP_DRM_INVALID_SIG
//
// MessageText:
//
// The required Windows Media Digital Rights Management (DRM) component cannot be validated. You might be able to resolve the problem by reinstalling the Player.%0
//
#define NS_E_WMP_DRM_INVALID_SIG         _HRESULT_TYPEDEF_(0xC00D11D7L)

//
// MessageId: NS_E_WMP_DRM_CANNOT_RESTORE
//
// MessageText:
//
// You have exceeded your restore limit for the day. Try restoring your media usage rights tomorrow.%0
//
#define NS_E_WMP_DRM_CANNOT_RESTORE      _HRESULT_TYPEDEF_(0xC00D11D8L)

//
// MessageId: NS_E_WMP_BURN_DISC_OVERFLOW
//
// MessageText:
//
// Some files might not fit on the CD. The required space cannot be calculated accurately because some files might be missing duration information. To ensure the calculation is accurate, play the files that are missing duration information.%0
//
#define NS_E_WMP_BURN_DISC_OVERFLOW      _HRESULT_TYPEDEF_(0xC00D11D9L)

//
// MessageId: NS_E_WMP_DRM_GENERIC_LICENSE_FAILURE
//
// MessageText:
//
// Windows Media Player cannot verify the file's media usage rights. If you obtained this file from an online store, go to the online store to get the necessary rights.%0
//
#define NS_E_WMP_DRM_GENERIC_LICENSE_FAILURE _HRESULT_TYPEDEF_(0xC00D11DAL)

//
// MessageId: NS_E_WMP_DRM_NO_SECURE_CLOCK
//
// MessageText:
//
// It is not possible to sync because this device's internal clock is not set correctly. To set the clock, select the option to set the device clock on the Privacy tab of the Options dialog box, connect to the Internet, and then sync the device again. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_DRM_NO_SECURE_CLOCK     _HRESULT_TYPEDEF_(0xC00D11DBL)

//
// MessageId: NS_E_WMP_DRM_NO_RIGHTS
//
// MessageText:
//
// Windows Media Player cannot play, burn, rip, or sync the protected file because you do not have the appropriate rights.%0
//
#define NS_E_WMP_DRM_NO_RIGHTS           _HRESULT_TYPEDEF_(0xC00D11DCL)

//
// MessageId: NS_E_WMP_DRM_INDIV_FAILED
//
// MessageText:
//
// Windows Media Player encountered an error during upgrade.%0
//
#define NS_E_WMP_DRM_INDIV_FAILED        _HRESULT_TYPEDEF_(0xC00D11DDL)

//
// MessageId: NS_E_WMP_SERVER_NONEWCONNECTIONS
//
// MessageText:
//
// Windows Media Player cannot connect to the server because it is not accepting any new connections. This could be because it has reached its maximum connection limit. Please try again later.%0
//
#define NS_E_WMP_SERVER_NONEWCONNECTIONS _HRESULT_TYPEDEF_(0xC00D11DEL)

//
// MessageId: NS_E_WMP_MULTIPLE_ERROR_IN_PLAYLIST
//
// MessageText:
//
// A number of queued files cannot be played. To find information about the problem, click the icon next to each file in the List pane.%0
//
#define NS_E_WMP_MULTIPLE_ERROR_IN_PLAYLIST _HRESULT_TYPEDEF_(0xC00D11DFL)

//
// MessageId: NS_E_WMP_IMAPI2_ERASE_FAIL
//
// MessageText:
//
// Windows Media Player encountered an error while erasing the rewritable CD or DVD. Verify that the CD or DVD burner is connected properly and that the disc is clean and not damaged.%0
//
#define NS_E_WMP_IMAPI2_ERASE_FAIL       _HRESULT_TYPEDEF_(0xC00D11E0L)

//
// MessageId: NS_E_WMP_IMAPI2_ERASE_DEVICE_BUSY
//
// MessageText:
//
// Windows Media Player cannot erase the rewritable CD or DVD. Verify that the CD or DVD burner is connected properly and that the disc is clean and not damaged. If the burner is already in use, wait until the current task finishes or quit other programs that might be using the burner.%0
//
#define NS_E_WMP_IMAPI2_ERASE_DEVICE_BUSY _HRESULT_TYPEDEF_(0xC00D11E1L)

//
// MessageId: NS_E_WMP_DRM_COMPONENT_FAILURE
//
// MessageText:
//
// A Windows Media Digital Rights Management (DRM) component encountered a problem. Contact Microsoft Product Support.%0
//
#define NS_E_WMP_DRM_COMPONENT_FAILURE   _HRESULT_TYPEDEF_(0xC00D11E2L)

//
// MessageId: NS_E_WMP_DRM_NO_DEVICE_CERT
//
// MessageText:
//
// It is not possible to obtain the device's certificate. Please contact the device manufacturer for a firmware update or for other steps to resolve this problem.%0
//
#define NS_E_WMP_DRM_NO_DEVICE_CERT      _HRESULT_TYPEDEF_(0xC00D11E3L)

//
// MessageId: NS_E_WMP_SERVER_SECURITY_ERROR
//
// MessageText:
//
// Windows Media Player encountered an error when connecting to the server. The security information from the server could not be validated.%0
//
#define NS_E_WMP_SERVER_SECURITY_ERROR   _HRESULT_TYPEDEF_(0xC00D11E4L)

//
// MessageId: NS_E_WMP_AUDIO_DEVICE_LOST
//
// MessageText:
//
// An audio device was disconnected or reconfigured. Verify that the audio device is connected, and then try to play the item again.%0
//
#define NS_E_WMP_AUDIO_DEVICE_LOST       _HRESULT_TYPEDEF_(0xC00D11E5L)

//
// MessageId: NS_E_WMP_IMAPI_MEDIA_INCOMPATIBLE
//
// MessageText:
//
// Windows Media Player could not complete burning because the disc is not compatible with your drive. Try inserting a different kind of recordable media or use a disc that supports a write speed that is compatible with your drive.%0
//
#define NS_E_WMP_IMAPI_MEDIA_INCOMPATIBLE _HRESULT_TYPEDEF_(0xC00D11E6L)

//
// WMP Sync Wizard Error codes extension 4590-4599
//
//
// MessageId: NS_E_SYNCWIZ_DEVICE_FULL
//
// MessageText:
//
// Windows Media Player cannot save the sync settings because your device is full. Delete some unneeded files on your device and then try again.%0
//
#define NS_E_SYNCWIZ_DEVICE_FULL         _HRESULT_TYPEDEF_(0xC00D11EEL)

//
// MessageId: NS_E_SYNCWIZ_CANNOT_CHANGE_SETTINGS
//
// MessageText:
//
// It is not possible to change sync settings at this time. Try again later.%0
//
#define NS_E_SYNCWIZ_CANNOT_CHANGE_SETTINGS _HRESULT_TYPEDEF_(0xC00D11EFL)

//
// MessageId: NS_E_TRANSCODE_DELETECACHEERROR
//
// MessageText:
//
// Windows Media Player cannot delete these files right now. If the Player is syncing, wait until it is complete and then try again.%0
//
#define NS_E_TRANSCODE_DELETECACHEERROR  _HRESULT_TYPEDEF_(0xC00D11F0L)

//
// WMP CD Filter Error codes extension
//
//
// MessageId: NS_E_CD_NO_BUFFERS_READ
//
// MessageText:
//
// Windows Media Player could not use digital mode to read the CD. The Player has automatically switched the CD drive to analog mode. To switch back to digital mode, use the Devices tab.%0
//
#define NS_E_CD_NO_BUFFERS_READ          _HRESULT_TYPEDEF_(0xC00D11F8L)

//
// MessageId: NS_E_CD_EMPTY_TRACK_QUEUE
//
// MessageText:
//
// No CD track was specified for playback.%0
//
#define NS_E_CD_EMPTY_TRACK_QUEUE        _HRESULT_TYPEDEF_(0xC00D11F9L)

//
// MessageId: NS_E_CD_NO_READER
//
// MessageText:
//
// The CD filter was not able to create the CD reader.%0
//
#define NS_E_CD_NO_READER                _HRESULT_TYPEDEF_(0xC00D11FAL)

//
// MessageId: NS_E_CD_ISRC_INVALID
//
// MessageText:
//
// Invalid ISRC code.%0
//
#define NS_E_CD_ISRC_INVALID             _HRESULT_TYPEDEF_(0xC00D11FBL)

//
// MessageId: NS_E_CD_MEDIA_CATALOG_NUMBER_INVALID
//
// MessageText:
//
// Invalid Media Catalog Number.%0
//
#define NS_E_CD_MEDIA_CATALOG_NUMBER_INVALID _HRESULT_TYPEDEF_(0xC00D11FCL)

//
// MessageId: NS_E_SLOW_READ_DIGITAL_WITH_ERRORCORRECTION
//
// MessageText:
//
// Windows Media Player cannot play audio CDs correctly because the CD drive is slow and error correction is turned on. To increase performance, turn off playback error correction for this drive.%0
//
#define NS_E_SLOW_READ_DIGITAL_WITH_ERRORCORRECTION _HRESULT_TYPEDEF_(0xC00D11FDL)

//
// MessageId: NS_E_CD_SPEEDDETECT_NOT_ENOUGH_READS
//
// MessageText:
//
// Windows Media Player cannot estimate the CD drive's playback speed because the CD track is too short.%0
//
#define NS_E_CD_SPEEDDETECT_NOT_ENOUGH_READS _HRESULT_TYPEDEF_(0xC00D11FEL)

//
// MessageId: NS_E_CD_QUEUEING_DISABLED
//
// MessageText:
//
// Cannot queue the CD track because queuing is not enabled.%0
//
#define NS_E_CD_QUEUEING_DISABLED        _HRESULT_TYPEDEF_(0xC00D11FFL)

//
// WMP DRM error codes 4610-4630
//
//
// MessageId: NS_E_WMP_DRM_ACQUIRING_LICENSE
//
// MessageText:
//
// Windows Media Player cannot download additional media usage rights until the current download is complete.%0
//
#define NS_E_WMP_DRM_ACQUIRING_LICENSE   _HRESULT_TYPEDEF_(0xC00D1202L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_EXPIRED
//
// MessageText:
//
// The media usage rights for this file have expired or are no longer valid. If you obtained the file from an online store, sign in to the store, and then try again.%0
//
#define NS_E_WMP_DRM_LICENSE_EXPIRED     _HRESULT_TYPEDEF_(0xC00D1203L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_NOTACQUIRED
//
// MessageText:
//
// Windows Media Player cannot download the media usage rights for the file. If you obtained the file from an online store, sign in to the store, and then try again.%0
//
#define NS_E_WMP_DRM_LICENSE_NOTACQUIRED _HRESULT_TYPEDEF_(0xC00D1204L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_NOTENABLED
//
// MessageText:
//
// The media usage rights for this file are not yet valid. To see when they will become valid, right-click the file in the library, click Properties, and then click the Media Usage Rights tab.%0
//
#define NS_E_WMP_DRM_LICENSE_NOTENABLED  _HRESULT_TYPEDEF_(0xC00D1205L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_UNUSABLE
//
// MessageText:
//
// The media usage rights for this file are not valid. If you obtained this file from an online store, contact the store for assistance.%0
//
#define NS_E_WMP_DRM_LICENSE_UNUSABLE    _HRESULT_TYPEDEF_(0xC00D1206L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_CONTENT_REVOKED
//
// MessageText:
//
// The content provider has revoked the media usage rights for this file. If you obtained this file from an online store, ask the store if a new version of the file is available.%0
//
#define NS_E_WMP_DRM_LICENSE_CONTENT_REVOKED _HRESULT_TYPEDEF_(0xC00D1207L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_NOSAP
//
// MessageText:
//
// The media usage rights for this file require a feature that is not supported in your current version of Windows Media Player or your current version of Windows. If you obtained this file from an online store, contact the store for further assistance.%0
//
#define NS_E_WMP_DRM_LICENSE_NOSAP       _HRESULT_TYPEDEF_(0xC00D1208L)

//
// MessageId: NS_E_WMP_DRM_UNABLE_TO_ACQUIRE_LICENSE
//
// MessageText:
//
// Windows Media Player cannot download media usage rights at this time. Try again later.%0
//
#define NS_E_WMP_DRM_UNABLE_TO_ACQUIRE_LICENSE _HRESULT_TYPEDEF_(0xC00D1209L)

//
// MessageId: NS_E_WMP_LICENSE_REQUIRED
//
// MessageText:
//
// Windows Media Player cannot play, burn, or sync the file because the media usage rights are missing. If you obtained the file from an online store, sign in to the store, and then try again.%0
//
#define NS_E_WMP_LICENSE_REQUIRED        _HRESULT_TYPEDEF_(0xC00D120AL)

//
// MessageId: NS_E_WMP_PROTECTED_CONTENT
//
// MessageText:
//
// Windows Media Player cannot play, burn, or sync the file because the media usage rights are missing. If you obtained the file from an online store, sign in to the store, and then try again.%0
//
#define NS_E_WMP_PROTECTED_CONTENT       _HRESULT_TYPEDEF_(0xC00D120BL)

//
// WMP Policy error codes
//
//
// MessageId: NS_E_WMP_POLICY_VALUE_NOT_CONFIGURED
//
// MessageText:
//
// Windows Media Player cannot read a policy. This can occur when the policy does not exist in the registry or when the registry cannot be read.%0
//
#define NS_E_WMP_POLICY_VALUE_NOT_CONFIGURED _HRESULT_TYPEDEF_(0xC00D122AL)

//
// WMP SYNC error codes 4660 -- 4700
//
//
// MessageId: NS_E_PDA_CANNOT_SYNC_FROM_INTERNET
//
// MessageText:
//
// Windows Media Player cannot sync content streamed directly from the Internet. If possible, download the file to your computer, and then try to sync the file.%0
//
#define NS_E_PDA_CANNOT_SYNC_FROM_INTERNET _HRESULT_TYPEDEF_(0xC00D1234L)

//
// MessageId: NS_E_PDA_CANNOT_SYNC_INVALID_PLAYLIST
//
// MessageText:
//
// This playlist is not valid or is corrupted. Create a new playlist using Windows Media Player, then sync the new playlist instead.%0
//
#define NS_E_PDA_CANNOT_SYNC_INVALID_PLAYLIST _HRESULT_TYPEDEF_(0xC00D1235L)

//
// MessageId: NS_E_PDA_FAILED_TO_SYNCHRONIZE_FILE
//
// MessageText:
//
// Windows Media Player encountered a problem while syncing the file to the device.%0
//
#define NS_E_PDA_FAILED_TO_SYNCHRONIZE_FILE _HRESULT_TYPEDEF_(0xC00D1236L)

//
// MessageId: NS_E_PDA_SYNC_FAILED
//
// MessageText:
//
// Windows Media Player encountered an error while syncing to the device.%0
//
#define NS_E_PDA_SYNC_FAILED             _HRESULT_TYPEDEF_(0xC00D1237L)

//
// MessageId: NS_E_PDA_DELETE_FAILED
//
// MessageText:
//
// Windows Media Player cannot delete a file from the device.%0
//
#define NS_E_PDA_DELETE_FAILED           _HRESULT_TYPEDEF_(0xC00D1238L)

//
// MessageId: NS_E_PDA_FAILED_TO_RETRIEVE_FILE
//
// MessageText:
//
// Windows Media Player cannot copy a file from the device to your library.%0
//
#define NS_E_PDA_FAILED_TO_RETRIEVE_FILE _HRESULT_TYPEDEF_(0xC00D1239L)

//
// MessageId: NS_E_PDA_DEVICE_NOT_RESPONDING
//
// MessageText:
//
// Windows Media Player cannot communicate with the device because the device is not responding. Try reconnecting the device, resetting the device, or contacting the device manufacturer for updated firmware.%0
//
#define NS_E_PDA_DEVICE_NOT_RESPONDING   _HRESULT_TYPEDEF_(0xC00D123AL)

//
// MessageId: NS_E_PDA_FAILED_TO_TRANSCODE_PHOTO
//
// MessageText:
//
// Windows Media Player cannot sync the picture to the device because a problem occurred while converting the file to another quality level or format. The original file might be damaged or corrupted.%0
//
#define NS_E_PDA_FAILED_TO_TRANSCODE_PHOTO _HRESULT_TYPEDEF_(0xC00D123BL)

//
// MessageId: NS_E_PDA_FAILED_TO_ENCRYPT_TRANSCODED_FILE
//
// MessageText:
//
// Windows Media Player cannot convert the file. The file might have been encrypted by the Encrypted File System (EFS). Try decrypting the file first and then syncing it. For information about how to decrypt a file, see Windows Help and Support.%0
//
#define NS_E_PDA_FAILED_TO_ENCRYPT_TRANSCODED_FILE _HRESULT_TYPEDEF_(0xC00D123CL)

//
// MessageId: NS_E_PDA_CANNOT_TRANSCODE_TO_AUDIO
//
// MessageText:
//
// Your device requires that this file be converted in order to play on the device. However, the device either does not support playing audio, or Windows Media Player cannot convert the file to an audio format that is supported by the device.%0
//
#define NS_E_PDA_CANNOT_TRANSCODE_TO_AUDIO _HRESULT_TYPEDEF_(0xC00D123DL)

//
// MessageId: NS_E_PDA_CANNOT_TRANSCODE_TO_VIDEO
//
// MessageText:
//
// Your device requires that this file be converted in order to play on the device. However, the device either does not support playing video, or Windows Media Player cannot convert the file to a video format that is supported by the device.%0
//
#define NS_E_PDA_CANNOT_TRANSCODE_TO_VIDEO _HRESULT_TYPEDEF_(0xC00D123EL)

//
// MessageId: NS_E_PDA_CANNOT_TRANSCODE_TO_IMAGE
//
// MessageText:
//
// Your device requires that this file be converted in order to play on the device. However, the device either does not support displaying pictures, or Windows Media Player cannot convert the file to a picture format that is supported by the device.%0
//
#define NS_E_PDA_CANNOT_TRANSCODE_TO_IMAGE _HRESULT_TYPEDEF_(0xC00D123FL)

//
// MessageId: NS_E_PDA_RETRIEVED_FILE_FILENAME_TOO_LONG
//
// MessageText:
//
// Windows Media Player cannot sync the file to your computer because the file name is too long. Try renaming the file on the device.%0
//
#define NS_E_PDA_RETRIEVED_FILE_FILENAME_TOO_LONG _HRESULT_TYPEDEF_(0xC00D1240L)

//
// MessageId: NS_E_PDA_CEWMDM_DRM_ERROR
//
// MessageText:
//
// Windows Media Player cannot sync the file because the device is not responding. This typically occurs when there is a problem with the device firmwa re.%0
//
#define NS_E_PDA_CEWMDM_DRM_ERROR        _HRESULT_TYPEDEF_(0xC00D1241L)

//
// MessageId: NS_E_INCOMPLETE_PLAYLIST
//
// MessageText:
//
//  NS_E_INCOMPLETE_PLAYLIST
//
#define NS_E_INCOMPLETE_PLAYLIST         _HRESULT_TYPEDEF_(0xC00D1242L)

//
// MessageId: NS_E_PDA_SYNC_RUNNING
//
// MessageText:
//
// It is not possible to perform the requested action because sync is in progress. You can either stop sync or wait for it to complete, and then try again.%0
//
#define NS_E_PDA_SYNC_RUNNING            _HRESULT_TYPEDEF_(0xC00D1243L)

//
// MessageId: NS_E_PDA_SYNC_LOGIN_ERROR
//
// MessageText:
//
// Windows Media Player cannot sync the subscription content because you are not signed in to the online store that provided it. Sign in to the online store, and then try again.%0
//
#define NS_E_PDA_SYNC_LOGIN_ERROR        _HRESULT_TYPEDEF_(0xC00D1244L)

//
// MessageId: NS_E_PDA_TRANSCODE_CODEC_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot convert the file to the format required by the device. One or more codecs required to convert the file could not be found.%0
//
#define NS_E_PDA_TRANSCODE_CODEC_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D1245L)

//
// MessageId: NS_E_CANNOT_SYNC_DRM_TO_NON_JANUS_DEVICE
//
// MessageText:
//
// It is not possible to sync subscription files to this device.%0
//
#define NS_E_CANNOT_SYNC_DRM_TO_NON_JANUS_DEVICE _HRESULT_TYPEDEF_(0xC00D1246L)

//
// MessageId: NS_E_CANNOT_SYNC_PREVIOUS_SYNC_RUNNING
//
// MessageText:
//
// Your device is operating slowly or is not responding. Until the device responds, it is not possible to sync again. To return the device to normal operation, try disconnecting it from the computer or resetting it.%0
//
#define NS_E_CANNOT_SYNC_PREVIOUS_SYNC_RUNNING _HRESULT_TYPEDEF_(0xC00D1247L)

//
//Background download plugin
//
//
// MessageId: NS_E_WMP_HWND_NOTFOUND
//
// MessageText:
//
// The Windows Media Player download manager cannot function properly because the Player main window cannot be found. Try restarting the Player.%0
//
#define NS_E_WMP_HWND_NOTFOUND           _HRESULT_TYPEDEF_(0xC00D125CL)

//
// MessageId: NS_E_BKGDOWNLOAD_WRONG_NO_FILES
//
// MessageText:
//
// Windows Media Player encountered a download that has the wrong number of files. This might occur if another program is trying to create jobs with the same signature as the Player.%0
//
#define NS_E_BKGDOWNLOAD_WRONG_NO_FILES  _HRESULT_TYPEDEF_(0xC00D125DL)

//
// MessageId: NS_E_BKGDOWNLOAD_COMPLETECANCELLEDJOB
//
// MessageText:
//
// Windows Media Player tried to complete a download that was already canceled. The file will not be available.%0
//
#define NS_E_BKGDOWNLOAD_COMPLETECANCELLEDJOB _HRESULT_TYPEDEF_(0xC00D125EL)

//
// MessageId: NS_E_BKGDOWNLOAD_CANCELCOMPLETEDJOB
//
// MessageText:
//
// Windows Media Player tried to cancel a download that was already completed. The file will not be removed.%0
//
#define NS_E_BKGDOWNLOAD_CANCELCOMPLETEDJOB _HRESULT_TYPEDEF_(0xC00D125FL)

//
// MessageId: NS_E_BKGDOWNLOAD_NOJOBPOINTER
//
// MessageText:
//
// Windows Media Player is trying to access a download that is not valid.%0
//
#define NS_E_BKGDOWNLOAD_NOJOBPOINTER    _HRESULT_TYPEDEF_(0xC00D1260L)

//
// MessageId: NS_E_BKGDOWNLOAD_INVALIDJOBSIGNATURE
//
// MessageText:
//
// This download was not created by Windows Media Player.%0
//
#define NS_E_BKGDOWNLOAD_INVALIDJOBSIGNATURE _HRESULT_TYPEDEF_(0xC00D1261L)

//
// MessageId: NS_E_BKGDOWNLOAD_FAILED_TO_CREATE_TEMPFILE
//
// MessageText:
//
// The Windows Media Player download manager cannot create a temporary file name. This might occur if the path is not valid or if the disk is full.%0
//
#define NS_E_BKGDOWNLOAD_FAILED_TO_CREATE_TEMPFILE _HRESULT_TYPEDEF_(0xC00D1262L)

//
// MessageId: NS_E_BKGDOWNLOAD_PLUGIN_FAILEDINITIALIZE
//
// MessageText:
//
// The Windows Media Player download manager plug-in cannot start. This might occur if the system is out of resources.%0
//
#define NS_E_BKGDOWNLOAD_PLUGIN_FAILEDINITIALIZE _HRESULT_TYPEDEF_(0xC00D1263L)

//
// MessageId: NS_E_BKGDOWNLOAD_PLUGIN_FAILEDTOMOVEFILE
//
// MessageText:
//
// The Windows Media Player download manager cannot move the file.%0
//
#define NS_E_BKGDOWNLOAD_PLUGIN_FAILEDTOMOVEFILE _HRESULT_TYPEDEF_(0xC00D1264L)

//
// MessageId: NS_E_BKGDOWNLOAD_CALLFUNCFAILED
//
// MessageText:
//
// The Windows Media Player download manager cannot perform a task because the system has no resources to allocate.%0
//
#define NS_E_BKGDOWNLOAD_CALLFUNCFAILED  _HRESULT_TYPEDEF_(0xC00D1265L)

//
// MessageId: NS_E_BKGDOWNLOAD_CALLFUNCTIMEOUT
//
// MessageText:
//
// The Windows Media Player download manager cannot perform a task because the task took too long to run.%0
//
#define NS_E_BKGDOWNLOAD_CALLFUNCTIMEOUT _HRESULT_TYPEDEF_(0xC00D1266L)

//
// MessageId: NS_E_BKGDOWNLOAD_CALLFUNCENDED
//
// MessageText:
//
// The Windows Media Player download manager cannot perform a task because the Player is terminating the service. The task will be recovered when the Player restarts.%0
//
#define NS_E_BKGDOWNLOAD_CALLFUNCENDED   _HRESULT_TYPEDEF_(0xC00D1267L)

//
// MessageId: NS_E_BKGDOWNLOAD_WMDUNPACKFAILED
//
// MessageText:
//
// The Windows Media Player download manager cannot expand a WMD file. The file will be deleted and the operation will not be completed successfully.%0
//
#define NS_E_BKGDOWNLOAD_WMDUNPACKFAILED _HRESULT_TYPEDEF_(0xC00D1268L)

//
// MessageId: NS_E_BKGDOWNLOAD_FAILEDINITIALIZE
//
// MessageText:
//
// The Windows Media Player download manager cannot start. This might occur if the system is out of resources.%0
//
#define NS_E_BKGDOWNLOAD_FAILEDINITIALIZE _HRESULT_TYPEDEF_(0xC00D1269L)

//
// MessageId: NS_E_INTERFACE_NOT_REGISTERED_IN_GIT
//
// MessageText:
//
// Windows Media Player cannot access a required functionality. This might occur if the wrong system files or Player DLLs are loaded.%0
//
#define NS_E_INTERFACE_NOT_REGISTERED_IN_GIT _HRESULT_TYPEDEF_(0xC00D126AL)

//
// MessageId: NS_E_BKGDOWNLOAD_INVALID_FILE_NAME
//
// MessageText:
//
// Windows Media Player cannot get the file name of the requested download. The requested download will be canceled.%0
//
#define NS_E_BKGDOWNLOAD_INVALID_FILE_NAME _HRESULT_TYPEDEF_(0xC00D126BL)

//
//Image Graph Errors 4750 -- 4800
//
//
// MessageId: NS_E_IMAGE_DOWNLOAD_FAILED
//
// MessageText:
//
// Windows Media Player encountered an error while downloading an image.%0
//
#define NS_E_IMAGE_DOWNLOAD_FAILED       _HRESULT_TYPEDEF_(0xC00D128EL)

//
// UDRM errors
//
//
// MessageId: NS_E_WMP_UDRM_NOUSERLIST
//
// MessageText:
//
// Windows Media Player cannot update your media usage rights because the Player cannot verify the list of activated users of this computer.%0
//
#define NS_E_WMP_UDRM_NOUSERLIST         _HRESULT_TYPEDEF_(0xC00D12C0L)

//
// MessageId: NS_E_WMP_DRM_NOT_ACQUIRING
//
// MessageText:
//
// Windows Media Player is trying to acquire media usage rights for a file that is no longer being used. Rights acquisition will stop.%0
//
#define NS_E_WMP_DRM_NOT_ACQUIRING       _HRESULT_TYPEDEF_(0xC00D12C1L)

//
// String is too large
//
//
// MessageId: NS_E_WMP_BSTR_TOO_LONG
//
// MessageText:
//
// The parameter is not valid.%0
//
#define NS_E_WMP_BSTR_TOO_LONG           _HRESULT_TYPEDEF_(0xC00D12F2L)

//
// Autoplay errors 4860 --- 4870
//
//
// MessageId: NS_E_WMP_AUTOPLAY_INVALID_STATE
//
// MessageText:
//
// The state is not valid for this request.%0
//
#define NS_E_WMP_AUTOPLAY_INVALID_STATE  _HRESULT_TYPEDEF_(0xC00D12FCL)

//
// MF mapped errors 4870 --- 4880
//
//
// MessageId: NS_E_WMP_COMPONENT_REVOKED
//
// MessageText:
//
// Windows Media Player cannot play this file until you complete the software component upgrade. After the component has been upgraded, try to play the file again.%0
//
#define NS_E_WMP_COMPONENT_REVOKED       _HRESULT_TYPEDEF_(0xC00D1306L)

//
// CURL Errors 4900 -- 4920
//
//
// MessageId: NS_E_CURL_NOTSAFE
//
// MessageText:
//
// The URL is not safe for the operation specified.%0
//
#define NS_E_CURL_NOTSAFE                _HRESULT_TYPEDEF_(0xC00D1324L)

//
// MessageId: NS_E_CURL_INVALIDCHAR
//
// MessageText:
//
// The URL contains one or more characters that are not valid.%0
//
#define NS_E_CURL_INVALIDCHAR            _HRESULT_TYPEDEF_(0xC00D1325L)

//
// MessageId: NS_E_CURL_INVALIDHOSTNAME
//
// MessageText:
//
// The URL contains a host name that is not valid.%0
//
#define NS_E_CURL_INVALIDHOSTNAME        _HRESULT_TYPEDEF_(0xC00D1326L)

//
// MessageId: NS_E_CURL_INVALIDPATH
//
// MessageText:
//
// The URL contains a path that is not valid.%0
//
#define NS_E_CURL_INVALIDPATH            _HRESULT_TYPEDEF_(0xC00D1327L)

//
// MessageId: NS_E_CURL_INVALIDSCHEME
//
// MessageText:
//
// The URL contains a scheme that is not valid.%0
//
#define NS_E_CURL_INVALIDSCHEME          _HRESULT_TYPEDEF_(0xC00D1328L)

//
// MessageId: NS_E_CURL_INVALIDURL
//
// MessageText:
//
// The URL is not valid.%0
//
#define NS_E_CURL_INVALIDURL             _HRESULT_TYPEDEF_(0xC00D1329L)

//
// MessageId: NS_E_CURL_CANTWALK
//
// MessageText:
//
// Windows Media Player cannot play the file. If you clicked a link on a web page, the link might not be valid.%0
//
#define NS_E_CURL_CANTWALK               _HRESULT_TYPEDEF_(0xC00D132BL)

//
// MessageId: NS_E_CURL_INVALIDPORT
//
// MessageText:
//
// The URL port is not valid.%0
//
#define NS_E_CURL_INVALIDPORT            _HRESULT_TYPEDEF_(0xC00D132CL)

//
// MessageId: NS_E_CURLHELPER_NOTADIRECTORY
//
// MessageText:
//
// The URL is not a directory.%0
//
#define NS_E_CURLHELPER_NOTADIRECTORY    _HRESULT_TYPEDEF_(0xC00D132DL)

//
// MessageId: NS_E_CURLHELPER_NOTAFILE
//
// MessageText:
//
// The URL is not a file.%0
//
#define NS_E_CURLHELPER_NOTAFILE         _HRESULT_TYPEDEF_(0xC00D132EL)

//
// MessageId: NS_E_CURL_CANTDECODE
//
// MessageText:
//
// The URL contains characters that cannot be decoded. The URL might be truncated or incomplete.%0
//
#define NS_E_CURL_CANTDECODE             _HRESULT_TYPEDEF_(0xC00D132FL)

//
// MessageId: NS_E_CURLHELPER_NOTRELATIVE
//
// MessageText:
//
// The specified URL is not a relative URL.%0
//
#define NS_E_CURLHELPER_NOTRELATIVE      _HRESULT_TYPEDEF_(0xC00D1330L)

//
// MessageId: NS_E_CURL_INVALIDBUFFERSIZE
//
// MessageText:
//
// The buffer is smaller than the size specified.%0
//
#define NS_E_CURL_INVALIDBUFFERSIZE      _HRESULT_TYPEDEF_(0xC00D1331L)

//
// Subscription Service Errors 4950 -- 4969
//
//
// MessageId: NS_E_SUBSCRIPTIONSERVICE_PLAYBACK_DISALLOWED
//
// MessageText:
//
// The content provider has not granted you the right to play this file. Go to the content provider's online store to get play rights.%0
//
#define NS_E_SUBSCRIPTIONSERVICE_PLAYBACK_DISALLOWED _HRESULT_TYPEDEF_(0xC00D1356L)

//
// MessageId: NS_E_CANNOT_BUY_OR_DOWNLOAD_FROM_MULTIPLE_SERVICES
//
// MessageText:
//
// Windows Media Player cannot purchase or download content from multiple online stores.%0
//
#define NS_E_CANNOT_BUY_OR_DOWNLOAD_FROM_MULTIPLE_SERVICES _HRESULT_TYPEDEF_(0xC00D1357L)

//
// MessageId: NS_E_CANNOT_BUY_OR_DOWNLOAD_CONTENT
//
// MessageText:
//
// The file cannot be purchased or downloaded. The file might not be available from the online store.%0
//
#define NS_E_CANNOT_BUY_OR_DOWNLOAD_CONTENT _HRESULT_TYPEDEF_(0xC00D1358L)

//
// MessageId: NS_S_TRACK_BUY_REQUIRES_ALBUM_PURCHASE
//
// MessageText:
//
// The file is only available for purchase when you buy the entire album.%0
//
#define NS_S_TRACK_BUY_REQUIRES_ALBUM_PURCHASE _HRESULT_TYPEDEF_(0x000D1359L)

//
// MessageId: NS_E_NOT_CONTENT_PARTNER_TRACK
//
// MessageText:
//
// The provider of this file cannot be identified.%0
//
#define NS_E_NOT_CONTENT_PARTNER_TRACK   _HRESULT_TYPEDEF_(0xC00D135AL)

//
// MessageId: NS_E_TRACK_DOWNLOAD_REQUIRES_ALBUM_PURCHASE
//
// MessageText:
//
// The file is only available for download when you buy the entire album.%0
//
#define NS_E_TRACK_DOWNLOAD_REQUIRES_ALBUM_PURCHASE _HRESULT_TYPEDEF_(0xC00D135BL)

//
// MessageId: NS_E_TRACK_DOWNLOAD_REQUIRES_PURCHASE
//
// MessageText:
//
// You must buy the file before you can download it.%0
//
#define NS_E_TRACK_DOWNLOAD_REQUIRES_PURCHASE _HRESULT_TYPEDEF_(0xC00D135CL)

//
// MessageId: NS_E_TRACK_PURCHASE_MAXIMUM_EXCEEDED
//
// MessageText:
//
// You have exceeded the maximum number of files that can be purchased in a single transaction.%0
//
#define NS_E_TRACK_PURCHASE_MAXIMUM_EXCEEDED _HRESULT_TYPEDEF_(0xC00D135DL)

//
// MessageId: NS_S_NAVIGATION_COMPLETE_WITH_ERRORS
//
// MessageText:
//
// There were problems completing the requested navigation. There are identifiers missing in the catalog.%0
//
#define NS_S_NAVIGATION_COMPLETE_WITH_ERRORS _HRESULT_TYPEDEF_(0x000D135EL)

//
// MessageId: NS_E_SUBSCRIPTIONSERVICE_LOGIN_FAILED
//
// MessageText:
//
// Windows Media Player cannot sign in to the online store. Verify that you are using the correct user name and password. If the problem persists, the store might be temporarily unavailable.%0
//
#define NS_E_SUBSCRIPTIONSERVICE_LOGIN_FAILED _HRESULT_TYPEDEF_(0xC00D135FL)

//
// MessageId: NS_E_SUBSCRIPTIONSERVICE_DOWNLOAD_TIMEOUT
//
// MessageText:
//
// Windows Media Player cannot download this item because the server is not responding. The server might be temporarily unavailable or you might have lost your Internet connection.%0
//
#define NS_E_SUBSCRIPTIONSERVICE_DOWNLOAD_TIMEOUT _HRESULT_TYPEDEF_(0xC00D1360L)

//
// MessageId: NS_S_TRACK_ALREADY_DOWNLOADED
//
// MessageText:
//
//  NS_S_TRACK_ALREADY_DOWNLOADED
//
#define NS_S_TRACK_ALREADY_DOWNLOADED    _HRESULT_TYPEDEF_(0x000D1361L)

//
// MessageId: NS_E_CONTENT_PARTNER_STILL_INITIALIZING
//
// MessageText:
//
// The content provider is still initializing.
//
#define NS_E_CONTENT_PARTNER_STILL_INITIALIZING _HRESULT_TYPEDEF_(0xC00D1362L)

//
// MessageId: NS_E_OPEN_CONTAINING_FOLDER_FAILED
//
// MessageText:
//
// The folder could not be opened. The folder might have been moved or deleted.
//
#define NS_E_OPEN_CONTAINING_FOLDER_FAILED _HRESULT_TYPEDEF_(0xC00D1363L)

//
// Advanced Edit Dialog Errors 4970 -- 4989
//
//
// MessageId: NS_E_ADVANCEDEDIT_TOO_MANY_PICTURES
//
// MessageText:
//
// Windows Media Player could not add all of the images to the file because the images exceeded the 7 megabyte (MB) limit.%0
//
#define NS_E_ADVANCEDEDIT_TOO_MANY_PICTURES _HRESULT_TYPEDEF_(0xC00D136AL)



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Server Errors
//
// IdRange = 5000 - 5999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_REDIRECT
//
// MessageText:
//
// The client redirected to another server.%0
//
#define NS_E_REDIRECT                    _HRESULT_TYPEDEF_(0xC00D1388L)

//
// MessageId: NS_E_STALE_PRESENTATION
//
// MessageText:
//
// The streaming media description is no longer current.%0
//
#define NS_E_STALE_PRESENTATION          _HRESULT_TYPEDEF_(0xC00D1389L)


 // Namespace Errors

//
// MessageId: NS_E_NAMESPACE_WRONG_PERSIST
//
// MessageText:
//
// It is not possible to create a persistent namespace node under a transient parent node.%0
//
#define NS_E_NAMESPACE_WRONG_PERSIST     _HRESULT_TYPEDEF_(0xC00D138AL)

//
// MessageId: NS_E_NAMESPACE_WRONG_TYPE
//
// MessageText:
//
// It is not possible to store a value in a namespace node that has a different value type.%0
//
#define NS_E_NAMESPACE_WRONG_TYPE        _HRESULT_TYPEDEF_(0xC00D138BL)

//
// MessageId: NS_E_NAMESPACE_NODE_CONFLICT
//
// MessageText:
//
// It is not possible to remove the root namespace node.%0
//
#define NS_E_NAMESPACE_NODE_CONFLICT     _HRESULT_TYPEDEF_(0xC00D138CL)

//
// MessageId: NS_E_NAMESPACE_NODE_NOT_FOUND
//
// MessageText:
//
// The specified namespace node could not be found.%0
//
#define NS_E_NAMESPACE_NODE_NOT_FOUND    _HRESULT_TYPEDEF_(0xC00D138DL)

//
// MessageId: NS_E_NAMESPACE_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer supplied to hold namespace node string is too small.%0
//
#define NS_E_NAMESPACE_BUFFER_TOO_SMALL  _HRESULT_TYPEDEF_(0xC00D138EL)

//
// MessageId: NS_E_NAMESPACE_TOO_MANY_CALLBACKS
//
// MessageText:
//
// The callback list on a namespace node is at the maximum size.%0
//
#define NS_E_NAMESPACE_TOO_MANY_CALLBACKS _HRESULT_TYPEDEF_(0xC00D138FL)

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_CALLBACK
//
// MessageText:
//
// It is not possible to register an already-registered callback on a namespace node.%0
//
#define NS_E_NAMESPACE_DUPLICATE_CALLBACK _HRESULT_TYPEDEF_(0xC00D1390L)

//
// MessageId: NS_E_NAMESPACE_CALLBACK_NOT_FOUND
//
// MessageText:
//
// Cannot find the callback in the namespace when attempting to remove the callback.%0
//
#define NS_E_NAMESPACE_CALLBACK_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D1391L)

//
// MessageId: NS_E_NAMESPACE_NAME_TOO_LONG
//
// MessageText:
//
// The namespace node name exceeds the allowed maximum length.%0
//
#define NS_E_NAMESPACE_NAME_TOO_LONG     _HRESULT_TYPEDEF_(0xC00D1392L)

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_NAME
//
// MessageText:
//
// Cannot create a namespace node that already exists.%0
//
#define NS_E_NAMESPACE_DUPLICATE_NAME    _HRESULT_TYPEDEF_(0xC00D1393L)

//
// MessageId: NS_E_NAMESPACE_EMPTY_NAME
//
// MessageText:
//
// The namespace node name cannot be a null string.%0
//
#define NS_E_NAMESPACE_EMPTY_NAME        _HRESULT_TYPEDEF_(0xC00D1394L)

//
// MessageId: NS_E_NAMESPACE_INDEX_TOO_LARGE
//
// MessageText:
//
// Finding a child namespace node by index failed because the index exceeded the number of children.%0
//
#define NS_E_NAMESPACE_INDEX_TOO_LARGE   _HRESULT_TYPEDEF_(0xC00D1395L)

//
// MessageId: NS_E_NAMESPACE_BAD_NAME
//
// MessageText:
//
// The namespace node name is invalid.%0
//
#define NS_E_NAMESPACE_BAD_NAME          _HRESULT_TYPEDEF_(0xC00D1396L)

//
// MessageId: NS_E_NAMESPACE_WRONG_SECURITY
//
// MessageText:
//
// It is not possible to store a value in a namespace node that has a different security type.%0
//
#define NS_E_NAMESPACE_WRONG_SECURITY    _HRESULT_TYPEDEF_(0xC00D1397L)


 // Cache Errors 5100-5199

//
// MessageId: NS_E_CACHE_ARCHIVE_CONFLICT
//
// MessageText:
//
// The archive request conflicts with other requests in progress.%0
//
#define NS_E_CACHE_ARCHIVE_CONFLICT      _HRESULT_TYPEDEF_(0xC00D13ECL)

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND
//
// MessageText:
//
// The specified origin server cannot be found.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D13EDL)

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_TIMEOUT
//
// MessageText:
//
// The specified origin server is not responding.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_TIMEOUT _HRESULT_TYPEDEF_(0xC00D13EEL)

//
// MessageId: NS_E_CACHE_NOT_BROADCAST
//
// MessageText:
//
// The internal code for HTTP status code 412 Precondition Failed due to not broadcast type.%0
//
#define NS_E_CACHE_NOT_BROADCAST         _HRESULT_TYPEDEF_(0xC00D13EFL)

//
// MessageId: NS_E_CACHE_CANNOT_BE_CACHED
//
// MessageText:
//
// The internal code for HTTP status code 403 Forbidden due to not cacheable.%0
//
#define NS_E_CACHE_CANNOT_BE_CACHED      _HRESULT_TYPEDEF_(0xC00D13F0L)

//
// MessageId: NS_E_CACHE_NOT_MODIFIED
//
// MessageText:
//
// The internal code for HTTP status code 304 Not Modified.%0
//
#define NS_E_CACHE_NOT_MODIFIED          _HRESULT_TYPEDEF_(0xC00D13F1L)


// Object Model Errors 5200-5299

//
// MessageId: NS_E_CANNOT_REMOVE_PUBLISHING_POINT
//
// MessageText:
//
// It is not possible to remove a cache or proxy publishing point.%0
//
#define NS_E_CANNOT_REMOVE_PUBLISHING_POINT _HRESULT_TYPEDEF_(0xC00D1450L)

//
// MessageId: NS_E_CANNOT_REMOVE_PLUGIN
//
// MessageText:
//
// It is not possible to remove the last instance of a type of plug-in.%0
//
#define NS_E_CANNOT_REMOVE_PLUGIN        _HRESULT_TYPEDEF_(0xC00D1451L)

//
// MessageId: NS_E_WRONG_PUBLISHING_POINT_TYPE
//
// MessageText:
//
// Cache and proxy publishing points do not support this property or method.%0
//
#define NS_E_WRONG_PUBLISHING_POINT_TYPE _HRESULT_TYPEDEF_(0xC00D1452L)

//
// MessageId: NS_E_UNSUPPORTED_LOAD_TYPE
//
// MessageText:
//
// The plug-in does not support the specified load type.%0
//
#define NS_E_UNSUPPORTED_LOAD_TYPE       _HRESULT_TYPEDEF_(0xC00D1453L)

//
// MessageId: NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION
//
// MessageText:
//
// The plug-in does not support any load types. The plug-in must support at least one load type.%0
//
#define NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION _HRESULT_TYPEDEF_(0xC00D1454L)

//
// MessageId: NS_E_INVALID_PUBLISHING_POINT_NAME
//
// MessageText:
//
// The publishing point name is invalid.%0
//
#define NS_E_INVALID_PUBLISHING_POINT_NAME _HRESULT_TYPEDEF_(0xC00D1455L)

//
// MessageId: NS_E_TOO_MANY_MULTICAST_SINKS
//
// MessageText:
//
// Only one multicast data writer plug-in can be enabled for a publishing point.%0
//
#define NS_E_TOO_MANY_MULTICAST_SINKS    _HRESULT_TYPEDEF_(0xC00D1456L)

//
// MessageId: NS_E_PUBLISHING_POINT_INVALID_REQUEST_WHILE_STARTED
//
// MessageText:
//
// The requested operation cannot be completed while the publishing point is started.%0
//
#define NS_E_PUBLISHING_POINT_INVALID_REQUEST_WHILE_STARTED _HRESULT_TYPEDEF_(0xC00D1457L)

//
// MessageId: NS_E_MULTICAST_PLUGIN_NOT_ENABLED
//
// MessageText:
//
// A multicast data writer plug-in must be enabled in order for this operation to be completed.%0
//
#define NS_E_MULTICAST_PLUGIN_NOT_ENABLED _HRESULT_TYPEDEF_(0xC00D1458L)

//
// MessageId: NS_E_INVALID_OPERATING_SYSTEM_VERSION
//
// MessageText:
//
// This feature requires Windows Server 2003, Enterprise Edition.%0
//
#define NS_E_INVALID_OPERATING_SYSTEM_VERSION _HRESULT_TYPEDEF_(0xC00D1459L)

//
// MessageId: NS_E_PUBLISHING_POINT_REMOVED
//
// MessageText:
//
// The requested operation cannot be completed because the specified publishing point has been removed.%0
//
#define NS_E_PUBLISHING_POINT_REMOVED    _HRESULT_TYPEDEF_(0xC00D145AL)

//
// MessageId: NS_E_INVALID_PUSH_PUBLISHING_POINT_START_REQUEST
//
// MessageText:
//
// Push publishing points are started when the encoder starts pushing the stream. This publishing point cannot be started by the server administrator.%0
//
#define NS_E_INVALID_PUSH_PUBLISHING_POINT_START_REQUEST _HRESULT_TYPEDEF_(0xC00D145BL)

//
// MessageId: NS_E_UNSUPPORTED_LANGUAGE
//
// MessageText:
//
// The specified language is not supported.%0
//
#define NS_E_UNSUPPORTED_LANGUAGE        _HRESULT_TYPEDEF_(0xC00D145CL)

//
// MessageId: NS_E_WRONG_OS_VERSION
//
// MessageText:
//
// Windows Media Services will only run on Windows Server 2003, Standard Edition and Windows Server 2003, Enterprise Edition.%0
//
#define NS_E_WRONG_OS_VERSION            _HRESULT_TYPEDEF_(0xC00D145DL)

//
// MessageId: NS_E_PUBLISHING_POINT_STOPPED
//
// MessageText:
//
// The operation cannot be completed because the publishing point has been stopped.%0
//
#define NS_E_PUBLISHING_POINT_STOPPED    _HRESULT_TYPEDEF_(0xC00D145EL)


// Playlist Errors 5300-5399

//
// MessageId: NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING
//
// MessageText:
//
// The playlist entry is already playing.%0
//
#define NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING _HRESULT_TYPEDEF_(0xC00D14B4L)

//
// MessageId: NS_E_EMPTY_PLAYLIST
//
// MessageText:
//
// The playlist or directory you are requesting does not contain content.%0
//
#define NS_E_EMPTY_PLAYLIST              _HRESULT_TYPEDEF_(0xC00D14B5L)

//
// MessageId: NS_E_PLAYLIST_PARSE_FAILURE
//
// MessageText:
//
// The server was unable to parse the requested playlist file.%0
//
#define NS_E_PLAYLIST_PARSE_FAILURE      _HRESULT_TYPEDEF_(0xC00D14B6L)

//
// MessageId: NS_E_PLAYLIST_UNSUPPORTED_ENTRY
//
// MessageText:
//
// The requested operation is not supported for this type of playlist entry.%0
//
#define NS_E_PLAYLIST_UNSUPPORTED_ENTRY  _HRESULT_TYPEDEF_(0xC00D14B7L)

//
// MessageId: NS_E_PLAYLIST_ENTRY_NOT_IN_PLAYLIST
//
// MessageText:
//
// Cannot jump to a playlist entry that is not inserted in the playlist.%0
//
#define NS_E_PLAYLIST_ENTRY_NOT_IN_PLAYLIST _HRESULT_TYPEDEF_(0xC00D14B8L)

//
// MessageId: NS_E_PLAYLIST_ENTRY_SEEK
//
// MessageText:
//
// Cannot seek to the desired playlist entry.%0
//
#define NS_E_PLAYLIST_ENTRY_SEEK         _HRESULT_TYPEDEF_(0xC00D14B9L)

//
// MessageId: NS_E_PLAYLIST_RECURSIVE_PLAYLISTS
//
// MessageText:
//
// Cannot play recursive playlist.%0
//
#define NS_E_PLAYLIST_RECURSIVE_PLAYLISTS _HRESULT_TYPEDEF_(0xC00D14BAL)

//
// MessageId: NS_E_PLAYLIST_TOO_MANY_NESTED_PLAYLISTS
//
// MessageText:
//
// The number of nested playlists exceeded the limit the server can handle.%0
//
#define NS_E_PLAYLIST_TOO_MANY_NESTED_PLAYLISTS _HRESULT_TYPEDEF_(0xC00D14BBL)

//
// MessageId: NS_E_PLAYLIST_SHUTDOWN
//
// MessageText:
//
// Cannot execute the requested operation because the playlist has been shut down by the Media Server.%0
//
#define NS_E_PLAYLIST_SHUTDOWN           _HRESULT_TYPEDEF_(0xC00D14BCL)

//
// MessageId: NS_E_PLAYLIST_END_RECEDING
//
// MessageText:
//
// The playlist has ended while receding.%0
//
#define NS_E_PLAYLIST_END_RECEDING       _HRESULT_TYPEDEF_(0xC00D14BDL)

//
// MessageId: NS_I_PLAYLIST_CHANGE_RECEDING
//
// MessageText:
//
// The playlist change occurred while receding.%0
//
#define NS_I_PLAYLIST_CHANGE_RECEDING    _HRESULT_TYPEDEF_(0x400D14BEL)


// Datapath Errors -- 5400 - 5499

//
// MessageId: NS_E_DATAPATH_NO_SINK
//
// MessageText:
//
// The data path does not have an associated data writer plug-in.%0
//
#define NS_E_DATAPATH_NO_SINK            _HRESULT_TYPEDEF_(0xC00D1518L)

//
// MessageId: NS_S_PUBLISHING_POINT_STARTED_WITH_FAILED_SINKS
//
// MessageText:
//
// The publishing point successfully started, but one or more of the requested data writer plug-ins failed.%0
//
#define NS_S_PUBLISHING_POINT_STARTED_WITH_FAILED_SINKS _HRESULT_TYPEDEF_(0x000D1519L)

//
// MessageId: NS_E_INVALID_PUSH_TEMPLATE
//
// MessageText:
//
// The specified push template is invalid.%0
//
#define NS_E_INVALID_PUSH_TEMPLATE       _HRESULT_TYPEDEF_(0xC00D151AL)

//
// MessageId: NS_E_INVALID_PUSH_PUBLISHING_POINT
//
// MessageText:
//
// The specified push publishing point is invalid.%0
//
#define NS_E_INVALID_PUSH_PUBLISHING_POINT _HRESULT_TYPEDEF_(0xC00D151BL)

//
// MessageId: NS_E_CRITICAL_ERROR
//
// MessageText:
//
// The requested operation cannot be performed because the server or publishing point is in a critical error state.%0
//
#define NS_E_CRITICAL_ERROR              _HRESULT_TYPEDEF_(0xC00D151CL)

//
// MessageId: NS_E_NO_NEW_CONNECTIONS
//
// MessageText:
//
// The content can not be played because the server is not currently accepting connections. Try connecting at a later time.%0
//
#define NS_E_NO_NEW_CONNECTIONS          _HRESULT_TYPEDEF_(0xC00D151DL)

//
// MessageId: NS_E_WSX_INVALID_VERSION
//
// MessageText:
//
// The version of this playlist is not supported by the server.%0
//
#define NS_E_WSX_INVALID_VERSION         _HRESULT_TYPEDEF_(0xC00D151EL)

//
// MessageId: NS_E_HEADER_MISMATCH
//
// MessageText:
//
// The command does not apply to the current media header user by a server component.%0
//
#define NS_E_HEADER_MISMATCH             _HRESULT_TYPEDEF_(0xC00D151FL)

//
// MessageId: NS_E_PUSH_DUPLICATE_PUBLISHING_POINT_NAME
//
// MessageText:
//
// The specified publishing point name is already in use.%0
//
#define NS_E_PUSH_DUPLICATE_PUBLISHING_POINT_NAME _HRESULT_TYPEDEF_(0xC00D1520L)


// Plugin Errors -- 5500 - 5599

//
// MessageId: NS_E_NO_SCRIPT_ENGINE
//
// MessageText:
//
// There is no script engine available for this file.%0
//
#define NS_E_NO_SCRIPT_ENGINE            _HRESULT_TYPEDEF_(0xC00D157CL)

//
// MessageId: NS_E_PLUGIN_ERROR_REPORTED
//
// MessageText:
//
// The plug-in has reported an error. See the Troubleshooting tab or the NT Application Event Log for details.%0
//
#define NS_E_PLUGIN_ERROR_REPORTED       _HRESULT_TYPEDEF_(0xC00D157DL)

//
// MessageId: NS_E_SOURCE_PLUGIN_NOT_FOUND
//
// MessageText:
//
// No enabled data source plug-in is available to access the requested content.%0
//
#define NS_E_SOURCE_PLUGIN_NOT_FOUND     _HRESULT_TYPEDEF_(0xC00D157EL)

//
// MessageId: NS_E_PLAYLIST_PLUGIN_NOT_FOUND
//
// MessageText:
//
// No enabled playlist parser plug-in is available to access the requested content.%0
//
#define NS_E_PLAYLIST_PLUGIN_NOT_FOUND   _HRESULT_TYPEDEF_(0xC00D157FL)

//
// MessageId: NS_E_DATA_SOURCE_ENUMERATION_NOT_SUPPORTED
//
// MessageText:
//
// The data source plug-in does not support enumeration.%0
//
#define NS_E_DATA_SOURCE_ENUMERATION_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D1580L)

//
// MessageId: NS_E_MEDIA_PARSER_INVALID_FORMAT
//
// MessageText:
//
// The server cannot stream the selected file because it is either damaged or corrupt. Select a different file.%0
//
#define NS_E_MEDIA_PARSER_INVALID_FORMAT _HRESULT_TYPEDEF_(0xC00D1581L)

//
// MessageId: NS_E_SCRIPT_DEBUGGER_NOT_INSTALLED
//
// MessageText:
//
// The plug-in cannot be enabled because a compatible script debugger is not installed on this system.  Install a script debugger, or disable the script debugger option on the general tab of the plug-in's properties page and try again.%0
//
#define NS_E_SCRIPT_DEBUGGER_NOT_INSTALLED _HRESULT_TYPEDEF_(0xC00D1582L)

//
// MessageId: NS_E_FEATURE_REQUIRES_ENTERPRISE_SERVER
//
// MessageText:
//
// The plug-in cannot be loaded because it requires Windows Server 2003, Enterprise Edition.%0
//
#define NS_E_FEATURE_REQUIRES_ENTERPRISE_SERVER _HRESULT_TYPEDEF_(0xC00D1583L)

//
// MessageId: NS_E_WIZARD_RUNNING
//
// MessageText:
//
// Another wizard is currently running. Please close the other wizard or wait until it finishes before attempting to run this wizard again.%0
//
#define NS_E_WIZARD_RUNNING              _HRESULT_TYPEDEF_(0xC00D1584L)

//
// MessageId: NS_E_INVALID_LOG_URL
//
// MessageText:
//
// Invalid log URL. Multicast logging URL must look like "http://servername/isapibackend.dll" .%0
//
#define NS_E_INVALID_LOG_URL             _HRESULT_TYPEDEF_(0xC00D1585L)

//
// MessageId: NS_E_INVALID_MTU_RANGE
//
// MessageText:
//
// Invalid MTU specified. The valid range for maximum packet size is between 36  and 65507 bytes .%0
//
#define NS_E_INVALID_MTU_RANGE           _HRESULT_TYPEDEF_(0xC00D1586L)

//
// MessageId: NS_E_INVALID_PLAY_STATISTICS
//
// MessageText:
//
// Invalid play statistics for logging .%0
//
#define NS_E_INVALID_PLAY_STATISTICS     _HRESULT_TYPEDEF_(0xC00D1587L)

//
// MessageId: NS_E_LOG_NEED_TO_BE_SKIPPED
//
// MessageText:
//
// The log needs to be skipped .%0
//
#define NS_E_LOG_NEED_TO_BE_SKIPPED      _HRESULT_TYPEDEF_(0xC00D1588L)

//
// MessageId: NS_E_HTTP_TEXT_DATACONTAINER_SIZE_LIMIT_EXCEEDED
//
// MessageText:
//
// The size of the data exceeded the limit the WMS HTTP Download Data Source plugin can handle.%0
//
#define NS_E_HTTP_TEXT_DATACONTAINER_SIZE_LIMIT_EXCEEDED _HRESULT_TYPEDEF_(0xC00D1589L)

//
// MessageId: NS_E_PORT_IN_USE
//
// MessageText:
//
// One usage of each socket address (protocol/network address/port) is permitted. Verify that other services or applications are not attempting to use the same port and then try to enable the plug-in again.%0
//
#define NS_E_PORT_IN_USE                 _HRESULT_TYPEDEF_(0xC00D158AL)

//
// MessageId: NS_E_PORT_IN_USE_HTTP
//
// MessageText:
//
// One usage of each socket address (protocol/network address/port) is permitted. Verify that other services (such as IIS) or applications are not attempting to use the same port and then try to enable the plug-in again.%0
//
#define NS_E_PORT_IN_USE_HTTP            _HRESULT_TYPEDEF_(0xC00D158BL)

//
// MessageId: NS_E_HTTP_TEXT_DATACONTAINER_INVALID_SERVER_RESPONSE
//
// MessageText:
//
// The WMS HTTP Download Data Source plugin was unable to receive the remote server's response.%0
//
#define NS_E_HTTP_TEXT_DATACONTAINER_INVALID_SERVER_RESPONSE _HRESULT_TYPEDEF_(0xC00D158CL)

//
// MessageId: NS_E_ARCHIVE_REACH_QUOTA
//
// MessageText:
//
// The archive plug-in has reached its quota.%0
//
#define NS_E_ARCHIVE_REACH_QUOTA         _HRESULT_TYPEDEF_(0xC00D158DL)

//
// MessageId: NS_E_ARCHIVE_ABORT_DUE_TO_BCAST
//
// MessageText:
//
// The archive plug-in aborted because the source was from broadcast.%0
//
#define NS_E_ARCHIVE_ABORT_DUE_TO_BCAST  _HRESULT_TYPEDEF_(0xC00D158EL)

//
// MessageId: NS_E_ARCHIVE_GAP_DETECTED
//
// MessageText:
//
// The archive plug-in detected an interrupt in the source.%0
//
#define NS_E_ARCHIVE_GAP_DETECTED        _HRESULT_TYPEDEF_(0xC00D158FL)

//
// MessageId: NS_E_AUTHORIZATION_FILE_NOT_FOUND
//
// MessageText:
//
// The system cannot find the file specified.%0
//
#define NS_E_AUTHORIZATION_FILE_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D1590L)



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Tools Errors
//
// IdRange = 7000 - 7999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_BAD_MARKIN
//
// MessageText:
//
// The mark-in time should be greater than 0 and less than the mark-out time.%0
//
#define NS_E_BAD_MARKIN                  _HRESULT_TYPEDEF_(0xC00D1B58L)

//
// MessageId: NS_E_BAD_MARKOUT
//
// MessageText:
//
// The mark-out time should be greater than the mark-in time and less than the file duration.%0
//
#define NS_E_BAD_MARKOUT                 _HRESULT_TYPEDEF_(0xC00D1B59L)

//
// MessageId: NS_E_NOMATCHING_MEDIASOURCE
//
// MessageText:
//
// No matching media type is found in the source %1.%0
//
#define NS_E_NOMATCHING_MEDIASOURCE      _HRESULT_TYPEDEF_(0xC00D1B5AL)

//
// MessageId: NS_E_UNSUPPORTED_SOURCETYPE
//
// MessageText:
//
// The specified source type is not supported.%0
//
#define NS_E_UNSUPPORTED_SOURCETYPE      _HRESULT_TYPEDEF_(0xC00D1B5BL)

//
// MessageId: NS_E_TOO_MANY_AUDIO
//
// MessageText:
//
// It is not possible to specify more than one audio input.%0
//
#define NS_E_TOO_MANY_AUDIO              _HRESULT_TYPEDEF_(0xC00D1B5CL)

//
// MessageId: NS_E_TOO_MANY_VIDEO
//
// MessageText:
//
// It is not possible to specify more than two video inputs.%0
//
#define NS_E_TOO_MANY_VIDEO              _HRESULT_TYPEDEF_(0xC00D1B5DL)

//
// MessageId: NS_E_NOMATCHING_ELEMENT
//
// MessageText:
//
// No matching element is found in the list.%0
//
#define NS_E_NOMATCHING_ELEMENT          _HRESULT_TYPEDEF_(0xC00D1B5EL)

//
// MessageId: NS_E_MISMATCHED_MEDIACONTENT
//
// MessageText:
//
// The profile's media types must match the media types defined for the session.%0
//
#define NS_E_MISMATCHED_MEDIACONTENT     _HRESULT_TYPEDEF_(0xC00D1B5FL)

//
// MessageId: NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP
//
// MessageText:
//
// It is not possible to remove an active source while encoding.%0
//
#define NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP _HRESULT_TYPEDEF_(0xC00D1B60L)

//
// MessageId: NS_E_AUDIODEVICE_BUSY
//
// MessageText:
//
// It is not possible to open the specified audio capture device because it is currently in use.%0
//
#define NS_E_AUDIODEVICE_BUSY            _HRESULT_TYPEDEF_(0xC00D1B61L)

//
// MessageId: NS_E_AUDIODEVICE_UNEXPECTED
//
// MessageText:
//
// It is not possible to open the specified audio capture device because an unexpected error has occurred.%0
//
#define NS_E_AUDIODEVICE_UNEXPECTED      _HRESULT_TYPEDEF_(0xC00D1B62L)

//
// MessageId: NS_E_AUDIODEVICE_BADFORMAT
//
// MessageText:
//
// The audio capture device does not support the specified audio format.%0
//
#define NS_E_AUDIODEVICE_BADFORMAT       _HRESULT_TYPEDEF_(0xC00D1B63L)

//
// MessageId: NS_E_VIDEODEVICE_BUSY
//
// MessageText:
//
// It is not possible to open the specified video capture device because it is currently in use.%0
//
#define NS_E_VIDEODEVICE_BUSY            _HRESULT_TYPEDEF_(0xC00D1B64L)

//
// MessageId: NS_E_VIDEODEVICE_UNEXPECTED
//
// MessageText:
//
// It is not possible to open the specified video capture device because an unexpected error has occurred.%0
//
#define NS_E_VIDEODEVICE_UNEXPECTED      _HRESULT_TYPEDEF_(0xC00D1B65L)

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING
//
// MessageText:
//
// This operation is not allowed while encoding.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING _HRESULT_TYPEDEF_(0xC00D1B66L)

//
// MessageId: NS_E_NO_PROFILE_IN_SOURCEGROUP
//
// MessageText:
//
// No profile is set for the source.%0
//
#define NS_E_NO_PROFILE_IN_SOURCEGROUP   _HRESULT_TYPEDEF_(0xC00D1B67L)

//
// MessageId: NS_E_VIDEODRIVER_UNSTABLE
//
// MessageText:
//
// The video capture driver returned an unrecoverable error.  It is now in an unstable state.%0
//
#define NS_E_VIDEODRIVER_UNSTABLE        _HRESULT_TYPEDEF_(0xC00D1B68L)

//
// MessageId: NS_E_VIDCAPSTARTFAILED
//
// MessageText:
//
// It was not possible to start the video device.%0
//
#define NS_E_VIDCAPSTARTFAILED           _HRESULT_TYPEDEF_(0xC00D1B69L)

//
// MessageId: NS_E_VIDSOURCECOMPRESSION
//
// MessageText:
//
// The video source does not support the requested output format or color depth.%0
//
#define NS_E_VIDSOURCECOMPRESSION        _HRESULT_TYPEDEF_(0xC00D1B6AL)

//
// MessageId: NS_E_VIDSOURCESIZE
//
// MessageText:
//
// The video source does not support the requested capture size.%0
//
#define NS_E_VIDSOURCESIZE               _HRESULT_TYPEDEF_(0xC00D1B6BL)

//
// MessageId: NS_E_ICMQUERYFORMAT
//
// MessageText:
//
// It was not possible to obtain output information from the video compressor.%0
//
#define NS_E_ICMQUERYFORMAT              _HRESULT_TYPEDEF_(0xC00D1B6CL)

//
// MessageId: NS_E_VIDCAPCREATEWINDOW
//
// MessageText:
//
// It was not possible to create a video capture window.%0
//
#define NS_E_VIDCAPCREATEWINDOW          _HRESULT_TYPEDEF_(0xC00D1B6DL)

//
// MessageId: NS_E_VIDCAPDRVINUSE
//
// MessageText:
//
// There is already a stream active on this video device.%0
//
#define NS_E_VIDCAPDRVINUSE              _HRESULT_TYPEDEF_(0xC00D1B6EL)

//
// MessageId: NS_E_NO_MEDIAFORMAT_IN_SOURCE
//
// MessageText:
//
// No media format is set in source.%0
//
#define NS_E_NO_MEDIAFORMAT_IN_SOURCE    _HRESULT_TYPEDEF_(0xC00D1B6FL)

//
// MessageId: NS_E_NO_VALID_OUTPUT_STREAM
//
// MessageText:
//
// Cannot find a valid output stream from the source.%0
//
#define NS_E_NO_VALID_OUTPUT_STREAM      _HRESULT_TYPEDEF_(0xC00D1B70L)

//
// MessageId: NS_E_NO_VALID_SOURCE_PLUGIN
//
// MessageText:
//
// It was not possible to find a valid source plug-in for the specified source.%0
//
#define NS_E_NO_VALID_SOURCE_PLUGIN      _HRESULT_TYPEDEF_(0xC00D1B71L)

//
// MessageId: NS_E_NO_ACTIVE_SOURCEGROUP
//
// MessageText:
//
// No source is currently active.%0
//
#define NS_E_NO_ACTIVE_SOURCEGROUP       _HRESULT_TYPEDEF_(0xC00D1B72L)

//
// MessageId: NS_E_NO_SCRIPT_STREAM
//
// MessageText:
//
// No script stream is set in the current source.%0
//
#define NS_E_NO_SCRIPT_STREAM            _HRESULT_TYPEDEF_(0xC00D1B73L)

//
// MessageId: NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING
//
// MessageText:
//
// This operation is not allowed while archiving.%0
//
#define NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING _HRESULT_TYPEDEF_(0xC00D1B74L)

//
// MessageId: NS_E_INVALIDPACKETSIZE
//
// MessageText:
//
// The setting for the maximum packet size is not valid.%0
//
#define NS_E_INVALIDPACKETSIZE           _HRESULT_TYPEDEF_(0xC00D1B75L)

//
// MessageId: NS_E_PLUGIN_CLSID_INVALID
//
// MessageText:
//
// The plug-in CLSID specified is not valid.%0
//
#define NS_E_PLUGIN_CLSID_INVALID        _HRESULT_TYPEDEF_(0xC00D1B76L)

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVETYPE
//
// MessageText:
//
// This archive type is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVETYPE     _HRESULT_TYPEDEF_(0xC00D1B77L)

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVEOPERATION
//
// MessageText:
//
// This archive operation is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVEOPERATION _HRESULT_TYPEDEF_(0xC00D1B78L)

//
// MessageId: NS_E_ARCHIVE_FILENAME_NOTSET
//
// MessageText:
//
// The local archive file name was not set.%0
//
#define NS_E_ARCHIVE_FILENAME_NOTSET     _HRESULT_TYPEDEF_(0xC00D1B79L)

//
// MessageId: NS_E_SOURCEGROUP_NOTPREPARED
//
// MessageText:
//
// The source is not yet prepared.%0
//
#define NS_E_SOURCEGROUP_NOTPREPARED     _HRESULT_TYPEDEF_(0xC00D1B7AL)

//
// MessageId: NS_E_PROFILE_MISMATCH
//
// MessageText:
//
// Profiles on the sources do not match.%0
//
#define NS_E_PROFILE_MISMATCH            _HRESULT_TYPEDEF_(0xC00D1B7BL)

//
// MessageId: NS_E_INCORRECTCLIPSETTINGS
//
// MessageText:
//
// The specified crop values are not valid.%0
//
#define NS_E_INCORRECTCLIPSETTINGS       _HRESULT_TYPEDEF_(0xC00D1B7CL)

//
// MessageId: NS_E_NOSTATSAVAILABLE
//
// MessageText:
//
// No statistics are available at this time.%0
//
#define NS_E_NOSTATSAVAILABLE            _HRESULT_TYPEDEF_(0xC00D1B7DL)

//
// MessageId: NS_E_NOTARCHIVING
//
// MessageText:
//
// The encoder is not archiving.%0
//
#define NS_E_NOTARCHIVING                _HRESULT_TYPEDEF_(0xC00D1B7EL)

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED
//
// MessageText:
//
// This operation is only allowed during encoding.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED _HRESULT_TYPEDEF_(0xC00D1B7FL)

//
// MessageId: NS_E_NOSOURCEGROUPS
//
// MessageText:
//
// This SourceGroupCollection doesn't contain any SourceGroups.%0
//
#define NS_E_NOSOURCEGROUPS              _HRESULT_TYPEDEF_(0xC00D1B80L)

//
// MessageId: NS_E_INVALIDINPUTFPS
//
// MessageText:
//
// This source does not have a frame rate of 30 fps. Therefore, it is not possible to apply the inverse telecine filter to the source.%0
//
#define NS_E_INVALIDINPUTFPS             _HRESULT_TYPEDEF_(0xC00D1B81L)

//
// MessageId: NS_E_NO_DATAVIEW_SUPPORT
//
// MessageText:
//
// It is not possible to display your source or output video in the Video panel.%0
//
#define NS_E_NO_DATAVIEW_SUPPORT         _HRESULT_TYPEDEF_(0xC00D1B82L)

//
// MessageId: NS_E_CODEC_UNAVAILABLE
//
// MessageText:
//
// One or more codecs required to open this content could not be found.%0
//
#define NS_E_CODEC_UNAVAILABLE           _HRESULT_TYPEDEF_(0xC00D1B83L)

//
// MessageId: NS_E_ARCHIVE_SAME_AS_INPUT
//
// MessageText:
//
// The archive file has the same name as an input file. Change one of the names before continuing.%0
//
#define NS_E_ARCHIVE_SAME_AS_INPUT       _HRESULT_TYPEDEF_(0xC00D1B84L)

//
// MessageId: NS_E_SOURCE_NOTSPECIFIED
//
// MessageText:
//
// The source has not been set up completely.%0
//
#define NS_E_SOURCE_NOTSPECIFIED         _HRESULT_TYPEDEF_(0xC00D1B85L)

//
// MessageId: NS_E_NO_REALTIME_TIMECOMPRESSION
//
// MessageText:
//
// It is not possible to apply time compression to a broadcast session.%0
//
#define NS_E_NO_REALTIME_TIMECOMPRESSION _HRESULT_TYPEDEF_(0xC00D1B86L)

//
// MessageId: NS_E_UNSUPPORTED_ENCODER_DEVICE
//
// MessageText:
//
// It is not possible to open this device.%0
//
#define NS_E_UNSUPPORTED_ENCODER_DEVICE  _HRESULT_TYPEDEF_(0xC00D1B87L)

//
// MessageId: NS_E_UNEXPECTED_DISPLAY_SETTINGS
//
// MessageText:
//
// It is not possible to start encoding because the display size or color has changed since the current session was defined. Restore the previous settings or create a new session.%0
//
#define NS_E_UNEXPECTED_DISPLAY_SETTINGS _HRESULT_TYPEDEF_(0xC00D1B88L)

//
// MessageId: NS_E_NO_AUDIODATA
//
// MessageText:
//
// No audio data has been received for several seconds. Check the audio source and restart the encoder.%0
//
#define NS_E_NO_AUDIODATA                _HRESULT_TYPEDEF_(0xC00D1B89L)

//
// MessageId: NS_E_INPUTSOURCE_PROBLEM
//
// MessageText:
//
// One or all of the specified sources are not working properly. Check that the sources are configured correctly.%0
//
#define NS_E_INPUTSOURCE_PROBLEM         _HRESULT_TYPEDEF_(0xC00D1B8AL)

//
// MessageId: NS_E_WME_VERSION_MISMATCH
//
// MessageText:
//
// The supplied configuration file is not supported by this version of the encoder.%0
//
#define NS_E_WME_VERSION_MISMATCH        _HRESULT_TYPEDEF_(0xC00D1B8BL)

//
// MessageId: NS_E_NO_REALTIME_PREPROCESS
//
// MessageText:
//
// It is not possible to use image preprocessing with live encoding.%0
//
#define NS_E_NO_REALTIME_PREPROCESS      _HRESULT_TYPEDEF_(0xC00D1B8CL)

//
// MessageId: NS_E_NO_REPEAT_PREPROCESS
//
// MessageText:
//
// It is not possible to use two-pass encoding when the source is set to loop.%0
//
#define NS_E_NO_REPEAT_PREPROCESS        _HRESULT_TYPEDEF_(0xC00D1B8DL)

//
// MessageId: NS_E_CANNOT_PAUSE_LIVEBROADCAST
//
// MessageText:
//
// It is not possible to pause encoding during a broadcast.%0
//
#define NS_E_CANNOT_PAUSE_LIVEBROADCAST  _HRESULT_TYPEDEF_(0xC00D1B8EL)

//
// MessageId: NS_E_DRM_PROFILE_NOT_SET
//
// MessageText:
//
// A DRM profile has not been set for the current session.%0
//
#define NS_E_DRM_PROFILE_NOT_SET         _HRESULT_TYPEDEF_(0xC00D1B8FL)

//
// MessageId: NS_E_DUPLICATE_DRMPROFILE
//
// MessageText:
//
// The profile ID is already used by a DRM profile. Specify a different profile ID.%0
//
#define NS_E_DUPLICATE_DRMPROFILE        _HRESULT_TYPEDEF_(0xC00D1B90L)

//
// MessageId: NS_E_INVALID_DEVICE
//
// MessageText:
//
// The setting of the selected device does not support control for playing back tapes.%0
//
#define NS_E_INVALID_DEVICE              _HRESULT_TYPEDEF_(0xC00D1B91L)

//
// MessageId: NS_E_SPEECHEDL_ON_NON_MIXEDMODE
//
// MessageText:
//
// You must specify a mixed voice and audio mode in order to use an optimization definition file.%0
//
#define NS_E_SPEECHEDL_ON_NON_MIXEDMODE  _HRESULT_TYPEDEF_(0xC00D1B92L)

//
// MessageId: NS_E_DRM_PASSWORD_TOO_LONG
//
// MessageText:
//
// The specified password is too long. Type a password with fewer than 8 characters.%0
//
#define NS_E_DRM_PASSWORD_TOO_LONG       _HRESULT_TYPEDEF_(0xC00D1B93L)

//
// MessageId: NS_E_DEVCONTROL_FAILED_SEEK
//
// MessageText:
//
// It is not possible to seek to the specified mark-in point.%0
//
#define NS_E_DEVCONTROL_FAILED_SEEK      _HRESULT_TYPEDEF_(0xC00D1B94L)

//
// MessageId: NS_E_INTERLACE_REQUIRE_SAMESIZE
//
// MessageText:
//
// When you choose to maintain the interlacing in your video, the output video size must match the input video size.%0
//
#define NS_E_INTERLACE_REQUIRE_SAMESIZE  _HRESULT_TYPEDEF_(0xC00D1B95L)

//
// MessageId: NS_E_TOO_MANY_DEVICECONTROL
//
// MessageText:
//
// Only one device control plug-in can control a device.%0
//
#define NS_E_TOO_MANY_DEVICECONTROL      _HRESULT_TYPEDEF_(0xC00D1B96L)

//
// MessageId: NS_E_NO_MULTIPASS_FOR_LIVEDEVICE
//
// MessageText:
//
// You must also enable storing content to hard disk temporarily in order to use two-pass encoding with the input device.%0
//
#define NS_E_NO_MULTIPASS_FOR_LIVEDEVICE _HRESULT_TYPEDEF_(0xC00D1B97L)

//
// MessageId: NS_E_MISSING_AUDIENCE
//
// MessageText:
//
// An audience is missing from the output stream configuration.%0
//
#define NS_E_MISSING_AUDIENCE            _HRESULT_TYPEDEF_(0xC00D1B98L)

//
// MessageId: NS_E_AUDIENCE_CONTENTTYPE_MISMATCH
//
// MessageText:
//
// All audiences in the output tree must have the same content type.%0
//
#define NS_E_AUDIENCE_CONTENTTYPE_MISMATCH _HRESULT_TYPEDEF_(0xC00D1B99L)

//
// MessageId: NS_E_MISSING_SOURCE_INDEX
//
// MessageText:
//
// A source index is missing from the output stream configuration.%0
//
#define NS_E_MISSING_SOURCE_INDEX        _HRESULT_TYPEDEF_(0xC00D1B9AL)

//
// MessageId: NS_E_NUM_LANGUAGE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same number of languages.%0
//
#define NS_E_NUM_LANGUAGE_MISMATCH       _HRESULT_TYPEDEF_(0xC00D1B9BL)

//
// MessageId: NS_E_LANGUAGE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same languages.%0
//
#define NS_E_LANGUAGE_MISMATCH           _HRESULT_TYPEDEF_(0xC00D1B9CL)

//
// MessageId: NS_E_VBRMODE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should use the same VBR encoding mode.%0
//
#define NS_E_VBRMODE_MISMATCH            _HRESULT_TYPEDEF_(0xC00D1B9DL)

//
// MessageId: NS_E_INVALID_INPUT_AUDIENCE_INDEX
//
// MessageText:
//
// The bit rate index specified is not valid.%0
//
#define NS_E_INVALID_INPUT_AUDIENCE_INDEX _HRESULT_TYPEDEF_(0xC00D1B9EL)

//
// MessageId: NS_E_INVALID_INPUT_LANGUAGE
//
// MessageText:
//
// The specified language is not valid.%0
//
#define NS_E_INVALID_INPUT_LANGUAGE      _HRESULT_TYPEDEF_(0xC00D1B9FL)

//
// MessageId: NS_E_INVALID_INPUT_STREAM
//
// MessageText:
//
// The specified source type is not valid.%0
//
#define NS_E_INVALID_INPUT_STREAM        _HRESULT_TYPEDEF_(0xC00D1BA0L)

//
// MessageId: NS_E_EXPECT_MONO_WAV_INPUT
//
// MessageText:
//
// The source must be a mono channel .wav file.%0
//
#define NS_E_EXPECT_MONO_WAV_INPUT       _HRESULT_TYPEDEF_(0xC00D1BA1L)

//
// MessageId: NS_E_INPUT_WAVFORMAT_MISMATCH
//
// MessageText:
//
// All the source .wav files must have the same format.%0
//
#define NS_E_INPUT_WAVFORMAT_MISMATCH    _HRESULT_TYPEDEF_(0xC00D1BA2L)

//
// MessageId: NS_E_RECORDQ_DISK_FULL
//
// MessageText:
//
// The hard disk being used for temporary storage of content has reached the minimum allowed disk space. Create more space on the hard disk and restart encoding.%0
//
#define NS_E_RECORDQ_DISK_FULL           _HRESULT_TYPEDEF_(0xC00D1BA3L)

//
// MessageId: NS_E_NO_PAL_INVERSE_TELECINE
//
// MessageText:
//
// It is not possible to apply the inverse telecine feature to PAL content.%0
//
#define NS_E_NO_PAL_INVERSE_TELECINE     _HRESULT_TYPEDEF_(0xC00D1BA4L)

//
// MessageId: NS_E_ACTIVE_SG_DEVICE_DISCONNECTED
//
// MessageText:
//
// A capture device in the current active source is no longer available.%0
//
#define NS_E_ACTIVE_SG_DEVICE_DISCONNECTED _HRESULT_TYPEDEF_(0xC00D1BA5L)

//
// MessageId: NS_E_ACTIVE_SG_DEVICE_CONTROL_DISCONNECTED
//
// MessageText:
//
// A device used in the current active source for device control is no longer available.%0
//
#define NS_E_ACTIVE_SG_DEVICE_CONTROL_DISCONNECTED _HRESULT_TYPEDEF_(0xC00D1BA6L)

//
// MessageId: NS_E_NO_FRAMES_SUBMITTED_TO_ANALYZER
//
// MessageText:
//
// No frames have been submitted to the analyzer for analysis.%0
//
#define NS_E_NO_FRAMES_SUBMITTED_TO_ANALYZER _HRESULT_TYPEDEF_(0xC00D1BA7L)

//
// MessageId: NS_E_INPUT_DOESNOT_SUPPORT_SMPTE
//
// MessageText:
//
// The source video does not support time codes.%0
//
#define NS_E_INPUT_DOESNOT_SUPPORT_SMPTE _HRESULT_TYPEDEF_(0xC00D1BA8L)

//
// MessageId: NS_E_NO_SMPTE_WITH_MULTIPLE_SOURCEGROUPS
//
// MessageText:
//
// It is not possible to generate a time code when there are multiple sources in a session.%0
//
#define NS_E_NO_SMPTE_WITH_MULTIPLE_SOURCEGROUPS _HRESULT_TYPEDEF_(0xC00D1BA9L)

//
// MessageId: NS_E_BAD_CONTENTEDL
//
// MessageText:
//
// The voice codec optimization definition file can not be found or is corrupted.%0
//
#define NS_E_BAD_CONTENTEDL              _HRESULT_TYPEDEF_(0xC00D1BAAL)

//
// MessageId: NS_E_INTERLACEMODE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same interlace mode.%0
//
#define NS_E_INTERLACEMODE_MISMATCH      _HRESULT_TYPEDEF_(0xC00D1BABL)

//
// MessageId: NS_E_NONSQUAREPIXELMODE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same nonsquare pixel mode.%0
//
#define NS_E_NONSQUAREPIXELMODE_MISMATCH _HRESULT_TYPEDEF_(0xC00D1BACL)

//
// MessageId: NS_E_SMPTEMODE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same time code mode.%0
//
#define NS_E_SMPTEMODE_MISMATCH          _HRESULT_TYPEDEF_(0xC00D1BADL)

//
// MessageId: NS_E_END_OF_TAPE
//
// MessageText:
//
// Either the end of the tape has been reached or there is no tape. Check the device and tape.%0
//
#define NS_E_END_OF_TAPE                 _HRESULT_TYPEDEF_(0xC00D1BAEL)

//
// MessageId: NS_E_NO_MEDIA_IN_AUDIENCE
//
// MessageText:
//
// No audio or video input has been specified.%0
//
#define NS_E_NO_MEDIA_IN_AUDIENCE        _HRESULT_TYPEDEF_(0xC00D1BAFL)

//
// MessageId: NS_E_NO_AUDIENCES
//
// MessageText:
//
// The profile must contain a bit rate.%0
//
#define NS_E_NO_AUDIENCES                _HRESULT_TYPEDEF_(0xC00D1BB0L)

//
// MessageId: NS_E_NO_AUDIO_COMPAT
//
// MessageText:
//
// You must specify at least one audio stream to be compatible with Windows Media Player 7.1.%0
//
#define NS_E_NO_AUDIO_COMPAT             _HRESULT_TYPEDEF_(0xC00D1BB1L)

//
// MessageId: NS_E_INVALID_VBR_COMPAT
//
// MessageText:
//
// Using a VBR encoding mode is not compatible with Windows Media Player 7.1.%0
//
#define NS_E_INVALID_VBR_COMPAT          _HRESULT_TYPEDEF_(0xC00D1BB2L)

//
// MessageId: NS_E_NO_PROFILE_NAME
//
// MessageText:
//
// You must specify a profile name.%0
//
#define NS_E_NO_PROFILE_NAME             _HRESULT_TYPEDEF_(0xC00D1BB3L)

//
// MessageId: NS_E_INVALID_VBR_WITH_UNCOMP
//
// MessageText:
//
// It is not possible to use a VBR encoding mode with uncompressed audio or video.%0
//
#define NS_E_INVALID_VBR_WITH_UNCOMP     _HRESULT_TYPEDEF_(0xC00D1BB4L)

//
// MessageId: NS_E_MULTIPLE_VBR_AUDIENCES
//
// MessageText:
//
// It is not possible to use MBR encoding with VBR encoding.%0
//
#define NS_E_MULTIPLE_VBR_AUDIENCES      _HRESULT_TYPEDEF_(0xC00D1BB5L)

//
// MessageId: NS_E_UNCOMP_COMP_COMBINATION
//
// MessageText:
//
// It is not possible to mix uncompressed and compressed content in a session.%0
//
#define NS_E_UNCOMP_COMP_COMBINATION     _HRESULT_TYPEDEF_(0xC00D1BB6L)

//
// MessageId: NS_E_MULTIPLE_AUDIO_CODECS
//
// MessageText:
//
// All audiences must use the same audio codec.%0
//
#define NS_E_MULTIPLE_AUDIO_CODECS       _HRESULT_TYPEDEF_(0xC00D1BB7L)

//
// MessageId: NS_E_MULTIPLE_AUDIO_FORMATS
//
// MessageText:
//
// All audiences should use the same audio format to be compatible with Windows Media Player 7.1.%0
//
#define NS_E_MULTIPLE_AUDIO_FORMATS      _HRESULT_TYPEDEF_(0xC00D1BB8L)

//
// MessageId: NS_E_AUDIO_BITRATE_STEPDOWN
//
// MessageText:
//
// The audio bit rate for an audience with a higher total bit rate must be greater than one with a lower total bit rate.%0
//
#define NS_E_AUDIO_BITRATE_STEPDOWN      _HRESULT_TYPEDEF_(0xC00D1BB9L)

//
// MessageId: NS_E_INVALID_AUDIO_PEAKRATE
//
// MessageText:
//
// The audio peak bit rate setting is not valid.%0
//
#define NS_E_INVALID_AUDIO_PEAKRATE      _HRESULT_TYPEDEF_(0xC00D1BBAL)

//
// MessageId: NS_E_INVALID_AUDIO_PEAKRATE_2
//
// MessageText:
//
// The audio peak bit rate setting must be greater than the audio bit rate setting.%0
//
#define NS_E_INVALID_AUDIO_PEAKRATE_2    _HRESULT_TYPEDEF_(0xC00D1BBBL)

//
// MessageId: NS_E_INVALID_AUDIO_BUFFERMAX
//
// MessageText:
//
// The setting for the maximum buffer size for audio is not valid.%0
//
#define NS_E_INVALID_AUDIO_BUFFERMAX     _HRESULT_TYPEDEF_(0xC00D1BBCL)

//
// MessageId: NS_E_MULTIPLE_VIDEO_CODECS
//
// MessageText:
//
// All audiences must use the same video codec.%0
//
#define NS_E_MULTIPLE_VIDEO_CODECS       _HRESULT_TYPEDEF_(0xC00D1BBDL)

//
// MessageId: NS_E_MULTIPLE_VIDEO_SIZES
//
// MessageText:
//
// All audiences should use the same video size to be compatible with Windows Media Player 7.1.%0
//
#define NS_E_MULTIPLE_VIDEO_SIZES        _HRESULT_TYPEDEF_(0xC00D1BBEL)

//
// MessageId: NS_E_INVALID_VIDEO_BITRATE
//
// MessageText:
//
// The video bit rate setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_BITRATE       _HRESULT_TYPEDEF_(0xC00D1BBFL)

//
// MessageId: NS_E_VIDEO_BITRATE_STEPDOWN
//
// MessageText:
//
// The video bit rate for an audience with a higher total bit rate must be greater than one with a lower total bit rate.%0
//
#define NS_E_VIDEO_BITRATE_STEPDOWN      _HRESULT_TYPEDEF_(0xC00D1BC0L)

//
// MessageId: NS_E_INVALID_VIDEO_PEAKRATE
//
// MessageText:
//
// The video peak bit rate setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_PEAKRATE      _HRESULT_TYPEDEF_(0xC00D1BC1L)

//
// MessageId: NS_E_INVALID_VIDEO_PEAKRATE_2
//
// MessageText:
//
// The video peak bit rate setting must be greater than the video bit rate setting.%0
//
#define NS_E_INVALID_VIDEO_PEAKRATE_2    _HRESULT_TYPEDEF_(0xC00D1BC2L)

//
// MessageId: NS_E_INVALID_VIDEO_WIDTH
//
// MessageText:
//
// The video width setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_WIDTH         _HRESULT_TYPEDEF_(0xC00D1BC3L)

//
// MessageId: NS_E_INVALID_VIDEO_HEIGHT
//
// MessageText:
//
// The video height setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_HEIGHT        _HRESULT_TYPEDEF_(0xC00D1BC4L)

//
// MessageId: NS_E_INVALID_VIDEO_FPS
//
// MessageText:
//
// The video frame rate setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_FPS           _HRESULT_TYPEDEF_(0xC00D1BC5L)

//
// MessageId: NS_E_INVALID_VIDEO_KEYFRAME
//
// MessageText:
//
// The video key frame setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_KEYFRAME      _HRESULT_TYPEDEF_(0xC00D1BC6L)

//
// MessageId: NS_E_INVALID_VIDEO_IQUALITY
//
// MessageText:
//
// The video image quality setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_IQUALITY      _HRESULT_TYPEDEF_(0xC00D1BC7L)

//
// MessageId: NS_E_INVALID_VIDEO_CQUALITY
//
// MessageText:
//
// The video codec quality setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_CQUALITY      _HRESULT_TYPEDEF_(0xC00D1BC8L)

//
// MessageId: NS_E_INVALID_VIDEO_BUFFER
//
// MessageText:
//
// The video buffer setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_BUFFER        _HRESULT_TYPEDEF_(0xC00D1BC9L)

//
// MessageId: NS_E_INVALID_VIDEO_BUFFERMAX
//
// MessageText:
//
// The setting for the maximum buffer size for video is not valid.%0
//
#define NS_E_INVALID_VIDEO_BUFFERMAX     _HRESULT_TYPEDEF_(0xC00D1BCAL)

//
// MessageId: NS_E_INVALID_VIDEO_BUFFERMAX_2
//
// MessageText:
//
// The value of the video maximum buffer size setting must be greater than the video buffer size setting.%0
//
#define NS_E_INVALID_VIDEO_BUFFERMAX_2   _HRESULT_TYPEDEF_(0xC00D1BCBL)

//
// MessageId: NS_E_INVALID_VIDEO_WIDTH_ALIGN
//
// MessageText:
//
// The alignment of the video width is not valid.%0
//
#define NS_E_INVALID_VIDEO_WIDTH_ALIGN   _HRESULT_TYPEDEF_(0xC00D1BCCL)

//
// MessageId: NS_E_INVALID_VIDEO_HEIGHT_ALIGN
//
// MessageText:
//
// The alignment of the video height is not valid.%0
//
#define NS_E_INVALID_VIDEO_HEIGHT_ALIGN  _HRESULT_TYPEDEF_(0xC00D1BCDL)

//
// MessageId: NS_E_MULTIPLE_SCRIPT_BITRATES
//
// MessageText:
//
// All bit rates must have the same script bit rate.%0
//
#define NS_E_MULTIPLE_SCRIPT_BITRATES    _HRESULT_TYPEDEF_(0xC00D1BCEL)

//
// MessageId: NS_E_INVALID_SCRIPT_BITRATE
//
// MessageText:
//
// The script bit rate specified is not valid.%0
//
#define NS_E_INVALID_SCRIPT_BITRATE      _HRESULT_TYPEDEF_(0xC00D1BCFL)

//
// MessageId: NS_E_MULTIPLE_FILE_BITRATES
//
// MessageText:
//
// All bit rates must have the same file transfer bit rate.%0
//
#define NS_E_MULTIPLE_FILE_BITRATES      _HRESULT_TYPEDEF_(0xC00D1BD0L)

//
// MessageId: NS_E_INVALID_FILE_BITRATE
//
// MessageText:
//
// The file transfer bit rate is not valid.%0
//
#define NS_E_INVALID_FILE_BITRATE        _HRESULT_TYPEDEF_(0xC00D1BD1L)

//
// MessageId: NS_E_SAME_AS_INPUT_COMBINATION
//
// MessageText:
//
// All audiences in a profile should either be same as input or have video width and height specified.%0
//
#define NS_E_SAME_AS_INPUT_COMBINATION   _HRESULT_TYPEDEF_(0xC00D1BD2L)

//
// MessageId: NS_E_SOURCE_CANNOT_LOOP
//
// MessageText:
//
// This source type does not support looping.%0
//
#define NS_E_SOURCE_CANNOT_LOOP          _HRESULT_TYPEDEF_(0xC00D1BD3L)

//
// MessageId: NS_E_INVALID_FOLDDOWN_COEFFICIENTS
//
// MessageText:
//
// The fold-down value needs to be between -144 and 0.%0
//
#define NS_E_INVALID_FOLDDOWN_COEFFICIENTS _HRESULT_TYPEDEF_(0xC00D1BD4L)

//
// MessageId: NS_E_DRMPROFILE_NOTFOUND
//
// MessageText:
//
// The specified DRM profile does not exist in the system.%0
//
#define NS_E_DRMPROFILE_NOTFOUND         _HRESULT_TYPEDEF_(0xC00D1BD5L)

//
// MessageId: NS_E_INVALID_TIMECODE
//
// MessageText:
//
// The specified time code is not valid.%0
//
#define NS_E_INVALID_TIMECODE            _HRESULT_TYPEDEF_(0xC00D1BD6L)

//
// MessageId: NS_E_NO_AUDIO_TIMECOMPRESSION
//
// MessageText:
//
// It is not possible to apply time compression to a video-only session.%0
//
#define NS_E_NO_AUDIO_TIMECOMPRESSION    _HRESULT_TYPEDEF_(0xC00D1BD7L)

//
// MessageId: NS_E_NO_TWOPASS_TIMECOMPRESSION
//
// MessageText:
//
// It is not possible to apply time compression to a session that is using two-pass encoding.%0
//
#define NS_E_NO_TWOPASS_TIMECOMPRESSION  _HRESULT_TYPEDEF_(0xC00D1BD8L)

//
// MessageId: NS_E_TIMECODE_REQUIRES_VIDEOSTREAM
//
// MessageText:
//
// It is not possible to generate a time code for an audio-only session.%0
//
#define NS_E_TIMECODE_REQUIRES_VIDEOSTREAM _HRESULT_TYPEDEF_(0xC00D1BD9L)

//
// MessageId: NS_E_NO_MBR_WITH_TIMECODE
//
// MessageText:
//
// It is not possible to generate a time code when you are encoding content at multiple bit rates.%0
//
#define NS_E_NO_MBR_WITH_TIMECODE        _HRESULT_TYPEDEF_(0xC00D1BDAL)

//
// MessageId: NS_E_INVALID_INTERLACEMODE
//
// MessageText:
//
// The video codec selected does not support maintaining interlacing in video.%0
//
#define NS_E_INVALID_INTERLACEMODE       _HRESULT_TYPEDEF_(0xC00D1BDBL)

//
// MessageId: NS_E_INVALID_INTERLACE_COMPAT
//
// MessageText:
//
// Maintaining interlacing in video is not compatible with Windows Media Player 7.1.%0
//
#define NS_E_INVALID_INTERLACE_COMPAT    _HRESULT_TYPEDEF_(0xC00D1BDCL)

//
// MessageId: NS_E_INVALID_NONSQUAREPIXEL_COMPAT
//
// MessageText:
//
// Allowing nonsquare pixel output is not compatible with Windows Media Player 7.1.%0
//
#define NS_E_INVALID_NONSQUAREPIXEL_COMPAT _HRESULT_TYPEDEF_(0xC00D1BDDL)

//
// MessageId: NS_E_INVALID_SOURCE_WITH_DEVICE_CONTROL
//
// MessageText:
//
// Only capture devices can be used with device control.%0
//
#define NS_E_INVALID_SOURCE_WITH_DEVICE_CONTROL _HRESULT_TYPEDEF_(0xC00D1BDEL)

//
// MessageId: NS_E_CANNOT_GENERATE_BROADCAST_INFO_FOR_QUALITYVBR
//
// MessageText:
//
// It is not possible to generate the stream format file if you are using quality-based VBR encoding for the audio or video stream. Instead use the Windows Media file generated after encoding to create the announcement file.%0
//
#define NS_E_CANNOT_GENERATE_BROADCAST_INFO_FOR_QUALITYVBR _HRESULT_TYPEDEF_(0xC00D1BDFL)

//
// MessageId: NS_E_EXCEED_MAX_DRM_PROFILE_LIMIT
//
// MessageText:
//
// It is not possible to create a DRM profile because the maximum number of profiles has been reached. You must delete some DRM profiles before creating new ones.%0
//
#define NS_E_EXCEED_MAX_DRM_PROFILE_LIMIT _HRESULT_TYPEDEF_(0xC00D1BE0L)

//
// MessageId: NS_E_DEVICECONTROL_UNSTABLE
//
// MessageText:
//
// The device is in an unstable state. Check that the device is functioning properly and a tape is in place.
//
#define NS_E_DEVICECONTROL_UNSTABLE      _HRESULT_TYPEDEF_(0xC00D1BE1L)

//
// MessageId: NS_E_INVALID_PIXEL_ASPECT_RATIO
//
// MessageText:
//
// The pixel aspect ratio value must be between 1 and 255.
//
#define NS_E_INVALID_PIXEL_ASPECT_RATIO  _HRESULT_TYPEDEF_(0xC00D1BE2L)

//
// MessageId: NS_E_AUDIENCE__LANGUAGE_CONTENTTYPE_MISMATCH
//
// MessageText:
//
// All streams with different languages in the same audience must have same properties.%0
//
#define NS_E_AUDIENCE__LANGUAGE_CONTENTTYPE_MISMATCH _HRESULT_TYPEDEF_(0xC00D1BE3L)

//
// MessageId: NS_E_INVALID_PROFILE_CONTENTTYPE
//
// MessageText:
//
// The profile must contain at least one audio or video stream.%0
//
#define NS_E_INVALID_PROFILE_CONTENTTYPE _HRESULT_TYPEDEF_(0xC00D1BE4L)

//
// MessageId: NS_E_TRANSFORM_PLUGIN_NOT_FOUND
//
// MessageText:
//
// The transform plug-in could not be found.%0
//
#define NS_E_TRANSFORM_PLUGIN_NOT_FOUND  _HRESULT_TYPEDEF_(0xC00D1BE5L)

//
// MessageId: NS_E_TRANSFORM_PLUGIN_INVALID
//
// MessageText:
//
// The transform plug-in is not valid. It may be damaged or you may not have the required permissions to access the plug-in.%0
//
#define NS_E_TRANSFORM_PLUGIN_INVALID    _HRESULT_TYPEDEF_(0xC00D1BE6L)

//
// MessageId: NS_E_EDL_REQUIRED_FOR_DEVICE_MULTIPASS
//
// MessageText:
//
// To use two-pass encoding, you must enable device control and setup an edit decision list (EDL) that has at least one entry.%0
//
#define NS_E_EDL_REQUIRED_FOR_DEVICE_MULTIPASS _HRESULT_TYPEDEF_(0xC00D1BE7L)

//
// MessageId: NS_E_INVALID_VIDEO_WIDTH_FOR_INTERLACED_ENCODING
//
// MessageText:
//
// When you choose to maintain the interlacing in your video, the output video size must be a multiple of 4.%0
//
#define NS_E_INVALID_VIDEO_WIDTH_FOR_INTERLACED_ENCODING _HRESULT_TYPEDEF_(0xC00D1BE8L)

//
// MessageId: NS_E_MARKIN_UNSUPPORTED
//
// MessageText:
//
// Markin/Markout is unsupported with this source type.%0
//
#define NS_E_MARKIN_UNSUPPORTED          _HRESULT_TYPEDEF_(0xC00D1BE9L)


/////////////////////////////////////////////////////////////////////////
//
// DRM Specific Errors
//
// IdRange = 10000..10999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_DRM_INVALID_APPLICATION
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_INVALID_APPLICATION     _HRESULT_TYPEDEF_(0xC00D2711L)

//
// MessageId: NS_E_DRM_LICENSE_STORE_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_STORE_ERROR     _HRESULT_TYPEDEF_(0xC00D2712L)

//
// MessageId: NS_E_DRM_SECURE_STORE_ERROR
//
// MessageText:
//
// Secure storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_ERROR      _HRESULT_TYPEDEF_(0xC00D2713L)

//
// MessageId: NS_E_DRM_LICENSE_STORE_SAVE_ERROR
//
// MessageText:
//
// License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_STORE_SAVE_ERROR _HRESULT_TYPEDEF_(0xC00D2714L)

//
// MessageId: NS_E_DRM_SECURE_STORE_UNLOCK_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_UNLOCK_ERROR _HRESULT_TYPEDEF_(0xC00D2715L)

//
// MessageId: NS_E_DRM_INVALID_CONTENT
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_CONTENT         _HRESULT_TYPEDEF_(0xC00D2716L)

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_LICENSE
//
// MessageText:
//
// The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_LICENSE  _HRESULT_TYPEDEF_(0xC00D2717L)

//
// MessageId: NS_E_DRM_INVALID_LICENSE
//
// MessageText:
//
// The license is corrupted or invalid. Acquire a new license%0
//
#define NS_E_DRM_INVALID_LICENSE         _HRESULT_TYPEDEF_(0xC00D2718L)

//
// MessageId: NS_E_DRM_INVALID_MACHINE
//
// MessageText:
//
// Licenses cannot be copied from one computer to another. Use License Management to transfer licenses, or get a new license for the media file.%0
//
#define NS_E_DRM_INVALID_MACHINE         _HRESULT_TYPEDEF_(0xC00D2719L)

//
// MessageId: NS_E_DRM_ENUM_LICENSE_FAILED
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENUM_LICENSE_FAILED     _HRESULT_TYPEDEF_(0xC00D271BL)

//
// MessageId: NS_E_DRM_INVALID_LICENSE_REQUEST
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_LICENSE_REQUEST _HRESULT_TYPEDEF_(0xC00D271CL)

//
// MessageId: NS_E_DRM_UNABLE_TO_INITIALIZE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_INITIALIZE    _HRESULT_TYPEDEF_(0xC00D271DL)

//
// MessageId: NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE
//
// MessageText:
//
// The license could not be acquired. Try again later.%0
//
#define NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE _HRESULT_TYPEDEF_(0xC00D271EL)

//
// MessageId: NS_E_DRM_INVALID_LICENSE_ACQUIRED
//
// MessageText:
//
// License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_INVALID_LICENSE_ACQUIRED _HRESULT_TYPEDEF_(0xC00D271FL)

//
// MessageId: NS_E_DRM_NO_RIGHTS
//
// MessageText:
//
// The requested operation cannot be performed on this file.%0
//
#define NS_E_DRM_NO_RIGHTS               _HRESULT_TYPEDEF_(0xC00D2720L)

//
// MessageId: NS_E_DRM_KEY_ERROR
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_DRM_KEY_ERROR               _HRESULT_TYPEDEF_(0xC00D2721L)

//
// MessageId: NS_E_DRM_ENCRYPT_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENCRYPT_ERROR           _HRESULT_TYPEDEF_(0xC00D2722L)

//
// MessageId: NS_E_DRM_DECRYPT_ERROR
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_DECRYPT_ERROR           _HRESULT_TYPEDEF_(0xC00D2723L)

//
// MessageId: NS_E_DRM_LICENSE_INVALID_XML
//
// MessageText:
//
// The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_LICENSE_INVALID_XML     _HRESULT_TYPEDEF_(0xC00D2725L)

//
// MessageId: NS_S_DRM_LICENSE_ACQUIRED
//
// MessageText:
//
// Status message: The license was acquired.%0
//
#define NS_S_DRM_LICENSE_ACQUIRED        _HRESULT_TYPEDEF_(0x000D2726L)

//
// MessageId: NS_S_DRM_INDIVIDUALIZED
//
// MessageText:
//
// Status message: The security upgrade has been completed.%0
//
#define NS_S_DRM_INDIVIDUALIZED          _HRESULT_TYPEDEF_(0x000D2727L)

//
// MessageId: NS_E_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
// A security upgrade is required to perform the operation on this media file.%0
//
#define NS_E_DRM_NEEDS_INDIVIDUALIZATION _HRESULT_TYPEDEF_(0xC00D2728L)

//
// MessageId: NS_E_DRM_ALREADY_INDIVIDUALIZED
//
// MessageText:
//
// You already have the latest security components. No upgrade is necessary at this time.%0
//
#define NS_E_DRM_ALREADY_INDIVIDUALIZED  _HRESULT_TYPEDEF_(0xC00D2729L)

//
// MessageId: NS_E_DRM_ACTION_NOT_QUERIED
//
// MessageText:
//
// The application cannot perform this action. Contact product support for this application.%0
//
#define NS_E_DRM_ACTION_NOT_QUERIED      _HRESULT_TYPEDEF_(0xC00D272AL)

//
// MessageId: NS_E_DRM_ACQUIRING_LICENSE
//
// MessageText:
//
// You cannot begin a new license acquisition process until the current one has been completed.%0
//
#define NS_E_DRM_ACQUIRING_LICENSE       _HRESULT_TYPEDEF_(0xC00D272BL)

//
// MessageId: NS_E_DRM_INDIVIDUALIZING
//
// MessageText:
//
// You cannot begin a new security upgrade until the current one has been completed.%0
//
#define NS_E_DRM_INDIVIDUALIZING         _HRESULT_TYPEDEF_(0xC00D272CL)

//
// MessageId: NS_E_BACKUP_RESTORE_FAILURE
//
// MessageText:
//
// Failure in Backup-Restore.%0
//
#define NS_E_BACKUP_RESTORE_FAILURE      _HRESULT_TYPEDEF_(0xC00D272DL)

//
// MessageId: NS_E_BACKUP_RESTORE_BAD_REQUEST_ID
//
// MessageText:
//
// Bad Request ID in Backup-Restore.%0
//
#define NS_E_BACKUP_RESTORE_BAD_REQUEST_ID _HRESULT_TYPEDEF_(0xC00D272EL)

//
// MessageId: NS_E_DRM_PARAMETERS_MISMATCHED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_PARAMETERS_MISMATCHED   _HRESULT_TYPEDEF_(0xC00D272FL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT
//
// MessageText:
//
// A license cannot be created for this media file. Reinstall the application.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT _HRESULT_TYPEDEF_(0xC00D2730L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT _HRESULT_TYPEDEF_(0xC00D2731L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT _HRESULT_TYPEDEF_(0xC00D2732L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT _HRESULT_TYPEDEF_(0xC00D2733L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT _HRESULT_TYPEDEF_(0xC00D2734L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT _HRESULT_TYPEDEF_(0xC00D2735L)

//
// MessageId: NS_E_DRM_INDIVIDUALIZE_ERROR
//
// MessageText:
//
// The security upgrade failed. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZE_ERROR     _HRESULT_TYPEDEF_(0xC00D2736L)

//
// MessageId: NS_E_DRM_LICENSE_OPEN_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_OPEN_ERROR      _HRESULT_TYPEDEF_(0xC00D2737L)

//
// MessageId: NS_E_DRM_LICENSE_CLOSE_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_CLOSE_ERROR     _HRESULT_TYPEDEF_(0xC00D2738L)

//
// MessageId: NS_E_DRM_GET_LICENSE_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSE_ERROR       _HRESULT_TYPEDEF_(0xC00D2739L)

//
// MessageId: NS_E_DRM_QUERY_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_QUERY_ERROR             _HRESULT_TYPEDEF_(0xC00D273AL)

//
// MessageId: NS_E_DRM_REPORT_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_REPORT_ERROR            _HRESULT_TYPEDEF_(0xC00D273BL)

//
// MessageId: NS_E_DRM_GET_LICENSESTRING_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSESTRING_ERROR _HRESULT_TYPEDEF_(0xC00D273CL)

//
// MessageId: NS_E_DRM_GET_CONTENTSTRING_ERROR
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_GET_CONTENTSTRING_ERROR _HRESULT_TYPEDEF_(0xC00D273DL)

//
// MessageId: NS_E_DRM_MONITOR_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Try again later.%0
//
#define NS_E_DRM_MONITOR_ERROR           _HRESULT_TYPEDEF_(0xC00D273EL)

//
// MessageId: NS_E_DRM_UNABLE_TO_SET_PARAMETER
//
// MessageText:
//
// The application has made an invalid call to the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_UNABLE_TO_SET_PARAMETER _HRESULT_TYPEDEF_(0xC00D273FL)

//
// MessageId: NS_E_DRM_INVALID_APPDATA
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_APPDATA         _HRESULT_TYPEDEF_(0xC00D2740L)

//
// MessageId: NS_E_DRM_INVALID_APPDATA_VERSION
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_APPDATA_VERSION _HRESULT_TYPEDEF_(0xC00D2741L)

//
// MessageId: NS_E_DRM_BACKUP_EXISTS
//
// MessageText:
//
// Licenses are already backed up in this location.%0
//
#define NS_E_DRM_BACKUP_EXISTS           _HRESULT_TYPEDEF_(0xC00D2742L)

//
// MessageId: NS_E_DRM_BACKUP_CORRUPT
//
// MessageText:
//
// One or more backed-up licenses are missing or corrupt.%0
//
#define NS_E_DRM_BACKUP_CORRUPT          _HRESULT_TYPEDEF_(0xC00D2743L)

//
// MessageId: NS_E_DRM_BACKUPRESTORE_BUSY
//
// MessageText:
//
// You cannot begin a new backup process until the current process has been completed.%0
//
#define NS_E_DRM_BACKUPRESTORE_BUSY      _HRESULT_TYPEDEF_(0xC00D2744L)

//
// MessageId: NS_E_BACKUP_RESTORE_BAD_DATA
//
// MessageText:
//
// Bad Data sent to Backup-Restore.%0
//
#define NS_E_BACKUP_RESTORE_BAD_DATA     _HRESULT_TYPEDEF_(0xC00D2745L)

//
// MessageId: NS_S_DRM_MONITOR_CANCELLED
//
// MessageText:
//
// Status message: License monitoring has been cancelled.%0
//
#define NS_S_DRM_MONITOR_CANCELLED       _HRESULT_TYPEDEF_(0x000D2746L)

//
// MessageId: NS_S_DRM_ACQUIRE_CANCELLED
//
// MessageText:
//
// Status message: License acquisition has been cancelled.%0
//
#define NS_S_DRM_ACQUIRE_CANCELLED       _HRESULT_TYPEDEF_(0x000D2747L)

//
// MessageId: NS_E_DRM_LICENSE_UNUSABLE
//
// MessageText:
//
// The license is invalid. Contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_UNUSABLE        _HRESULT_TYPEDEF_(0xC00D2748L)

//
// MessageId: NS_E_DRM_INVALID_PROPERTY
//
// MessageText:
//
// A required property was not set by the application. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_PROPERTY        _HRESULT_TYPEDEF_(0xC00D2749L)

//
// MessageId: NS_E_DRM_SECURE_STORE_NOT_FOUND
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component of this application. Try to acquire a license again.%0
//
#define NS_E_DRM_SECURE_STORE_NOT_FOUND  _HRESULT_TYPEDEF_(0xC00D274AL)

//
// MessageId: NS_E_DRM_CACHED_CONTENT_ERROR
//
// MessageText:
//
// Windows Media Digital Rights Management (DRM) cannot play the protected file because you do not have the appropriate rights.%0
//
#define NS_E_DRM_CACHED_CONTENT_ERROR    _HRESULT_TYPEDEF_(0xC00D274BL)

//
// MessageId: NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE
//
// MessageText:
//
// A problem occurred during the security upgrade. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE _HRESULT_TYPEDEF_(0xC00D274CL)

//
// MessageId: NS_E_DRM_DRIVER_AUTH_FAILURE
//
// MessageText:
//
// Certified driver components are required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_AUTH_FAILURE     _HRESULT_TYPEDEF_(0xC00D274DL)

//
// MessageId: NS_E_DRM_NEED_UPGRADE_MSSAP
//
// MessageText:
//
// One or more of the Secure Audio Path components were not found or an entry point in those components was not found.%0
//
#define NS_E_DRM_NEED_UPGRADE_MSSAP      _HRESULT_TYPEDEF_(0xC00D274EL)

//
// MessageId: NS_E_DRM_REOPEN_CONTENT
//
// MessageText:
//
// Status message: Reopen the file.%0
//
#define NS_E_DRM_REOPEN_CONTENT          _HRESULT_TYPEDEF_(0xC00D274FL)

//
// MessageId: NS_E_DRM_DRIVER_DIGIOUT_FAILURE
//
// MessageText:
//
// Certain driver functionality is required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_DIGIOUT_FAILURE  _HRESULT_TYPEDEF_(0xC00D2750L)

//
// MessageId: NS_E_DRM_INVALID_SECURESTORE_PASSWORD
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_SECURESTORE_PASSWORD _HRESULT_TYPEDEF_(0xC00D2751L)

//
// MessageId: NS_E_DRM_APPCERT_REVOKED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_APPCERT_REVOKED         _HRESULT_TYPEDEF_(0xC00D2752L)

//
// MessageId: NS_E_DRM_RESTORE_FRAUD
//
// MessageText:
//
// You cannot restore your license(s).%0
//
#define NS_E_DRM_RESTORE_FRAUD           _HRESULT_TYPEDEF_(0xC00D2753L)

//
// MessageId: NS_E_DRM_HARDWARE_INCONSISTENT
//
// MessageText:
//
// The licenses for your media files are corrupted. Contact Microsoft product support.%0
//
#define NS_E_DRM_HARDWARE_INCONSISTENT   _HRESULT_TYPEDEF_(0xC00D2754L)

//
// MessageId: NS_E_DRM_SDMI_TRIGGER
//
// MessageText:
//
// To transfer this media file, you must upgrade the application.%0
//
#define NS_E_DRM_SDMI_TRIGGER            _HRESULT_TYPEDEF_(0xC00D2755L)

//
// MessageId: NS_E_DRM_SDMI_NOMORECOPIES
//
// MessageText:
//
// You cannot make any more copies of this media file.%0
//
#define NS_E_DRM_SDMI_NOMORECOPIES       _HRESULT_TYPEDEF_(0xC00D2756L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT _HRESULT_TYPEDEF_(0xC00D2757L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT _HRESULT_TYPEDEF_(0xC00D2758L)

;// This error is never shown to user but needed for program logic.
//
// MessageId: NS_E_DRM_LICENSE_NOTACQUIRED
//
// MessageText:
//
// Unable to obtain license.%0
//
#define NS_E_DRM_LICENSE_NOTACQUIRED     _HRESULT_TYPEDEF_(0xC00D2759L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT _HRESULT_TYPEDEF_(0xC00D275AL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT _HRESULT_TYPEDEF_(0xC00D275BL)

//
// MessageId: NS_E_DRM_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer supplied is not sufficient.%0.
//
#define NS_E_DRM_BUFFER_TOO_SMALL        _HRESULT_TYPEDEF_(0xC00D275CL)

//
// MessageId: NS_E_DRM_UNSUPPORTED_PROPERTY
//
// MessageText:
//
// The property requested is not supported.%0.
//
#define NS_E_DRM_UNSUPPORTED_PROPERTY    _HRESULT_TYPEDEF_(0xC00D275DL)

//
// MessageId: NS_E_DRM_ERROR_BAD_NET_RESP
//
// MessageText:
//
// The specified server cannot perform the requested operation.%0.
//
#define NS_E_DRM_ERROR_BAD_NET_RESP      _HRESULT_TYPEDEF_(0xC00D275EL)

//
// MessageId: NS_E_DRM_STORE_NOTALLSTORED
//
// MessageText:
//
// Some of the licenses could not be stored.%0.
//
#define NS_E_DRM_STORE_NOTALLSTORED      _HRESULT_TYPEDEF_(0xC00D275FL)

//
// MessageId: NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID
//
// MessageText:
//
// The Digital Rights Management security upgrade component could not be validated. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID _HRESULT_TYPEDEF_(0xC00D2760L)

//
// MessageId: NS_E_DRM_INVALID_DATA
//
// MessageText:
//
// Invalid or corrupt data was encountered.%0
//
#define NS_E_DRM_INVALID_DATA            _HRESULT_TYPEDEF_(0xC00D2761L)

//
// MessageId: NS_E_DRM_POLICY_DISABLE_ONLINE
//
// MessageText:
//
// The Windows Media Digital Rights Management system cannot perform the requested action because your computer or network administrator has enabled the group policy Prevent Windows Media DRM Internet Access. For assistance, contact your administrator.%0
//
#define NS_E_DRM_POLICY_DISABLE_ONLINE   _HRESULT_TYPEDEF_(0xC00D2762L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT _HRESULT_TYPEDEF_(0xC00D2763L)

//
// MessageId: NS_E_DRM_NOT_CONFIGURED
//
// MessageText:
//
// Not all of the necessary properties for DRM have been set.%0
//
#define NS_E_DRM_NOT_CONFIGURED          _HRESULT_TYPEDEF_(0xC00D2764L)

//
// MessageId: NS_E_DRM_DEVICE_ACTIVATION_CANCELED
//
// MessageText:
//
// The portable device does not have the security required to copy protected files to it. To obtain the additional security, try to copy the file to your portable device again. When a message appears, click OK.%0
//
#define NS_E_DRM_DEVICE_ACTIVATION_CANCELED _HRESULT_TYPEDEF_(0xC00D2765L)

//
// MessageId: NS_E_BACKUP_RESTORE_TOO_MANY_RESETS
//
// MessageText:
//
// Too many resets in Backup-Restore.%0
//
#define NS_E_BACKUP_RESTORE_TOO_MANY_RESETS _HRESULT_TYPEDEF_(0xC00D2766L)

//
// MessageId: NS_E_DRM_DEBUGGING_NOT_ALLOWED
//
// MessageText:
//
// Running this process under a debugger while using DRM content is not allowed.%0
//
#define NS_E_DRM_DEBUGGING_NOT_ALLOWED   _HRESULT_TYPEDEF_(0xC00D2767L)

//
// MessageId: NS_E_DRM_OPERATION_CANCELED
//
// MessageText:
//
// The user canceled the DRM operation.%0
//
#define NS_E_DRM_OPERATION_CANCELED      _HRESULT_TYPEDEF_(0xC00D2768L)

//
// MessageId: NS_E_DRM_RESTRICTIONS_NOT_RETRIEVED
//
// MessageText:
//
// The license you are using has associated output restrictions. This license is unusable until these restrictions are queried.%0
//
#define NS_E_DRM_RESTRICTIONS_NOT_RETRIEVED _HRESULT_TYPEDEF_(0xC00D2769L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PLAYLIST_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PLAYLIST_OBJECT _HRESULT_TYPEDEF_(0xC00D276AL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PLAYLIST_BURN_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PLAYLIST_BURN_OBJECT _HRESULT_TYPEDEF_(0xC00D276BL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_DEVICE_REGISTRATION_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_DEVICE_REGISTRATION_OBJECT _HRESULT_TYPEDEF_(0xC00D276CL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_METERING_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_METERING_OBJECT _HRESULT_TYPEDEF_(0xC00D276DL)

//
// MessageId: NS_S_DRM_BURNABLE_TRACK
//
// MessageText:
//
// The track is burnable and had no playlist burn limit.%0.
//
#define NS_S_DRM_BURNABLE_TRACK          _HRESULT_TYPEDEF_(0x000D276EL)

//
// MessageId: NS_S_DRM_BURNABLE_TRACK_WITH_PLAYLIST_RESTRICTION
//
// MessageText:
//
// The track is burnable but has a playlist burn limit.%0.
//
#define NS_S_DRM_BURNABLE_TRACK_WITH_PLAYLIST_RESTRICTION _HRESULT_TYPEDEF_(0x000D276FL)

//
// MessageId: NS_E_DRM_TRACK_EXCEEDED_PLAYLIST_RESTICTION
//
// MessageText:
//
// The specified track has exceeded it's specified playlist burn limit in this playlist.%0.
//
#define NS_E_DRM_TRACK_EXCEEDED_PLAYLIST_RESTICTION _HRESULT_TYPEDEF_(0xC00D2770L)

//
// MessageId: NS_E_DRM_TRACK_EXCEEDED_TRACKBURN_RESTRICTION
//
// MessageText:
//
// The specified track has exceeded it's track burn limit.%0.
//
#define NS_E_DRM_TRACK_EXCEEDED_TRACKBURN_RESTRICTION _HRESULT_TYPEDEF_(0xC00D2771L)

//
// MessageId: NS_E_DRM_UNABLE_TO_GET_DEVICE_CERT
//
// MessageText:
//
// A problem has occurred in obtaining the device's certificate.%0.
//
#define NS_E_DRM_UNABLE_TO_GET_DEVICE_CERT _HRESULT_TYPEDEF_(0xC00D2772L)

//
// MessageId: NS_E_DRM_UNABLE_TO_GET_SECURE_CLOCK
//
// MessageText:
//
// A problem has occurred in obtaining the device's secure clock. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_GET_SECURE_CLOCK _HRESULT_TYPEDEF_(0xC00D2773L)

//
// MessageId: NS_E_DRM_UNABLE_TO_SET_SECURE_CLOCK
//
// MessageText:
//
// A problem has occurred in setting the device's secure clock. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_SET_SECURE_CLOCK _HRESULT_TYPEDEF_(0xC00D2774L)

//
// MessageId: NS_E_DRM_UNABLE_TO_GET_SECURE_CLOCK_FROM_SERVER
//
// MessageText:
//
// A problem has occurred in obtaining the secure clock from server. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_GET_SECURE_CLOCK_FROM_SERVER _HRESULT_TYPEDEF_(0xC00D2775L)

//
// MessageId: NS_E_DRM_POLICY_METERING_DISABLED
//
// MessageText:
//
// This content requires the metering policy to be enabled.%0.
//
#define NS_E_DRM_POLICY_METERING_DISABLED _HRESULT_TYPEDEF_(0xC00D2776L)

//
// MessageId: NS_E_DRM_TRANSFER_CHAINED_LICENSES_UNSUPPORTED
//
// MessageText:
//
// Transfer of chained licenses unsupported.%0.
//
#define NS_E_DRM_TRANSFER_CHAINED_LICENSES_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2777L)

//
// MessageId: NS_E_DRM_SDK_VERSIONMISMATCH
//
// MessageText:
//
// The Digital Rights Management component is not installed properly.  Reinstall the Player.%0.
//
#define NS_E_DRM_SDK_VERSIONMISMATCH     _HRESULT_TYPEDEF_(0xC00D2778L)

//
// MessageId: NS_E_DRM_LIC_NEEDS_DEVICE_CLOCK_SET
//
// MessageText:
//
// The file could not be transferred because the device clock is not set. %0.
//
#define NS_E_DRM_LIC_NEEDS_DEVICE_CLOCK_SET _HRESULT_TYPEDEF_(0xC00D2779L)

//
// MessageId: NS_E_LICENSE_HEADER_MISSING_URL
//
// MessageText:
//
// The content header is missing an acquisition URL.%0
//
#define NS_E_LICENSE_HEADER_MISSING_URL  _HRESULT_TYPEDEF_(0xC00D277AL)

//
// MessageId: NS_E_DEVICE_NOT_WMDRM_DEVICE
//
// MessageText:
//
// The current attached device does not support WMDRM.%0
//
#define NS_E_DEVICE_NOT_WMDRM_DEVICE     _HRESULT_TYPEDEF_(0xC00D277BL)

//
// MessageId: NS_E_DRM_INVALID_APPCERT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_APPCERT         _HRESULT_TYPEDEF_(0xC00D277CL)

//
// MessageId: NS_E_DRM_PROTOCOL_FORCEFUL_TERMINATION_ON_PETITION
//
// MessageText:
//
// The client application has been forcefully terminated during a DRM petition.%0.
//
#define NS_E_DRM_PROTOCOL_FORCEFUL_TERMINATION_ON_PETITION _HRESULT_TYPEDEF_(0xC00D277DL)

//
// MessageId: NS_E_DRM_PROTOCOL_FORCEFUL_TERMINATION_ON_CHALLENGE
//
// MessageText:
//
// The client application has been forcefully terminated during a DRM challenge.%0.
//
#define NS_E_DRM_PROTOCOL_FORCEFUL_TERMINATION_ON_CHALLENGE _HRESULT_TYPEDEF_(0xC00D277EL)

//
// MessageId: NS_E_DRM_CHECKPOINT_FAILED
//
// MessageText:
//
// Secure storage protection error.  Restore your licenses from a previous backup and try again.%0
//
#define NS_E_DRM_CHECKPOINT_FAILED       _HRESULT_TYPEDEF_(0xC00D277FL)

//
// MessageId: NS_E_DRM_BB_UNABLE_TO_INITIALIZE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management root of trust. Contact Microsoft product support.%0
//
#define NS_E_DRM_BB_UNABLE_TO_INITIALIZE _HRESULT_TYPEDEF_(0xC00D2780L)

//
// MessageId: NS_E_DRM_UNABLE_TO_LOAD_HARDWARE_ID
//
// MessageText:
//
// A problem has occurred in retrieving the Digital Rights Management machine identification. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_LOAD_HARDWARE_ID _HRESULT_TYPEDEF_(0xC00D2781L)

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_DATA_STORE
//
// MessageText:
//
// A problem has occurred in opening the Digital Rights Management data storage file. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_DATA_STORE _HRESULT_TYPEDEF_(0xC00D2782L)

//
// MessageId: NS_E_DRM_DATASTORE_CORRUPT
//
// MessageText:
//
// The Digital Rights Management data storage is not functioning properly.  Contact Microsoft product support.%0.
//
#define NS_E_DRM_DATASTORE_CORRUPT       _HRESULT_TYPEDEF_(0xC00D2783L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_INMEMORYSTORE_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_INMEMORYSTORE_OBJECT _HRESULT_TYPEDEF_(0xC00D2784L)

//
// MessageId: NS_E_DRM_STUBLIB_REQUIRED
//
// MessageText:
//
// A secured library is required to access the requested functionality.%0.
//
#define NS_E_DRM_STUBLIB_REQUIRED        _HRESULT_TYPEDEF_(0xC00D2785L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_CERTIFICATE_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_CERTIFICATE_OBJECT _HRESULT_TYPEDEF_(0xC00D2786L)

//
// MessageId: NS_E_DRM_MIGRATION_TARGET_NOT_ONLINE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_E_DRM_MIGRATION_TARGET_NOT_ONLINE _HRESULT_TYPEDEF_(0xC00D2787L)

//
// MessageId: NS_E_DRM_INVALID_MIGRATION_IMAGE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_MIGRATION_IMAGE _HRESULT_TYPEDEF_(0xC00D2788L)

//
// MessageId: NS_E_DRM_MIGRATION_TARGET_STATES_CORRUPTED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_E_DRM_MIGRATION_TARGET_STATES_CORRUPTED _HRESULT_TYPEDEF_(0xC00D2789L)

//
// MessageId: NS_E_DRM_MIGRATION_IMPORTER_NOT_AVAILABLE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_E_DRM_MIGRATION_IMPORTER_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D278AL)

//
// MessageId: NS_DRM_E_MIGRATION_UPGRADE_WITH_DIFF_SID
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_DRM_E_MIGRATION_UPGRADE_WITH_DIFF_SID _HRESULT_TYPEDEF_(0xC00D278BL)

//
// MessageId: NS_DRM_E_MIGRATION_SOURCE_MACHINE_IN_USE
//
// MessageText:
//
// The Digital Rights Management component is in use during license migration. Contact Microsoft product support.%0.
//
#define NS_DRM_E_MIGRATION_SOURCE_MACHINE_IN_USE _HRESULT_TYPEDEF_(0xC00D278CL)

//
// MessageId: NS_DRM_E_MIGRATION_TARGET_MACHINE_LESS_THAN_LH
//
// MessageText:
//
// Licenses are being migrated to a machine running XP or downlevel OS. This operation can only be performed on Windows Vista or a later OS. Contact Microsoft product support.%0.
//
#define NS_DRM_E_MIGRATION_TARGET_MACHINE_LESS_THAN_LH _HRESULT_TYPEDEF_(0xC00D278DL)

//
// MessageId: NS_DRM_E_MIGRATION_IMAGE_ALREADY_EXISTS
//
// MessageText:
//
// Migration Image already exists. Contact Microsoft product support.%0.
//
#define NS_DRM_E_MIGRATION_IMAGE_ALREADY_EXISTS _HRESULT_TYPEDEF_(0xC00D278EL)

//
// MessageId: NS_E_DRM_HARDWAREID_MISMATCH
//
// MessageText:
//
// The requested action cannot be performed because a hardware configuration change has been detected by the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_DRM_HARDWAREID_MISMATCH     _HRESULT_TYPEDEF_(0xC00D278FL)

//
// MessageId: NS_E_INVALID_DRMV2CLT_STUBLIB
//
// MessageText:
//
// The wrong stublib has been linked to an application or DLL using drmv2clt.dll.%0
//
#define NS_E_INVALID_DRMV2CLT_STUBLIB    _HRESULT_TYPEDEF_(0xC00D2790L)

//
// MessageId: NS_E_DRM_MIGRATION_INVALID_LEGACYV2_DATA
//
// MessageText:
//
// The legacy V2 data being imported is invalid
//
#define NS_E_DRM_MIGRATION_INVALID_LEGACYV2_DATA _HRESULT_TYPEDEF_(0xC00D2791L)

//
// MessageId: NS_E_DRM_MIGRATION_LICENSE_ALREADY_EXISTS
//
// MessageText:
//
// The license being imported already exists
//
#define NS_E_DRM_MIGRATION_LICENSE_ALREADY_EXISTS _HRESULT_TYPEDEF_(0xC00D2792L)

//
// MessageId: NS_E_DRM_MIGRATION_INVALID_LEGACYV2_SST_PASSWORD
//
// MessageText:
//
// The password of the Legacy V2 SST entry being imported is incorrect
//
#define NS_E_DRM_MIGRATION_INVALID_LEGACYV2_SST_PASSWORD _HRESULT_TYPEDEF_(0xC00D2793L)

//
// MessageId: NS_E_DRM_MIGRATION_NOT_SUPPORTED
//
// MessageText:
//
// Migration is not supported by the plugin
//
#define NS_E_DRM_MIGRATION_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D2794L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_MIGRATION_IMPORTER_OBJECT
//
// MessageText:
//
// A migration importer cannot be created for this media file. Reinstall the application.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_MIGRATION_IMPORTER_OBJECT _HRESULT_TYPEDEF_(0xC00D2795L)

//
// MessageId: NS_E_DRM_CHECKPOINT_MISMATCH
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_DRM_CHECKPOINT_MISMATCH     _HRESULT_TYPEDEF_(0xC00D2796L)

//
// MessageId: NS_E_DRM_CHECKPOINT_CORRUPT
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_DRM_CHECKPOINT_CORRUPT      _HRESULT_TYPEDEF_(0xC00D2797L)

//
// MessageId: NS_E_REG_FLUSH_FAILURE
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_REG_FLUSH_FAILURE           _HRESULT_TYPEDEF_(0xC00D2798L)

//
// MessageId: NS_E_HDS_KEY_MISMATCH
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_HDS_KEY_MISMATCH            _HRESULT_TYPEDEF_(0xC00D2799L)

//
// MessageId: NS_E_DRM_MIGRATION_OPERATION_CANCELLED
//
// MessageText:
//
// Migration was cancelled by the user.%0
//
#define NS_E_DRM_MIGRATION_OPERATION_CANCELLED _HRESULT_TYPEDEF_(0xC00D279AL)

//
// MessageId: NS_E_DRM_MIGRATION_OBJECT_IN_USE
//
// MessageText:
//
// Migration object is already in use and cannot be called until the current operation completes.%0
//
#define NS_E_DRM_MIGRATION_OBJECT_IN_USE _HRESULT_TYPEDEF_(0xC00D279BL)

//
// MessageId: NS_E_DRM_MALFORMED_CONTENT_HEADER
//
// MessageText:
//
// The content header does not comply with DRM requirements and cannot be used.%0
//
#define NS_E_DRM_MALFORMED_CONTENT_HEADER _HRESULT_TYPEDEF_(0xC00D279CL)


//
// License Reasons Section
// Error Codes why a license is not usable. Reserve 10200..10300 for this purpose.
// 10200..10249 is for license reported reasons. 10250..10300 is for client detected reasons.
//

//
// MessageId: NS_E_DRM_LICENSE_EXPIRED
//
// MessageText:
//
// The license for this file has expired and is no longer valid. Contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_EXPIRED         _HRESULT_TYPEDEF_(0xC00D27D8L)

//
// MessageId: NS_E_DRM_LICENSE_NOTENABLED
//
// MessageText:
//
// The license for this file is not valid yet, but will be at a future date.%0
//
#define NS_E_DRM_LICENSE_NOTENABLED      _HRESULT_TYPEDEF_(0xC00D27D9L)

//
// MessageId: NS_E_DRM_LICENSE_APPSECLOW
//
// MessageText:
//
// The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_APPSECLOW       _HRESULT_TYPEDEF_(0xC00D27DAL)

//
// MessageId: NS_E_DRM_STORE_NEEDINDI
//
// MessageText:
//
// The license cannot be stored as it requires security upgrade of Digital Rights Management component.%0.
//
#define NS_E_DRM_STORE_NEEDINDI          _HRESULT_TYPEDEF_(0xC00D27DBL)

//
// MessageId: NS_E_DRM_STORE_NOTALLOWED
//
// MessageText:
//
// Your machine does not meet the requirements for storing the license.%0.
//
#define NS_E_DRM_STORE_NOTALLOWED        _HRESULT_TYPEDEF_(0xC00D27DCL)

//
// MessageId: NS_E_DRM_LICENSE_APP_NOTALLOWED
//
// MessageText:
//
// The license for this file requires an upgraded version of your player or a different player.%0.
//
#define NS_E_DRM_LICENSE_APP_NOTALLOWED  _HRESULT_TYPEDEF_(0xC00D27DDL)

//
// MessageId: NS_S_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
// A security upgrade is required to perform the operation on this media file.%0
//
#define NS_S_DRM_NEEDS_INDIVIDUALIZATION _HRESULT_TYPEDEF_(0x000D27DEL)

//
// MessageId: NS_E_DRM_LICENSE_CERT_EXPIRED
//
// MessageText:
//
// The license server's certificate expired. Make sure your system clock is set correctly. Contact your content provider for further assistance. %0.
//
#define NS_E_DRM_LICENSE_CERT_EXPIRED    _HRESULT_TYPEDEF_(0xC00D27DFL)

//
// MessageId: NS_E_DRM_LICENSE_SECLOW
//
// MessageText:
//
// The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_SECLOW          _HRESULT_TYPEDEF_(0xC00D27E0L)

//
// MessageId: NS_E_DRM_LICENSE_CONTENT_REVOKED
//
// MessageText:
//
// The content owner for the license you just acquired is no longer supporting their content. Contact the content owner for a newer version of the content.%0
//
#define NS_E_DRM_LICENSE_CONTENT_REVOKED _HRESULT_TYPEDEF_(0xC00D27E1L)

//
// MessageId: NS_E_DRM_DEVICE_NOT_REGISTERED
//
// MessageText:
//
// The content owner for the license you just acquired requires your device to register to the current machine.%0
//
#define NS_E_DRM_DEVICE_NOT_REGISTERED   _HRESULT_TYPEDEF_(0xC00D27E2L)

//
// MessageId: NS_E_DRM_LICENSE_NOSAP
//
// MessageText:
//
// The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSAP           _HRESULT_TYPEDEF_(0xC00D280AL)

//
// MessageId: NS_E_DRM_LICENSE_NOSVP
//
// MessageText:
//
// The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSVP           _HRESULT_TYPEDEF_(0xC00D280BL)

//
// MessageId: NS_E_DRM_LICENSE_NOWDM
//
// MessageText:
//
// The license for this file requires Windows Driver Model (WDM) audio drivers. Contact your sound card manufacturer for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOWDM           _HRESULT_TYPEDEF_(0xC00D280CL)

//
// MessageId: NS_E_DRM_LICENSE_NOTRUSTEDCODEC
//
// MessageText:
//
// The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_NOTRUSTEDCODEC  _HRESULT_TYPEDEF_(0xC00D280DL)

//
// MessageId: NS_E_DRM_SOURCEID_NOT_SUPPORTED
//
// MessageText:
//
// The license for this file is not supported by your current player. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_SOURCEID_NOT_SUPPORTED  _HRESULT_TYPEDEF_(0xC00D280EL)


//
// End of License Reasons Section
//

//
// MessageId: NS_E_DRM_NEEDS_UPGRADE_TEMPFILE
//
// MessageText:
//
// An updated version of your media player is required to play the selected content.%0
//
#define NS_E_DRM_NEEDS_UPGRADE_TEMPFILE  _HRESULT_TYPEDEF_(0xC00D283DL)

//
// MessageId: NS_E_DRM_NEED_UPGRADE_PD
//
// MessageText:
//
// A new version of the Digital Rights Management component is required. Contact product support for this application to get the latest version.%0
//
#define NS_E_DRM_NEED_UPGRADE_PD         _HRESULT_TYPEDEF_(0xC00D283EL)

//
// MessageId: NS_E_DRM_SIGNATURE_FAILURE
//
// MessageText:
//
// Failed to either create or verify the content header.%0
//
#define NS_E_DRM_SIGNATURE_FAILURE       _HRESULT_TYPEDEF_(0xC00D283FL)

//
// MessageId: NS_E_DRM_LICENSE_SERVER_INFO_MISSING
//
// MessageText:
//
// Could not read the necessary information from the system registry.%0
//
#define NS_E_DRM_LICENSE_SERVER_INFO_MISSING _HRESULT_TYPEDEF_(0xC00D2840L)

//
// MessageId: NS_E_DRM_BUSY
//
// MessageText:
//
// The DRM subsystem is currently locked by another application or user.  Try again later.%0
//
#define NS_E_DRM_BUSY                    _HRESULT_TYPEDEF_(0xC00D2841L)

//
// MessageId: NS_E_DRM_PD_TOO_MANY_DEVICES
//
// MessageText:
//
// There are too many target devices registered on the portable media.%0
//
#define NS_E_DRM_PD_TOO_MANY_DEVICES     _HRESULT_TYPEDEF_(0xC00D2842L)

//
// MessageId: NS_E_DRM_INDIV_FRAUD
//
// MessageText:
//
// The security upgrade cannot be completed because the allowed number of daily upgrades has been exceeded. Try again tomorrow.%0
//
#define NS_E_DRM_INDIV_FRAUD             _HRESULT_TYPEDEF_(0xC00D2843L)

//
// MessageId: NS_E_DRM_INDIV_NO_CABS
//
// MessageText:
//
// The security upgrade cannot be completed because the server is unable to perform the operation. Try again later.%0
//
#define NS_E_DRM_INDIV_NO_CABS           _HRESULT_TYPEDEF_(0xC00D2844L)

//
// MessageId: NS_E_DRM_INDIV_SERVICE_UNAVAILABLE
//
// MessageText:
//
// The security upgrade cannot be performed because the server is not available. Try again later.%0
//
#define NS_E_DRM_INDIV_SERVICE_UNAVAILABLE _HRESULT_TYPEDEF_(0xC00D2845L)

//
// MessageId: NS_E_DRM_RESTORE_SERVICE_UNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot restore your licenses because the server is not available. Try again later.%0
//
#define NS_E_DRM_RESTORE_SERVICE_UNAVAILABLE _HRESULT_TYPEDEF_(0xC00D2846L)

//
// MessageId: NS_E_DRM_CLIENT_CODE_EXPIRED
//
// MessageText:
//
// Windows Media Player cannot play the protected file. Verify that your computer's date is set correctly. If it is correct, on the Help menu, click Check for Player Updates to install the latest version of the Player.%0
//
#define NS_E_DRM_CLIENT_CODE_EXPIRED     _HRESULT_TYPEDEF_(0xC00D2847L)

//
// MessageId: NS_E_DRM_NO_UPLINK_LICENSE
//
// MessageText:
//
// The chained license cannot be created because the referenced uplink license does not exist.
//
#define NS_E_DRM_NO_UPLINK_LICENSE       _HRESULT_TYPEDEF_(0xC00D2848L)

//
// MessageId: NS_E_DRM_INVALID_KID
//
// MessageText:
//
// The specified KID is invalid
//
#define NS_E_DRM_INVALID_KID             _HRESULT_TYPEDEF_(0xC00D2849L)

//
// MessageId: NS_E_DRM_LICENSE_INITIALIZATION_ERROR
//
// MessageText:
//
// License initialization did not work. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_INITIALIZATION_ERROR _HRESULT_TYPEDEF_(0xC00D284AL)

//
// MessageId: NS_E_DRM_CHAIN_TOO_LONG
//
// MessageText:
//
// The uplink license of a chained license cannot itself be a chained license.
//
#define NS_E_DRM_CHAIN_TOO_LONG          _HRESULT_TYPEDEF_(0xC00D284CL)

//
// MessageId: NS_E_DRM_UNSUPPORTED_ALGORITHM
//
// MessageText:
//
// The specified encryption algorithm is unsupported.
//
#define NS_E_DRM_UNSUPPORTED_ALGORITHM   _HRESULT_TYPEDEF_(0xC00D284DL)

//
// MessageId: NS_E_DRM_LICENSE_DELETION_ERROR
//
// MessageText:
//
// License deletion did not work. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_DELETION_ERROR  _HRESULT_TYPEDEF_(0xC00D284EL)


//
// WMDRMNET Reasons Section
// Error Codes related to WMDRMNET (WMDRM-ND) or Device Registration.
// Reserved 10400..10500 for this purpose.
//

//
// MessageId: NS_E_DRM_INVALID_CERTIFICATE
//
// MessageText:
//
// The client's certificate is corrupted or the signature cannot be verified.%0
//
#define NS_E_DRM_INVALID_CERTIFICATE     _HRESULT_TYPEDEF_(0xC00D28A0L)

//
// MessageId: NS_E_DRM_CERTIFICATE_REVOKED
//
// MessageText:
//
// The client's certificate has been revoked.%0
//
#define NS_E_DRM_CERTIFICATE_REVOKED     _HRESULT_TYPEDEF_(0xC00D28A1L)

//
// MessageId: NS_E_DRM_LICENSE_UNAVAILABLE
//
// MessageText:
//
// There is no license available for the requested action.%0
//
#define NS_E_DRM_LICENSE_UNAVAILABLE     _HRESULT_TYPEDEF_(0xC00D28A2L)

//
// MessageId: NS_E_DRM_DEVICE_LIMIT_REACHED
//
// MessageText:
//
// The maximum number of devices in use has been reached. Unable to open additional devices.%0
//
#define NS_E_DRM_DEVICE_LIMIT_REACHED    _HRESULT_TYPEDEF_(0xC00D28A3L)

//
// MessageId: NS_E_DRM_UNABLE_TO_VERIFY_PROXIMITY
//
// MessageText:
//
// The proximity detection procedure could not confirm that the receiver is near the transmitter in the network.%0
//
#define NS_E_DRM_UNABLE_TO_VERIFY_PROXIMITY _HRESULT_TYPEDEF_(0xC00D28A4L)

//
// MessageId: NS_E_DRM_MUST_REGISTER
//
// MessageText:
//
// The client must be registered before executing the intended operation.%0
//
#define NS_E_DRM_MUST_REGISTER           _HRESULT_TYPEDEF_(0xC00D28A5L)

//
// MessageId: NS_E_DRM_MUST_APPROVE
//
// MessageText:
//
// The client must be approved before executing the intended operation.%0
//
#define NS_E_DRM_MUST_APPROVE            _HRESULT_TYPEDEF_(0xC00D28A6L)

//
// MessageId: NS_E_DRM_MUST_REVALIDATE
//
// MessageText:
//
// The client must be revalidated before executing the intended operation.%0
//
#define NS_E_DRM_MUST_REVALIDATE         _HRESULT_TYPEDEF_(0xC00D28A7L)

//
// MessageId: NS_E_DRM_INVALID_PROXIMITY_RESPONSE
//
// MessageText:
//
// The response to the proximity detection challenge is invalid.%0
//
#define NS_E_DRM_INVALID_PROXIMITY_RESPONSE _HRESULT_TYPEDEF_(0xC00D28A8L)

//
// MessageId: NS_E_DRM_INVALID_SESSION
//
// MessageText:
//
// The requested session is invalid.%0
//
#define NS_E_DRM_INVALID_SESSION         _HRESULT_TYPEDEF_(0xC00D28A9L)

//
// MessageId: NS_E_DRM_DEVICE_NOT_OPEN
//
// MessageText:
//
// The device must be opened before it can be used to receive content.%0
//
#define NS_E_DRM_DEVICE_NOT_OPEN         _HRESULT_TYPEDEF_(0xC00D28AAL)

//
// MessageId: NS_E_DRM_DEVICE_ALREADY_REGISTERED
//
// MessageText:
//
// Device registration failed because the device is already registered.%0
//
#define NS_E_DRM_DEVICE_ALREADY_REGISTERED _HRESULT_TYPEDEF_(0xC00D28ABL)

//
// MessageId: NS_E_DRM_UNSUPPORTED_PROTOCOL_VERSION
//
// MessageText:
//
// Unsupported WMDRM-ND protocol version.%0
//
#define NS_E_DRM_UNSUPPORTED_PROTOCOL_VERSION _HRESULT_TYPEDEF_(0xC00D28ACL)

//
// MessageId: NS_E_DRM_UNSUPPORTED_ACTION
//
// MessageText:
//
// The requested action is not supported.%0
//
#define NS_E_DRM_UNSUPPORTED_ACTION      _HRESULT_TYPEDEF_(0xC00D28ADL)

//
// MessageId: NS_E_DRM_CERTIFICATE_SECURITY_LEVEL_INADEQUATE
//
// MessageText:
//
// The certificate does not have an adequate security level for the requested action.%0
//
#define NS_E_DRM_CERTIFICATE_SECURITY_LEVEL_INADEQUATE _HRESULT_TYPEDEF_(0xC00D28AEL)

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_PORT
//
// MessageText:
//
// Unable to open the specified port for receiving Proximity messages.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_PORT     _HRESULT_TYPEDEF_(0xC00D28AFL)

//
// MessageId: NS_E_DRM_BAD_REQUEST
//
// MessageText:
//
// The message format is invalid.%0
//
#define NS_E_DRM_BAD_REQUEST             _HRESULT_TYPEDEF_(0xC00D28B0L)

//
// MessageId: NS_E_DRM_INVALID_CRL
//
// MessageText:
//
// The Certificate Revocation List is invalid or corrupted.%0
//
#define NS_E_DRM_INVALID_CRL             _HRESULT_TYPEDEF_(0xC00D28B1L)

//
// MessageId: NS_E_DRM_ATTRIBUTE_TOO_LONG
//
// MessageText:
//
// The length of the attribute name or value is too long.%0
//
#define NS_E_DRM_ATTRIBUTE_TOO_LONG      _HRESULT_TYPEDEF_(0xC00D28B2L)

//
// MessageId: NS_E_DRM_EXPIRED_LICENSEBLOB
//
// MessageText:
//
// The license blob passed in the cardea request is expired.%0
//
#define NS_E_DRM_EXPIRED_LICENSEBLOB     _HRESULT_TYPEDEF_(0xC00D28B3L)

//
// MessageId: NS_E_DRM_INVALID_LICENSEBLOB
//
// MessageText:
//
// The license blob passed in the cardea request is invalid. Contact Microsoft product support.%0
//
#define NS_E_DRM_INVALID_LICENSEBLOB     _HRESULT_TYPEDEF_(0xC00D28B4L)

//
// MessageId: NS_E_DRM_INCLUSION_LIST_REQUIRED
//
// MessageText:
//
// The requested operation can not be performed because the license does not contain an inclusion list.%0
//
#define NS_E_DRM_INCLUSION_LIST_REQUIRED _HRESULT_TYPEDEF_(0xC00D28B5L)

//
// MessageId: NS_E_DRM_DRMV2CLT_REVOKED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_DRMV2CLT_REVOKED        _HRESULT_TYPEDEF_(0xC00D28B6L)

//
// MessageId: NS_E_DRM_RIV_TOO_SMALL
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_RIV_TOO_SMALL           _HRESULT_TYPEDEF_(0xC00D28B7L)


//
// Output link protection error codes
//

//
// MessageId: NS_E_OUTPUT_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of output protection required by the content.%0
//
#define NS_E_OUTPUT_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2904L)

//
// MessageId: NS_E_COMPRESSED_DIGITAL_VIDEO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for compressed digital video.%0
//
#define NS_E_COMPRESSED_DIGITAL_VIDEO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2905L)

//
// MessageId: NS_E_UNCOMPRESSED_DIGITAL_VIDEO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for uncompressed digital video.%0
//
#define NS_E_UNCOMPRESSED_DIGITAL_VIDEO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2906L)

//
// MessageId: NS_E_ANALOG_VIDEO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for analog video.%0
//
#define NS_E_ANALOG_VIDEO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2907L)

//
// MessageId: NS_E_COMPRESSED_DIGITAL_AUDIO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for compressed digital audio.%0
//
#define NS_E_COMPRESSED_DIGITAL_AUDIO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2908L)

//
// MessageId: NS_E_UNCOMPRESSED_DIGITAL_AUDIO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for uncompressed digital audio.%0
//
#define NS_E_UNCOMPRESSED_DIGITAL_AUDIO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2909L)

//
// MessageId: NS_E_OUTPUT_PROTECTION_SCHEME_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the scheme of output protection required by the content.%0
//
#define NS_E_OUTPUT_PROTECTION_SCHEME_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D290AL)



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Setup Specific Errors
//
// IdRange = 11000..11999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_S_REBOOT_RECOMMENDED
//
// MessageText:
//
// Installation was successful; however, some file cleanup is not complete. For best results, restart your computer.%0
//
#define NS_S_REBOOT_RECOMMENDED          _HRESULT_TYPEDEF_(0x000D2AF8L)

//
// MessageId: NS_S_REBOOT_REQUIRED
//
// MessageText:
//
// Installation was successful; however, some file cleanup is not complete. To continue, you must restart your computer.%0
//
#define NS_S_REBOOT_REQUIRED             _HRESULT_TYPEDEF_(0x000D2AF9L)

//
// MessageId: NS_E_REBOOT_RECOMMENDED
//
// MessageText:
//
// Installation was not successful and some file cleanup is not complete. For best results, restart your computer.%0
//
#define NS_E_REBOOT_RECOMMENDED          _HRESULT_TYPEDEF_(0xC00D2AFAL)

//
// MessageId: NS_E_REBOOT_REQUIRED
//
// MessageText:
//
// Installation was not successful. To continue, you must restart your computer.%0
//
#define NS_E_REBOOT_REQUIRED             _HRESULT_TYPEDEF_(0xC00D2AFBL)

//
// MessageId: NS_E_SETUP_INCOMPLETE
//
// MessageText:
//
// Installation was not successful.%0.
//
#define NS_E_SETUP_INCOMPLETE            _HRESULT_TYPEDEF_(0xC00D2AFCL)

//
// MessageId: NS_E_SETUP_DRM_MIGRATION_FAILED
//
// MessageText:
//
// Setup cannot migrate the Windows Media Digital Rights Management (DRM) components.%0.
//
#define NS_E_SETUP_DRM_MIGRATION_FAILED  _HRESULT_TYPEDEF_(0xC00D2AFDL)

//
// MessageId: NS_E_SETUP_IGNORABLE_FAILURE
//
// MessageText:
//
// Some skin or playlist components cannot be installed.%0.
//
#define NS_E_SETUP_IGNORABLE_FAILURE     _HRESULT_TYPEDEF_(0xC00D2AFEL)

//
// MessageId: NS_E_SETUP_DRM_MIGRATION_FAILED_AND_IGNORABLE_FAILURE
//
// MessageText:
//
// Setup cannot migrate the Windows Media Digital Rights Management (DRM) components. In addition, some skin or playlist components cannot be installed.%0.
//
#define NS_E_SETUP_DRM_MIGRATION_FAILED_AND_IGNORABLE_FAILURE _HRESULT_TYPEDEF_(0xC00D2AFFL)

//
// MessageId: NS_E_SETUP_BLOCKED
//
// MessageText:
//
// Installation is blocked because your computer does not meet one or more of the setup requirements.%0.
//
#define NS_E_SETUP_BLOCKED               _HRESULT_TYPEDEF_(0xC00D2B00L)


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Networking Errors
//
// IdRange = 12000..12999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_UNKNOWN_PROTOCOL
//
// MessageText:
//
// The specified protocol is not supported.%0
//
#define NS_E_UNKNOWN_PROTOCOL            _HRESULT_TYPEDEF_(0xC00D2EE0L)

//
// MessageId: NS_E_REDIRECT_TO_PROXY
//
// MessageText:
//
// The client is redirected to a proxy server.%0
//
#define NS_E_REDIRECT_TO_PROXY           _HRESULT_TYPEDEF_(0xC00D2EE1L)

//
// MessageId: NS_E_INTERNAL_SERVER_ERROR
//
// MessageText:
//
// The server encountered an unexpected condition which prevented it from fulfilling the request.%0
//
#define NS_E_INTERNAL_SERVER_ERROR       _HRESULT_TYPEDEF_(0xC00D2EE2L)

//
// MessageId: NS_E_BAD_REQUEST
//
// MessageText:
//
// The request could not be understood by the server.%0
//
#define NS_E_BAD_REQUEST                 _HRESULT_TYPEDEF_(0xC00D2EE3L)

//
// MessageId: NS_E_ERROR_FROM_PROXY
//
// MessageText:
//
// The proxy experienced an error while attempting to contact the media server.%0
//
#define NS_E_ERROR_FROM_PROXY            _HRESULT_TYPEDEF_(0xC00D2EE4L)

//
// MessageId: NS_E_PROXY_TIMEOUT
//
// MessageText:
//
// The proxy did not receive a timely response while attempting to contact the media server.%0
//
#define NS_E_PROXY_TIMEOUT               _HRESULT_TYPEDEF_(0xC00D2EE5L)

//
// MessageId: NS_E_SERVER_UNAVAILABLE
//
// MessageText:
//
// The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.%0
//
#define NS_E_SERVER_UNAVAILABLE          _HRESULT_TYPEDEF_(0xC00D2EE6L)

//
// MessageId: NS_E_REFUSED_BY_SERVER
//
// MessageText:
//
// The server is refusing to fulfill the requested operation.%0
//
#define NS_E_REFUSED_BY_SERVER           _HRESULT_TYPEDEF_(0xC00D2EE7L)

//
// MessageId: NS_E_INCOMPATIBLE_SERVER
//
// MessageText:
//
// The server is not a compatible streaming media server.%0
//
#define NS_E_INCOMPATIBLE_SERVER         _HRESULT_TYPEDEF_(0xC00D2EE8L)

//
// MessageId: NS_E_MULTICAST_DISABLED
//
// MessageText:
//
// The content cannot be streamed because the Multicast protocol has been disabled.%0
//
#define NS_E_MULTICAST_DISABLED          _HRESULT_TYPEDEF_(0xC00D2EE9L)

//
// MessageId: NS_E_INVALID_REDIRECT
//
// MessageText:
//
// The server redirected the player to an invalid location.%0
//
#define NS_E_INVALID_REDIRECT            _HRESULT_TYPEDEF_(0xC00D2EEAL)

//
// MessageId: NS_E_ALL_PROTOCOLS_DISABLED
//
// MessageText:
//
// The content cannot be streamed because all protocols have been disabled.%0
//
#define NS_E_ALL_PROTOCOLS_DISABLED      _HRESULT_TYPEDEF_(0xC00D2EEBL)

//
// MessageId: NS_E_MSBD_NO_LONGER_SUPPORTED
//
// MessageText:
//
// The MSBD protocol is no longer supported. Please use HTTP to connect to the Windows Media stream.%0
//
#define NS_E_MSBD_NO_LONGER_SUPPORTED    _HRESULT_TYPEDEF_(0xC00D2EECL)

//
// MessageId: NS_E_PROXY_NOT_FOUND
//
// MessageText:
//
// The proxy server could not be located. Please check your proxy server configuration.%0
//
#define NS_E_PROXY_NOT_FOUND             _HRESULT_TYPEDEF_(0xC00D2EEDL)

//
// MessageId: NS_E_CANNOT_CONNECT_TO_PROXY
//
// MessageText:
//
// Unable to establish a connection to the proxy server. Please check your proxy server configuration.%0
//
#define NS_E_CANNOT_CONNECT_TO_PROXY     _HRESULT_TYPEDEF_(0xC00D2EEEL)

//
// MessageId: NS_E_SERVER_DNS_TIMEOUT
//
// MessageText:
//
// Unable to locate the media server. The operation timed out.%0
//
#define NS_E_SERVER_DNS_TIMEOUT          _HRESULT_TYPEDEF_(0xC00D2EEFL)

//
// MessageId: NS_E_PROXY_DNS_TIMEOUT
//
// MessageText:
//
// Unable to locate the proxy server. The operation timed out.%0
//
#define NS_E_PROXY_DNS_TIMEOUT           _HRESULT_TYPEDEF_(0xC00D2EF0L)

//
// MessageId: NS_E_CLOSED_ON_SUSPEND
//
// MessageText:
//
// Media closed because Windows was shut down.%0
//
#define NS_E_CLOSED_ON_SUSPEND           _HRESULT_TYPEDEF_(0xC00D2EF1L)

//
// MessageId: NS_E_CANNOT_READ_PLAYLIST_FROM_MEDIASERVER
//
// MessageText:
//
// Unable to read the contents of a playlist file from a media server.%0
//
#define NS_E_CANNOT_READ_PLAYLIST_FROM_MEDIASERVER _HRESULT_TYPEDEF_(0xC00D2EF2L)

//
// MessageId: NS_E_SESSION_NOT_FOUND
//
// MessageText:
//
// Session not found.%0
//
#define NS_E_SESSION_NOT_FOUND           _HRESULT_TYPEDEF_(0xC00D2EF3L)

//
// MessageId: NS_E_REQUIRE_STREAMING_CLIENT
//
// MessageText:
//
// Content requires a streaming media client.%0
//
#define NS_E_REQUIRE_STREAMING_CLIENT    _HRESULT_TYPEDEF_(0xC00D2EF4L)

//
// MessageId: NS_E_PLAYLIST_ENTRY_HAS_CHANGED
//
// MessageText:
//
// A command applies to a previous playlist entry.%0
//
#define NS_E_PLAYLIST_ENTRY_HAS_CHANGED  _HRESULT_TYPEDEF_(0xC00D2EF5L)

//
// MessageId: NS_E_PROXY_ACCESSDENIED
//
// MessageText:
//
// The proxy server is denying access.  The username and/or password might be incorrect.%0
//
#define NS_E_PROXY_ACCESSDENIED          _HRESULT_TYPEDEF_(0xC00D2EF6L)

//
// MessageId: NS_E_PROXY_SOURCE_ACCESSDENIED
//
// MessageText:
//
// The proxy could not provide valid authentication credentials to the media server.%0
//
#define NS_E_PROXY_SOURCE_ACCESSDENIED   _HRESULT_TYPEDEF_(0xC00D2EF7L)

//
// MessageId: NS_E_NETWORK_SINK_WRITE
//
// MessageText:
//
// The network sink failed to write data to the network.%0
//
#define NS_E_NETWORK_SINK_WRITE          _HRESULT_TYPEDEF_(0xC00D2EF8L)

//
// MessageId: NS_E_FIREWALL
//
// MessageText:
//
// Packets are not being received from the server. The packets might be blocked by a filtering device, such as a network firewall.%0
//
#define NS_E_FIREWALL                    _HRESULT_TYPEDEF_(0xC00D2EF9L)

//
// MessageId: NS_E_MMS_NOT_SUPPORTED
//
// MessageText:
//
// The MMS protocol is not supported. Please use HTTP or RTSP to connect to the Windows Media stream.%0
//
#define NS_E_MMS_NOT_SUPPORTED           _HRESULT_TYPEDEF_(0xC00D2EFAL)

//
// MessageId: NS_E_SERVER_ACCESSDENIED
//
// MessageText:
//
// The Windows Media server is denying access.  The username and/or password might be incorrect.%0
//
#define NS_E_SERVER_ACCESSDENIED         _HRESULT_TYPEDEF_(0xC00D2EFBL)

//
// MessageId: NS_E_RESOURCE_GONE
//
// MessageText:
//
// The Publishing Point or file on the Windows Media Server is no longer available.%0
//
#define NS_E_RESOURCE_GONE               _HRESULT_TYPEDEF_(0xC00D2EFCL)

//
// MessageId: NS_E_NO_EXISTING_PACKETIZER
//
// MessageText:
//
// There is no existing packetizer plugin for a stream.%0
//
#define NS_E_NO_EXISTING_PACKETIZER      _HRESULT_TYPEDEF_(0xC00D2EFDL)

//
// MessageId: NS_E_BAD_SYNTAX_IN_SERVER_RESPONSE
//
// MessageText:
//
// The response from the media server could not be understood. This might be caused by an incompatible proxy server or media server.%0
//
#define NS_E_BAD_SYNTAX_IN_SERVER_RESPONSE _HRESULT_TYPEDEF_(0xC00D2EFEL)

//
// MessageId: NS_I_RECONNECTED
//
// MessageText:
//
// The client is reconnected.%0
//
#define NS_I_RECONNECTED                 _HRESULT_TYPEDEF_(0x400D2EFFL)

//
// MessageId: NS_E_RESET_SOCKET_CONNECTION
//
// MessageText:
//
// The Windows Media Server reset the network connection.%0
//
#define NS_E_RESET_SOCKET_CONNECTION     _HRESULT_TYPEDEF_(0xC00D2F00L)

//
// MessageId: NS_I_NOLOG_STOP
//
// MessageText:
//
// Forcing a switch to a pending header on start.%0
//
#define NS_I_NOLOG_STOP                  _HRESULT_TYPEDEF_(0x400D2F01L)

//
// MessageId: NS_E_TOO_MANY_HOPS
//
// MessageText:
//
// The request could not reach the media server (too many hops).%0
//
#define NS_E_TOO_MANY_HOPS               _HRESULT_TYPEDEF_(0xC00D2F02L)

//
// MessageId: NS_I_EXISTING_PACKETIZER
//
// MessageText:
//
// There is already an existing packetizer plugin for the stream.%0
//
#define NS_I_EXISTING_PACKETIZER         _HRESULT_TYPEDEF_(0x400D2F03L)

//
// MessageId: NS_I_MANUAL_PROXY
//
// MessageText:
//
// The proxy setting is manual.%0
//
#define NS_I_MANUAL_PROXY                _HRESULT_TYPEDEF_(0x400D2F04L)

//
// MessageId: NS_E_TOO_MUCH_DATA_FROM_SERVER
//
// MessageText:
//
// The server is sending too much data. The connection has been terminated.%0
//
#define NS_E_TOO_MUCH_DATA_FROM_SERVER   _HRESULT_TYPEDEF_(0xC00D2F05L)

//
// MessageId: NS_E_CONNECT_TIMEOUT
//
// MessageText:
//
// It was not possible to establish a connection to the media server in a timely manner. The media server may be down for maintenance, or it may be necessary to use a proxy server to access this media server.%0
//
#define NS_E_CONNECT_TIMEOUT             _HRESULT_TYPEDEF_(0xC00D2F06L)

//
// MessageId: NS_E_PROXY_CONNECT_TIMEOUT
//
// MessageText:
//
// It was not possible to establish a connection to the proxy server in a timely manner. Please check your proxy server configuration.%0
//
#define NS_E_PROXY_CONNECT_TIMEOUT       _HRESULT_TYPEDEF_(0xC00D2F07L)

//
// MessageId: NS_E_SESSION_INVALID
//
// MessageText:
//
// Session not found.%0
//
#define NS_E_SESSION_INVALID             _HRESULT_TYPEDEF_(0xC00D2F08L)

//
// MessageId: NS_S_EOSRECEDING
//
// MessageText:
//
// EOS hit during rewinding.%0
//
#define NS_S_EOSRECEDING                 _HRESULT_TYPEDEF_(0x000D2F09L)

//
// MessageId: NS_E_PACKETSINK_UNKNOWN_FEC_STREAM
//
// MessageText:
//
// Unknown packet sink stream.%0
//
#define NS_E_PACKETSINK_UNKNOWN_FEC_STREAM _HRESULT_TYPEDEF_(0xC00D2F0AL)

//
// MessageId: NS_E_PUSH_CANNOTCONNECT
//
// MessageText:
//
// Unable to establish a connection to the server. Ensure Windows Media Services is started and the HTTP Server control protocol is properly enabled.%0
//
#define NS_E_PUSH_CANNOTCONNECT          _HRESULT_TYPEDEF_(0xC00D2F0BL)

//
// MessageId: NS_E_INCOMPATIBLE_PUSH_SERVER
//
// MessageText:
//
// The Server service that received the HTTP push request is not a compatible version of Windows Media Services (WMS).  This error may indicate the push request was received by IIS instead of WMS.  Ensure WMS is started and has the HTTP Server control protocol properly enabled and try again.%0
//
#define NS_E_INCOMPATIBLE_PUSH_SERVER    _HRESULT_TYPEDEF_(0xC00D2F0CL)

//
// MessageId: NS_S_CHANGENOTICE
//
// MessageText:
//
// Internal.%0
//
#define NS_S_CHANGENOTICE                _HRESULT_TYPEDEF_(0x000D2F0DL)


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Client Media Services
//
// IdRange = 13000..13999 (0x32C8-0x36AF)
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_END_OF_PLAYLIST
//
// MessageText:
//
// The playlist has reached its end.%0
//
#define NS_E_END_OF_PLAYLIST             _HRESULT_TYPEDEF_(0xC00D32C8L)

//
// MessageId: NS_E_USE_FILE_SOURCE
//
// MessageText:
//
// Use file source.%0
//
#define NS_E_USE_FILE_SOURCE             _HRESULT_TYPEDEF_(0xC00D32C9L)

//
// MessageId: NS_E_PROPERTY_NOT_FOUND
//
// MessageText:
//
// The property was not found.%0
//
#define NS_E_PROPERTY_NOT_FOUND          _HRESULT_TYPEDEF_(0xC00D32CAL)

//
// MessageId: NS_E_PROPERTY_READ_ONLY
//
// MessageText:
//
// The property is read only.%0
//
#define NS_E_PROPERTY_READ_ONLY          _HRESULT_TYPEDEF_(0xC00D32CCL)

//
// MessageId: NS_E_TABLE_KEY_NOT_FOUND
//
// MessageText:
//
// The table key was not found.%0
//
#define NS_E_TABLE_KEY_NOT_FOUND         _HRESULT_TYPEDEF_(0xC00D32CDL)

//
// MessageId: NS_E_INVALID_QUERY_OPERATOR
//
// MessageText:
//
// Invalid query operator.%0
//
#define NS_E_INVALID_QUERY_OPERATOR      _HRESULT_TYPEDEF_(0xC00D32CFL)

//
// MessageId: NS_E_INVALID_QUERY_PROPERTY
//
// MessageText:
//
// Invalid query property.%0
//
#define NS_E_INVALID_QUERY_PROPERTY      _HRESULT_TYPEDEF_(0xC00D32D0L)

//
// MessageId: NS_E_PROPERTY_NOT_SUPPORTED
//
// MessageText:
//
// The property is not supported.%0
//
#define NS_E_PROPERTY_NOT_SUPPORTED      _HRESULT_TYPEDEF_(0xC00D32D2L)

//
// MessageId: NS_E_SCHEMA_CLASSIFY_FAILURE
//
// MessageText:
//
// Schema classification failure.%0
//
#define NS_E_SCHEMA_CLASSIFY_FAILURE     _HRESULT_TYPEDEF_(0xC00D32D4L)

//
// MessageId: NS_E_METADATA_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// The metadata format is not supported.%0
//
#define NS_E_METADATA_FORMAT_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D32D5L)

//
// MessageId: NS_E_METADATA_NO_EDITING_CAPABILITY
//
// MessageText:
//
// Cannot edit the metadata.%0
//
#define NS_E_METADATA_NO_EDITING_CAPABILITY _HRESULT_TYPEDEF_(0xC00D32D6L)

//
// MessageId: NS_E_METADATA_CANNOT_SET_LOCALE
//
// MessageText:
//
// Cannot set the locale id.%0
//
#define NS_E_METADATA_CANNOT_SET_LOCALE  _HRESULT_TYPEDEF_(0xC00D32D7L)

//
// MessageId: NS_E_METADATA_LANGUAGE_NOT_SUPORTED
//
// MessageText:
//
// The language is not supported in the format.%0
//
#define NS_E_METADATA_LANGUAGE_NOT_SUPORTED _HRESULT_TYPEDEF_(0xC00D32D8L)

//
// MessageId: NS_E_METADATA_NO_RFC1766_NAME_FOR_LOCALE
//
// MessageText:
//
// There is no RFC1766 name translation for the supplied locale id.%0
//
#define NS_E_METADATA_NO_RFC1766_NAME_FOR_LOCALE _HRESULT_TYPEDEF_(0xC00D32D9L)

//
// MessageId: NS_E_METADATA_NOT_AVAILABLE
//
// MessageText:
//
// The metadata (or metadata item) is not available.%0
//
#define NS_E_METADATA_NOT_AVAILABLE      _HRESULT_TYPEDEF_(0xC00D32DAL)

//
// MessageId: NS_E_METADATA_CACHE_DATA_NOT_AVAILABLE
//
// MessageText:
//
// The cached metadata (or metadata item) is not available.%0
//
#define NS_E_METADATA_CACHE_DATA_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D32DBL)

//
// MessageId: NS_E_METADATA_INVALID_DOCUMENT_TYPE
//
// MessageText:
//
// The metadata document is invalid.%0
//
#define NS_E_METADATA_INVALID_DOCUMENT_TYPE _HRESULT_TYPEDEF_(0xC00D32DCL)

//
// MessageId: NS_E_METADATA_IDENTIFIER_NOT_AVAILABLE
//
// MessageText:
//
// The metadata content identifier is not available.%0
//
#define NS_E_METADATA_IDENTIFIER_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D32DDL)

//
// MessageId: NS_E_METADATA_CANNOT_RETRIEVE_FROM_OFFLINE_CACHE
//
// MessageText:
//
// Cannot retrieve metadata from the offline metadata cache.%0
//
#define NS_E_METADATA_CANNOT_RETRIEVE_FROM_OFFLINE_CACHE _HRESULT_TYPEDEF_(0xC00D32DEL)


#endif // _NSERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\NspAPI.h ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    nspapi.h

Abstract:

    Name Space Provider API prototypes and manifests. See the
    "Windows NT NameSpace Provider Specification" document for
    details.


Environment:

    User Mode -Win32

Notes:

    You must include "basetyps.h" first. Some types should
    use definitions from base files rather than redefine here.
    Unfortunately, so such base file exists.

--*/

#ifndef _NSPAPI_INCLUDED
#define _NSPAPI_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
typedef struct _BLOB {
    ULONG cbSize ;
#ifdef MIDL_PASS
    [size_is(cbSize)] BYTE *pBlobData;
#else  // MIDL_PASS
    BYTE *pBlobData ;
#endif // MIDL_PASS
} BLOB, *LPBLOB ;
#endif

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif


//
// Service categories
//
#define SERVICE_RESOURCE            (0x00000001)
#define SERVICE_SERVICE             (0x00000002)
#define SERVICE_LOCAL               (0x00000004)

//
// Operation used when calling SetService()
//
#define SERVICE_REGISTER            (0x00000001)
#define SERVICE_DEREGISTER          (0x00000002)
#define SERVICE_FLUSH               (0x00000003)
#define SERVICE_ADD_TYPE            (0x00000004)
#define SERVICE_DELETE_TYPE         (0x00000005)

//
// Flags that affect the operations above
//
#define SERVICE_FLAG_DEFER          (0x00000001)
#define SERVICE_FLAG_HARD           (0x00000002)

//
// Used as input to GetService() for setting the dwProps parameter
//
#define PROP_COMMENT                (0x00000001)
#define PROP_LOCALE                 (0x00000002)
#define PROP_DISPLAY_HINT           (0x00000004)
#define PROP_VERSION                (0x00000008)
#define PROP_START_TIME             (0x00000010)
#define PROP_MACHINE                (0x00000020)
#define PROP_ADDRESSES              (0x00000100)
#define PROP_SD                     (0x00000200)
#define PROP_ALL                    (0x80000000)

//
// Flags that describe attributes of Service Addresses
//

#define SERVICE_ADDRESS_FLAG_RPC_CN (0x00000001)
#define SERVICE_ADDRESS_FLAG_RPC_DG (0x00000002)
#define SERVICE_ADDRESS_FLAG_RPC_NB (0x00000004)

//
// Name Spaces
//

#define NS_DEFAULT                  (0)

#define NS_SAP                      (1)
#define NS_NDS                      (2)
#define NS_PEER_BROWSE              (3)

#define NS_TCPIP_LOCAL              (10)
#define NS_TCPIP_HOSTS              (11)
#define NS_DNS                      (12)
#define NS_NETBT                    (13)
#define NS_WINS                     (14)

#define NS_NBP                      (20)

#define NS_MS                       (30)
#define NS_STDA                     (31)
#define NS_NTDS                     (32)

#define NS_X500                     (40)
#define NS_NIS                      (41)

#define NS_VNS                      (50)

//
// Name space attributes.
//
#define NSTYPE_HIERARCHICAL         (0x00000001)
#define NSTYPE_DYNAMIC              (0x00000002)
#define NSTYPE_ENUMERABLE           (0x00000004)
#define NSTYPE_WORKGROUP            (0x00000008)

//
// Transport attributes.
//
#define XP_CONNECTIONLESS           (0x00000001)
#define XP_GUARANTEED_DELIVERY      (0x00000002)
#define XP_GUARANTEED_ORDER         (0x00000004)
#define XP_MESSAGE_ORIENTED         (0x00000008)
#define XP_PSEUDO_STREAM            (0x00000010)
#define XP_GRACEFUL_CLOSE           (0x00000020)
#define XP_EXPEDITED_DATA           (0x00000040)
#define XP_CONNECT_DATA             (0x00000080)
#define XP_DISCONNECT_DATA          (0x00000100)
#define XP_SUPPORTS_BROADCAST       (0x00000200)
#define XP_SUPPORTS_MULTICAST       (0x00000400)
#define XP_BANDWIDTH_ALLOCATION     (0x00000800)
#define XP_FRAGMENTATION            (0x00001000)
#define XP_ENCRYPTS                 (0x00002000)

//
// Resolution flags for GetAddressByName().
//
#define RES_SOFT_SEARCH             (0x00000001)
#define RES_FIND_MULTIPLE           (0x00000002)
#define RES_SERVICE                 (0x00000004)

//
// Well known value names for Service Types
//

#define SERVICE_TYPE_VALUE_SAPIDA        "SapId"
#define SERVICE_TYPE_VALUE_SAPIDW       L"SapId"

#define SERVICE_TYPE_VALUE_CONNA         "ConnectionOriented"
#define SERVICE_TYPE_VALUE_CONNW        L"ConnectionOriented"

#define SERVICE_TYPE_VALUE_TCPPORTA      "TcpPort"
#define SERVICE_TYPE_VALUE_TCPPORTW     L"TcpPort"

#define SERVICE_TYPE_VALUE_UDPPORTA      "UdpPort"
#define SERVICE_TYPE_VALUE_UDPPORTW     L"UdpPort"

#ifdef UNICODE

#define SERVICE_TYPE_VALUE_SAPID        SERVICE_TYPE_VALUE_SAPIDW
#define SERVICE_TYPE_VALUE_CONN         SERVICE_TYPE_VALUE_CONNW
#define SERVICE_TYPE_VALUE_TCPPORT      SERVICE_TYPE_VALUE_TCPPORTW
#define SERVICE_TYPE_VALUE_UDPPORT      SERVICE_TYPE_VALUE_UDPPORTW

#else // not UNICODE

#define SERVICE_TYPE_VALUE_SAPID        SERVICE_TYPE_VALUE_SAPIDA
#define SERVICE_TYPE_VALUE_CONN         SERVICE_TYPE_VALUE_CONNA
#define SERVICE_TYPE_VALUE_TCPPORT      SERVICE_TYPE_VALUE_TCPPORTA
#define SERVICE_TYPE_VALUE_UDPPORT      SERVICE_TYPE_VALUE_UDPPORTA

#endif


//
// status flags returned by SetService
//
#define SET_SERVICE_PARTIAL_SUCCESS  (0x00000001)

//
// Name Space Information
//
typedef struct _NS_INFOA {
    DWORD dwNameSpace ;
    DWORD dwNameSpaceFlags ;
    LPSTR   lpNameSpace ;
} NS_INFOA,  * PNS_INFOA, FAR * LPNS_INFOA;
//
// Name Space Information
//
typedef struct _NS_INFOW {
    DWORD dwNameSpace ;
    DWORD dwNameSpaceFlags ;
    LPWSTR  lpNameSpace ;
} NS_INFOW,  * PNS_INFOW, FAR * LPNS_INFOW;
#ifdef UNICODE
typedef NS_INFOW NS_INFO;
typedef PNS_INFOW PNS_INFO;
typedef LPNS_INFOW LPNS_INFO;
#else
typedef NS_INFOA NS_INFO;
typedef PNS_INFOA PNS_INFO;
typedef LPNS_INFOA LPNS_INFO;
#endif // UNICODE

//
// Service Type Values. The structures are used to define named Service
// Type specific values. This structure is self relative and has no pointers.
//
typedef struct _SERVICE_TYPE_VALUE {
    DWORD dwNameSpace ;
    DWORD dwValueType ;
    DWORD dwValueSize ;
    DWORD dwValueNameOffset ;
    DWORD dwValueOffset ;
} SERVICE_TYPE_VALUE, *PSERVICE_TYPE_VALUE, FAR *LPSERVICE_TYPE_VALUE ;

//
// An absolute version of above. This structure does contain pointers.
//
typedef struct _SERVICE_TYPE_VALUE_ABSA  {
    DWORD dwNameSpace ;
    DWORD dwValueType ;
    DWORD dwValueSize ;
    LPSTR   lpValueName ;
    PVOID lpValue ;
} SERVICE_TYPE_VALUE_ABSA,
  *PSERVICE_TYPE_VALUE_ABSA,
  FAR *LPSERVICE_TYPE_VALUE_ABSA;
//
// An absolute version of above. This structure does contain pointers.
//
typedef struct _SERVICE_TYPE_VALUE_ABSW  {
    DWORD dwNameSpace ;
    DWORD dwValueType ;
    DWORD dwValueSize ;
    LPWSTR  lpValueName ;
    PVOID lpValue ;
} SERVICE_TYPE_VALUE_ABSW,
  *PSERVICE_TYPE_VALUE_ABSW,
  FAR *LPSERVICE_TYPE_VALUE_ABSW;
#ifdef UNICODE
typedef SERVICE_TYPE_VALUE_ABSW SERVICE_TYPE_VALUE_ABS;
typedef PSERVICE_TYPE_VALUE_ABSW PSERVICE_TYPE_VALUE_ABS;
typedef LPSERVICE_TYPE_VALUE_ABSW LPSERVICE_TYPE_VALUE_ABS;
#else
typedef SERVICE_TYPE_VALUE_ABSA SERVICE_TYPE_VALUE_ABS;
typedef PSERVICE_TYPE_VALUE_ABSA PSERVICE_TYPE_VALUE_ABS;
typedef LPSERVICE_TYPE_VALUE_ABSA LPSERVICE_TYPE_VALUE_ABS;
#endif // UNICODE

//
// Service Type Information. Contains the name of the Service Type and
// and an array of SERVICE_NS_TYPE_VALUE structures. This structure is self
// relative and has no pointers in it.
//
typedef struct _SERVICE_TYPE_INFO {
    DWORD dwTypeNameOffset ;
    DWORD dwValueCount ;
    SERVICE_TYPE_VALUE Values[1] ;
} SERVICE_TYPE_INFO, *PSERVICE_TYPE_INFO, FAR *LPSERVICE_TYPE_INFO ;

typedef struct _SERVICE_TYPE_INFO_ABSA {
    LPSTR   lpTypeName ;
    DWORD dwValueCount ;
    SERVICE_TYPE_VALUE_ABSA Values[1] ;
} SERVICE_TYPE_INFO_ABSA,
  *PSERVICE_TYPE_INFO_ABSA,
  FAR *LPSERVICE_TYPE_INFO_ABSA ;
typedef struct _SERVICE_TYPE_INFO_ABSW {
    LPWSTR  lpTypeName ;
    DWORD dwValueCount ;
    SERVICE_TYPE_VALUE_ABSW Values[1] ;
} SERVICE_TYPE_INFO_ABSW,
  *PSERVICE_TYPE_INFO_ABSW,
  FAR *LPSERVICE_TYPE_INFO_ABSW ;
#ifdef UNICODE
typedef SERVICE_TYPE_INFO_ABSW SERVICE_TYPE_INFO_ABS;
typedef PSERVICE_TYPE_INFO_ABSW PSERVICE_TYPE_INFO_ABS;
typedef LPSERVICE_TYPE_INFO_ABSW LPSERVICE_TYPE_INFO_ABS;
#else
typedef SERVICE_TYPE_INFO_ABSA SERVICE_TYPE_INFO_ABS;
typedef PSERVICE_TYPE_INFO_ABSA PSERVICE_TYPE_INFO_ABS;
typedef LPSERVICE_TYPE_INFO_ABSA LPSERVICE_TYPE_INFO_ABS;
#endif // UNICODE


//
// A Single Address definition.
//
typedef struct _SERVICE_ADDRESS {
    DWORD   dwAddressType ;
    DWORD   dwAddressFlags ;
    DWORD   dwAddressLength ;
    DWORD   dwPrincipalLength ;
#ifdef MIDL_PASS
    [size_is(dwAddressLength)] BYTE *lpAddress;
#else  // MIDL_PASS
    BYTE   *lpAddress ;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [size_is(dwPrincipalLength)] BYTE *lpPrincipal;
#else  // MIDL_PASS
    BYTE   *lpPrincipal ;
#endif // MIDL_PASS
} SERVICE_ADDRESS, *PSERVICE_ADDRESS, *LPSERVICE_ADDRESS;

//
// Addresses used by the service. Contains array of SERVICE_ADDRESS.
//
typedef struct _SERVICE_ADDRESSES {
    DWORD           dwAddressCount ;
#ifdef MIDL_PASS
    [size_is(dwAddressCount)] SERVICE_ADDRESS Addressses[*];
#else  // MIDL_PASS
    SERVICE_ADDRESS Addresses[1] ;
#endif // MIDL_PASS
} SERVICE_ADDRESSES, *PSERVICE_ADDRESSES, *LPSERVICE_ADDRESSES;


//
// Service Information.
//
typedef struct _SERVICE_INFOA {
    LPGUID lpServiceType ;
    LPSTR   lpServiceName ;
    LPSTR   lpComment ;
    LPSTR   lpLocale ;
    DWORD dwDisplayHint ;
    DWORD dwVersion ;
    DWORD dwTime ;
    LPSTR   lpMachineName ;
    LPSERVICE_ADDRESSES lpServiceAddress ;
    BLOB ServiceSpecificInfo ;
} SERVICE_INFOA, *PSERVICE_INFOA, FAR * LPSERVICE_INFOA ;
//
// Service Information.
//
typedef struct _SERVICE_INFOW {
    LPGUID lpServiceType ;
    LPWSTR  lpServiceName ;
    LPWSTR  lpComment ;
    LPWSTR  lpLocale ;
    DWORD dwDisplayHint ;
    DWORD dwVersion ;
    DWORD dwTime ;
    LPWSTR  lpMachineName ;
    LPSERVICE_ADDRESSES lpServiceAddress ;
    BLOB ServiceSpecificInfo ;
} SERVICE_INFOW, *PSERVICE_INFOW, FAR * LPSERVICE_INFOW ;
#ifdef UNICODE
typedef SERVICE_INFOW SERVICE_INFO;
typedef PSERVICE_INFOW PSERVICE_INFO;
typedef LPSERVICE_INFOW LPSERVICE_INFO;
#else
typedef SERVICE_INFOA SERVICE_INFO;
typedef PSERVICE_INFOA PSERVICE_INFO;
typedef LPSERVICE_INFOA LPSERVICE_INFO;
#endif // UNICODE


//
// Name Space & Service Information
//
typedef struct _NS_SERVICE_INFOA {
    DWORD dwNameSpace ;
    SERVICE_INFOA ServiceInfo ;
} NS_SERVICE_INFOA, *PNS_SERVICE_INFOA, FAR * LPNS_SERVICE_INFOA ;
//
// Name Space & Service Information
//
typedef struct _NS_SERVICE_INFOW {
    DWORD dwNameSpace ;
    SERVICE_INFOW ServiceInfo ;
} NS_SERVICE_INFOW, *PNS_SERVICE_INFOW, FAR * LPNS_SERVICE_INFOW ;
#ifdef UNICODE
typedef NS_SERVICE_INFOW NS_SERVICE_INFO;
typedef PNS_SERVICE_INFOW PNS_SERVICE_INFO;
typedef LPNS_SERVICE_INFOW LPNS_SERVICE_INFO;
#else
typedef NS_SERVICE_INFOA NS_SERVICE_INFO;
typedef PNS_SERVICE_INFOA PNS_SERVICE_INFO;
typedef LPNS_SERVICE_INFOA LPNS_SERVICE_INFO;
#endif // UNICODE

#ifndef __CSADDR_DEFINED__
#define __CSADDR_DEFINED__

//
// SockAddr Information
//
typedef struct _SOCKET_ADDRESS {
    LPSOCKADDR lpSockaddr ;
    INT iSockaddrLength ;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, FAR * LPSOCKET_ADDRESS ;

//
// CSAddr Information
//
typedef struct _CSADDR_INFO {
    SOCKET_ADDRESS LocalAddr ;
    SOCKET_ADDRESS RemoteAddr ;
    INT iSocketType ;
    INT iProtocol ;
} CSADDR_INFO, *PCSADDR_INFO, FAR * LPCSADDR_INFO ;

#endif

//
// Protocol Information
//
typedef struct _PROTOCOL_INFOA {
    DWORD dwServiceFlags ;
    INT iAddressFamily ;
    INT iMaxSockAddr ;
    INT iMinSockAddr ;
    INT iSocketType ;
    INT iProtocol ;
    DWORD dwMessageSize ;
    LPSTR   lpProtocol ;
} PROTOCOL_INFOA, *PPROTOCOL_INFOA, FAR * LPPROTOCOL_INFOA ;
//
// Protocol Information
//
typedef struct _PROTOCOL_INFOW {
    DWORD dwServiceFlags ;
    INT iAddressFamily ;
    INT iMaxSockAddr ;
    INT iMinSockAddr ;
    INT iSocketType ;
    INT iProtocol ;
    DWORD dwMessageSize ;
    LPWSTR  lpProtocol ;
} PROTOCOL_INFOW, *PPROTOCOL_INFOW, FAR * LPPROTOCOL_INFOW ;
#ifdef UNICODE
typedef PROTOCOL_INFOW PROTOCOL_INFO;
typedef PPROTOCOL_INFOW PPROTOCOL_INFO;
typedef LPPROTOCOL_INFOW LPPROTOCOL_INFO;
#else
typedef PROTOCOL_INFOA PROTOCOL_INFO;
typedef PPROTOCOL_INFOA PPROTOCOL_INFO;
typedef LPPROTOCOL_INFOA LPPROTOCOL_INFO;
#endif // UNICODE

//
// NETRESOURCE2 Structure
//
typedef struct _NETRESOURCE2A {
    DWORD dwScope ;
    DWORD dwType ;
    DWORD dwUsage ;
    DWORD dwDisplayType ;
    LPSTR   lpLocalName ;
    LPSTR   lpRemoteName ;
    LPSTR   lpComment ;
    NS_INFO ns_info ;
    GUID ServiceType ;
    DWORD dwProtocols ;
    LPINT lpiProtocols ;
} NETRESOURCE2A, *PNETRESOURCE2A, FAR * LPNETRESOURCE2A ;
//
// NETRESOURCE2 Structure
//
typedef struct _NETRESOURCE2W {
    DWORD dwScope ;
    DWORD dwType ;
    DWORD dwUsage ;
    DWORD dwDisplayType ;
    LPWSTR  lpLocalName ;
    LPWSTR  lpRemoteName ;
    LPWSTR  lpComment ;
    NS_INFO ns_info ;
    GUID ServiceType ;
    DWORD dwProtocols ;
    LPINT lpiProtocols ;
} NETRESOURCE2W, *PNETRESOURCE2W, FAR * LPNETRESOURCE2W ;
#ifdef UNICODE
typedef NETRESOURCE2W NETRESOURCE2;
typedef PNETRESOURCE2W PNETRESOURCE2;
typedef LPNETRESOURCE2W LPNETRESOURCE2;
#else
typedef NETRESOURCE2A NETRESOURCE2;
typedef PNETRESOURCE2A PNETRESOURCE2;
typedef LPNETRESOURCE2A LPNETRESOURCE2;
#endif // UNICODE

typedef  DWORD (* LPFN_NSPAPI) (VOID ) ;

//
// Structures for using the service routines asynchronously.
//
typedef
VOID
(*LPSERVICE_CALLBACK_PROC) (
    __in LPARAM lParam,
    __in HANDLE hAsyncTaskHandle
    );

typedef struct _SERVICE_ASYNC_INFO {
    LPSERVICE_CALLBACK_PROC lpServiceCallbackProc;
    LPARAM lParam;
    HANDLE hAsyncTaskHandle;
} SERVICE_ASYNC_INFO, *PSERVICE_ASYNC_INFO, FAR * LPSERVICE_ASYNC_INFO;

//
// Public NSP API prototypes.
//
INT
APIENTRY
EnumProtocolsA (
    __in_opt LPINT           lpiProtocols,
    __out_bcount(*lpdwBufferLength)    LPVOID          lpProtocolBuffer,
    __inout  LPDWORD         lpdwBufferLength
    );
//
// Public NSP API prototypes.
//
INT
APIENTRY
EnumProtocolsW (
    __in_opt LPINT           lpiProtocols,
    __out_bcount(*lpdwBufferLength)    LPVOID          lpProtocolBuffer,
    __inout  LPDWORD         lpdwBufferLength
    );
#ifdef UNICODE
#define EnumProtocols  EnumProtocolsW
#else
#define EnumProtocols  EnumProtocolsA
#endif // !UNICODE

INT
APIENTRY
GetAddressByNameA (
    __in     DWORD                dwNameSpace,
    __in     LPGUID               lpServiceType,
    __in_opt LPSTR                lpServiceName,
    __in_opt LPINT                lpiProtocols,
    __in     DWORD                dwResolution,
    __in_opt LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,
    __out_bcount(*lpdwBufferLength)    LPVOID               lpCsaddrBuffer,
    __inout  LPDWORD              lpdwBufferLength,
    __inout_bcount_opt(*lpdwAliasBufferLength) LPSTR  lpAliasBuffer,
    __inout LPDWORD               lpdwAliasBufferLength
    );
INT
APIENTRY
GetAddressByNameW (
    __in     DWORD                dwNameSpace,
    __in     LPGUID               lpServiceType,
    __in_opt LPWSTR               lpServiceName,
    __in_opt LPINT                lpiProtocols,
    __in     DWORD                dwResolution,
    __in_opt LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,
    __out_bcount(*lpdwBufferLength)    LPVOID               lpCsaddrBuffer,
    __inout  LPDWORD              lpdwBufferLength,
    __inout_ecount_opt(*lpdwAliasBufferLength) LPWSTR  lpAliasBuffer,
    __inout LPDWORD             lpdwAliasBufferLength
    );
#ifdef UNICODE
#define GetAddressByName  GetAddressByNameW
#else
#define GetAddressByName  GetAddressByNameA
#endif // !UNICODE

INT
APIENTRY
GetTypeByNameA (
    __in    LPSTR         lpServiceName,
    __inout LPGUID        lpServiceType
    );
INT
APIENTRY
GetTypeByNameW (
    __in    LPWSTR         lpServiceName,
    __inout LPGUID         lpServiceType
    );
#ifdef UNICODE
#define GetTypeByName  GetTypeByNameW
#else
#define GetTypeByName  GetTypeByNameA
#endif // !UNICODE

INT
APIENTRY
GetNameByTypeA (
    __in   LPGUID          lpServiceType,
    __out_bcount(dwNameLength) LPSTR         lpServiceName,
    __in   DWORD           dwNameLength
    );
INT
APIENTRY
GetNameByTypeW (
    __in   LPGUID          lpServiceType,
    __out_bcount(dwNameLength) LPWSTR         lpServiceName,
    __in   DWORD           dwNameLength
    );
#ifdef UNICODE
#define GetNameByType  GetNameByTypeW
#else
#define GetNameByType  GetNameByTypeA
#endif // !UNICODE

INT
APIENTRY
SetServiceA (
    __in     DWORD                dwNameSpace,
    __in     DWORD                dwOperation,
    __in     DWORD                dwFlags,
    __in     LPSERVICE_INFOA      lpServiceInfo,
    __in_opt LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,
    __out    LPDWORD              lpdwStatusFlags
    );
INT
APIENTRY
SetServiceW (
    __in     DWORD                dwNameSpace,
    __in     DWORD                dwOperation,
    __in     DWORD                dwFlags,
    __in     LPSERVICE_INFOW      lpServiceInfo,
    __in_opt LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,
    __out    LPDWORD              lpdwStatusFlags
    );
#ifdef UNICODE
#define SetService  SetServiceW
#else
#define SetService  SetServiceA
#endif // !UNICODE

INT
APIENTRY
GetServiceA (
    __in     DWORD                dwNameSpace,
    __in     LPGUID               lpGuid,
    __in     LPSTR                lpServiceName,
    __in     DWORD                dwProperties,
    __out_bcount(*lpdwBufferSize)  LPVOID               lpBuffer,
    __inout  LPDWORD              lpdwBufferSize,
    __in_opt LPSERVICE_ASYNC_INFO lpServiceAsyncInfo
    );
INT
APIENTRY
GetServiceW (
    __in     DWORD                dwNameSpace,
    __in     LPGUID               lpGuid,
    __in     LPWSTR               lpServiceName,
    __in     DWORD                dwProperties,
    __out_bcount(*lpdwBufferSize) LPVOID               lpBuffer,
    __inout  LPDWORD              lpdwBufferSize,
    __in_opt LPSERVICE_ASYNC_INFO lpServiceAsyncInfo
    );
#ifdef UNICODE
#define GetService  GetServiceW
#else
#define GetService  GetServiceA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  // _NSPAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\ntddscsi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddscsi.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the SCSI port adapters.

--*/


//
// Interface GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddscsi.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddscsi.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

DEFINE_GUID(ScsiRawInterfaceGuid, 0x53f56309L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(WmiScsiAddressGuid,   0x53f5630fL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
#endif

#ifndef _NTDDSCSIH_
#define _NTDDSCSIH_

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER
#define FILE_DEVICE_SCSI                0x0000001b

#define DD_SCSI_DEVICE_NAME "\\Device\\ScsiPort"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_SCSI_PASS_THROUGH         CTL_CODE(IOCTL_SCSI_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_MINIPORT             CTL_CODE(IOCTL_SCSI_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_GET_INQUIRY_DATA     CTL_CODE(IOCTL_SCSI_BASE, 0x0403, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_GET_CAPABILITIES     CTL_CODE(IOCTL_SCSI_BASE, 0x0404, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_PASS_THROUGH_DIRECT  CTL_CODE(IOCTL_SCSI_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_GET_ADDRESS          CTL_CODE(IOCTL_SCSI_BASE, 0x0406, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_RESCAN_BUS           CTL_CODE(IOCTL_SCSI_BASE, 0x0407, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_GET_DUMP_POINTERS    CTL_CODE(IOCTL_SCSI_BASE, 0x0408, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_FREE_DUMP_POINTERS   CTL_CODE(IOCTL_SCSI_BASE, 0x0409, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IDE_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ATA_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ATA_PASS_THROUGH_DIRECT   CTL_CODE(IOCTL_SCSI_BASE, 0x040c, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ATA_MINIPORT              CTL_CODE(IOCTL_SCSI_BASE, 0x040d, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MINIPORT_PROCESS_SERVICE_IRP CTL_CODE(IOCTL_SCSI_BASE,  0x040e, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MPIO_PASS_THROUGH_PATH    CTL_CODE(IOCTL_SCSI_BASE, 0x040f, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MPIO_PASS_THROUGH_PATH_DIRECT CTL_CODE(IOCTL_SCSI_BASE, 0x0410, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Non Volatile Cache support
//

#define IOCTL_SCSI_MINIPORT_NVCACHE           ((FILE_DEVICE_SCSI << 16) + 0x0600)

//
// Define the SCSI pass through structure.
//

typedef struct _SCSI_PASS_THROUGH {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG_PTR DataBufferOffset;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH, *PSCSI_PASS_THROUGH;

//
// Define the SCSI pass through direct structure.
//

typedef struct _SCSI_PASS_THROUGH_DIRECT {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    PVOID DataBuffer;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH_DIRECT, *PSCSI_PASS_THROUGH_DIRECT;


//
// Define the SCSI pass through direct structure for Win64 (thunking).
//
#if defined(_WIN64)
typedef struct _SCSI_PASS_THROUGH32 {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG32 DataBufferOffset;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH32, *PSCSI_PASS_THROUGH32;

//
// Define the SCSI pass through direct structure.
//

typedef struct _SCSI_PASS_THROUGH_DIRECT32 {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    VOID * POINTER_32 DataBuffer;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH_DIRECT32, *PSCSI_PASS_THROUGH_DIRECT32;

#endif

//
// ATA pass through structure
//

typedef struct _ATA_PASS_THROUGH_EX {
    USHORT Length;
    USHORT AtaFlags;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR ReservedAsUchar;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG ReservedAsUlong;
    ULONG_PTR DataBufferOffset;
    UCHAR PreviousTaskFile[8];
    UCHAR CurrentTaskFile[8];
} ATA_PASS_THROUGH_EX, *PATA_PASS_THROUGH_EX;

//
// ATA pass through direct structure.
//

typedef struct _ATA_PASS_THROUGH_DIRECT {
    USHORT Length;
    USHORT AtaFlags;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR ReservedAsUchar;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG ReservedAsUlong;
    PVOID DataBuffer;
    UCHAR PreviousTaskFile[8];
    UCHAR CurrentTaskFile[8];
} ATA_PASS_THROUGH_DIRECT, *PATA_PASS_THROUGH_DIRECT;

//
// Define the ATA pass through direct structure for Win64 (thunking).
//
#if defined(_WIN64)

typedef struct _ATA_PASS_THROUGH_EX32 {
    USHORT Length;
    USHORT AtaFlags;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR ReservedAsUchar;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG ReservedAsUlong;
    ULONG32 DataBufferOffset;
    UCHAR PreviousTaskFile[8];
    UCHAR CurrentTaskFile[8];
} ATA_PASS_THROUGH_EX32, *PATA_PASS_THROUGH_EX32;

//
// ATA pass through direct structure.
//

typedef struct _ATA_PASS_THROUGH_DIRECT32 {
    USHORT Length;
    USHORT AtaFlags;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR ReservedAsUchar;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG ReservedAsUlong;
    VOID * POINTER_32 DataBuffer;
    UCHAR PreviousTaskFile[8];
    UCHAR CurrentTaskFile[8];
} ATA_PASS_THROUGH_DIRECT32, *PATA_PASS_THROUGH_DIRECT32;
#endif

//
// ATA Pass Through Flags
//
#define ATA_FLAGS_DRDY_REQUIRED         (1 << 0)
#define ATA_FLAGS_DATA_IN               (1 << 1)
#define ATA_FLAGS_DATA_OUT              (1 << 2)
#define ATA_FLAGS_48BIT_COMMAND         (1 << 3)
#define ATA_FLAGS_USE_DMA               (1 << 4)
#define ATA_FLAGS_NO_MULTIPLE           (1 << 5)

//
// Define header for IOCTL_ATA_MINIPORT
//

typedef struct _IDE_IO_CONTROL {
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnStatus;
        ULONG DataLength;
} IDE_IO_CONTROL, *PIDE_IO_CONTROL;

//
// Define the structure for IOCTL_MPIO_PASS_THROUGH_PATH.
//

typedef struct _MPIO_PASS_THROUGH_PATH {
        SCSI_PASS_THROUGH PassThrough;
        ULONG   Version;
        USHORT  Length;
        UCHAR   Flags;
        UCHAR   PortNumber;
        ULONGLONG MpioPathId;
} MPIO_PASS_THROUGH_PATH, *PMPIO_PASS_THROUGH_PATH;

//
// Define the structure for IOCTL_MPIO_PASS_THROUGH_PATH_DIRECT.
//

typedef struct _MPIO_PASS_THROUGH_PATH_DIRECT {
        SCSI_PASS_THROUGH_DIRECT PassThrough;
        ULONG   Version;
        USHORT  Length;
        UCHAR   Flags;
        UCHAR   PortNumber;
        ULONGLONG MpioPathId;
} MPIO_PASS_THROUGH_PATH_DIRECT, *PMPIO_PASS_THROUGH_PATH_DIRECT;


//
// Define the IOCTL_MPIO_PASS_THROUGH_PATH structure for Win64 (thunking).
//

#if defined(_WIN64)
typedef struct _MPIO_PASS_THROUGH_PATH32 {
        SCSI_PASS_THROUGH32 PassThrough;
        ULONG   Version;
        USHORT  Length;
        UCHAR   Flags;
        UCHAR   PortNumber;
        ULONGLONG MpioPathId;
} MPIO_PASS_THROUGH_PATH32, *PMPIO_PASS_THROUGH_PATH32;

//
// Define the IOCTL_MPIO_PASS_THROUGH_PATH_DIRECT structure for Win64 (thunking).
//

typedef struct _MPIO_PASS_THROUGH_PATH_DIRECT32 {
        SCSI_PASS_THROUGH_DIRECT32 PassThrough;
        ULONG   Version;
        USHORT  Length;
        UCHAR   Flags;
        UCHAR   PortNumber;
        ULONGLONG MpioPathId;
} MPIO_PASS_THROUGH_PATH_DIRECT32, *PMPIO_PASS_THROUGH_PATH_DIRECT32;

#endif

//
// Define SCSI information.
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_BUS_DATA {
    UCHAR NumberOfLogicalUnits;
    UCHAR InitiatorBusId;
    ULONG InquiryDataOffset;
}SCSI_BUS_DATA, *PSCSI_BUS_DATA;

//
// Define SCSI adapter bus information structure..
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_ADAPTER_BUS_INFO {
    UCHAR NumberOfBuses;
    SCSI_BUS_DATA BusData[1];
} SCSI_ADAPTER_BUS_INFO, *PSCSI_ADAPTER_BUS_INFO;

//
// Define SCSI adapter bus information.
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_INQUIRY_DATA {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    ULONG InquiryDataLength;
    ULONG NextInquiryDataOffset;
    UCHAR InquiryData[1];
}SCSI_INQUIRY_DATA, *PSCSI_INQUIRY_DATA;

//
// Define header for I/O control SRB.
//

typedef struct _SRB_IO_CONTROL {
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;

typedef struct _NVCACHE_REQUEST_BLOCK {
    ULONG           NRBSize;
    USHORT          Function;
    ULONG           NRBFlags;
    ULONG           NRBStatus;
    ULONG           Count;
    ULONGLONG       LBA;
    ULONG           DataBufSize;
    ULONG           NVCacheStatus;
    ULONG           NVCacheSubStatus;
} NVCACHE_REQUEST_BLOCK, *PNVCACHE_REQUEST_BLOCK;

#define NRB_FUNCTION_NVCACHE_INFO               0xEC
#define NRB_FUNCTION_SPINDLE_STATUS                 0xE5
#define NRB_FUNCTION_NVCACHE_POWER_MODE_SET         0x00
#define NRB_FUNCTION_NVCACHE_POWER_MODE_RETURN  0x01
#define NRB_FUNCTION_FLUSH_NVCACHE              0x14
#define NRB_FUNCTION_QUERY_PINNED_SET           0x12
#define NRB_FUNCTION_QUERY_CACHE_MISS           0x13
#define NRB_FUNCTION_ADD_LBAS_PINNED_SET        0x10
#define NRB_FUNCTION_REMOVE_LBAS_PINNED_SET     0x11
#define NRB_FUNCTION_QUERY_ASCENDER_STATUS      0xD0
#define NRB_FUNCTION_QUERY_HYBRID_DISK_STATUS   0xD1

#define NRB_SUCCESS                             0
#define NRB_ILLEGAL_REQUEST                     1
#define NRB_INVALID_PARAMETER                   2
#define NRB_INPUT_DATA_OVERRUN                  3
#define NRB_INPUT_DATA_UNDERRUN                 4
#define NRB_OUTPUT_DATA_OVERRUN                 5
#define NRB_OUTPUT_DATA_UNDERRUN                6

typedef struct _NV_FEATURE_PARAMETER{
        USHORT NVPowerModeEnabled;
        USHORT NVParameterReserv1;
        USHORT NVCmdEnabled;
        USHORT NVParameterReserv2;
        USHORT NVPowerModeVer;
        USHORT NVCmdVer;
        ULONG  NVSize;               // in number of LBA
        USHORT NVReadSpeed;          // in MB/s
        USHORT NVWrtSpeed;
        ULONG  DeviceSpinUpTime;             // in second
} NV_FEATURE_PARAMETER, *PNV_FEATURE_PARAMETER;

//
// SCSI port driver capabilities structure.
//

typedef struct _IO_SCSI_CAPABILITIES {

    //
    // Length of this structure
    //

    ULONG Length;

    //
    // Maximum transfer size in single SRB
    //

    ULONG MaximumTransferLength;

    //
    // Maximum number of physical pages per data buffer
    //

    ULONG MaximumPhysicalPages;

    //
    // Async calls from port to class
    //

    ULONG SupportedAsynchronousEvents;

    //
    // Alignment mask for data transfers.
    //

    ULONG AlignmentMask;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Host adapter scans down for bios devices.
    //

    BOOLEAN AdapterScansDown;

    //
    // The host adapter uses programmed I/O.
    //

    BOOLEAN AdapterUsesPio;

} IO_SCSI_CAPABILITIES, *PIO_SCSI_CAPABILITIES;

typedef struct _SCSI_ADDRESS {
    ULONG Length;
    UCHAR PortNumber;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
}SCSI_ADDRESS, *PSCSI_ADDRESS;

//
// Define structure for returning crash dump pointers.
//

struct _ADAPTER_OBJECT;
#define DUMP_POINTERS_VERSION_1         1
#define DUMP_POINTERS_VERSION_2         2
#define DUMP_DRIVER_NAME_LENGTH         15

typedef struct _DUMP_POINTERS_VERSION {
    //
    // Dump pointers structure version
    //
    ULONG Version;

    //
    // Dump pointers structure size
    //
    ULONG Size;

} DUMP_POINTERS_VERSION, *PDUMP_POINTERS_VERSION;

typedef struct _DUMP_POINTERS {
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID DumpData;
    PVOID CommonBufferVa;
    LARGE_INTEGER CommonBufferPa;
    ULONG CommonBufferSize;
    BOOLEAN AllocateCommonBuffers;
#if (NTDDI_VERSION < NTDDI_WINXP)
    UCHAR Spare1[3];
#else
    BOOLEAN UseDiskDump;
    UCHAR Spare1[2];
#endif
    PVOID DeviceObject;
} DUMP_POINTERS, *PDUMP_POINTERS;

typedef struct _DUMP_POINTERS_EX {
    DUMP_POINTERS_VERSION Header;
    PVOID DumpData;
    PVOID CommonBufferVa;
    ULONG CommonBufferSize;
    BOOLEAN AllocateCommonBuffers;
    PVOID DeviceObject;
    PVOID DriverList;
} DUMP_POINTERS_EX, *PDUMP_POINTERS_EX;

typedef struct _DUMP_DRIVER {

    //
    // Dump driver list from port driver
    //
    PVOID DumpDriverList;

    //
    // Name of the driver to be loaded
    //
    WCHAR DriverName[DUMP_DRIVER_NAME_LENGTH];

    //
    // Driver base name
    //
    WCHAR BaseName[DUMP_DRIVER_NAME_LENGTH];

} DUMP_DRIVER, *PDUMP_DRIVER;


//
// Define values for pass-through DataIn field.
//

#define SCSI_IOCTL_DATA_OUT          0
#define SCSI_IOCTL_DATA_IN           1
#define SCSI_IOCTL_DATA_UNSPECIFIED  2

//
// Define values for MPIO-pass-through-path Flags field.
//

#define MPIO_IOCTL_FLAG_USE_PATHID      1
#define MPIO_IOCTL_FLAG_USE_SCSIADDRESS 2
#define MPIO_IOCTL_FLAG_INVOLVE_DSM     4

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\NtDsBMsg.h ===
/*
 *	NTDSBMSG.H
 *
 *	Windows NT Directory Service Backup/Restore API error codes
 *	Copyright (C) 1996-1998, Microsoft Corporation
 *	
 */

#ifndef _NTDSBMSG_
#define _NTDSBMSG_

//
//	SUCCESS
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_NTDSB                   0x800
#define FACILITY_BACKUP                  0x7FF


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: hrNone
//
// MessageText:
//
// The operation was successful
//
#define hrNone                           ((HRESULT)0x00000000L)

//
//	ERRORS
//
//
// MessageId: hrNyi
//
// MessageText:
//
// The function is not yet implemented
//
#define hrNyi                            ((HRESULT)0xC0000001L)

//
//	Backup errors
//
//
// MessageId: hrInvalidParam
//
// MessageText:
//
// The parameter is not valid.
//
#define hrInvalidParam                   ((HRESULT)0xC7FF0001L)

//
// MessageId: hrError
//
// MessageText:
//
// An internal error has occurred.
//
#define hrError                          ((HRESULT)0xC7FF0002L)

//
// MessageId: hrInvalidHandle
//
// MessageText:
//
// The handle is not valid.
//
#define hrInvalidHandle                  ((HRESULT)0xC7FF0003L)

//
// MessageId: hrRestoreInProgress
//
// MessageText:
//
// The Restore process is already in progress.
//
#define hrRestoreInProgress              ((HRESULT)0xC7FF0004L)

//
// MessageId: hrAlreadyOpen
//
// MessageText:
//
// The file specified is already open.
//
#define hrAlreadyOpen                    ((HRESULT)0xC7FF0005L)

//
// MessageId: hrInvalidRecips
//
// MessageText:
//
// The recipients are invalid.
//
#define hrInvalidRecips                  ((HRESULT)0xC7FF0006L)

//
// MessageId: hrCouldNotConnect
//
// MessageText:
//
// Unable to perform the backup. Either you are not connected to the specified backup server
// or the service you are trying to backup is not running.
//
#define hrCouldNotConnect                ((HRESULT)0xC7FF0007L)

//
// MessageId: hrRestoreMapExists
//
// MessageText:
//
// A restore map already exists for the specified component.  You can only specify
// a restore map when performing a full restore.
//
#define hrRestoreMapExists               ((HRESULT)0xC7FF0008L)

//
// MessageId: hrIncrementalBackupDisabled
//
// MessageText:
//
// Another application has modified the specified Windows NT Directory Service database such that any
// subsequent backups will fail. You must perform a full backup to fix this problem.
//
#define hrIncrementalBackupDisabled      ((HRESULT)0xC7FF0009L)

//
// MessageId: hrLogFileNotFound
//
// MessageText:
//
// Unable to perform an incremental backup because a required Windows NT Directory Service database log file could not be found.
//
#define hrLogFileNotFound                ((HRESULT)0xC7FF000AL)

//
// MessageId: hrCircularLogging
//
// MessageText:
//
// The Windows NT Directory Service component specified is configured to use circular database logs.
// It cannot be backed up without a full backup.
//
#define hrCircularLogging                ((HRESULT)0xC7FF000BL)

//
// MessageId: hrNoFullRestore
//
// MessageText:
//
// The databases have not been restored to this machine. You cannot restore an incremental backup
// until a full backup has been restored.
//
#define hrNoFullRestore                  ((HRESULT)0xC7FF000CL)

//
// MessageId: hrCommunicationError
//
// MessageText:
//
// A communications error occurred while attempting to perform a local backup.
//
#define hrCommunicationError             ((HRESULT)0xC7FF000DL)

//
// MessageId: hrFullBackupNotTaken
//
// MessageText:
//
// You must perform a full backup before you can perform an incremental backup.
//
#define hrFullBackupNotTaken             ((HRESULT)0xC7FF000EL)

//
// MessageId: hrMissingExpiryToken
//
// MessageText:
//
// Expiry token is missing. Cannot restore without knowing the expiry information.
//
#define hrMissingExpiryToken             ((HRESULT)0xC7FF000FL)

//
// MessageId: hrUnknownExpiryTokenFormat
//
// MessageText:
//
// Expiry token is in unrecognizable format.
//
#define hrUnknownExpiryTokenFormat       ((HRESULT)0xC7FF0010L)

//
// MessageId: hrContentsExpired
//
// MessageText:
//
// DS Contents in the backup copy are out of date. Try restoring with a more recent copy.
//
#define hrContentsExpired                ((HRESULT)0xC7FF0011L)

#define	hrAlreadyListening	((HRESULT)RPC_S_ALREADY_LISTENING)
//
//	ERRORS
//
//
// SYSTEM errors
//
//
// MessageId: hrFileClose
//
// MessageText:
//
// Unable to close the DOS file
//
#define hrFileClose                      ((HRESULT)0xC8000066L)

//
// MessageId: hrOutOfThreads
//
// MessageText:
//
// Unable to start a thread because there are none available.
//
#define hrOutOfThreads                   ((HRESULT)0xC8000067L)

//
// MessageId: hrTooManyIO
//
// MessageText:
//
// The system is busy because there are too many I/Os.
//
#define hrTooManyIO                      ((HRESULT)0xC8000069L)

//
//	BUFFER MANAGER errors
//
//
// MessageId: hrBFNotSynchronous
//
// MessageText:
//
// The buffer page has been evicted.
//
#define hrBFNotSynchronous               ((HRESULT)0x880000C8L)

//
// MessageId: hrBFPageNotFound
//
// MessageText:
//
// Unable to find the page.
//
#define hrBFPageNotFound                 ((HRESULT)0x880000C9L)

//
// MessageId: hrBFInUse
//
// MessageText:
//
// Unable to abandon the buffer.
//
#define hrBFInUse                        ((HRESULT)0xC80000CAL)

//
//	DIRECTORY MANAGER errors
//
//
// MessageId: hrPMRecDeleted
//
// MessageText:
//
// The record has been deleted.
//
#define hrPMRecDeleted                   ((HRESULT)0xC800012EL)

//
// MessageId: hrRemainingVersions
//
// MessageText:
//
// There is idle work remaining.
//
#define hrRemainingVersions              ((HRESULT)0x88000141L)

//
//	RECORD MANAGER errors
//
//
// MessageId: hrFLDKeyTooBig
//
// MessageText:
//
// The key was truncated because it exceeded the maximum length.
//
#define hrFLDKeyTooBig                   ((HRESULT)0x88000190L)

//
// MessageId: hrFLDTooManySegments
//
// MessageText:
//
// There are too many key segments.
//
#define hrFLDTooManySegments             ((HRESULT)0xC8000191L)

//
// MessageId: hrFLDNullKey
//
// MessageText:
//
// The key is NULL.
//
#define hrFLDNullKey                     ((HRESULT)0x88000192L)

//
//	LOGGING/RECOVERY errors
//
//
// MessageId: hrLogFileCorrupt
//
// MessageText:
//
// The log file is damaged.
//
#define hrLogFileCorrupt                 ((HRESULT)0xC80001F5L)

//
// MessageId: hrNoBackupDirectory
//
// MessageText:
//
// No backup directory was given.
//
#define hrNoBackupDirectory              ((HRESULT)0xC80001F7L)

//
// MessageId: hrBackupDirectoryNotEmpty
//
// MessageText:
//
// The backup directory is not empty.
//
#define hrBackupDirectoryNotEmpty        ((HRESULT)0xC80001F8L)

//
// MessageId: hrBackupInProgress
//
// MessageText:
//
// Backup is already active.
//
#define hrBackupInProgress               ((HRESULT)0xC80001F9L)

//
// MessageId: hrMissingPreviousLogFile
//
// MessageText:
//
// A log file for the checkpoint is missing.
//
#define hrMissingPreviousLogFile         ((HRESULT)0xC80001FDL)

//
// MessageId: hrLogWriteFail
//
// MessageText:
//
// Unable to write to the log file.
//
#define hrLogWriteFail                   ((HRESULT)0xC80001FEL)

//
// MessageId: hrBadLogVersion
//
// MessageText:
//
// The version of the log file is not compatible with the version of the Windows NT Directory Service database (NTDS).
//
#define hrBadLogVersion                  ((HRESULT)0xC8000202L)

//
// MessageId: hrInvalidLogSequence
//
// MessageText:
//
// The time stamp in the next log does not match what was expected.
//
#define hrInvalidLogSequence             ((HRESULT)0xC8000203L)

//
// MessageId: hrLoggingDisabled
//
// MessageText:
//
// The log is not active.
//
#define hrLoggingDisabled                ((HRESULT)0xC8000204L)

//
// MessageId: hrLogBufferTooSmall
//
// MessageText:
//
// The log buffer is too small to be recovered.
//
#define hrLogBufferTooSmall              ((HRESULT)0xC8000205L)

//
// MessageId: hrLogSequenceEnd
//
// MessageText:
//
// The maximum number of log files has been exceeded.
//
#define hrLogSequenceEnd                 ((HRESULT)0xC8000207L)

//
// MessageId: hrNoBackup
//
// MessageText:
//
// There is no backup in progress.
//
#define hrNoBackup                       ((HRESULT)0xC8000208L)

//
// MessageId: hrInvalidBackupSequence
//
// MessageText:
//
// The backup call is out of sequence.
//
#define hrInvalidBackupSequence          ((HRESULT)0xC8000209L)

//
// MessageId: hrBackupNotAllowedYet
//
// MessageText:
//
// Unable to perform a backup now.
//
#define hrBackupNotAllowedYet            ((HRESULT)0xC800020BL)

//
// MessageId: hrDeleteBackupFileFail
//
// MessageText:
//
// Unable to delete the backup file.
//
#define hrDeleteBackupFileFail           ((HRESULT)0xC800020CL)

//
// MessageId: hrMakeBackupDirectoryFail
//
// MessageText:
//
// Unable to make a backup temporary directory.
//
#define hrMakeBackupDirectoryFail        ((HRESULT)0xC800020DL)

//
// MessageId: hrInvalidBackup
//
// MessageText:
//
// An incremental backup cannot be performed when circular logging is enabled.
//
#define hrInvalidBackup                  ((HRESULT)0xC800020EL)

//
// MessageId: hrRecoveredWithErrors
//
// MessageText:
//
// Errors were encountered during the repair process.
//
#define hrRecoveredWithErrors            ((HRESULT)0xC800020FL)

//
// MessageId: hrMissingLogFile
//
// MessageText:
//
// The current log file is missing.
//
#define hrMissingLogFile                 ((HRESULT)0xC8000210L)

//
// MessageId: hrLogDiskFull
//
// MessageText:
//
// The log disk is full.
//
#define hrLogDiskFull                    ((HRESULT)0xC8000211L)

//
// MessageId: hrBadLogSignature
//
// MessageText:
//
// A log file is damaged.
//
#define hrBadLogSignature                ((HRESULT)0xC8000212L)

//
// MessageId: hrBadDbSignature
//
// MessageText:
//
// A database file is damaged.
//
#define hrBadDbSignature                 ((HRESULT)0xC8000213L)

//
// MessageId: hrBadCheckpointSignature
//
// MessageText:
//
// A checkpoint file is damaged.
//
#define hrBadCheckpointSignature         ((HRESULT)0xC8000214L)

//
// MessageId: hrCheckpointCorrupt
//
// MessageText:
//
// A checkpoint file either could not be found or is damaged.
//
#define hrCheckpointCorrupt              ((HRESULT)0xC8000215L)

//
// MessageId: hrDatabaseInconsistent
//
// MessageText:
//
// The database is damaged.
//
#define hrDatabaseInconsistent           ((HRESULT)0xC8000226L)

//
// MessageId: hrConsistentTimeMismatch
//
// MessageText:
//
// There is a mismatch in the database's last consistent time.
//
#define hrConsistentTimeMismatch         ((HRESULT)0xC8000227L)

//
// MessageId: hrPatchFileMismatch
//
// MessageText:
//
// The patch file is not generated from this backup.
//
#define hrPatchFileMismatch              ((HRESULT)0xC8000228L)

//
// MessageId: hrRestoreLogTooLow
//
// MessageText:
//
// The starting log number is too low for the restore.
//
#define hrRestoreLogTooLow               ((HRESULT)0xC8000229L)

//
// MessageId: hrRestoreLogTooHigh
//
// MessageText:
//
// The starting log number is too high for the restore.
//
#define hrRestoreLogTooHigh              ((HRESULT)0xC800022AL)

//
// MessageId: hrGivenLogFileHasBadSignature
//
// MessageText:
//
// The log file downloaded from the tape is damaged.
//
#define hrGivenLogFileHasBadSignature    ((HRESULT)0xC800022BL)

//
// MessageId: hrGivenLogFileIsNotContiguous
//
// MessageText:
//
// Unable to find a mandatory log file after the tape was downloaded.
//
#define hrGivenLogFileIsNotContiguous    ((HRESULT)0xC800022CL)

//
// MessageId: hrMissingRestoreLogFiles
//
// MessageText:
//
// The data is not fully restored because some log files are missing.
//
#define hrMissingRestoreLogFiles         ((HRESULT)0xC800022DL)

//
// MessageId: hrExistingLogFileHasBadSignature
//
// MessageText:
//
// The log file in the log file path is damaged.
//
#define hrExistingLogFileHasBadSignature ((HRESULT)0x8800022EL)

//
// MessageId: hrExistingLogFileIsNotContiguous
//
// MessageText:
//
// Unable to find a mandatory log file in the log file path.
//
#define hrExistingLogFileIsNotContiguous ((HRESULT)0x8800022FL)

//
// MessageId: hrMissingFullBackup
//
// MessageText:
//
// The database missed a previous full backup before the incremental backup.
//
#define hrMissingFullBackup              ((HRESULT)0xC8000230L)

//
// MessageId: hrBadBackupDatabaseSize
//
// MessageText:
//
// The backup database size must be a multiple of 4K (4096 bytes).
//
#define hrBadBackupDatabaseSize          ((HRESULT)0xC8000231L)

//
// MessageId: hrTermInProgress
//
// MessageText:
//
// The database is being shut down.
//
#define hrTermInProgress                 ((HRESULT)0xC80003E8L)

//
// MessageId: hrFeatureNotAvailable
//
// MessageText:
//
// The feature is not available.
//
#define hrFeatureNotAvailable            ((HRESULT)0xC80003E9L)

//
// MessageId: hrInvalidName
//
// MessageText:
//
// The name is not valid.
//
#define hrInvalidName                    ((HRESULT)0xC80003EAL)

//
// MessageId: hrInvalidParameter
//
// MessageText:
//
// The parameter is not valid.
//
#define hrInvalidParameter               ((HRESULT)0xC80003EBL)

//
// MessageId: hrColumnNull
//
// MessageText:
//
// The value of the column is null.
//
#define hrColumnNull                     ((HRESULT)0x880003ECL)

//
// MessageId: hrBufferTruncated
//
// MessageText:
//
// The buffer is too small for data.
//
#define hrBufferTruncated                ((HRESULT)0x880003EEL)

//
// MessageId: hrDatabaseAttached
//
// MessageText:
//
// The database is already attached.
//
#define hrDatabaseAttached               ((HRESULT)0x880003EFL)

//
// MessageId: hrInvalidDatabaseId
//
// MessageText:
//
// The database ID is not valid.
//
#define hrInvalidDatabaseId              ((HRESULT)0xC80003F2L)

//
// MessageId: hrOutOfMemory
//
// MessageText:
//
// The computer is out of memory.
//
#define hrOutOfMemory                    ((HRESULT)0xC80003F3L)

//
// MessageId: hrOutOfDatabaseSpace
//
// MessageText:
//
// The database has reached the maximum size of 16 GB.
//
#define hrOutOfDatabaseSpace             ((HRESULT)0xC80003F4L)

//
// MessageId: hrOutOfCursors
//
// MessageText:
//
// Out of table cursors.
//
#define hrOutOfCursors                   ((HRESULT)0xC80003F5L)

//
// MessageId: hrOutOfBuffers
//
// MessageText:
//
// Out of database page buffers.
//
#define hrOutOfBuffers                   ((HRESULT)0xC80003F6L)

//
// MessageId: hrTooManyIndexes
//
// MessageText:
//
// There are too many indexes.
//
#define hrTooManyIndexes                 ((HRESULT)0xC80003F7L)

//
// MessageId: hrTooManyKeys
//
// MessageText:
//
// There are too many columns in an index.
//
#define hrTooManyKeys                    ((HRESULT)0xC80003F8L)

//
// MessageId: hrRecordDeleted
//
// MessageText:
//
// The record has been deleted.
//
#define hrRecordDeleted                  ((HRESULT)0xC80003F9L)

//
// MessageId: hrReadVerifyFailure
//
// MessageText:
//
// A read verification error occurred.
//
#define hrReadVerifyFailure              ((HRESULT)0xC80003FAL)

//
// MessageId: hrOutOfFileHandles
//
// MessageText:
//
// Out of file handles.
//
#define hrOutOfFileHandles               ((HRESULT)0xC80003FCL)

//
// MessageId: hrDiskIO
//
// MessageText:
//
// A disk I/O error occurred.
//
#define hrDiskIO                         ((HRESULT)0xC80003FEL)

//
// MessageId: hrInvalidPath
//
// MessageText:
//
// The path to the file is not valid.
//
#define hrInvalidPath                    ((HRESULT)0xC80003FFL)

//
// MessageId: hrRecordTooBig
//
// MessageText:
//
// The record has exceeded the maximum size.
//
#define hrRecordTooBig                   ((HRESULT)0xC8000402L)

//
// MessageId: hrTooManyOpenDatabases
//
// MessageText:
//
// There are too many open databases.
//
#define hrTooManyOpenDatabases           ((HRESULT)0xC8000403L)

//
// MessageId: hrInvalidDatabase
//
// MessageText:
//
// The file is not a database file.
//
#define hrInvalidDatabase                ((HRESULT)0xC8000404L)

//
// MessageId: hrNotInitialized
//
// MessageText:
//
// The database was not yet called.
//
#define hrNotInitialized                 ((HRESULT)0xC8000405L)

//
// MessageId: hrAlreadyInitialized
//
// MessageText:
//
// The database was already called.
//
#define hrAlreadyInitialized             ((HRESULT)0xC8000406L)

//
// MessageId: hrFileAccessDenied
//
// MessageText:
//
// Unable to access the file.
//
#define hrFileAccessDenied               ((HRESULT)0xC8000408L)

//
// MessageId: hrBufferTooSmall
//
// MessageText:
//
// The buffer is too small.
//
#define hrBufferTooSmall                 ((HRESULT)0xC800040EL)

//
// MessageId: hrSeekNotEqual
//
// MessageText:
//
// Either SeekLE or SeekGE did not find an exact match.
//
#define hrSeekNotEqual                   ((HRESULT)0x8800040FL)

//
// MessageId: hrTooManyColumns
//
// MessageText:
//
// There are too many columns defined.
//
#define hrTooManyColumns                 ((HRESULT)0xC8000410L)

//
// MessageId: hrContainerNotEmpty
//
// MessageText:
//
// The container is not empty.
//
#define hrContainerNotEmpty              ((HRESULT)0xC8000413L)

//
// MessageId: hrInvalidFilename
//
// MessageText:
//
// The filename is not valid.
//
#define hrInvalidFilename                ((HRESULT)0xC8000414L)

//
// MessageId: hrInvalidBookmark
//
// MessageText:
//
// The bookmark is not valid.
//
#define hrInvalidBookmark                ((HRESULT)0xC8000415L)

//
// MessageId: hrColumnInUse
//
// MessageText:
//
// The column is used in an index.
//
#define hrColumnInUse                    ((HRESULT)0xC8000416L)

//
// MessageId: hrInvalidBufferSize
//
// MessageText:
//
// The data buffer does not match the column size.
//
#define hrInvalidBufferSize              ((HRESULT)0xC8000417L)

//
// MessageId: hrColumnNotUpdatable
//
// MessageText:
//
// Unable to set the column value.
//
#define hrColumnNotUpdatable             ((HRESULT)0xC8000418L)

//
// MessageId: hrIndexInUse
//
// MessageText:
//
// The index is in use.
//
#define hrIndexInUse                     ((HRESULT)0xC800041BL)

//
// MessageId: hrNullKeyDisallowed
//
// MessageText:
//
// Null keys are not allowed on an index.
//
#define hrNullKeyDisallowed              ((HRESULT)0xC800041DL)

//
// MessageId: hrNotInTransaction
//
// MessageText:
//
// The operation must be within a transaction.
//
#define hrNotInTransaction               ((HRESULT)0xC800041EL)

//
// MessageId: hrNoIdleActivity
//
// MessageText:
//
// No idle activity occurred.
//
#define hrNoIdleActivity                 ((HRESULT)0x88000422L)

//
// MessageId: hrTooManyActiveUsers
//
// MessageText:
//
// There are too many active database users.
//
#define hrTooManyActiveUsers             ((HRESULT)0xC8000423L)

//
// MessageId: hrInvalidCountry
//
// MessageText:
//
// The country code is either not known or is not valid.
//
#define hrInvalidCountry                 ((HRESULT)0xC8000425L)

//
// MessageId: hrInvalidLanguageId
//
// MessageText:
//
// The language ID is either not known or is not valid.
//
#define hrInvalidLanguageId              ((HRESULT)0xC8000426L)

//
// MessageId: hrInvalidCodePage
//
// MessageText:
//
// The code page is either not known or is not valid.
//
#define hrInvalidCodePage                ((HRESULT)0xC8000427L)

//
// MessageId: hrNoWriteLock
//
// MessageText:
//
// There is no write lock at transaction level 0.
//
#define hrNoWriteLock                    ((HRESULT)0x8800042BL)

//
// MessageId: hrColumnSetNull
//
// MessageText:
//
// The column value is set to null.
//
#define hrColumnSetNull                  ((HRESULT)0x8800042CL)

//
// MessageId: hrVersionStoreOutOfMemory
//
// MessageText:
//
//  lMaxVerPages exceeded (XJET only)
//
#define hrVersionStoreOutOfMemory        ((HRESULT)0xC800042DL)

//
// MessageId: hrCurrencyStackOutOfMemory
//
// MessageText:
//
// Out of cursors.
//
#define hrCurrencyStackOutOfMemory       ((HRESULT)0xC800042EL)

//
// MessageId: hrOutOfSessions
//
// MessageText:
//
// Out of sessions.
//
#define hrOutOfSessions                  ((HRESULT)0xC800044DL)

//
// MessageId: hrWriteConflict
//
// MessageText:
//
// The write lock failed due to an outstanding write lock.
//
#define hrWriteConflict                  ((HRESULT)0xC800044EL)

//
// MessageId: hrTransTooDeep
//
// MessageText:
//
// The transactions are nested too deeply.
//
#define hrTransTooDeep                   ((HRESULT)0xC800044FL)

//
// MessageId: hrInvalidSesid
//
// MessageText:
//
// The session handle is not valid.
//
#define hrInvalidSesid                   ((HRESULT)0xC8000450L)

//
// MessageId: hrSessionWriteConflict
//
// MessageText:
//
// Another session has a private version of the page.
//
#define hrSessionWriteConflict           ((HRESULT)0xC8000453L)

//
// MessageId: hrInTransaction
//
// MessageText:
//
// The operation is not allowed within a transaction.
//
#define hrInTransaction                  ((HRESULT)0xC8000454L)

//
// MessageId: hrDatabaseDuplicate
//
// MessageText:
//
// The database already exists.
//
#define hrDatabaseDuplicate              ((HRESULT)0xC80004B1L)

//
// MessageId: hrDatabaseInUse
//
// MessageText:
//
// The database is in use.
//
#define hrDatabaseInUse                  ((HRESULT)0xC80004B2L)

//
// MessageId: hrDatabaseNotFound
//
// MessageText:
//
// The database does not exist.
//
#define hrDatabaseNotFound               ((HRESULT)0xC80004B3L)

//
// MessageId: hrDatabaseInvalidName
//
// MessageText:
//
// The database name is not valid.
//
#define hrDatabaseInvalidName            ((HRESULT)0xC80004B4L)

//
// MessageId: hrDatabaseInvalidPages
//
// MessageText:
//
// The number of pages is not valid.
//
#define hrDatabaseInvalidPages           ((HRESULT)0xC80004B5L)

//
// MessageId: hrDatabaseCorrupted
//
// MessageText:
//
// The database file is either damaged or cannot be found.
//
#define hrDatabaseCorrupted              ((HRESULT)0xC80004B6L)

//
// MessageId: hrDatabaseLocked
//
// MessageText:
//
// The database is locked.
//
#define hrDatabaseLocked                 ((HRESULT)0xC80004B7L)

//
// MessageId: hrTableEmpty
//
// MessageText:
//
// An empty table was opened.
//
#define hrTableEmpty                     ((HRESULT)0x88000515L)

//
// MessageId: hrTableLocked
//
// MessageText:
//
// The table is locked.
//
#define hrTableLocked                    ((HRESULT)0xC8000516L)

//
// MessageId: hrTableDuplicate
//
// MessageText:
//
// The table already exists.
//
#define hrTableDuplicate                 ((HRESULT)0xC8000517L)

//
// MessageId: hrTableInUse
//
// MessageText:
//
// Unable to lock the table because it is already in use.
//
#define hrTableInUse                     ((HRESULT)0xC8000518L)

//
// MessageId: hrObjectNotFound
//
// MessageText:
//
// The table or object does not exist.
//
#define hrObjectNotFound                 ((HRESULT)0xC8000519L)

//
// MessageId: hrCannotRename
//
// MessageText:
//
// Unable to rename the temporary file.
//
#define hrCannotRename                   ((HRESULT)0xC800051AL)

//
// MessageId: hrDensityInvalid
//
// MessageText:
//
// The file/index density is not valid.
//
#define hrDensityInvalid                 ((HRESULT)0xC800051BL)

//
// MessageId: hrTableNotEmpty
//
// MessageText:
//
// Unable to define the clustered index.
//
#define hrTableNotEmpty                  ((HRESULT)0xC800051CL)

//
// MessageId: hrInvalidTableId
//
// MessageText:
//
// The table ID is not valid.
//
#define hrInvalidTableId                 ((HRESULT)0xC800051EL)

//
// MessageId: hrTooManyOpenTables
//
// MessageText:
//
// Unable to open any more tables.
//
#define hrTooManyOpenTables              ((HRESULT)0xC800051FL)

//
// MessageId: hrIllegalOperation
//
// MessageText:
//
// The operation is not supported on tables.
//
#define hrIllegalOperation               ((HRESULT)0xC8000520L)

//
// MessageId: hrObjectDuplicate
//
// MessageText:
//
// The table or object name is already being used.
//
#define hrObjectDuplicate                ((HRESULT)0xC8000522L)

//
// MessageId: hrInvalidObject
//
// MessageText:
//
// The object is not valid for operation.
//
#define hrInvalidObject                  ((HRESULT)0xC8000524L)

//
// MessageId: hrIndexCantBuild
//
// MessageText:
//
// Unable to build a clustered index.
//
#define hrIndexCantBuild                 ((HRESULT)0xC8000579L)

//
// MessageId: hrIndexHasPrimary
//
// MessageText:
//
// The primary index is already defined.
//
#define hrIndexHasPrimary                ((HRESULT)0xC800057AL)

//
// MessageId: hrIndexDuplicate
//
// MessageText:
//
// The index is already defined.
//
#define hrIndexDuplicate                 ((HRESULT)0xC800057BL)

//
// MessageId: hrIndexNotFound
//
// MessageText:
//
// The index does not exist.
//
#define hrIndexNotFound                  ((HRESULT)0xC800057CL)

//
// MessageId: hrIndexMustStay
//
// MessageText:
//
// Unable to delete a clustered index.
//
#define hrIndexMustStay                  ((HRESULT)0xC800057DL)

//
// MessageId: hrIndexInvalidDef
//
// MessageText:
//
// The index definition is illegal.
//
#define hrIndexInvalidDef                ((HRESULT)0xC800057EL)

//
// MessageId: hrIndexHasClustered
//
// MessageText:
//
// The clustered index is already defined.
//
#define hrIndexHasClustered              ((HRESULT)0xC8000580L)

//
// MessageId: hrCreateIndexFailed
//
// MessageText:
//
// Unable to create the index because an error occurred while creating a table.
//
#define hrCreateIndexFailed              ((HRESULT)0x88000581L)

//
// MessageId: hrTooManyOpenIndexes
//
// MessageText:
//
// Out of index description blocks.
//
#define hrTooManyOpenIndexes             ((HRESULT)0xC8000582L)

//
// MessageId: hrColumnLong
//
// MessageText:
//
// The column value is too long.
//
#define hrColumnLong                     ((HRESULT)0xC80005DDL)

//
// MessageId: hrColumnDoesNotFit
//
// MessageText:
//
// The field will not fit in the record.
//
#define hrColumnDoesNotFit               ((HRESULT)0xC80005DFL)

//
// MessageId: hrNullInvalid
//
// MessageText:
//
// The value cannot be null.
//
#define hrNullInvalid                    ((HRESULT)0xC80005E0L)

//
// MessageId: hrColumnIndexed
//
// MessageText:
//
// Unable to delete because the column is indexed.
//
#define hrColumnIndexed                  ((HRESULT)0xC80005E1L)

//
// MessageId: hrColumnTooBig
//
// MessageText:
//
// The length of the field exceeds the maximum length.
//
#define hrColumnTooBig                   ((HRESULT)0xC80005E2L)

//
// MessageId: hrColumnNotFound
//
// MessageText:
//
// Unable to find the column.
//
#define hrColumnNotFound                 ((HRESULT)0xC80005E3L)

//
// MessageId: hrColumnDuplicate
//
// MessageText:
//
// The field is already defined.
//
#define hrColumnDuplicate                ((HRESULT)0xC80005E4L)

//
// MessageId: hrColumn2ndSysMaint
//
// MessageText:
//
// Only one auto-increment or version column is allowed per table.
//
#define hrColumn2ndSysMaint              ((HRESULT)0xC80005E6L)

//
// MessageId: hrInvalidColumnType
//
// MessageText:
//
// The column data type is not valid.
//
#define hrInvalidColumnType              ((HRESULT)0xC80005E7L)

//
// MessageId: hrColumnMaxTruncated
//
// MessageText:
//
// The column was truncated because it exceeded the maximum length.
//
#define hrColumnMaxTruncated             ((HRESULT)0x880005E8L)

//
// MessageId: hrColumnCannotIndex
//
// MessageText:
//
// Unable to index a long value column.
//
#define hrColumnCannotIndex              ((HRESULT)0xC80005E9L)

//
// MessageId: hrTaggedNotNULL
//
// MessageText:
//
// Tagged columns cannot be null.
//
#define hrTaggedNotNULL                  ((HRESULT)0xC80005EAL)

//
// MessageId: hrNoCurrentIndex
//
// MessageText:
//
// The entry is not valid without a current index.
//
#define hrNoCurrentIndex                 ((HRESULT)0xC80005EBL)

//
// MessageId: hrKeyIsMade
//
// MessageText:
//
// The key is completely made.
//
#define hrKeyIsMade                      ((HRESULT)0xC80005ECL)

//
// MessageId: hrBadColumnId
//
// MessageText:
//
// The column ID is not correct.
//
#define hrBadColumnId                    ((HRESULT)0xC80005EDL)

//
// MessageId: hrBadItagSequence
//
// MessageText:
//
// There is a bad instance identifier for a multivalued column.
//
#define hrBadItagSequence                ((HRESULT)0xC80005EEL)

//
// MessageId: hrCannotBeTagged
//
// MessageText:
//
// AutoIncrement and Version cannot be multivalued.
//
#define hrCannotBeTagged                 ((HRESULT)0xC80005F1L)

//
// MessageId: hrRecordNotFound
//
// MessageText:
//
// Unable to find the key.
//
#define hrRecordNotFound                 ((HRESULT)0xC8000641L)

//
// MessageId: hrNoCurrentRecord
//
// MessageText:
//
// The currency is not on a record.
//
#define hrNoCurrentRecord                ((HRESULT)0xC8000643L)

//
// MessageId: hrRecordClusteredChanged
//
// MessageText:
//
// A clustered key cannot be changed.
//
#define hrRecordClusteredChanged         ((HRESULT)0xC8000644L)

//
// MessageId: hrKeyDuplicate
//
// MessageText:
//
// The key already exists.
//
#define hrKeyDuplicate                   ((HRESULT)0xC8000645L)

//
// MessageId: hrAlreadyPrepared
//
// MessageText:
//
// The current entry has already been copied or cleared.
//
#define hrAlreadyPrepared                ((HRESULT)0xC8000647L)

//
// MessageId: hrKeyNotMade
//
// MessageText:
//
// No key was made.
//
#define hrKeyNotMade                     ((HRESULT)0xC8000648L)

//
// MessageId: hrUpdateNotPrepared
//
// MessageText:
//
// Update was not prepared.
//
#define hrUpdateNotPrepared              ((HRESULT)0xC8000649L)

//
// MessageId: hrwrnDataHasChanged
//
// MessageText:
//
// Data has changed.
//
#define hrwrnDataHasChanged              ((HRESULT)0x8800064AL)

//
// MessageId: hrerrDataHasChanged
//
// MessageText:
//
// The operation was abandoned because data has changed.
//
#define hrerrDataHasChanged              ((HRESULT)0xC800064BL)

//
// MessageId: hrKeyChanged
//
// MessageText:
//
// Moved to a new key.
//
#define hrKeyChanged                     ((HRESULT)0x88000652L)

//
// MessageId: hrTooManySorts
//
// MessageText:
//
// There are too many sort processes.
//
#define hrTooManySorts                   ((HRESULT)0xC80006A5L)

//
// MessageId: hrInvalidOnSort
//
// MessageText:
//
// An operation that is not valid occurred in the sort.
//
#define hrInvalidOnSort                  ((HRESULT)0xC80006A6L)

//
// MessageId: hrTempFileOpenError
//
// MessageText:
//
// Unable to open the temporary file.
//
#define hrTempFileOpenError              ((HRESULT)0xC800070BL)

//
// MessageId: hrTooManyAttachedDatabases
//
// MessageText:
//
// There are too many databases open.
//
#define hrTooManyAttachedDatabases       ((HRESULT)0xC800070DL)

//
// MessageId: hrDiskFull
//
// MessageText:
//
// The disk is full.
//
#define hrDiskFull                       ((HRESULT)0xC8000710L)

//
// MessageId: hrPermissionDenied
//
// MessageText:
//
// Permission is denied.
//
#define hrPermissionDenied               ((HRESULT)0xC8000711L)

//
// MessageId: hrFileNotFound
//
// MessageText:
//
// Unable to find the file.
//
#define hrFileNotFound                   ((HRESULT)0xC8000713L)

//
// MessageId: hrFileOpenReadOnly
//
// MessageText:
//
// The database file is read only.
//
#define hrFileOpenReadOnly               ((HRESULT)0x88000715L)

//
// MessageId: hrAfterInitialization
//
// MessageText:
//
// Unable to restore after initialization.
//
#define hrAfterInitialization            ((HRESULT)0xC800073AL)

//
// MessageId: hrLogCorrupted
//
// MessageText:
//
// The database log files are damaged.
//
#define hrLogCorrupted                   ((HRESULT)0xC800073CL)

//
// MessageId: hrInvalidOperation
//
// MessageText:
//
// The operation is not valid.
//
#define hrInvalidOperation               ((HRESULT)0xC8000772L)

//
// MessageId: hrAccessDenied
//
// MessageText:
//
// Access is denied.
//
#define hrAccessDenied                   ((HRESULT)0xC8000773L)

#endif	// _NTDSBMSG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\NTSDExts.h ===
/*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntsdexts.h

Abstract:

    This file contains procedure prototypes and structures
    needed to write old NTSD and KD debugger extensions.

    NOTE:  Newer defitions and interfaces are in wdbgexts.h

Environment:

    runs in the Win32 NTSD debug environment.

Revision History:

--*/

#ifndef _NTSDEXTNS_
#define _NTSDEXTNS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef
VOID
(__cdecl *PNTSD_OUTPUT_ROUTINE)(
    char *,
    ...
    );

typedef
ULONG_PTR
(*PNTSD_GET_EXPRESSION)(
    char *
    );

typedef
VOID
(*PNTSD_GET_SYMBOL)(
    ULONG_PTR offset,
    PUCHAR pchBuffer,
    ULONG_PTR *pDisplacement
    );

typedef
DWORD
(*PNTSD_DISASM)(
    ULONG_PTR *lpOffset,
    LPSTR lpBuffer,
    ULONG fShowEfeectiveAddress
    );

typedef
BOOL
(*PNTSD_CHECK_CONTROL_C)(
    VOID
    );

typedef struct _NTSD_EXTENSION_APIS {
    DWORD nSize;
    PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
    PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
    PNTSD_GET_SYMBOL lpGetSymbolRoutine;
    PNTSD_DISASM lpDisasmRoutine;
    PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
} NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

typedef
VOID
(*PNTSD_EXTENSION_ROUTINE)(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    );

#ifdef __cplusplus
}
#endif


#endif // _NTSDEXTNS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win7\sdk\include\NtDsAPI.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    ntdsapi.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for public NTDS APIs other than directory interfaces like LDAP.

Environment:

    User Mode - Win32

Notes:

--*/


#ifndef _NTDSAPI_H_
#define _NTDSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <schedule.h>

#if !defined(_NTDSAPI_)
#define NTDSAPI DECLSPEC_IMPORT
#if !defined(_NTDSAPI_POSTXP_ASLIB_)
#define NTDSAPI_POSTXP DECLSPEC_IMPORT
#else
#define NTDSAPI_POSTXP
#endif
#else
#define NTDSAPI
#define NTDSAPI_POSTXP
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Data definitions                                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#ifdef MIDL_PASS
typedef GUID UUID;
typedef void * RPC_AUTH_IDENTITY_HANDLE;
typedef void VOID;
#endif


// Following constants define the Active Directory Behavior
// Version numbers.
#define DS_BEHAVIOR_WIN2000                            0
#define DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS         1
#define DS_BEHAVIOR_WIN2003                            2
#define DS_BEHAVIOR_WIN2008                            3
#define DS_BEHAVIOR_WIN2008R2                          4

// Deprecated constants
#define DS_BEHAVIOR_LONGHORN 		DS_BEHAVIOR_WIN2008
#define DS_BEHAVIOR_WIN7                DS_BEHAVIOR_WIN2008R2

#define DS_DEFAULT_LOCALE                                           \
           (MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),  \
                     SORT_DEFAULT))

#define DS_DEFAULT_LOCALE_COMPARE_FLAGS    (NORM_IGNORECASE     |   \
                                            NORM_IGNOREKANATYPE |   \
                                            NORM_IGNORENONSPACE |   \
                                            NORM_IGNOREWIDTH    |   \
                                            SORT_STRINGSORT )

// When booted to DS mode, this event is signalled when the DS has completed
// its initial sync attempts.  The period of time between system startup and
// this event's state being set is indeterminate from the local service's
// standpoint.  In the meantime the contents of the DS should be considered
// incomplete / out-dated, and the machine will not be advertised as a domain
// controller to off-machine clients.  Other local services that rely on
// information published in the DS should avoid accessing (or at least
// relying on) the contents of the DS until this event is set.
#define DS_SYNCED_EVENT_NAME    "NTDSInitialSyncsCompleted"
#define DS_SYNCED_EVENT_NAME_W L"NTDSInitialSyncsCompleted"

// Permissions bits used in security descriptors in the directory.
#ifndef _DS_CONTROL_BITS_DEFINED_
#define _DS_CONTROL_BITS_DEFINED_
#define ACTRL_DS_OPEN                           0x00000000
#define ACTRL_DS_CREATE_CHILD                   0x00000001
#define ACTRL_DS_DELETE_CHILD                   0x00000002
#define ACTRL_DS_LIST                           0x00000004
#define ACTRL_DS_SELF                           0x00000008
#define ACTRL_DS_READ_PROP                      0x00000010
#define ACTRL_DS_WRITE_PROP                     0x00000020
#define ACTRL_DS_DELETE_TREE                    0x00000040
#define ACTRL_DS_LIST_OBJECT                    0x00000080
#define ACTRL_DS_CONTROL_ACCESS                 0x00000100

// generic read
#define DS_GENERIC_READ          ((STANDARD_RIGHTS_READ)     | \
                                  (ACTRL_DS_LIST)            | \
                                  (ACTRL_DS_READ_PROP)       | \
                                  (ACTRL_DS_LIST_OBJECT))

// generic execute
#define DS_GENERIC_EXECUTE       ((STANDARD_RIGHTS_EXECUTE)  | \
                                  (ACTRL_DS_LIST))
// generic right
#define DS_GENERIC_WRITE         ((STANDARD_RIGHTS_WRITE)    | \
                                  (ACTRL_DS_SELF)            | \
                                  (ACTRL_DS_WRITE_PROP))
// generic all

#define DS_GENERIC_ALL           ((STANDARD_RIGHTS_REQUIRED) | \
                                  (ACTRL_DS_CREATE_CHILD)    | \
                                  (ACTRL_DS_DELETE_CHILD)    | \
                                  (ACTRL_DS_DELETE_TREE)     | \
                                  (ACTRL_DS_READ_PROP)       | \
                                  (ACTRL_DS_WRITE_PROP)      | \
                                  (ACTRL_DS_LIST)            | \
                                  (ACTRL_DS_LIST_OBJECT)     | \
                                  (ACTRL_DS_CONTROL_ACCESS)  | \
                                  (ACTRL_DS_SELF))
#endif

typedef enum
{
    // unknown name type
    DS_UNKNOWN_NAME = 0,

    // eg: CN=User Name,OU=Users,DC=Example,DC=Microsoft,DC=Com
    DS_FQDN_1779_NAME = 1,

    // eg: Example\UserN
    // Domain-only version includes trailing '\\'.
    DS_NT4_ACCOUNT_NAME = 2,

    // Probably "User Name" but could be something else.  I.e. The
    // display name is not necessarily the defining RDN.
    DS_DISPLAY_NAME = 3,

    // obsolete - see #define later
    // DS_DOMAIN_SIMPLE_NAME = 4,

    // obsolete - see #define later
    // DS_ENTERPRISE_SIMPLE_NAME = 5,

    // String-ized GUID as returned by IIDFromString().
    // eg: {4fa050f0-f561-11cf-bdd9-00aa003a77b6}
    DS_UNIQUE_ID_NAME = 6,

    // eg: example.microsoft.com/software/user name
    // Domain-only version includes trailing '/'.
    DS_CANONICAL_NAME = 7,

    // eg: usern@example.microsoft.com
    DS_USER_PRINCIPAL_NAME = 8,

    // Same as DS_CANONICAL_NAME except that rightmost '/' is
    // replaced with '\n' - even in domain-only case.
    // eg: example.microsoft.com/software\nuser name
    DS_CANONICAL_NAME_EX = 9,

    // eg: www/www.microsoft.com@example.com - generalized service principal
    // names.
    DS_SERVICE_PRINCIPAL_NAME = 10,

    // This is the string representation of a SID.  Invalid for formatDesired.
    // See sddl.h for SID binary <--> text conversion routines.
    // eg: S-1-5-21-397955417-626881126-188441444-501
    DS_SID_OR_SID_HISTORY_NAME = 11,

    // Pseudo-name format so GetUserNameEx can return the DNS domain name to
    // a caller.  This level is not supported by the DS APIs.
    DS_DNS_DOMAIN_NAME = 12

} DS_NAME_FORMAT;

// Map old name formats to closest new format so that old code builds
// against new headers w/o errors and still gets (almost) correct result.

#define DS_DOMAIN_SIMPLE_NAME       DS_USER_PRINCIPAL_NAME
#define DS_ENTERPRISE_SIMPLE_NAME   DS_USER_PRINCIPAL_NAME

typedef enum
{
    DS_NAME_NO_FLAGS = 0x0,

    // Perform a syntactical mapping at the client (if possible) without
    // going out on the wire.  Returns DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
    // if a purely syntactical mapping is not possible.
    DS_NAME_FLAG_SYNTACTICAL_ONLY = 0x1,

    // Force a trip to the DC for evaluation, even if this could be
    // locally cracked syntactically.
    DS_NAME_FLAG_EVAL_AT_DC = 0x2,

    // The call fails if the DC is not a GC
    DS_NAME_FLAG_GCVERIFY = 0x4,

    // Enable cross forest trust referral
    DS_NAME_FLAG_TRUST_REFERRAL = 0x8

} DS_NAME_FLAGS;

typedef enum
{
    DS_NAME_NO_ERROR = 0,

    // Generic processing error.
    DS_NAME_ERROR_RESOLVING = 1,

    // Couldn't find the name at all - or perhaps caller doesn't have
    // rights to see it.
    DS_NAME_ERROR_NOT_FOUND = 2,

    // Input name mapped to more than one output name.
    DS_NAME_ERROR_NOT_UNIQUE = 3,

    // Input name found, but not the associated output format.
    // Can happen if object doesn't have all the required attributes.
    DS_NAME_ERROR_NO_MAPPING = 4,

    // Unable to resolve entire name, but was able to determine which
    // domain object resides in.  Thus DS_NAME_RESULT_ITEM?.pDomain
    // is valid on return.
    DS_NAME_ERROR_DOMAIN_ONLY = 5,

    // Unable to perform a purely syntactical mapping at the client
    // without going out on the wire.
    DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = 6,

    // The name is from an external trusted forest.
    DS_NAME_ERROR_TRUST_REFERRAL = 7

} DS_NAME_ERROR;

#define DS_NAME_LEGAL_FLAGS (DS_NAME_FLAG_SYNTACTICAL_ONLY)

typedef enum {

    // "paulle-nec.ntwksta.ms.com"
    DS_SPN_DNS_HOST = 0,

    // "cn=paulle-nec,ou=computers,dc=ntwksta,dc=ms,dc=com"
    DS_SPN_DN_HOST = 1,

    // "paulle-nec"
    DS_SPN_NB_HOST = 2,

    // "ntdev.ms.com"
    DS_SPN_DOMAIN = 3,

    // "ntdev"
    DS_SPN_NB_DOMAIN = 4,

    // "cn=anRpcService,cn=RPC Services,cn=system,dc=ms,dc=com"
    // "cn=aWsService,cn=Winsock Services,cn=system,dc=ms,dc=com"
    // "cn=aService,dc=itg,dc=ms,dc=com"
    // "www.ms.com", "ftp.ms.com", "ldap.ms.com"
    // "products.ms.com"
    DS_SPN_SERVICE = 5

} DS_SPN_NAME_TYPE;

typedef enum {                          // example:
        DS_SPN_ADD_SPN_OP = 0,          // add SPNs
        DS_SPN_REPLACE_SPN_OP = 1,      // set all SPNs
        DS_SPN_DELETE_SPN_OP = 2        // Delete SPNs
} DS_SPN_WRITE_OP;

typedef struct
{
    DWORD                   status;     // DS_NAME_ERROR
#ifdef MIDL_PASS
    [string,unique] CHAR    *pDomain;   // DNS domain
    [string,unique] CHAR    *pName;     // name in requested format
#else
    LPSTR                   pDomain;    // DNS domain
    LPSTR                   pName;      // name in requested format
#endif

} DS_NAME_RESULT_ITEMA, *PDS_NAME_RESULT_ITEMA;

typedef struct
{
    DWORD                   cItems;     // item count
#ifdef MIDL_PASS
    [size_is(cItems)] PDS_NAME_RESULT_ITEMA rItems;
#else
    PDS_NAME_RESULT_ITEMA    rItems;    // item array
#endif

} DS_NAME_RESULTA, *PDS_NAME_RESULTA;

typedef struct
{
    DWORD                   status;     // DS_NAME_ERROR
#ifdef MIDL_PASS
    [string,unique] WCHAR   *pDomain;   // DNS domain
    [string,unique] WCHAR   *pName;     // name in requested format
#else
    LPWSTR                  pDomain;    // DNS domain
    LPWSTR                  pName;      // name in requested format
#endif

} DS_NAME_RESULT_ITEMW, *PDS_NAME_RESULT_ITEMW;

typedef struct
{
    DWORD                   cItems;     // item count
#ifdef MIDL_PASS
    [size_is(cItems)] PDS_NAME_RESULT_ITEMW rItems;
#else
    PDS_NAME_RESULT_ITEMW    rItems;    // item array
#endif

} DS_NAME_RESULTW, *PDS_NAME_RESULTW;

#ifdef UNICODE
#define DS_NAME_RESULT DS_NAME_RESULTW
#define PDS_NAME_RESULT PDS_NAME_RESULTW
#define DS_NAME_RESULT_ITEM DS_NAME_RESULT_ITEMW
#define PDS_NAME_RESULT_ITEM PDS_NAME_RESULT_ITEMW
#else
#define DS_NAME_RESULT DS_NAME_RESULTA
#define PDS_NAME_RESULT PDS_NAME_RESULTA
#define DS_NAME_RESULT_ITEM DS_NAME_RESULT_ITEMA
#define PDS_NAME_RESULT_ITEM PDS_NAME_RESULT_ITEMA
#endif

// Public replication option flags

// ********************
// DsBindWithSpnEx flags
// ********************
// Allow the Bind to use delegate service level, so that you can
// do ntdsapi operations that require delegation, such as
// DsAddSidHistory, and DsReplicaSyncAll().  Most operations do
// not require DELEGATE so this flag should only be specified
// if you need it, because if you bind to a rogue server with
// the DELEGATE flag, you'll allow the rogue server to use your
// credentials to connect back to a non-rogue server and perform
// operations other than you intended.
#define  NTDSAPI_BIND_ALLOW_DELEGATION		(0x00000001)
// With AD/AM, a single machine, could have multiple "AD's" on a
// single server.  Since DsBindXxxx() will not pick an AD/AM
// instance without an instance specifier ( ":389" ), it can be
// difficult (well impossible) to determine from just a server
// name, what the instance annotation or instance guid is.  This
// option will take a server name and find the first available
// AD or AD/AM instance.  WARNING: The results could be non-
// deterministic on a server w/ multiple instances.
#define  NTDSAPI_BIND_FIND_BINDING          (0x00000002)
// We have a family of API's for binding called DsBindWithSpn.
// Would anyone who called these and passed in a non-NULL SPN
// ever want to negotiate down to something that doesn't use that
// SPN?  No, this is a security hole.  So, for backwards compatibility
// if you call without an SPN, we'll create one for you, and attempt
// to use it, and allow negotiation to do it's thing if it doesn't
// work.
#define  NTDSAPI_BIND_FORCE_KERBEROS     (0x00000004)



// ********************
// Replica Sync flags
// These flag values are used both as input to DsReplicaSync and
// as output from DsReplicaGetInfo, PENDING_OPS, DS_REPL_OPW.ulOptions
// ********************

// Perform this operation asynchronously.
#define DS_REPSYNC_ASYNCHRONOUS_OPERATION 0x00000001

// Writeable replica.  Otherwise, read-only.
#define DS_REPSYNC_WRITEABLE              0x00000002

// This is a periodic sync request as scheduled by the admin.
#define DS_REPSYNC_PERIODIC               0x00000004

// Use inter-site messaging
#define DS_REPSYNC_INTERSITE_MESSAGING    0x00000008

// Sync starting from scratch (i.e., at the first USN).
#define DS_REPSYNC_FULL                   0x00000020

// This is a notification of an update that was marked urgent.
#define DS_REPSYNC_URGENT                 0x00000040

// Don't discard this synchronization request, even if a similar
// sync is pending.
#define DS_REPSYNC_NO_DISCARD             0x00000080

// Sync even if link is currently disabled.
#define DS_REPSYNC_FORCE                  0x00000100

// Causes the source DSA to check if a reps-to is present for the local DSA
// (aka the destination). If not, one is added.  This ensures that
// source sends change notifications.
#define DS_REPSYNC_ADD_REFERENCE          0x00000200

// A sync from this source has never completed (e.g., a new source).
#define DS_REPSYNC_NEVER_COMPLETED        0x00000400

// When this sync is complete, requests a sync in the opposite direction.
#define DS_REPSYNC_TWO_WAY                0x00000800

// Do not request change notifications from this source.
#define DS_REPSYNC_NEVER_NOTIFY           0x00001000

// Sync the NC from this source when the DSA is started.
#define DS_REPSYNC_INITIAL                0x00002000

// Use compression when replicating.  Saves message size (e.g., network
// bandwidth) at the expense of extra CPU overhead at both the source and
// destination servers.
#define DS_REPSYNC_USE_COMPRESSION        0x00004000

// Sync was abandoned for lack of updates (W2K, W2K3)
#define DS_REPSYNC_ABANDONED              0x00008000

// Special secret processing
#define DS_REPSYNC_SELECT_SECRETS         0x00008000

// Initial sync in progress
#define DS_REPSYNC_INITIAL_IN_PROGRESS    0x00010000

// Partial Attribute Set sync in progress
#define DS_REPSYNC_PARTIAL_ATTRIBUTE_SET  0x00020000

// Sync is being retried
#define DS_REPSYNC_REQUEUE                0x00040000

// Sync is a notification request from a source
#define DS_REPSYNC_NOTIFICATION           0x00080000

// Sync is a special form which requests to establish contact
// now and do the rest of the sync later
#define DS_REPSYNC_ASYNCHRONOUS_REPLICA   0x00100000

// Request critical objects only
#define DS_REPSYNC_CRITICAL               0x00200000

// A full synchronization is in progress
#define DS_REPSYNC_FULL_IN_PROGRESS       0x00400000

// Synchronization request was previously preempted
#define DS_REPSYNC_PREEMPTED              0x00800000

// Non GC readonly replica
#define DS_REPSYNC_NONGC_RO_REPLICA       0x01000000

// ********************
// Replica Add flags
// ********************

// Perform this operation asynchronously.
#define DS_REPADD_ASYNCHRONOUS_OPERATION  0x00000001

// Create a writeable replica.  Otherwise, read-only.
#define DS_REPADD_WRITEABLE               0x00000002

// Sync the NC from this source when the DSA is started.
#define DS_REPADD_INITIAL                 0x00000004

// Sync the NC from this source periodically, as defined by the
// schedule passed in the preptimesSync argument.
#define DS_REPADD_PERIODIC                0x00000008

// Sync from the source DSA via an Intersite Messaging Service (ISM) transport
// (e.g., SMTP) rather than native DS RPC.
#define DS_REPADD_INTERSITE_MESSAGING     0x00000010

// Don't replicate the NC now -- just save enough state such that we
// know to replicate it later.
#define DS_REPADD_ASYNCHRONOUS_REPLICA     0x00000020

// Disable notification-based synchronization for the NC from this source.
// This is expected to be a temporary state; the similar flag
// DS_REPADD_NEVER_NOTIFY should be used if the disable is to be more permanent.
#define DS_REPADD_DISABLE_NOTIFICATION     0x00000040

// Disable periodic synchronization for the NC from this source
#define DS_REPADD_DISABLE_PERIODIC         0x00000080

// Use compression when replicating.  Saves message size (e.g., network
// bandwidth) at the expense of extra CPU overhead at both the source and
// destination servers.
#define DS_REPADD_USE_COMPRESSION          0x00000100

// Do not request change notifications from this source.  When this flag is
// set, the source will not notify the destination when changes occur.
// Recommended for all intersite replication, which may occur over WAN links.
// This is expected to be a more or less permanent state; the similar flag
// DS_REPADD_DISABLE_NOTIFICATION should be used if notifications are to be
// disabled only temporarily.
#define DS_REPADD_NEVER_NOTIFY             0x00000200

// When this sync is complete, requests a sync in the opposite direction.
#define DS_REPADD_TWO_WAY                  0x00000400

// Request critical objects only
// Critical only is only allowed while installing
// A critical only sync does not bring all objects in the partition. It
// replicates just the ones necessary for minimal directory operation.
// A normal, non-critical sync must be performed before the partition
// can be considered fully synchronized.
#define DS_REPADD_CRITICAL                 0x00000800

// Special secret processing
#define DS_REPADD_SELECT_SECRETS           0x00001000

// Non GC RO Replica
#define DS_REPADD_NONGC_RO_REPLICA         0x01000000



// ********************
// Replica Delete flags
// ********************

// Perform this operation asynchronously.
#define DS_REPDEL_ASYNCHRONOUS_OPERATION 0x00000001

// The replica being deleted is writeable.
#define DS_REPDEL_WRITEABLE               0x00000002

// Replica is a mail-based replica
#define DS_REPDEL_INTERSITE_MESSAGING     0x00000004

// Ignore any error generated by contacting the source to tell it to scratch
// this server from its Reps-To for this NC.
#define DS_REPDEL_IGNORE_ERRORS           0x00000008

// Do not contact the source telling it to scratch this server from its
// Rep-To for this NC.  Otherwise, if the link is RPC-based, the source will
// be contacted.
#define DS_REPDEL_LOCAL_ONLY              0x00000010

// Delete all the objects in the NC
// "No source" is incompatible with (and rejected for) writeable NCs.  This is
// valid only for read-only NCs, and then only if the NC has no source.  This
// can occur when the NC has been partially deleted (in which case the KCC
// periodically calls the delete API with the "no source" flag set).
#define DS_REPDEL_NO_SOURCE               0x00000020

// Allow deletion of read-only replica even if it sources
// other read-only replicas.
#define DS_REPDEL_REF_OK                  0x00000040


// ********************
// Replica Modify flags
// ********************

// Perform this operation asynchronously.
#define DS_REPMOD_ASYNCHRONOUS_OPERATION  0x00000001

// The replica is writeable.
#define DS_REPMOD_WRITEABLE               0x00000002


// ********************
// Replica Modify fields
// ********************

#define DS_REPMOD_UPDATE_FLAGS             0x00000001
#define DS_REPMOD_UPDATE_INSTANCE          0x00000002
#define DS_REPMOD_UPDATE_ADDRESS           DS_REPMOD_UPDATE_INSTANCE
#define DS_REPMOD_UPDATE_SCHEDULE          0x00000004
#define DS_REPMOD_UPDATE_RESULT            0x00000008
#define DS_REPMOD_UPDATE_TRANSPORT         0x00000010

// ********************
// Update Refs fields
// ********************

// Perform this operation asynchronously.
#define DS_REPUPD_ASYNCHRONOUS_OPERATION  0x00000001

// The replica being deleted is writeable.
#define DS_REPUPD_WRITEABLE               0x00000002

// Add a reference
#define DS_REPUPD_ADD_REFERENCE           0x00000004

// Remove a reference
#define DS_REPUPD_DELETE_REFERENCE        0x00000008

// Use GCSPN while notifying replica partner
#define DS_REPUPD_REFERENCE_GCSPN         0x00000010


// ********************
//  NC Related Flags
// ********************
//
// Instance Type bits, specifies flags for NC head creation.
//
#define DS_INSTANCETYPE_IS_NC_HEAD        0x00000001 // This if what to specify on an object to indicate it's an NC Head.
#define DS_INSTANCETYPE_NC_IS_WRITEABLE   0x00000004 // This is to indicate that the NC Head is writeable.
#define DS_INSTANCETYPE_NC_COMING         0x00000010 // This is to indicate that this NC is still replicating in objects to this DC, and may not be a complete NC.
#define DS_INSTANCETYPE_NC_GOING          0x00000020 // This is to indicate that this NC is in the process of being removed from this DC, and may not be a complete NC.

// ********************
//  xxx_OPT_xxx Flags
// ********************

// These macros define bit flags which can be set in the "options" attribute
// of objects of the specified object class.

// Bit flags valid for options attribute on NTDS-DSA objects.
//
#define NTDSDSA_OPT_IS_GC                     ( 1 << 0 ) /* DSA is a global catalog */
#define NTDSDSA_OPT_DISABLE_INBOUND_REPL      ( 1 << 1 ) /* disable inbound replication */
#define NTDSDSA_OPT_DISABLE_OUTBOUND_REPL     ( 1 << 2 ) /* disable outbound replication */
#define NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE    ( 1 << 3 ) /* disable logical conn xlation */
#define NTDSDSA_OPT_DISABLE_SPN_REGISTRATION  ( 1 << 4 ) /* disable SPN registration for ADAM */
#define NTDSDSA_OPT_GENERATE_OWN_TOPO         ( 1 << 5 ) /* create own site topology */

// Bit flags for options attribute on NTDS-Connection objects.
//
// The reasons that two bits are required to control notification are as follows.
// We must support existing connections with the old behavior and the UI does not
// create manual connections with the new bit set.
// The default for existing and manually created connections with bits 2 and 3
// clear must be the standard prior behavior: notification for intra-site and
// no notification for inter-site.
// We need a way to distinguish a old connection which desires the default
// notification rules, and a new connection for which we desire to explicitly
// control the notification state as passed down from a site link.  Thus we
// have a new bit to say we are overriding the default, and a new bit to indicate
// what the overridden default shall be.
//
#define NTDSCONN_OPT_IS_GENERATED ( 1 << 0 )  /* object generated by DS, not admin */
#define NTDSCONN_OPT_TWOWAY_SYNC  ( 1 << 1 )  /* force sync in opposite direction at end of sync */
#define NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT (1 << 2 )  // Do not use defaults to determine notification
#define NTDSCONN_OPT_USE_NOTIFY   (1 << 3) // Does source notify destination

// For intra-site connections, this bit has no meaning.
// For inter-site connections, this bit means:
//  0 - Compression of replication data enabled
//  1 - Compression of replication data disabled
#define NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION    (1 << 4)

// For connections whose IS_GENERATED bit is 0, this bit has no effect.
// For KCC-generated connections, this bit indicates that the schedule attribute
// is owned by the user and should not be touched by the KCC.
#define NTDSCONN_OPT_USER_OWNED_SCHEDULE    (1 << 5)

// This is the default rodc connection - 1 per rodc for FRS's uses
#define NTDSCONN_OPT_RODC_TOPOLOGY            (1 << 6)          

// Connection reasons
//
// Values for "reason for connection".  A connection can be needed for
// more than one reason.
//
#define NTDSCONN_KCC_NO_REASON                ( 0 )               // 000
#define NTDSCONN_KCC_GC_TOPOLOGY              ( 1 << 0 )          // 001
#define NTDSCONN_KCC_RING_TOPOLOGY            ( 1 << 1 )          // 002
#define NTDSCONN_KCC_MINIMIZE_HOPS_TOPOLOGY   ( 1 << 2 )          // 004
#define NTDSCONN_KCC_STALE_SERVERS_TOPOLOGY   ( 1 << 3 )          // 008
#define NTDSCONN_KCC_OSCILLATING_CONNECTION_TOPOLOGY   ( 1 << 4 ) // 010
#define NTDSCONN_KCC_INTERSITE_GC_TOPOLOGY    (1 << 5)            // 020
#define NTDSCONN_KCC_INTERSITE_TOPOLOGY       (1 << 6)            // 040
#define NTDSCONN_KCC_SERVER_FAILOVER_TOPOLOGY (1 << 7)            // 080
#define NTDSCONN_KCC_SITE_FAILOVER_TOPOLOGY   (1 << 8)            // 100
#define NTDSCONN_KCC_REDUNDANT_SERVER_TOPOLOGY (1 << 9)           // 200

//
// The high 4 bits of the options attribute are used by NTFRS to assign priority
// for inbound connections. Bit 31 is used to force FRS to ignore schedule during
// the initial sync. Bits 30 - 28 are used to specify a priority between 0-7.
//

#define FRSCONN_PRIORITY_MASK		      0x70000000
#define FRSCONN_MAX_PRIORITY		      0x8

#define NTDSCONN_OPT_IGNORE_SCHEDULE_MASK 0x80000000

#define	NTDSCONN_IGNORE_SCHEDULE(_options_)\
        (((_options_) & NTDSCONN_OPT_IGNORE_SCHEDULE_MASK) >> 31)

#define	FRSCONN_GET_PRIORITY(_options_)    \
        (((((_options_) & FRSCONN_PRIORITY_MASK) >> 28) != 0 ) ? \
         (((_options_) & FRSCONN_PRIORITY_MASK) >> 28) :        \
         FRSCONN_MAX_PRIORITY                                   \
        )

// Bit flags for options attribute on NTDS-Site-Settings objects.
//
#define NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED     ( 1 << 0 ) /* automatic topology gen disabled */
#define NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED      ( 1 << 1 ) /* automatic topology cleanup disabled */
#define NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED     ( 1 << 2 ) /* automatic minimum hops topology disabled */
#define NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED ( 1 << 3 ) /* automatic stale server detection disabled */
#define NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED ( 1 << 4 ) /* automatic inter-site topology gen disabled */
#define NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED      ( 1 << 5 ) /* group memberships for users enabled */
#define NTDSSETTINGS_OPT_FORCE_KCC_WHISTLER_BEHAVIOR   ( 1 << 6 ) /* force KCC to operate in Whistler behavior mode */
#define NTDSSETTINGS_OPT_FORCE_KCC_W2K_ELECTION        ( 1 << 7 ) /* force KCC to use the Windows 2000 ISTG election algorithm */
#define NTDSSETTINGS_OPT_IS_RAND_BH_SELECTION_DISABLED ( 1 << 8 ) /* prevent the KCC from randomly picking a bridgehead when creating a connection */
#define NTDSSETTINGS_OPT_IS_SCHEDULE_HASHING_ENABLED   ( 1 << 9 ) /* allow the KCC to use hashing when creating a replication schedule */
#define NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED     ( 1 << 10 ) /* create static failover connections */

// The following two options allow the new kcc spanning tree algorithm, which replaces the ISM,
// to override the ISM policy settings. These two flags are analogous to those found on the
// transport object.

// default without flag: schedules are significant
// This flag causes the KCC in W2K3 mode to ignore schedules
#define NTDSSETTINGS_OPT_W2K3_IGNORE_SCHEDULES ( 1 << 11 ) // Schedules disabled

// default without flag: links transitive (bridges not required) auto site link bridging enabled
// This flag causes the KCC in W2K3 mode to require bridges
#define NTDSSETTINGS_OPT_W2K3_BRIDGES_REQUIRED (1 << 12 ) // siteLink bridges are required

// How many redundant connections will be generated
#define NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY 2

// Bit flags for options attribute on Inter-Site-Transport objects
//
// Note, the sense of the flag should be such that the default state or
// behavior corresponds to the flag NOT being present. Put another way, the
// flag should state the OPPOSITE of the default
//
// default: schedules are significant
#define NTDSTRANSPORT_OPT_IGNORE_SCHEDULES ( 1 << 0 ) // Schedules disabled

// default: links transitive (bridges not required)
#define NTDSTRANSPORT_OPT_BRIDGES_REQUIRED (1 << 1 ) // siteLink bridges are required

// Bit flags for options attribute on site-Connection objects
//
// These are not realized in the DS, but are built up in the KCC
#define NTDSSITECONN_OPT_USE_NOTIFY ( 1 << 0 ) // Use notification on this link
#define NTDSSITECONN_OPT_TWOWAY_SYNC ( 1 << 1 )  /* force sync in opposite direction at end of sync */

// This bit means:
//  0 - Compression of replication data across this site connection enabled
//  1 - Compression of replication data across this site connection disabled
#define NTDSSITECONN_OPT_DISABLE_COMPRESSION ( 1 << 2 )

// Bit flags for options attribute on site-Link objects
// Note that these options are AND-ed along a site-link path
//
#define NTDSSITELINK_OPT_USE_NOTIFY ( 1 << 0 ) // Use notification on this link
#define NTDSSITELINK_OPT_TWOWAY_SYNC ( 1 << 1 )  /* force sync in opposite direction at end of sync */

// This bit means:
//  0 - Compression of replication data across this site link enabled
//  1 - Compression of replication data across this site link disabled
#define NTDSSITELINK_OPT_DISABLE_COMPRESSION ( 1 << 2 )


// ***********************
// Well Known Object Guids
// ***********************

#define GUID_USERS_CONTAINER_A              "a9d1ca15768811d1aded00c04fd8d5cd"
#define GUID_COMPUTRS_CONTAINER_A           "aa312825768811d1aded00c04fd8d5cd"
#define GUID_SYSTEMS_CONTAINER_A            "ab1d30f3768811d1aded00c04fd8d5cd"
#define GUID_DOMAIN_CONTROLLERS_CONTAINER_A "a361b2ffffd211d1aa4b00c04fd7d83a"
#define GUID_INFRASTRUCTURE_CONTAINER_A     "2fbac1870ade11d297c400c04fd8d5cd"
#define GUID_DELETED_OBJECTS_CONTAINER_A    "18e2ea80684f11d2b9aa00c04f79f805"
#define GUID_LOSTANDFOUND_CONTAINER_A       "ab8153b7768811d1aded00c04fd8d5cd"
#define GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_A "22b70c67d56e4efb91e9300fca3dc1aa"
#define GUID_PROGRAM_DATA_CONTAINER_A       "09460c08ae1e4a4ea0f64aee7daa1e5a"
#define GUID_MICROSOFT_PROGRAM_DATA_CONTAINER_A "f4be92a4c777485e878e9421d53087db"
#define GUID_NTDS_QUOTAS_CONTAINER_A        "6227f0af1fc2410d8e3bb10615bb5b0f"

#define GUID_USERS_CONTAINER_W              L"a9d1ca15768811d1aded00c04fd8d5cd"
#define GUID_COMPUTRS_CONTAINER_W           L"aa312825768811d1aded00c04fd8d5cd"
#define GUID_SYSTEMS_CONTAINER_W            L"ab1d30f3768811d1aded00c04fd8d5cd"
#define GUID_DOMAIN_CONTROLLERS_CONTAINER_W L"a361b2ffffd211d1aa4b00c04fd7d83a"
#define GUID_INFRASTRUCTURE_CONTAINER_W     L"2fbac1870ade11d297c400c04fd8d5cd"
#define GUID_DELETED_OBJECTS_CONTAINER_W    L"18e2ea80684f11d2b9aa00c04f79f805"
#define GUID_LOSTANDFOUND_CONTAINER_W       L"ab8153b7768811d1aded00c04fd8d5cd"
#define GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_W L"22b70c67d56e4efb91e9300fca3dc1aa"
#define GUID_PROGRAM_DATA_CONTAINER_W       L"09460c08ae1e4a4ea0f64aee7daa1e5a"
#define GUID_MICROSOFT_PROGRAM_DATA_CONTAINER_W L"f4be92a4c777485e878e9421d53087db"
#define GUID_NTDS_QUOTAS_CONTAINER_W        L"6227f0af1fc2410d8e3bb10615bb5b0f"

#define GUID_USERS_CONTAINER_BYTE              "\xa9\xd1\xca\x15\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_COMPUTRS_CONTAINER_BYTE           "\xaa\x31\x28\x25\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_SYSTEMS_CONTAINER_BYTE            "\xab\x1d\x30\xf3\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_DOMAIN_CONTROLLERS_CONTAINER_BYTE "\xa3\x61\xb2\xff\xff\xd2\x11\xd1\xaa\x4b\x00\xc0\x4f\xd7\xd8\x3a"
#define GUID_INFRASTRUCTURE_CONTAINER_BYTE     "\x2f\xba\xc1\x87\x0a\xde\x11\xd2\x97\xc4\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_DELETED_OBJECTS_CONTAINER_BYTE    "\x18\xe2\xea\x80\x68\x4f\x11\xd2\xb9\xaa\x00\xc0\x4f\x79\xf8\x05"
#define GUID_LOSTANDFOUND_CONTAINER_BYTE       "\xab\x81\x53\xb7\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE "\x22\xb7\x0c\x67\xd5\x6e\x4e\xfb\x91\xe9\x30\x0f\xca\x3d\xc1\xaa"
#define GUID_PROGRAM_DATA_CONTAINER_BYTE       "\x09\x46\x0c\x08\xae\x1e\x4a\x4e\xa0\xf6\x4a\xee\x7d\xaa\x1e\x5a"
#define GUID_MICROSOFT_PROGRAM_DATA_CONTAINER_BYTE "\xf4\xbe\x92\xa4\xc7\x77\x48\x5e\x87\x8e\x94\x21\xd5\x30\x87\xdb"
#define GUID_NTDS_QUOTAS_CONTAINER_BYTE        "\x62\x27\xf0\xaf\x1f\xc2\x41\x0d\x8e\x3b\xb1\x06\x15\xbb\x5b\x0f"


typedef enum _DS_MANGLE_FOR {
        DS_MANGLE_UNKNOWN = 0,
        DS_MANGLE_OBJECT_RDN_FOR_DELETION,
        DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
        } DS_MANGLE_FOR;

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Prototypes                                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// DSBind takes two optional input parameters which identify whether the
// caller found a domain controller themselves via DsGetDcName or whether
// a domain controller should be found using default parameters.
// Behavior of the possible combinations are outlined below.
//
// DomainControllerName(value), DnsDomainName(NULL)
//
//      The value for DomainControllerName is assumed to have been
//      obtained via DsGetDcName (i.e. Field with the same name in a
//      DOMAIN_CONTROLLER_INFO struct on return from DsGetDcName call.)
//      The client is bound to the domain controller at this name.
//
//      Mutual authentication will be performed using an SPN of
//      LDAP/DomainControllerName provided DomainControllerName
//      is not a NETBIOS name or IP address - i.e. it must be a
//      DNS host name.
//
//      For AD/AM, the DomainControllerName is treated as a Binding String,
//      where the first part is the ServerName (some sort of Network
//      identifier - such as DNS, IP address, NetBios Name, etc), and the
//      2nd part is the public LDAP port.  The AD/AM RPC interface uses
//      the LDAP port as our public annotation for RPC.  Ex:
//
//          MyNetBiosName:3030
//          192.0.0.1:2020
//          server1.microsoft.com:389
//
//      Alternatively, clients can use DsBindByInstance() to specify a
//      a specific RPC Annotation, and an even more specific InstanceGuid,
//      (or "objectGuid" in RPC) which is the "objectGuid" off the servers'
//      DSA (aka "NTDS Settings") object.
//
// DomainControllerName(value), DnsDomainName(value)
//
//      DsBind will connect to the server identified by DomainControllerName.
//
//      Mutual authentication will be performed using an SPN of
//      LDAP/DomainControllerName/DnsDomainName provided neither value
//      is a NETBIOS names or IP address - i.e. they must be
//      valid DNS names.
//
// DomainControllerName(NULL), DnsDomainName(NULL)
//
//      DsBind will attempt to find to a global catalog and fail if one
//      can not be found.
//
//      Mutual authentication will be performed using an SPN of
//      GC/DnsHostName/ForestName where DnsHostName and ForestName
//      represent the DomainControllerName and DnsForestName fields
//      respectively of the DOMAIN_CONTROLLER_INFO returned by the
//      DsGetDcName call used to find a global catalog.
//
// DomainControllerName(NULL), DnsDomainName(value)
//
//      DsBind will attempt to find a domain controller for the domain
//      identified by DnsDomainName and fail if one can not be found.
//
//      Mutual authentication will be performed using an SPN of
//      LDAP/DnsHostName/DnsDomainName where DnsDomainName is that
//      provided by the caller and DnsHostName is that returned by
//      DsGetDcName for the domain specified - provided DnsDomainName
//      is a valid DNS domain name - i.e. not a NETBIOS domain name.

__checkReturn
NTDSAPI
DWORD
WINAPI
DsBindW(
    __in_opt LPCWSTR         DomainControllerName,      // in, optional
    __in_opt LPCWSTR         DnsDomainName,             // in, optional
    __out HANDLE          *phDS);

__checkReturn
NTDSAPI
DWORD
WINAPI
DsBindA(
    __in_opt LPCSTR          DomainControllerName,      // in, optional
    __in_opt LPCSTR          DnsDomainName,             // in, optional
    __out HANDLE          *phDS);

#ifdef UNICODE
#define DsBind DsBindW
#else
#define DsBind DsBindA
#endif

__checkReturn
NTDSAPI
DWORD
WINAPI
DsBindWithCredW(
    __in_opt LPCWSTR         DomainControllerName,      // in, optional
    __in_opt LPCWSTR         DnsDomainName,             // in, optional
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __out HANDLE          *phDS);

__checkReturn
NTDSAPI
DWORD
WINAPI
DsBindWithCredA(
    __in_opt LPCSTR          DomainControllerName,      // in, optional
    __in_opt LPCSTR          DnsDomainName,             // in, optional
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __out HANDLE          *phDS);

#ifdef UNICODE
#define DsBindWithCred DsBindWithCredW
#else
#define DsBindWithCred DsBindWithCredA
#endif

//
// DsBindWithSpn{A|W} allows the caller to specify the service principal
// name (SPN) which will be used for mutual authentication against
// the destination server.  Do not provide an SPN if you are expecting
// DsBind to find a server for you as SPNs are machine specific and its
// unlikely the SPN you provide matches the server DsBind finds for you.
// Providing a NULL ServicePrincipalName argument results in behavior
// identical to DsBindWithCred{A|W}.
//

__checkReturn
NTDSAPI
DWORD
WINAPI
DsBindWithSpnW(
    __in_opt LPCWSTR         DomainControllerName,      // in, optional
    __in_opt LPCWSTR         DnsDomainName,             // in, optional
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __in_opt LPCWSTR         ServicePrincipalName,      // in, optional
    __out HANDLE          *phDS);

__checkReturn
NTDSAPI
DWORD
WINAPI
DsBindWithSpnA(
    __in_opt LPCSTR          DomainControllerName,      // in, optional
    __in_opt LPCSTR          DnsDomainName,             // in, optional
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __in_opt LPCSTR          ServicePrincipalName,      // in, optional
    __out HANDLE          *phDS);

#ifdef UNICODE
#define DsBindWithSpn DsBindWithSpnW
#else
#define DsBindWithSpn DsBindWithSpnA
#endif

//
// DsBindWithSpnEx{A|W} allows you all the options of the previous
// DsBindWithSpn(), plus the added benefit of specifying some optional
// Binding flags.  Currently if you pass NTDSAPI_BIND_ALLOW_DELEGATION,
// you will get the exact old behaviour.  If you can avoid it, you
// should not specify this flag, see flag above for details.
//

__checkReturn
NTDSAPI_POSTXP
DWORD
WINAPI
DsBindWithSpnExW(
    __in_opt LPCWSTR         DomainControllerName,      // in, optional
    __in_opt LPCWSTR         DnsDomainName,             // in, optional
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __in_opt LPCWSTR         ServicePrincipalName,      // in, optional
    __in_opt DWORD           BindFlags,                 // in, optional
    __out HANDLE          *phDS);

__checkReturn
NTDSAPI_POSTXP
DWORD
WINAPI
DsBindWithSpnExA(
    __in_opt LPCSTR          DomainControllerName,      // in, optional
    __in_opt LPCSTR          DnsDomainName,             // in, optional
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __in_opt LPCSTR          ServicePrincipalName,      // in, optional
    __in_opt DWORD           BindFlags,                 // in, optional
    __out HANDLE          *phDS);

#ifdef UNICODE
#define DsBindWithSpnEx DsBindWithSpnExW
#else
#define DsBindWithSpnEx DsBindWithSpnExA
#endif

//
// DsBindByInstance{A|W} Allows the explicit binding to any AD/AM
// or AD instance by Annotation or InstanceGuid.  For binding to
// an AD instance the Annotation and InstanceGuid can be left NULL.
// To Bind to an AD/AM instance one or the other must be specified
// to specify the AD/AM instance desired.
//

__checkReturn
NTDSAPI_POSTXP
DWORD
WINAPI
DsBindByInstanceW(
    __in_opt LPCWSTR         ServerName,                // in, optional
    __in_opt LPCWSTR         Annotation,                // in, optional
    __in_opt GUID *          InstanceGuid,              // in, optional
    __in_opt LPCWSTR         DnsDomainName,             // in, optional
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __in_opt LPCWSTR         ServicePrincipalName,      // in, optional
    __in_opt DWORD           BindFlags,                 // in, optional
    __out HANDLE          *phDS);

__checkReturn
NTDSAPI_POSTXP
DWORD
WINAPI
DsBindByInstanceA(
    __in_opt LPCSTR         ServerName,                 // in, optional
    __in_opt LPCSTR         Annotation,                 // in, optional
    __in_opt GUID *         InstanceGuid,               // in, optional
    __in_opt LPCSTR         DnsDomainName,              // in, optional
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __in_opt LPCSTR         ServicePrincipalName,       // in, optional
    __in_opt DWORD          BindFlags,                  // in, optional
    __out HANDLE         *phDS);

#ifdef UNICODE
#define DsBindByInstance DsBindByInstanceW
#else
#define DsBindByInstance DsBindByInstanceA
#endif

//
// DsBindToISTG{A|W} allows the caller to bind to the server which
// holds the Inter-Site Topology Generator role in the specified site.
// The site name should be the RDN of a site.  If no site is specified,
// the function will try to bind to the ISTG in a nearby site.
//

__checkReturn
NTDSAPI_POSTXP
DWORD
WINAPI
DsBindToISTGW(
    __in_opt LPCWSTR         SiteName,                  // in, optional
    __out HANDLE          *phDS);

__checkReturn
NTDSAPI_POSTXP
DWORD
WINAPI
DsBindToISTGA(
    __in_opt LPCSTR          SiteName,                  // in, optional
    __out HANDLE          *phDS);

#ifdef UNICODE
#define DsBindToISTG DsBindToISTGW
#else
#define DsBindToISTG DsBindToISTGA
#endif

//
// DsBindingSetTimeout allows the caller to specify a timeout value
// which will be honored by all RPC calls using the specified binding
// handle. RPC calls which take longer the timeout value are canceled.
//

__checkReturn
NTDSAPI_POSTXP
DWORD
WINAPI
DsBindingSetTimeout(
    __in HANDLE          hDS,                        // in
    __in ULONG           cTimeoutSecs                // in
    );

//
// DsUnBind
//

NTDSAPI
DWORD
WINAPI
DsUnBindW(
    __in HANDLE          *phDS);             // in

NTDSAPI
DWORD
WINAPI
DsUnBindA(
    __in HANDLE          *phDS);             // in

#ifdef UNICODE
#define DsUnBind DsUnBindW
#else
#define DsUnBind DsUnBindA
#endif

//
// DsMakePasswordCredentials
//
// This function constructs a credential structure which is suitable for input
// to the DsBindWithCredentials function, or the ldap_open function (winldap.h)
// The credential must be freed using DsFreeCredential.
//
// None of the input parameters may be present indicating a null, default
// credential.  Otherwise the username must be present.  If the domain or
// password are null, they default to empty strings.  The domain name may be
// null when the username is fully qualified, for example UPN format.
//

__checkReturn
NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsW(
    __in_opt LPCWSTR User,
    __in_opt LPCWSTR Domain,
    __in_opt LPCWSTR Password,
    __out RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    );

__checkReturn
NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsA(
    __in_opt LPCSTR User,
    __in_opt LPCSTR Domain,
    __in_opt LPCSTR Password,
    __out RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    );

#ifdef UNICODE
#define DsMakePasswordCredentials DsMakePasswordCredentialsW
#else
#define DsMakePasswordCredentials DsMakePasswordCredentialsA
#endif

NTDSAPI
VOID
WINAPI
DsFreePasswordCredentials(
    __in RPC_AUTH_IDENTITY_HANDLE AuthIdentity
    );

#define DsFreePasswordCredentialsW DsFreePasswordCredentials
#define DsFreePasswordCredentialsA DsFreePasswordCredentials

//
// DsCrackNames
//

__checkReturn
NTDSAPI
DWORD
WINAPI
DsCrackNamesW(
    __in_opt HANDLE          hDS,                // in
    __in DS_NAME_FLAGS       flags,              // in
    __in DS_NAME_FORMAT      formatOffered,      // in
    __in DS_NAME_FORMAT      formatDesired,      // in
    __in DWORD               cNames,             // in
    __in_ecount(cNames) const LPCWSTR *rpNames,  // in
    __deref_out PDS_NAME_RESULTW *ppResult);     // out


__checkReturn
NTDSAPI
DWORD
WINAPI
DsCrackNamesA(
    __in_opt HANDLE          hDS,                // in
    __in DS_NAME_FLAGS       flags,              // in
    __in DS_NAME_FORMAT      formatOffered,      // in
    __in DS_NAME_FORMAT      formatDesired,      // in
    __in DWORD               cNames,             // in
    __in_ecount(cNames) const LPCSTR *rpNames,   // in
    __deref_out PDS_NAME_RESULTA *ppResult);     // out

#ifdef UNICODE
#define DsCrackNames DsCrackNamesW
#else
#define DsCrackNames DsCrackNamesA
#endif

//
// DsFreeNameResult
//

NTDSAPI
void
WINAPI
DsFreeNameResultW(
    __in DS_NAME_RESULTW *pResult);          // in

NTDSAPI
void
WINAPI
DsFreeNameResultA(
    __in DS_NAME_RESULTA *pResult);          // in

#ifdef UNICODE
#define DsFreeNameResult DsFreeNameResultW
#else
#define DsFreeNameResult DsFreeNameResultA
#endif

// ==========================================================
// DSMakeSpn -- client call to create SPN for a service to which it wants to
// authenticate.
// This name is then passed to "pszTargetName" of InitializeSecurityContext().
//
// Notes:
// If the service name is a DNS host name, or canonical DNS service name
// e.g. "www.ms.com", i.e., caller resolved with gethostbyname, then instance
// name should be NULL.
// Realm is host name minus first component, unless it is in the exception list
//
// If the service name is NetBIOS machine name, then instance name should be
// NULL
// Form must be <domain>\<machine>
// Realm will be <domain>
//
// If the service name is that of a replicated service, where each replica has
// its own account (e.g., with SRV records) then the caller must supply the
// instance name then realm name is same as ServiceName
//
// If the service name is a DN, then must also supply instance name
// (DN could be name of service object (incl RPC or Winsock), name of machine
// account, name of domain object)
// then realm name is domain part of the DN
//
// If the service name is NetBIOS domain name, then must also supply instance
// name; realm name is domain name
//
// If the service is named by an IP address -- then use referring service name
// as service name
//
//  ServiceClass - e.g. "http", "ftp", "ldap", GUID
//  ServiceName - DNS or DN; assumes we can compute domain from service name
//  InstanceName OPTIONAL- DNS name of host for instance of service
//  InstancePort - port number for instance (0 if default)
//  Referrer OPTIONAL- DNS name of host that gave this referral
//  pcSpnLength - in -- max length IN CHARACTERS of principal name;
//                out -- actual
//                Length includes terminator
//  pszSPN - server principal name
//
// If buffer is not large enough, ERROR_BUFFER_OVERFLOW is returned and the
// needed length is returned in pcSpnLength.
//
//

__checkReturn
NTDSAPI
DWORD
WINAPI
DsMakeSpnW(
    __in LPCWSTR ServiceClass,
    __in LPCWSTR ServiceName,
    __in_opt LPCWSTR InstanceName,
    __in USHORT InstancePort,
    __in_opt LPCWSTR Referrer,
    __inout DWORD *pcSpnLength,
    __out_ecount_part_opt(*pcSpnLength, *pcSpnLength) LPWSTR pszSpn
);

__checkReturn
NTDSAPI
DWORD
WINAPI
DsMakeSpnA(
    __in LPCSTR ServiceClass,
    __in LPCSTR ServiceName,
    __in_opt LPCSTR InstanceName,
    __in USHORT InstancePort,
    __in_opt LPCSTR Referrer,
    __inout DWORD *pcSpnLength,
    __out_ecount_part (*pcSpnLength, *pcSpnLength) LPSTR pszSpn
);

#ifdef UNICODE
#define DsMakeSpn DsMakeSpnW
#else
#define DsMakeSpn DsMakeSpnA
#endif

// ==========================================================
// DsGetSPN -- server's call to gets SPNs for a service name by which it is
// known to clients. N.B.: there may be more than one name by which clients
// know it the SPNs are then passed to DsAddAccountSpn to register them in
// the DS
//
//      IN SpnNameType eType,
//      IN LPCTSTR ServiceClass,
// kind of service -- "http", "ldap", "ftp", etc.
//      IN LPCTSTR ServiceName OPTIONAL,
// name of service -- DN or DNS; not needed for host-based
//      IN USHORT InstancePort,
// port number (0 => default) for instances
//      IN USHORT cInstanceNames,
// count of extra instance names and ports (0=>use gethostbyname)
//      IN LPCTSTR InstanceNames[] OPTIONAL,
// extra instance names (not used for host names)
//      IN USHORT InstancePorts[] OPTIONAL,
// extra instance ports (0 => default)
//      IN OUT PULONG pcSpn,    // count of SPNs
//      IN OUT LPTSTR * prpszSPN[]
// a bunch of SPNs for this service; free with DsFreeSpnArray

__checkReturn
NTDSAPI
DWORD
WINAPI
DsGetSpnA(
    __in DS_SPN_NAME_TYPE ServiceType,
    __in LPCSTR ServiceClass,
    __in_opt LPCSTR ServiceName,
    __in USHORT InstancePort,
    __in USHORT cInstanceNames,
    __in_ecount_opt(cInstanceNames) LPCSTR *pInstanceNames,
    __in_opt const USHORT *pInstancePorts,
    __out DWORD *pcSpn,
    __deref_out_ecount (*pcSpn) LPSTR **prpszSpn
    );

__checkReturn
NTDSAPI
DWORD
WINAPI
DsGetSpnW(
    __in DS_SPN_NAME_TYPE ServiceType,
    __in LPCWSTR ServiceClass,
    __in LPCWSTR ServiceName,
    __in USHORT InstancePort,
    __in USHORT cInstanceNames,
    __in_ecount(cInstanceNames) LPCWSTR *pInstanceNames,
    __in_opt const USHORT *pInstancePorts,
    __out DWORD *pcSpn,
    __deref_out_ecount(*pcSpn) LPWSTR **prpszSpn
    );

#ifdef UNICODE
#define DsGetSpn DsGetSpnW
#else
#define DsGetSpn DsGetSpnA
#endif

// ==========================================================
// DsFreeSpnArray() -- Free array returned by DsGetSpn{A,W}

NTDSAPI
void
WINAPI
DsFreeSpnArrayA(
    __in DWORD cSpn,
    __deref_in_ecount(cSpn) LPSTR *rpszSpn
    );

NTDSAPI
void
WINAPI
DsFreeSpnArrayW(
    __in DWORD cSpn,
    __deref_inout_ecount(cSpn) LPWSTR *rpszSpn
    );

#ifdef UNICODE
#define DsFreeSpnArray DsFreeSpnArrayW
#else
#define DsFreeSpnArray DsFreeSpnArrayA
#endif

// ==========================================================
// DsCrackSpn() -- parse an SPN into the ServiceClass,
// ServiceName, and InstanceName (and InstancePort) pieces.
// An SPN is passed in, along with a pointer to the maximum length
// for each piece and a pointer to a buffer where each piece should go.
// On exit, the maximum lengths are updated to the actual length for each piece
// and the buffer contain the appropriate piece. The InstancePort is 0 if not
// present.
//
// DWORD DsCrackSpn(
//      IN LPTSTR pszSPN,               // the SPN to parse
//      IN OUT PUSHORT pcServiceClass,  // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR ServiceClass,       // the ServiceClass part of the SPN
//      IN OUT PUSHORT pcServiceName,   // input -- max length of ServiceName;
//                                         output -- actual length
//      OUT LPCTSTR ServiceName,        // the ServiceName part of the SPN
//      IN OUT PUSHORT pcInstance,      // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR InstanceName,  // the InstanceName part of the SPN
//      OUT PUSHORT InstancePort          // instance port
//
// Note: lengths are in characters; all string lengths include terminators
// All arguments except pszSpn are optional.
//

__checkReturn
NTDSAPI
DWORD
WINAPI
DsCrackSpnA(
    __in LPCSTR pszSpn,
    __inout_opt LPDWORD pcServiceClass,
    __out_ecount_part_opt (*pcServiceClass, *pcServiceClass) LPSTR ServiceClass,
    __inout_opt LPDWORD pcServiceName,
    __out_ecount_part_opt (*pcServiceName, *pcServiceName) LPSTR ServiceName,
    __inout_opt LPDWORD pcInstanceName,
    __out_ecount_part_opt (*pcInstanceName, *pcInstanceName) LPSTR InstanceName,
    __out_opt USHORT *pInstancePort
    );

__checkReturn
NTDSAPI
DWORD
WINAPI
DsCrackSpnW(
    __in LPCWSTR pszSpn,
    __inout_opt DWORD *pcServiceClass,
    __out_ecount_part_opt (*pcServiceClass, *pcServiceClass) LPWSTR S